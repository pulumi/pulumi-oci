// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Oci.ApmSynthetics
{
    /// <summary>
    /// This resource provides the Monitor resource in Oracle Cloud Infrastructure Apm Synthetics service.
    /// 
    /// Creates a new monitor.
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Oci = Pulumi.Oci;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var testMonitor = new Oci.ApmSynthetics.Config("test_monitor", new()
    ///     {
    ///         ApmDomainId = testApmDomain.Id,
    ///         DisplayName = monitorDisplayName,
    ///         MonitorType = monitorMonitorType,
    ///         RepeatIntervalInSeconds = monitorRepeatIntervalInSeconds,
    ///         VantagePoints = new[]
    ///         {
    ///             new Oci.ApmSynthetics.Inputs.ConfigVantagePointArgs
    ///             {
    ///                 Name = monitorVantagePointsName,
    ///                 DisplayName = monitorVantagePointsParamDisplayName,
    ///             },
    ///         },
    ///         AvailabilityConfiguration = new Oci.ApmSynthetics.Inputs.ConfigAvailabilityConfigurationArgs
    ///         {
    ///             MaxAllowedFailuresPerInterval = monitorAvailabilityConfigurationMaxAllowedFailuresPerInterval,
    ///             MinAllowedRunsPerInterval = monitorAvailabilityConfigurationMinAllowedRunsPerInterval,
    ///         },
    ///         BatchIntervalInSeconds = monitorBatchIntervalInSeconds,
    ///         Configuration = new Oci.ApmSynthetics.Inputs.ConfigConfigurationArgs
    ///         {
    ///             ClientCertificateDetails = new Oci.ApmSynthetics.Inputs.ConfigConfigurationClientCertificateDetailsArgs
    ///             {
    ///                 ClientCertificate = new Oci.ApmSynthetics.Inputs.ConfigConfigurationClientCertificateDetailsClientCertificateArgs
    ///                 {
    ///                     Content = monitorConfigurationClientCertificateDetailsClientCertificateContent,
    ///                     FileName = monitorConfigurationClientCertificateDetailsClientCertificateFileName,
    ///                 },
    ///                 PrivateKey = new Oci.ApmSynthetics.Inputs.ConfigConfigurationClientCertificateDetailsPrivateKeyArgs
    ///                 {
    ///                     Content = monitorConfigurationClientCertificateDetailsPrivateKeyContent,
    ///                     FileName = monitorConfigurationClientCertificateDetailsPrivateKeyFileName,
    ///                 },
    ///             },
    ///             ConfigType = monitorConfigurationConfigType,
    ///             DnsConfiguration = new Oci.ApmSynthetics.Inputs.ConfigConfigurationDnsConfigurationArgs
    ///             {
    ///                 IsOverrideDns = monitorConfigurationDnsConfigurationIsOverrideDns,
    ///                 OverrideDnsIp = monitorConfigurationDnsConfigurationOverrideDnsIp,
    ///             },
    ///             IsCertificateValidationEnabled = monitorConfigurationIsCertificateValidationEnabled,
    ///             IsDefaultSnapshotEnabled = monitorConfigurationIsDefaultSnapshotEnabled,
    ///             IsFailureRetried = monitorConfigurationIsFailureRetried,
    ///             IsQueryRecursive = monitorConfigurationIsQueryRecursive,
    ///             IsRedirectionEnabled = monitorConfigurationIsRedirectionEnabled,
    ///             NameServer = monitorConfigurationNameServer,
    ///             NetworkConfiguration = new Oci.ApmSynthetics.Inputs.ConfigConfigurationNetworkConfigurationArgs
    ///             {
    ///                 NumberOfHops = monitorConfigurationNetworkConfigurationNumberOfHops,
    ///                 ProbeMode = monitorConfigurationNetworkConfigurationProbeMode,
    ///                 ProbePerHop = monitorConfigurationNetworkConfigurationProbePerHop,
    ///                 Protocol = monitorConfigurationNetworkConfigurationProtocol,
    ///                 TransmissionRate = monitorConfigurationNetworkConfigurationTransmissionRate,
    ///             },
    ///             Protocol = monitorConfigurationProtocol,
    ///             RecordType = monitorConfigurationRecordType,
    ///             ReqAuthenticationDetails = new Oci.ApmSynthetics.Inputs.ConfigConfigurationReqAuthenticationDetailsArgs
    ///             {
    ///                 AuthHeaders = new[]
    ///                 {
    ///                     new Oci.ApmSynthetics.Inputs.ConfigConfigurationReqAuthenticationDetailsAuthHeaderArgs
    ///                     {
    ///                         HeaderName = monitorConfigurationReqAuthenticationDetailsAuthHeadersHeaderName,
    ///                         HeaderValue = monitorConfigurationReqAuthenticationDetailsAuthHeadersHeaderValue,
    ///                     },
    ///                 },
    ///                 AuthRequestMethod = monitorConfigurationReqAuthenticationDetailsAuthRequestMethod,
    ///                 AuthRequestPostBody = monitorConfigurationReqAuthenticationDetailsAuthRequestPostBody,
    ///                 AuthToken = monitorConfigurationReqAuthenticationDetailsAuthToken,
    ///                 AuthUrl = monitorConfigurationReqAuthenticationDetailsAuthUrl,
    ///                 AuthUserName = testUser.Name,
    ///                 AuthUserPassword = monitorConfigurationReqAuthenticationDetailsAuthUserPassword,
    ///                 OauthScheme = monitorConfigurationReqAuthenticationDetailsOauthScheme,
    ///             },
    ///             ReqAuthenticationScheme = monitorConfigurationReqAuthenticationScheme,
    ///             RequestHeaders = new[]
    ///             {
    ///                 new Oci.ApmSynthetics.Inputs.ConfigConfigurationRequestHeaderArgs
    ///                 {
    ///                     HeaderName = monitorConfigurationRequestHeadersHeaderName,
    ///                     HeaderValue = monitorConfigurationRequestHeadersHeaderValue,
    ///                 },
    ///             },
    ///             RequestMethod = monitorConfigurationRequestMethod,
    ///             RequestPostBody = monitorConfigurationRequestPostBody,
    ///             RequestQueryParams = new[]
    ///             {
    ///                 new Oci.ApmSynthetics.Inputs.ConfigConfigurationRequestQueryParamArgs
    ///                 {
    ///                     ParamName = monitorConfigurationRequestQueryParamsParamName,
    ///                     ParamValue = monitorConfigurationRequestQueryParamsParamValue,
    ///                 },
    ///             },
    ///             VerifyResponseCodes = monitorConfigurationVerifyResponseCodes,
    ///             VerifyResponseContent = monitorConfigurationVerifyResponseContent,
    ///             VerifyTexts = new[]
    ///             {
    ///                 new Oci.ApmSynthetics.Inputs.ConfigConfigurationVerifyTextArgs
    ///                 {
    ///                     Text = monitorConfigurationVerifyTextsText,
    ///                 },
    ///             },
    ///         },
    ///         DefinedTags = 
    ///         {
    ///             { "foo-namespace.bar-key", "value" },
    ///         },
    ///         FreeformTags = 
    ///         {
    ///             { "bar-key", "value" },
    ///         },
    ///         IsRunNow = monitorIsRunNow,
    ///         IsRunOnce = monitorIsRunOnce,
    ///         MaintenanceWindowSchedule = new Oci.ApmSynthetics.Inputs.ConfigMaintenanceWindowScheduleArgs
    ///         {
    ///             TimeEnded = monitorMaintenanceWindowScheduleTimeEnded,
    ///             TimeStarted = monitorMaintenanceWindowScheduleTimeStarted,
    ///         },
    ///         SchedulingPolicy = monitorSchedulingPolicy,
    ///         ScriptId = testScript.Id,
    ///         ScriptParameters = new[]
    ///         {
    ///             new Oci.ApmSynthetics.Inputs.ConfigScriptParameterArgs
    ///             {
    ///                 ParamName = monitorScriptParametersParamName,
    ///                 ParamValue = monitorScriptParametersParamValue,
    ///             },
    ///         },
    ///         Status = monitorStatus,
    ///         Target = monitorTarget,
    ///         TimeoutInSeconds = monitorTimeoutInSeconds,
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// Monitors can be imported using the `id`, e.g.
    /// 
    /// ```sh
    /// $ pulumi import oci:ApmSynthetics/config:Config test_monitor "monitors/{monitorId}/apmDomainId/{apmDomainId}"
    /// ```
    /// </summary>
    [OciResourceType("oci:ApmSynthetics/config:Config")]
    public partial class Config : global::Pulumi.CustomResource
    {
        /// <summary>
        /// (Updatable) The APM domain ID the request is intended for.
        /// </summary>
        [Output("apmDomainId")]
        public Output<string> ApmDomainId { get; private set; } = null!;

        /// <summary>
        /// (Updatable) Monitor availability configuration details.
        /// </summary>
        [Output("availabilityConfiguration")]
        public Output<Outputs.ConfigAvailabilityConfiguration> AvailabilityConfiguration { get; private set; } = null!;

        /// <summary>
        /// (Updatable) Time interval between 2 runs in round robin batch mode (*SchedulingPolicy - BATCHED_ROUND_ROBIN).
        /// </summary>
        [Output("batchIntervalInSeconds")]
        public Output<int> BatchIntervalInSeconds { get; private set; } = null!;

        /// <summary>
        /// (Updatable) Details of monitor configuration.
        /// </summary>
        [Output("configuration")]
        public Output<Outputs.ConfigConfiguration> Configuration { get; private set; } = null!;

        /// <summary>
        /// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        /// </summary>
        [Output("definedTags")]
        public Output<ImmutableDictionary<string, object>> DefinedTags { get; private set; } = null!;

        /// <summary>
        /// (Updatable) Unique name that can be edited. The name should not contain any confidential information.
        /// </summary>
        [Output("displayName")]
        public Output<string> DisplayName { get; private set; } = null!;

        /// <summary>
        /// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        /// </summary>
        [Output("freeformTags")]
        public Output<ImmutableDictionary<string, object>> FreeformTags { get; private set; } = null!;

        /// <summary>
        /// (Updatable) If isRunNow is enabled, then the monitor will run immediately.
        /// </summary>
        [Output("isRunNow")]
        public Output<bool> IsRunNow { get; private set; } = null!;

        /// <summary>
        /// (Updatable) If runOnce is enabled, then the monitor will run once.
        /// </summary>
        [Output("isRunOnce")]
        public Output<bool> IsRunOnce { get; private set; } = null!;

        /// <summary>
        /// (Updatable) Details required to schedule maintenance window.
        /// </summary>
        [Output("maintenanceWindowSchedule")]
        public Output<Outputs.ConfigMaintenanceWindowSchedule> MaintenanceWindowSchedule { get; private set; } = null!;

        /// <summary>
        /// Type of monitor.
        /// </summary>
        [Output("monitorType")]
        public Output<string> MonitorType { get; private set; } = null!;

        /// <summary>
        /// (Updatable) Interval in seconds after the start time when the job should be repeated. Minimum repeatIntervalInSeconds should be 300 seconds for Scripted REST, Scripted Browser and Browser monitors, and 60 seconds for REST monitor.
        /// </summary>
        [Output("repeatIntervalInSeconds")]
        public Output<int> RepeatIntervalInSeconds { get; private set; } = null!;

        /// <summary>
        /// (Updatable) Scheduling policy to decide the distribution of monitor executions on vantage points.
        /// </summary>
        [Output("schedulingPolicy")]
        public Output<string> SchedulingPolicy { get; private set; } = null!;

        /// <summary>
        /// (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the script. scriptId is mandatory for creation of SCRIPTED_BROWSER and SCRIPTED_REST monitor types. For other monitor types, it should be set to null.
        /// </summary>
        [Output("scriptId")]
        public Output<string> ScriptId { get; private set; } = null!;

        /// <summary>
        /// Name of the script.
        /// </summary>
        [Output("scriptName")]
        public Output<string> ScriptName { get; private set; } = null!;

        /// <summary>
        /// (Updatable) List of script parameters in the monitor. This is valid only for SCRIPTED_BROWSER and SCRIPTED_REST monitor types. For other monitor types, it should be set to null. Example: `[{"paramName": "userid", "paramValue":"testuser"}]`
        /// </summary>
        [Output("scriptParameters")]
        public Output<ImmutableArray<Outputs.ConfigScriptParameter>> ScriptParameters { get; private set; } = null!;

        /// <summary>
        /// (Updatable) Enables or disables the monitor.
        /// </summary>
        [Output("status")]
        public Output<string> Status { get; private set; } = null!;

        /// <summary>
        /// (Updatable) Specify the endpoint on which to run the monitor. For BROWSER, REST and NETWORK monitor types, target is mandatory. If target is specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script (specified by scriptId in monitor) against the specified target endpoint. If target is not specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script as it is. For NETWORK monitor with TCP protocol, a port needs to be provided along with target. Example: 192.168.0.1:80
        /// </summary>
        [Output("target")]
        public Output<string> Target { get; private set; } = null!;

        /// <summary>
        /// The time the resource was created, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-12T22:47:12.613Z`
        /// </summary>
        [Output("timeCreated")]
        public Output<string> TimeCreated { get; private set; } = null!;

        /// <summary>
        /// The time the resource was updated, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-13T22:47:12.613Z`
        /// </summary>
        [Output("timeUpdated")]
        public Output<string> TimeUpdated { get; private set; } = null!;

        /// <summary>
        /// (Updatable) Timeout in seconds. If isFailureRetried is true, then timeout cannot be more than 30% of repeatIntervalInSeconds time for monitors. If isFailureRetried is false, then timeout cannot be more than 50% of repeatIntervalInSeconds time for monitors. Also, timeoutInSeconds should be a multiple of 60 for Scripted REST, Scripted Browser and Browser monitors. Monitor will be allowed to run only for timeoutInSeconds time. It would be terminated after that.
        /// </summary>
        [Output("timeoutInSeconds")]
        public Output<int> TimeoutInSeconds { get; private set; } = null!;

        /// <summary>
        /// Number of vantage points where monitor is running.
        /// </summary>
        [Output("vantagePointCount")]
        public Output<int> VantagePointCount { get; private set; } = null!;

        /// <summary>
        /// (Updatable) A list of public and dedicated vantage points from which to execute the monitor. Use /publicVantagePoints to fetch public vantage points, and /dedicatedVantagePoints to fetch dedicated vantage points. 
        /// 
        /// 
        /// ** IMPORTANT **
        /// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        /// </summary>
        [Output("vantagePoints")]
        public Output<ImmutableArray<Outputs.ConfigVantagePoint>> VantagePoints { get; private set; } = null!;


        /// <summary>
        /// Create a Config resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Config(string name, ConfigArgs args, CustomResourceOptions? options = null)
            : base("oci:ApmSynthetics/config:Config", name, args ?? new ConfigArgs(), MakeResourceOptions(options, ""))
        {
        }

        private Config(string name, Input<string> id, ConfigState? state = null, CustomResourceOptions? options = null)
            : base("oci:ApmSynthetics/config:Config", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Config resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Config Get(string name, Input<string> id, ConfigState? state = null, CustomResourceOptions? options = null)
        {
            return new Config(name, id, state, options);
        }
    }

    public sealed class ConfigArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// (Updatable) The APM domain ID the request is intended for.
        /// </summary>
        [Input("apmDomainId", required: true)]
        public Input<string> ApmDomainId { get; set; } = null!;

        /// <summary>
        /// (Updatable) Monitor availability configuration details.
        /// </summary>
        [Input("availabilityConfiguration")]
        public Input<Inputs.ConfigAvailabilityConfigurationArgs>? AvailabilityConfiguration { get; set; }

        /// <summary>
        /// (Updatable) Time interval between 2 runs in round robin batch mode (*SchedulingPolicy - BATCHED_ROUND_ROBIN).
        /// </summary>
        [Input("batchIntervalInSeconds")]
        public Input<int>? BatchIntervalInSeconds { get; set; }

        /// <summary>
        /// (Updatable) Details of monitor configuration.
        /// </summary>
        [Input("configuration")]
        public Input<Inputs.ConfigConfigurationArgs>? Configuration { get; set; }

        [Input("definedTags")]
        private InputMap<object>? _definedTags;

        /// <summary>
        /// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        /// </summary>
        public InputMap<object> DefinedTags
        {
            get => _definedTags ?? (_definedTags = new InputMap<object>());
            set => _definedTags = value;
        }

        /// <summary>
        /// (Updatable) Unique name that can be edited. The name should not contain any confidential information.
        /// </summary>
        [Input("displayName", required: true)]
        public Input<string> DisplayName { get; set; } = null!;

        [Input("freeformTags")]
        private InputMap<object>? _freeformTags;

        /// <summary>
        /// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        /// </summary>
        public InputMap<object> FreeformTags
        {
            get => _freeformTags ?? (_freeformTags = new InputMap<object>());
            set => _freeformTags = value;
        }

        /// <summary>
        /// (Updatable) If isRunNow is enabled, then the monitor will run immediately.
        /// </summary>
        [Input("isRunNow")]
        public Input<bool>? IsRunNow { get; set; }

        /// <summary>
        /// (Updatable) If runOnce is enabled, then the monitor will run once.
        /// </summary>
        [Input("isRunOnce")]
        public Input<bool>? IsRunOnce { get; set; }

        /// <summary>
        /// (Updatable) Details required to schedule maintenance window.
        /// </summary>
        [Input("maintenanceWindowSchedule")]
        public Input<Inputs.ConfigMaintenanceWindowScheduleArgs>? MaintenanceWindowSchedule { get; set; }

        /// <summary>
        /// Type of monitor.
        /// </summary>
        [Input("monitorType", required: true)]
        public Input<string> MonitorType { get; set; } = null!;

        /// <summary>
        /// (Updatable) Interval in seconds after the start time when the job should be repeated. Minimum repeatIntervalInSeconds should be 300 seconds for Scripted REST, Scripted Browser and Browser monitors, and 60 seconds for REST monitor.
        /// </summary>
        [Input("repeatIntervalInSeconds", required: true)]
        public Input<int> RepeatIntervalInSeconds { get; set; } = null!;

        /// <summary>
        /// (Updatable) Scheduling policy to decide the distribution of monitor executions on vantage points.
        /// </summary>
        [Input("schedulingPolicy")]
        public Input<string>? SchedulingPolicy { get; set; }

        /// <summary>
        /// (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the script. scriptId is mandatory for creation of SCRIPTED_BROWSER and SCRIPTED_REST monitor types. For other monitor types, it should be set to null.
        /// </summary>
        [Input("scriptId")]
        public Input<string>? ScriptId { get; set; }

        /// <summary>
        /// Name of the script.
        /// </summary>
        [Input("scriptName")]
        public Input<string>? ScriptName { get; set; }

        [Input("scriptParameters")]
        private InputList<Inputs.ConfigScriptParameterArgs>? _scriptParameters;

        /// <summary>
        /// (Updatable) List of script parameters in the monitor. This is valid only for SCRIPTED_BROWSER and SCRIPTED_REST monitor types. For other monitor types, it should be set to null. Example: `[{"paramName": "userid", "paramValue":"testuser"}]`
        /// </summary>
        public InputList<Inputs.ConfigScriptParameterArgs> ScriptParameters
        {
            get => _scriptParameters ?? (_scriptParameters = new InputList<Inputs.ConfigScriptParameterArgs>());
            set => _scriptParameters = value;
        }

        /// <summary>
        /// (Updatable) Enables or disables the monitor.
        /// </summary>
        [Input("status")]
        public Input<string>? Status { get; set; }

        /// <summary>
        /// (Updatable) Specify the endpoint on which to run the monitor. For BROWSER, REST and NETWORK monitor types, target is mandatory. If target is specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script (specified by scriptId in monitor) against the specified target endpoint. If target is not specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script as it is. For NETWORK monitor with TCP protocol, a port needs to be provided along with target. Example: 192.168.0.1:80
        /// </summary>
        [Input("target")]
        public Input<string>? Target { get; set; }

        /// <summary>
        /// (Updatable) Timeout in seconds. If isFailureRetried is true, then timeout cannot be more than 30% of repeatIntervalInSeconds time for monitors. If isFailureRetried is false, then timeout cannot be more than 50% of repeatIntervalInSeconds time for monitors. Also, timeoutInSeconds should be a multiple of 60 for Scripted REST, Scripted Browser and Browser monitors. Monitor will be allowed to run only for timeoutInSeconds time. It would be terminated after that.
        /// </summary>
        [Input("timeoutInSeconds")]
        public Input<int>? TimeoutInSeconds { get; set; }

        [Input("vantagePoints", required: true)]
        private InputList<Inputs.ConfigVantagePointArgs>? _vantagePoints;

        /// <summary>
        /// (Updatable) A list of public and dedicated vantage points from which to execute the monitor. Use /publicVantagePoints to fetch public vantage points, and /dedicatedVantagePoints to fetch dedicated vantage points. 
        /// 
        /// 
        /// ** IMPORTANT **
        /// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        /// </summary>
        public InputList<Inputs.ConfigVantagePointArgs> VantagePoints
        {
            get => _vantagePoints ?? (_vantagePoints = new InputList<Inputs.ConfigVantagePointArgs>());
            set => _vantagePoints = value;
        }

        public ConfigArgs()
        {
        }
        public static new ConfigArgs Empty => new ConfigArgs();
    }

    public sealed class ConfigState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// (Updatable) The APM domain ID the request is intended for.
        /// </summary>
        [Input("apmDomainId")]
        public Input<string>? ApmDomainId { get; set; }

        /// <summary>
        /// (Updatable) Monitor availability configuration details.
        /// </summary>
        [Input("availabilityConfiguration")]
        public Input<Inputs.ConfigAvailabilityConfigurationGetArgs>? AvailabilityConfiguration { get; set; }

        /// <summary>
        /// (Updatable) Time interval between 2 runs in round robin batch mode (*SchedulingPolicy - BATCHED_ROUND_ROBIN).
        /// </summary>
        [Input("batchIntervalInSeconds")]
        public Input<int>? BatchIntervalInSeconds { get; set; }

        /// <summary>
        /// (Updatable) Details of monitor configuration.
        /// </summary>
        [Input("configuration")]
        public Input<Inputs.ConfigConfigurationGetArgs>? Configuration { get; set; }

        [Input("definedTags")]
        private InputMap<object>? _definedTags;

        /// <summary>
        /// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        /// </summary>
        public InputMap<object> DefinedTags
        {
            get => _definedTags ?? (_definedTags = new InputMap<object>());
            set => _definedTags = value;
        }

        /// <summary>
        /// (Updatable) Unique name that can be edited. The name should not contain any confidential information.
        /// </summary>
        [Input("displayName")]
        public Input<string>? DisplayName { get; set; }

        [Input("freeformTags")]
        private InputMap<object>? _freeformTags;

        /// <summary>
        /// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        /// </summary>
        public InputMap<object> FreeformTags
        {
            get => _freeformTags ?? (_freeformTags = new InputMap<object>());
            set => _freeformTags = value;
        }

        /// <summary>
        /// (Updatable) If isRunNow is enabled, then the monitor will run immediately.
        /// </summary>
        [Input("isRunNow")]
        public Input<bool>? IsRunNow { get; set; }

        /// <summary>
        /// (Updatable) If runOnce is enabled, then the monitor will run once.
        /// </summary>
        [Input("isRunOnce")]
        public Input<bool>? IsRunOnce { get; set; }

        /// <summary>
        /// (Updatable) Details required to schedule maintenance window.
        /// </summary>
        [Input("maintenanceWindowSchedule")]
        public Input<Inputs.ConfigMaintenanceWindowScheduleGetArgs>? MaintenanceWindowSchedule { get; set; }

        /// <summary>
        /// Type of monitor.
        /// </summary>
        [Input("monitorType")]
        public Input<string>? MonitorType { get; set; }

        /// <summary>
        /// (Updatable) Interval in seconds after the start time when the job should be repeated. Minimum repeatIntervalInSeconds should be 300 seconds for Scripted REST, Scripted Browser and Browser monitors, and 60 seconds for REST monitor.
        /// </summary>
        [Input("repeatIntervalInSeconds")]
        public Input<int>? RepeatIntervalInSeconds { get; set; }

        /// <summary>
        /// (Updatable) Scheduling policy to decide the distribution of monitor executions on vantage points.
        /// </summary>
        [Input("schedulingPolicy")]
        public Input<string>? SchedulingPolicy { get; set; }

        /// <summary>
        /// (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the script. scriptId is mandatory for creation of SCRIPTED_BROWSER and SCRIPTED_REST monitor types. For other monitor types, it should be set to null.
        /// </summary>
        [Input("scriptId")]
        public Input<string>? ScriptId { get; set; }

        /// <summary>
        /// Name of the script.
        /// </summary>
        [Input("scriptName")]
        public Input<string>? ScriptName { get; set; }

        [Input("scriptParameters")]
        private InputList<Inputs.ConfigScriptParameterGetArgs>? _scriptParameters;

        /// <summary>
        /// (Updatable) List of script parameters in the monitor. This is valid only for SCRIPTED_BROWSER and SCRIPTED_REST monitor types. For other monitor types, it should be set to null. Example: `[{"paramName": "userid", "paramValue":"testuser"}]`
        /// </summary>
        public InputList<Inputs.ConfigScriptParameterGetArgs> ScriptParameters
        {
            get => _scriptParameters ?? (_scriptParameters = new InputList<Inputs.ConfigScriptParameterGetArgs>());
            set => _scriptParameters = value;
        }

        /// <summary>
        /// (Updatable) Enables or disables the monitor.
        /// </summary>
        [Input("status")]
        public Input<string>? Status { get; set; }

        /// <summary>
        /// (Updatable) Specify the endpoint on which to run the monitor. For BROWSER, REST and NETWORK monitor types, target is mandatory. If target is specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script (specified by scriptId in monitor) against the specified target endpoint. If target is not specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script as it is. For NETWORK monitor with TCP protocol, a port needs to be provided along with target. Example: 192.168.0.1:80
        /// </summary>
        [Input("target")]
        public Input<string>? Target { get; set; }

        /// <summary>
        /// The time the resource was created, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-12T22:47:12.613Z`
        /// </summary>
        [Input("timeCreated")]
        public Input<string>? TimeCreated { get; set; }

        /// <summary>
        /// The time the resource was updated, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-13T22:47:12.613Z`
        /// </summary>
        [Input("timeUpdated")]
        public Input<string>? TimeUpdated { get; set; }

        /// <summary>
        /// (Updatable) Timeout in seconds. If isFailureRetried is true, then timeout cannot be more than 30% of repeatIntervalInSeconds time for monitors. If isFailureRetried is false, then timeout cannot be more than 50% of repeatIntervalInSeconds time for monitors. Also, timeoutInSeconds should be a multiple of 60 for Scripted REST, Scripted Browser and Browser monitors. Monitor will be allowed to run only for timeoutInSeconds time. It would be terminated after that.
        /// </summary>
        [Input("timeoutInSeconds")]
        public Input<int>? TimeoutInSeconds { get; set; }

        /// <summary>
        /// Number of vantage points where monitor is running.
        /// </summary>
        [Input("vantagePointCount")]
        public Input<int>? VantagePointCount { get; set; }

        [Input("vantagePoints")]
        private InputList<Inputs.ConfigVantagePointGetArgs>? _vantagePoints;

        /// <summary>
        /// (Updatable) A list of public and dedicated vantage points from which to execute the monitor. Use /publicVantagePoints to fetch public vantage points, and /dedicatedVantagePoints to fetch dedicated vantage points. 
        /// 
        /// 
        /// ** IMPORTANT **
        /// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        /// </summary>
        public InputList<Inputs.ConfigVantagePointGetArgs> VantagePoints
        {
            get => _vantagePoints ?? (_vantagePoints = new InputList<Inputs.ConfigVantagePointGetArgs>());
            set => _vantagePoints = value;
        }

        public ConfigState()
        {
        }
        public static new ConfigState Empty => new ConfigState();
    }
}
