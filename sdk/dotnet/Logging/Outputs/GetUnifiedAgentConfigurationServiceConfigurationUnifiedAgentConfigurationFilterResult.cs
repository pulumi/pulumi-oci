// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Oci.Logging.Outputs
{

    [OutputType]
    public sealed class GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterResult
    {
        /// <summary>
        /// A list of filtering rules to include logs
        /// </summary>
        public readonly ImmutableArray<Outputs.GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterAllowListResult> AllowLists;
        /// <summary>
        /// Type of the custom filter
        /// </summary>
        public readonly string CustomFilterType;
        /// <summary>
        /// List of custom sections in custom filter
        /// </summary>
        public readonly ImmutableArray<Outputs.GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterCustomSectionResult> CustomSections;
        /// <summary>
        /// A list of filtering rules to reject logs
        /// </summary>
        public readonly ImmutableArray<Outputs.GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterDenyListResult> DenyLists;
        /// <summary>
        /// If true, emit invalid record to @ERROR label. Invalid cases are: 1) key does not exist; 2) the format does not match; or 3) an unexpected error. You can rescue unexpected format logs in the @ERROR lable. If you want to ignore these errors, set this to false.
        /// </summary>
        public readonly bool EmitInvalidRecordToError;
        /// <summary>
        /// Unified schema logging filter type.
        /// </summary>
        public readonly string FilterType;
        /// <summary>
        /// Store the parsed values as a hash value in a field.
        /// </summary>
        public readonly string HashValueField;
        /// <summary>
        /// Store the parsed values with the specified key name prefix.
        /// </summary>
        public readonly string InjectKeyPrefix;
        /// <summary>
        /// If true, automatically casts the field types.
        /// </summary>
        public readonly bool IsAutoTypecastEnabled;
        /// <summary>
        /// If true, it modifies a new empty hash
        /// </summary>
        public readonly bool IsRenewRecordEnabled;
        /// <summary>
        /// When set to true, the full Ruby syntax is enabled in the ${} expression.
        /// </summary>
        public readonly bool IsRubyEnabled;
        /// <summary>
        /// A list of keys to keep. Only relevant if isRenewRecordEnabled is set to true
        /// </summary>
        public readonly ImmutableArray<string> KeepKeys;
        /// <summary>
        /// The field name in the record to parse.
        /// </summary>
        public readonly string KeyName;
        /// <summary>
        /// The name key to tag this Grok pattern.
        /// </summary>
        public readonly string Name;
        /// <summary>
        /// Parameters of the custom filter
        /// </summary>
        public readonly ImmutableDictionary<string, object> Params;
        /// <summary>
        /// Source parser object.
        /// </summary>
        public readonly ImmutableArray<Outputs.GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserResult> Parsers;
        /// <summary>
        /// Add new key-value pairs in logs
        /// </summary>
        public readonly ImmutableArray<Outputs.GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterRecordListResult> RecordLists;
        /// <summary>
        /// If true, remove the keyName field when parsing is succeeded.
        /// </summary>
        public readonly bool RemoveKeyNameField;
        /// <summary>
        /// A list of keys to delete
        /// </summary>
        public readonly ImmutableArray<string> RemoveKeys;
        /// <summary>
        /// Overwrites the time of logs with this value, this value must be a Unix timestamp.
        /// </summary>
        public readonly string RenewTimeKey;
        /// <summary>
        /// If true, the invalid string is replaced with safe characters and is re-parsed.
        /// </summary>
        public readonly bool ReplaceInvalidSequence;
        /// <summary>
        /// If true, keep the original key-value pair in the parsed result.
        /// </summary>
        public readonly bool ReserveData;
        /// <summary>
        /// If true, keep the original event time in the parsed result.
        /// </summary>
        public readonly bool ReserveTime;

        [OutputConstructor]
        private GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterResult(
            ImmutableArray<Outputs.GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterAllowListResult> allowLists,

            string customFilterType,

            ImmutableArray<Outputs.GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterCustomSectionResult> customSections,

            ImmutableArray<Outputs.GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterDenyListResult> denyLists,

            bool emitInvalidRecordToError,

            string filterType,

            string hashValueField,

            string injectKeyPrefix,

            bool isAutoTypecastEnabled,

            bool isRenewRecordEnabled,

            bool isRubyEnabled,

            ImmutableArray<string> keepKeys,

            string keyName,

            string name,

            ImmutableDictionary<string, object> @params,

            ImmutableArray<Outputs.GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserResult> parsers,

            ImmutableArray<Outputs.GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterRecordListResult> recordLists,

            bool removeKeyNameField,

            ImmutableArray<string> removeKeys,

            string renewTimeKey,

            bool replaceInvalidSequence,

            bool reserveData,

            bool reserveTime)
        {
            AllowLists = allowLists;
            CustomFilterType = customFilterType;
            CustomSections = customSections;
            DenyLists = denyLists;
            EmitInvalidRecordToError = emitInvalidRecordToError;
            FilterType = filterType;
            HashValueField = hashValueField;
            InjectKeyPrefix = injectKeyPrefix;
            IsAutoTypecastEnabled = isAutoTypecastEnabled;
            IsRenewRecordEnabled = isRenewRecordEnabled;
            IsRubyEnabled = isRubyEnabled;
            KeepKeys = keepKeys;
            KeyName = keyName;
            Name = name;
            Params = @params;
            Parsers = parsers;
            RecordLists = recordLists;
            RemoveKeyNameField = removeKeyNameField;
            RemoveKeys = removeKeys;
            RenewTimeKey = renewTimeKey;
            ReplaceInvalidSequence = replaceInvalidSequence;
            ReserveData = reserveData;
            ReserveTime = reserveTime;
        }
    }
}
