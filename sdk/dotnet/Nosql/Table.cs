// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Oci.Nosql
{
    /// <summary>
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Oci = Pulumi.Oci;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var testTable = new Oci.Nosql.Table("test_table", new()
    ///     {
    ///         CompartmentId = compartmentId,
    ///         DdlStatement = tableDdlStatement,
    ///         Name = tableName,
    ///         DefinedTags = tableDefinedTags,
    ///         FreeformTags = 
    ///         {
    ///             { "bar-key", "value" },
    ///         },
    ///         IsAutoReclaimable = tableIsAutoReclaimable,
    ///         TableLimits = new Oci.Nosql.Inputs.TableTableLimitsArgs
    ///         {
    ///             MaxReadUnits = tableTableLimitsMaxReadUnits,
    ///             MaxStorageInGbs = tableTableLimitsMaxStorageInGbs,
    ///             MaxWriteUnits = tableTableLimitsMaxWriteUnits,
    ///             CapacityMode = tableTableLimitsCapacityMode,
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// Tables can be imported using the `id`, e.g.
    /// 
    /// ```sh
    /// $ pulumi import oci:Nosql/table:Table test_table "id"
    /// ```
    /// </summary>
    [OciResourceType("oci:Nosql/table:Table")]
    public partial class Table : global::Pulumi.CustomResource
    {
        /// <summary>
        /// (Updatable) Compartment Identifier.
        /// </summary>
        [Output("compartmentId")]
        public Output<string> CompartmentId { get; private set; } = null!;

        /// <summary>
        /// (Updatable) CREATE TABLE DDL statement. While updating an existing table, note that the column order should not be changed, and new columns can only be appended at the end of the table.
        /// </summary>
        [Output("ddlStatement")]
        public Output<string> DdlStatement { get; private set; } = null!;

        /// <summary>
        /// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace.  Example: `{"foo-namespace": {"bar-key": "value"}}`
        /// </summary>
        [Output("definedTags")]
        public Output<ImmutableDictionary<string, string>> DefinedTags { get; private set; } = null!;

        /// <summary>
        /// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        /// </summary>
        [Output("freeformTags")]
        public Output<ImmutableDictionary<string, string>> FreeformTags { get; private set; } = null!;

        /// <summary>
        /// True if table can be reclaimed after an idle period.
        /// </summary>
        [Output("isAutoReclaimable")]
        public Output<bool> IsAutoReclaimable { get; private set; } = null!;

        /// <summary>
        /// True if this table is currently a member of a replication set.
        /// </summary>
        [Output("isMultiRegion")]
        public Output<bool> IsMultiRegion { get; private set; } = null!;

        /// <summary>
        /// A message describing the current state in more detail.
        /// </summary>
        [Output("lifecycleDetails")]
        public Output<string> LifecycleDetails { get; private set; } = null!;

        /// <summary>
        /// If this table is in a replication set, this value represents the progress of the initialization of the replica's data.  A value of 100 indicates that initialization has completed.
        /// </summary>
        [Output("localReplicaInitializationInPercent")]
        public Output<int> LocalReplicaInitializationInPercent { get; private set; } = null!;

        /// <summary>
        /// Table name.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// An array of Replica listing this table's replicas, if any
        /// </summary>
        [Output("replicas")]
        public Output<ImmutableArray<Outputs.TableReplica>> Replicas { get; private set; } = null!;

        /// <summary>
        /// The current state of this table's schema. Available states are MUTABLE - The schema can be changed. The table is not eligible for replication. FROZEN - The schema is immutable. The table is eligible for replication.
        /// </summary>
        [Output("schemaState")]
        public Output<string> SchemaState { get; private set; } = null!;

        /// <summary>
        /// The table schema information as a JSON object.
        /// </summary>
        [Output("schemas")]
        public Output<ImmutableArray<Outputs.TableSchema>> Schemas { get; private set; } = null!;

        /// <summary>
        /// The state of a table.
        /// </summary>
        [Output("state")]
        public Output<string> State { get; private set; } = null!;

        /// <summary>
        /// Read-only system tag. These predefined keys are scoped to namespaces.  At present the only supported namespace is `"orcl-cloud"`; and the only key in that namespace is `"free-tier-retained"`. Example: `{"orcl-cloud"": {"free-tier-retained": "true"}}`
        /// </summary>
        [Output("systemTags")]
        public Output<ImmutableDictionary<string, string>> SystemTags { get; private set; } = null!;

        /// <summary>
        /// (Updatable) Throughput and storage limits configuration of a table. It is required for top level table, must be null for child table as child table shares its top parent table's limits.
        /// </summary>
        [Output("tableLimits")]
        public Output<Outputs.TableTableLimits> TableLimits { get; private set; } = null!;

        /// <summary>
        /// The time the the table was created. An RFC3339 formatted datetime string.
        /// </summary>
        [Output("timeCreated")]
        public Output<string> TimeCreated { get; private set; } = null!;

        /// <summary>
        /// If lifecycleState is INACTIVE, indicates when this table will be automatically removed. An RFC3339 formatted datetime string.
        /// </summary>
        [Output("timeOfExpiration")]
        public Output<string> TimeOfExpiration { get; private set; } = null!;

        /// <summary>
        /// The time the the table's metadata was last updated. An RFC3339 formatted datetime string.
        /// </summary>
        [Output("timeUpdated")]
        public Output<string> TimeUpdated { get; private set; } = null!;


        /// <summary>
        /// Create a Table resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Table(string name, TableArgs args, CustomResourceOptions? options = null)
            : base("oci:Nosql/table:Table", name, args ?? new TableArgs(), MakeResourceOptions(options, ""))
        {
        }

        private Table(string name, Input<string> id, TableState? state = null, CustomResourceOptions? options = null)
            : base("oci:Nosql/table:Table", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Table resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Table Get(string name, Input<string> id, TableState? state = null, CustomResourceOptions? options = null)
        {
            return new Table(name, id, state, options);
        }
    }

    public sealed class TableArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// (Updatable) Compartment Identifier.
        /// </summary>
        [Input("compartmentId", required: true)]
        public Input<string> CompartmentId { get; set; } = null!;

        /// <summary>
        /// (Updatable) CREATE TABLE DDL statement. While updating an existing table, note that the column order should not be changed, and new columns can only be appended at the end of the table.
        /// </summary>
        [Input("ddlStatement", required: true)]
        public Input<string> DdlStatement { get; set; } = null!;

        [Input("definedTags")]
        private InputMap<string>? _definedTags;

        /// <summary>
        /// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace.  Example: `{"foo-namespace": {"bar-key": "value"}}`
        /// </summary>
        public InputMap<string> DefinedTags
        {
            get => _definedTags ?? (_definedTags = new InputMap<string>());
            set => _definedTags = value;
        }

        [Input("freeformTags")]
        private InputMap<string>? _freeformTags;

        /// <summary>
        /// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        /// </summary>
        public InputMap<string> FreeformTags
        {
            get => _freeformTags ?? (_freeformTags = new InputMap<string>());
            set => _freeformTags = value;
        }

        /// <summary>
        /// True if table can be reclaimed after an idle period.
        /// </summary>
        [Input("isAutoReclaimable")]
        public Input<bool>? IsAutoReclaimable { get; set; }

        /// <summary>
        /// Table name.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// (Updatable) Throughput and storage limits configuration of a table. It is required for top level table, must be null for child table as child table shares its top parent table's limits.
        /// </summary>
        [Input("tableLimits")]
        public Input<Inputs.TableTableLimitsArgs>? TableLimits { get; set; }

        public TableArgs()
        {
        }
        public static new TableArgs Empty => new TableArgs();
    }

    public sealed class TableState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// (Updatable) Compartment Identifier.
        /// </summary>
        [Input("compartmentId")]
        public Input<string>? CompartmentId { get; set; }

        /// <summary>
        /// (Updatable) CREATE TABLE DDL statement. While updating an existing table, note that the column order should not be changed, and new columns can only be appended at the end of the table.
        /// </summary>
        [Input("ddlStatement")]
        public Input<string>? DdlStatement { get; set; }

        [Input("definedTags")]
        private InputMap<string>? _definedTags;

        /// <summary>
        /// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace.  Example: `{"foo-namespace": {"bar-key": "value"}}`
        /// </summary>
        public InputMap<string> DefinedTags
        {
            get => _definedTags ?? (_definedTags = new InputMap<string>());
            set => _definedTags = value;
        }

        [Input("freeformTags")]
        private InputMap<string>? _freeformTags;

        /// <summary>
        /// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        /// </summary>
        public InputMap<string> FreeformTags
        {
            get => _freeformTags ?? (_freeformTags = new InputMap<string>());
            set => _freeformTags = value;
        }

        /// <summary>
        /// True if table can be reclaimed after an idle period.
        /// </summary>
        [Input("isAutoReclaimable")]
        public Input<bool>? IsAutoReclaimable { get; set; }

        /// <summary>
        /// True if this table is currently a member of a replication set.
        /// </summary>
        [Input("isMultiRegion")]
        public Input<bool>? IsMultiRegion { get; set; }

        /// <summary>
        /// A message describing the current state in more detail.
        /// </summary>
        [Input("lifecycleDetails")]
        public Input<string>? LifecycleDetails { get; set; }

        /// <summary>
        /// If this table is in a replication set, this value represents the progress of the initialization of the replica's data.  A value of 100 indicates that initialization has completed.
        /// </summary>
        [Input("localReplicaInitializationInPercent")]
        public Input<int>? LocalReplicaInitializationInPercent { get; set; }

        /// <summary>
        /// Table name.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("replicas")]
        private InputList<Inputs.TableReplicaGetArgs>? _replicas;

        /// <summary>
        /// An array of Replica listing this table's replicas, if any
        /// </summary>
        public InputList<Inputs.TableReplicaGetArgs> Replicas
        {
            get => _replicas ?? (_replicas = new InputList<Inputs.TableReplicaGetArgs>());
            set => _replicas = value;
        }

        /// <summary>
        /// The current state of this table's schema. Available states are MUTABLE - The schema can be changed. The table is not eligible for replication. FROZEN - The schema is immutable. The table is eligible for replication.
        /// </summary>
        [Input("schemaState")]
        public Input<string>? SchemaState { get; set; }

        [Input("schemas")]
        private InputList<Inputs.TableSchemaGetArgs>? _schemas;

        /// <summary>
        /// The table schema information as a JSON object.
        /// </summary>
        public InputList<Inputs.TableSchemaGetArgs> Schemas
        {
            get => _schemas ?? (_schemas = new InputList<Inputs.TableSchemaGetArgs>());
            set => _schemas = value;
        }

        /// <summary>
        /// The state of a table.
        /// </summary>
        [Input("state")]
        public Input<string>? State { get; set; }

        [Input("systemTags")]
        private InputMap<string>? _systemTags;

        /// <summary>
        /// Read-only system tag. These predefined keys are scoped to namespaces.  At present the only supported namespace is `"orcl-cloud"`; and the only key in that namespace is `"free-tier-retained"`. Example: `{"orcl-cloud"": {"free-tier-retained": "true"}}`
        /// </summary>
        public InputMap<string> SystemTags
        {
            get => _systemTags ?? (_systemTags = new InputMap<string>());
            set => _systemTags = value;
        }

        /// <summary>
        /// (Updatable) Throughput and storage limits configuration of a table. It is required for top level table, must be null for child table as child table shares its top parent table's limits.
        /// </summary>
        [Input("tableLimits")]
        public Input<Inputs.TableTableLimitsGetArgs>? TableLimits { get; set; }

        /// <summary>
        /// The time the the table was created. An RFC3339 formatted datetime string.
        /// </summary>
        [Input("timeCreated")]
        public Input<string>? TimeCreated { get; set; }

        /// <summary>
        /// If lifecycleState is INACTIVE, indicates when this table will be automatically removed. An RFC3339 formatted datetime string.
        /// </summary>
        [Input("timeOfExpiration")]
        public Input<string>? TimeOfExpiration { get; set; }

        /// <summary>
        /// The time the the table's metadata was last updated. An RFC3339 formatted datetime string.
        /// </summary>
        [Input("timeUpdated")]
        public Input<string>? TimeUpdated { get; set; }

        public TableState()
        {
        }
        public static new TableState Empty => new TableState();
    }
}
