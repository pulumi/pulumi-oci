// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package apmsynthetics

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-oci/sdk/go/oci/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// This resource provides the Monitor resource in Oracle Cloud Infrastructure Apm Synthetics service.
//
// Creates a new monitor.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-oci/sdk/go/oci/ApmSynthetics"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := ApmSynthetics.NewConfig(ctx, "test_monitor", &ApmSynthetics.ConfigArgs{
//				ApmDomainId:             pulumi.Any(testApmDomain.Id),
//				DisplayName:             pulumi.Any(monitorDisplayName),
//				MonitorType:             pulumi.Any(monitorMonitorType),
//				RepeatIntervalInSeconds: pulumi.Any(monitorRepeatIntervalInSeconds),
//				VantagePoints: apmsynthetics.ConfigVantagePointArray{
//					&apmsynthetics.ConfigVantagePointArgs{
//						Name:        pulumi.Any(monitorVantagePointsName),
//						DisplayName: pulumi.Any(monitorVantagePointsParamDisplayName),
//					},
//				},
//				AvailabilityConfiguration: &apmsynthetics.ConfigAvailabilityConfigurationArgs{
//					MaxAllowedFailuresPerInterval: pulumi.Any(monitorAvailabilityConfigurationMaxAllowedFailuresPerInterval),
//					MinAllowedRunsPerInterval:     pulumi.Any(monitorAvailabilityConfigurationMinAllowedRunsPerInterval),
//				},
//				BatchIntervalInSeconds: pulumi.Any(monitorBatchIntervalInSeconds),
//				Configuration: &apmsynthetics.ConfigConfigurationArgs{
//					ClientCertificateDetails: &apmsynthetics.ConfigConfigurationClientCertificateDetailsArgs{
//						ClientCertificate: &apmsynthetics.ConfigConfigurationClientCertificateDetailsClientCertificateArgs{
//							Content:  pulumi.Any(monitorConfigurationClientCertificateDetailsClientCertificateContent),
//							FileName: pulumi.Any(monitorConfigurationClientCertificateDetailsClientCertificateFileName),
//						},
//						PrivateKey: &apmsynthetics.ConfigConfigurationClientCertificateDetailsPrivateKeyArgs{
//							Content:  pulumi.Any(monitorConfigurationClientCertificateDetailsPrivateKeyContent),
//							FileName: pulumi.Any(monitorConfigurationClientCertificateDetailsPrivateKeyFileName),
//						},
//					},
//					ConfigType: pulumi.Any(monitorConfigurationConfigType),
//					DnsConfiguration: &apmsynthetics.ConfigConfigurationDnsConfigurationArgs{
//						IsOverrideDns: pulumi.Any(monitorConfigurationDnsConfigurationIsOverrideDns),
//						OverrideDnsIp: pulumi.Any(monitorConfigurationDnsConfigurationOverrideDnsIp),
//					},
//					IsCertificateValidationEnabled: pulumi.Any(monitorConfigurationIsCertificateValidationEnabled),
//					IsDefaultSnapshotEnabled:       pulumi.Any(monitorConfigurationIsDefaultSnapshotEnabled),
//					IsFailureRetried:               pulumi.Any(monitorConfigurationIsFailureRetried),
//					IsQueryRecursive:               pulumi.Any(monitorConfigurationIsQueryRecursive),
//					IsRedirectionEnabled:           pulumi.Any(monitorConfigurationIsRedirectionEnabled),
//					NameServer:                     pulumi.Any(monitorConfigurationNameServer),
//					NetworkConfiguration: &apmsynthetics.ConfigConfigurationNetworkConfigurationArgs{
//						NumberOfHops:     pulumi.Any(monitorConfigurationNetworkConfigurationNumberOfHops),
//						ProbeMode:        pulumi.Any(monitorConfigurationNetworkConfigurationProbeMode),
//						ProbePerHop:      pulumi.Any(monitorConfigurationNetworkConfigurationProbePerHop),
//						Protocol:         pulumi.Any(monitorConfigurationNetworkConfigurationProtocol),
//						TransmissionRate: pulumi.Any(monitorConfigurationNetworkConfigurationTransmissionRate),
//					},
//					Protocol:   pulumi.Any(monitorConfigurationProtocol),
//					RecordType: pulumi.Any(monitorConfigurationRecordType),
//					ReqAuthenticationDetails: &apmsynthetics.ConfigConfigurationReqAuthenticationDetailsArgs{
//						AuthHeaders: apmsynthetics.ConfigConfigurationReqAuthenticationDetailsAuthHeaderArray{
//							&apmsynthetics.ConfigConfigurationReqAuthenticationDetailsAuthHeaderArgs{
//								HeaderName:  pulumi.Any(monitorConfigurationReqAuthenticationDetailsAuthHeadersHeaderName),
//								HeaderValue: pulumi.Any(monitorConfigurationReqAuthenticationDetailsAuthHeadersHeaderValue),
//							},
//						},
//						AuthRequestMethod:   pulumi.Any(monitorConfigurationReqAuthenticationDetailsAuthRequestMethod),
//						AuthRequestPostBody: pulumi.Any(monitorConfigurationReqAuthenticationDetailsAuthRequestPostBody),
//						AuthToken:           pulumi.Any(monitorConfigurationReqAuthenticationDetailsAuthToken),
//						AuthUrl:             pulumi.Any(monitorConfigurationReqAuthenticationDetailsAuthUrl),
//						AuthUserName:        pulumi.Any(testUser.Name),
//						AuthUserPassword:    pulumi.Any(monitorConfigurationReqAuthenticationDetailsAuthUserPassword),
//						OauthScheme:         pulumi.Any(monitorConfigurationReqAuthenticationDetailsOauthScheme),
//					},
//					ReqAuthenticationScheme: pulumi.Any(monitorConfigurationReqAuthenticationScheme),
//					RequestHeaders: apmsynthetics.ConfigConfigurationRequestHeaderArray{
//						&apmsynthetics.ConfigConfigurationRequestHeaderArgs{
//							HeaderName:  pulumi.Any(monitorConfigurationRequestHeadersHeaderName),
//							HeaderValue: pulumi.Any(monitorConfigurationRequestHeadersHeaderValue),
//						},
//					},
//					RequestMethod:   pulumi.Any(monitorConfigurationRequestMethod),
//					RequestPostBody: pulumi.Any(monitorConfigurationRequestPostBody),
//					RequestQueryParams: apmsynthetics.ConfigConfigurationRequestQueryParamArray{
//						&apmsynthetics.ConfigConfigurationRequestQueryParamArgs{
//							ParamName:  pulumi.Any(monitorConfigurationRequestQueryParamsParamName),
//							ParamValue: pulumi.Any(monitorConfigurationRequestQueryParamsParamValue),
//						},
//					},
//					VerifyResponseCodes:   pulumi.Any(monitorConfigurationVerifyResponseCodes),
//					VerifyResponseContent: pulumi.Any(monitorConfigurationVerifyResponseContent),
//					VerifyTexts: apmsynthetics.ConfigConfigurationVerifyTextArray{
//						&apmsynthetics.ConfigConfigurationVerifyTextArgs{
//							Text: pulumi.Any(monitorConfigurationVerifyTextsText),
//						},
//					},
//				},
//				DefinedTags: pulumi.Map{
//					"foo-namespace.bar-key": pulumi.Any("value"),
//				},
//				FreeformTags: pulumi.Map{
//					"bar-key": pulumi.Any("value"),
//				},
//				IsRunNow:  pulumi.Any(monitorIsRunNow),
//				IsRunOnce: pulumi.Any(monitorIsRunOnce),
//				MaintenanceWindowSchedule: &apmsynthetics.ConfigMaintenanceWindowScheduleArgs{
//					TimeEnded:   pulumi.Any(monitorMaintenanceWindowScheduleTimeEnded),
//					TimeStarted: pulumi.Any(monitorMaintenanceWindowScheduleTimeStarted),
//				},
//				SchedulingPolicy: pulumi.Any(monitorSchedulingPolicy),
//				ScriptId:         pulumi.Any(testScript.Id),
//				ScriptParameters: apmsynthetics.ConfigScriptParameterArray{
//					&apmsynthetics.ConfigScriptParameterArgs{
//						ParamName:  pulumi.Any(monitorScriptParametersParamName),
//						ParamValue: pulumi.Any(monitorScriptParametersParamValue),
//					},
//				},
//				Status:           pulumi.Any(monitorStatus),
//				Target:           pulumi.Any(monitorTarget),
//				TimeoutInSeconds: pulumi.Any(monitorTimeoutInSeconds),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Monitors can be imported using the `id`, e.g.
//
// ```sh
// $ pulumi import oci:ApmSynthetics/config:Config test_monitor "monitors/{monitorId}/apmDomainId/{apmDomainId}"
// ```
type Config struct {
	pulumi.CustomResourceState

	// (Updatable) The APM domain ID the request is intended for.
	ApmDomainId pulumi.StringOutput `pulumi:"apmDomainId"`
	// (Updatable) Monitor availability configuration details.
	AvailabilityConfiguration ConfigAvailabilityConfigurationOutput `pulumi:"availabilityConfiguration"`
	// (Updatable) Time interval between 2 runs in round robin batch mode (*SchedulingPolicy - BATCHED_ROUND_ROBIN).
	BatchIntervalInSeconds pulumi.IntOutput `pulumi:"batchIntervalInSeconds"`
	// (Updatable) Details of monitor configuration.
	Configuration ConfigConfigurationOutput `pulumi:"configuration"`
	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
	DefinedTags pulumi.MapOutput `pulumi:"definedTags"`
	// (Updatable) Unique name that can be edited. The name should not contain any confidential information.
	DisplayName pulumi.StringOutput `pulumi:"displayName"`
	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
	FreeformTags pulumi.MapOutput `pulumi:"freeformTags"`
	// (Updatable) If isRunNow is enabled, then the monitor will run immediately.
	IsRunNow pulumi.BoolOutput `pulumi:"isRunNow"`
	// (Updatable) If runOnce is enabled, then the monitor will run once.
	IsRunOnce pulumi.BoolOutput `pulumi:"isRunOnce"`
	// (Updatable) Details required to schedule maintenance window.
	MaintenanceWindowSchedule ConfigMaintenanceWindowScheduleOutput `pulumi:"maintenanceWindowSchedule"`
	// Type of monitor.
	MonitorType pulumi.StringOutput `pulumi:"monitorType"`
	// (Updatable) Interval in seconds after the start time when the job should be repeated. Minimum repeatIntervalInSeconds should be 300 seconds for Scripted REST, Scripted Browser and Browser monitors, and 60 seconds for REST monitor.
	RepeatIntervalInSeconds pulumi.IntOutput `pulumi:"repeatIntervalInSeconds"`
	// (Updatable) Scheduling policy to decide the distribution of monitor executions on vantage points.
	SchedulingPolicy pulumi.StringOutput `pulumi:"schedulingPolicy"`
	// (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the script. scriptId is mandatory for creation of SCRIPTED_BROWSER and SCRIPTED_REST monitor types. For other monitor types, it should be set to null.
	ScriptId pulumi.StringOutput `pulumi:"scriptId"`
	// Name of the script.
	ScriptName pulumi.StringOutput `pulumi:"scriptName"`
	// (Updatable) List of script parameters in the monitor. This is valid only for SCRIPTED_BROWSER and SCRIPTED_REST monitor types. For other monitor types, it should be set to null. Example: `[{"paramName": "userid", "paramValue":"testuser"}]`
	ScriptParameters ConfigScriptParameterArrayOutput `pulumi:"scriptParameters"`
	// (Updatable) Enables or disables the monitor.
	Status pulumi.StringOutput `pulumi:"status"`
	// (Updatable) Specify the endpoint on which to run the monitor. For BROWSER, REST and NETWORK monitor types, target is mandatory. If target is specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script (specified by scriptId in monitor) against the specified target endpoint. If target is not specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script as it is. For NETWORK monitor with TCP protocol, a port needs to be provided along with target. Example: 192.168.0.1:80
	Target pulumi.StringOutput `pulumi:"target"`
	// The time the resource was created, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-12T22:47:12.613Z`
	TimeCreated pulumi.StringOutput `pulumi:"timeCreated"`
	// The time the resource was updated, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-13T22:47:12.613Z`
	TimeUpdated pulumi.StringOutput `pulumi:"timeUpdated"`
	// (Updatable) Timeout in seconds. If isFailureRetried is true, then timeout cannot be more than 30% of repeatIntervalInSeconds time for monitors. If isFailureRetried is false, then timeout cannot be more than 50% of repeatIntervalInSeconds time for monitors. Also, timeoutInSeconds should be a multiple of 60 for Scripted REST, Scripted Browser and Browser monitors. Monitor will be allowed to run only for timeoutInSeconds time. It would be terminated after that.
	TimeoutInSeconds pulumi.IntOutput `pulumi:"timeoutInSeconds"`
	// Number of vantage points where monitor is running.
	VantagePointCount pulumi.IntOutput `pulumi:"vantagePointCount"`
	// (Updatable) A list of public and dedicated vantage points from which to execute the monitor. Use /publicVantagePoints to fetch public vantage points, and /dedicatedVantagePoints to fetch dedicated vantage points.
	//
	// ** IMPORTANT **
	// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
	VantagePoints ConfigVantagePointArrayOutput `pulumi:"vantagePoints"`
}

// NewConfig registers a new resource with the given unique name, arguments, and options.
func NewConfig(ctx *pulumi.Context,
	name string, args *ConfigArgs, opts ...pulumi.ResourceOption) (*Config, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ApmDomainId == nil {
		return nil, errors.New("invalid value for required argument 'ApmDomainId'")
	}
	if args.DisplayName == nil {
		return nil, errors.New("invalid value for required argument 'DisplayName'")
	}
	if args.MonitorType == nil {
		return nil, errors.New("invalid value for required argument 'MonitorType'")
	}
	if args.RepeatIntervalInSeconds == nil {
		return nil, errors.New("invalid value for required argument 'RepeatIntervalInSeconds'")
	}
	if args.VantagePoints == nil {
		return nil, errors.New("invalid value for required argument 'VantagePoints'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Config
	err := ctx.RegisterResource("oci:ApmSynthetics/config:Config", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetConfig gets an existing Config resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetConfig(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ConfigState, opts ...pulumi.ResourceOption) (*Config, error) {
	var resource Config
	err := ctx.ReadResource("oci:ApmSynthetics/config:Config", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Config resources.
type configState struct {
	// (Updatable) The APM domain ID the request is intended for.
	ApmDomainId *string `pulumi:"apmDomainId"`
	// (Updatable) Monitor availability configuration details.
	AvailabilityConfiguration *ConfigAvailabilityConfiguration `pulumi:"availabilityConfiguration"`
	// (Updatable) Time interval between 2 runs in round robin batch mode (*SchedulingPolicy - BATCHED_ROUND_ROBIN).
	BatchIntervalInSeconds *int `pulumi:"batchIntervalInSeconds"`
	// (Updatable) Details of monitor configuration.
	Configuration *ConfigConfiguration `pulumi:"configuration"`
	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
	DefinedTags map[string]interface{} `pulumi:"definedTags"`
	// (Updatable) Unique name that can be edited. The name should not contain any confidential information.
	DisplayName *string `pulumi:"displayName"`
	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
	FreeformTags map[string]interface{} `pulumi:"freeformTags"`
	// (Updatable) If isRunNow is enabled, then the monitor will run immediately.
	IsRunNow *bool `pulumi:"isRunNow"`
	// (Updatable) If runOnce is enabled, then the monitor will run once.
	IsRunOnce *bool `pulumi:"isRunOnce"`
	// (Updatable) Details required to schedule maintenance window.
	MaintenanceWindowSchedule *ConfigMaintenanceWindowSchedule `pulumi:"maintenanceWindowSchedule"`
	// Type of monitor.
	MonitorType *string `pulumi:"monitorType"`
	// (Updatable) Interval in seconds after the start time when the job should be repeated. Minimum repeatIntervalInSeconds should be 300 seconds for Scripted REST, Scripted Browser and Browser monitors, and 60 seconds for REST monitor.
	RepeatIntervalInSeconds *int `pulumi:"repeatIntervalInSeconds"`
	// (Updatable) Scheduling policy to decide the distribution of monitor executions on vantage points.
	SchedulingPolicy *string `pulumi:"schedulingPolicy"`
	// (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the script. scriptId is mandatory for creation of SCRIPTED_BROWSER and SCRIPTED_REST monitor types. For other monitor types, it should be set to null.
	ScriptId *string `pulumi:"scriptId"`
	// Name of the script.
	ScriptName *string `pulumi:"scriptName"`
	// (Updatable) List of script parameters in the monitor. This is valid only for SCRIPTED_BROWSER and SCRIPTED_REST monitor types. For other monitor types, it should be set to null. Example: `[{"paramName": "userid", "paramValue":"testuser"}]`
	ScriptParameters []ConfigScriptParameter `pulumi:"scriptParameters"`
	// (Updatable) Enables or disables the monitor.
	Status *string `pulumi:"status"`
	// (Updatable) Specify the endpoint on which to run the monitor. For BROWSER, REST and NETWORK monitor types, target is mandatory. If target is specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script (specified by scriptId in monitor) against the specified target endpoint. If target is not specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script as it is. For NETWORK monitor with TCP protocol, a port needs to be provided along with target. Example: 192.168.0.1:80
	Target *string `pulumi:"target"`
	// The time the resource was created, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-12T22:47:12.613Z`
	TimeCreated *string `pulumi:"timeCreated"`
	// The time the resource was updated, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-13T22:47:12.613Z`
	TimeUpdated *string `pulumi:"timeUpdated"`
	// (Updatable) Timeout in seconds. If isFailureRetried is true, then timeout cannot be more than 30% of repeatIntervalInSeconds time for monitors. If isFailureRetried is false, then timeout cannot be more than 50% of repeatIntervalInSeconds time for monitors. Also, timeoutInSeconds should be a multiple of 60 for Scripted REST, Scripted Browser and Browser monitors. Monitor will be allowed to run only for timeoutInSeconds time. It would be terminated after that.
	TimeoutInSeconds *int `pulumi:"timeoutInSeconds"`
	// Number of vantage points where monitor is running.
	VantagePointCount *int `pulumi:"vantagePointCount"`
	// (Updatable) A list of public and dedicated vantage points from which to execute the monitor. Use /publicVantagePoints to fetch public vantage points, and /dedicatedVantagePoints to fetch dedicated vantage points.
	//
	// ** IMPORTANT **
	// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
	VantagePoints []ConfigVantagePoint `pulumi:"vantagePoints"`
}

type ConfigState struct {
	// (Updatable) The APM domain ID the request is intended for.
	ApmDomainId pulumi.StringPtrInput
	// (Updatable) Monitor availability configuration details.
	AvailabilityConfiguration ConfigAvailabilityConfigurationPtrInput
	// (Updatable) Time interval between 2 runs in round robin batch mode (*SchedulingPolicy - BATCHED_ROUND_ROBIN).
	BatchIntervalInSeconds pulumi.IntPtrInput
	// (Updatable) Details of monitor configuration.
	Configuration ConfigConfigurationPtrInput
	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
	DefinedTags pulumi.MapInput
	// (Updatable) Unique name that can be edited. The name should not contain any confidential information.
	DisplayName pulumi.StringPtrInput
	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
	FreeformTags pulumi.MapInput
	// (Updatable) If isRunNow is enabled, then the monitor will run immediately.
	IsRunNow pulumi.BoolPtrInput
	// (Updatable) If runOnce is enabled, then the monitor will run once.
	IsRunOnce pulumi.BoolPtrInput
	// (Updatable) Details required to schedule maintenance window.
	MaintenanceWindowSchedule ConfigMaintenanceWindowSchedulePtrInput
	// Type of monitor.
	MonitorType pulumi.StringPtrInput
	// (Updatable) Interval in seconds after the start time when the job should be repeated. Minimum repeatIntervalInSeconds should be 300 seconds for Scripted REST, Scripted Browser and Browser monitors, and 60 seconds for REST monitor.
	RepeatIntervalInSeconds pulumi.IntPtrInput
	// (Updatable) Scheduling policy to decide the distribution of monitor executions on vantage points.
	SchedulingPolicy pulumi.StringPtrInput
	// (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the script. scriptId is mandatory for creation of SCRIPTED_BROWSER and SCRIPTED_REST monitor types. For other monitor types, it should be set to null.
	ScriptId pulumi.StringPtrInput
	// Name of the script.
	ScriptName pulumi.StringPtrInput
	// (Updatable) List of script parameters in the monitor. This is valid only for SCRIPTED_BROWSER and SCRIPTED_REST monitor types. For other monitor types, it should be set to null. Example: `[{"paramName": "userid", "paramValue":"testuser"}]`
	ScriptParameters ConfigScriptParameterArrayInput
	// (Updatable) Enables or disables the monitor.
	Status pulumi.StringPtrInput
	// (Updatable) Specify the endpoint on which to run the monitor. For BROWSER, REST and NETWORK monitor types, target is mandatory. If target is specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script (specified by scriptId in monitor) against the specified target endpoint. If target is not specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script as it is. For NETWORK monitor with TCP protocol, a port needs to be provided along with target. Example: 192.168.0.1:80
	Target pulumi.StringPtrInput
	// The time the resource was created, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-12T22:47:12.613Z`
	TimeCreated pulumi.StringPtrInput
	// The time the resource was updated, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-13T22:47:12.613Z`
	TimeUpdated pulumi.StringPtrInput
	// (Updatable) Timeout in seconds. If isFailureRetried is true, then timeout cannot be more than 30% of repeatIntervalInSeconds time for monitors. If isFailureRetried is false, then timeout cannot be more than 50% of repeatIntervalInSeconds time for monitors. Also, timeoutInSeconds should be a multiple of 60 for Scripted REST, Scripted Browser and Browser monitors. Monitor will be allowed to run only for timeoutInSeconds time. It would be terminated after that.
	TimeoutInSeconds pulumi.IntPtrInput
	// Number of vantage points where monitor is running.
	VantagePointCount pulumi.IntPtrInput
	// (Updatable) A list of public and dedicated vantage points from which to execute the monitor. Use /publicVantagePoints to fetch public vantage points, and /dedicatedVantagePoints to fetch dedicated vantage points.
	//
	// ** IMPORTANT **
	// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
	VantagePoints ConfigVantagePointArrayInput
}

func (ConfigState) ElementType() reflect.Type {
	return reflect.TypeOf((*configState)(nil)).Elem()
}

type configArgs struct {
	// (Updatable) The APM domain ID the request is intended for.
	ApmDomainId string `pulumi:"apmDomainId"`
	// (Updatable) Monitor availability configuration details.
	AvailabilityConfiguration *ConfigAvailabilityConfiguration `pulumi:"availabilityConfiguration"`
	// (Updatable) Time interval between 2 runs in round robin batch mode (*SchedulingPolicy - BATCHED_ROUND_ROBIN).
	BatchIntervalInSeconds *int `pulumi:"batchIntervalInSeconds"`
	// (Updatable) Details of monitor configuration.
	Configuration *ConfigConfiguration `pulumi:"configuration"`
	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
	DefinedTags map[string]interface{} `pulumi:"definedTags"`
	// (Updatable) Unique name that can be edited. The name should not contain any confidential information.
	DisplayName string `pulumi:"displayName"`
	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
	FreeformTags map[string]interface{} `pulumi:"freeformTags"`
	// (Updatable) If isRunNow is enabled, then the monitor will run immediately.
	IsRunNow *bool `pulumi:"isRunNow"`
	// (Updatable) If runOnce is enabled, then the monitor will run once.
	IsRunOnce *bool `pulumi:"isRunOnce"`
	// (Updatable) Details required to schedule maintenance window.
	MaintenanceWindowSchedule *ConfigMaintenanceWindowSchedule `pulumi:"maintenanceWindowSchedule"`
	// Type of monitor.
	MonitorType string `pulumi:"monitorType"`
	// (Updatable) Interval in seconds after the start time when the job should be repeated. Minimum repeatIntervalInSeconds should be 300 seconds for Scripted REST, Scripted Browser and Browser monitors, and 60 seconds for REST monitor.
	RepeatIntervalInSeconds int `pulumi:"repeatIntervalInSeconds"`
	// (Updatable) Scheduling policy to decide the distribution of monitor executions on vantage points.
	SchedulingPolicy *string `pulumi:"schedulingPolicy"`
	// (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the script. scriptId is mandatory for creation of SCRIPTED_BROWSER and SCRIPTED_REST monitor types. For other monitor types, it should be set to null.
	ScriptId *string `pulumi:"scriptId"`
	// Name of the script.
	ScriptName *string `pulumi:"scriptName"`
	// (Updatable) List of script parameters in the monitor. This is valid only for SCRIPTED_BROWSER and SCRIPTED_REST monitor types. For other monitor types, it should be set to null. Example: `[{"paramName": "userid", "paramValue":"testuser"}]`
	ScriptParameters []ConfigScriptParameter `pulumi:"scriptParameters"`
	// (Updatable) Enables or disables the monitor.
	Status *string `pulumi:"status"`
	// (Updatable) Specify the endpoint on which to run the monitor. For BROWSER, REST and NETWORK monitor types, target is mandatory. If target is specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script (specified by scriptId in monitor) against the specified target endpoint. If target is not specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script as it is. For NETWORK monitor with TCP protocol, a port needs to be provided along with target. Example: 192.168.0.1:80
	Target *string `pulumi:"target"`
	// (Updatable) Timeout in seconds. If isFailureRetried is true, then timeout cannot be more than 30% of repeatIntervalInSeconds time for monitors. If isFailureRetried is false, then timeout cannot be more than 50% of repeatIntervalInSeconds time for monitors. Also, timeoutInSeconds should be a multiple of 60 for Scripted REST, Scripted Browser and Browser monitors. Monitor will be allowed to run only for timeoutInSeconds time. It would be terminated after that.
	TimeoutInSeconds *int `pulumi:"timeoutInSeconds"`
	// (Updatable) A list of public and dedicated vantage points from which to execute the monitor. Use /publicVantagePoints to fetch public vantage points, and /dedicatedVantagePoints to fetch dedicated vantage points.
	//
	// ** IMPORTANT **
	// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
	VantagePoints []ConfigVantagePoint `pulumi:"vantagePoints"`
}

// The set of arguments for constructing a Config resource.
type ConfigArgs struct {
	// (Updatable) The APM domain ID the request is intended for.
	ApmDomainId pulumi.StringInput
	// (Updatable) Monitor availability configuration details.
	AvailabilityConfiguration ConfigAvailabilityConfigurationPtrInput
	// (Updatable) Time interval between 2 runs in round robin batch mode (*SchedulingPolicy - BATCHED_ROUND_ROBIN).
	BatchIntervalInSeconds pulumi.IntPtrInput
	// (Updatable) Details of monitor configuration.
	Configuration ConfigConfigurationPtrInput
	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
	DefinedTags pulumi.MapInput
	// (Updatable) Unique name that can be edited. The name should not contain any confidential information.
	DisplayName pulumi.StringInput
	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
	FreeformTags pulumi.MapInput
	// (Updatable) If isRunNow is enabled, then the monitor will run immediately.
	IsRunNow pulumi.BoolPtrInput
	// (Updatable) If runOnce is enabled, then the monitor will run once.
	IsRunOnce pulumi.BoolPtrInput
	// (Updatable) Details required to schedule maintenance window.
	MaintenanceWindowSchedule ConfigMaintenanceWindowSchedulePtrInput
	// Type of monitor.
	MonitorType pulumi.StringInput
	// (Updatable) Interval in seconds after the start time when the job should be repeated. Minimum repeatIntervalInSeconds should be 300 seconds for Scripted REST, Scripted Browser and Browser monitors, and 60 seconds for REST monitor.
	RepeatIntervalInSeconds pulumi.IntInput
	// (Updatable) Scheduling policy to decide the distribution of monitor executions on vantage points.
	SchedulingPolicy pulumi.StringPtrInput
	// (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the script. scriptId is mandatory for creation of SCRIPTED_BROWSER and SCRIPTED_REST monitor types. For other monitor types, it should be set to null.
	ScriptId pulumi.StringPtrInput
	// Name of the script.
	ScriptName pulumi.StringPtrInput
	// (Updatable) List of script parameters in the monitor. This is valid only for SCRIPTED_BROWSER and SCRIPTED_REST monitor types. For other monitor types, it should be set to null. Example: `[{"paramName": "userid", "paramValue":"testuser"}]`
	ScriptParameters ConfigScriptParameterArrayInput
	// (Updatable) Enables or disables the monitor.
	Status pulumi.StringPtrInput
	// (Updatable) Specify the endpoint on which to run the monitor. For BROWSER, REST and NETWORK monitor types, target is mandatory. If target is specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script (specified by scriptId in monitor) against the specified target endpoint. If target is not specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script as it is. For NETWORK monitor with TCP protocol, a port needs to be provided along with target. Example: 192.168.0.1:80
	Target pulumi.StringPtrInput
	// (Updatable) Timeout in seconds. If isFailureRetried is true, then timeout cannot be more than 30% of repeatIntervalInSeconds time for monitors. If isFailureRetried is false, then timeout cannot be more than 50% of repeatIntervalInSeconds time for monitors. Also, timeoutInSeconds should be a multiple of 60 for Scripted REST, Scripted Browser and Browser monitors. Monitor will be allowed to run only for timeoutInSeconds time. It would be terminated after that.
	TimeoutInSeconds pulumi.IntPtrInput
	// (Updatable) A list of public and dedicated vantage points from which to execute the monitor. Use /publicVantagePoints to fetch public vantage points, and /dedicatedVantagePoints to fetch dedicated vantage points.
	//
	// ** IMPORTANT **
	// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
	VantagePoints ConfigVantagePointArrayInput
}

func (ConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*configArgs)(nil)).Elem()
}

type ConfigInput interface {
	pulumi.Input

	ToConfigOutput() ConfigOutput
	ToConfigOutputWithContext(ctx context.Context) ConfigOutput
}

func (*Config) ElementType() reflect.Type {
	return reflect.TypeOf((**Config)(nil)).Elem()
}

func (i *Config) ToConfigOutput() ConfigOutput {
	return i.ToConfigOutputWithContext(context.Background())
}

func (i *Config) ToConfigOutputWithContext(ctx context.Context) ConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConfigOutput)
}

// ConfigArrayInput is an input type that accepts ConfigArray and ConfigArrayOutput values.
// You can construct a concrete instance of `ConfigArrayInput` via:
//
//	ConfigArray{ ConfigArgs{...} }
type ConfigArrayInput interface {
	pulumi.Input

	ToConfigArrayOutput() ConfigArrayOutput
	ToConfigArrayOutputWithContext(context.Context) ConfigArrayOutput
}

type ConfigArray []ConfigInput

func (ConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Config)(nil)).Elem()
}

func (i ConfigArray) ToConfigArrayOutput() ConfigArrayOutput {
	return i.ToConfigArrayOutputWithContext(context.Background())
}

func (i ConfigArray) ToConfigArrayOutputWithContext(ctx context.Context) ConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConfigArrayOutput)
}

// ConfigMapInput is an input type that accepts ConfigMap and ConfigMapOutput values.
// You can construct a concrete instance of `ConfigMapInput` via:
//
//	ConfigMap{ "key": ConfigArgs{...} }
type ConfigMapInput interface {
	pulumi.Input

	ToConfigMapOutput() ConfigMapOutput
	ToConfigMapOutputWithContext(context.Context) ConfigMapOutput
}

type ConfigMap map[string]ConfigInput

func (ConfigMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Config)(nil)).Elem()
}

func (i ConfigMap) ToConfigMapOutput() ConfigMapOutput {
	return i.ToConfigMapOutputWithContext(context.Background())
}

func (i ConfigMap) ToConfigMapOutputWithContext(ctx context.Context) ConfigMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConfigMapOutput)
}

type ConfigOutput struct{ *pulumi.OutputState }

func (ConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Config)(nil)).Elem()
}

func (o ConfigOutput) ToConfigOutput() ConfigOutput {
	return o
}

func (o ConfigOutput) ToConfigOutputWithContext(ctx context.Context) ConfigOutput {
	return o
}

// (Updatable) The APM domain ID the request is intended for.
func (o ConfigOutput) ApmDomainId() pulumi.StringOutput {
	return o.ApplyT(func(v *Config) pulumi.StringOutput { return v.ApmDomainId }).(pulumi.StringOutput)
}

// (Updatable) Monitor availability configuration details.
func (o ConfigOutput) AvailabilityConfiguration() ConfigAvailabilityConfigurationOutput {
	return o.ApplyT(func(v *Config) ConfigAvailabilityConfigurationOutput { return v.AvailabilityConfiguration }).(ConfigAvailabilityConfigurationOutput)
}

// (Updatable) Time interval between 2 runs in round robin batch mode (*SchedulingPolicy - BATCHED_ROUND_ROBIN).
func (o ConfigOutput) BatchIntervalInSeconds() pulumi.IntOutput {
	return o.ApplyT(func(v *Config) pulumi.IntOutput { return v.BatchIntervalInSeconds }).(pulumi.IntOutput)
}

// (Updatable) Details of monitor configuration.
func (o ConfigOutput) Configuration() ConfigConfigurationOutput {
	return o.ApplyT(func(v *Config) ConfigConfigurationOutput { return v.Configuration }).(ConfigConfigurationOutput)
}

// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
func (o ConfigOutput) DefinedTags() pulumi.MapOutput {
	return o.ApplyT(func(v *Config) pulumi.MapOutput { return v.DefinedTags }).(pulumi.MapOutput)
}

// (Updatable) Unique name that can be edited. The name should not contain any confidential information.
func (o ConfigOutput) DisplayName() pulumi.StringOutput {
	return o.ApplyT(func(v *Config) pulumi.StringOutput { return v.DisplayName }).(pulumi.StringOutput)
}

// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
func (o ConfigOutput) FreeformTags() pulumi.MapOutput {
	return o.ApplyT(func(v *Config) pulumi.MapOutput { return v.FreeformTags }).(pulumi.MapOutput)
}

// (Updatable) If isRunNow is enabled, then the monitor will run immediately.
func (o ConfigOutput) IsRunNow() pulumi.BoolOutput {
	return o.ApplyT(func(v *Config) pulumi.BoolOutput { return v.IsRunNow }).(pulumi.BoolOutput)
}

// (Updatable) If runOnce is enabled, then the monitor will run once.
func (o ConfigOutput) IsRunOnce() pulumi.BoolOutput {
	return o.ApplyT(func(v *Config) pulumi.BoolOutput { return v.IsRunOnce }).(pulumi.BoolOutput)
}

// (Updatable) Details required to schedule maintenance window.
func (o ConfigOutput) MaintenanceWindowSchedule() ConfigMaintenanceWindowScheduleOutput {
	return o.ApplyT(func(v *Config) ConfigMaintenanceWindowScheduleOutput { return v.MaintenanceWindowSchedule }).(ConfigMaintenanceWindowScheduleOutput)
}

// Type of monitor.
func (o ConfigOutput) MonitorType() pulumi.StringOutput {
	return o.ApplyT(func(v *Config) pulumi.StringOutput { return v.MonitorType }).(pulumi.StringOutput)
}

// (Updatable) Interval in seconds after the start time when the job should be repeated. Minimum repeatIntervalInSeconds should be 300 seconds for Scripted REST, Scripted Browser and Browser monitors, and 60 seconds for REST monitor.
func (o ConfigOutput) RepeatIntervalInSeconds() pulumi.IntOutput {
	return o.ApplyT(func(v *Config) pulumi.IntOutput { return v.RepeatIntervalInSeconds }).(pulumi.IntOutput)
}

// (Updatable) Scheduling policy to decide the distribution of monitor executions on vantage points.
func (o ConfigOutput) SchedulingPolicy() pulumi.StringOutput {
	return o.ApplyT(func(v *Config) pulumi.StringOutput { return v.SchedulingPolicy }).(pulumi.StringOutput)
}

// (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the script. scriptId is mandatory for creation of SCRIPTED_BROWSER and SCRIPTED_REST monitor types. For other monitor types, it should be set to null.
func (o ConfigOutput) ScriptId() pulumi.StringOutput {
	return o.ApplyT(func(v *Config) pulumi.StringOutput { return v.ScriptId }).(pulumi.StringOutput)
}

// Name of the script.
func (o ConfigOutput) ScriptName() pulumi.StringOutput {
	return o.ApplyT(func(v *Config) pulumi.StringOutput { return v.ScriptName }).(pulumi.StringOutput)
}

// (Updatable) List of script parameters in the monitor. This is valid only for SCRIPTED_BROWSER and SCRIPTED_REST monitor types. For other monitor types, it should be set to null. Example: `[{"paramName": "userid", "paramValue":"testuser"}]`
func (o ConfigOutput) ScriptParameters() ConfigScriptParameterArrayOutput {
	return o.ApplyT(func(v *Config) ConfigScriptParameterArrayOutput { return v.ScriptParameters }).(ConfigScriptParameterArrayOutput)
}

// (Updatable) Enables or disables the monitor.
func (o ConfigOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v *Config) pulumi.StringOutput { return v.Status }).(pulumi.StringOutput)
}

// (Updatable) Specify the endpoint on which to run the monitor. For BROWSER, REST and NETWORK monitor types, target is mandatory. If target is specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script (specified by scriptId in monitor) against the specified target endpoint. If target is not specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script as it is. For NETWORK monitor with TCP protocol, a port needs to be provided along with target. Example: 192.168.0.1:80
func (o ConfigOutput) Target() pulumi.StringOutput {
	return o.ApplyT(func(v *Config) pulumi.StringOutput { return v.Target }).(pulumi.StringOutput)
}

// The time the resource was created, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-12T22:47:12.613Z`
func (o ConfigOutput) TimeCreated() pulumi.StringOutput {
	return o.ApplyT(func(v *Config) pulumi.StringOutput { return v.TimeCreated }).(pulumi.StringOutput)
}

// The time the resource was updated, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-13T22:47:12.613Z`
func (o ConfigOutput) TimeUpdated() pulumi.StringOutput {
	return o.ApplyT(func(v *Config) pulumi.StringOutput { return v.TimeUpdated }).(pulumi.StringOutput)
}

// (Updatable) Timeout in seconds. If isFailureRetried is true, then timeout cannot be more than 30% of repeatIntervalInSeconds time for monitors. If isFailureRetried is false, then timeout cannot be more than 50% of repeatIntervalInSeconds time for monitors. Also, timeoutInSeconds should be a multiple of 60 for Scripted REST, Scripted Browser and Browser monitors. Monitor will be allowed to run only for timeoutInSeconds time. It would be terminated after that.
func (o ConfigOutput) TimeoutInSeconds() pulumi.IntOutput {
	return o.ApplyT(func(v *Config) pulumi.IntOutput { return v.TimeoutInSeconds }).(pulumi.IntOutput)
}

// Number of vantage points where monitor is running.
func (o ConfigOutput) VantagePointCount() pulumi.IntOutput {
	return o.ApplyT(func(v *Config) pulumi.IntOutput { return v.VantagePointCount }).(pulumi.IntOutput)
}

// (Updatable) A list of public and dedicated vantage points from which to execute the monitor. Use /publicVantagePoints to fetch public vantage points, and /dedicatedVantagePoints to fetch dedicated vantage points.
//
// ** IMPORTANT **
// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
func (o ConfigOutput) VantagePoints() ConfigVantagePointArrayOutput {
	return o.ApplyT(func(v *Config) ConfigVantagePointArrayOutput { return v.VantagePoints }).(ConfigVantagePointArrayOutput)
}

type ConfigArrayOutput struct{ *pulumi.OutputState }

func (ConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Config)(nil)).Elem()
}

func (o ConfigArrayOutput) ToConfigArrayOutput() ConfigArrayOutput {
	return o
}

func (o ConfigArrayOutput) ToConfigArrayOutputWithContext(ctx context.Context) ConfigArrayOutput {
	return o
}

func (o ConfigArrayOutput) Index(i pulumi.IntInput) ConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Config {
		return vs[0].([]*Config)[vs[1].(int)]
	}).(ConfigOutput)
}

type ConfigMapOutput struct{ *pulumi.OutputState }

func (ConfigMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Config)(nil)).Elem()
}

func (o ConfigMapOutput) ToConfigMapOutput() ConfigMapOutput {
	return o
}

func (o ConfigMapOutput) ToConfigMapOutputWithContext(ctx context.Context) ConfigMapOutput {
	return o
}

func (o ConfigMapOutput) MapIndex(k pulumi.StringInput) ConfigOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Config {
		return vs[0].(map[string]*Config)[vs[1].(string)]
	}).(ConfigOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ConfigInput)(nil)).Elem(), &Config{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConfigArrayInput)(nil)).Elem(), ConfigArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConfigMapInput)(nil)).Elem(), ConfigMap{})
	pulumi.RegisterOutputType(ConfigOutput{})
	pulumi.RegisterOutputType(ConfigArrayOutput{})
	pulumi.RegisterOutputType(ConfigMapOutput{})
}
