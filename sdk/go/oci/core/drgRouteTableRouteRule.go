// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package core

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-oci/sdk/v3/go/oci/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// This resource provides the Drg Route Table Route Rule resource in Oracle Cloud Infrastructure Core service.
//
// Adds one static route rule to the specified DRG route table.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-oci/sdk/v3/go/oci/core"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := core.NewDrgRouteTableRouteRule(ctx, "test_drg_route_table_route_rule", &core.DrgRouteTableRouteRuleArgs{
//				DrgRouteTableId:        pulumi.Any(testDrgRouteTable.Id),
//				Destination:            pulumi.Any(drgRouteTableRouteRuleRouteRulesDestination),
//				DestinationType:        pulumi.Any(drgRouteTableRouteRuleRouteRulesDestinationType),
//				NextHopDrgAttachmentId: pulumi.Any(testDrgAttachment.Id),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// DrgRouteTableRouteRule can be imported using the `id`, e.g.
//
// ```sh
// $ pulumi import oci:Core/drgRouteTableRouteRule:DrgRouteTableRouteRule test_drg_route_table_route_rule "drgRouteTables/{drgRouteTableId}/routeRules/{id}"
// ```
type DrgRouteTableRouteRule struct {
	pulumi.CustomResourceState

	// Additional properties for the route, computed by the service.
	Attributes pulumi.StringMapOutput `pulumi:"attributes"`
	// (Updatable) This is the range of IP addresses used for matching when routing traffic. Only CIDR_BLOCK values are allowed.
	//
	// Potential values:
	// * IP address range in CIDR notation. This can be an IPv4 or IPv6 CIDR. For example: `192.168.1.0/24` or `2001:0db8:0123:45::/56`.
	Destination pulumi.StringOutput `pulumi:"destination"`
	// Type of destination for the rule. Required if `direction` = `EGRESS`. Allowed values:
	// * `CIDR_BLOCK`: If the rule's `destination` is an IP address range in CIDR notation.
	DestinationType pulumi.StringOutput `pulumi:"destinationType"`
	// The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DRG route table.
	//
	// Potential values:
	// * IP address range in CIDR notation. This can be an IPv4 CIDR block or IPv6 prefix. For example: `192.168.1.0/24` or `2001:0db8:0123:45::/56`.
	DrgRouteTableId pulumi.StringOutput `pulumi:"drgRouteTableId"`
	// Indicates that if the next hop attachment does not exist, so traffic for this route is discarded without notification.
	IsBlackhole pulumi.BoolOutput `pulumi:"isBlackhole"`
	// Indicates that the route was not imported due to a conflict between route rules.
	IsConflict pulumi.BoolOutput `pulumi:"isConflict"`
	// The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the next hop DRG attachment. The next hop DRG attachment is responsible for reaching the network destination.
	//
	// ** IMPORTANT **
	// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
	NextHopDrgAttachmentId pulumi.StringOutput `pulumi:"nextHopDrgAttachmentId"`
	// The earliest origin of a route. If a route is advertised to a DRG through an IPsec tunnel attachment, and is propagated to peered DRGs via RPC attachments, the route's provenance in the peered DRGs remains `IPSEC_TUNNEL`, because that is the earliest origin.
	RouteProvenance pulumi.StringOutput `pulumi:"routeProvenance"`
	// You can specify static routes for the DRG route table using the API. The DRG learns dynamic routes from the DRG attachments using various routing protocols.
	RouteType pulumi.StringOutput `pulumi:"routeType"`
}

// NewDrgRouteTableRouteRule registers a new resource with the given unique name, arguments, and options.
func NewDrgRouteTableRouteRule(ctx *pulumi.Context,
	name string, args *DrgRouteTableRouteRuleArgs, opts ...pulumi.ResourceOption) (*DrgRouteTableRouteRule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Destination == nil {
		return nil, errors.New("invalid value for required argument 'Destination'")
	}
	if args.DestinationType == nil {
		return nil, errors.New("invalid value for required argument 'DestinationType'")
	}
	if args.DrgRouteTableId == nil {
		return nil, errors.New("invalid value for required argument 'DrgRouteTableId'")
	}
	if args.NextHopDrgAttachmentId == nil {
		return nil, errors.New("invalid value for required argument 'NextHopDrgAttachmentId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource DrgRouteTableRouteRule
	err := ctx.RegisterResource("oci:Core/drgRouteTableRouteRule:DrgRouteTableRouteRule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDrgRouteTableRouteRule gets an existing DrgRouteTableRouteRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDrgRouteTableRouteRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DrgRouteTableRouteRuleState, opts ...pulumi.ResourceOption) (*DrgRouteTableRouteRule, error) {
	var resource DrgRouteTableRouteRule
	err := ctx.ReadResource("oci:Core/drgRouteTableRouteRule:DrgRouteTableRouteRule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering DrgRouteTableRouteRule resources.
type drgRouteTableRouteRuleState struct {
	// Additional properties for the route, computed by the service.
	Attributes map[string]string `pulumi:"attributes"`
	// (Updatable) This is the range of IP addresses used for matching when routing traffic. Only CIDR_BLOCK values are allowed.
	//
	// Potential values:
	// * IP address range in CIDR notation. This can be an IPv4 or IPv6 CIDR. For example: `192.168.1.0/24` or `2001:0db8:0123:45::/56`.
	Destination *string `pulumi:"destination"`
	// Type of destination for the rule. Required if `direction` = `EGRESS`. Allowed values:
	// * `CIDR_BLOCK`: If the rule's `destination` is an IP address range in CIDR notation.
	DestinationType *string `pulumi:"destinationType"`
	// The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DRG route table.
	//
	// Potential values:
	// * IP address range in CIDR notation. This can be an IPv4 CIDR block or IPv6 prefix. For example: `192.168.1.0/24` or `2001:0db8:0123:45::/56`.
	DrgRouteTableId *string `pulumi:"drgRouteTableId"`
	// Indicates that if the next hop attachment does not exist, so traffic for this route is discarded without notification.
	IsBlackhole *bool `pulumi:"isBlackhole"`
	// Indicates that the route was not imported due to a conflict between route rules.
	IsConflict *bool `pulumi:"isConflict"`
	// The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the next hop DRG attachment. The next hop DRG attachment is responsible for reaching the network destination.
	//
	// ** IMPORTANT **
	// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
	NextHopDrgAttachmentId *string `pulumi:"nextHopDrgAttachmentId"`
	// The earliest origin of a route. If a route is advertised to a DRG through an IPsec tunnel attachment, and is propagated to peered DRGs via RPC attachments, the route's provenance in the peered DRGs remains `IPSEC_TUNNEL`, because that is the earliest origin.
	RouteProvenance *string `pulumi:"routeProvenance"`
	// You can specify static routes for the DRG route table using the API. The DRG learns dynamic routes from the DRG attachments using various routing protocols.
	RouteType *string `pulumi:"routeType"`
}

type DrgRouteTableRouteRuleState struct {
	// Additional properties for the route, computed by the service.
	Attributes pulumi.StringMapInput
	// (Updatable) This is the range of IP addresses used for matching when routing traffic. Only CIDR_BLOCK values are allowed.
	//
	// Potential values:
	// * IP address range in CIDR notation. This can be an IPv4 or IPv6 CIDR. For example: `192.168.1.0/24` or `2001:0db8:0123:45::/56`.
	Destination pulumi.StringPtrInput
	// Type of destination for the rule. Required if `direction` = `EGRESS`. Allowed values:
	// * `CIDR_BLOCK`: If the rule's `destination` is an IP address range in CIDR notation.
	DestinationType pulumi.StringPtrInput
	// The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DRG route table.
	//
	// Potential values:
	// * IP address range in CIDR notation. This can be an IPv4 CIDR block or IPv6 prefix. For example: `192.168.1.0/24` or `2001:0db8:0123:45::/56`.
	DrgRouteTableId pulumi.StringPtrInput
	// Indicates that if the next hop attachment does not exist, so traffic for this route is discarded without notification.
	IsBlackhole pulumi.BoolPtrInput
	// Indicates that the route was not imported due to a conflict between route rules.
	IsConflict pulumi.BoolPtrInput
	// The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the next hop DRG attachment. The next hop DRG attachment is responsible for reaching the network destination.
	//
	// ** IMPORTANT **
	// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
	NextHopDrgAttachmentId pulumi.StringPtrInput
	// The earliest origin of a route. If a route is advertised to a DRG through an IPsec tunnel attachment, and is propagated to peered DRGs via RPC attachments, the route's provenance in the peered DRGs remains `IPSEC_TUNNEL`, because that is the earliest origin.
	RouteProvenance pulumi.StringPtrInput
	// You can specify static routes for the DRG route table using the API. The DRG learns dynamic routes from the DRG attachments using various routing protocols.
	RouteType pulumi.StringPtrInput
}

func (DrgRouteTableRouteRuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*drgRouteTableRouteRuleState)(nil)).Elem()
}

type drgRouteTableRouteRuleArgs struct {
	// (Updatable) This is the range of IP addresses used for matching when routing traffic. Only CIDR_BLOCK values are allowed.
	//
	// Potential values:
	// * IP address range in CIDR notation. This can be an IPv4 or IPv6 CIDR. For example: `192.168.1.0/24` or `2001:0db8:0123:45::/56`.
	Destination string `pulumi:"destination"`
	// Type of destination for the rule. Required if `direction` = `EGRESS`. Allowed values:
	// * `CIDR_BLOCK`: If the rule's `destination` is an IP address range in CIDR notation.
	DestinationType string `pulumi:"destinationType"`
	// The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DRG route table.
	//
	// Potential values:
	// * IP address range in CIDR notation. This can be an IPv4 CIDR block or IPv6 prefix. For example: `192.168.1.0/24` or `2001:0db8:0123:45::/56`.
	DrgRouteTableId string `pulumi:"drgRouteTableId"`
	// The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the next hop DRG attachment. The next hop DRG attachment is responsible for reaching the network destination.
	//
	// ** IMPORTANT **
	// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
	NextHopDrgAttachmentId string `pulumi:"nextHopDrgAttachmentId"`
}

// The set of arguments for constructing a DrgRouteTableRouteRule resource.
type DrgRouteTableRouteRuleArgs struct {
	// (Updatable) This is the range of IP addresses used for matching when routing traffic. Only CIDR_BLOCK values are allowed.
	//
	// Potential values:
	// * IP address range in CIDR notation. This can be an IPv4 or IPv6 CIDR. For example: `192.168.1.0/24` or `2001:0db8:0123:45::/56`.
	Destination pulumi.StringInput
	// Type of destination for the rule. Required if `direction` = `EGRESS`. Allowed values:
	// * `CIDR_BLOCK`: If the rule's `destination` is an IP address range in CIDR notation.
	DestinationType pulumi.StringInput
	// The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DRG route table.
	//
	// Potential values:
	// * IP address range in CIDR notation. This can be an IPv4 CIDR block or IPv6 prefix. For example: `192.168.1.0/24` or `2001:0db8:0123:45::/56`.
	DrgRouteTableId pulumi.StringInput
	// The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the next hop DRG attachment. The next hop DRG attachment is responsible for reaching the network destination.
	//
	// ** IMPORTANT **
	// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
	NextHopDrgAttachmentId pulumi.StringInput
}

func (DrgRouteTableRouteRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*drgRouteTableRouteRuleArgs)(nil)).Elem()
}

type DrgRouteTableRouteRuleInput interface {
	pulumi.Input

	ToDrgRouteTableRouteRuleOutput() DrgRouteTableRouteRuleOutput
	ToDrgRouteTableRouteRuleOutputWithContext(ctx context.Context) DrgRouteTableRouteRuleOutput
}

func (*DrgRouteTableRouteRule) ElementType() reflect.Type {
	return reflect.TypeOf((**DrgRouteTableRouteRule)(nil)).Elem()
}

func (i *DrgRouteTableRouteRule) ToDrgRouteTableRouteRuleOutput() DrgRouteTableRouteRuleOutput {
	return i.ToDrgRouteTableRouteRuleOutputWithContext(context.Background())
}

func (i *DrgRouteTableRouteRule) ToDrgRouteTableRouteRuleOutputWithContext(ctx context.Context) DrgRouteTableRouteRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DrgRouteTableRouteRuleOutput)
}

// DrgRouteTableRouteRuleArrayInput is an input type that accepts DrgRouteTableRouteRuleArray and DrgRouteTableRouteRuleArrayOutput values.
// You can construct a concrete instance of `DrgRouteTableRouteRuleArrayInput` via:
//
//	DrgRouteTableRouteRuleArray{ DrgRouteTableRouteRuleArgs{...} }
type DrgRouteTableRouteRuleArrayInput interface {
	pulumi.Input

	ToDrgRouteTableRouteRuleArrayOutput() DrgRouteTableRouteRuleArrayOutput
	ToDrgRouteTableRouteRuleArrayOutputWithContext(context.Context) DrgRouteTableRouteRuleArrayOutput
}

type DrgRouteTableRouteRuleArray []DrgRouteTableRouteRuleInput

func (DrgRouteTableRouteRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DrgRouteTableRouteRule)(nil)).Elem()
}

func (i DrgRouteTableRouteRuleArray) ToDrgRouteTableRouteRuleArrayOutput() DrgRouteTableRouteRuleArrayOutput {
	return i.ToDrgRouteTableRouteRuleArrayOutputWithContext(context.Background())
}

func (i DrgRouteTableRouteRuleArray) ToDrgRouteTableRouteRuleArrayOutputWithContext(ctx context.Context) DrgRouteTableRouteRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DrgRouteTableRouteRuleArrayOutput)
}

// DrgRouteTableRouteRuleMapInput is an input type that accepts DrgRouteTableRouteRuleMap and DrgRouteTableRouteRuleMapOutput values.
// You can construct a concrete instance of `DrgRouteTableRouteRuleMapInput` via:
//
//	DrgRouteTableRouteRuleMap{ "key": DrgRouteTableRouteRuleArgs{...} }
type DrgRouteTableRouteRuleMapInput interface {
	pulumi.Input

	ToDrgRouteTableRouteRuleMapOutput() DrgRouteTableRouteRuleMapOutput
	ToDrgRouteTableRouteRuleMapOutputWithContext(context.Context) DrgRouteTableRouteRuleMapOutput
}

type DrgRouteTableRouteRuleMap map[string]DrgRouteTableRouteRuleInput

func (DrgRouteTableRouteRuleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DrgRouteTableRouteRule)(nil)).Elem()
}

func (i DrgRouteTableRouteRuleMap) ToDrgRouteTableRouteRuleMapOutput() DrgRouteTableRouteRuleMapOutput {
	return i.ToDrgRouteTableRouteRuleMapOutputWithContext(context.Background())
}

func (i DrgRouteTableRouteRuleMap) ToDrgRouteTableRouteRuleMapOutputWithContext(ctx context.Context) DrgRouteTableRouteRuleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DrgRouteTableRouteRuleMapOutput)
}

type DrgRouteTableRouteRuleOutput struct{ *pulumi.OutputState }

func (DrgRouteTableRouteRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DrgRouteTableRouteRule)(nil)).Elem()
}

func (o DrgRouteTableRouteRuleOutput) ToDrgRouteTableRouteRuleOutput() DrgRouteTableRouteRuleOutput {
	return o
}

func (o DrgRouteTableRouteRuleOutput) ToDrgRouteTableRouteRuleOutputWithContext(ctx context.Context) DrgRouteTableRouteRuleOutput {
	return o
}

// Additional properties for the route, computed by the service.
func (o DrgRouteTableRouteRuleOutput) Attributes() pulumi.StringMapOutput {
	return o.ApplyT(func(v *DrgRouteTableRouteRule) pulumi.StringMapOutput { return v.Attributes }).(pulumi.StringMapOutput)
}

// (Updatable) This is the range of IP addresses used for matching when routing traffic. Only CIDR_BLOCK values are allowed.
//
// Potential values:
// * IP address range in CIDR notation. This can be an IPv4 or IPv6 CIDR. For example: `192.168.1.0/24` or `2001:0db8:0123:45::/56`.
func (o DrgRouteTableRouteRuleOutput) Destination() pulumi.StringOutput {
	return o.ApplyT(func(v *DrgRouteTableRouteRule) pulumi.StringOutput { return v.Destination }).(pulumi.StringOutput)
}

// Type of destination for the rule. Required if `direction` = `EGRESS`. Allowed values:
// * `CIDR_BLOCK`: If the rule's `destination` is an IP address range in CIDR notation.
func (o DrgRouteTableRouteRuleOutput) DestinationType() pulumi.StringOutput {
	return o.ApplyT(func(v *DrgRouteTableRouteRule) pulumi.StringOutput { return v.DestinationType }).(pulumi.StringOutput)
}

// The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DRG route table.
//
// Potential values:
// * IP address range in CIDR notation. This can be an IPv4 CIDR block or IPv6 prefix. For example: `192.168.1.0/24` or `2001:0db8:0123:45::/56`.
func (o DrgRouteTableRouteRuleOutput) DrgRouteTableId() pulumi.StringOutput {
	return o.ApplyT(func(v *DrgRouteTableRouteRule) pulumi.StringOutput { return v.DrgRouteTableId }).(pulumi.StringOutput)
}

// Indicates that if the next hop attachment does not exist, so traffic for this route is discarded without notification.
func (o DrgRouteTableRouteRuleOutput) IsBlackhole() pulumi.BoolOutput {
	return o.ApplyT(func(v *DrgRouteTableRouteRule) pulumi.BoolOutput { return v.IsBlackhole }).(pulumi.BoolOutput)
}

// Indicates that the route was not imported due to a conflict between route rules.
func (o DrgRouteTableRouteRuleOutput) IsConflict() pulumi.BoolOutput {
	return o.ApplyT(func(v *DrgRouteTableRouteRule) pulumi.BoolOutput { return v.IsConflict }).(pulumi.BoolOutput)
}

// The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the next hop DRG attachment. The next hop DRG attachment is responsible for reaching the network destination.
//
// ** IMPORTANT **
// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
func (o DrgRouteTableRouteRuleOutput) NextHopDrgAttachmentId() pulumi.StringOutput {
	return o.ApplyT(func(v *DrgRouteTableRouteRule) pulumi.StringOutput { return v.NextHopDrgAttachmentId }).(pulumi.StringOutput)
}

// The earliest origin of a route. If a route is advertised to a DRG through an IPsec tunnel attachment, and is propagated to peered DRGs via RPC attachments, the route's provenance in the peered DRGs remains `IPSEC_TUNNEL`, because that is the earliest origin.
func (o DrgRouteTableRouteRuleOutput) RouteProvenance() pulumi.StringOutput {
	return o.ApplyT(func(v *DrgRouteTableRouteRule) pulumi.StringOutput { return v.RouteProvenance }).(pulumi.StringOutput)
}

// You can specify static routes for the DRG route table using the API. The DRG learns dynamic routes from the DRG attachments using various routing protocols.
func (o DrgRouteTableRouteRuleOutput) RouteType() pulumi.StringOutput {
	return o.ApplyT(func(v *DrgRouteTableRouteRule) pulumi.StringOutput { return v.RouteType }).(pulumi.StringOutput)
}

type DrgRouteTableRouteRuleArrayOutput struct{ *pulumi.OutputState }

func (DrgRouteTableRouteRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DrgRouteTableRouteRule)(nil)).Elem()
}

func (o DrgRouteTableRouteRuleArrayOutput) ToDrgRouteTableRouteRuleArrayOutput() DrgRouteTableRouteRuleArrayOutput {
	return o
}

func (o DrgRouteTableRouteRuleArrayOutput) ToDrgRouteTableRouteRuleArrayOutputWithContext(ctx context.Context) DrgRouteTableRouteRuleArrayOutput {
	return o
}

func (o DrgRouteTableRouteRuleArrayOutput) Index(i pulumi.IntInput) DrgRouteTableRouteRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *DrgRouteTableRouteRule {
		return vs[0].([]*DrgRouteTableRouteRule)[vs[1].(int)]
	}).(DrgRouteTableRouteRuleOutput)
}

type DrgRouteTableRouteRuleMapOutput struct{ *pulumi.OutputState }

func (DrgRouteTableRouteRuleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DrgRouteTableRouteRule)(nil)).Elem()
}

func (o DrgRouteTableRouteRuleMapOutput) ToDrgRouteTableRouteRuleMapOutput() DrgRouteTableRouteRuleMapOutput {
	return o
}

func (o DrgRouteTableRouteRuleMapOutput) ToDrgRouteTableRouteRuleMapOutputWithContext(ctx context.Context) DrgRouteTableRouteRuleMapOutput {
	return o
}

func (o DrgRouteTableRouteRuleMapOutput) MapIndex(k pulumi.StringInput) DrgRouteTableRouteRuleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *DrgRouteTableRouteRule {
		return vs[0].(map[string]*DrgRouteTableRouteRule)[vs[1].(string)]
	}).(DrgRouteTableRouteRuleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*DrgRouteTableRouteRuleInput)(nil)).Elem(), &DrgRouteTableRouteRule{})
	pulumi.RegisterInputType(reflect.TypeOf((*DrgRouteTableRouteRuleArrayInput)(nil)).Elem(), DrgRouteTableRouteRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DrgRouteTableRouteRuleMapInput)(nil)).Elem(), DrgRouteTableRouteRuleMap{})
	pulumi.RegisterOutputType(DrgRouteTableRouteRuleOutput{})
	pulumi.RegisterOutputType(DrgRouteTableRouteRuleArrayOutput{})
	pulumi.RegisterOutputType(DrgRouteTableRouteRuleMapOutput{})
}
