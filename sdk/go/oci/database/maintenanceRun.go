// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package database

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-oci/sdk/v2/go/oci/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// This resource provides the Maintenance Run resource in Oracle Cloud Infrastructure Database service.
//
// Creates a maintenance run with one of the following:
// The latest available release update patch (RUP) for the Autonomous Container Database.
// The latest available RUP and DST time zone (TZ) file updates for the Autonomous Container Database.
// Creates a maintenance run to update the DST TZ file for the Autonomous Container Database.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-oci/sdk/v2/go/oci/database"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := database.NewMaintenanceRun(ctx, "test_maintenance_run", &database.MaintenanceRunArgs{
//				PatchType:               pulumi.Any(maintenanceRunPatchType),
//				TargetResourceId:        pulumi.Any(testResource.Id),
//				TimeScheduled:           pulumi.Any(maintenanceRunTimeScheduled),
//				CompartmentId:           pulumi.Any(compartmentId),
//				DatabaseSoftwareImageId: pulumi.Any(testDatabaseSoftwareImage.Id),
//				IsDstFileUpdateEnabled:  pulumi.Any(maintenanceRunIsDstFileUpdateEnabled),
//				PatchingMode:            pulumi.Any(maintenanceRunPatchingMode),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// MaintenanceRuns can be imported using the `id`, e.g.
//
// ```sh
// $ pulumi import oci:Database/maintenanceRun:MaintenanceRun test_maintenance_run "id"
// ```
type MaintenanceRun struct {
	pulumi.CustomResourceState

	// The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment containing the Maintenance Run.
	CompartmentId pulumi.StringOutput `pulumi:"compartmentId"`
	// Extend current custom action timeout between the current database servers during waiting state, from 0 (zero) to 30 minutes.
	CurrentCustomActionTimeoutInMins pulumi.IntOutput `pulumi:"currentCustomActionTimeoutInMins"`
	// The name of the current infrastruture component that is getting patched.
	CurrentPatchingComponent pulumi.StringOutput `pulumi:"currentPatchingComponent"`
	// Determines the amount of time the system will wait before the start of each database server patching operation. Specify a number of minutes, from 15 to 120.
	CustomActionTimeoutInMins pulumi.IntOutput `pulumi:"customActionTimeoutInMins"`
	// The Autonomous Database Software Image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
	DatabaseSoftwareImageId pulumi.StringOutput `pulumi:"databaseSoftwareImageId"`
	// Description of the maintenance run.
	Description pulumi.StringOutput `pulumi:"description"`
	// The user-friendly name for the maintenance run.
	DisplayName pulumi.StringOutput `pulumi:"displayName"`
	// The estimated start time of the next infrastruture component patching operation.
	EstimatedComponentPatchingStartTime pulumi.StringOutput `pulumi:"estimatedComponentPatchingStartTime"`
	// The estimated total time required in minutes for all patching operations (database server, storage server, and network switch patching).
	EstimatedPatchingTimes MaintenanceRunEstimatedPatchingTimeArrayOutput `pulumi:"estimatedPatchingTimes"`
	// If true, enables the configuration of a custom action timeout (waiting period) between database servers patching operations.
	IsCustomActionTimeoutEnabled pulumi.BoolOutput `pulumi:"isCustomActionTimeoutEnabled"`
	// Indicates if an automatic DST Time Zone file update is enabled for the Autonomous Container Database. If enabled along with Release Update, patching will be done in a Non-Rolling manner.
	IsDstFileUpdateEnabled pulumi.BoolOutput `pulumi:"isDstFileUpdateEnabled"`
	// If `FALSE`, the maintenance run doesn't support granular maintenance.
	IsMaintenanceRunGranular pulumi.BoolOutput `pulumi:"isMaintenanceRunGranular"`
	// Additional information about the current lifecycle state.
	LifecycleDetails pulumi.StringOutput `pulumi:"lifecycleDetails"`
	// Maintenance sub-type.
	MaintenanceSubtype pulumi.StringOutput `pulumi:"maintenanceSubtype"`
	// Maintenance type.
	MaintenanceType pulumi.StringOutput `pulumi:"maintenanceType"`
	// Contain the patch failure count.
	PatchFailureCount pulumi.IntOutput `pulumi:"patchFailureCount"`
	// The unique identifier of the patch. The identifier string includes the patch type, the Oracle Database version, and the patch creation date (using the format YYMMDD). For example, the identifier `ru_patch_19.9.0.0_201030` is used for an RU patch for Oracle Database 19.9.0.0 that was released October 30, 2020.
	PatchId pulumi.StringOutput `pulumi:"patchId"`
	// Patch type, either "QUARTERLY", "TIMEZONE" or "CUSTOM_DATABASE_SOFTWARE_IMAGE".
	PatchType pulumi.StringOutput `pulumi:"patchType"`
	// The time when the patching operation ended.
	PatchingEndTime pulumi.StringOutput `pulumi:"patchingEndTime"`
	// (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
	//
	// *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
	PatchingMode pulumi.StringOutput `pulumi:"patchingMode"`
	// The time when the patching operation started.
	PatchingStartTime pulumi.StringOutput `pulumi:"patchingStartTime"`
	// The status of the patching operation.
	PatchingStatus pulumi.StringOutput `pulumi:"patchingStatus"`
	// The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance run for the Autonomous Data Guard association's peer container database.
	PeerMaintenanceRunId pulumi.StringOutput `pulumi:"peerMaintenanceRunId"`
	// The current state of the maintenance run. For Autonomous Database Serverless instances, valid states are IN_PROGRESS, SUCCEEDED, and FAILED.
	State pulumi.StringOutput `pulumi:"state"`
	// The target software version for the database server patching operation.
	TargetDbServerVersion pulumi.StringOutput `pulumi:"targetDbServerVersion"`
	// The ID of the target resource for which the maintenance run should be created.
	TargetResourceId pulumi.StringOutput `pulumi:"targetResourceId"`
	// The type of the target resource on which the maintenance run occurs.
	TargetResourceType pulumi.StringOutput `pulumi:"targetResourceType"`
	// The target Cell version that is to be patched to.
	TargetStorageServerVersion pulumi.StringOutput `pulumi:"targetStorageServerVersion"`
	// The date and time the maintenance run was completed.
	TimeEnded pulumi.StringOutput `pulumi:"timeEnded"`
	// (Updatable) The date and time that update should be scheduled.
	//
	// ** IMPORTANT **
	// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
	TimeScheduled pulumi.StringOutput `pulumi:"timeScheduled"`
	// The date and time the maintenance run starts.
	TimeStarted pulumi.StringOutput `pulumi:"timeStarted"`
	// The total time taken by corresponding resource activity in minutes.
	TotalTimeTakenInMins pulumi.IntOutput `pulumi:"totalTimeTakenInMins"`
}

// NewMaintenanceRun registers a new resource with the given unique name, arguments, and options.
func NewMaintenanceRun(ctx *pulumi.Context,
	name string, args *MaintenanceRunArgs, opts ...pulumi.ResourceOption) (*MaintenanceRun, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.PatchType == nil {
		return nil, errors.New("invalid value for required argument 'PatchType'")
	}
	if args.TargetResourceId == nil {
		return nil, errors.New("invalid value for required argument 'TargetResourceId'")
	}
	if args.TimeScheduled == nil {
		return nil, errors.New("invalid value for required argument 'TimeScheduled'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource MaintenanceRun
	err := ctx.RegisterResource("oci:Database/maintenanceRun:MaintenanceRun", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetMaintenanceRun gets an existing MaintenanceRun resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetMaintenanceRun(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *MaintenanceRunState, opts ...pulumi.ResourceOption) (*MaintenanceRun, error) {
	var resource MaintenanceRun
	err := ctx.ReadResource("oci:Database/maintenanceRun:MaintenanceRun", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering MaintenanceRun resources.
type maintenanceRunState struct {
	// The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment containing the Maintenance Run.
	CompartmentId *string `pulumi:"compartmentId"`
	// Extend current custom action timeout between the current database servers during waiting state, from 0 (zero) to 30 minutes.
	CurrentCustomActionTimeoutInMins *int `pulumi:"currentCustomActionTimeoutInMins"`
	// The name of the current infrastruture component that is getting patched.
	CurrentPatchingComponent *string `pulumi:"currentPatchingComponent"`
	// Determines the amount of time the system will wait before the start of each database server patching operation. Specify a number of minutes, from 15 to 120.
	CustomActionTimeoutInMins *int `pulumi:"customActionTimeoutInMins"`
	// The Autonomous Database Software Image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
	DatabaseSoftwareImageId *string `pulumi:"databaseSoftwareImageId"`
	// Description of the maintenance run.
	Description *string `pulumi:"description"`
	// The user-friendly name for the maintenance run.
	DisplayName *string `pulumi:"displayName"`
	// The estimated start time of the next infrastruture component patching operation.
	EstimatedComponentPatchingStartTime *string `pulumi:"estimatedComponentPatchingStartTime"`
	// The estimated total time required in minutes for all patching operations (database server, storage server, and network switch patching).
	EstimatedPatchingTimes []MaintenanceRunEstimatedPatchingTime `pulumi:"estimatedPatchingTimes"`
	// If true, enables the configuration of a custom action timeout (waiting period) between database servers patching operations.
	IsCustomActionTimeoutEnabled *bool `pulumi:"isCustomActionTimeoutEnabled"`
	// Indicates if an automatic DST Time Zone file update is enabled for the Autonomous Container Database. If enabled along with Release Update, patching will be done in a Non-Rolling manner.
	IsDstFileUpdateEnabled *bool `pulumi:"isDstFileUpdateEnabled"`
	// If `FALSE`, the maintenance run doesn't support granular maintenance.
	IsMaintenanceRunGranular *bool `pulumi:"isMaintenanceRunGranular"`
	// Additional information about the current lifecycle state.
	LifecycleDetails *string `pulumi:"lifecycleDetails"`
	// Maintenance sub-type.
	MaintenanceSubtype *string `pulumi:"maintenanceSubtype"`
	// Maintenance type.
	MaintenanceType *string `pulumi:"maintenanceType"`
	// Contain the patch failure count.
	PatchFailureCount *int `pulumi:"patchFailureCount"`
	// The unique identifier of the patch. The identifier string includes the patch type, the Oracle Database version, and the patch creation date (using the format YYMMDD). For example, the identifier `ru_patch_19.9.0.0_201030` is used for an RU patch for Oracle Database 19.9.0.0 that was released October 30, 2020.
	PatchId *string `pulumi:"patchId"`
	// Patch type, either "QUARTERLY", "TIMEZONE" or "CUSTOM_DATABASE_SOFTWARE_IMAGE".
	PatchType *string `pulumi:"patchType"`
	// The time when the patching operation ended.
	PatchingEndTime *string `pulumi:"patchingEndTime"`
	// (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
	//
	// *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
	PatchingMode *string `pulumi:"patchingMode"`
	// The time when the patching operation started.
	PatchingStartTime *string `pulumi:"patchingStartTime"`
	// The status of the patching operation.
	PatchingStatus *string `pulumi:"patchingStatus"`
	// The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance run for the Autonomous Data Guard association's peer container database.
	PeerMaintenanceRunId *string `pulumi:"peerMaintenanceRunId"`
	// The current state of the maintenance run. For Autonomous Database Serverless instances, valid states are IN_PROGRESS, SUCCEEDED, and FAILED.
	State *string `pulumi:"state"`
	// The target software version for the database server patching operation.
	TargetDbServerVersion *string `pulumi:"targetDbServerVersion"`
	// The ID of the target resource for which the maintenance run should be created.
	TargetResourceId *string `pulumi:"targetResourceId"`
	// The type of the target resource on which the maintenance run occurs.
	TargetResourceType *string `pulumi:"targetResourceType"`
	// The target Cell version that is to be patched to.
	TargetStorageServerVersion *string `pulumi:"targetStorageServerVersion"`
	// The date and time the maintenance run was completed.
	TimeEnded *string `pulumi:"timeEnded"`
	// (Updatable) The date and time that update should be scheduled.
	//
	// ** IMPORTANT **
	// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
	TimeScheduled *string `pulumi:"timeScheduled"`
	// The date and time the maintenance run starts.
	TimeStarted *string `pulumi:"timeStarted"`
	// The total time taken by corresponding resource activity in minutes.
	TotalTimeTakenInMins *int `pulumi:"totalTimeTakenInMins"`
}

type MaintenanceRunState struct {
	// The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment containing the Maintenance Run.
	CompartmentId pulumi.StringPtrInput
	// Extend current custom action timeout between the current database servers during waiting state, from 0 (zero) to 30 minutes.
	CurrentCustomActionTimeoutInMins pulumi.IntPtrInput
	// The name of the current infrastruture component that is getting patched.
	CurrentPatchingComponent pulumi.StringPtrInput
	// Determines the amount of time the system will wait before the start of each database server patching operation. Specify a number of minutes, from 15 to 120.
	CustomActionTimeoutInMins pulumi.IntPtrInput
	// The Autonomous Database Software Image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
	DatabaseSoftwareImageId pulumi.StringPtrInput
	// Description of the maintenance run.
	Description pulumi.StringPtrInput
	// The user-friendly name for the maintenance run.
	DisplayName pulumi.StringPtrInput
	// The estimated start time of the next infrastruture component patching operation.
	EstimatedComponentPatchingStartTime pulumi.StringPtrInput
	// The estimated total time required in minutes for all patching operations (database server, storage server, and network switch patching).
	EstimatedPatchingTimes MaintenanceRunEstimatedPatchingTimeArrayInput
	// If true, enables the configuration of a custom action timeout (waiting period) between database servers patching operations.
	IsCustomActionTimeoutEnabled pulumi.BoolPtrInput
	// Indicates if an automatic DST Time Zone file update is enabled for the Autonomous Container Database. If enabled along with Release Update, patching will be done in a Non-Rolling manner.
	IsDstFileUpdateEnabled pulumi.BoolPtrInput
	// If `FALSE`, the maintenance run doesn't support granular maintenance.
	IsMaintenanceRunGranular pulumi.BoolPtrInput
	// Additional information about the current lifecycle state.
	LifecycleDetails pulumi.StringPtrInput
	// Maintenance sub-type.
	MaintenanceSubtype pulumi.StringPtrInput
	// Maintenance type.
	MaintenanceType pulumi.StringPtrInput
	// Contain the patch failure count.
	PatchFailureCount pulumi.IntPtrInput
	// The unique identifier of the patch. The identifier string includes the patch type, the Oracle Database version, and the patch creation date (using the format YYMMDD). For example, the identifier `ru_patch_19.9.0.0_201030` is used for an RU patch for Oracle Database 19.9.0.0 that was released October 30, 2020.
	PatchId pulumi.StringPtrInput
	// Patch type, either "QUARTERLY", "TIMEZONE" or "CUSTOM_DATABASE_SOFTWARE_IMAGE".
	PatchType pulumi.StringPtrInput
	// The time when the patching operation ended.
	PatchingEndTime pulumi.StringPtrInput
	// (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
	//
	// *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
	PatchingMode pulumi.StringPtrInput
	// The time when the patching operation started.
	PatchingStartTime pulumi.StringPtrInput
	// The status of the patching operation.
	PatchingStatus pulumi.StringPtrInput
	// The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance run for the Autonomous Data Guard association's peer container database.
	PeerMaintenanceRunId pulumi.StringPtrInput
	// The current state of the maintenance run. For Autonomous Database Serverless instances, valid states are IN_PROGRESS, SUCCEEDED, and FAILED.
	State pulumi.StringPtrInput
	// The target software version for the database server patching operation.
	TargetDbServerVersion pulumi.StringPtrInput
	// The ID of the target resource for which the maintenance run should be created.
	TargetResourceId pulumi.StringPtrInput
	// The type of the target resource on which the maintenance run occurs.
	TargetResourceType pulumi.StringPtrInput
	// The target Cell version that is to be patched to.
	TargetStorageServerVersion pulumi.StringPtrInput
	// The date and time the maintenance run was completed.
	TimeEnded pulumi.StringPtrInput
	// (Updatable) The date and time that update should be scheduled.
	//
	// ** IMPORTANT **
	// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
	TimeScheduled pulumi.StringPtrInput
	// The date and time the maintenance run starts.
	TimeStarted pulumi.StringPtrInput
	// The total time taken by corresponding resource activity in minutes.
	TotalTimeTakenInMins pulumi.IntPtrInput
}

func (MaintenanceRunState) ElementType() reflect.Type {
	return reflect.TypeOf((*maintenanceRunState)(nil)).Elem()
}

type maintenanceRunArgs struct {
	// The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment containing the Maintenance Run.
	CompartmentId *string `pulumi:"compartmentId"`
	// The Autonomous Database Software Image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
	DatabaseSoftwareImageId *string `pulumi:"databaseSoftwareImageId"`
	// Indicates if an automatic DST Time Zone file update is enabled for the Autonomous Container Database. If enabled along with Release Update, patching will be done in a Non-Rolling manner.
	IsDstFileUpdateEnabled *bool `pulumi:"isDstFileUpdateEnabled"`
	// Patch type, either "QUARTERLY", "TIMEZONE" or "CUSTOM_DATABASE_SOFTWARE_IMAGE".
	PatchType string `pulumi:"patchType"`
	// (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
	//
	// *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
	PatchingMode *string `pulumi:"patchingMode"`
	// The ID of the target resource for which the maintenance run should be created.
	TargetResourceId string `pulumi:"targetResourceId"`
	// (Updatable) The date and time that update should be scheduled.
	//
	// ** IMPORTANT **
	// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
	TimeScheduled string `pulumi:"timeScheduled"`
}

// The set of arguments for constructing a MaintenanceRun resource.
type MaintenanceRunArgs struct {
	// The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment containing the Maintenance Run.
	CompartmentId pulumi.StringPtrInput
	// The Autonomous Database Software Image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
	DatabaseSoftwareImageId pulumi.StringPtrInput
	// Indicates if an automatic DST Time Zone file update is enabled for the Autonomous Container Database. If enabled along with Release Update, patching will be done in a Non-Rolling manner.
	IsDstFileUpdateEnabled pulumi.BoolPtrInput
	// Patch type, either "QUARTERLY", "TIMEZONE" or "CUSTOM_DATABASE_SOFTWARE_IMAGE".
	PatchType pulumi.StringInput
	// (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
	//
	// *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
	PatchingMode pulumi.StringPtrInput
	// The ID of the target resource for which the maintenance run should be created.
	TargetResourceId pulumi.StringInput
	// (Updatable) The date and time that update should be scheduled.
	//
	// ** IMPORTANT **
	// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
	TimeScheduled pulumi.StringInput
}

func (MaintenanceRunArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*maintenanceRunArgs)(nil)).Elem()
}

type MaintenanceRunInput interface {
	pulumi.Input

	ToMaintenanceRunOutput() MaintenanceRunOutput
	ToMaintenanceRunOutputWithContext(ctx context.Context) MaintenanceRunOutput
}

func (*MaintenanceRun) ElementType() reflect.Type {
	return reflect.TypeOf((**MaintenanceRun)(nil)).Elem()
}

func (i *MaintenanceRun) ToMaintenanceRunOutput() MaintenanceRunOutput {
	return i.ToMaintenanceRunOutputWithContext(context.Background())
}

func (i *MaintenanceRun) ToMaintenanceRunOutputWithContext(ctx context.Context) MaintenanceRunOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MaintenanceRunOutput)
}

// MaintenanceRunArrayInput is an input type that accepts MaintenanceRunArray and MaintenanceRunArrayOutput values.
// You can construct a concrete instance of `MaintenanceRunArrayInput` via:
//
//	MaintenanceRunArray{ MaintenanceRunArgs{...} }
type MaintenanceRunArrayInput interface {
	pulumi.Input

	ToMaintenanceRunArrayOutput() MaintenanceRunArrayOutput
	ToMaintenanceRunArrayOutputWithContext(context.Context) MaintenanceRunArrayOutput
}

type MaintenanceRunArray []MaintenanceRunInput

func (MaintenanceRunArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*MaintenanceRun)(nil)).Elem()
}

func (i MaintenanceRunArray) ToMaintenanceRunArrayOutput() MaintenanceRunArrayOutput {
	return i.ToMaintenanceRunArrayOutputWithContext(context.Background())
}

func (i MaintenanceRunArray) ToMaintenanceRunArrayOutputWithContext(ctx context.Context) MaintenanceRunArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MaintenanceRunArrayOutput)
}

// MaintenanceRunMapInput is an input type that accepts MaintenanceRunMap and MaintenanceRunMapOutput values.
// You can construct a concrete instance of `MaintenanceRunMapInput` via:
//
//	MaintenanceRunMap{ "key": MaintenanceRunArgs{...} }
type MaintenanceRunMapInput interface {
	pulumi.Input

	ToMaintenanceRunMapOutput() MaintenanceRunMapOutput
	ToMaintenanceRunMapOutputWithContext(context.Context) MaintenanceRunMapOutput
}

type MaintenanceRunMap map[string]MaintenanceRunInput

func (MaintenanceRunMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*MaintenanceRun)(nil)).Elem()
}

func (i MaintenanceRunMap) ToMaintenanceRunMapOutput() MaintenanceRunMapOutput {
	return i.ToMaintenanceRunMapOutputWithContext(context.Background())
}

func (i MaintenanceRunMap) ToMaintenanceRunMapOutputWithContext(ctx context.Context) MaintenanceRunMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MaintenanceRunMapOutput)
}

type MaintenanceRunOutput struct{ *pulumi.OutputState }

func (MaintenanceRunOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MaintenanceRun)(nil)).Elem()
}

func (o MaintenanceRunOutput) ToMaintenanceRunOutput() MaintenanceRunOutput {
	return o
}

func (o MaintenanceRunOutput) ToMaintenanceRunOutputWithContext(ctx context.Context) MaintenanceRunOutput {
	return o
}

// The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment containing the Maintenance Run.
func (o MaintenanceRunOutput) CompartmentId() pulumi.StringOutput {
	return o.ApplyT(func(v *MaintenanceRun) pulumi.StringOutput { return v.CompartmentId }).(pulumi.StringOutput)
}

// Extend current custom action timeout between the current database servers during waiting state, from 0 (zero) to 30 minutes.
func (o MaintenanceRunOutput) CurrentCustomActionTimeoutInMins() pulumi.IntOutput {
	return o.ApplyT(func(v *MaintenanceRun) pulumi.IntOutput { return v.CurrentCustomActionTimeoutInMins }).(pulumi.IntOutput)
}

// The name of the current infrastruture component that is getting patched.
func (o MaintenanceRunOutput) CurrentPatchingComponent() pulumi.StringOutput {
	return o.ApplyT(func(v *MaintenanceRun) pulumi.StringOutput { return v.CurrentPatchingComponent }).(pulumi.StringOutput)
}

// Determines the amount of time the system will wait before the start of each database server patching operation. Specify a number of minutes, from 15 to 120.
func (o MaintenanceRunOutput) CustomActionTimeoutInMins() pulumi.IntOutput {
	return o.ApplyT(func(v *MaintenanceRun) pulumi.IntOutput { return v.CustomActionTimeoutInMins }).(pulumi.IntOutput)
}

// The Autonomous Database Software Image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
func (o MaintenanceRunOutput) DatabaseSoftwareImageId() pulumi.StringOutput {
	return o.ApplyT(func(v *MaintenanceRun) pulumi.StringOutput { return v.DatabaseSoftwareImageId }).(pulumi.StringOutput)
}

// Description of the maintenance run.
func (o MaintenanceRunOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v *MaintenanceRun) pulumi.StringOutput { return v.Description }).(pulumi.StringOutput)
}

// The user-friendly name for the maintenance run.
func (o MaintenanceRunOutput) DisplayName() pulumi.StringOutput {
	return o.ApplyT(func(v *MaintenanceRun) pulumi.StringOutput { return v.DisplayName }).(pulumi.StringOutput)
}

// The estimated start time of the next infrastruture component patching operation.
func (o MaintenanceRunOutput) EstimatedComponentPatchingStartTime() pulumi.StringOutput {
	return o.ApplyT(func(v *MaintenanceRun) pulumi.StringOutput { return v.EstimatedComponentPatchingStartTime }).(pulumi.StringOutput)
}

// The estimated total time required in minutes for all patching operations (database server, storage server, and network switch patching).
func (o MaintenanceRunOutput) EstimatedPatchingTimes() MaintenanceRunEstimatedPatchingTimeArrayOutput {
	return o.ApplyT(func(v *MaintenanceRun) MaintenanceRunEstimatedPatchingTimeArrayOutput {
		return v.EstimatedPatchingTimes
	}).(MaintenanceRunEstimatedPatchingTimeArrayOutput)
}

// If true, enables the configuration of a custom action timeout (waiting period) between database servers patching operations.
func (o MaintenanceRunOutput) IsCustomActionTimeoutEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *MaintenanceRun) pulumi.BoolOutput { return v.IsCustomActionTimeoutEnabled }).(pulumi.BoolOutput)
}

// Indicates if an automatic DST Time Zone file update is enabled for the Autonomous Container Database. If enabled along with Release Update, patching will be done in a Non-Rolling manner.
func (o MaintenanceRunOutput) IsDstFileUpdateEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *MaintenanceRun) pulumi.BoolOutput { return v.IsDstFileUpdateEnabled }).(pulumi.BoolOutput)
}

// If `FALSE`, the maintenance run doesn't support granular maintenance.
func (o MaintenanceRunOutput) IsMaintenanceRunGranular() pulumi.BoolOutput {
	return o.ApplyT(func(v *MaintenanceRun) pulumi.BoolOutput { return v.IsMaintenanceRunGranular }).(pulumi.BoolOutput)
}

// Additional information about the current lifecycle state.
func (o MaintenanceRunOutput) LifecycleDetails() pulumi.StringOutput {
	return o.ApplyT(func(v *MaintenanceRun) pulumi.StringOutput { return v.LifecycleDetails }).(pulumi.StringOutput)
}

// Maintenance sub-type.
func (o MaintenanceRunOutput) MaintenanceSubtype() pulumi.StringOutput {
	return o.ApplyT(func(v *MaintenanceRun) pulumi.StringOutput { return v.MaintenanceSubtype }).(pulumi.StringOutput)
}

// Maintenance type.
func (o MaintenanceRunOutput) MaintenanceType() pulumi.StringOutput {
	return o.ApplyT(func(v *MaintenanceRun) pulumi.StringOutput { return v.MaintenanceType }).(pulumi.StringOutput)
}

// Contain the patch failure count.
func (o MaintenanceRunOutput) PatchFailureCount() pulumi.IntOutput {
	return o.ApplyT(func(v *MaintenanceRun) pulumi.IntOutput { return v.PatchFailureCount }).(pulumi.IntOutput)
}

// The unique identifier of the patch. The identifier string includes the patch type, the Oracle Database version, and the patch creation date (using the format YYMMDD). For example, the identifier `ru_patch_19.9.0.0_201030` is used for an RU patch for Oracle Database 19.9.0.0 that was released October 30, 2020.
func (o MaintenanceRunOutput) PatchId() pulumi.StringOutput {
	return o.ApplyT(func(v *MaintenanceRun) pulumi.StringOutput { return v.PatchId }).(pulumi.StringOutput)
}

// Patch type, either "QUARTERLY", "TIMEZONE" or "CUSTOM_DATABASE_SOFTWARE_IMAGE".
func (o MaintenanceRunOutput) PatchType() pulumi.StringOutput {
	return o.ApplyT(func(v *MaintenanceRun) pulumi.StringOutput { return v.PatchType }).(pulumi.StringOutput)
}

// The time when the patching operation ended.
func (o MaintenanceRunOutput) PatchingEndTime() pulumi.StringOutput {
	return o.ApplyT(func(v *MaintenanceRun) pulumi.StringOutput { return v.PatchingEndTime }).(pulumi.StringOutput)
}

// (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
//
// *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
func (o MaintenanceRunOutput) PatchingMode() pulumi.StringOutput {
	return o.ApplyT(func(v *MaintenanceRun) pulumi.StringOutput { return v.PatchingMode }).(pulumi.StringOutput)
}

// The time when the patching operation started.
func (o MaintenanceRunOutput) PatchingStartTime() pulumi.StringOutput {
	return o.ApplyT(func(v *MaintenanceRun) pulumi.StringOutput { return v.PatchingStartTime }).(pulumi.StringOutput)
}

// The status of the patching operation.
func (o MaintenanceRunOutput) PatchingStatus() pulumi.StringOutput {
	return o.ApplyT(func(v *MaintenanceRun) pulumi.StringOutput { return v.PatchingStatus }).(pulumi.StringOutput)
}

// The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance run for the Autonomous Data Guard association's peer container database.
func (o MaintenanceRunOutput) PeerMaintenanceRunId() pulumi.StringOutput {
	return o.ApplyT(func(v *MaintenanceRun) pulumi.StringOutput { return v.PeerMaintenanceRunId }).(pulumi.StringOutput)
}

// The current state of the maintenance run. For Autonomous Database Serverless instances, valid states are IN_PROGRESS, SUCCEEDED, and FAILED.
func (o MaintenanceRunOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v *MaintenanceRun) pulumi.StringOutput { return v.State }).(pulumi.StringOutput)
}

// The target software version for the database server patching operation.
func (o MaintenanceRunOutput) TargetDbServerVersion() pulumi.StringOutput {
	return o.ApplyT(func(v *MaintenanceRun) pulumi.StringOutput { return v.TargetDbServerVersion }).(pulumi.StringOutput)
}

// The ID of the target resource for which the maintenance run should be created.
func (o MaintenanceRunOutput) TargetResourceId() pulumi.StringOutput {
	return o.ApplyT(func(v *MaintenanceRun) pulumi.StringOutput { return v.TargetResourceId }).(pulumi.StringOutput)
}

// The type of the target resource on which the maintenance run occurs.
func (o MaintenanceRunOutput) TargetResourceType() pulumi.StringOutput {
	return o.ApplyT(func(v *MaintenanceRun) pulumi.StringOutput { return v.TargetResourceType }).(pulumi.StringOutput)
}

// The target Cell version that is to be patched to.
func (o MaintenanceRunOutput) TargetStorageServerVersion() pulumi.StringOutput {
	return o.ApplyT(func(v *MaintenanceRun) pulumi.StringOutput { return v.TargetStorageServerVersion }).(pulumi.StringOutput)
}

// The date and time the maintenance run was completed.
func (o MaintenanceRunOutput) TimeEnded() pulumi.StringOutput {
	return o.ApplyT(func(v *MaintenanceRun) pulumi.StringOutput { return v.TimeEnded }).(pulumi.StringOutput)
}

// (Updatable) The date and time that update should be scheduled.
//
// ** IMPORTANT **
// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
func (o MaintenanceRunOutput) TimeScheduled() pulumi.StringOutput {
	return o.ApplyT(func(v *MaintenanceRun) pulumi.StringOutput { return v.TimeScheduled }).(pulumi.StringOutput)
}

// The date and time the maintenance run starts.
func (o MaintenanceRunOutput) TimeStarted() pulumi.StringOutput {
	return o.ApplyT(func(v *MaintenanceRun) pulumi.StringOutput { return v.TimeStarted }).(pulumi.StringOutput)
}

// The total time taken by corresponding resource activity in minutes.
func (o MaintenanceRunOutput) TotalTimeTakenInMins() pulumi.IntOutput {
	return o.ApplyT(func(v *MaintenanceRun) pulumi.IntOutput { return v.TotalTimeTakenInMins }).(pulumi.IntOutput)
}

type MaintenanceRunArrayOutput struct{ *pulumi.OutputState }

func (MaintenanceRunArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*MaintenanceRun)(nil)).Elem()
}

func (o MaintenanceRunArrayOutput) ToMaintenanceRunArrayOutput() MaintenanceRunArrayOutput {
	return o
}

func (o MaintenanceRunArrayOutput) ToMaintenanceRunArrayOutputWithContext(ctx context.Context) MaintenanceRunArrayOutput {
	return o
}

func (o MaintenanceRunArrayOutput) Index(i pulumi.IntInput) MaintenanceRunOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *MaintenanceRun {
		return vs[0].([]*MaintenanceRun)[vs[1].(int)]
	}).(MaintenanceRunOutput)
}

type MaintenanceRunMapOutput struct{ *pulumi.OutputState }

func (MaintenanceRunMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*MaintenanceRun)(nil)).Elem()
}

func (o MaintenanceRunMapOutput) ToMaintenanceRunMapOutput() MaintenanceRunMapOutput {
	return o
}

func (o MaintenanceRunMapOutput) ToMaintenanceRunMapOutputWithContext(ctx context.Context) MaintenanceRunMapOutput {
	return o
}

func (o MaintenanceRunMapOutput) MapIndex(k pulumi.StringInput) MaintenanceRunOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *MaintenanceRun {
		return vs[0].(map[string]*MaintenanceRun)[vs[1].(string)]
	}).(MaintenanceRunOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*MaintenanceRunInput)(nil)).Elem(), &MaintenanceRun{})
	pulumi.RegisterInputType(reflect.TypeOf((*MaintenanceRunArrayInput)(nil)).Elem(), MaintenanceRunArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*MaintenanceRunMapInput)(nil)).Elem(), MaintenanceRunMap{})
	pulumi.RegisterOutputType(MaintenanceRunOutput{})
	pulumi.RegisterOutputType(MaintenanceRunArrayOutput{})
	pulumi.RegisterOutputType(MaintenanceRunMapOutput{})
}
