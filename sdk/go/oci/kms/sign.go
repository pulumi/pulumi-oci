// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package kms

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// This resource provides the Sign resource in Oracle Cloud Infrastructure Kms service.
//
// Creates a digital signature for a message or message digest by using the private key of a public-private key pair,
// also known as an asymmetric key. To verify the generated signature, you can use the [Verify](https://docs.cloud.oracle.com/iaas/api/#/en/key/latest/VerifiedData/Verify)
// operation. Or, if you want to validate the signature outside of the service, you can do so by using the public key of the same asymmetric key.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-oci/sdk/go/oci/Kms"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := Kms.NewSign(ctx, "testSign", &Kms.SignArgs{
//				CryptoEndpoint:   pulumi.Any(_var.Sign_message_crypto_endpoint),
//				KeyId:            pulumi.Any(oci_kms_key.Test_key.Id),
//				Message:          pulumi.Any(_var.Sign_message),
//				SigningAlgorithm: pulumi.Any(_var.Sign_signing_algorithm),
//				KeyVersionId:     pulumi.Any(oci_kms_key_version.Test_key_version.Id),
//				MessageType:      pulumi.Any(_var.Sign_message_type),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Sign can be imported using the `id`, e.g.
//
// ```sh
//
//	$ pulumi import oci:Kms/sign:Sign test_sign "id"
//
// ```
type Sign struct {
	pulumi.CustomResourceState

	// The service endpoint to perform cryptographic operations against. Cryptographic operations include 'Encrypt,' 'Decrypt,', 'GenerateDataEncryptionKey', 'Sign' and 'Verify' operations. see Vault Crypto endpoint.
	CryptoEndpoint pulumi.StringOutput `pulumi:"cryptoEndpoint"`
	// The OCID of the key used to sign the message.
	KeyId pulumi.StringOutput `pulumi:"keyId"`
	// The OCID of the key version used to sign the message.
	KeyVersionId pulumi.StringOutput `pulumi:"keyVersionId"`
	// The base64-encoded binary data object denoting the message or message digest to sign. You can have a message up to 4096 bytes in size. To sign a larger message, provide the message digest.
	Message pulumi.StringOutput `pulumi:"message"`
	// Denotes whether the value of the message parameter is a raw message or a message digest.  The default value, `RAW`, indicates a message. To indicate a message digest, use `DIGEST`.
	MessageType pulumi.StringOutput `pulumi:"messageType"`
	// The base64-encoded binary data object denoting the cryptographic signature generated for the message or message digest.
	Signature pulumi.StringOutput `pulumi:"signature"`
	// The algorithm to use to sign the message or message digest. For RSA keys, supported signature schemes include PKCS #1 and RSASSA-PSS, along with  different hashing algorithms.  For ECDSA keys, ECDSA is the supported signature scheme with different hashing algorithms. When you pass a message digest for signing, ensure that you specify the same hashing algorithm  as used when creating the message digest.
	SigningAlgorithm pulumi.StringOutput `pulumi:"signingAlgorithm"`
}

// NewSign registers a new resource with the given unique name, arguments, and options.
func NewSign(ctx *pulumi.Context,
	name string, args *SignArgs, opts ...pulumi.ResourceOption) (*Sign, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.CryptoEndpoint == nil {
		return nil, errors.New("invalid value for required argument 'CryptoEndpoint'")
	}
	if args.KeyId == nil {
		return nil, errors.New("invalid value for required argument 'KeyId'")
	}
	if args.Message == nil {
		return nil, errors.New("invalid value for required argument 'Message'")
	}
	if args.SigningAlgorithm == nil {
		return nil, errors.New("invalid value for required argument 'SigningAlgorithm'")
	}
	var resource Sign
	err := ctx.RegisterResource("oci:Kms/sign:Sign", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSign gets an existing Sign resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSign(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SignState, opts ...pulumi.ResourceOption) (*Sign, error) {
	var resource Sign
	err := ctx.ReadResource("oci:Kms/sign:Sign", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Sign resources.
type signState struct {
	// The service endpoint to perform cryptographic operations against. Cryptographic operations include 'Encrypt,' 'Decrypt,', 'GenerateDataEncryptionKey', 'Sign' and 'Verify' operations. see Vault Crypto endpoint.
	CryptoEndpoint *string `pulumi:"cryptoEndpoint"`
	// The OCID of the key used to sign the message.
	KeyId *string `pulumi:"keyId"`
	// The OCID of the key version used to sign the message.
	KeyVersionId *string `pulumi:"keyVersionId"`
	// The base64-encoded binary data object denoting the message or message digest to sign. You can have a message up to 4096 bytes in size. To sign a larger message, provide the message digest.
	Message *string `pulumi:"message"`
	// Denotes whether the value of the message parameter is a raw message or a message digest.  The default value, `RAW`, indicates a message. To indicate a message digest, use `DIGEST`.
	MessageType *string `pulumi:"messageType"`
	// The base64-encoded binary data object denoting the cryptographic signature generated for the message or message digest.
	Signature *string `pulumi:"signature"`
	// The algorithm to use to sign the message or message digest. For RSA keys, supported signature schemes include PKCS #1 and RSASSA-PSS, along with  different hashing algorithms.  For ECDSA keys, ECDSA is the supported signature scheme with different hashing algorithms. When you pass a message digest for signing, ensure that you specify the same hashing algorithm  as used when creating the message digest.
	SigningAlgorithm *string `pulumi:"signingAlgorithm"`
}

type SignState struct {
	// The service endpoint to perform cryptographic operations against. Cryptographic operations include 'Encrypt,' 'Decrypt,', 'GenerateDataEncryptionKey', 'Sign' and 'Verify' operations. see Vault Crypto endpoint.
	CryptoEndpoint pulumi.StringPtrInput
	// The OCID of the key used to sign the message.
	KeyId pulumi.StringPtrInput
	// The OCID of the key version used to sign the message.
	KeyVersionId pulumi.StringPtrInput
	// The base64-encoded binary data object denoting the message or message digest to sign. You can have a message up to 4096 bytes in size. To sign a larger message, provide the message digest.
	Message pulumi.StringPtrInput
	// Denotes whether the value of the message parameter is a raw message or a message digest.  The default value, `RAW`, indicates a message. To indicate a message digest, use `DIGEST`.
	MessageType pulumi.StringPtrInput
	// The base64-encoded binary data object denoting the cryptographic signature generated for the message or message digest.
	Signature pulumi.StringPtrInput
	// The algorithm to use to sign the message or message digest. For RSA keys, supported signature schemes include PKCS #1 and RSASSA-PSS, along with  different hashing algorithms.  For ECDSA keys, ECDSA is the supported signature scheme with different hashing algorithms. When you pass a message digest for signing, ensure that you specify the same hashing algorithm  as used when creating the message digest.
	SigningAlgorithm pulumi.StringPtrInput
}

func (SignState) ElementType() reflect.Type {
	return reflect.TypeOf((*signState)(nil)).Elem()
}

type signArgs struct {
	// The service endpoint to perform cryptographic operations against. Cryptographic operations include 'Encrypt,' 'Decrypt,', 'GenerateDataEncryptionKey', 'Sign' and 'Verify' operations. see Vault Crypto endpoint.
	CryptoEndpoint string `pulumi:"cryptoEndpoint"`
	// The OCID of the key used to sign the message.
	KeyId string `pulumi:"keyId"`
	// The OCID of the key version used to sign the message.
	KeyVersionId *string `pulumi:"keyVersionId"`
	// The base64-encoded binary data object denoting the message or message digest to sign. You can have a message up to 4096 bytes in size. To sign a larger message, provide the message digest.
	Message string `pulumi:"message"`
	// Denotes whether the value of the message parameter is a raw message or a message digest.  The default value, `RAW`, indicates a message. To indicate a message digest, use `DIGEST`.
	MessageType *string `pulumi:"messageType"`
	// The algorithm to use to sign the message or message digest. For RSA keys, supported signature schemes include PKCS #1 and RSASSA-PSS, along with  different hashing algorithms.  For ECDSA keys, ECDSA is the supported signature scheme with different hashing algorithms. When you pass a message digest for signing, ensure that you specify the same hashing algorithm  as used when creating the message digest.
	SigningAlgorithm string `pulumi:"signingAlgorithm"`
}

// The set of arguments for constructing a Sign resource.
type SignArgs struct {
	// The service endpoint to perform cryptographic operations against. Cryptographic operations include 'Encrypt,' 'Decrypt,', 'GenerateDataEncryptionKey', 'Sign' and 'Verify' operations. see Vault Crypto endpoint.
	CryptoEndpoint pulumi.StringInput
	// The OCID of the key used to sign the message.
	KeyId pulumi.StringInput
	// The OCID of the key version used to sign the message.
	KeyVersionId pulumi.StringPtrInput
	// The base64-encoded binary data object denoting the message or message digest to sign. You can have a message up to 4096 bytes in size. To sign a larger message, provide the message digest.
	Message pulumi.StringInput
	// Denotes whether the value of the message parameter is a raw message or a message digest.  The default value, `RAW`, indicates a message. To indicate a message digest, use `DIGEST`.
	MessageType pulumi.StringPtrInput
	// The algorithm to use to sign the message or message digest. For RSA keys, supported signature schemes include PKCS #1 and RSASSA-PSS, along with  different hashing algorithms.  For ECDSA keys, ECDSA is the supported signature scheme with different hashing algorithms. When you pass a message digest for signing, ensure that you specify the same hashing algorithm  as used when creating the message digest.
	SigningAlgorithm pulumi.StringInput
}

func (SignArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*signArgs)(nil)).Elem()
}

type SignInput interface {
	pulumi.Input

	ToSignOutput() SignOutput
	ToSignOutputWithContext(ctx context.Context) SignOutput
}

func (*Sign) ElementType() reflect.Type {
	return reflect.TypeOf((**Sign)(nil)).Elem()
}

func (i *Sign) ToSignOutput() SignOutput {
	return i.ToSignOutputWithContext(context.Background())
}

func (i *Sign) ToSignOutputWithContext(ctx context.Context) SignOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SignOutput)
}

// SignArrayInput is an input type that accepts SignArray and SignArrayOutput values.
// You can construct a concrete instance of `SignArrayInput` via:
//
//	SignArray{ SignArgs{...} }
type SignArrayInput interface {
	pulumi.Input

	ToSignArrayOutput() SignArrayOutput
	ToSignArrayOutputWithContext(context.Context) SignArrayOutput
}

type SignArray []SignInput

func (SignArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Sign)(nil)).Elem()
}

func (i SignArray) ToSignArrayOutput() SignArrayOutput {
	return i.ToSignArrayOutputWithContext(context.Background())
}

func (i SignArray) ToSignArrayOutputWithContext(ctx context.Context) SignArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SignArrayOutput)
}

// SignMapInput is an input type that accepts SignMap and SignMapOutput values.
// You can construct a concrete instance of `SignMapInput` via:
//
//	SignMap{ "key": SignArgs{...} }
type SignMapInput interface {
	pulumi.Input

	ToSignMapOutput() SignMapOutput
	ToSignMapOutputWithContext(context.Context) SignMapOutput
}

type SignMap map[string]SignInput

func (SignMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Sign)(nil)).Elem()
}

func (i SignMap) ToSignMapOutput() SignMapOutput {
	return i.ToSignMapOutputWithContext(context.Background())
}

func (i SignMap) ToSignMapOutputWithContext(ctx context.Context) SignMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SignMapOutput)
}

type SignOutput struct{ *pulumi.OutputState }

func (SignOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Sign)(nil)).Elem()
}

func (o SignOutput) ToSignOutput() SignOutput {
	return o
}

func (o SignOutput) ToSignOutputWithContext(ctx context.Context) SignOutput {
	return o
}

// The service endpoint to perform cryptographic operations against. Cryptographic operations include 'Encrypt,' 'Decrypt,', 'GenerateDataEncryptionKey', 'Sign' and 'Verify' operations. see Vault Crypto endpoint.
func (o SignOutput) CryptoEndpoint() pulumi.StringOutput {
	return o.ApplyT(func(v *Sign) pulumi.StringOutput { return v.CryptoEndpoint }).(pulumi.StringOutput)
}

// The OCID of the key used to sign the message.
func (o SignOutput) KeyId() pulumi.StringOutput {
	return o.ApplyT(func(v *Sign) pulumi.StringOutput { return v.KeyId }).(pulumi.StringOutput)
}

// The OCID of the key version used to sign the message.
func (o SignOutput) KeyVersionId() pulumi.StringOutput {
	return o.ApplyT(func(v *Sign) pulumi.StringOutput { return v.KeyVersionId }).(pulumi.StringOutput)
}

// The base64-encoded binary data object denoting the message or message digest to sign. You can have a message up to 4096 bytes in size. To sign a larger message, provide the message digest.
func (o SignOutput) Message() pulumi.StringOutput {
	return o.ApplyT(func(v *Sign) pulumi.StringOutput { return v.Message }).(pulumi.StringOutput)
}

// Denotes whether the value of the message parameter is a raw message or a message digest.  The default value, `RAW`, indicates a message. To indicate a message digest, use `DIGEST`.
func (o SignOutput) MessageType() pulumi.StringOutput {
	return o.ApplyT(func(v *Sign) pulumi.StringOutput { return v.MessageType }).(pulumi.StringOutput)
}

// The base64-encoded binary data object denoting the cryptographic signature generated for the message or message digest.
func (o SignOutput) Signature() pulumi.StringOutput {
	return o.ApplyT(func(v *Sign) pulumi.StringOutput { return v.Signature }).(pulumi.StringOutput)
}

// The algorithm to use to sign the message or message digest. For RSA keys, supported signature schemes include PKCS #1 and RSASSA-PSS, along with  different hashing algorithms.  For ECDSA keys, ECDSA is the supported signature scheme with different hashing algorithms. When you pass a message digest for signing, ensure that you specify the same hashing algorithm  as used when creating the message digest.
func (o SignOutput) SigningAlgorithm() pulumi.StringOutput {
	return o.ApplyT(func(v *Sign) pulumi.StringOutput { return v.SigningAlgorithm }).(pulumi.StringOutput)
}

type SignArrayOutput struct{ *pulumi.OutputState }

func (SignArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Sign)(nil)).Elem()
}

func (o SignArrayOutput) ToSignArrayOutput() SignArrayOutput {
	return o
}

func (o SignArrayOutput) ToSignArrayOutputWithContext(ctx context.Context) SignArrayOutput {
	return o
}

func (o SignArrayOutput) Index(i pulumi.IntInput) SignOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Sign {
		return vs[0].([]*Sign)[vs[1].(int)]
	}).(SignOutput)
}

type SignMapOutput struct{ *pulumi.OutputState }

func (SignMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Sign)(nil)).Elem()
}

func (o SignMapOutput) ToSignMapOutput() SignMapOutput {
	return o
}

func (o SignMapOutput) ToSignMapOutputWithContext(ctx context.Context) SignMapOutput {
	return o
}

func (o SignMapOutput) MapIndex(k pulumi.StringInput) SignOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Sign {
		return vs[0].(map[string]*Sign)[vs[1].(string)]
	}).(SignOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SignInput)(nil)).Elem(), &Sign{})
	pulumi.RegisterInputType(reflect.TypeOf((*SignArrayInput)(nil)).Elem(), SignArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SignMapInput)(nil)).Elem(), SignMap{})
	pulumi.RegisterOutputType(SignOutput{})
	pulumi.RegisterOutputType(SignArrayOutput{})
	pulumi.RegisterOutputType(SignMapOutput{})
}
