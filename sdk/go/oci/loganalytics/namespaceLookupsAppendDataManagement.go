// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package loganalytics

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-oci/sdk/v3/go/oci/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// This resource provides the Namespace Lookups Append Data Management resource in Oracle Cloud Infrastructure Log Analytics service.
//
// Appends data to the lookup content. The csv file containing the content to be appended is passed in as binary data in the request.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-oci/sdk/v3/go/oci/loganalytics"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := loganalytics.NewNamespaceLookupsAppendDataManagement(ctx, "test_namespace_lookups_append_data_management", &loganalytics.NamespaceLookupsAppendDataManagementArgs{
//				AppendLookupFileBody: namespaceLookupsAppendDataManagementAppendLookupFileBody,
//				LookupName:           pulumi.Any(namespaceLookupsAppendDataManagementLookupName),
//				Namespace:            pulumi.Any(namespaceLookupsAppendDataManagementNamespace),
//				CharEncoding:         pulumi.Any(namespaceLookupsAppendDataManagementCharEncoding),
//				Expect:               pulumi.Any(namespaceLookupsAppendDataManagementExpect),
//				IsForce:              pulumi.Any(namespaceLookupsAppendDataManagementIsForce),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Import is not supported for NamespaceLookupsAppendDataManagement
type NamespaceLookupsAppendDataManagement struct {
	pulumi.CustomResourceState

	AppendLookupFile pulumi.StringOutput `pulumi:"appendLookupFile"`
	// The character encoding of the uploaded file.
	CharEncoding pulumi.StringOutput `pulumi:"charEncoding"`
	// A value of `100-continue` requests preliminary verification of the request method, path, and headers before the request body is sent. If no error results from such verification, the server will send a 100 (Continue) interim response to indicate readiness for the request body. The only allowed value for this parameter is "100-Continue" (case-insensitive).
	Expect pulumi.StringOutput `pulumi:"expect"`
	// is force
	IsForce pulumi.BoolOutput `pulumi:"isForce"`
	// The name of the lookup to operate on.
	LookupName pulumi.StringOutput `pulumi:"lookupName"`
	// The Logging Analytics namespace used for the request.
	//
	// ** IMPORTANT **
	// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
	Namespace pulumi.StringOutput `pulumi:"namespace"`
}

// NewNamespaceLookupsAppendDataManagement registers a new resource with the given unique name, arguments, and options.
func NewNamespaceLookupsAppendDataManagement(ctx *pulumi.Context,
	name string, args *NamespaceLookupsAppendDataManagementArgs, opts ...pulumi.ResourceOption) (*NamespaceLookupsAppendDataManagement, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AppendLookupFile == nil {
		return nil, errors.New("invalid value for required argument 'AppendLookupFile'")
	}
	if args.LookupName == nil {
		return nil, errors.New("invalid value for required argument 'LookupName'")
	}
	if args.Namespace == nil {
		return nil, errors.New("invalid value for required argument 'Namespace'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource NamespaceLookupsAppendDataManagement
	err := ctx.RegisterResource("oci:LogAnalytics/namespaceLookupsAppendDataManagement:NamespaceLookupsAppendDataManagement", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetNamespaceLookupsAppendDataManagement gets an existing NamespaceLookupsAppendDataManagement resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetNamespaceLookupsAppendDataManagement(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *NamespaceLookupsAppendDataManagementState, opts ...pulumi.ResourceOption) (*NamespaceLookupsAppendDataManagement, error) {
	var resource NamespaceLookupsAppendDataManagement
	err := ctx.ReadResource("oci:LogAnalytics/namespaceLookupsAppendDataManagement:NamespaceLookupsAppendDataManagement", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering NamespaceLookupsAppendDataManagement resources.
type namespaceLookupsAppendDataManagementState struct {
	AppendLookupFile *string `pulumi:"appendLookupFile"`
	// The character encoding of the uploaded file.
	CharEncoding *string `pulumi:"charEncoding"`
	// A value of `100-continue` requests preliminary verification of the request method, path, and headers before the request body is sent. If no error results from such verification, the server will send a 100 (Continue) interim response to indicate readiness for the request body. The only allowed value for this parameter is "100-Continue" (case-insensitive).
	Expect *string `pulumi:"expect"`
	// is force
	IsForce *bool `pulumi:"isForce"`
	// The name of the lookup to operate on.
	LookupName *string `pulumi:"lookupName"`
	// The Logging Analytics namespace used for the request.
	//
	// ** IMPORTANT **
	// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
	Namespace *string `pulumi:"namespace"`
}

type NamespaceLookupsAppendDataManagementState struct {
	AppendLookupFile pulumi.StringPtrInput
	// The character encoding of the uploaded file.
	CharEncoding pulumi.StringPtrInput
	// A value of `100-continue` requests preliminary verification of the request method, path, and headers before the request body is sent. If no error results from such verification, the server will send a 100 (Continue) interim response to indicate readiness for the request body. The only allowed value for this parameter is "100-Continue" (case-insensitive).
	Expect pulumi.StringPtrInput
	// is force
	IsForce pulumi.BoolPtrInput
	// The name of the lookup to operate on.
	LookupName pulumi.StringPtrInput
	// The Logging Analytics namespace used for the request.
	//
	// ** IMPORTANT **
	// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
	Namespace pulumi.StringPtrInput
}

func (NamespaceLookupsAppendDataManagementState) ElementType() reflect.Type {
	return reflect.TypeOf((*namespaceLookupsAppendDataManagementState)(nil)).Elem()
}

type namespaceLookupsAppendDataManagementArgs struct {
	AppendLookupFile string `pulumi:"appendLookupFile"`
	// The character encoding of the uploaded file.
	CharEncoding *string `pulumi:"charEncoding"`
	// A value of `100-continue` requests preliminary verification of the request method, path, and headers before the request body is sent. If no error results from such verification, the server will send a 100 (Continue) interim response to indicate readiness for the request body. The only allowed value for this parameter is "100-Continue" (case-insensitive).
	Expect *string `pulumi:"expect"`
	// is force
	IsForce *bool `pulumi:"isForce"`
	// The name of the lookup to operate on.
	LookupName string `pulumi:"lookupName"`
	// The Logging Analytics namespace used for the request.
	//
	// ** IMPORTANT **
	// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
	Namespace string `pulumi:"namespace"`
}

// The set of arguments for constructing a NamespaceLookupsAppendDataManagement resource.
type NamespaceLookupsAppendDataManagementArgs struct {
	AppendLookupFile pulumi.StringInput
	// The character encoding of the uploaded file.
	CharEncoding pulumi.StringPtrInput
	// A value of `100-continue` requests preliminary verification of the request method, path, and headers before the request body is sent. If no error results from such verification, the server will send a 100 (Continue) interim response to indicate readiness for the request body. The only allowed value for this parameter is "100-Continue" (case-insensitive).
	Expect pulumi.StringPtrInput
	// is force
	IsForce pulumi.BoolPtrInput
	// The name of the lookup to operate on.
	LookupName pulumi.StringInput
	// The Logging Analytics namespace used for the request.
	//
	// ** IMPORTANT **
	// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
	Namespace pulumi.StringInput
}

func (NamespaceLookupsAppendDataManagementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*namespaceLookupsAppendDataManagementArgs)(nil)).Elem()
}

type NamespaceLookupsAppendDataManagementInput interface {
	pulumi.Input

	ToNamespaceLookupsAppendDataManagementOutput() NamespaceLookupsAppendDataManagementOutput
	ToNamespaceLookupsAppendDataManagementOutputWithContext(ctx context.Context) NamespaceLookupsAppendDataManagementOutput
}

func (*NamespaceLookupsAppendDataManagement) ElementType() reflect.Type {
	return reflect.TypeOf((**NamespaceLookupsAppendDataManagement)(nil)).Elem()
}

func (i *NamespaceLookupsAppendDataManagement) ToNamespaceLookupsAppendDataManagementOutput() NamespaceLookupsAppendDataManagementOutput {
	return i.ToNamespaceLookupsAppendDataManagementOutputWithContext(context.Background())
}

func (i *NamespaceLookupsAppendDataManagement) ToNamespaceLookupsAppendDataManagementOutputWithContext(ctx context.Context) NamespaceLookupsAppendDataManagementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceLookupsAppendDataManagementOutput)
}

// NamespaceLookupsAppendDataManagementArrayInput is an input type that accepts NamespaceLookupsAppendDataManagementArray and NamespaceLookupsAppendDataManagementArrayOutput values.
// You can construct a concrete instance of `NamespaceLookupsAppendDataManagementArrayInput` via:
//
//	NamespaceLookupsAppendDataManagementArray{ NamespaceLookupsAppendDataManagementArgs{...} }
type NamespaceLookupsAppendDataManagementArrayInput interface {
	pulumi.Input

	ToNamespaceLookupsAppendDataManagementArrayOutput() NamespaceLookupsAppendDataManagementArrayOutput
	ToNamespaceLookupsAppendDataManagementArrayOutputWithContext(context.Context) NamespaceLookupsAppendDataManagementArrayOutput
}

type NamespaceLookupsAppendDataManagementArray []NamespaceLookupsAppendDataManagementInput

func (NamespaceLookupsAppendDataManagementArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NamespaceLookupsAppendDataManagement)(nil)).Elem()
}

func (i NamespaceLookupsAppendDataManagementArray) ToNamespaceLookupsAppendDataManagementArrayOutput() NamespaceLookupsAppendDataManagementArrayOutput {
	return i.ToNamespaceLookupsAppendDataManagementArrayOutputWithContext(context.Background())
}

func (i NamespaceLookupsAppendDataManagementArray) ToNamespaceLookupsAppendDataManagementArrayOutputWithContext(ctx context.Context) NamespaceLookupsAppendDataManagementArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceLookupsAppendDataManagementArrayOutput)
}

// NamespaceLookupsAppendDataManagementMapInput is an input type that accepts NamespaceLookupsAppendDataManagementMap and NamespaceLookupsAppendDataManagementMapOutput values.
// You can construct a concrete instance of `NamespaceLookupsAppendDataManagementMapInput` via:
//
//	NamespaceLookupsAppendDataManagementMap{ "key": NamespaceLookupsAppendDataManagementArgs{...} }
type NamespaceLookupsAppendDataManagementMapInput interface {
	pulumi.Input

	ToNamespaceLookupsAppendDataManagementMapOutput() NamespaceLookupsAppendDataManagementMapOutput
	ToNamespaceLookupsAppendDataManagementMapOutputWithContext(context.Context) NamespaceLookupsAppendDataManagementMapOutput
}

type NamespaceLookupsAppendDataManagementMap map[string]NamespaceLookupsAppendDataManagementInput

func (NamespaceLookupsAppendDataManagementMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NamespaceLookupsAppendDataManagement)(nil)).Elem()
}

func (i NamespaceLookupsAppendDataManagementMap) ToNamespaceLookupsAppendDataManagementMapOutput() NamespaceLookupsAppendDataManagementMapOutput {
	return i.ToNamespaceLookupsAppendDataManagementMapOutputWithContext(context.Background())
}

func (i NamespaceLookupsAppendDataManagementMap) ToNamespaceLookupsAppendDataManagementMapOutputWithContext(ctx context.Context) NamespaceLookupsAppendDataManagementMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceLookupsAppendDataManagementMapOutput)
}

type NamespaceLookupsAppendDataManagementOutput struct{ *pulumi.OutputState }

func (NamespaceLookupsAppendDataManagementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NamespaceLookupsAppendDataManagement)(nil)).Elem()
}

func (o NamespaceLookupsAppendDataManagementOutput) ToNamespaceLookupsAppendDataManagementOutput() NamespaceLookupsAppendDataManagementOutput {
	return o
}

func (o NamespaceLookupsAppendDataManagementOutput) ToNamespaceLookupsAppendDataManagementOutputWithContext(ctx context.Context) NamespaceLookupsAppendDataManagementOutput {
	return o
}

func (o NamespaceLookupsAppendDataManagementOutput) AppendLookupFile() pulumi.StringOutput {
	return o.ApplyT(func(v *NamespaceLookupsAppendDataManagement) pulumi.StringOutput { return v.AppendLookupFile }).(pulumi.StringOutput)
}

// The character encoding of the uploaded file.
func (o NamespaceLookupsAppendDataManagementOutput) CharEncoding() pulumi.StringOutput {
	return o.ApplyT(func(v *NamespaceLookupsAppendDataManagement) pulumi.StringOutput { return v.CharEncoding }).(pulumi.StringOutput)
}

// A value of `100-continue` requests preliminary verification of the request method, path, and headers before the request body is sent. If no error results from such verification, the server will send a 100 (Continue) interim response to indicate readiness for the request body. The only allowed value for this parameter is "100-Continue" (case-insensitive).
func (o NamespaceLookupsAppendDataManagementOutput) Expect() pulumi.StringOutput {
	return o.ApplyT(func(v *NamespaceLookupsAppendDataManagement) pulumi.StringOutput { return v.Expect }).(pulumi.StringOutput)
}

// is force
func (o NamespaceLookupsAppendDataManagementOutput) IsForce() pulumi.BoolOutput {
	return o.ApplyT(func(v *NamespaceLookupsAppendDataManagement) pulumi.BoolOutput { return v.IsForce }).(pulumi.BoolOutput)
}

// The name of the lookup to operate on.
func (o NamespaceLookupsAppendDataManagementOutput) LookupName() pulumi.StringOutput {
	return o.ApplyT(func(v *NamespaceLookupsAppendDataManagement) pulumi.StringOutput { return v.LookupName }).(pulumi.StringOutput)
}

// The Logging Analytics namespace used for the request.
//
// ** IMPORTANT **
// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
func (o NamespaceLookupsAppendDataManagementOutput) Namespace() pulumi.StringOutput {
	return o.ApplyT(func(v *NamespaceLookupsAppendDataManagement) pulumi.StringOutput { return v.Namespace }).(pulumi.StringOutput)
}

type NamespaceLookupsAppendDataManagementArrayOutput struct{ *pulumi.OutputState }

func (NamespaceLookupsAppendDataManagementArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NamespaceLookupsAppendDataManagement)(nil)).Elem()
}

func (o NamespaceLookupsAppendDataManagementArrayOutput) ToNamespaceLookupsAppendDataManagementArrayOutput() NamespaceLookupsAppendDataManagementArrayOutput {
	return o
}

func (o NamespaceLookupsAppendDataManagementArrayOutput) ToNamespaceLookupsAppendDataManagementArrayOutputWithContext(ctx context.Context) NamespaceLookupsAppendDataManagementArrayOutput {
	return o
}

func (o NamespaceLookupsAppendDataManagementArrayOutput) Index(i pulumi.IntInput) NamespaceLookupsAppendDataManagementOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *NamespaceLookupsAppendDataManagement {
		return vs[0].([]*NamespaceLookupsAppendDataManagement)[vs[1].(int)]
	}).(NamespaceLookupsAppendDataManagementOutput)
}

type NamespaceLookupsAppendDataManagementMapOutput struct{ *pulumi.OutputState }

func (NamespaceLookupsAppendDataManagementMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NamespaceLookupsAppendDataManagement)(nil)).Elem()
}

func (o NamespaceLookupsAppendDataManagementMapOutput) ToNamespaceLookupsAppendDataManagementMapOutput() NamespaceLookupsAppendDataManagementMapOutput {
	return o
}

func (o NamespaceLookupsAppendDataManagementMapOutput) ToNamespaceLookupsAppendDataManagementMapOutputWithContext(ctx context.Context) NamespaceLookupsAppendDataManagementMapOutput {
	return o
}

func (o NamespaceLookupsAppendDataManagementMapOutput) MapIndex(k pulumi.StringInput) NamespaceLookupsAppendDataManagementOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *NamespaceLookupsAppendDataManagement {
		return vs[0].(map[string]*NamespaceLookupsAppendDataManagement)[vs[1].(string)]
	}).(NamespaceLookupsAppendDataManagementOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*NamespaceLookupsAppendDataManagementInput)(nil)).Elem(), &NamespaceLookupsAppendDataManagement{})
	pulumi.RegisterInputType(reflect.TypeOf((*NamespaceLookupsAppendDataManagementArrayInput)(nil)).Elem(), NamespaceLookupsAppendDataManagementArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NamespaceLookupsAppendDataManagementMapInput)(nil)).Elem(), NamespaceLookupsAppendDataManagementMap{})
	pulumi.RegisterOutputType(NamespaceLookupsAppendDataManagementOutput{})
	pulumi.RegisterOutputType(NamespaceLookupsAppendDataManagementArrayOutput{})
	pulumi.RegisterOutputType(NamespaceLookupsAppendDataManagementMapOutput{})
}
