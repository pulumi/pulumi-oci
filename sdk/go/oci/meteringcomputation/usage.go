// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package meteringcomputation

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-oci/sdk/v2/go/oci/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// This resource provides the Usage resource in Oracle Cloud Infrastructure Metering Computation service.
//
// Returns usage for the given account.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-oci/sdk/v2/go/oci/meteringcomputation"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := meteringcomputation.NewUsage(ctx, "test_usage", &meteringcomputation.UsageArgs{
//				Granularity:      pulumi.Any(usageGranularity),
//				TenantId:         pulumi.Any(testTenant.Id),
//				TimeUsageEnded:   pulumi.Any(usageTimeUsageEnded),
//				TimeUsageStarted: pulumi.Any(usageTimeUsageStarted),
//				CompartmentDepth: pulumi.Any(usageCompartmentDepth),
//				Filter:           pulumi.Any(usageFilter),
//				Forecast: &meteringcomputation.UsageForecastArgs{
//					TimeForecastEnded:   pulumi.Any(usageForecastTimeForecastEnded),
//					ForecastType:        pulumi.Any(usageForecastForecastType),
//					TimeForecastStarted: pulumi.Any(usageForecastTimeForecastStarted),
//				},
//				GroupBies: pulumi.Any(usageGroupBy),
//				GroupByTags: meteringcomputation.UsageGroupByTagArray{
//					&meteringcomputation.UsageGroupByTagArgs{
//						Key:       pulumi.Any(usageGroupByTagKey),
//						Namespace: pulumi.Any(usageGroupByTagNamespace),
//						Value:     pulumi.Any(usageGroupByTagValue),
//					},
//				},
//				IsAggregateByTime: pulumi.Any(usageIsAggregateByTime),
//				QueryType:         pulumi.Any(usageQueryType),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Import is not supported for this resource.
type Usage struct {
	pulumi.CustomResourceState

	// The compartment depth level.
	CompartmentDepth pulumi.Float64Output `pulumi:"compartmentDepth"`
	// The filter object for query usage.
	Filter pulumi.StringPtrOutput `pulumi:"filter"`
	// Forecast configuration of usage/cost.
	Forecast UsageForecastOutput `pulumi:"forecast"`
	// The usage granularity. HOURLY - Hourly data aggregation. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. TOTAL - Not yet supported.
	Granularity pulumi.StringOutput `pulumi:"granularity"`
	// Aggregate the result by. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
	GroupBies pulumi.StringArrayOutput `pulumi:"groupBies"`
	// GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: `[{"namespace":"oracle", "key":"createdBy"]`
	GroupByTags UsageGroupByTagArrayOutput `pulumi:"groupByTags"`
	// Whether aggregated by time. If isAggregateByTime is true, all usage/cost over the query time period will be added up.
	IsAggregateByTime pulumi.BoolOutput `pulumi:"isAggregateByTime"`
	// A list of usage items.
	Items UsageItemArrayOutput `pulumi:"items"`
	// The query usage type. COST by default if it is missing. Usage - Query the usage data. Cost - Query the cost/billing data. Credit - Query the credit adjustments data. ExpiredCredit - Query the expired credits data. AllCredit - Query the credit adjustments and expired credit.
	QueryType pulumi.StringOutput `pulumi:"queryType"`
	// Tenant ID.
	TenantId pulumi.StringOutput `pulumi:"tenantId"`
	// The usage end time.
	TimeUsageEnded pulumi.StringOutput `pulumi:"timeUsageEnded"`
	// The usage start time.
	//
	// ** IMPORTANT **
	// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
	TimeUsageStarted pulumi.StringOutput `pulumi:"timeUsageStarted"`
}

// NewUsage registers a new resource with the given unique name, arguments, and options.
func NewUsage(ctx *pulumi.Context,
	name string, args *UsageArgs, opts ...pulumi.ResourceOption) (*Usage, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Granularity == nil {
		return nil, errors.New("invalid value for required argument 'Granularity'")
	}
	if args.TenantId == nil {
		return nil, errors.New("invalid value for required argument 'TenantId'")
	}
	if args.TimeUsageEnded == nil {
		return nil, errors.New("invalid value for required argument 'TimeUsageEnded'")
	}
	if args.TimeUsageStarted == nil {
		return nil, errors.New("invalid value for required argument 'TimeUsageStarted'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Usage
	err := ctx.RegisterResource("oci:MeteringComputation/usage:Usage", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetUsage gets an existing Usage resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetUsage(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *UsageState, opts ...pulumi.ResourceOption) (*Usage, error) {
	var resource Usage
	err := ctx.ReadResource("oci:MeteringComputation/usage:Usage", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Usage resources.
type usageState struct {
	// The compartment depth level.
	CompartmentDepth *float64 `pulumi:"compartmentDepth"`
	// The filter object for query usage.
	Filter *string `pulumi:"filter"`
	// Forecast configuration of usage/cost.
	Forecast *UsageForecast `pulumi:"forecast"`
	// The usage granularity. HOURLY - Hourly data aggregation. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. TOTAL - Not yet supported.
	Granularity *string `pulumi:"granularity"`
	// Aggregate the result by. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
	GroupBies []string `pulumi:"groupBies"`
	// GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: `[{"namespace":"oracle", "key":"createdBy"]`
	GroupByTags []UsageGroupByTag `pulumi:"groupByTags"`
	// Whether aggregated by time. If isAggregateByTime is true, all usage/cost over the query time period will be added up.
	IsAggregateByTime *bool `pulumi:"isAggregateByTime"`
	// A list of usage items.
	Items []UsageItem `pulumi:"items"`
	// The query usage type. COST by default if it is missing. Usage - Query the usage data. Cost - Query the cost/billing data. Credit - Query the credit adjustments data. ExpiredCredit - Query the expired credits data. AllCredit - Query the credit adjustments and expired credit.
	QueryType *string `pulumi:"queryType"`
	// Tenant ID.
	TenantId *string `pulumi:"tenantId"`
	// The usage end time.
	TimeUsageEnded *string `pulumi:"timeUsageEnded"`
	// The usage start time.
	//
	// ** IMPORTANT **
	// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
	TimeUsageStarted *string `pulumi:"timeUsageStarted"`
}

type UsageState struct {
	// The compartment depth level.
	CompartmentDepth pulumi.Float64PtrInput
	// The filter object for query usage.
	Filter pulumi.StringPtrInput
	// Forecast configuration of usage/cost.
	Forecast UsageForecastPtrInput
	// The usage granularity. HOURLY - Hourly data aggregation. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. TOTAL - Not yet supported.
	Granularity pulumi.StringPtrInput
	// Aggregate the result by. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
	GroupBies pulumi.StringArrayInput
	// GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: `[{"namespace":"oracle", "key":"createdBy"]`
	GroupByTags UsageGroupByTagArrayInput
	// Whether aggregated by time. If isAggregateByTime is true, all usage/cost over the query time period will be added up.
	IsAggregateByTime pulumi.BoolPtrInput
	// A list of usage items.
	Items UsageItemArrayInput
	// The query usage type. COST by default if it is missing. Usage - Query the usage data. Cost - Query the cost/billing data. Credit - Query the credit adjustments data. ExpiredCredit - Query the expired credits data. AllCredit - Query the credit adjustments and expired credit.
	QueryType pulumi.StringPtrInput
	// Tenant ID.
	TenantId pulumi.StringPtrInput
	// The usage end time.
	TimeUsageEnded pulumi.StringPtrInput
	// The usage start time.
	//
	// ** IMPORTANT **
	// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
	TimeUsageStarted pulumi.StringPtrInput
}

func (UsageState) ElementType() reflect.Type {
	return reflect.TypeOf((*usageState)(nil)).Elem()
}

type usageArgs struct {
	// The compartment depth level.
	CompartmentDepth *float64 `pulumi:"compartmentDepth"`
	// The filter object for query usage.
	Filter *string `pulumi:"filter"`
	// Forecast configuration of usage/cost.
	Forecast *UsageForecast `pulumi:"forecast"`
	// The usage granularity. HOURLY - Hourly data aggregation. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. TOTAL - Not yet supported.
	Granularity string `pulumi:"granularity"`
	// Aggregate the result by. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
	GroupBies []string `pulumi:"groupBies"`
	// GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: `[{"namespace":"oracle", "key":"createdBy"]`
	GroupByTags []UsageGroupByTag `pulumi:"groupByTags"`
	// Whether aggregated by time. If isAggregateByTime is true, all usage/cost over the query time period will be added up.
	IsAggregateByTime *bool `pulumi:"isAggregateByTime"`
	// The query usage type. COST by default if it is missing. Usage - Query the usage data. Cost - Query the cost/billing data. Credit - Query the credit adjustments data. ExpiredCredit - Query the expired credits data. AllCredit - Query the credit adjustments and expired credit.
	QueryType *string `pulumi:"queryType"`
	// Tenant ID.
	TenantId string `pulumi:"tenantId"`
	// The usage end time.
	TimeUsageEnded string `pulumi:"timeUsageEnded"`
	// The usage start time.
	//
	// ** IMPORTANT **
	// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
	TimeUsageStarted string `pulumi:"timeUsageStarted"`
}

// The set of arguments for constructing a Usage resource.
type UsageArgs struct {
	// The compartment depth level.
	CompartmentDepth pulumi.Float64PtrInput
	// The filter object for query usage.
	Filter pulumi.StringPtrInput
	// Forecast configuration of usage/cost.
	Forecast UsageForecastPtrInput
	// The usage granularity. HOURLY - Hourly data aggregation. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. TOTAL - Not yet supported.
	Granularity pulumi.StringInput
	// Aggregate the result by. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
	GroupBies pulumi.StringArrayInput
	// GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: `[{"namespace":"oracle", "key":"createdBy"]`
	GroupByTags UsageGroupByTagArrayInput
	// Whether aggregated by time. If isAggregateByTime is true, all usage/cost over the query time period will be added up.
	IsAggregateByTime pulumi.BoolPtrInput
	// The query usage type. COST by default if it is missing. Usage - Query the usage data. Cost - Query the cost/billing data. Credit - Query the credit adjustments data. ExpiredCredit - Query the expired credits data. AllCredit - Query the credit adjustments and expired credit.
	QueryType pulumi.StringPtrInput
	// Tenant ID.
	TenantId pulumi.StringInput
	// The usage end time.
	TimeUsageEnded pulumi.StringInput
	// The usage start time.
	//
	// ** IMPORTANT **
	// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
	TimeUsageStarted pulumi.StringInput
}

func (UsageArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*usageArgs)(nil)).Elem()
}

type UsageInput interface {
	pulumi.Input

	ToUsageOutput() UsageOutput
	ToUsageOutputWithContext(ctx context.Context) UsageOutput
}

func (*Usage) ElementType() reflect.Type {
	return reflect.TypeOf((**Usage)(nil)).Elem()
}

func (i *Usage) ToUsageOutput() UsageOutput {
	return i.ToUsageOutputWithContext(context.Background())
}

func (i *Usage) ToUsageOutputWithContext(ctx context.Context) UsageOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UsageOutput)
}

// UsageArrayInput is an input type that accepts UsageArray and UsageArrayOutput values.
// You can construct a concrete instance of `UsageArrayInput` via:
//
//	UsageArray{ UsageArgs{...} }
type UsageArrayInput interface {
	pulumi.Input

	ToUsageArrayOutput() UsageArrayOutput
	ToUsageArrayOutputWithContext(context.Context) UsageArrayOutput
}

type UsageArray []UsageInput

func (UsageArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Usage)(nil)).Elem()
}

func (i UsageArray) ToUsageArrayOutput() UsageArrayOutput {
	return i.ToUsageArrayOutputWithContext(context.Background())
}

func (i UsageArray) ToUsageArrayOutputWithContext(ctx context.Context) UsageArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UsageArrayOutput)
}

// UsageMapInput is an input type that accepts UsageMap and UsageMapOutput values.
// You can construct a concrete instance of `UsageMapInput` via:
//
//	UsageMap{ "key": UsageArgs{...} }
type UsageMapInput interface {
	pulumi.Input

	ToUsageMapOutput() UsageMapOutput
	ToUsageMapOutputWithContext(context.Context) UsageMapOutput
}

type UsageMap map[string]UsageInput

func (UsageMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Usage)(nil)).Elem()
}

func (i UsageMap) ToUsageMapOutput() UsageMapOutput {
	return i.ToUsageMapOutputWithContext(context.Background())
}

func (i UsageMap) ToUsageMapOutputWithContext(ctx context.Context) UsageMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UsageMapOutput)
}

type UsageOutput struct{ *pulumi.OutputState }

func (UsageOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Usage)(nil)).Elem()
}

func (o UsageOutput) ToUsageOutput() UsageOutput {
	return o
}

func (o UsageOutput) ToUsageOutputWithContext(ctx context.Context) UsageOutput {
	return o
}

// The compartment depth level.
func (o UsageOutput) CompartmentDepth() pulumi.Float64Output {
	return o.ApplyT(func(v *Usage) pulumi.Float64Output { return v.CompartmentDepth }).(pulumi.Float64Output)
}

// The filter object for query usage.
func (o UsageOutput) Filter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Usage) pulumi.StringPtrOutput { return v.Filter }).(pulumi.StringPtrOutput)
}

// Forecast configuration of usage/cost.
func (o UsageOutput) Forecast() UsageForecastOutput {
	return o.ApplyT(func(v *Usage) UsageForecastOutput { return v.Forecast }).(UsageForecastOutput)
}

// The usage granularity. HOURLY - Hourly data aggregation. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. TOTAL - Not yet supported.
func (o UsageOutput) Granularity() pulumi.StringOutput {
	return o.ApplyT(func(v *Usage) pulumi.StringOutput { return v.Granularity }).(pulumi.StringOutput)
}

// Aggregate the result by. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
func (o UsageOutput) GroupBies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Usage) pulumi.StringArrayOutput { return v.GroupBies }).(pulumi.StringArrayOutput)
}

// GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: `[{"namespace":"oracle", "key":"createdBy"]`
func (o UsageOutput) GroupByTags() UsageGroupByTagArrayOutput {
	return o.ApplyT(func(v *Usage) UsageGroupByTagArrayOutput { return v.GroupByTags }).(UsageGroupByTagArrayOutput)
}

// Whether aggregated by time. If isAggregateByTime is true, all usage/cost over the query time period will be added up.
func (o UsageOutput) IsAggregateByTime() pulumi.BoolOutput {
	return o.ApplyT(func(v *Usage) pulumi.BoolOutput { return v.IsAggregateByTime }).(pulumi.BoolOutput)
}

// A list of usage items.
func (o UsageOutput) Items() UsageItemArrayOutput {
	return o.ApplyT(func(v *Usage) UsageItemArrayOutput { return v.Items }).(UsageItemArrayOutput)
}

// The query usage type. COST by default if it is missing. Usage - Query the usage data. Cost - Query the cost/billing data. Credit - Query the credit adjustments data. ExpiredCredit - Query the expired credits data. AllCredit - Query the credit adjustments and expired credit.
func (o UsageOutput) QueryType() pulumi.StringOutput {
	return o.ApplyT(func(v *Usage) pulumi.StringOutput { return v.QueryType }).(pulumi.StringOutput)
}

// Tenant ID.
func (o UsageOutput) TenantId() pulumi.StringOutput {
	return o.ApplyT(func(v *Usage) pulumi.StringOutput { return v.TenantId }).(pulumi.StringOutput)
}

// The usage end time.
func (o UsageOutput) TimeUsageEnded() pulumi.StringOutput {
	return o.ApplyT(func(v *Usage) pulumi.StringOutput { return v.TimeUsageEnded }).(pulumi.StringOutput)
}

// The usage start time.
//
// ** IMPORTANT **
// Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
func (o UsageOutput) TimeUsageStarted() pulumi.StringOutput {
	return o.ApplyT(func(v *Usage) pulumi.StringOutput { return v.TimeUsageStarted }).(pulumi.StringOutput)
}

type UsageArrayOutput struct{ *pulumi.OutputState }

func (UsageArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Usage)(nil)).Elem()
}

func (o UsageArrayOutput) ToUsageArrayOutput() UsageArrayOutput {
	return o
}

func (o UsageArrayOutput) ToUsageArrayOutputWithContext(ctx context.Context) UsageArrayOutput {
	return o
}

func (o UsageArrayOutput) Index(i pulumi.IntInput) UsageOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Usage {
		return vs[0].([]*Usage)[vs[1].(int)]
	}).(UsageOutput)
}

type UsageMapOutput struct{ *pulumi.OutputState }

func (UsageMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Usage)(nil)).Elem()
}

func (o UsageMapOutput) ToUsageMapOutput() UsageMapOutput {
	return o
}

func (o UsageMapOutput) ToUsageMapOutputWithContext(ctx context.Context) UsageMapOutput {
	return o
}

func (o UsageMapOutput) MapIndex(k pulumi.StringInput) UsageOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Usage {
		return vs[0].(map[string]*Usage)[vs[1].(string)]
	}).(UsageOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*UsageInput)(nil)).Elem(), &Usage{})
	pulumi.RegisterInputType(reflect.TypeOf((*UsageArrayInput)(nil)).Elem(), UsageArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UsageMapInput)(nil)).Elem(), UsageMap{})
	pulumi.RegisterOutputType(UsageOutput{})
	pulumi.RegisterOutputType(UsageArrayOutput{})
	pulumi.RegisterOutputType(UsageMapOutput{})
}
