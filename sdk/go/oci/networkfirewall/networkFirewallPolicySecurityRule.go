// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package networkfirewall

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-oci/sdk/go/oci/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// This resource provides the Network Firewall Policy Security Rule resource in Oracle Cloud Infrastructure Network Firewall service.
//
// Creates a new Security Rule for the Network Firewall Policy.
//
// ## Example Usage
//
// <!--Start PulumiCodeChooser -->
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-oci/sdk/go/oci/NetworkFirewall"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := NetworkFirewall.NewNetworkFirewallPolicySecurityRule(ctx, "testNetworkFirewallPolicySecurityRule", &NetworkFirewall.NetworkFirewallPolicySecurityRuleArgs{
//				Action: pulumi.Any(_var.Network_firewall_policy_security_rule_action),
//				Condition: &networkfirewall.NetworkFirewallPolicySecurityRuleConditionArgs{
//					Applications:         pulumi.Any(_var.Network_firewall_policy_security_rule_condition_application),
//					DestinationAddresses: pulumi.Any(_var.Network_firewall_policy_security_rule_condition_destination_address),
//					Services:             pulumi.Any(_var.Network_firewall_policy_security_rule_condition_service),
//					SourceAddresses:      pulumi.Any(_var.Network_firewall_policy_security_rule_condition_source_address),
//					Urls:                 pulumi.Any(_var.Network_firewall_policy_security_rule_condition_url),
//				},
//				NetworkFirewallPolicyId: pulumi.Any(oci_network_firewall_network_firewall_policy.Test_network_firewall_policy.Id),
//				Inspection:              pulumi.Any(_var.Network_firewall_policy_security_rule_inspection),
//				Positions: networkfirewall.NetworkFirewallPolicySecurityRulePositionArray{
//					&networkfirewall.NetworkFirewallPolicySecurityRulePositionArgs{
//						AfterRule:  pulumi.Any(_var.Network_firewall_policy_security_rule_position_after_rule),
//						BeforeRule: pulumi.Any(_var.Network_firewall_policy_security_rule_position_before_rule),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// <!--End PulumiCodeChooser -->
//
// ## Import
//
// NetworkFirewallPolicySecurityRules can be imported using the `name`, e.g.
//
// ```sh
// $ pulumi import oci:NetworkFirewall/networkFirewallPolicySecurityRule:NetworkFirewallPolicySecurityRule test_network_firewall_policy_security_rule "networkFirewallPolicies/{networkFirewallPolicyId}/securityRules/{securityRuleName}"
// ```
type NetworkFirewallPolicySecurityRule struct {
	pulumi.CustomResourceState

	// (Updatable) Types of Action on the Traffic flow.
	// * ALLOW - Allows the traffic.
	// * DROP - Silently drops the traffic, e.g. without sending a TCP reset.
	// * REJECT - Rejects the traffic, sending a TCP reset to client and/or server as applicable.
	// * INSPECT - Inspects traffic for vulnerability as specified in `inspection`, which may result in rejection.
	Action pulumi.StringOutput `pulumi:"action"`
	// (Updatable) Criteria to evaluate against network traffic. A match occurs when at least one item in the array associated with each specified property corresponds with the relevant aspect of the traffic. The resources mentioned must already be present in the policy before being referenced in the rule.
	Condition NetworkFirewallPolicySecurityRuleConditionOutput `pulumi:"condition"`
	// (Updatable) Type of inspection to affect the traffic flow. This is only applicable if action is INSPECT.
	// * INTRUSION_DETECTION - Intrusion Detection.
	// * INTRUSION_PREVENTION - Intrusion Detection and Prevention. Traffic classified as potentially malicious will be rejected as described in `type`.
	Inspection pulumi.StringPtrOutput `pulumi:"inspection"`
	// Name for the Security rule, must be unique within the policy.
	Name pulumi.StringOutput `pulumi:"name"`
	// Unique Network Firewall Policy identifier
	NetworkFirewallPolicyId pulumi.StringOutput `pulumi:"networkFirewallPolicyId"`
	// OCID of the Network Firewall Policy this security rule belongs to.
	ParentResourceId pulumi.StringOutput `pulumi:"parentResourceId"`
	// (Updatable) An object which defines the position of the rule. Only one of the following position references should be provided.
	Positions     NetworkFirewallPolicySecurityRulePositionArrayOutput `pulumi:"positions"`
	PriorityOrder pulumi.StringPtrOutput                               `pulumi:"priorityOrder"`
}

// NewNetworkFirewallPolicySecurityRule registers a new resource with the given unique name, arguments, and options.
func NewNetworkFirewallPolicySecurityRule(ctx *pulumi.Context,
	name string, args *NetworkFirewallPolicySecurityRuleArgs, opts ...pulumi.ResourceOption) (*NetworkFirewallPolicySecurityRule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Action == nil {
		return nil, errors.New("invalid value for required argument 'Action'")
	}
	if args.Condition == nil {
		return nil, errors.New("invalid value for required argument 'Condition'")
	}
	if args.NetworkFirewallPolicyId == nil {
		return nil, errors.New("invalid value for required argument 'NetworkFirewallPolicyId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource NetworkFirewallPolicySecurityRule
	err := ctx.RegisterResource("oci:NetworkFirewall/networkFirewallPolicySecurityRule:NetworkFirewallPolicySecurityRule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetNetworkFirewallPolicySecurityRule gets an existing NetworkFirewallPolicySecurityRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetNetworkFirewallPolicySecurityRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *NetworkFirewallPolicySecurityRuleState, opts ...pulumi.ResourceOption) (*NetworkFirewallPolicySecurityRule, error) {
	var resource NetworkFirewallPolicySecurityRule
	err := ctx.ReadResource("oci:NetworkFirewall/networkFirewallPolicySecurityRule:NetworkFirewallPolicySecurityRule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering NetworkFirewallPolicySecurityRule resources.
type networkFirewallPolicySecurityRuleState struct {
	// (Updatable) Types of Action on the Traffic flow.
	// * ALLOW - Allows the traffic.
	// * DROP - Silently drops the traffic, e.g. without sending a TCP reset.
	// * REJECT - Rejects the traffic, sending a TCP reset to client and/or server as applicable.
	// * INSPECT - Inspects traffic for vulnerability as specified in `inspection`, which may result in rejection.
	Action *string `pulumi:"action"`
	// (Updatable) Criteria to evaluate against network traffic. A match occurs when at least one item in the array associated with each specified property corresponds with the relevant aspect of the traffic. The resources mentioned must already be present in the policy before being referenced in the rule.
	Condition *NetworkFirewallPolicySecurityRuleCondition `pulumi:"condition"`
	// (Updatable) Type of inspection to affect the traffic flow. This is only applicable if action is INSPECT.
	// * INTRUSION_DETECTION - Intrusion Detection.
	// * INTRUSION_PREVENTION - Intrusion Detection and Prevention. Traffic classified as potentially malicious will be rejected as described in `type`.
	Inspection *string `pulumi:"inspection"`
	// Name for the Security rule, must be unique within the policy.
	Name *string `pulumi:"name"`
	// Unique Network Firewall Policy identifier
	NetworkFirewallPolicyId *string `pulumi:"networkFirewallPolicyId"`
	// OCID of the Network Firewall Policy this security rule belongs to.
	ParentResourceId *string `pulumi:"parentResourceId"`
	// (Updatable) An object which defines the position of the rule. Only one of the following position references should be provided.
	Positions     []NetworkFirewallPolicySecurityRulePosition `pulumi:"positions"`
	PriorityOrder *string                                     `pulumi:"priorityOrder"`
}

type NetworkFirewallPolicySecurityRuleState struct {
	// (Updatable) Types of Action on the Traffic flow.
	// * ALLOW - Allows the traffic.
	// * DROP - Silently drops the traffic, e.g. without sending a TCP reset.
	// * REJECT - Rejects the traffic, sending a TCP reset to client and/or server as applicable.
	// * INSPECT - Inspects traffic for vulnerability as specified in `inspection`, which may result in rejection.
	Action pulumi.StringPtrInput
	// (Updatable) Criteria to evaluate against network traffic. A match occurs when at least one item in the array associated with each specified property corresponds with the relevant aspect of the traffic. The resources mentioned must already be present in the policy before being referenced in the rule.
	Condition NetworkFirewallPolicySecurityRuleConditionPtrInput
	// (Updatable) Type of inspection to affect the traffic flow. This is only applicable if action is INSPECT.
	// * INTRUSION_DETECTION - Intrusion Detection.
	// * INTRUSION_PREVENTION - Intrusion Detection and Prevention. Traffic classified as potentially malicious will be rejected as described in `type`.
	Inspection pulumi.StringPtrInput
	// Name for the Security rule, must be unique within the policy.
	Name pulumi.StringPtrInput
	// Unique Network Firewall Policy identifier
	NetworkFirewallPolicyId pulumi.StringPtrInput
	// OCID of the Network Firewall Policy this security rule belongs to.
	ParentResourceId pulumi.StringPtrInput
	// (Updatable) An object which defines the position of the rule. Only one of the following position references should be provided.
	Positions     NetworkFirewallPolicySecurityRulePositionArrayInput
	PriorityOrder pulumi.StringPtrInput
}

func (NetworkFirewallPolicySecurityRuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*networkFirewallPolicySecurityRuleState)(nil)).Elem()
}

type networkFirewallPolicySecurityRuleArgs struct {
	// (Updatable) Types of Action on the Traffic flow.
	// * ALLOW - Allows the traffic.
	// * DROP - Silently drops the traffic, e.g. without sending a TCP reset.
	// * REJECT - Rejects the traffic, sending a TCP reset to client and/or server as applicable.
	// * INSPECT - Inspects traffic for vulnerability as specified in `inspection`, which may result in rejection.
	Action string `pulumi:"action"`
	// (Updatable) Criteria to evaluate against network traffic. A match occurs when at least one item in the array associated with each specified property corresponds with the relevant aspect of the traffic. The resources mentioned must already be present in the policy before being referenced in the rule.
	Condition NetworkFirewallPolicySecurityRuleCondition `pulumi:"condition"`
	// (Updatable) Type of inspection to affect the traffic flow. This is only applicable if action is INSPECT.
	// * INTRUSION_DETECTION - Intrusion Detection.
	// * INTRUSION_PREVENTION - Intrusion Detection and Prevention. Traffic classified as potentially malicious will be rejected as described in `type`.
	Inspection *string `pulumi:"inspection"`
	// Name for the Security rule, must be unique within the policy.
	Name *string `pulumi:"name"`
	// Unique Network Firewall Policy identifier
	NetworkFirewallPolicyId string `pulumi:"networkFirewallPolicyId"`
	// (Updatable) An object which defines the position of the rule. Only one of the following position references should be provided.
	Positions     []NetworkFirewallPolicySecurityRulePosition `pulumi:"positions"`
	PriorityOrder *string                                     `pulumi:"priorityOrder"`
}

// The set of arguments for constructing a NetworkFirewallPolicySecurityRule resource.
type NetworkFirewallPolicySecurityRuleArgs struct {
	// (Updatable) Types of Action on the Traffic flow.
	// * ALLOW - Allows the traffic.
	// * DROP - Silently drops the traffic, e.g. without sending a TCP reset.
	// * REJECT - Rejects the traffic, sending a TCP reset to client and/or server as applicable.
	// * INSPECT - Inspects traffic for vulnerability as specified in `inspection`, which may result in rejection.
	Action pulumi.StringInput
	// (Updatable) Criteria to evaluate against network traffic. A match occurs when at least one item in the array associated with each specified property corresponds with the relevant aspect of the traffic. The resources mentioned must already be present in the policy before being referenced in the rule.
	Condition NetworkFirewallPolicySecurityRuleConditionInput
	// (Updatable) Type of inspection to affect the traffic flow. This is only applicable if action is INSPECT.
	// * INTRUSION_DETECTION - Intrusion Detection.
	// * INTRUSION_PREVENTION - Intrusion Detection and Prevention. Traffic classified as potentially malicious will be rejected as described in `type`.
	Inspection pulumi.StringPtrInput
	// Name for the Security rule, must be unique within the policy.
	Name pulumi.StringPtrInput
	// Unique Network Firewall Policy identifier
	NetworkFirewallPolicyId pulumi.StringInput
	// (Updatable) An object which defines the position of the rule. Only one of the following position references should be provided.
	Positions     NetworkFirewallPolicySecurityRulePositionArrayInput
	PriorityOrder pulumi.StringPtrInput
}

func (NetworkFirewallPolicySecurityRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*networkFirewallPolicySecurityRuleArgs)(nil)).Elem()
}

type NetworkFirewallPolicySecurityRuleInput interface {
	pulumi.Input

	ToNetworkFirewallPolicySecurityRuleOutput() NetworkFirewallPolicySecurityRuleOutput
	ToNetworkFirewallPolicySecurityRuleOutputWithContext(ctx context.Context) NetworkFirewallPolicySecurityRuleOutput
}

func (*NetworkFirewallPolicySecurityRule) ElementType() reflect.Type {
	return reflect.TypeOf((**NetworkFirewallPolicySecurityRule)(nil)).Elem()
}

func (i *NetworkFirewallPolicySecurityRule) ToNetworkFirewallPolicySecurityRuleOutput() NetworkFirewallPolicySecurityRuleOutput {
	return i.ToNetworkFirewallPolicySecurityRuleOutputWithContext(context.Background())
}

func (i *NetworkFirewallPolicySecurityRule) ToNetworkFirewallPolicySecurityRuleOutputWithContext(ctx context.Context) NetworkFirewallPolicySecurityRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkFirewallPolicySecurityRuleOutput)
}

// NetworkFirewallPolicySecurityRuleArrayInput is an input type that accepts NetworkFirewallPolicySecurityRuleArray and NetworkFirewallPolicySecurityRuleArrayOutput values.
// You can construct a concrete instance of `NetworkFirewallPolicySecurityRuleArrayInput` via:
//
//	NetworkFirewallPolicySecurityRuleArray{ NetworkFirewallPolicySecurityRuleArgs{...} }
type NetworkFirewallPolicySecurityRuleArrayInput interface {
	pulumi.Input

	ToNetworkFirewallPolicySecurityRuleArrayOutput() NetworkFirewallPolicySecurityRuleArrayOutput
	ToNetworkFirewallPolicySecurityRuleArrayOutputWithContext(context.Context) NetworkFirewallPolicySecurityRuleArrayOutput
}

type NetworkFirewallPolicySecurityRuleArray []NetworkFirewallPolicySecurityRuleInput

func (NetworkFirewallPolicySecurityRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NetworkFirewallPolicySecurityRule)(nil)).Elem()
}

func (i NetworkFirewallPolicySecurityRuleArray) ToNetworkFirewallPolicySecurityRuleArrayOutput() NetworkFirewallPolicySecurityRuleArrayOutput {
	return i.ToNetworkFirewallPolicySecurityRuleArrayOutputWithContext(context.Background())
}

func (i NetworkFirewallPolicySecurityRuleArray) ToNetworkFirewallPolicySecurityRuleArrayOutputWithContext(ctx context.Context) NetworkFirewallPolicySecurityRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkFirewallPolicySecurityRuleArrayOutput)
}

// NetworkFirewallPolicySecurityRuleMapInput is an input type that accepts NetworkFirewallPolicySecurityRuleMap and NetworkFirewallPolicySecurityRuleMapOutput values.
// You can construct a concrete instance of `NetworkFirewallPolicySecurityRuleMapInput` via:
//
//	NetworkFirewallPolicySecurityRuleMap{ "key": NetworkFirewallPolicySecurityRuleArgs{...} }
type NetworkFirewallPolicySecurityRuleMapInput interface {
	pulumi.Input

	ToNetworkFirewallPolicySecurityRuleMapOutput() NetworkFirewallPolicySecurityRuleMapOutput
	ToNetworkFirewallPolicySecurityRuleMapOutputWithContext(context.Context) NetworkFirewallPolicySecurityRuleMapOutput
}

type NetworkFirewallPolicySecurityRuleMap map[string]NetworkFirewallPolicySecurityRuleInput

func (NetworkFirewallPolicySecurityRuleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NetworkFirewallPolicySecurityRule)(nil)).Elem()
}

func (i NetworkFirewallPolicySecurityRuleMap) ToNetworkFirewallPolicySecurityRuleMapOutput() NetworkFirewallPolicySecurityRuleMapOutput {
	return i.ToNetworkFirewallPolicySecurityRuleMapOutputWithContext(context.Background())
}

func (i NetworkFirewallPolicySecurityRuleMap) ToNetworkFirewallPolicySecurityRuleMapOutputWithContext(ctx context.Context) NetworkFirewallPolicySecurityRuleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkFirewallPolicySecurityRuleMapOutput)
}

type NetworkFirewallPolicySecurityRuleOutput struct{ *pulumi.OutputState }

func (NetworkFirewallPolicySecurityRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NetworkFirewallPolicySecurityRule)(nil)).Elem()
}

func (o NetworkFirewallPolicySecurityRuleOutput) ToNetworkFirewallPolicySecurityRuleOutput() NetworkFirewallPolicySecurityRuleOutput {
	return o
}

func (o NetworkFirewallPolicySecurityRuleOutput) ToNetworkFirewallPolicySecurityRuleOutputWithContext(ctx context.Context) NetworkFirewallPolicySecurityRuleOutput {
	return o
}

// (Updatable) Types of Action on the Traffic flow.
// * ALLOW - Allows the traffic.
// * DROP - Silently drops the traffic, e.g. without sending a TCP reset.
// * REJECT - Rejects the traffic, sending a TCP reset to client and/or server as applicable.
// * INSPECT - Inspects traffic for vulnerability as specified in `inspection`, which may result in rejection.
func (o NetworkFirewallPolicySecurityRuleOutput) Action() pulumi.StringOutput {
	return o.ApplyT(func(v *NetworkFirewallPolicySecurityRule) pulumi.StringOutput { return v.Action }).(pulumi.StringOutput)
}

// (Updatable) Criteria to evaluate against network traffic. A match occurs when at least one item in the array associated with each specified property corresponds with the relevant aspect of the traffic. The resources mentioned must already be present in the policy before being referenced in the rule.
func (o NetworkFirewallPolicySecurityRuleOutput) Condition() NetworkFirewallPolicySecurityRuleConditionOutput {
	return o.ApplyT(func(v *NetworkFirewallPolicySecurityRule) NetworkFirewallPolicySecurityRuleConditionOutput {
		return v.Condition
	}).(NetworkFirewallPolicySecurityRuleConditionOutput)
}

// (Updatable) Type of inspection to affect the traffic flow. This is only applicable if action is INSPECT.
// * INTRUSION_DETECTION - Intrusion Detection.
// * INTRUSION_PREVENTION - Intrusion Detection and Prevention. Traffic classified as potentially malicious will be rejected as described in `type`.
func (o NetworkFirewallPolicySecurityRuleOutput) Inspection() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NetworkFirewallPolicySecurityRule) pulumi.StringPtrOutput { return v.Inspection }).(pulumi.StringPtrOutput)
}

// Name for the Security rule, must be unique within the policy.
func (o NetworkFirewallPolicySecurityRuleOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *NetworkFirewallPolicySecurityRule) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Unique Network Firewall Policy identifier
func (o NetworkFirewallPolicySecurityRuleOutput) NetworkFirewallPolicyId() pulumi.StringOutput {
	return o.ApplyT(func(v *NetworkFirewallPolicySecurityRule) pulumi.StringOutput { return v.NetworkFirewallPolicyId }).(pulumi.StringOutput)
}

// OCID of the Network Firewall Policy this security rule belongs to.
func (o NetworkFirewallPolicySecurityRuleOutput) ParentResourceId() pulumi.StringOutput {
	return o.ApplyT(func(v *NetworkFirewallPolicySecurityRule) pulumi.StringOutput { return v.ParentResourceId }).(pulumi.StringOutput)
}

// (Updatable) An object which defines the position of the rule. Only one of the following position references should be provided.
func (o NetworkFirewallPolicySecurityRuleOutput) Positions() NetworkFirewallPolicySecurityRulePositionArrayOutput {
	return o.ApplyT(func(v *NetworkFirewallPolicySecurityRule) NetworkFirewallPolicySecurityRulePositionArrayOutput {
		return v.Positions
	}).(NetworkFirewallPolicySecurityRulePositionArrayOutput)
}

func (o NetworkFirewallPolicySecurityRuleOutput) PriorityOrder() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NetworkFirewallPolicySecurityRule) pulumi.StringPtrOutput { return v.PriorityOrder }).(pulumi.StringPtrOutput)
}

type NetworkFirewallPolicySecurityRuleArrayOutput struct{ *pulumi.OutputState }

func (NetworkFirewallPolicySecurityRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NetworkFirewallPolicySecurityRule)(nil)).Elem()
}

func (o NetworkFirewallPolicySecurityRuleArrayOutput) ToNetworkFirewallPolicySecurityRuleArrayOutput() NetworkFirewallPolicySecurityRuleArrayOutput {
	return o
}

func (o NetworkFirewallPolicySecurityRuleArrayOutput) ToNetworkFirewallPolicySecurityRuleArrayOutputWithContext(ctx context.Context) NetworkFirewallPolicySecurityRuleArrayOutput {
	return o
}

func (o NetworkFirewallPolicySecurityRuleArrayOutput) Index(i pulumi.IntInput) NetworkFirewallPolicySecurityRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *NetworkFirewallPolicySecurityRule {
		return vs[0].([]*NetworkFirewallPolicySecurityRule)[vs[1].(int)]
	}).(NetworkFirewallPolicySecurityRuleOutput)
}

type NetworkFirewallPolicySecurityRuleMapOutput struct{ *pulumi.OutputState }

func (NetworkFirewallPolicySecurityRuleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NetworkFirewallPolicySecurityRule)(nil)).Elem()
}

func (o NetworkFirewallPolicySecurityRuleMapOutput) ToNetworkFirewallPolicySecurityRuleMapOutput() NetworkFirewallPolicySecurityRuleMapOutput {
	return o
}

func (o NetworkFirewallPolicySecurityRuleMapOutput) ToNetworkFirewallPolicySecurityRuleMapOutputWithContext(ctx context.Context) NetworkFirewallPolicySecurityRuleMapOutput {
	return o
}

func (o NetworkFirewallPolicySecurityRuleMapOutput) MapIndex(k pulumi.StringInput) NetworkFirewallPolicySecurityRuleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *NetworkFirewallPolicySecurityRule {
		return vs[0].(map[string]*NetworkFirewallPolicySecurityRule)[vs[1].(string)]
	}).(NetworkFirewallPolicySecurityRuleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkFirewallPolicySecurityRuleInput)(nil)).Elem(), &NetworkFirewallPolicySecurityRule{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkFirewallPolicySecurityRuleArrayInput)(nil)).Elem(), NetworkFirewallPolicySecurityRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkFirewallPolicySecurityRuleMapInput)(nil)).Elem(), NetworkFirewallPolicySecurityRuleMap{})
	pulumi.RegisterOutputType(NetworkFirewallPolicySecurityRuleOutput{})
	pulumi.RegisterOutputType(NetworkFirewallPolicySecurityRuleArrayOutput{})
	pulumi.RegisterOutputType(NetworkFirewallPolicySecurityRuleMapOutput{})
}
