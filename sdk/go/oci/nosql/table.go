// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package nosql

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-oci/sdk/v2/go/oci/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// This resource provides the Table resource in Oracle Cloud Infrastructure NoSQL Database service.
//
// Create a new table.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-oci/sdk/v2/go/oci/nosql"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := nosql.NewTable(ctx, "test_table", &nosql.TableArgs{
//				CompartmentId: pulumi.Any(compartmentId),
//				DdlStatement:  pulumi.Any(tableDdlStatement),
//				Name:          pulumi.Any(tableName),
//				DefinedTags:   pulumi.Any(tableDefinedTags),
//				FreeformTags: pulumi.StringMap{
//					"bar-key": pulumi.String("value"),
//				},
//				IsAutoReclaimable: pulumi.Any(tableIsAutoReclaimable),
//				TableLimits: &nosql.TableTableLimitsArgs{
//					MaxReadUnits:    pulumi.Any(tableTableLimitsMaxReadUnits),
//					MaxStorageInGbs: pulumi.Any(tableTableLimitsMaxStorageInGbs),
//					MaxWriteUnits:   pulumi.Any(tableTableLimitsMaxWriteUnits),
//					CapacityMode:    pulumi.Any(tableTableLimitsCapacityMode),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Tables can be imported using the `id`, e.g.
//
// ```sh
// $ pulumi import oci:Nosql/table:Table test_table "id"
// ```
type Table struct {
	pulumi.CustomResourceState

	// (Updatable) Compartment Identifier.
	CompartmentId pulumi.StringOutput `pulumi:"compartmentId"`
	// (Updatable) CREATE TABLE DDL statement. While updating an existing table, note that the column order should not be changed, and new columns can only be appended at the end of the table.
	DdlStatement pulumi.StringOutput `pulumi:"ddlStatement"`
	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace.  Example: `{"foo-namespace": {"bar-key": "value"}}`
	DefinedTags pulumi.StringMapOutput `pulumi:"definedTags"`
	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
	FreeformTags pulumi.StringMapOutput `pulumi:"freeformTags"`
	// True if table can be reclaimed after an idle period.
	IsAutoReclaimable pulumi.BoolOutput `pulumi:"isAutoReclaimable"`
	// True if this table is currently a member of a replication set.
	IsMultiRegion pulumi.BoolOutput `pulumi:"isMultiRegion"`
	// A message describing the current state in more detail.
	LifecycleDetails pulumi.StringOutput `pulumi:"lifecycleDetails"`
	// If this table is in a replication set, this value represents the progress of the initialization of the replica's data.  A value of 100 indicates that initialization has completed.
	LocalReplicaInitializationInPercent pulumi.IntOutput `pulumi:"localReplicaInitializationInPercent"`
	// Table name.
	Name pulumi.StringOutput `pulumi:"name"`
	// An array of Replica listing this table's replicas, if any
	Replicas TableReplicaTypeArrayOutput `pulumi:"replicas"`
	// The current state of this table's schema. Available states are MUTABLE - The schema can be changed. The table is not eligible for replication. FROZEN - The schema is immutable. The table is eligible for replication.
	SchemaState pulumi.StringOutput `pulumi:"schemaState"`
	// The table schema information as a JSON object.
	Schemas TableSchemaArrayOutput `pulumi:"schemas"`
	// The state of a table.
	State pulumi.StringOutput `pulumi:"state"`
	// Read-only system tag. These predefined keys are scoped to namespaces.  At present the only supported namespace is `"orcl-cloud"`; and the only key in that namespace is `"free-tier-retained"`. Example: `{"orcl-cloud"": {"free-tier-retained": "true"}}`
	SystemTags pulumi.StringMapOutput `pulumi:"systemTags"`
	// (Updatable) Throughput and storage limits configuration of a table. It is required for top level table, must be null for child table as child table shares its top parent table's limits.
	TableLimits TableTableLimitsOutput `pulumi:"tableLimits"`
	// The time the the table was created. An RFC3339 formatted datetime string.
	TimeCreated pulumi.StringOutput `pulumi:"timeCreated"`
	// If lifecycleState is INACTIVE, indicates when this table will be automatically removed. An RFC3339 formatted datetime string.
	TimeOfExpiration pulumi.StringOutput `pulumi:"timeOfExpiration"`
	// The time the the table's metadata was last updated. An RFC3339 formatted datetime string.
	TimeUpdated pulumi.StringOutput `pulumi:"timeUpdated"`
}

// NewTable registers a new resource with the given unique name, arguments, and options.
func NewTable(ctx *pulumi.Context,
	name string, args *TableArgs, opts ...pulumi.ResourceOption) (*Table, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.CompartmentId == nil {
		return nil, errors.New("invalid value for required argument 'CompartmentId'")
	}
	if args.DdlStatement == nil {
		return nil, errors.New("invalid value for required argument 'DdlStatement'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Table
	err := ctx.RegisterResource("oci:Nosql/table:Table", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetTable gets an existing Table resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetTable(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *TableState, opts ...pulumi.ResourceOption) (*Table, error) {
	var resource Table
	err := ctx.ReadResource("oci:Nosql/table:Table", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Table resources.
type tableState struct {
	// (Updatable) Compartment Identifier.
	CompartmentId *string `pulumi:"compartmentId"`
	// (Updatable) CREATE TABLE DDL statement. While updating an existing table, note that the column order should not be changed, and new columns can only be appended at the end of the table.
	DdlStatement *string `pulumi:"ddlStatement"`
	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace.  Example: `{"foo-namespace": {"bar-key": "value"}}`
	DefinedTags map[string]string `pulumi:"definedTags"`
	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
	FreeformTags map[string]string `pulumi:"freeformTags"`
	// True if table can be reclaimed after an idle period.
	IsAutoReclaimable *bool `pulumi:"isAutoReclaimable"`
	// True if this table is currently a member of a replication set.
	IsMultiRegion *bool `pulumi:"isMultiRegion"`
	// A message describing the current state in more detail.
	LifecycleDetails *string `pulumi:"lifecycleDetails"`
	// If this table is in a replication set, this value represents the progress of the initialization of the replica's data.  A value of 100 indicates that initialization has completed.
	LocalReplicaInitializationInPercent *int `pulumi:"localReplicaInitializationInPercent"`
	// Table name.
	Name *string `pulumi:"name"`
	// An array of Replica listing this table's replicas, if any
	Replicas []TableReplicaType `pulumi:"replicas"`
	// The current state of this table's schema. Available states are MUTABLE - The schema can be changed. The table is not eligible for replication. FROZEN - The schema is immutable. The table is eligible for replication.
	SchemaState *string `pulumi:"schemaState"`
	// The table schema information as a JSON object.
	Schemas []TableSchema `pulumi:"schemas"`
	// The state of a table.
	State *string `pulumi:"state"`
	// Read-only system tag. These predefined keys are scoped to namespaces.  At present the only supported namespace is `"orcl-cloud"`; and the only key in that namespace is `"free-tier-retained"`. Example: `{"orcl-cloud"": {"free-tier-retained": "true"}}`
	SystemTags map[string]string `pulumi:"systemTags"`
	// (Updatable) Throughput and storage limits configuration of a table. It is required for top level table, must be null for child table as child table shares its top parent table's limits.
	TableLimits *TableTableLimits `pulumi:"tableLimits"`
	// The time the the table was created. An RFC3339 formatted datetime string.
	TimeCreated *string `pulumi:"timeCreated"`
	// If lifecycleState is INACTIVE, indicates when this table will be automatically removed. An RFC3339 formatted datetime string.
	TimeOfExpiration *string `pulumi:"timeOfExpiration"`
	// The time the the table's metadata was last updated. An RFC3339 formatted datetime string.
	TimeUpdated *string `pulumi:"timeUpdated"`
}

type TableState struct {
	// (Updatable) Compartment Identifier.
	CompartmentId pulumi.StringPtrInput
	// (Updatable) CREATE TABLE DDL statement. While updating an existing table, note that the column order should not be changed, and new columns can only be appended at the end of the table.
	DdlStatement pulumi.StringPtrInput
	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace.  Example: `{"foo-namespace": {"bar-key": "value"}}`
	DefinedTags pulumi.StringMapInput
	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
	FreeformTags pulumi.StringMapInput
	// True if table can be reclaimed after an idle period.
	IsAutoReclaimable pulumi.BoolPtrInput
	// True if this table is currently a member of a replication set.
	IsMultiRegion pulumi.BoolPtrInput
	// A message describing the current state in more detail.
	LifecycleDetails pulumi.StringPtrInput
	// If this table is in a replication set, this value represents the progress of the initialization of the replica's data.  A value of 100 indicates that initialization has completed.
	LocalReplicaInitializationInPercent pulumi.IntPtrInput
	// Table name.
	Name pulumi.StringPtrInput
	// An array of Replica listing this table's replicas, if any
	Replicas TableReplicaTypeArrayInput
	// The current state of this table's schema. Available states are MUTABLE - The schema can be changed. The table is not eligible for replication. FROZEN - The schema is immutable. The table is eligible for replication.
	SchemaState pulumi.StringPtrInput
	// The table schema information as a JSON object.
	Schemas TableSchemaArrayInput
	// The state of a table.
	State pulumi.StringPtrInput
	// Read-only system tag. These predefined keys are scoped to namespaces.  At present the only supported namespace is `"orcl-cloud"`; and the only key in that namespace is `"free-tier-retained"`. Example: `{"orcl-cloud"": {"free-tier-retained": "true"}}`
	SystemTags pulumi.StringMapInput
	// (Updatable) Throughput and storage limits configuration of a table. It is required for top level table, must be null for child table as child table shares its top parent table's limits.
	TableLimits TableTableLimitsPtrInput
	// The time the the table was created. An RFC3339 formatted datetime string.
	TimeCreated pulumi.StringPtrInput
	// If lifecycleState is INACTIVE, indicates when this table will be automatically removed. An RFC3339 formatted datetime string.
	TimeOfExpiration pulumi.StringPtrInput
	// The time the the table's metadata was last updated. An RFC3339 formatted datetime string.
	TimeUpdated pulumi.StringPtrInput
}

func (TableState) ElementType() reflect.Type {
	return reflect.TypeOf((*tableState)(nil)).Elem()
}

type tableArgs struct {
	// (Updatable) Compartment Identifier.
	CompartmentId string `pulumi:"compartmentId"`
	// (Updatable) CREATE TABLE DDL statement. While updating an existing table, note that the column order should not be changed, and new columns can only be appended at the end of the table.
	DdlStatement string `pulumi:"ddlStatement"`
	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace.  Example: `{"foo-namespace": {"bar-key": "value"}}`
	DefinedTags map[string]string `pulumi:"definedTags"`
	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
	FreeformTags map[string]string `pulumi:"freeformTags"`
	// True if table can be reclaimed after an idle period.
	IsAutoReclaimable *bool `pulumi:"isAutoReclaimable"`
	// Table name.
	Name *string `pulumi:"name"`
	// (Updatable) Throughput and storage limits configuration of a table. It is required for top level table, must be null for child table as child table shares its top parent table's limits.
	TableLimits *TableTableLimits `pulumi:"tableLimits"`
}

// The set of arguments for constructing a Table resource.
type TableArgs struct {
	// (Updatable) Compartment Identifier.
	CompartmentId pulumi.StringInput
	// (Updatable) CREATE TABLE DDL statement. While updating an existing table, note that the column order should not be changed, and new columns can only be appended at the end of the table.
	DdlStatement pulumi.StringInput
	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace.  Example: `{"foo-namespace": {"bar-key": "value"}}`
	DefinedTags pulumi.StringMapInput
	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
	FreeformTags pulumi.StringMapInput
	// True if table can be reclaimed after an idle period.
	IsAutoReclaimable pulumi.BoolPtrInput
	// Table name.
	Name pulumi.StringPtrInput
	// (Updatable) Throughput and storage limits configuration of a table. It is required for top level table, must be null for child table as child table shares its top parent table's limits.
	TableLimits TableTableLimitsPtrInput
}

func (TableArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*tableArgs)(nil)).Elem()
}

type TableInput interface {
	pulumi.Input

	ToTableOutput() TableOutput
	ToTableOutputWithContext(ctx context.Context) TableOutput
}

func (*Table) ElementType() reflect.Type {
	return reflect.TypeOf((**Table)(nil)).Elem()
}

func (i *Table) ToTableOutput() TableOutput {
	return i.ToTableOutputWithContext(context.Background())
}

func (i *Table) ToTableOutputWithContext(ctx context.Context) TableOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TableOutput)
}

// TableArrayInput is an input type that accepts TableArray and TableArrayOutput values.
// You can construct a concrete instance of `TableArrayInput` via:
//
//	TableArray{ TableArgs{...} }
type TableArrayInput interface {
	pulumi.Input

	ToTableArrayOutput() TableArrayOutput
	ToTableArrayOutputWithContext(context.Context) TableArrayOutput
}

type TableArray []TableInput

func (TableArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Table)(nil)).Elem()
}

func (i TableArray) ToTableArrayOutput() TableArrayOutput {
	return i.ToTableArrayOutputWithContext(context.Background())
}

func (i TableArray) ToTableArrayOutputWithContext(ctx context.Context) TableArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TableArrayOutput)
}

// TableMapInput is an input type that accepts TableMap and TableMapOutput values.
// You can construct a concrete instance of `TableMapInput` via:
//
//	TableMap{ "key": TableArgs{...} }
type TableMapInput interface {
	pulumi.Input

	ToTableMapOutput() TableMapOutput
	ToTableMapOutputWithContext(context.Context) TableMapOutput
}

type TableMap map[string]TableInput

func (TableMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Table)(nil)).Elem()
}

func (i TableMap) ToTableMapOutput() TableMapOutput {
	return i.ToTableMapOutputWithContext(context.Background())
}

func (i TableMap) ToTableMapOutputWithContext(ctx context.Context) TableMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TableMapOutput)
}

type TableOutput struct{ *pulumi.OutputState }

func (TableOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Table)(nil)).Elem()
}

func (o TableOutput) ToTableOutput() TableOutput {
	return o
}

func (o TableOutput) ToTableOutputWithContext(ctx context.Context) TableOutput {
	return o
}

// (Updatable) Compartment Identifier.
func (o TableOutput) CompartmentId() pulumi.StringOutput {
	return o.ApplyT(func(v *Table) pulumi.StringOutput { return v.CompartmentId }).(pulumi.StringOutput)
}

// (Updatable) CREATE TABLE DDL statement. While updating an existing table, note that the column order should not be changed, and new columns can only be appended at the end of the table.
func (o TableOutput) DdlStatement() pulumi.StringOutput {
	return o.ApplyT(func(v *Table) pulumi.StringOutput { return v.DdlStatement }).(pulumi.StringOutput)
}

// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace.  Example: `{"foo-namespace": {"bar-key": "value"}}`
func (o TableOutput) DefinedTags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Table) pulumi.StringMapOutput { return v.DefinedTags }).(pulumi.StringMapOutput)
}

// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
func (o TableOutput) FreeformTags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Table) pulumi.StringMapOutput { return v.FreeformTags }).(pulumi.StringMapOutput)
}

// True if table can be reclaimed after an idle period.
func (o TableOutput) IsAutoReclaimable() pulumi.BoolOutput {
	return o.ApplyT(func(v *Table) pulumi.BoolOutput { return v.IsAutoReclaimable }).(pulumi.BoolOutput)
}

// True if this table is currently a member of a replication set.
func (o TableOutput) IsMultiRegion() pulumi.BoolOutput {
	return o.ApplyT(func(v *Table) pulumi.BoolOutput { return v.IsMultiRegion }).(pulumi.BoolOutput)
}

// A message describing the current state in more detail.
func (o TableOutput) LifecycleDetails() pulumi.StringOutput {
	return o.ApplyT(func(v *Table) pulumi.StringOutput { return v.LifecycleDetails }).(pulumi.StringOutput)
}

// If this table is in a replication set, this value represents the progress of the initialization of the replica's data.  A value of 100 indicates that initialization has completed.
func (o TableOutput) LocalReplicaInitializationInPercent() pulumi.IntOutput {
	return o.ApplyT(func(v *Table) pulumi.IntOutput { return v.LocalReplicaInitializationInPercent }).(pulumi.IntOutput)
}

// Table name.
func (o TableOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Table) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// An array of Replica listing this table's replicas, if any
func (o TableOutput) Replicas() TableReplicaTypeArrayOutput {
	return o.ApplyT(func(v *Table) TableReplicaTypeArrayOutput { return v.Replicas }).(TableReplicaTypeArrayOutput)
}

// The current state of this table's schema. Available states are MUTABLE - The schema can be changed. The table is not eligible for replication. FROZEN - The schema is immutable. The table is eligible for replication.
func (o TableOutput) SchemaState() pulumi.StringOutput {
	return o.ApplyT(func(v *Table) pulumi.StringOutput { return v.SchemaState }).(pulumi.StringOutput)
}

// The table schema information as a JSON object.
func (o TableOutput) Schemas() TableSchemaArrayOutput {
	return o.ApplyT(func(v *Table) TableSchemaArrayOutput { return v.Schemas }).(TableSchemaArrayOutput)
}

// The state of a table.
func (o TableOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v *Table) pulumi.StringOutput { return v.State }).(pulumi.StringOutput)
}

// Read-only system tag. These predefined keys are scoped to namespaces.  At present the only supported namespace is `"orcl-cloud"`; and the only key in that namespace is `"free-tier-retained"`. Example: `{"orcl-cloud"": {"free-tier-retained": "true"}}`
func (o TableOutput) SystemTags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Table) pulumi.StringMapOutput { return v.SystemTags }).(pulumi.StringMapOutput)
}

// (Updatable) Throughput and storage limits configuration of a table. It is required for top level table, must be null for child table as child table shares its top parent table's limits.
func (o TableOutput) TableLimits() TableTableLimitsOutput {
	return o.ApplyT(func(v *Table) TableTableLimitsOutput { return v.TableLimits }).(TableTableLimitsOutput)
}

// The time the the table was created. An RFC3339 formatted datetime string.
func (o TableOutput) TimeCreated() pulumi.StringOutput {
	return o.ApplyT(func(v *Table) pulumi.StringOutput { return v.TimeCreated }).(pulumi.StringOutput)
}

// If lifecycleState is INACTIVE, indicates when this table will be automatically removed. An RFC3339 formatted datetime string.
func (o TableOutput) TimeOfExpiration() pulumi.StringOutput {
	return o.ApplyT(func(v *Table) pulumi.StringOutput { return v.TimeOfExpiration }).(pulumi.StringOutput)
}

// The time the the table's metadata was last updated. An RFC3339 formatted datetime string.
func (o TableOutput) TimeUpdated() pulumi.StringOutput {
	return o.ApplyT(func(v *Table) pulumi.StringOutput { return v.TimeUpdated }).(pulumi.StringOutput)
}

type TableArrayOutput struct{ *pulumi.OutputState }

func (TableArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Table)(nil)).Elem()
}

func (o TableArrayOutput) ToTableArrayOutput() TableArrayOutput {
	return o
}

func (o TableArrayOutput) ToTableArrayOutputWithContext(ctx context.Context) TableArrayOutput {
	return o
}

func (o TableArrayOutput) Index(i pulumi.IntInput) TableOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Table {
		return vs[0].([]*Table)[vs[1].(int)]
	}).(TableOutput)
}

type TableMapOutput struct{ *pulumi.OutputState }

func (TableMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Table)(nil)).Elem()
}

func (o TableMapOutput) ToTableMapOutput() TableMapOutput {
	return o
}

func (o TableMapOutput) ToTableMapOutputWithContext(ctx context.Context) TableMapOutput {
	return o
}

func (o TableMapOutput) MapIndex(k pulumi.StringInput) TableOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Table {
		return vs[0].(map[string]*Table)[vs[1].(string)]
	}).(TableOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*TableInput)(nil)).Elem(), &Table{})
	pulumi.RegisterInputType(reflect.TypeOf((*TableArrayInput)(nil)).Elem(), TableArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TableMapInput)(nil)).Elem(), TableMap{})
	pulumi.RegisterOutputType(TableOutput{})
	pulumi.RegisterOutputType(TableArrayOutput{})
	pulumi.RegisterOutputType(TableMapOutput{})
}
