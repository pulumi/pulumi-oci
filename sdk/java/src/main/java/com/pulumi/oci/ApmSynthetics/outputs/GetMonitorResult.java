// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.oci.ApmSynthetics.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.oci.ApmSynthetics.outputs.GetMonitorAvailabilityConfiguration;
import com.pulumi.oci.ApmSynthetics.outputs.GetMonitorConfiguration;
import com.pulumi.oci.ApmSynthetics.outputs.GetMonitorMaintenanceWindowSchedule;
import com.pulumi.oci.ApmSynthetics.outputs.GetMonitorScriptParameter;
import com.pulumi.oci.ApmSynthetics.outputs.GetMonitorVantagePoint;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.Object;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;

@CustomType
public final class GetMonitorResult {
    private String apmDomainId;
    /**
     * @return Monitor availability configuration details.
     * 
     */
    private List<GetMonitorAvailabilityConfiguration> availabilityConfigurations;
    /**
     * @return Time interval between two runs in round robin batch mode (SchedulingPolicy - BATCHED_ROUND_ROBIN).
     * 
     */
    private Integer batchIntervalInSeconds;
    /**
     * @return Details of monitor configuration.
     * 
     */
    private List<GetMonitorConfiguration> configurations;
    /**
     * @return Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{&#34;foo-namespace.bar-key&#34;: &#34;value&#34;}`
     * 
     */
    private Map<String,Object> definedTags;
    /**
     * @return Unique name that can be edited. The name should not contain any confidential information.
     * 
     */
    private String displayName;
    /**
     * @return Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{&#34;bar-key&#34;: &#34;value&#34;}`
     * 
     */
    private Map<String,Object> freeformTags;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the monitor.
     * 
     */
    private String id;
    /**
     * @return If isRunNow is enabled, then the monitor will run immediately.
     * 
     */
    private Boolean isRunNow;
    /**
     * @return If runOnce is enabled, then the monitor will run once.
     * 
     */
    private Boolean isRunOnce;
    /**
     * @return Details required to schedule maintenance window.
     * 
     */
    private List<GetMonitorMaintenanceWindowSchedule> maintenanceWindowSchedules;
    private String monitorId;
    /**
     * @return Type of monitor.
     * 
     */
    private String monitorType;
    /**
     * @return Interval in seconds after the start time when the job should be repeated. Minimum repeatIntervalInSeconds should be 300 seconds for Scripted REST, Scripted Browser and Browser monitors, and 60 seconds for REST monitor.
     * 
     */
    private Integer repeatIntervalInSeconds;
    /**
     * @return Scheduling policy to decide the distribution of monitor executions on vantage points.
     * 
     */
    private String schedulingPolicy;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the script. scriptId is mandatory for creation of SCRIPTED_BROWSER and SCRIPTED_REST monitor types. For other monitor types, it should be set to null.
     * 
     */
    private String scriptId;
    /**
     * @return Name of the script.
     * 
     */
    private String scriptName;
    /**
     * @return List of script parameters. Example: `[{&#34;monitorScriptParameter&#34;: {&#34;paramName&#34;: &#34;userid&#34;, &#34;paramValue&#34;:&#34;testuser&#34;}, &#34;isSecret&#34;: false, &#34;isOverwritten&#34;: false}]`
     * 
     */
    private List<GetMonitorScriptParameter> scriptParameters;
    /**
     * @return Enables or disables the monitor.
     * 
     */
    private String status;
    /**
     * @return Specify the endpoint on which to run the monitor. For BROWSER and REST monitor types, target is mandatory. If target is specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script (specified by scriptId in monitor) against the specified target endpoint. If target is not specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script as it is. For NETWORK monitor with TCP protocol, a port needs to be provided along with target. Example: 192.168.0.1:80
     * 
     */
    private String target;
    /**
     * @return The time the resource was created, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-12T22:47:12.613Z`
     * 
     */
    private String timeCreated;
    /**
     * @return The time the resource was updated, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-13T22:47:12.613Z`
     * 
     */
    private String timeUpdated;
    /**
     * @return Timeout in seconds. If isFailureRetried is true, then timeout cannot be more than 30% of repeatIntervalInSeconds time for monitors. If isFailureRetried is false, then timeout cannot be more than 50% of repeatIntervalInSeconds time for monitors. Also, timeoutInSeconds should be a multiple of 60 for Scripted REST, Scripted Browser and Browser monitors. Monitor will be allowed to run only for timeoutInSeconds time. It would be terminated after that.
     * 
     */
    private Integer timeoutInSeconds;
    /**
     * @return Number of vantage points where monitor is running.
     * 
     */
    private Integer vantagePointCount;
    /**
     * @return List of public and dedicated vantage points where the monitor is running.
     * 
     */
    private List<GetMonitorVantagePoint> vantagePoints;

    private GetMonitorResult() {}
    public String apmDomainId() {
        return this.apmDomainId;
    }
    /**
     * @return Monitor availability configuration details.
     * 
     */
    public List<GetMonitorAvailabilityConfiguration> availabilityConfigurations() {
        return this.availabilityConfigurations;
    }
    /**
     * @return Time interval between two runs in round robin batch mode (SchedulingPolicy - BATCHED_ROUND_ROBIN).
     * 
     */
    public Integer batchIntervalInSeconds() {
        return this.batchIntervalInSeconds;
    }
    /**
     * @return Details of monitor configuration.
     * 
     */
    public List<GetMonitorConfiguration> configurations() {
        return this.configurations;
    }
    /**
     * @return Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{&#34;foo-namespace.bar-key&#34;: &#34;value&#34;}`
     * 
     */
    public Map<String,Object> definedTags() {
        return this.definedTags;
    }
    /**
     * @return Unique name that can be edited. The name should not contain any confidential information.
     * 
     */
    public String displayName() {
        return this.displayName;
    }
    /**
     * @return Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{&#34;bar-key&#34;: &#34;value&#34;}`
     * 
     */
    public Map<String,Object> freeformTags() {
        return this.freeformTags;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the monitor.
     * 
     */
    public String id() {
        return this.id;
    }
    /**
     * @return If isRunNow is enabled, then the monitor will run immediately.
     * 
     */
    public Boolean isRunNow() {
        return this.isRunNow;
    }
    /**
     * @return If runOnce is enabled, then the monitor will run once.
     * 
     */
    public Boolean isRunOnce() {
        return this.isRunOnce;
    }
    /**
     * @return Details required to schedule maintenance window.
     * 
     */
    public List<GetMonitorMaintenanceWindowSchedule> maintenanceWindowSchedules() {
        return this.maintenanceWindowSchedules;
    }
    public String monitorId() {
        return this.monitorId;
    }
    /**
     * @return Type of monitor.
     * 
     */
    public String monitorType() {
        return this.monitorType;
    }
    /**
     * @return Interval in seconds after the start time when the job should be repeated. Minimum repeatIntervalInSeconds should be 300 seconds for Scripted REST, Scripted Browser and Browser monitors, and 60 seconds for REST monitor.
     * 
     */
    public Integer repeatIntervalInSeconds() {
        return this.repeatIntervalInSeconds;
    }
    /**
     * @return Scheduling policy to decide the distribution of monitor executions on vantage points.
     * 
     */
    public String schedulingPolicy() {
        return this.schedulingPolicy;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the script. scriptId is mandatory for creation of SCRIPTED_BROWSER and SCRIPTED_REST monitor types. For other monitor types, it should be set to null.
     * 
     */
    public String scriptId() {
        return this.scriptId;
    }
    /**
     * @return Name of the script.
     * 
     */
    public String scriptName() {
        return this.scriptName;
    }
    /**
     * @return List of script parameters. Example: `[{&#34;monitorScriptParameter&#34;: {&#34;paramName&#34;: &#34;userid&#34;, &#34;paramValue&#34;:&#34;testuser&#34;}, &#34;isSecret&#34;: false, &#34;isOverwritten&#34;: false}]`
     * 
     */
    public List<GetMonitorScriptParameter> scriptParameters() {
        return this.scriptParameters;
    }
    /**
     * @return Enables or disables the monitor.
     * 
     */
    public String status() {
        return this.status;
    }
    /**
     * @return Specify the endpoint on which to run the monitor. For BROWSER and REST monitor types, target is mandatory. If target is specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script (specified by scriptId in monitor) against the specified target endpoint. If target is not specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script as it is. For NETWORK monitor with TCP protocol, a port needs to be provided along with target. Example: 192.168.0.1:80
     * 
     */
    public String target() {
        return this.target;
    }
    /**
     * @return The time the resource was created, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-12T22:47:12.613Z`
     * 
     */
    public String timeCreated() {
        return this.timeCreated;
    }
    /**
     * @return The time the resource was updated, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-13T22:47:12.613Z`
     * 
     */
    public String timeUpdated() {
        return this.timeUpdated;
    }
    /**
     * @return Timeout in seconds. If isFailureRetried is true, then timeout cannot be more than 30% of repeatIntervalInSeconds time for monitors. If isFailureRetried is false, then timeout cannot be more than 50% of repeatIntervalInSeconds time for monitors. Also, timeoutInSeconds should be a multiple of 60 for Scripted REST, Scripted Browser and Browser monitors. Monitor will be allowed to run only for timeoutInSeconds time. It would be terminated after that.
     * 
     */
    public Integer timeoutInSeconds() {
        return this.timeoutInSeconds;
    }
    /**
     * @return Number of vantage points where monitor is running.
     * 
     */
    public Integer vantagePointCount() {
        return this.vantagePointCount;
    }
    /**
     * @return List of public and dedicated vantage points where the monitor is running.
     * 
     */
    public List<GetMonitorVantagePoint> vantagePoints() {
        return this.vantagePoints;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetMonitorResult defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String apmDomainId;
        private List<GetMonitorAvailabilityConfiguration> availabilityConfigurations;
        private Integer batchIntervalInSeconds;
        private List<GetMonitorConfiguration> configurations;
        private Map<String,Object> definedTags;
        private String displayName;
        private Map<String,Object> freeformTags;
        private String id;
        private Boolean isRunNow;
        private Boolean isRunOnce;
        private List<GetMonitorMaintenanceWindowSchedule> maintenanceWindowSchedules;
        private String monitorId;
        private String monitorType;
        private Integer repeatIntervalInSeconds;
        private String schedulingPolicy;
        private String scriptId;
        private String scriptName;
        private List<GetMonitorScriptParameter> scriptParameters;
        private String status;
        private String target;
        private String timeCreated;
        private String timeUpdated;
        private Integer timeoutInSeconds;
        private Integer vantagePointCount;
        private List<GetMonitorVantagePoint> vantagePoints;
        public Builder() {}
        public Builder(GetMonitorResult defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.apmDomainId = defaults.apmDomainId;
    	      this.availabilityConfigurations = defaults.availabilityConfigurations;
    	      this.batchIntervalInSeconds = defaults.batchIntervalInSeconds;
    	      this.configurations = defaults.configurations;
    	      this.definedTags = defaults.definedTags;
    	      this.displayName = defaults.displayName;
    	      this.freeformTags = defaults.freeformTags;
    	      this.id = defaults.id;
    	      this.isRunNow = defaults.isRunNow;
    	      this.isRunOnce = defaults.isRunOnce;
    	      this.maintenanceWindowSchedules = defaults.maintenanceWindowSchedules;
    	      this.monitorId = defaults.monitorId;
    	      this.monitorType = defaults.monitorType;
    	      this.repeatIntervalInSeconds = defaults.repeatIntervalInSeconds;
    	      this.schedulingPolicy = defaults.schedulingPolicy;
    	      this.scriptId = defaults.scriptId;
    	      this.scriptName = defaults.scriptName;
    	      this.scriptParameters = defaults.scriptParameters;
    	      this.status = defaults.status;
    	      this.target = defaults.target;
    	      this.timeCreated = defaults.timeCreated;
    	      this.timeUpdated = defaults.timeUpdated;
    	      this.timeoutInSeconds = defaults.timeoutInSeconds;
    	      this.vantagePointCount = defaults.vantagePointCount;
    	      this.vantagePoints = defaults.vantagePoints;
        }

        @CustomType.Setter
        public Builder apmDomainId(String apmDomainId) {
            this.apmDomainId = Objects.requireNonNull(apmDomainId);
            return this;
        }
        @CustomType.Setter
        public Builder availabilityConfigurations(List<GetMonitorAvailabilityConfiguration> availabilityConfigurations) {
            this.availabilityConfigurations = Objects.requireNonNull(availabilityConfigurations);
            return this;
        }
        public Builder availabilityConfigurations(GetMonitorAvailabilityConfiguration... availabilityConfigurations) {
            return availabilityConfigurations(List.of(availabilityConfigurations));
        }
        @CustomType.Setter
        public Builder batchIntervalInSeconds(Integer batchIntervalInSeconds) {
            this.batchIntervalInSeconds = Objects.requireNonNull(batchIntervalInSeconds);
            return this;
        }
        @CustomType.Setter
        public Builder configurations(List<GetMonitorConfiguration> configurations) {
            this.configurations = Objects.requireNonNull(configurations);
            return this;
        }
        public Builder configurations(GetMonitorConfiguration... configurations) {
            return configurations(List.of(configurations));
        }
        @CustomType.Setter
        public Builder definedTags(Map<String,Object> definedTags) {
            this.definedTags = Objects.requireNonNull(definedTags);
            return this;
        }
        @CustomType.Setter
        public Builder displayName(String displayName) {
            this.displayName = Objects.requireNonNull(displayName);
            return this;
        }
        @CustomType.Setter
        public Builder freeformTags(Map<String,Object> freeformTags) {
            this.freeformTags = Objects.requireNonNull(freeformTags);
            return this;
        }
        @CustomType.Setter
        public Builder id(String id) {
            this.id = Objects.requireNonNull(id);
            return this;
        }
        @CustomType.Setter
        public Builder isRunNow(Boolean isRunNow) {
            this.isRunNow = Objects.requireNonNull(isRunNow);
            return this;
        }
        @CustomType.Setter
        public Builder isRunOnce(Boolean isRunOnce) {
            this.isRunOnce = Objects.requireNonNull(isRunOnce);
            return this;
        }
        @CustomType.Setter
        public Builder maintenanceWindowSchedules(List<GetMonitorMaintenanceWindowSchedule> maintenanceWindowSchedules) {
            this.maintenanceWindowSchedules = Objects.requireNonNull(maintenanceWindowSchedules);
            return this;
        }
        public Builder maintenanceWindowSchedules(GetMonitorMaintenanceWindowSchedule... maintenanceWindowSchedules) {
            return maintenanceWindowSchedules(List.of(maintenanceWindowSchedules));
        }
        @CustomType.Setter
        public Builder monitorId(String monitorId) {
            this.monitorId = Objects.requireNonNull(monitorId);
            return this;
        }
        @CustomType.Setter
        public Builder monitorType(String monitorType) {
            this.monitorType = Objects.requireNonNull(monitorType);
            return this;
        }
        @CustomType.Setter
        public Builder repeatIntervalInSeconds(Integer repeatIntervalInSeconds) {
            this.repeatIntervalInSeconds = Objects.requireNonNull(repeatIntervalInSeconds);
            return this;
        }
        @CustomType.Setter
        public Builder schedulingPolicy(String schedulingPolicy) {
            this.schedulingPolicy = Objects.requireNonNull(schedulingPolicy);
            return this;
        }
        @CustomType.Setter
        public Builder scriptId(String scriptId) {
            this.scriptId = Objects.requireNonNull(scriptId);
            return this;
        }
        @CustomType.Setter
        public Builder scriptName(String scriptName) {
            this.scriptName = Objects.requireNonNull(scriptName);
            return this;
        }
        @CustomType.Setter
        public Builder scriptParameters(List<GetMonitorScriptParameter> scriptParameters) {
            this.scriptParameters = Objects.requireNonNull(scriptParameters);
            return this;
        }
        public Builder scriptParameters(GetMonitorScriptParameter... scriptParameters) {
            return scriptParameters(List.of(scriptParameters));
        }
        @CustomType.Setter
        public Builder status(String status) {
            this.status = Objects.requireNonNull(status);
            return this;
        }
        @CustomType.Setter
        public Builder target(String target) {
            this.target = Objects.requireNonNull(target);
            return this;
        }
        @CustomType.Setter
        public Builder timeCreated(String timeCreated) {
            this.timeCreated = Objects.requireNonNull(timeCreated);
            return this;
        }
        @CustomType.Setter
        public Builder timeUpdated(String timeUpdated) {
            this.timeUpdated = Objects.requireNonNull(timeUpdated);
            return this;
        }
        @CustomType.Setter
        public Builder timeoutInSeconds(Integer timeoutInSeconds) {
            this.timeoutInSeconds = Objects.requireNonNull(timeoutInSeconds);
            return this;
        }
        @CustomType.Setter
        public Builder vantagePointCount(Integer vantagePointCount) {
            this.vantagePointCount = Objects.requireNonNull(vantagePointCount);
            return this;
        }
        @CustomType.Setter
        public Builder vantagePoints(List<GetMonitorVantagePoint> vantagePoints) {
            this.vantagePoints = Objects.requireNonNull(vantagePoints);
            return this;
        }
        public Builder vantagePoints(GetMonitorVantagePoint... vantagePoints) {
            return vantagePoints(List.of(vantagePoints));
        }
        public GetMonitorResult build() {
            final var _resultValue = new GetMonitorResult();
            _resultValue.apmDomainId = apmDomainId;
            _resultValue.availabilityConfigurations = availabilityConfigurations;
            _resultValue.batchIntervalInSeconds = batchIntervalInSeconds;
            _resultValue.configurations = configurations;
            _resultValue.definedTags = definedTags;
            _resultValue.displayName = displayName;
            _resultValue.freeformTags = freeformTags;
            _resultValue.id = id;
            _resultValue.isRunNow = isRunNow;
            _resultValue.isRunOnce = isRunOnce;
            _resultValue.maintenanceWindowSchedules = maintenanceWindowSchedules;
            _resultValue.monitorId = monitorId;
            _resultValue.monitorType = monitorType;
            _resultValue.repeatIntervalInSeconds = repeatIntervalInSeconds;
            _resultValue.schedulingPolicy = schedulingPolicy;
            _resultValue.scriptId = scriptId;
            _resultValue.scriptName = scriptName;
            _resultValue.scriptParameters = scriptParameters;
            _resultValue.status = status;
            _resultValue.target = target;
            _resultValue.timeCreated = timeCreated;
            _resultValue.timeUpdated = timeUpdated;
            _resultValue.timeoutInSeconds = timeoutInSeconds;
            _resultValue.vantagePointCount = vantagePointCount;
            _resultValue.vantagePoints = vantagePoints;
            return _resultValue;
        }
    }
}
