// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.oci.ApmSynthetics.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.oci.ApmSynthetics.outputs.GetMonitorsMonitorCollectionItemConfiguration;
import com.pulumi.oci.ApmSynthetics.outputs.GetMonitorsMonitorCollectionItemScriptParameter;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.Object;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;

@CustomType
public final class GetMonitorsMonitorCollectionItem {
    /**
     * @return The APM domain ID the request is intended for.
     * 
     */
    private final String apmDomainId;
    /**
     * @return Time interval between 2 runs in round robin batch mode (*SchedulingPolicy - BATCHED_ROUND_ROBIN).
     * 
     */
    private final Integer batchIntervalInSeconds;
    /**
     * @return Details of monitor configuration.
     * 
     */
    private final List<GetMonitorsMonitorCollectionItemConfiguration> configurations;
    /**
     * @return Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{&#34;foo-namespace.bar-key&#34;: &#34;value&#34;}`
     * 
     */
    private final Map<String,Object> definedTags;
    /**
     * @return A filter to return only the resources that match the entire display name.
     * 
     */
    private final String displayName;
    /**
     * @return Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{&#34;bar-key&#34;: &#34;value&#34;}`
     * 
     */
    private final Map<String,Object> freeformTags;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the monitor.
     * 
     */
    private final String id;
    /**
     * @return If isRunNow is enabled, then the monitor will run now.
     * 
     */
    private final Boolean isRunNow;
    /**
     * @return If runOnce is enabled, then the monitor will run once.
     * 
     */
    private final Boolean isRunOnce;
    /**
     * @return A filter to return only monitors that match the given monitor type. Supported values are SCRIPTED_BROWSER, BROWSER, SCRIPTED_REST and REST.
     * 
     */
    private final String monitorType;
    /**
     * @return Interval in seconds after the start time when the job should be repeated. Minimum repeatIntervalInSeconds should be 300 seconds for Scripted REST, Scripted Browser and Browser monitors, and 60 seconds for REST monitor.
     * 
     */
    private final Integer repeatIntervalInSeconds;
    /**
     * @return Scheduling policy on Vantage points.
     * 
     */
    private final String schedulingPolicy;
    /**
     * @return A filter to return only monitors using scriptId.
     * 
     */
    private final String scriptId;
    /**
     * @return Name of the script.
     * 
     */
    private final String scriptName;
    /**
     * @return List of script parameters. Example: `[{&#34;monitorScriptParameter&#34;: {&#34;paramName&#34;: &#34;userid&#34;, &#34;paramValue&#34;:&#34;testuser&#34;}, &#34;isSecret&#34;: false, &#34;isOverwritten&#34;: false}]`
     * 
     */
    private final List<GetMonitorsMonitorCollectionItemScriptParameter> scriptParameters;
    /**
     * @return A filter to return only monitors that match the status given.
     * 
     */
    private final String status;
    /**
     * @return Specify the endpoint on which to run the monitor. For BROWSER and REST monitor types, target is mandatory. If target is specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script (specified by scriptId in monitor) against the specified target endpoint. If target is not specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script as it is.
     * 
     */
    private final String target;
    /**
     * @return The time the resource was created, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-12T22:47:12.613Z`
     * 
     */
    private final String timeCreated;
    /**
     * @return The time the resource was updated, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-13T22:47:12.613Z`
     * 
     */
    private final String timeUpdated;
    /**
     * @return Timeout in seconds. Timeout cannot be more than 30% of repeatIntervalInSeconds time for monitors. Also, timeoutInSeconds should be a multiple of 60 for Scripted REST, Scripted Browser and Browser monitors. Monitor will be allowed to run only for timeoutInSeconds time. It would be terminated after that.
     * 
     */
    private final Integer timeoutInSeconds;
    /**
     * @return Number of vantage points where monitor is running.
     * 
     */
    private final Integer vantagePointCount;
    /**
     * @return List of public and dedicated vantage points where the monitor is running.
     * 
     */
    private final List<String> vantagePoints;

    @CustomType.Constructor
    private GetMonitorsMonitorCollectionItem(
        @CustomType.Parameter("apmDomainId") String apmDomainId,
        @CustomType.Parameter("batchIntervalInSeconds") Integer batchIntervalInSeconds,
        @CustomType.Parameter("configurations") List<GetMonitorsMonitorCollectionItemConfiguration> configurations,
        @CustomType.Parameter("definedTags") Map<String,Object> definedTags,
        @CustomType.Parameter("displayName") String displayName,
        @CustomType.Parameter("freeformTags") Map<String,Object> freeformTags,
        @CustomType.Parameter("id") String id,
        @CustomType.Parameter("isRunNow") Boolean isRunNow,
        @CustomType.Parameter("isRunOnce") Boolean isRunOnce,
        @CustomType.Parameter("monitorType") String monitorType,
        @CustomType.Parameter("repeatIntervalInSeconds") Integer repeatIntervalInSeconds,
        @CustomType.Parameter("schedulingPolicy") String schedulingPolicy,
        @CustomType.Parameter("scriptId") String scriptId,
        @CustomType.Parameter("scriptName") String scriptName,
        @CustomType.Parameter("scriptParameters") List<GetMonitorsMonitorCollectionItemScriptParameter> scriptParameters,
        @CustomType.Parameter("status") String status,
        @CustomType.Parameter("target") String target,
        @CustomType.Parameter("timeCreated") String timeCreated,
        @CustomType.Parameter("timeUpdated") String timeUpdated,
        @CustomType.Parameter("timeoutInSeconds") Integer timeoutInSeconds,
        @CustomType.Parameter("vantagePointCount") Integer vantagePointCount,
        @CustomType.Parameter("vantagePoints") List<String> vantagePoints) {
        this.apmDomainId = apmDomainId;
        this.batchIntervalInSeconds = batchIntervalInSeconds;
        this.configurations = configurations;
        this.definedTags = definedTags;
        this.displayName = displayName;
        this.freeformTags = freeformTags;
        this.id = id;
        this.isRunNow = isRunNow;
        this.isRunOnce = isRunOnce;
        this.monitorType = monitorType;
        this.repeatIntervalInSeconds = repeatIntervalInSeconds;
        this.schedulingPolicy = schedulingPolicy;
        this.scriptId = scriptId;
        this.scriptName = scriptName;
        this.scriptParameters = scriptParameters;
        this.status = status;
        this.target = target;
        this.timeCreated = timeCreated;
        this.timeUpdated = timeUpdated;
        this.timeoutInSeconds = timeoutInSeconds;
        this.vantagePointCount = vantagePointCount;
        this.vantagePoints = vantagePoints;
    }

    /**
     * @return The APM domain ID the request is intended for.
     * 
     */
    public String apmDomainId() {
        return this.apmDomainId;
    }
    /**
     * @return Time interval between 2 runs in round robin batch mode (*SchedulingPolicy - BATCHED_ROUND_ROBIN).
     * 
     */
    public Integer batchIntervalInSeconds() {
        return this.batchIntervalInSeconds;
    }
    /**
     * @return Details of monitor configuration.
     * 
     */
    public List<GetMonitorsMonitorCollectionItemConfiguration> configurations() {
        return this.configurations;
    }
    /**
     * @return Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{&#34;foo-namespace.bar-key&#34;: &#34;value&#34;}`
     * 
     */
    public Map<String,Object> definedTags() {
        return this.definedTags;
    }
    /**
     * @return A filter to return only the resources that match the entire display name.
     * 
     */
    public String displayName() {
        return this.displayName;
    }
    /**
     * @return Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{&#34;bar-key&#34;: &#34;value&#34;}`
     * 
     */
    public Map<String,Object> freeformTags() {
        return this.freeformTags;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the monitor.
     * 
     */
    public String id() {
        return this.id;
    }
    /**
     * @return If isRunNow is enabled, then the monitor will run now.
     * 
     */
    public Boolean isRunNow() {
        return this.isRunNow;
    }
    /**
     * @return If runOnce is enabled, then the monitor will run once.
     * 
     */
    public Boolean isRunOnce() {
        return this.isRunOnce;
    }
    /**
     * @return A filter to return only monitors that match the given monitor type. Supported values are SCRIPTED_BROWSER, BROWSER, SCRIPTED_REST and REST.
     * 
     */
    public String monitorType() {
        return this.monitorType;
    }
    /**
     * @return Interval in seconds after the start time when the job should be repeated. Minimum repeatIntervalInSeconds should be 300 seconds for Scripted REST, Scripted Browser and Browser monitors, and 60 seconds for REST monitor.
     * 
     */
    public Integer repeatIntervalInSeconds() {
        return this.repeatIntervalInSeconds;
    }
    /**
     * @return Scheduling policy on Vantage points.
     * 
     */
    public String schedulingPolicy() {
        return this.schedulingPolicy;
    }
    /**
     * @return A filter to return only monitors using scriptId.
     * 
     */
    public String scriptId() {
        return this.scriptId;
    }
    /**
     * @return Name of the script.
     * 
     */
    public String scriptName() {
        return this.scriptName;
    }
    /**
     * @return List of script parameters. Example: `[{&#34;monitorScriptParameter&#34;: {&#34;paramName&#34;: &#34;userid&#34;, &#34;paramValue&#34;:&#34;testuser&#34;}, &#34;isSecret&#34;: false, &#34;isOverwritten&#34;: false}]`
     * 
     */
    public List<GetMonitorsMonitorCollectionItemScriptParameter> scriptParameters() {
        return this.scriptParameters;
    }
    /**
     * @return A filter to return only monitors that match the status given.
     * 
     */
    public String status() {
        return this.status;
    }
    /**
     * @return Specify the endpoint on which to run the monitor. For BROWSER and REST monitor types, target is mandatory. If target is specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script (specified by scriptId in monitor) against the specified target endpoint. If target is not specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script as it is.
     * 
     */
    public String target() {
        return this.target;
    }
    /**
     * @return The time the resource was created, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-12T22:47:12.613Z`
     * 
     */
    public String timeCreated() {
        return this.timeCreated;
    }
    /**
     * @return The time the resource was updated, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-13T22:47:12.613Z`
     * 
     */
    public String timeUpdated() {
        return this.timeUpdated;
    }
    /**
     * @return Timeout in seconds. Timeout cannot be more than 30% of repeatIntervalInSeconds time for monitors. Also, timeoutInSeconds should be a multiple of 60 for Scripted REST, Scripted Browser and Browser monitors. Monitor will be allowed to run only for timeoutInSeconds time. It would be terminated after that.
     * 
     */
    public Integer timeoutInSeconds() {
        return this.timeoutInSeconds;
    }
    /**
     * @return Number of vantage points where monitor is running.
     * 
     */
    public Integer vantagePointCount() {
        return this.vantagePointCount;
    }
    /**
     * @return List of public and dedicated vantage points where the monitor is running.
     * 
     */
    public List<String> vantagePoints() {
        return this.vantagePoints;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetMonitorsMonitorCollectionItem defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private String apmDomainId;
        private Integer batchIntervalInSeconds;
        private List<GetMonitorsMonitorCollectionItemConfiguration> configurations;
        private Map<String,Object> definedTags;
        private String displayName;
        private Map<String,Object> freeformTags;
        private String id;
        private Boolean isRunNow;
        private Boolean isRunOnce;
        private String monitorType;
        private Integer repeatIntervalInSeconds;
        private String schedulingPolicy;
        private String scriptId;
        private String scriptName;
        private List<GetMonitorsMonitorCollectionItemScriptParameter> scriptParameters;
        private String status;
        private String target;
        private String timeCreated;
        private String timeUpdated;
        private Integer timeoutInSeconds;
        private Integer vantagePointCount;
        private List<String> vantagePoints;

        public Builder() {
    	      // Empty
        }

        public Builder(GetMonitorsMonitorCollectionItem defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.apmDomainId = defaults.apmDomainId;
    	      this.batchIntervalInSeconds = defaults.batchIntervalInSeconds;
    	      this.configurations = defaults.configurations;
    	      this.definedTags = defaults.definedTags;
    	      this.displayName = defaults.displayName;
    	      this.freeformTags = defaults.freeformTags;
    	      this.id = defaults.id;
    	      this.isRunNow = defaults.isRunNow;
    	      this.isRunOnce = defaults.isRunOnce;
    	      this.monitorType = defaults.monitorType;
    	      this.repeatIntervalInSeconds = defaults.repeatIntervalInSeconds;
    	      this.schedulingPolicy = defaults.schedulingPolicy;
    	      this.scriptId = defaults.scriptId;
    	      this.scriptName = defaults.scriptName;
    	      this.scriptParameters = defaults.scriptParameters;
    	      this.status = defaults.status;
    	      this.target = defaults.target;
    	      this.timeCreated = defaults.timeCreated;
    	      this.timeUpdated = defaults.timeUpdated;
    	      this.timeoutInSeconds = defaults.timeoutInSeconds;
    	      this.vantagePointCount = defaults.vantagePointCount;
    	      this.vantagePoints = defaults.vantagePoints;
        }

        public Builder apmDomainId(String apmDomainId) {
            this.apmDomainId = Objects.requireNonNull(apmDomainId);
            return this;
        }
        public Builder batchIntervalInSeconds(Integer batchIntervalInSeconds) {
            this.batchIntervalInSeconds = Objects.requireNonNull(batchIntervalInSeconds);
            return this;
        }
        public Builder configurations(List<GetMonitorsMonitorCollectionItemConfiguration> configurations) {
            this.configurations = Objects.requireNonNull(configurations);
            return this;
        }
        public Builder configurations(GetMonitorsMonitorCollectionItemConfiguration... configurations) {
            return configurations(List.of(configurations));
        }
        public Builder definedTags(Map<String,Object> definedTags) {
            this.definedTags = Objects.requireNonNull(definedTags);
            return this;
        }
        public Builder displayName(String displayName) {
            this.displayName = Objects.requireNonNull(displayName);
            return this;
        }
        public Builder freeformTags(Map<String,Object> freeformTags) {
            this.freeformTags = Objects.requireNonNull(freeformTags);
            return this;
        }
        public Builder id(String id) {
            this.id = Objects.requireNonNull(id);
            return this;
        }
        public Builder isRunNow(Boolean isRunNow) {
            this.isRunNow = Objects.requireNonNull(isRunNow);
            return this;
        }
        public Builder isRunOnce(Boolean isRunOnce) {
            this.isRunOnce = Objects.requireNonNull(isRunOnce);
            return this;
        }
        public Builder monitorType(String monitorType) {
            this.monitorType = Objects.requireNonNull(monitorType);
            return this;
        }
        public Builder repeatIntervalInSeconds(Integer repeatIntervalInSeconds) {
            this.repeatIntervalInSeconds = Objects.requireNonNull(repeatIntervalInSeconds);
            return this;
        }
        public Builder schedulingPolicy(String schedulingPolicy) {
            this.schedulingPolicy = Objects.requireNonNull(schedulingPolicy);
            return this;
        }
        public Builder scriptId(String scriptId) {
            this.scriptId = Objects.requireNonNull(scriptId);
            return this;
        }
        public Builder scriptName(String scriptName) {
            this.scriptName = Objects.requireNonNull(scriptName);
            return this;
        }
        public Builder scriptParameters(List<GetMonitorsMonitorCollectionItemScriptParameter> scriptParameters) {
            this.scriptParameters = Objects.requireNonNull(scriptParameters);
            return this;
        }
        public Builder scriptParameters(GetMonitorsMonitorCollectionItemScriptParameter... scriptParameters) {
            return scriptParameters(List.of(scriptParameters));
        }
        public Builder status(String status) {
            this.status = Objects.requireNonNull(status);
            return this;
        }
        public Builder target(String target) {
            this.target = Objects.requireNonNull(target);
            return this;
        }
        public Builder timeCreated(String timeCreated) {
            this.timeCreated = Objects.requireNonNull(timeCreated);
            return this;
        }
        public Builder timeUpdated(String timeUpdated) {
            this.timeUpdated = Objects.requireNonNull(timeUpdated);
            return this;
        }
        public Builder timeoutInSeconds(Integer timeoutInSeconds) {
            this.timeoutInSeconds = Objects.requireNonNull(timeoutInSeconds);
            return this;
        }
        public Builder vantagePointCount(Integer vantagePointCount) {
            this.vantagePointCount = Objects.requireNonNull(vantagePointCount);
            return this;
        }
        public Builder vantagePoints(List<String> vantagePoints) {
            this.vantagePoints = Objects.requireNonNull(vantagePoints);
            return this;
        }
        public Builder vantagePoints(String... vantagePoints) {
            return vantagePoints(List.of(vantagePoints));
        }        public GetMonitorsMonitorCollectionItem build() {
            return new GetMonitorsMonitorCollectionItem(apmDomainId, batchIntervalInSeconds, configurations, definedTags, displayName, freeformTags, id, isRunNow, isRunOnce, monitorType, repeatIntervalInSeconds, schedulingPolicy, scriptId, scriptName, scriptParameters, status, target, timeCreated, timeUpdated, timeoutInSeconds, vantagePointCount, vantagePoints);
        }
    }
}
