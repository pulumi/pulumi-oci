// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.oci.ApmSynthetics.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.oci.ApmSynthetics.outputs.GetMonitorsMonitorCollectionItemAvailabilityConfiguration;
import com.pulumi.oci.ApmSynthetics.outputs.GetMonitorsMonitorCollectionItemConfiguration;
import com.pulumi.oci.ApmSynthetics.outputs.GetMonitorsMonitorCollectionItemMaintenanceWindowSchedule;
import com.pulumi.oci.ApmSynthetics.outputs.GetMonitorsMonitorCollectionItemScriptParameter;
import com.pulumi.oci.ApmSynthetics.outputs.GetMonitorsMonitorCollectionItemVantagePoint;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.Object;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;

@CustomType
public final class GetMonitorsMonitorCollectionItem {
    /**
     * @return The APM domain ID the request is intended for.
     * 
     */
    private String apmDomainId;
    /**
     * @return Monitor availability configuration details.
     * 
     */
    private List<GetMonitorsMonitorCollectionItemAvailabilityConfiguration> availabilityConfigurations;
    /**
     * @return Time interval between two runs in round robin batch mode (SchedulingPolicy - BATCHED_ROUND_ROBIN).
     * 
     */
    private Integer batchIntervalInSeconds;
    /**
     * @return Details of monitor configuration.
     * 
     */
    private List<GetMonitorsMonitorCollectionItemConfiguration> configurations;
    /**
     * @return Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{&#34;foo-namespace.bar-key&#34;: &#34;value&#34;}`
     * 
     */
    private Map<String,Object> definedTags;
    /**
     * @return A filter to return only the resources that match the entire display name.
     * 
     */
    private String displayName;
    /**
     * @return Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{&#34;bar-key&#34;: &#34;value&#34;}`
     * 
     */
    private Map<String,Object> freeformTags;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the monitor.
     * 
     */
    private String id;
    /**
     * @return If isRunNow is enabled, then the monitor will run immediately.
     * 
     */
    private Boolean isRunNow;
    /**
     * @return If runOnce is enabled, then the monitor will run once.
     * 
     */
    private Boolean isRunOnce;
    /**
     * @return Details required to schedule maintenance window.
     * 
     */
    private List<GetMonitorsMonitorCollectionItemMaintenanceWindowSchedule> maintenanceWindowSchedules;
    /**
     * @return A filter to return only monitors that match the given monitor type. Supported values are SCRIPTED_BROWSER, BROWSER, SCRIPTED_REST and REST.
     * 
     */
    private String monitorType;
    /**
     * @return Interval in seconds after the start time when the job should be repeated. Minimum repeatIntervalInSeconds should be 300 seconds for Scripted REST, Scripted Browser and Browser monitors, and 60 seconds for REST monitor.
     * 
     */
    private Integer repeatIntervalInSeconds;
    /**
     * @return Scheduling policy to decide the distribution of monitor executions on vantage points.
     * 
     */
    private String schedulingPolicy;
    /**
     * @return A filter to return only monitors using scriptId.
     * 
     */
    private String scriptId;
    /**
     * @return Name of the script.
     * 
     */
    private String scriptName;
    /**
     * @return List of script parameters. Example: `[{&#34;monitorScriptParameter&#34;: {&#34;paramName&#34;: &#34;userid&#34;, &#34;paramValue&#34;:&#34;testuser&#34;}, &#34;isSecret&#34;: false, &#34;isOverwritten&#34;: false}]`
     * 
     */
    private List<GetMonitorsMonitorCollectionItemScriptParameter> scriptParameters;
    /**
     * @return A filter to return only monitors that match the status given.
     * 
     */
    private String status;
    /**
     * @return Specify the endpoint on which to run the monitor. For BROWSER and REST monitor types, target is mandatory. If target is specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script (specified by scriptId in monitor) against the specified target endpoint. If target is not specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script as it is. For NETWORK monitor with TCP protocol, a port needs to be provided along with target. Example: 192.168.0.1:80
     * 
     */
    private String target;
    /**
     * @return The time the resource was created, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-12T22:47:12.613Z`
     * 
     */
    private String timeCreated;
    /**
     * @return The time the resource was updated, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-13T22:47:12.613Z`
     * 
     */
    private String timeUpdated;
    /**
     * @return Timeout in seconds. If isFailureRetried is true, then timeout cannot be more than 30% of repeatIntervalInSeconds time for monitors. If isFailureRetried is false, then timeout cannot be more than 50% of repeatIntervalInSeconds time for monitors. Also, timeoutInSeconds should be a multiple of 60 for Scripted REST, Scripted Browser and Browser monitors. Monitor will be allowed to run only for timeoutInSeconds time. It would be terminated after that.
     * 
     */
    private Integer timeoutInSeconds;
    /**
     * @return Number of vantage points where monitor is running.
     * 
     */
    private Integer vantagePointCount;
    /**
     * @return List of public and dedicated vantage points where the monitor is running.
     * 
     */
    private List<GetMonitorsMonitorCollectionItemVantagePoint> vantagePoints;

    private GetMonitorsMonitorCollectionItem() {}
    /**
     * @return The APM domain ID the request is intended for.
     * 
     */
    public String apmDomainId() {
        return this.apmDomainId;
    }
    /**
     * @return Monitor availability configuration details.
     * 
     */
    public List<GetMonitorsMonitorCollectionItemAvailabilityConfiguration> availabilityConfigurations() {
        return this.availabilityConfigurations;
    }
    /**
     * @return Time interval between two runs in round robin batch mode (SchedulingPolicy - BATCHED_ROUND_ROBIN).
     * 
     */
    public Integer batchIntervalInSeconds() {
        return this.batchIntervalInSeconds;
    }
    /**
     * @return Details of monitor configuration.
     * 
     */
    public List<GetMonitorsMonitorCollectionItemConfiguration> configurations() {
        return this.configurations;
    }
    /**
     * @return Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{&#34;foo-namespace.bar-key&#34;: &#34;value&#34;}`
     * 
     */
    public Map<String,Object> definedTags() {
        return this.definedTags;
    }
    /**
     * @return A filter to return only the resources that match the entire display name.
     * 
     */
    public String displayName() {
        return this.displayName;
    }
    /**
     * @return Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{&#34;bar-key&#34;: &#34;value&#34;}`
     * 
     */
    public Map<String,Object> freeformTags() {
        return this.freeformTags;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the monitor.
     * 
     */
    public String id() {
        return this.id;
    }
    /**
     * @return If isRunNow is enabled, then the monitor will run immediately.
     * 
     */
    public Boolean isRunNow() {
        return this.isRunNow;
    }
    /**
     * @return If runOnce is enabled, then the monitor will run once.
     * 
     */
    public Boolean isRunOnce() {
        return this.isRunOnce;
    }
    /**
     * @return Details required to schedule maintenance window.
     * 
     */
    public List<GetMonitorsMonitorCollectionItemMaintenanceWindowSchedule> maintenanceWindowSchedules() {
        return this.maintenanceWindowSchedules;
    }
    /**
     * @return A filter to return only monitors that match the given monitor type. Supported values are SCRIPTED_BROWSER, BROWSER, SCRIPTED_REST and REST.
     * 
     */
    public String monitorType() {
        return this.monitorType;
    }
    /**
     * @return Interval in seconds after the start time when the job should be repeated. Minimum repeatIntervalInSeconds should be 300 seconds for Scripted REST, Scripted Browser and Browser monitors, and 60 seconds for REST monitor.
     * 
     */
    public Integer repeatIntervalInSeconds() {
        return this.repeatIntervalInSeconds;
    }
    /**
     * @return Scheduling policy to decide the distribution of monitor executions on vantage points.
     * 
     */
    public String schedulingPolicy() {
        return this.schedulingPolicy;
    }
    /**
     * @return A filter to return only monitors using scriptId.
     * 
     */
    public String scriptId() {
        return this.scriptId;
    }
    /**
     * @return Name of the script.
     * 
     */
    public String scriptName() {
        return this.scriptName;
    }
    /**
     * @return List of script parameters. Example: `[{&#34;monitorScriptParameter&#34;: {&#34;paramName&#34;: &#34;userid&#34;, &#34;paramValue&#34;:&#34;testuser&#34;}, &#34;isSecret&#34;: false, &#34;isOverwritten&#34;: false}]`
     * 
     */
    public List<GetMonitorsMonitorCollectionItemScriptParameter> scriptParameters() {
        return this.scriptParameters;
    }
    /**
     * @return A filter to return only monitors that match the status given.
     * 
     */
    public String status() {
        return this.status;
    }
    /**
     * @return Specify the endpoint on which to run the monitor. For BROWSER and REST monitor types, target is mandatory. If target is specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script (specified by scriptId in monitor) against the specified target endpoint. If target is not specified in the SCRIPTED_BROWSER monitor type, then the monitor will run the selected script as it is. For NETWORK monitor with TCP protocol, a port needs to be provided along with target. Example: 192.168.0.1:80
     * 
     */
    public String target() {
        return this.target;
    }
    /**
     * @return The time the resource was created, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-12T22:47:12.613Z`
     * 
     */
    public String timeCreated() {
        return this.timeCreated;
    }
    /**
     * @return The time the resource was updated, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-13T22:47:12.613Z`
     * 
     */
    public String timeUpdated() {
        return this.timeUpdated;
    }
    /**
     * @return Timeout in seconds. If isFailureRetried is true, then timeout cannot be more than 30% of repeatIntervalInSeconds time for monitors. If isFailureRetried is false, then timeout cannot be more than 50% of repeatIntervalInSeconds time for monitors. Also, timeoutInSeconds should be a multiple of 60 for Scripted REST, Scripted Browser and Browser monitors. Monitor will be allowed to run only for timeoutInSeconds time. It would be terminated after that.
     * 
     */
    public Integer timeoutInSeconds() {
        return this.timeoutInSeconds;
    }
    /**
     * @return Number of vantage points where monitor is running.
     * 
     */
    public Integer vantagePointCount() {
        return this.vantagePointCount;
    }
    /**
     * @return List of public and dedicated vantage points where the monitor is running.
     * 
     */
    public List<GetMonitorsMonitorCollectionItemVantagePoint> vantagePoints() {
        return this.vantagePoints;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetMonitorsMonitorCollectionItem defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String apmDomainId;
        private List<GetMonitorsMonitorCollectionItemAvailabilityConfiguration> availabilityConfigurations;
        private Integer batchIntervalInSeconds;
        private List<GetMonitorsMonitorCollectionItemConfiguration> configurations;
        private Map<String,Object> definedTags;
        private String displayName;
        private Map<String,Object> freeformTags;
        private String id;
        private Boolean isRunNow;
        private Boolean isRunOnce;
        private List<GetMonitorsMonitorCollectionItemMaintenanceWindowSchedule> maintenanceWindowSchedules;
        private String monitorType;
        private Integer repeatIntervalInSeconds;
        private String schedulingPolicy;
        private String scriptId;
        private String scriptName;
        private List<GetMonitorsMonitorCollectionItemScriptParameter> scriptParameters;
        private String status;
        private String target;
        private String timeCreated;
        private String timeUpdated;
        private Integer timeoutInSeconds;
        private Integer vantagePointCount;
        private List<GetMonitorsMonitorCollectionItemVantagePoint> vantagePoints;
        public Builder() {}
        public Builder(GetMonitorsMonitorCollectionItem defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.apmDomainId = defaults.apmDomainId;
    	      this.availabilityConfigurations = defaults.availabilityConfigurations;
    	      this.batchIntervalInSeconds = defaults.batchIntervalInSeconds;
    	      this.configurations = defaults.configurations;
    	      this.definedTags = defaults.definedTags;
    	      this.displayName = defaults.displayName;
    	      this.freeformTags = defaults.freeformTags;
    	      this.id = defaults.id;
    	      this.isRunNow = defaults.isRunNow;
    	      this.isRunOnce = defaults.isRunOnce;
    	      this.maintenanceWindowSchedules = defaults.maintenanceWindowSchedules;
    	      this.monitorType = defaults.monitorType;
    	      this.repeatIntervalInSeconds = defaults.repeatIntervalInSeconds;
    	      this.schedulingPolicy = defaults.schedulingPolicy;
    	      this.scriptId = defaults.scriptId;
    	      this.scriptName = defaults.scriptName;
    	      this.scriptParameters = defaults.scriptParameters;
    	      this.status = defaults.status;
    	      this.target = defaults.target;
    	      this.timeCreated = defaults.timeCreated;
    	      this.timeUpdated = defaults.timeUpdated;
    	      this.timeoutInSeconds = defaults.timeoutInSeconds;
    	      this.vantagePointCount = defaults.vantagePointCount;
    	      this.vantagePoints = defaults.vantagePoints;
        }

        @CustomType.Setter
        public Builder apmDomainId(String apmDomainId) {
            if (apmDomainId == null) {
              throw new MissingRequiredPropertyException("GetMonitorsMonitorCollectionItem", "apmDomainId");
            }
            this.apmDomainId = apmDomainId;
            return this;
        }
        @CustomType.Setter
        public Builder availabilityConfigurations(List<GetMonitorsMonitorCollectionItemAvailabilityConfiguration> availabilityConfigurations) {
            if (availabilityConfigurations == null) {
              throw new MissingRequiredPropertyException("GetMonitorsMonitorCollectionItem", "availabilityConfigurations");
            }
            this.availabilityConfigurations = availabilityConfigurations;
            return this;
        }
        public Builder availabilityConfigurations(GetMonitorsMonitorCollectionItemAvailabilityConfiguration... availabilityConfigurations) {
            return availabilityConfigurations(List.of(availabilityConfigurations));
        }
        @CustomType.Setter
        public Builder batchIntervalInSeconds(Integer batchIntervalInSeconds) {
            if (batchIntervalInSeconds == null) {
              throw new MissingRequiredPropertyException("GetMonitorsMonitorCollectionItem", "batchIntervalInSeconds");
            }
            this.batchIntervalInSeconds = batchIntervalInSeconds;
            return this;
        }
        @CustomType.Setter
        public Builder configurations(List<GetMonitorsMonitorCollectionItemConfiguration> configurations) {
            if (configurations == null) {
              throw new MissingRequiredPropertyException("GetMonitorsMonitorCollectionItem", "configurations");
            }
            this.configurations = configurations;
            return this;
        }
        public Builder configurations(GetMonitorsMonitorCollectionItemConfiguration... configurations) {
            return configurations(List.of(configurations));
        }
        @CustomType.Setter
        public Builder definedTags(Map<String,Object> definedTags) {
            if (definedTags == null) {
              throw new MissingRequiredPropertyException("GetMonitorsMonitorCollectionItem", "definedTags");
            }
            this.definedTags = definedTags;
            return this;
        }
        @CustomType.Setter
        public Builder displayName(String displayName) {
            if (displayName == null) {
              throw new MissingRequiredPropertyException("GetMonitorsMonitorCollectionItem", "displayName");
            }
            this.displayName = displayName;
            return this;
        }
        @CustomType.Setter
        public Builder freeformTags(Map<String,Object> freeformTags) {
            if (freeformTags == null) {
              throw new MissingRequiredPropertyException("GetMonitorsMonitorCollectionItem", "freeformTags");
            }
            this.freeformTags = freeformTags;
            return this;
        }
        @CustomType.Setter
        public Builder id(String id) {
            if (id == null) {
              throw new MissingRequiredPropertyException("GetMonitorsMonitorCollectionItem", "id");
            }
            this.id = id;
            return this;
        }
        @CustomType.Setter
        public Builder isRunNow(Boolean isRunNow) {
            if (isRunNow == null) {
              throw new MissingRequiredPropertyException("GetMonitorsMonitorCollectionItem", "isRunNow");
            }
            this.isRunNow = isRunNow;
            return this;
        }
        @CustomType.Setter
        public Builder isRunOnce(Boolean isRunOnce) {
            if (isRunOnce == null) {
              throw new MissingRequiredPropertyException("GetMonitorsMonitorCollectionItem", "isRunOnce");
            }
            this.isRunOnce = isRunOnce;
            return this;
        }
        @CustomType.Setter
        public Builder maintenanceWindowSchedules(List<GetMonitorsMonitorCollectionItemMaintenanceWindowSchedule> maintenanceWindowSchedules) {
            if (maintenanceWindowSchedules == null) {
              throw new MissingRequiredPropertyException("GetMonitorsMonitorCollectionItem", "maintenanceWindowSchedules");
            }
            this.maintenanceWindowSchedules = maintenanceWindowSchedules;
            return this;
        }
        public Builder maintenanceWindowSchedules(GetMonitorsMonitorCollectionItemMaintenanceWindowSchedule... maintenanceWindowSchedules) {
            return maintenanceWindowSchedules(List.of(maintenanceWindowSchedules));
        }
        @CustomType.Setter
        public Builder monitorType(String monitorType) {
            if (monitorType == null) {
              throw new MissingRequiredPropertyException("GetMonitorsMonitorCollectionItem", "monitorType");
            }
            this.monitorType = monitorType;
            return this;
        }
        @CustomType.Setter
        public Builder repeatIntervalInSeconds(Integer repeatIntervalInSeconds) {
            if (repeatIntervalInSeconds == null) {
              throw new MissingRequiredPropertyException("GetMonitorsMonitorCollectionItem", "repeatIntervalInSeconds");
            }
            this.repeatIntervalInSeconds = repeatIntervalInSeconds;
            return this;
        }
        @CustomType.Setter
        public Builder schedulingPolicy(String schedulingPolicy) {
            if (schedulingPolicy == null) {
              throw new MissingRequiredPropertyException("GetMonitorsMonitorCollectionItem", "schedulingPolicy");
            }
            this.schedulingPolicy = schedulingPolicy;
            return this;
        }
        @CustomType.Setter
        public Builder scriptId(String scriptId) {
            if (scriptId == null) {
              throw new MissingRequiredPropertyException("GetMonitorsMonitorCollectionItem", "scriptId");
            }
            this.scriptId = scriptId;
            return this;
        }
        @CustomType.Setter
        public Builder scriptName(String scriptName) {
            if (scriptName == null) {
              throw new MissingRequiredPropertyException("GetMonitorsMonitorCollectionItem", "scriptName");
            }
            this.scriptName = scriptName;
            return this;
        }
        @CustomType.Setter
        public Builder scriptParameters(List<GetMonitorsMonitorCollectionItemScriptParameter> scriptParameters) {
            if (scriptParameters == null) {
              throw new MissingRequiredPropertyException("GetMonitorsMonitorCollectionItem", "scriptParameters");
            }
            this.scriptParameters = scriptParameters;
            return this;
        }
        public Builder scriptParameters(GetMonitorsMonitorCollectionItemScriptParameter... scriptParameters) {
            return scriptParameters(List.of(scriptParameters));
        }
        @CustomType.Setter
        public Builder status(String status) {
            if (status == null) {
              throw new MissingRequiredPropertyException("GetMonitorsMonitorCollectionItem", "status");
            }
            this.status = status;
            return this;
        }
        @CustomType.Setter
        public Builder target(String target) {
            if (target == null) {
              throw new MissingRequiredPropertyException("GetMonitorsMonitorCollectionItem", "target");
            }
            this.target = target;
            return this;
        }
        @CustomType.Setter
        public Builder timeCreated(String timeCreated) {
            if (timeCreated == null) {
              throw new MissingRequiredPropertyException("GetMonitorsMonitorCollectionItem", "timeCreated");
            }
            this.timeCreated = timeCreated;
            return this;
        }
        @CustomType.Setter
        public Builder timeUpdated(String timeUpdated) {
            if (timeUpdated == null) {
              throw new MissingRequiredPropertyException("GetMonitorsMonitorCollectionItem", "timeUpdated");
            }
            this.timeUpdated = timeUpdated;
            return this;
        }
        @CustomType.Setter
        public Builder timeoutInSeconds(Integer timeoutInSeconds) {
            if (timeoutInSeconds == null) {
              throw new MissingRequiredPropertyException("GetMonitorsMonitorCollectionItem", "timeoutInSeconds");
            }
            this.timeoutInSeconds = timeoutInSeconds;
            return this;
        }
        @CustomType.Setter
        public Builder vantagePointCount(Integer vantagePointCount) {
            if (vantagePointCount == null) {
              throw new MissingRequiredPropertyException("GetMonitorsMonitorCollectionItem", "vantagePointCount");
            }
            this.vantagePointCount = vantagePointCount;
            return this;
        }
        @CustomType.Setter
        public Builder vantagePoints(List<GetMonitorsMonitorCollectionItemVantagePoint> vantagePoints) {
            if (vantagePoints == null) {
              throw new MissingRequiredPropertyException("GetMonitorsMonitorCollectionItem", "vantagePoints");
            }
            this.vantagePoints = vantagePoints;
            return this;
        }
        public Builder vantagePoints(GetMonitorsMonitorCollectionItemVantagePoint... vantagePoints) {
            return vantagePoints(List.of(vantagePoints));
        }
        public GetMonitorsMonitorCollectionItem build() {
            final var _resultValue = new GetMonitorsMonitorCollectionItem();
            _resultValue.apmDomainId = apmDomainId;
            _resultValue.availabilityConfigurations = availabilityConfigurations;
            _resultValue.batchIntervalInSeconds = batchIntervalInSeconds;
            _resultValue.configurations = configurations;
            _resultValue.definedTags = definedTags;
            _resultValue.displayName = displayName;
            _resultValue.freeformTags = freeformTags;
            _resultValue.id = id;
            _resultValue.isRunNow = isRunNow;
            _resultValue.isRunOnce = isRunOnce;
            _resultValue.maintenanceWindowSchedules = maintenanceWindowSchedules;
            _resultValue.monitorType = monitorType;
            _resultValue.repeatIntervalInSeconds = repeatIntervalInSeconds;
            _resultValue.schedulingPolicy = schedulingPolicy;
            _resultValue.scriptId = scriptId;
            _resultValue.scriptName = scriptName;
            _resultValue.scriptParameters = scriptParameters;
            _resultValue.status = status;
            _resultValue.target = target;
            _resultValue.timeCreated = timeCreated;
            _resultValue.timeUpdated = timeUpdated;
            _resultValue.timeoutInSeconds = timeoutInSeconds;
            _resultValue.vantagePointCount = vantagePointCount;
            _resultValue.vantagePoints = vantagePoints;
            return _resultValue;
        }
    }
}
