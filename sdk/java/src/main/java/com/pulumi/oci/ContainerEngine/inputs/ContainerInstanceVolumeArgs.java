// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.oci.ContainerEngine.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.oci.ContainerEngine.inputs.ContainerInstanceVolumeConfigArgs;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ContainerInstanceVolumeArgs extends com.pulumi.resources.ResourceArgs {

    public static final ContainerInstanceVolumeArgs Empty = new ContainerInstanceVolumeArgs();

    /**
     * The volume type of the empty directory, can be either File Storage or Memory.
     * 
     */
    @Import(name="backingStore")
    private @Nullable Output<String> backingStore;

    /**
     * @return The volume type of the empty directory, can be either File Storage or Memory.
     * 
     */
    public Optional<Output<String>> backingStore() {
        return Optional.ofNullable(this.backingStore);
    }

    /**
     * Contains key value pairs which can be mounted as individual files inside the container. The value needs to be base64 encoded. It is decoded to plain text before the mount.
     * 
     */
    @Import(name="configs")
    private @Nullable Output<List<ContainerInstanceVolumeConfigArgs>> configs;

    /**
     * @return Contains key value pairs which can be mounted as individual files inside the container. The value needs to be base64 encoded. It is decoded to plain text before the mount.
     * 
     */
    public Optional<Output<List<ContainerInstanceVolumeConfigArgs>>> configs() {
        return Optional.ofNullable(this.configs);
    }

    /**
     * The name of the volume. This must be unique within a single container instance.
     * 
     */
    @Import(name="name", required=true)
    private Output<String> name;

    /**
     * @return The name of the volume. This must be unique within a single container instance.
     * 
     */
    public Output<String> name() {
        return this.name;
    }

    /**
     * The type of volume.
     * 
     */
    @Import(name="volumeType", required=true)
    private Output<String> volumeType;

    /**
     * @return The type of volume.
     * 
     */
    public Output<String> volumeType() {
        return this.volumeType;
    }

    private ContainerInstanceVolumeArgs() {}

    private ContainerInstanceVolumeArgs(ContainerInstanceVolumeArgs $) {
        this.backingStore = $.backingStore;
        this.configs = $.configs;
        this.name = $.name;
        this.volumeType = $.volumeType;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ContainerInstanceVolumeArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ContainerInstanceVolumeArgs $;

        public Builder() {
            $ = new ContainerInstanceVolumeArgs();
        }

        public Builder(ContainerInstanceVolumeArgs defaults) {
            $ = new ContainerInstanceVolumeArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param backingStore The volume type of the empty directory, can be either File Storage or Memory.
         * 
         * @return builder
         * 
         */
        public Builder backingStore(@Nullable Output<String> backingStore) {
            $.backingStore = backingStore;
            return this;
        }

        /**
         * @param backingStore The volume type of the empty directory, can be either File Storage or Memory.
         * 
         * @return builder
         * 
         */
        public Builder backingStore(String backingStore) {
            return backingStore(Output.of(backingStore));
        }

        /**
         * @param configs Contains key value pairs which can be mounted as individual files inside the container. The value needs to be base64 encoded. It is decoded to plain text before the mount.
         * 
         * @return builder
         * 
         */
        public Builder configs(@Nullable Output<List<ContainerInstanceVolumeConfigArgs>> configs) {
            $.configs = configs;
            return this;
        }

        /**
         * @param configs Contains key value pairs which can be mounted as individual files inside the container. The value needs to be base64 encoded. It is decoded to plain text before the mount.
         * 
         * @return builder
         * 
         */
        public Builder configs(List<ContainerInstanceVolumeConfigArgs> configs) {
            return configs(Output.of(configs));
        }

        /**
         * @param configs Contains key value pairs which can be mounted as individual files inside the container. The value needs to be base64 encoded. It is decoded to plain text before the mount.
         * 
         * @return builder
         * 
         */
        public Builder configs(ContainerInstanceVolumeConfigArgs... configs) {
            return configs(List.of(configs));
        }

        /**
         * @param name The name of the volume. This must be unique within a single container instance.
         * 
         * @return builder
         * 
         */
        public Builder name(Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The name of the volume. This must be unique within a single container instance.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param volumeType The type of volume.
         * 
         * @return builder
         * 
         */
        public Builder volumeType(Output<String> volumeType) {
            $.volumeType = volumeType;
            return this;
        }

        /**
         * @param volumeType The type of volume.
         * 
         * @return builder
         * 
         */
        public Builder volumeType(String volumeType) {
            return volumeType(Output.of(volumeType));
        }

        public ContainerInstanceVolumeArgs build() {
            if ($.name == null) {
                throw new MissingRequiredPropertyException("ContainerInstanceVolumeArgs", "name");
            }
            if ($.volumeType == null) {
                throw new MissingRequiredPropertyException("ContainerInstanceVolumeArgs", "volumeType");
            }
            return $;
        }
    }

}
