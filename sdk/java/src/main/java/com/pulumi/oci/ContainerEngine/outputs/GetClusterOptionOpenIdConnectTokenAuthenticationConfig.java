// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.oci.ContainerEngine.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.oci.ContainerEngine.outputs.GetClusterOptionOpenIdConnectTokenAuthenticationConfigRequiredClaim;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Objects;

@CustomType
public final class GetClusterOptionOpenIdConnectTokenAuthenticationConfig {
    /**
     * @return A Base64 encoded public RSA or ECDSA certificates used to signed your identity provider&#39;s web certificate.
     * 
     */
    private String caCertificate;
    /**
     * @return A client id that all tokens must be issued for.
     * 
     */
    private String clientId;
    /**
     * @return A Base64 encoded string of a Kubernetes OIDC Auth Config file. More info [here](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#using-authentication-configuration)
     * 
     */
    private String configurationFile;
    /**
     * @return JWT claim to use as the user&#39;s group. If the claim is present it must be an array of strings.
     * 
     */
    private String groupsClaim;
    /**
     * @return Prefix prepended to group claims to prevent clashes with existing names (such as system:groups).
     * 
     */
    private String groupsPrefix;
    /**
     * @return Whether the cluster has OIDC Auth Config enabled. Defaults to false.
     * 
     */
    private Boolean isOpenIdConnectAuthEnabled;
    /**
     * @return URL of the provider that allows the API server to discover public signing keys.  Only URLs that use the https:// scheme are accepted. This is typically the provider&#39;s discovery URL,  changed to have an empty path.
     * 
     */
    private String issuerUrl;
    /**
     * @return A key=value pair that describes a required claim in the ID Token. If set, the claim is verified to be present  in the ID Token with a matching value. Repeat this flag to specify multiple claims.
     * 
     */
    private List<GetClusterOptionOpenIdConnectTokenAuthenticationConfigRequiredClaim> requiredClaims;
    /**
     * @return The signing algorithms accepted. Default is [&#34;RS256&#34;].
     * 
     */
    private List<String> signingAlgorithms;
    /**
     * @return JWT claim to use as the user name. By default sub, which is expected to be a unique identifier of the end  user. Admins can choose other claims, such as email or name, depending on their provider. However, claims  other than email will be prefixed with the issuer URL to prevent naming clashes with other plugins.
     * 
     */
    private String usernameClaim;
    /**
     * @return Prefix prepended to username claims to prevent clashes with existing names (such as system:users).  For example, the value oidc: will create usernames like oidc:jane.doe. If this flag isn&#39;t provided and  --oidc-username-claim is a value other than email the prefix defaults to ( Issuer URL )# where  ( Issuer URL ) is the value of --oidc-issuer-url. The value - can be used to disable all prefixing.
     * 
     */
    private String usernamePrefix;

    private GetClusterOptionOpenIdConnectTokenAuthenticationConfig() {}
    /**
     * @return A Base64 encoded public RSA or ECDSA certificates used to signed your identity provider&#39;s web certificate.
     * 
     */
    public String caCertificate() {
        return this.caCertificate;
    }
    /**
     * @return A client id that all tokens must be issued for.
     * 
     */
    public String clientId() {
        return this.clientId;
    }
    /**
     * @return A Base64 encoded string of a Kubernetes OIDC Auth Config file. More info [here](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#using-authentication-configuration)
     * 
     */
    public String configurationFile() {
        return this.configurationFile;
    }
    /**
     * @return JWT claim to use as the user&#39;s group. If the claim is present it must be an array of strings.
     * 
     */
    public String groupsClaim() {
        return this.groupsClaim;
    }
    /**
     * @return Prefix prepended to group claims to prevent clashes with existing names (such as system:groups).
     * 
     */
    public String groupsPrefix() {
        return this.groupsPrefix;
    }
    /**
     * @return Whether the cluster has OIDC Auth Config enabled. Defaults to false.
     * 
     */
    public Boolean isOpenIdConnectAuthEnabled() {
        return this.isOpenIdConnectAuthEnabled;
    }
    /**
     * @return URL of the provider that allows the API server to discover public signing keys.  Only URLs that use the https:// scheme are accepted. This is typically the provider&#39;s discovery URL,  changed to have an empty path.
     * 
     */
    public String issuerUrl() {
        return this.issuerUrl;
    }
    /**
     * @return A key=value pair that describes a required claim in the ID Token. If set, the claim is verified to be present  in the ID Token with a matching value. Repeat this flag to specify multiple claims.
     * 
     */
    public List<GetClusterOptionOpenIdConnectTokenAuthenticationConfigRequiredClaim> requiredClaims() {
        return this.requiredClaims;
    }
    /**
     * @return The signing algorithms accepted. Default is [&#34;RS256&#34;].
     * 
     */
    public List<String> signingAlgorithms() {
        return this.signingAlgorithms;
    }
    /**
     * @return JWT claim to use as the user name. By default sub, which is expected to be a unique identifier of the end  user. Admins can choose other claims, such as email or name, depending on their provider. However, claims  other than email will be prefixed with the issuer URL to prevent naming clashes with other plugins.
     * 
     */
    public String usernameClaim() {
        return this.usernameClaim;
    }
    /**
     * @return Prefix prepended to username claims to prevent clashes with existing names (such as system:users).  For example, the value oidc: will create usernames like oidc:jane.doe. If this flag isn&#39;t provided and  --oidc-username-claim is a value other than email the prefix defaults to ( Issuer URL )# where  ( Issuer URL ) is the value of --oidc-issuer-url. The value - can be used to disable all prefixing.
     * 
     */
    public String usernamePrefix() {
        return this.usernamePrefix;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetClusterOptionOpenIdConnectTokenAuthenticationConfig defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String caCertificate;
        private String clientId;
        private String configurationFile;
        private String groupsClaim;
        private String groupsPrefix;
        private Boolean isOpenIdConnectAuthEnabled;
        private String issuerUrl;
        private List<GetClusterOptionOpenIdConnectTokenAuthenticationConfigRequiredClaim> requiredClaims;
        private List<String> signingAlgorithms;
        private String usernameClaim;
        private String usernamePrefix;
        public Builder() {}
        public Builder(GetClusterOptionOpenIdConnectTokenAuthenticationConfig defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.caCertificate = defaults.caCertificate;
    	      this.clientId = defaults.clientId;
    	      this.configurationFile = defaults.configurationFile;
    	      this.groupsClaim = defaults.groupsClaim;
    	      this.groupsPrefix = defaults.groupsPrefix;
    	      this.isOpenIdConnectAuthEnabled = defaults.isOpenIdConnectAuthEnabled;
    	      this.issuerUrl = defaults.issuerUrl;
    	      this.requiredClaims = defaults.requiredClaims;
    	      this.signingAlgorithms = defaults.signingAlgorithms;
    	      this.usernameClaim = defaults.usernameClaim;
    	      this.usernamePrefix = defaults.usernamePrefix;
        }

        @CustomType.Setter
        public Builder caCertificate(String caCertificate) {
            if (caCertificate == null) {
              throw new MissingRequiredPropertyException("GetClusterOptionOpenIdConnectTokenAuthenticationConfig", "caCertificate");
            }
            this.caCertificate = caCertificate;
            return this;
        }
        @CustomType.Setter
        public Builder clientId(String clientId) {
            if (clientId == null) {
              throw new MissingRequiredPropertyException("GetClusterOptionOpenIdConnectTokenAuthenticationConfig", "clientId");
            }
            this.clientId = clientId;
            return this;
        }
        @CustomType.Setter
        public Builder configurationFile(String configurationFile) {
            if (configurationFile == null) {
              throw new MissingRequiredPropertyException("GetClusterOptionOpenIdConnectTokenAuthenticationConfig", "configurationFile");
            }
            this.configurationFile = configurationFile;
            return this;
        }
        @CustomType.Setter
        public Builder groupsClaim(String groupsClaim) {
            if (groupsClaim == null) {
              throw new MissingRequiredPropertyException("GetClusterOptionOpenIdConnectTokenAuthenticationConfig", "groupsClaim");
            }
            this.groupsClaim = groupsClaim;
            return this;
        }
        @CustomType.Setter
        public Builder groupsPrefix(String groupsPrefix) {
            if (groupsPrefix == null) {
              throw new MissingRequiredPropertyException("GetClusterOptionOpenIdConnectTokenAuthenticationConfig", "groupsPrefix");
            }
            this.groupsPrefix = groupsPrefix;
            return this;
        }
        @CustomType.Setter
        public Builder isOpenIdConnectAuthEnabled(Boolean isOpenIdConnectAuthEnabled) {
            if (isOpenIdConnectAuthEnabled == null) {
              throw new MissingRequiredPropertyException("GetClusterOptionOpenIdConnectTokenAuthenticationConfig", "isOpenIdConnectAuthEnabled");
            }
            this.isOpenIdConnectAuthEnabled = isOpenIdConnectAuthEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder issuerUrl(String issuerUrl) {
            if (issuerUrl == null) {
              throw new MissingRequiredPropertyException("GetClusterOptionOpenIdConnectTokenAuthenticationConfig", "issuerUrl");
            }
            this.issuerUrl = issuerUrl;
            return this;
        }
        @CustomType.Setter
        public Builder requiredClaims(List<GetClusterOptionOpenIdConnectTokenAuthenticationConfigRequiredClaim> requiredClaims) {
            if (requiredClaims == null) {
              throw new MissingRequiredPropertyException("GetClusterOptionOpenIdConnectTokenAuthenticationConfig", "requiredClaims");
            }
            this.requiredClaims = requiredClaims;
            return this;
        }
        public Builder requiredClaims(GetClusterOptionOpenIdConnectTokenAuthenticationConfigRequiredClaim... requiredClaims) {
            return requiredClaims(List.of(requiredClaims));
        }
        @CustomType.Setter
        public Builder signingAlgorithms(List<String> signingAlgorithms) {
            if (signingAlgorithms == null) {
              throw new MissingRequiredPropertyException("GetClusterOptionOpenIdConnectTokenAuthenticationConfig", "signingAlgorithms");
            }
            this.signingAlgorithms = signingAlgorithms;
            return this;
        }
        public Builder signingAlgorithms(String... signingAlgorithms) {
            return signingAlgorithms(List.of(signingAlgorithms));
        }
        @CustomType.Setter
        public Builder usernameClaim(String usernameClaim) {
            if (usernameClaim == null) {
              throw new MissingRequiredPropertyException("GetClusterOptionOpenIdConnectTokenAuthenticationConfig", "usernameClaim");
            }
            this.usernameClaim = usernameClaim;
            return this;
        }
        @CustomType.Setter
        public Builder usernamePrefix(String usernamePrefix) {
            if (usernamePrefix == null) {
              throw new MissingRequiredPropertyException("GetClusterOptionOpenIdConnectTokenAuthenticationConfig", "usernamePrefix");
            }
            this.usernamePrefix = usernamePrefix;
            return this;
        }
        public GetClusterOptionOpenIdConnectTokenAuthenticationConfig build() {
            final var _resultValue = new GetClusterOptionOpenIdConnectTokenAuthenticationConfig();
            _resultValue.caCertificate = caCertificate;
            _resultValue.clientId = clientId;
            _resultValue.configurationFile = configurationFile;
            _resultValue.groupsClaim = groupsClaim;
            _resultValue.groupsPrefix = groupsPrefix;
            _resultValue.isOpenIdConnectAuthEnabled = isOpenIdConnectAuthEnabled;
            _resultValue.issuerUrl = issuerUrl;
            _resultValue.requiredClaims = requiredClaims;
            _resultValue.signingAlgorithms = signingAlgorithms;
            _resultValue.usernameClaim = usernameClaim;
            _resultValue.usernamePrefix = usernamePrefix;
            return _resultValue;
        }
    }
}
