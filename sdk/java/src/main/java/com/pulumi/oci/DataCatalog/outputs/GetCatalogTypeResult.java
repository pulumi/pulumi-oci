// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.oci.DataCatalog.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import javax.annotation.Nullable;

@CustomType
public final class GetCatalogTypeResult {
    /**
     * @return The data catalog&#39;s OCID.
     * 
     */
    private String catalogId;
    /**
     * @return Detailed description of the type.
     * 
     */
    private String description;
    /**
     * @return Mapping type equivalence in the external system.
     * 
     */
    private String externalTypeName;
    private @Nullable List<String> fields;
    /**
     * @return The provider-assigned unique ID for this managed resource.
     * 
     */
    private String id;
    /**
     * @return Indicates whether the type is approved for use as a classifying object.
     * 
     */
    private Boolean isApproved;
    /**
     * @return Indicates whether the type is internal, making it unavailable for use by metadata elements.
     * 
     */
    private Boolean isInternal;
    /**
     * @return Indicates whether the type can be used for tagging metadata elements.
     * 
     */
    private Boolean isTag;
    /**
     * @return Unique type key that is immutable.
     * 
     */
    private String key;
    /**
     * @return The immutable name of the type.
     * 
     */
    private String name;
    /**
     * @return A map of arrays which defines the type specific properties, both required and optional. The map keys are category names and the values are arrays contiaing all property details. Every property is contained inside of a category. Most types have required properties within the &#34;default&#34; category. Example: `{ &#34;properties&#34;: { &#34;default&#34;: { &#34;attributes:&#34;: [ { &#34;name&#34;: &#34;host&#34;, &#34;type&#34;: &#34;string&#34;, &#34;isRequired&#34;: true, &#34;isUpdatable&#34;: false }, ... ] } } }`
     * 
     */
    private Map<String,String> properties;
    /**
     * @return The current state of the type.
     * 
     */
    private String state;
    /**
     * @return Indicates the category this type belongs to. For instance, data assets, connections.
     * 
     */
    private String typeCategory;
    private String typeKey;
    /**
     * @return URI to the type instance in the API.
     * 
     */
    private String uri;

    private GetCatalogTypeResult() {}
    /**
     * @return The data catalog&#39;s OCID.
     * 
     */
    public String catalogId() {
        return this.catalogId;
    }
    /**
     * @return Detailed description of the type.
     * 
     */
    public String description() {
        return this.description;
    }
    /**
     * @return Mapping type equivalence in the external system.
     * 
     */
    public String externalTypeName() {
        return this.externalTypeName;
    }
    public List<String> fields() {
        return this.fields == null ? List.of() : this.fields;
    }
    /**
     * @return The provider-assigned unique ID for this managed resource.
     * 
     */
    public String id() {
        return this.id;
    }
    /**
     * @return Indicates whether the type is approved for use as a classifying object.
     * 
     */
    public Boolean isApproved() {
        return this.isApproved;
    }
    /**
     * @return Indicates whether the type is internal, making it unavailable for use by metadata elements.
     * 
     */
    public Boolean isInternal() {
        return this.isInternal;
    }
    /**
     * @return Indicates whether the type can be used for tagging metadata elements.
     * 
     */
    public Boolean isTag() {
        return this.isTag;
    }
    /**
     * @return Unique type key that is immutable.
     * 
     */
    public String key() {
        return this.key;
    }
    /**
     * @return The immutable name of the type.
     * 
     */
    public String name() {
        return this.name;
    }
    /**
     * @return A map of arrays which defines the type specific properties, both required and optional. The map keys are category names and the values are arrays contiaing all property details. Every property is contained inside of a category. Most types have required properties within the &#34;default&#34; category. Example: `{ &#34;properties&#34;: { &#34;default&#34;: { &#34;attributes:&#34;: [ { &#34;name&#34;: &#34;host&#34;, &#34;type&#34;: &#34;string&#34;, &#34;isRequired&#34;: true, &#34;isUpdatable&#34;: false }, ... ] } } }`
     * 
     */
    public Map<String,String> properties() {
        return this.properties;
    }
    /**
     * @return The current state of the type.
     * 
     */
    public String state() {
        return this.state;
    }
    /**
     * @return Indicates the category this type belongs to. For instance, data assets, connections.
     * 
     */
    public String typeCategory() {
        return this.typeCategory;
    }
    public String typeKey() {
        return this.typeKey;
    }
    /**
     * @return URI to the type instance in the API.
     * 
     */
    public String uri() {
        return this.uri;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetCatalogTypeResult defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String catalogId;
        private String description;
        private String externalTypeName;
        private @Nullable List<String> fields;
        private String id;
        private Boolean isApproved;
        private Boolean isInternal;
        private Boolean isTag;
        private String key;
        private String name;
        private Map<String,String> properties;
        private String state;
        private String typeCategory;
        private String typeKey;
        private String uri;
        public Builder() {}
        public Builder(GetCatalogTypeResult defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.catalogId = defaults.catalogId;
    	      this.description = defaults.description;
    	      this.externalTypeName = defaults.externalTypeName;
    	      this.fields = defaults.fields;
    	      this.id = defaults.id;
    	      this.isApproved = defaults.isApproved;
    	      this.isInternal = defaults.isInternal;
    	      this.isTag = defaults.isTag;
    	      this.key = defaults.key;
    	      this.name = defaults.name;
    	      this.properties = defaults.properties;
    	      this.state = defaults.state;
    	      this.typeCategory = defaults.typeCategory;
    	      this.typeKey = defaults.typeKey;
    	      this.uri = defaults.uri;
        }

        @CustomType.Setter
        public Builder catalogId(String catalogId) {
            if (catalogId == null) {
              throw new MissingRequiredPropertyException("GetCatalogTypeResult", "catalogId");
            }
            this.catalogId = catalogId;
            return this;
        }
        @CustomType.Setter
        public Builder description(String description) {
            if (description == null) {
              throw new MissingRequiredPropertyException("GetCatalogTypeResult", "description");
            }
            this.description = description;
            return this;
        }
        @CustomType.Setter
        public Builder externalTypeName(String externalTypeName) {
            if (externalTypeName == null) {
              throw new MissingRequiredPropertyException("GetCatalogTypeResult", "externalTypeName");
            }
            this.externalTypeName = externalTypeName;
            return this;
        }
        @CustomType.Setter
        public Builder fields(@Nullable List<String> fields) {

            this.fields = fields;
            return this;
        }
        public Builder fields(String... fields) {
            return fields(List.of(fields));
        }
        @CustomType.Setter
        public Builder id(String id) {
            if (id == null) {
              throw new MissingRequiredPropertyException("GetCatalogTypeResult", "id");
            }
            this.id = id;
            return this;
        }
        @CustomType.Setter
        public Builder isApproved(Boolean isApproved) {
            if (isApproved == null) {
              throw new MissingRequiredPropertyException("GetCatalogTypeResult", "isApproved");
            }
            this.isApproved = isApproved;
            return this;
        }
        @CustomType.Setter
        public Builder isInternal(Boolean isInternal) {
            if (isInternal == null) {
              throw new MissingRequiredPropertyException("GetCatalogTypeResult", "isInternal");
            }
            this.isInternal = isInternal;
            return this;
        }
        @CustomType.Setter
        public Builder isTag(Boolean isTag) {
            if (isTag == null) {
              throw new MissingRequiredPropertyException("GetCatalogTypeResult", "isTag");
            }
            this.isTag = isTag;
            return this;
        }
        @CustomType.Setter
        public Builder key(String key) {
            if (key == null) {
              throw new MissingRequiredPropertyException("GetCatalogTypeResult", "key");
            }
            this.key = key;
            return this;
        }
        @CustomType.Setter
        public Builder name(String name) {
            if (name == null) {
              throw new MissingRequiredPropertyException("GetCatalogTypeResult", "name");
            }
            this.name = name;
            return this;
        }
        @CustomType.Setter
        public Builder properties(Map<String,String> properties) {
            if (properties == null) {
              throw new MissingRequiredPropertyException("GetCatalogTypeResult", "properties");
            }
            this.properties = properties;
            return this;
        }
        @CustomType.Setter
        public Builder state(String state) {
            if (state == null) {
              throw new MissingRequiredPropertyException("GetCatalogTypeResult", "state");
            }
            this.state = state;
            return this;
        }
        @CustomType.Setter
        public Builder typeCategory(String typeCategory) {
            if (typeCategory == null) {
              throw new MissingRequiredPropertyException("GetCatalogTypeResult", "typeCategory");
            }
            this.typeCategory = typeCategory;
            return this;
        }
        @CustomType.Setter
        public Builder typeKey(String typeKey) {
            if (typeKey == null) {
              throw new MissingRequiredPropertyException("GetCatalogTypeResult", "typeKey");
            }
            this.typeKey = typeKey;
            return this;
        }
        @CustomType.Setter
        public Builder uri(String uri) {
            if (uri == null) {
              throw new MissingRequiredPropertyException("GetCatalogTypeResult", "uri");
            }
            this.uri = uri;
            return this;
        }
        public GetCatalogTypeResult build() {
            final var _resultValue = new GetCatalogTypeResult();
            _resultValue.catalogId = catalogId;
            _resultValue.description = description;
            _resultValue.externalTypeName = externalTypeName;
            _resultValue.fields = fields;
            _resultValue.id = id;
            _resultValue.isApproved = isApproved;
            _resultValue.isInternal = isInternal;
            _resultValue.isTag = isTag;
            _resultValue.key = key;
            _resultValue.name = name;
            _resultValue.properties = properties;
            _resultValue.state = state;
            _resultValue.typeCategory = typeCategory;
            _resultValue.typeKey = typeKey;
            _resultValue.uri = uri;
            return _resultValue;
        }
    }
}
