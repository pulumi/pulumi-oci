// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.oci.DataSafe.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.oci.DataSafe.inputs.CalculateAuditVolumeAvailableAvailableAuditVolumeArgs;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class CalculateAuditVolumeAvailableState extends com.pulumi.resources.ResourceArgs {

    public static final CalculateAuditVolumeAvailableState Empty = new CalculateAuditVolumeAvailableState();

    /**
     * The date from which the audit trail must start collecting data in UTC, in the format defined by RFC3339. If not specified, this will default to the date based on the retention period.
     * 
     */
    @Import(name="auditCollectionStartTime")
    private @Nullable Output<String> auditCollectionStartTime;

    /**
     * @return The date from which the audit trail must start collecting data in UTC, in the format defined by RFC3339. If not specified, this will default to the date based on the retention period.
     * 
     */
    public Optional<Output<String>> auditCollectionStartTime() {
        return Optional.ofNullable(this.auditCollectionStartTime);
    }

    /**
     * The OCID of the audit.
     * 
     */
    @Import(name="auditProfileId")
    private @Nullable Output<String> auditProfileId;

    /**
     * @return The OCID of the audit.
     * 
     */
    public Optional<Output<String>> auditProfileId() {
        return Optional.ofNullable(this.auditProfileId);
    }

    /**
     * List of available audit volumes.
     * 
     */
    @Import(name="availableAuditVolumes")
    private @Nullable Output<List<CalculateAuditVolumeAvailableAvailableAuditVolumeArgs>> availableAuditVolumes;

    /**
     * @return List of available audit volumes.
     * 
     */
    public Optional<Output<List<CalculateAuditVolumeAvailableAvailableAuditVolumeArgs>>> availableAuditVolumes() {
        return Optional.ofNullable(this.availableAuditVolumes);
    }

    /**
     * Unique name of the database associated to the peer target database.
     * 
     */
    @Import(name="databaseUniqueName")
    private @Nullable Output<String> databaseUniqueName;

    /**
     * @return Unique name of the database associated to the peer target database.
     * 
     */
    public Optional<Output<String>> databaseUniqueName() {
        return Optional.ofNullable(this.databaseUniqueName);
    }

    /**
     * The trail locations for which the audit data volume has to be calculated.
     * 
     * ** IMPORTANT **
     * Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
     * 
     */
    @Import(name="trailLocations")
    private @Nullable Output<List<String>> trailLocations;

    /**
     * @return The trail locations for which the audit data volume has to be calculated.
     * 
     * ** IMPORTANT **
     * Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
     * 
     */
    public Optional<Output<List<String>>> trailLocations() {
        return Optional.ofNullable(this.trailLocations);
    }

    private CalculateAuditVolumeAvailableState() {}

    private CalculateAuditVolumeAvailableState(CalculateAuditVolumeAvailableState $) {
        this.auditCollectionStartTime = $.auditCollectionStartTime;
        this.auditProfileId = $.auditProfileId;
        this.availableAuditVolumes = $.availableAuditVolumes;
        this.databaseUniqueName = $.databaseUniqueName;
        this.trailLocations = $.trailLocations;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(CalculateAuditVolumeAvailableState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private CalculateAuditVolumeAvailableState $;

        public Builder() {
            $ = new CalculateAuditVolumeAvailableState();
        }

        public Builder(CalculateAuditVolumeAvailableState defaults) {
            $ = new CalculateAuditVolumeAvailableState(Objects.requireNonNull(defaults));
        }

        /**
         * @param auditCollectionStartTime The date from which the audit trail must start collecting data in UTC, in the format defined by RFC3339. If not specified, this will default to the date based on the retention period.
         * 
         * @return builder
         * 
         */
        public Builder auditCollectionStartTime(@Nullable Output<String> auditCollectionStartTime) {
            $.auditCollectionStartTime = auditCollectionStartTime;
            return this;
        }

        /**
         * @param auditCollectionStartTime The date from which the audit trail must start collecting data in UTC, in the format defined by RFC3339. If not specified, this will default to the date based on the retention period.
         * 
         * @return builder
         * 
         */
        public Builder auditCollectionStartTime(String auditCollectionStartTime) {
            return auditCollectionStartTime(Output.of(auditCollectionStartTime));
        }

        /**
         * @param auditProfileId The OCID of the audit.
         * 
         * @return builder
         * 
         */
        public Builder auditProfileId(@Nullable Output<String> auditProfileId) {
            $.auditProfileId = auditProfileId;
            return this;
        }

        /**
         * @param auditProfileId The OCID of the audit.
         * 
         * @return builder
         * 
         */
        public Builder auditProfileId(String auditProfileId) {
            return auditProfileId(Output.of(auditProfileId));
        }

        /**
         * @param availableAuditVolumes List of available audit volumes.
         * 
         * @return builder
         * 
         */
        public Builder availableAuditVolumes(@Nullable Output<List<CalculateAuditVolumeAvailableAvailableAuditVolumeArgs>> availableAuditVolumes) {
            $.availableAuditVolumes = availableAuditVolumes;
            return this;
        }

        /**
         * @param availableAuditVolumes List of available audit volumes.
         * 
         * @return builder
         * 
         */
        public Builder availableAuditVolumes(List<CalculateAuditVolumeAvailableAvailableAuditVolumeArgs> availableAuditVolumes) {
            return availableAuditVolumes(Output.of(availableAuditVolumes));
        }

        /**
         * @param availableAuditVolumes List of available audit volumes.
         * 
         * @return builder
         * 
         */
        public Builder availableAuditVolumes(CalculateAuditVolumeAvailableAvailableAuditVolumeArgs... availableAuditVolumes) {
            return availableAuditVolumes(List.of(availableAuditVolumes));
        }

        /**
         * @param databaseUniqueName Unique name of the database associated to the peer target database.
         * 
         * @return builder
         * 
         */
        public Builder databaseUniqueName(@Nullable Output<String> databaseUniqueName) {
            $.databaseUniqueName = databaseUniqueName;
            return this;
        }

        /**
         * @param databaseUniqueName Unique name of the database associated to the peer target database.
         * 
         * @return builder
         * 
         */
        public Builder databaseUniqueName(String databaseUniqueName) {
            return databaseUniqueName(Output.of(databaseUniqueName));
        }

        /**
         * @param trailLocations The trail locations for which the audit data volume has to be calculated.
         * 
         * ** IMPORTANT **
         * Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
         * 
         * @return builder
         * 
         */
        public Builder trailLocations(@Nullable Output<List<String>> trailLocations) {
            $.trailLocations = trailLocations;
            return this;
        }

        /**
         * @param trailLocations The trail locations for which the audit data volume has to be calculated.
         * 
         * ** IMPORTANT **
         * Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
         * 
         * @return builder
         * 
         */
        public Builder trailLocations(List<String> trailLocations) {
            return trailLocations(Output.of(trailLocations));
        }

        /**
         * @param trailLocations The trail locations for which the audit data volume has to be calculated.
         * 
         * ** IMPORTANT **
         * Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
         * 
         * @return builder
         * 
         */
        public Builder trailLocations(String... trailLocations) {
            return trailLocations(List.of(trailLocations));
        }

        public CalculateAuditVolumeAvailableState build() {
            return $;
        }
    }

}
