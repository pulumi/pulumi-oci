// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.oci.DataSafe.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Double;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;

@CustomType
public final class GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntry {
    /**
     * @return The name of the substitution column.
     * 
     */
    private String columnName;
    /**
     * @return The description of the format entry.
     * 
     */
    private String description;
    /**
     * @return The upper bound of the range within which all the original column values fall. The end date must be greater than or equal to the start date.
     * 
     */
    private String endDate;
    /**
     * @return The maximum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be greater than or equal to  the start length.
     * 
     */
    private Integer endLength;
    /**
     * @return The upper bound of the range within which random decimal numbers should be generated. It must be greater than or equal to the start value. It supports  input of double type.
     * 
     */
    private Double endValue;
    /**
     * @return The constant number to be used for masking.
     * 
     */
    private Double fixedNumber;
    /**
     * @return The constant string to be used for masking.
     * 
     */
    private String fixedString;
    /**
     * @return One or more reference columns to be used to group column values so that they can be shuffled within their own group. The grouping columns and  the column to be masked must belong to the same table.
     * 
     */
    private List<String> groupingColumns;
    /**
     * @return The number of characters that should be there in the substring. It should be an integer and greater than zero.
     * 
     */
    private Integer length;
    /**
     * @return The OCID of the library masking format.
     * 
     */
    private String libraryMaskingFormatId;
    /**
     * @return The pattern that should be used to mask data.
     * 
     */
    private String pattern;
    /**
     * @return The post processing function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format. It can be a standalone or packaged function, so PACKAGE_NAME is optional.
     * 
     */
    private String postProcessingFunction;
    /**
     * @return A comma-separated list of values to be used to replace column values. The list can be of strings, numbers, or dates. The data type of each value in the list must be compatible with the data type of the column. The number of entries in the list cannot be more than 999.
     * 
     */
    private List<String> randomLists;
    /**
     * @return The regular expression to be used for masking. For data with characters in the ASCII character set, providing a regular expression is optional. However, it  is required if the data contains multi-byte characters. If not provided, an  error is returned when a multi-byte character is found.
     * 
     */
    private String regularExpression;
    /**
     * @return The value that should be used to replace the data matching the regular  expression. It can be a fixed string, fixed number, null value, or  SQL expression.
     * 
     */
    private String replaceWith;
    /**
     * @return The name of the schema that contains the database column.
     * 
     */
    private String schemaName;
    /**
     * @return The SQL expression to be used to generate the masked values. It can  consist of one or more values, operators, and SQL functions that  evaluate to a value. It can also contain substitution columns from  the same table. Specify the substitution columns within percent (%)  symbols.
     * 
     */
    private String sqlExpression;
    /**
     * @return The lower bound of the range within which all the original column values fall. The start date must be less than or equal to the end date.
     * 
     */
    private String startDate;
    /**
     * @return The minimum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be less than or equal to the  end length.
     * 
     */
    private Integer startLength;
    /**
     * @return The starting position in the original string from where the substring should be extracted. It can be either a positive or a negative integer. If It&#39;s negative, the counting starts from the end of the string.
     * 
     */
    private Integer startPosition;
    /**
     * @return The lower bound of the range within which random decimal numbers should  be generated. It must be less than or equal to the end value. It supports  input of double type.
     * 
     */
    private Double startValue;
    /**
     * @return The name of the table that contains the substitution column.
     * 
     */
    private String tableName;
    /**
     * @return The type of the format entry.
     * 
     */
    private String type;
    /**
     * @return The user-defined function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format.  It can be a standalone or packaged function, so PACKAGE_NAME is optional.
     * 
     */
    private String userDefinedFunction;

    private GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntry() {}
    /**
     * @return The name of the substitution column.
     * 
     */
    public String columnName() {
        return this.columnName;
    }
    /**
     * @return The description of the format entry.
     * 
     */
    public String description() {
        return this.description;
    }
    /**
     * @return The upper bound of the range within which all the original column values fall. The end date must be greater than or equal to the start date.
     * 
     */
    public String endDate() {
        return this.endDate;
    }
    /**
     * @return The maximum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be greater than or equal to  the start length.
     * 
     */
    public Integer endLength() {
        return this.endLength;
    }
    /**
     * @return The upper bound of the range within which random decimal numbers should be generated. It must be greater than or equal to the start value. It supports  input of double type.
     * 
     */
    public Double endValue() {
        return this.endValue;
    }
    /**
     * @return The constant number to be used for masking.
     * 
     */
    public Double fixedNumber() {
        return this.fixedNumber;
    }
    /**
     * @return The constant string to be used for masking.
     * 
     */
    public String fixedString() {
        return this.fixedString;
    }
    /**
     * @return One or more reference columns to be used to group column values so that they can be shuffled within their own group. The grouping columns and  the column to be masked must belong to the same table.
     * 
     */
    public List<String> groupingColumns() {
        return this.groupingColumns;
    }
    /**
     * @return The number of characters that should be there in the substring. It should be an integer and greater than zero.
     * 
     */
    public Integer length() {
        return this.length;
    }
    /**
     * @return The OCID of the library masking format.
     * 
     */
    public String libraryMaskingFormatId() {
        return this.libraryMaskingFormatId;
    }
    /**
     * @return The pattern that should be used to mask data.
     * 
     */
    public String pattern() {
        return this.pattern;
    }
    /**
     * @return The post processing function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format. It can be a standalone or packaged function, so PACKAGE_NAME is optional.
     * 
     */
    public String postProcessingFunction() {
        return this.postProcessingFunction;
    }
    /**
     * @return A comma-separated list of values to be used to replace column values. The list can be of strings, numbers, or dates. The data type of each value in the list must be compatible with the data type of the column. The number of entries in the list cannot be more than 999.
     * 
     */
    public List<String> randomLists() {
        return this.randomLists;
    }
    /**
     * @return The regular expression to be used for masking. For data with characters in the ASCII character set, providing a regular expression is optional. However, it  is required if the data contains multi-byte characters. If not provided, an  error is returned when a multi-byte character is found.
     * 
     */
    public String regularExpression() {
        return this.regularExpression;
    }
    /**
     * @return The value that should be used to replace the data matching the regular  expression. It can be a fixed string, fixed number, null value, or  SQL expression.
     * 
     */
    public String replaceWith() {
        return this.replaceWith;
    }
    /**
     * @return The name of the schema that contains the database column.
     * 
     */
    public String schemaName() {
        return this.schemaName;
    }
    /**
     * @return The SQL expression to be used to generate the masked values. It can  consist of one or more values, operators, and SQL functions that  evaluate to a value. It can also contain substitution columns from  the same table. Specify the substitution columns within percent (%)  symbols.
     * 
     */
    public String sqlExpression() {
        return this.sqlExpression;
    }
    /**
     * @return The lower bound of the range within which all the original column values fall. The start date must be less than or equal to the end date.
     * 
     */
    public String startDate() {
        return this.startDate;
    }
    /**
     * @return The minimum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be less than or equal to the  end length.
     * 
     */
    public Integer startLength() {
        return this.startLength;
    }
    /**
     * @return The starting position in the original string from where the substring should be extracted. It can be either a positive or a negative integer. If It&#39;s negative, the counting starts from the end of the string.
     * 
     */
    public Integer startPosition() {
        return this.startPosition;
    }
    /**
     * @return The lower bound of the range within which random decimal numbers should  be generated. It must be less than or equal to the end value. It supports  input of double type.
     * 
     */
    public Double startValue() {
        return this.startValue;
    }
    /**
     * @return The name of the table that contains the substitution column.
     * 
     */
    public String tableName() {
        return this.tableName;
    }
    /**
     * @return The type of the format entry.
     * 
     */
    public String type() {
        return this.type;
    }
    /**
     * @return The user-defined function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format.  It can be a standalone or packaged function, so PACKAGE_NAME is optional.
     * 
     */
    public String userDefinedFunction() {
        return this.userDefinedFunction;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntry defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String columnName;
        private String description;
        private String endDate;
        private Integer endLength;
        private Double endValue;
        private Double fixedNumber;
        private String fixedString;
        private List<String> groupingColumns;
        private Integer length;
        private String libraryMaskingFormatId;
        private String pattern;
        private String postProcessingFunction;
        private List<String> randomLists;
        private String regularExpression;
        private String replaceWith;
        private String schemaName;
        private String sqlExpression;
        private String startDate;
        private Integer startLength;
        private Integer startPosition;
        private Double startValue;
        private String tableName;
        private String type;
        private String userDefinedFunction;
        public Builder() {}
        public Builder(GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntry defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.columnName = defaults.columnName;
    	      this.description = defaults.description;
    	      this.endDate = defaults.endDate;
    	      this.endLength = defaults.endLength;
    	      this.endValue = defaults.endValue;
    	      this.fixedNumber = defaults.fixedNumber;
    	      this.fixedString = defaults.fixedString;
    	      this.groupingColumns = defaults.groupingColumns;
    	      this.length = defaults.length;
    	      this.libraryMaskingFormatId = defaults.libraryMaskingFormatId;
    	      this.pattern = defaults.pattern;
    	      this.postProcessingFunction = defaults.postProcessingFunction;
    	      this.randomLists = defaults.randomLists;
    	      this.regularExpression = defaults.regularExpression;
    	      this.replaceWith = defaults.replaceWith;
    	      this.schemaName = defaults.schemaName;
    	      this.sqlExpression = defaults.sqlExpression;
    	      this.startDate = defaults.startDate;
    	      this.startLength = defaults.startLength;
    	      this.startPosition = defaults.startPosition;
    	      this.startValue = defaults.startValue;
    	      this.tableName = defaults.tableName;
    	      this.type = defaults.type;
    	      this.userDefinedFunction = defaults.userDefinedFunction;
        }

        @CustomType.Setter
        public Builder columnName(String columnName) {
            if (columnName == null) {
              throw new MissingRequiredPropertyException("GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntry", "columnName");
            }
            this.columnName = columnName;
            return this;
        }
        @CustomType.Setter
        public Builder description(String description) {
            if (description == null) {
              throw new MissingRequiredPropertyException("GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntry", "description");
            }
            this.description = description;
            return this;
        }
        @CustomType.Setter
        public Builder endDate(String endDate) {
            if (endDate == null) {
              throw new MissingRequiredPropertyException("GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntry", "endDate");
            }
            this.endDate = endDate;
            return this;
        }
        @CustomType.Setter
        public Builder endLength(Integer endLength) {
            if (endLength == null) {
              throw new MissingRequiredPropertyException("GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntry", "endLength");
            }
            this.endLength = endLength;
            return this;
        }
        @CustomType.Setter
        public Builder endValue(Double endValue) {
            if (endValue == null) {
              throw new MissingRequiredPropertyException("GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntry", "endValue");
            }
            this.endValue = endValue;
            return this;
        }
        @CustomType.Setter
        public Builder fixedNumber(Double fixedNumber) {
            if (fixedNumber == null) {
              throw new MissingRequiredPropertyException("GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntry", "fixedNumber");
            }
            this.fixedNumber = fixedNumber;
            return this;
        }
        @CustomType.Setter
        public Builder fixedString(String fixedString) {
            if (fixedString == null) {
              throw new MissingRequiredPropertyException("GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntry", "fixedString");
            }
            this.fixedString = fixedString;
            return this;
        }
        @CustomType.Setter
        public Builder groupingColumns(List<String> groupingColumns) {
            if (groupingColumns == null) {
              throw new MissingRequiredPropertyException("GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntry", "groupingColumns");
            }
            this.groupingColumns = groupingColumns;
            return this;
        }
        public Builder groupingColumns(String... groupingColumns) {
            return groupingColumns(List.of(groupingColumns));
        }
        @CustomType.Setter
        public Builder length(Integer length) {
            if (length == null) {
              throw new MissingRequiredPropertyException("GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntry", "length");
            }
            this.length = length;
            return this;
        }
        @CustomType.Setter
        public Builder libraryMaskingFormatId(String libraryMaskingFormatId) {
            if (libraryMaskingFormatId == null) {
              throw new MissingRequiredPropertyException("GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntry", "libraryMaskingFormatId");
            }
            this.libraryMaskingFormatId = libraryMaskingFormatId;
            return this;
        }
        @CustomType.Setter
        public Builder pattern(String pattern) {
            if (pattern == null) {
              throw new MissingRequiredPropertyException("GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntry", "pattern");
            }
            this.pattern = pattern;
            return this;
        }
        @CustomType.Setter
        public Builder postProcessingFunction(String postProcessingFunction) {
            if (postProcessingFunction == null) {
              throw new MissingRequiredPropertyException("GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntry", "postProcessingFunction");
            }
            this.postProcessingFunction = postProcessingFunction;
            return this;
        }
        @CustomType.Setter
        public Builder randomLists(List<String> randomLists) {
            if (randomLists == null) {
              throw new MissingRequiredPropertyException("GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntry", "randomLists");
            }
            this.randomLists = randomLists;
            return this;
        }
        public Builder randomLists(String... randomLists) {
            return randomLists(List.of(randomLists));
        }
        @CustomType.Setter
        public Builder regularExpression(String regularExpression) {
            if (regularExpression == null) {
              throw new MissingRequiredPropertyException("GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntry", "regularExpression");
            }
            this.regularExpression = regularExpression;
            return this;
        }
        @CustomType.Setter
        public Builder replaceWith(String replaceWith) {
            if (replaceWith == null) {
              throw new MissingRequiredPropertyException("GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntry", "replaceWith");
            }
            this.replaceWith = replaceWith;
            return this;
        }
        @CustomType.Setter
        public Builder schemaName(String schemaName) {
            if (schemaName == null) {
              throw new MissingRequiredPropertyException("GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntry", "schemaName");
            }
            this.schemaName = schemaName;
            return this;
        }
        @CustomType.Setter
        public Builder sqlExpression(String sqlExpression) {
            if (sqlExpression == null) {
              throw new MissingRequiredPropertyException("GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntry", "sqlExpression");
            }
            this.sqlExpression = sqlExpression;
            return this;
        }
        @CustomType.Setter
        public Builder startDate(String startDate) {
            if (startDate == null) {
              throw new MissingRequiredPropertyException("GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntry", "startDate");
            }
            this.startDate = startDate;
            return this;
        }
        @CustomType.Setter
        public Builder startLength(Integer startLength) {
            if (startLength == null) {
              throw new MissingRequiredPropertyException("GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntry", "startLength");
            }
            this.startLength = startLength;
            return this;
        }
        @CustomType.Setter
        public Builder startPosition(Integer startPosition) {
            if (startPosition == null) {
              throw new MissingRequiredPropertyException("GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntry", "startPosition");
            }
            this.startPosition = startPosition;
            return this;
        }
        @CustomType.Setter
        public Builder startValue(Double startValue) {
            if (startValue == null) {
              throw new MissingRequiredPropertyException("GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntry", "startValue");
            }
            this.startValue = startValue;
            return this;
        }
        @CustomType.Setter
        public Builder tableName(String tableName) {
            if (tableName == null) {
              throw new MissingRequiredPropertyException("GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntry", "tableName");
            }
            this.tableName = tableName;
            return this;
        }
        @CustomType.Setter
        public Builder type(String type) {
            if (type == null) {
              throw new MissingRequiredPropertyException("GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntry", "type");
            }
            this.type = type;
            return this;
        }
        @CustomType.Setter
        public Builder userDefinedFunction(String userDefinedFunction) {
            if (userDefinedFunction == null) {
              throw new MissingRequiredPropertyException("GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntry", "userDefinedFunction");
            }
            this.userDefinedFunction = userDefinedFunction;
            return this;
        }
        public GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntry build() {
            final var _resultValue = new GetMaskingPoliciesMaskingColumnMaskingFormatFormatEntry();
            _resultValue.columnName = columnName;
            _resultValue.description = description;
            _resultValue.endDate = endDate;
            _resultValue.endLength = endLength;
            _resultValue.endValue = endValue;
            _resultValue.fixedNumber = fixedNumber;
            _resultValue.fixedString = fixedString;
            _resultValue.groupingColumns = groupingColumns;
            _resultValue.length = length;
            _resultValue.libraryMaskingFormatId = libraryMaskingFormatId;
            _resultValue.pattern = pattern;
            _resultValue.postProcessingFunction = postProcessingFunction;
            _resultValue.randomLists = randomLists;
            _resultValue.regularExpression = regularExpression;
            _resultValue.replaceWith = replaceWith;
            _resultValue.schemaName = schemaName;
            _resultValue.sqlExpression = sqlExpression;
            _resultValue.startDate = startDate;
            _resultValue.startLength = startLength;
            _resultValue.startPosition = startPosition;
            _resultValue.startValue = startValue;
            _resultValue.tableName = tableName;
            _resultValue.type = type;
            _resultValue.userDefinedFunction = userDefinedFunction;
            return _resultValue;
        }
    }
}
