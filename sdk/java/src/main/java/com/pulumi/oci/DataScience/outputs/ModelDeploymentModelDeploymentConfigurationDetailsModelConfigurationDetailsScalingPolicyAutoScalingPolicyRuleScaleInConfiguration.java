// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.oci.DataScience.outputs;

import com.pulumi.core.annotations.CustomType;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleInConfiguration {
    /**
     * @return (Updatable) The value is used for adjusting the count of instances by.
     * 
     */
    private @Nullable Integer instanceCountAdjustment;
    /**
     * @return (Updatable) The period of time that the condition defined in the alarm must persist before the alarm state changes from &#34;OK&#34; to &#34;FIRING&#34; or vice versa. For example, a value of 5 minutes means that the alarm must persist in breaching the condition for five minutes before the alarm updates its state to &#34;FIRING&#34;; likewise, the alarm must persist in not breaching the condition for five minutes before the alarm updates its state to &#34;OK.&#34;
     * 
     * The duration is specified as a string in ISO 8601 format (`PT10M` for ten minutes or `PT1H` for one hour). Minimum: PT3M. Maximum: PT1H. Default: PT3M.
     * 
     */
    private @Nullable String pendingDuration;
    /**
     * @return (Updatable) The Monitoring Query Language (MQL) expression to evaluate for the alarm. The Alarms feature of the Monitoring service interprets results for each returned time series as Boolean values, where zero represents false and a non-zero value represents true. A true value means that the trigger rule condition has been met. The query must specify a metric, statistic, interval, and trigger rule (threshold or absence). Supported values for interval: `1m`-`60m` (also `1h`). You can optionally specify dimensions and grouping functions. Supported grouping functions: `grouping()`, `groupBy()`.
     * 
     * Example of threshold alarm:
     * 
     * ***
     * 
     * CPUUtilization[1m]{resourceId = &#34;MODEL_DEPLOYMENT_OCID&#34;}.grouping().mean() &lt; 25 CPUUtilization[1m]{resourceId = &#34;MODEL_DEPLOYMENT_OCID&#34;}.grouping().mean() &gt; 75
     * 
     * ***
     * 
     */
    private @Nullable String query;
    /**
     * @return (Updatable) The type of scaling configuration.
     * 
     */
    private @Nullable String scalingConfigurationType;
    /**
     * @return (Updatable) A metric value at which the scaling operation will be triggered.
     * 
     */
    private @Nullable Integer threshold;

    private ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleInConfiguration() {}
    /**
     * @return (Updatable) The value is used for adjusting the count of instances by.
     * 
     */
    public Optional<Integer> instanceCountAdjustment() {
        return Optional.ofNullable(this.instanceCountAdjustment);
    }
    /**
     * @return (Updatable) The period of time that the condition defined in the alarm must persist before the alarm state changes from &#34;OK&#34; to &#34;FIRING&#34; or vice versa. For example, a value of 5 minutes means that the alarm must persist in breaching the condition for five minutes before the alarm updates its state to &#34;FIRING&#34;; likewise, the alarm must persist in not breaching the condition for five minutes before the alarm updates its state to &#34;OK.&#34;
     * 
     * The duration is specified as a string in ISO 8601 format (`PT10M` for ten minutes or `PT1H` for one hour). Minimum: PT3M. Maximum: PT1H. Default: PT3M.
     * 
     */
    public Optional<String> pendingDuration() {
        return Optional.ofNullable(this.pendingDuration);
    }
    /**
     * @return (Updatable) The Monitoring Query Language (MQL) expression to evaluate for the alarm. The Alarms feature of the Monitoring service interprets results for each returned time series as Boolean values, where zero represents false and a non-zero value represents true. A true value means that the trigger rule condition has been met. The query must specify a metric, statistic, interval, and trigger rule (threshold or absence). Supported values for interval: `1m`-`60m` (also `1h`). You can optionally specify dimensions and grouping functions. Supported grouping functions: `grouping()`, `groupBy()`.
     * 
     * Example of threshold alarm:
     * 
     * ***
     * 
     * CPUUtilization[1m]{resourceId = &#34;MODEL_DEPLOYMENT_OCID&#34;}.grouping().mean() &lt; 25 CPUUtilization[1m]{resourceId = &#34;MODEL_DEPLOYMENT_OCID&#34;}.grouping().mean() &gt; 75
     * 
     * ***
     * 
     */
    public Optional<String> query() {
        return Optional.ofNullable(this.query);
    }
    /**
     * @return (Updatable) The type of scaling configuration.
     * 
     */
    public Optional<String> scalingConfigurationType() {
        return Optional.ofNullable(this.scalingConfigurationType);
    }
    /**
     * @return (Updatable) A metric value at which the scaling operation will be triggered.
     * 
     */
    public Optional<Integer> threshold() {
        return Optional.ofNullable(this.threshold);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleInConfiguration defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable Integer instanceCountAdjustment;
        private @Nullable String pendingDuration;
        private @Nullable String query;
        private @Nullable String scalingConfigurationType;
        private @Nullable Integer threshold;
        public Builder() {}
        public Builder(ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleInConfiguration defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.instanceCountAdjustment = defaults.instanceCountAdjustment;
    	      this.pendingDuration = defaults.pendingDuration;
    	      this.query = defaults.query;
    	      this.scalingConfigurationType = defaults.scalingConfigurationType;
    	      this.threshold = defaults.threshold;
        }

        @CustomType.Setter
        public Builder instanceCountAdjustment(@Nullable Integer instanceCountAdjustment) {

            this.instanceCountAdjustment = instanceCountAdjustment;
            return this;
        }
        @CustomType.Setter
        public Builder pendingDuration(@Nullable String pendingDuration) {

            this.pendingDuration = pendingDuration;
            return this;
        }
        @CustomType.Setter
        public Builder query(@Nullable String query) {

            this.query = query;
            return this;
        }
        @CustomType.Setter
        public Builder scalingConfigurationType(@Nullable String scalingConfigurationType) {

            this.scalingConfigurationType = scalingConfigurationType;
            return this;
        }
        @CustomType.Setter
        public Builder threshold(@Nullable Integer threshold) {

            this.threshold = threshold;
            return this;
        }
        public ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleInConfiguration build() {
            final var _resultValue = new ModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyAutoScalingPolicyRuleScaleInConfiguration();
            _resultValue.instanceCountAdjustment = instanceCountAdjustment;
            _resultValue.pendingDuration = pendingDuration;
            _resultValue.query = query;
            _resultValue.scalingConfigurationType = scalingConfigurationType;
            _resultValue.threshold = threshold;
            return _resultValue;
        }
    }
}
