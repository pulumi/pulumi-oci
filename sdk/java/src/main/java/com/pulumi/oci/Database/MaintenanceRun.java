// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.oci.Database;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.oci.Database.MaintenanceRunArgs;
import com.pulumi.oci.Database.inputs.MaintenanceRunState;
import com.pulumi.oci.Database.outputs.MaintenanceRunEstimatedPatchingTime;
import com.pulumi.oci.Utilities;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import javax.annotation.Nullable;

/**
 * This resource provides the Maintenance Run resource in Oracle Cloud Infrastructure Database service.
 * 
 * Creates a maintenance run with one of the following:
 * The latest available release update patch (RUP) for the Autonomous Container Database.
 * The latest available RUP and DST time zone (TZ) file updates for the Autonomous Container Database.
 * Creates a maintenance run to update the DST TZ file for the Autonomous Container Database.
 * 
 * ## Example Usage
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.oci.Database.MaintenanceRun;
 * import com.pulumi.oci.Database.MaintenanceRunArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var testMaintenanceRun = new MaintenanceRun(&#34;testMaintenanceRun&#34;, MaintenanceRunArgs.builder()        
 *             .patchType(maintenanceRunPatchType)
 *             .targetResourceId(testResource.id())
 *             .timeScheduled(maintenanceRunTimeScheduled)
 *             .compartmentId(compartmentId)
 *             .isDstFileUpdateEnabled(maintenanceRunIsDstFileUpdateEnabled)
 *             .patchingMode(maintenanceRunPatchingMode)
 *             .build());
 * 
 *     }
 * }
 * ```
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ## Import
 * 
 * MaintenanceRuns can be imported using the `id`, e.g.
 * 
 * ```sh
 * $ pulumi import oci:Database/maintenanceRun:MaintenanceRun test_maintenance_run &#34;id&#34;
 * ```
 * 
 */
@ResourceType(type="oci:Database/maintenanceRun:MaintenanceRun")
public class MaintenanceRun extends com.pulumi.resources.CustomResource {
    /**
     * The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment containing the Maintenance Run.
     * 
     */
    @Export(name="compartmentId", refs={String.class}, tree="[0]")
    private Output<String> compartmentId;

    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment containing the Maintenance Run.
     * 
     */
    public Output<String> compartmentId() {
        return this.compartmentId;
    }
    /**
     * Extend current custom action timeout between the current database servers during waiting state, from 0 (zero) to 30 minutes.
     * 
     */
    @Export(name="currentCustomActionTimeoutInMins", refs={Integer.class}, tree="[0]")
    private Output<Integer> currentCustomActionTimeoutInMins;

    /**
     * @return Extend current custom action timeout between the current database servers during waiting state, from 0 (zero) to 30 minutes.
     * 
     */
    public Output<Integer> currentCustomActionTimeoutInMins() {
        return this.currentCustomActionTimeoutInMins;
    }
    /**
     * The name of the current infrastruture component that is getting patched.
     * 
     */
    @Export(name="currentPatchingComponent", refs={String.class}, tree="[0]")
    private Output<String> currentPatchingComponent;

    /**
     * @return The name of the current infrastruture component that is getting patched.
     * 
     */
    public Output<String> currentPatchingComponent() {
        return this.currentPatchingComponent;
    }
    /**
     * Determines the amount of time the system will wait before the start of each database server patching operation. Specify a number of minutes, from 15 to 120.
     * 
     */
    @Export(name="customActionTimeoutInMins", refs={Integer.class}, tree="[0]")
    private Output<Integer> customActionTimeoutInMins;

    /**
     * @return Determines the amount of time the system will wait before the start of each database server patching operation. Specify a number of minutes, from 15 to 120.
     * 
     */
    public Output<Integer> customActionTimeoutInMins() {
        return this.customActionTimeoutInMins;
    }
    /**
     * Description of the maintenance run.
     * 
     */
    @Export(name="description", refs={String.class}, tree="[0]")
    private Output<String> description;

    /**
     * @return Description of the maintenance run.
     * 
     */
    public Output<String> description() {
        return this.description;
    }
    /**
     * The user-friendly name for the maintenance run.
     * 
     */
    @Export(name="displayName", refs={String.class}, tree="[0]")
    private Output<String> displayName;

    /**
     * @return The user-friendly name for the maintenance run.
     * 
     */
    public Output<String> displayName() {
        return this.displayName;
    }
    /**
     * The estimated start time of the next infrastruture component patching operation.
     * 
     */
    @Export(name="estimatedComponentPatchingStartTime", refs={String.class}, tree="[0]")
    private Output<String> estimatedComponentPatchingStartTime;

    /**
     * @return The estimated start time of the next infrastruture component patching operation.
     * 
     */
    public Output<String> estimatedComponentPatchingStartTime() {
        return this.estimatedComponentPatchingStartTime;
    }
    /**
     * The estimated total time required in minutes for all patching operations (database server, storage server, and network switch patching).
     * 
     */
    @Export(name="estimatedPatchingTimes", refs={List.class,MaintenanceRunEstimatedPatchingTime.class}, tree="[0,1]")
    private Output<List<MaintenanceRunEstimatedPatchingTime>> estimatedPatchingTimes;

    /**
     * @return The estimated total time required in minutes for all patching operations (database server, storage server, and network switch patching).
     * 
     */
    public Output<List<MaintenanceRunEstimatedPatchingTime>> estimatedPatchingTimes() {
        return this.estimatedPatchingTimes;
    }
    /**
     * If true, enables the configuration of a custom action timeout (waiting period) between database servers patching operations.
     * 
     */
    @Export(name="isCustomActionTimeoutEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> isCustomActionTimeoutEnabled;

    /**
     * @return If true, enables the configuration of a custom action timeout (waiting period) between database servers patching operations.
     * 
     */
    public Output<Boolean> isCustomActionTimeoutEnabled() {
        return this.isCustomActionTimeoutEnabled;
    }
    /**
     * Indicates if an automatic DST Time Zone file update is enabled for the Autonomous Container Database. If enabled along with Release Update, patching will be done in a Non-Rolling manner.
     * 
     */
    @Export(name="isDstFileUpdateEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> isDstFileUpdateEnabled;

    /**
     * @return Indicates if an automatic DST Time Zone file update is enabled for the Autonomous Container Database. If enabled along with Release Update, patching will be done in a Non-Rolling manner.
     * 
     */
    public Output<Boolean> isDstFileUpdateEnabled() {
        return this.isDstFileUpdateEnabled;
    }
    /**
     * Additional information about the current lifecycle state.
     * 
     */
    @Export(name="lifecycleDetails", refs={String.class}, tree="[0]")
    private Output<String> lifecycleDetails;

    /**
     * @return Additional information about the current lifecycle state.
     * 
     */
    public Output<String> lifecycleDetails() {
        return this.lifecycleDetails;
    }
    /**
     * Maintenance sub-type.
     * 
     */
    @Export(name="maintenanceSubtype", refs={String.class}, tree="[0]")
    private Output<String> maintenanceSubtype;

    /**
     * @return Maintenance sub-type.
     * 
     */
    public Output<String> maintenanceSubtype() {
        return this.maintenanceSubtype;
    }
    /**
     * Maintenance type.
     * 
     */
    @Export(name="maintenanceType", refs={String.class}, tree="[0]")
    private Output<String> maintenanceType;

    /**
     * @return Maintenance type.
     * 
     */
    public Output<String> maintenanceType() {
        return this.maintenanceType;
    }
    /**
     * Contain the patch failure count.
     * 
     */
    @Export(name="patchFailureCount", refs={Integer.class}, tree="[0]")
    private Output<Integer> patchFailureCount;

    /**
     * @return Contain the patch failure count.
     * 
     */
    public Output<Integer> patchFailureCount() {
        return this.patchFailureCount;
    }
    /**
     * The unique identifier of the patch. The identifier string includes the patch type, the Oracle Database version, and the patch creation date (using the format YYMMDD). For example, the identifier `ru_patch_19.9.0.0_201030` is used for an RU patch for Oracle Database 19.9.0.0 that was released October 30, 2020.
     * 
     */
    @Export(name="patchId", refs={String.class}, tree="[0]")
    private Output<String> patchId;

    /**
     * @return The unique identifier of the patch. The identifier string includes the patch type, the Oracle Database version, and the patch creation date (using the format YYMMDD). For example, the identifier `ru_patch_19.9.0.0_201030` is used for an RU patch for Oracle Database 19.9.0.0 that was released October 30, 2020.
     * 
     */
    public Output<String> patchId() {
        return this.patchId;
    }
    /**
     * Patch type, either &#34;QUARTERLY&#34; or &#34;TIMEZONE&#34;.
     * 
     */
    @Export(name="patchType", refs={String.class}, tree="[0]")
    private Output<String> patchType;

    /**
     * @return Patch type, either &#34;QUARTERLY&#34; or &#34;TIMEZONE&#34;.
     * 
     */
    public Output<String> patchType() {
        return this.patchType;
    }
    /**
     * The time when the patching operation ended.
     * 
     */
    @Export(name="patchingEndTime", refs={String.class}, tree="[0]")
    private Output<String> patchingEndTime;

    /**
     * @return The time when the patching operation ended.
     * 
     */
    public Output<String> patchingEndTime() {
        return this.patchingEndTime;
    }
    /**
     * (Updatable) Cloud Exadata infrastructure node patching method, either &#34;ROLLING&#34; or &#34;NONROLLING&#34;. Default value is ROLLING.
     * 
     * *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
     * 
     */
    @Export(name="patchingMode", refs={String.class}, tree="[0]")
    private Output<String> patchingMode;

    /**
     * @return (Updatable) Cloud Exadata infrastructure node patching method, either &#34;ROLLING&#34; or &#34;NONROLLING&#34;. Default value is ROLLING.
     * 
     * *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
     * 
     */
    public Output<String> patchingMode() {
        return this.patchingMode;
    }
    /**
     * The time when the patching operation started.
     * 
     */
    @Export(name="patchingStartTime", refs={String.class}, tree="[0]")
    private Output<String> patchingStartTime;

    /**
     * @return The time when the patching operation started.
     * 
     */
    public Output<String> patchingStartTime() {
        return this.patchingStartTime;
    }
    /**
     * The status of the patching operation.
     * 
     */
    @Export(name="patchingStatus", refs={String.class}, tree="[0]")
    private Output<String> patchingStatus;

    /**
     * @return The status of the patching operation.
     * 
     */
    public Output<String> patchingStatus() {
        return this.patchingStatus;
    }
    /**
     * The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance run for the Autonomous Data Guard association&#39;s peer container database.
     * 
     */
    @Export(name="peerMaintenanceRunId", refs={String.class}, tree="[0]")
    private Output<String> peerMaintenanceRunId;

    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance run for the Autonomous Data Guard association&#39;s peer container database.
     * 
     */
    public Output<String> peerMaintenanceRunId() {
        return this.peerMaintenanceRunId;
    }
    /**
     * The current state of the maintenance run. For Autonomous Database Serverless instances, valid states are IN_PROGRESS, SUCCEEDED, and FAILED.
     * 
     */
    @Export(name="state", refs={String.class}, tree="[0]")
    private Output<String> state;

    /**
     * @return The current state of the maintenance run. For Autonomous Database Serverless instances, valid states are IN_PROGRESS, SUCCEEDED, and FAILED.
     * 
     */
    public Output<String> state() {
        return this.state;
    }
    /**
     * The target software version for the database server patching operation.
     * 
     */
    @Export(name="targetDbServerVersion", refs={String.class}, tree="[0]")
    private Output<String> targetDbServerVersion;

    /**
     * @return The target software version for the database server patching operation.
     * 
     */
    public Output<String> targetDbServerVersion() {
        return this.targetDbServerVersion;
    }
    /**
     * The ID of the target resource for which the maintenance run should be created.
     * 
     */
    @Export(name="targetResourceId", refs={String.class}, tree="[0]")
    private Output<String> targetResourceId;

    /**
     * @return The ID of the target resource for which the maintenance run should be created.
     * 
     */
    public Output<String> targetResourceId() {
        return this.targetResourceId;
    }
    /**
     * The type of the target resource on which the maintenance run occurs.
     * 
     */
    @Export(name="targetResourceType", refs={String.class}, tree="[0]")
    private Output<String> targetResourceType;

    /**
     * @return The type of the target resource on which the maintenance run occurs.
     * 
     */
    public Output<String> targetResourceType() {
        return this.targetResourceType;
    }
    /**
     * The target Cell version that is to be patched to.
     * 
     */
    @Export(name="targetStorageServerVersion", refs={String.class}, tree="[0]")
    private Output<String> targetStorageServerVersion;

    /**
     * @return The target Cell version that is to be patched to.
     * 
     */
    public Output<String> targetStorageServerVersion() {
        return this.targetStorageServerVersion;
    }
    /**
     * The date and time the maintenance run was completed.
     * 
     */
    @Export(name="timeEnded", refs={String.class}, tree="[0]")
    private Output<String> timeEnded;

    /**
     * @return The date and time the maintenance run was completed.
     * 
     */
    public Output<String> timeEnded() {
        return this.timeEnded;
    }
    /**
     * (Updatable) The date and time that update should be scheduled.
     * 
     * ** IMPORTANT **
     * Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
     * 
     */
    @Export(name="timeScheduled", refs={String.class}, tree="[0]")
    private Output<String> timeScheduled;

    /**
     * @return (Updatable) The date and time that update should be scheduled.
     * 
     * ** IMPORTANT **
     * Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
     * 
     */
    public Output<String> timeScheduled() {
        return this.timeScheduled;
    }
    /**
     * The date and time the maintenance run starts.
     * 
     */
    @Export(name="timeStarted", refs={String.class}, tree="[0]")
    private Output<String> timeStarted;

    /**
     * @return The date and time the maintenance run starts.
     * 
     */
    public Output<String> timeStarted() {
        return this.timeStarted;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public MaintenanceRun(String name) {
        this(name, MaintenanceRunArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public MaintenanceRun(String name, MaintenanceRunArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public MaintenanceRun(String name, MaintenanceRunArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("oci:Database/maintenanceRun:MaintenanceRun", name, args == null ? MaintenanceRunArgs.Empty : args, makeResourceOptions(options, Codegen.empty()));
    }

    private MaintenanceRun(String name, Output<String> id, @Nullable MaintenanceRunState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("oci:Database/maintenanceRun:MaintenanceRun", name, state, makeResourceOptions(options, id));
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static MaintenanceRun get(String name, Output<String> id, @Nullable MaintenanceRunState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new MaintenanceRun(name, id, state, options);
    }
}
