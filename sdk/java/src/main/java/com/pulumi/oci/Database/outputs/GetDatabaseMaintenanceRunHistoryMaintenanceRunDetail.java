// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.oci.Database.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.oci.Database.outputs.GetDatabaseMaintenanceRunHistoryMaintenanceRunDetailEstimatedPatchingTime;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;

@CustomType
public final class GetDatabaseMaintenanceRunHistoryMaintenanceRunDetail {
    /**
     * @return The OCID of the compartment.
     * 
     */
    private String compartmentId;
    /**
     * @return Extend current custom action timeout between the current database servers during waiting state, from 0 (zero) to 30 minutes.
     * 
     */
    private Integer currentCustomActionTimeoutInMins;
    /**
     * @return The name of the current infrastruture component that is getting patched.
     * 
     */
    private String currentPatchingComponent;
    /**
     * @return Determines the amount of time the system will wait before the start of each database server patching operation. Specify a number of minutes, from 15 to 120.
     * 
     */
    private Integer customActionTimeoutInMins;
    /**
     * @return Description of the maintenance run.
     * 
     */
    private String description;
    /**
     * @return The user-friendly name for the maintenance run.
     * 
     */
    private String displayName;
    /**
     * @return The estimated start time of the next infrastruture component patching operation.
     * 
     */
    private String estimatedComponentPatchingStartTime;
    /**
     * @return The estimated total time required in minutes for all patching operations (database server, storage server, and network switch patching).
     * 
     */
    private List<GetDatabaseMaintenanceRunHistoryMaintenanceRunDetailEstimatedPatchingTime> estimatedPatchingTimes;
    /**
     * @return The OCID of the maintenance run.
     * 
     */
    private String id;
    /**
     * @return If true, enables the configuration of a custom action timeout (waiting period) between database servers patching operations.
     * 
     */
    private Boolean isCustomActionTimeoutEnabled;
    /**
     * @return Indicates if an automatic DST Time Zone file update is enabled for the Autonomous Container Database. If enabled along with Release Update, patching will be done in a Non-Rolling manner.
     * 
     */
    private Boolean isDstFileUpdateEnabled;
    /**
     * @return Additional information about the current lifecycle state.
     * 
     */
    private String lifecycleDetails;
    /**
     * @return Maintenance sub-type.
     * 
     */
    private String maintenanceSubtype;
    /**
     * @return Maintenance type.
     * 
     */
    private String maintenanceType;
    /**
     * @return Contain the patch failure count.
     * 
     */
    private Integer patchFailureCount;
    /**
     * @return The unique identifier of the patch. The identifier string includes the patch type, the Oracle Database version, and the patch creation date (using the format YYMMDD). For example, the identifier `ru_patch_19.9.0.0_201030` is used for an RU patch for Oracle Database 19.9.0.0 that was released October 30, 2020.
     * 
     */
    private String patchId;
    /**
     * @return The time when the patching operation ended.
     * 
     */
    private String patchingEndTime;
    /**
     * @return Cloud Exadata infrastructure node patching method, either &#34;ROLLING&#34; or &#34;NONROLLING&#34;. Default value is ROLLING.
     * 
     */
    private String patchingMode;
    /**
     * @return The time when the patching operation started.
     * 
     */
    private String patchingStartTime;
    /**
     * @return The status of the patching operation.
     * 
     */
    private String patchingStatus;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance run for the Autonomous Data Guard association&#39;s peer container database.
     * 
     */
    private String peerMaintenanceRunId;
    /**
     * @return The current state of the maintenance run. For Autonomous Database Serverless instances, valid states are IN_PROGRESS, SUCCEEDED, and FAILED.
     * 
     */
    private String state;
    /**
     * @return The target software version for the database server patching operation.
     * 
     */
    private String targetDbServerVersion;
    /**
     * @return The ID of the target resource on which the maintenance run occurs.
     * 
     */
    private String targetResourceId;
    /**
     * @return The type of the target resource on which the maintenance run occurs.
     * 
     */
    private String targetResourceType;
    /**
     * @return The target Cell version that is to be patched to.
     * 
     */
    private String targetStorageServerVersion;
    /**
     * @return The date and time the maintenance run was completed.
     * 
     */
    private String timeEnded;
    /**
     * @return The date and time the maintenance run is scheduled to occur.
     * 
     */
    private String timeScheduled;
    /**
     * @return The date and time the maintenance run starts.
     * 
     */
    private String timeStarted;

    private GetDatabaseMaintenanceRunHistoryMaintenanceRunDetail() {}
    /**
     * @return The OCID of the compartment.
     * 
     */
    public String compartmentId() {
        return this.compartmentId;
    }
    /**
     * @return Extend current custom action timeout between the current database servers during waiting state, from 0 (zero) to 30 minutes.
     * 
     */
    public Integer currentCustomActionTimeoutInMins() {
        return this.currentCustomActionTimeoutInMins;
    }
    /**
     * @return The name of the current infrastruture component that is getting patched.
     * 
     */
    public String currentPatchingComponent() {
        return this.currentPatchingComponent;
    }
    /**
     * @return Determines the amount of time the system will wait before the start of each database server patching operation. Specify a number of minutes, from 15 to 120.
     * 
     */
    public Integer customActionTimeoutInMins() {
        return this.customActionTimeoutInMins;
    }
    /**
     * @return Description of the maintenance run.
     * 
     */
    public String description() {
        return this.description;
    }
    /**
     * @return The user-friendly name for the maintenance run.
     * 
     */
    public String displayName() {
        return this.displayName;
    }
    /**
     * @return The estimated start time of the next infrastruture component patching operation.
     * 
     */
    public String estimatedComponentPatchingStartTime() {
        return this.estimatedComponentPatchingStartTime;
    }
    /**
     * @return The estimated total time required in minutes for all patching operations (database server, storage server, and network switch patching).
     * 
     */
    public List<GetDatabaseMaintenanceRunHistoryMaintenanceRunDetailEstimatedPatchingTime> estimatedPatchingTimes() {
        return this.estimatedPatchingTimes;
    }
    /**
     * @return The OCID of the maintenance run.
     * 
     */
    public String id() {
        return this.id;
    }
    /**
     * @return If true, enables the configuration of a custom action timeout (waiting period) between database servers patching operations.
     * 
     */
    public Boolean isCustomActionTimeoutEnabled() {
        return this.isCustomActionTimeoutEnabled;
    }
    /**
     * @return Indicates if an automatic DST Time Zone file update is enabled for the Autonomous Container Database. If enabled along with Release Update, patching will be done in a Non-Rolling manner.
     * 
     */
    public Boolean isDstFileUpdateEnabled() {
        return this.isDstFileUpdateEnabled;
    }
    /**
     * @return Additional information about the current lifecycle state.
     * 
     */
    public String lifecycleDetails() {
        return this.lifecycleDetails;
    }
    /**
     * @return Maintenance sub-type.
     * 
     */
    public String maintenanceSubtype() {
        return this.maintenanceSubtype;
    }
    /**
     * @return Maintenance type.
     * 
     */
    public String maintenanceType() {
        return this.maintenanceType;
    }
    /**
     * @return Contain the patch failure count.
     * 
     */
    public Integer patchFailureCount() {
        return this.patchFailureCount;
    }
    /**
     * @return The unique identifier of the patch. The identifier string includes the patch type, the Oracle Database version, and the patch creation date (using the format YYMMDD). For example, the identifier `ru_patch_19.9.0.0_201030` is used for an RU patch for Oracle Database 19.9.0.0 that was released October 30, 2020.
     * 
     */
    public String patchId() {
        return this.patchId;
    }
    /**
     * @return The time when the patching operation ended.
     * 
     */
    public String patchingEndTime() {
        return this.patchingEndTime;
    }
    /**
     * @return Cloud Exadata infrastructure node patching method, either &#34;ROLLING&#34; or &#34;NONROLLING&#34;. Default value is ROLLING.
     * 
     */
    public String patchingMode() {
        return this.patchingMode;
    }
    /**
     * @return The time when the patching operation started.
     * 
     */
    public String patchingStartTime() {
        return this.patchingStartTime;
    }
    /**
     * @return The status of the patching operation.
     * 
     */
    public String patchingStatus() {
        return this.patchingStatus;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance run for the Autonomous Data Guard association&#39;s peer container database.
     * 
     */
    public String peerMaintenanceRunId() {
        return this.peerMaintenanceRunId;
    }
    /**
     * @return The current state of the maintenance run. For Autonomous Database Serverless instances, valid states are IN_PROGRESS, SUCCEEDED, and FAILED.
     * 
     */
    public String state() {
        return this.state;
    }
    /**
     * @return The target software version for the database server patching operation.
     * 
     */
    public String targetDbServerVersion() {
        return this.targetDbServerVersion;
    }
    /**
     * @return The ID of the target resource on which the maintenance run occurs.
     * 
     */
    public String targetResourceId() {
        return this.targetResourceId;
    }
    /**
     * @return The type of the target resource on which the maintenance run occurs.
     * 
     */
    public String targetResourceType() {
        return this.targetResourceType;
    }
    /**
     * @return The target Cell version that is to be patched to.
     * 
     */
    public String targetStorageServerVersion() {
        return this.targetStorageServerVersion;
    }
    /**
     * @return The date and time the maintenance run was completed.
     * 
     */
    public String timeEnded() {
        return this.timeEnded;
    }
    /**
     * @return The date and time the maintenance run is scheduled to occur.
     * 
     */
    public String timeScheduled() {
        return this.timeScheduled;
    }
    /**
     * @return The date and time the maintenance run starts.
     * 
     */
    public String timeStarted() {
        return this.timeStarted;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetDatabaseMaintenanceRunHistoryMaintenanceRunDetail defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String compartmentId;
        private Integer currentCustomActionTimeoutInMins;
        private String currentPatchingComponent;
        private Integer customActionTimeoutInMins;
        private String description;
        private String displayName;
        private String estimatedComponentPatchingStartTime;
        private List<GetDatabaseMaintenanceRunHistoryMaintenanceRunDetailEstimatedPatchingTime> estimatedPatchingTimes;
        private String id;
        private Boolean isCustomActionTimeoutEnabled;
        private Boolean isDstFileUpdateEnabled;
        private String lifecycleDetails;
        private String maintenanceSubtype;
        private String maintenanceType;
        private Integer patchFailureCount;
        private String patchId;
        private String patchingEndTime;
        private String patchingMode;
        private String patchingStartTime;
        private String patchingStatus;
        private String peerMaintenanceRunId;
        private String state;
        private String targetDbServerVersion;
        private String targetResourceId;
        private String targetResourceType;
        private String targetStorageServerVersion;
        private String timeEnded;
        private String timeScheduled;
        private String timeStarted;
        public Builder() {}
        public Builder(GetDatabaseMaintenanceRunHistoryMaintenanceRunDetail defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.compartmentId = defaults.compartmentId;
    	      this.currentCustomActionTimeoutInMins = defaults.currentCustomActionTimeoutInMins;
    	      this.currentPatchingComponent = defaults.currentPatchingComponent;
    	      this.customActionTimeoutInMins = defaults.customActionTimeoutInMins;
    	      this.description = defaults.description;
    	      this.displayName = defaults.displayName;
    	      this.estimatedComponentPatchingStartTime = defaults.estimatedComponentPatchingStartTime;
    	      this.estimatedPatchingTimes = defaults.estimatedPatchingTimes;
    	      this.id = defaults.id;
    	      this.isCustomActionTimeoutEnabled = defaults.isCustomActionTimeoutEnabled;
    	      this.isDstFileUpdateEnabled = defaults.isDstFileUpdateEnabled;
    	      this.lifecycleDetails = defaults.lifecycleDetails;
    	      this.maintenanceSubtype = defaults.maintenanceSubtype;
    	      this.maintenanceType = defaults.maintenanceType;
    	      this.patchFailureCount = defaults.patchFailureCount;
    	      this.patchId = defaults.patchId;
    	      this.patchingEndTime = defaults.patchingEndTime;
    	      this.patchingMode = defaults.patchingMode;
    	      this.patchingStartTime = defaults.patchingStartTime;
    	      this.patchingStatus = defaults.patchingStatus;
    	      this.peerMaintenanceRunId = defaults.peerMaintenanceRunId;
    	      this.state = defaults.state;
    	      this.targetDbServerVersion = defaults.targetDbServerVersion;
    	      this.targetResourceId = defaults.targetResourceId;
    	      this.targetResourceType = defaults.targetResourceType;
    	      this.targetStorageServerVersion = defaults.targetStorageServerVersion;
    	      this.timeEnded = defaults.timeEnded;
    	      this.timeScheduled = defaults.timeScheduled;
    	      this.timeStarted = defaults.timeStarted;
        }

        @CustomType.Setter
        public Builder compartmentId(String compartmentId) {
            this.compartmentId = Objects.requireNonNull(compartmentId);
            return this;
        }
        @CustomType.Setter
        public Builder currentCustomActionTimeoutInMins(Integer currentCustomActionTimeoutInMins) {
            this.currentCustomActionTimeoutInMins = Objects.requireNonNull(currentCustomActionTimeoutInMins);
            return this;
        }
        @CustomType.Setter
        public Builder currentPatchingComponent(String currentPatchingComponent) {
            this.currentPatchingComponent = Objects.requireNonNull(currentPatchingComponent);
            return this;
        }
        @CustomType.Setter
        public Builder customActionTimeoutInMins(Integer customActionTimeoutInMins) {
            this.customActionTimeoutInMins = Objects.requireNonNull(customActionTimeoutInMins);
            return this;
        }
        @CustomType.Setter
        public Builder description(String description) {
            this.description = Objects.requireNonNull(description);
            return this;
        }
        @CustomType.Setter
        public Builder displayName(String displayName) {
            this.displayName = Objects.requireNonNull(displayName);
            return this;
        }
        @CustomType.Setter
        public Builder estimatedComponentPatchingStartTime(String estimatedComponentPatchingStartTime) {
            this.estimatedComponentPatchingStartTime = Objects.requireNonNull(estimatedComponentPatchingStartTime);
            return this;
        }
        @CustomType.Setter
        public Builder estimatedPatchingTimes(List<GetDatabaseMaintenanceRunHistoryMaintenanceRunDetailEstimatedPatchingTime> estimatedPatchingTimes) {
            this.estimatedPatchingTimes = Objects.requireNonNull(estimatedPatchingTimes);
            return this;
        }
        public Builder estimatedPatchingTimes(GetDatabaseMaintenanceRunHistoryMaintenanceRunDetailEstimatedPatchingTime... estimatedPatchingTimes) {
            return estimatedPatchingTimes(List.of(estimatedPatchingTimes));
        }
        @CustomType.Setter
        public Builder id(String id) {
            this.id = Objects.requireNonNull(id);
            return this;
        }
        @CustomType.Setter
        public Builder isCustomActionTimeoutEnabled(Boolean isCustomActionTimeoutEnabled) {
            this.isCustomActionTimeoutEnabled = Objects.requireNonNull(isCustomActionTimeoutEnabled);
            return this;
        }
        @CustomType.Setter
        public Builder isDstFileUpdateEnabled(Boolean isDstFileUpdateEnabled) {
            this.isDstFileUpdateEnabled = Objects.requireNonNull(isDstFileUpdateEnabled);
            return this;
        }
        @CustomType.Setter
        public Builder lifecycleDetails(String lifecycleDetails) {
            this.lifecycleDetails = Objects.requireNonNull(lifecycleDetails);
            return this;
        }
        @CustomType.Setter
        public Builder maintenanceSubtype(String maintenanceSubtype) {
            this.maintenanceSubtype = Objects.requireNonNull(maintenanceSubtype);
            return this;
        }
        @CustomType.Setter
        public Builder maintenanceType(String maintenanceType) {
            this.maintenanceType = Objects.requireNonNull(maintenanceType);
            return this;
        }
        @CustomType.Setter
        public Builder patchFailureCount(Integer patchFailureCount) {
            this.patchFailureCount = Objects.requireNonNull(patchFailureCount);
            return this;
        }
        @CustomType.Setter
        public Builder patchId(String patchId) {
            this.patchId = Objects.requireNonNull(patchId);
            return this;
        }
        @CustomType.Setter
        public Builder patchingEndTime(String patchingEndTime) {
            this.patchingEndTime = Objects.requireNonNull(patchingEndTime);
            return this;
        }
        @CustomType.Setter
        public Builder patchingMode(String patchingMode) {
            this.patchingMode = Objects.requireNonNull(patchingMode);
            return this;
        }
        @CustomType.Setter
        public Builder patchingStartTime(String patchingStartTime) {
            this.patchingStartTime = Objects.requireNonNull(patchingStartTime);
            return this;
        }
        @CustomType.Setter
        public Builder patchingStatus(String patchingStatus) {
            this.patchingStatus = Objects.requireNonNull(patchingStatus);
            return this;
        }
        @CustomType.Setter
        public Builder peerMaintenanceRunId(String peerMaintenanceRunId) {
            this.peerMaintenanceRunId = Objects.requireNonNull(peerMaintenanceRunId);
            return this;
        }
        @CustomType.Setter
        public Builder state(String state) {
            this.state = Objects.requireNonNull(state);
            return this;
        }
        @CustomType.Setter
        public Builder targetDbServerVersion(String targetDbServerVersion) {
            this.targetDbServerVersion = Objects.requireNonNull(targetDbServerVersion);
            return this;
        }
        @CustomType.Setter
        public Builder targetResourceId(String targetResourceId) {
            this.targetResourceId = Objects.requireNonNull(targetResourceId);
            return this;
        }
        @CustomType.Setter
        public Builder targetResourceType(String targetResourceType) {
            this.targetResourceType = Objects.requireNonNull(targetResourceType);
            return this;
        }
        @CustomType.Setter
        public Builder targetStorageServerVersion(String targetStorageServerVersion) {
            this.targetStorageServerVersion = Objects.requireNonNull(targetStorageServerVersion);
            return this;
        }
        @CustomType.Setter
        public Builder timeEnded(String timeEnded) {
            this.timeEnded = Objects.requireNonNull(timeEnded);
            return this;
        }
        @CustomType.Setter
        public Builder timeScheduled(String timeScheduled) {
            this.timeScheduled = Objects.requireNonNull(timeScheduled);
            return this;
        }
        @CustomType.Setter
        public Builder timeStarted(String timeStarted) {
            this.timeStarted = Objects.requireNonNull(timeStarted);
            return this;
        }
        public GetDatabaseMaintenanceRunHistoryMaintenanceRunDetail build() {
            final var _resultValue = new GetDatabaseMaintenanceRunHistoryMaintenanceRunDetail();
            _resultValue.compartmentId = compartmentId;
            _resultValue.currentCustomActionTimeoutInMins = currentCustomActionTimeoutInMins;
            _resultValue.currentPatchingComponent = currentPatchingComponent;
            _resultValue.customActionTimeoutInMins = customActionTimeoutInMins;
            _resultValue.description = description;
            _resultValue.displayName = displayName;
            _resultValue.estimatedComponentPatchingStartTime = estimatedComponentPatchingStartTime;
            _resultValue.estimatedPatchingTimes = estimatedPatchingTimes;
            _resultValue.id = id;
            _resultValue.isCustomActionTimeoutEnabled = isCustomActionTimeoutEnabled;
            _resultValue.isDstFileUpdateEnabled = isDstFileUpdateEnabled;
            _resultValue.lifecycleDetails = lifecycleDetails;
            _resultValue.maintenanceSubtype = maintenanceSubtype;
            _resultValue.maintenanceType = maintenanceType;
            _resultValue.patchFailureCount = patchFailureCount;
            _resultValue.patchId = patchId;
            _resultValue.patchingEndTime = patchingEndTime;
            _resultValue.patchingMode = patchingMode;
            _resultValue.patchingStartTime = patchingStartTime;
            _resultValue.patchingStatus = patchingStatus;
            _resultValue.peerMaintenanceRunId = peerMaintenanceRunId;
            _resultValue.state = state;
            _resultValue.targetDbServerVersion = targetDbServerVersion;
            _resultValue.targetResourceId = targetResourceId;
            _resultValue.targetResourceType = targetResourceType;
            _resultValue.targetStorageServerVersion = targetStorageServerVersion;
            _resultValue.timeEnded = timeEnded;
            _resultValue.timeScheduled = timeScheduled;
            _resultValue.timeStarted = timeStarted;
            return _resultValue;
        }
    }
}
