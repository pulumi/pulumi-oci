// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.oci.DatabaseManagement.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;

@CustomType
public final class GetCloudExadataStorageServerIormPlanDbPlanItem {
    /**
     * @return The resource allocation as a percentage (0-100) within the level.
     * 
     */
    private Integer allocation;
    /**
     * @return Starting with Oracle Exadata System Software release 19.1.0, you can use the asmcluster attribute to distinguish between databases with the same name running in different Oracle ASM clusters.
     * 
     */
    private String asmCluster;
    /**
     * @return Defines a soft limit for space usage in Exadata Smart Flash Cache. If the cache is not full, the limit can be exceeded. You specify the value for flashcachelimit in bytes. You can also use the suffixes M (megabytes), G (gigabytes), or T (terabytes) to specify larger values. For example, 300M, 150G, or 1T. The value for flashcachelimit must be at least 4 MB. The flashcachelimit and flashcachesize attributes cannot be specified in the same directive. The value for flashcachelimit cannot be smaller than flashcachemin, if it is specified.
     * 
     */
    private String flashCacheLimit;
    /**
     * @return Specifies a minimum guaranteed space allocation in Exadata Smart Flash Cache. You specify the value for flashcachemin in bytes. You can also use the suffixes M (megabytes), G (gigabytes), or T (terabytes) to specify larger values. For example, 300M, 150G, or 1T. The value for flashcachemin must be at least 4 MB. In any plan, the sum of all flashcachemin values cannot exceed the size of Exadata Smart Flash Cache. If flashcachelimit is specified, then the value for flashcachemin cannot exceed flashcachelimit. If flashcachesize is specified, then the value for flashcachemin cannot exceed flashcachesize.
     * 
     */
    private String flashCacheMin;
    /**
     * @return Defines a hard limit for space usage in Exadata Smart Flash Cache. The limit cannot be exceeded, even if the cache is not full. In an IORM plan, if the size of Exadata Smart Flash Cache can accommodate all of the flashcachemin and flashcachesize allocations, then each flashcachesize definition represents a guaranteed space allocation. However, starting with Oracle Exadata System Software release 19.2.0 you can use the flashcachesize attribute to over-provision space in Exadata Smart Flash Cache. Consequently, if the size of Exadata Smart Flash Cache cannot accommodate all of the flashcachemin and flashcachesize allocations, then only flashcachemin is guaranteed.
     * 
     */
    private String flashCacheSize;
    /**
     * @return Controls use of Exadata Smart Flash Cache by a database. This ensures that cache space is reserved for mission-critical databases. flashcache=off is invalid in a directive that contains the flashcachemin, flashcachelimit, or flashcachesize attributes.
     * 
     */
    private Boolean isFlashCacheOn;
    /**
     * @return Controls use of Exadata Smart Flash Log by a database. This ensures that Exadata Smart Flash Log is reserved for mission-critical databases.
     * 
     */
    private Boolean isFlashLogOn;
    /**
     * @return Controls use of the persistent memory (PMEM) cache by a database. This ensures that cache space is reserved for mission-critical databases. pmemcache=off is invalid in a directive that contains the pmemcachemin, pmemcachelimit, or pmemcachesize attributes.
     * 
     */
    private Boolean isPmemCacheOn;
    /**
     * @return Controls use of persistent memory logging (PMEM log) by a database. This ensures that PMEM log is reserved for mission-critical databases.
     * 
     */
    private Boolean isPmemLogOn;
    /**
     * @return The allocation level. Valid values are from 1 to 8. Resources are allocated to level 1 first, and then remaining resources are allocated to level 2, and so on.
     * 
     */
    private Integer level;
    /**
     * @return The name of a database or a profile.
     * 
     */
    private String name;
    /**
     * @return Defines a soft limit for space usage in the persistent memory (PMEM) cache. If the cache is not full, the limit can be exceeded. You specify the value for pmemcachelimit in bytes. You can also use the suffixes M (megabytes), G (gigabytes), or T (terabytes) to specify larger values. For example, 300M, 150G, or 1T. The value for pmemcachelimit must be at least 4 MB. The pmemcachelimit and pmemcachesize attributes cannot be specified in the same directive. The value for pmemcachelimit cannot be smaller than pmemcachemin, if it is specified.
     * 
     */
    private String pmemCacheLimit;
    /**
     * @return Specifies a minimum guaranteed space allocation in the persistent memory (PMEM) cache.
     * 
     */
    private String pmemCacheMin;
    /**
     * @return Defines a hard limit for space usage in the persistent memory (PMEM) cache. The limit cannot be exceeded, even if the cache is not full. In an IORM plan, if the size of the PMEM cache can accommodate all of the pmemcachemin and pmemcachesize allocations, then each pmemcachesize definition represents a guaranteed space allocation. However, you can use the pmemcachesize attribute to over-provision space in the PMEM cache. Consequently, if the PMEM cache size cannot accommodate all of the pmemcachemin and pmemcachesize allocations, then only pmemcachemin is guaranteed.
     * 
     */
    private String pmemCacheSize;
    /**
     * @return Enables you to specify different plan directives based on the Oracle Data Guard database role.
     * 
     */
    private String role;
    /**
     * @return The relative priority of a database in the database plan. A higher share value implies higher priority and more access to the I/O resources. Use either share or (level, allocation). All plan directives in a database plan should use the same setting. Share-based resource allocation is the recommended method for a database plan.
     * 
     */
    private Integer share;
    /**
     * @return Enables you to create a profile or template, to ease management and configuration of resource plans in environments with many databases.
     * * type=database: Specifies a directive that applies to a specific database. If type in not specified, then the directive defaults to the database type.
     * * type=profile: Specifies a directive that applies to a profile rather than a specific database.
     * 
     */
    private String type;

    private GetCloudExadataStorageServerIormPlanDbPlanItem() {}
    /**
     * @return The resource allocation as a percentage (0-100) within the level.
     * 
     */
    public Integer allocation() {
        return this.allocation;
    }
    /**
     * @return Starting with Oracle Exadata System Software release 19.1.0, you can use the asmcluster attribute to distinguish between databases with the same name running in different Oracle ASM clusters.
     * 
     */
    public String asmCluster() {
        return this.asmCluster;
    }
    /**
     * @return Defines a soft limit for space usage in Exadata Smart Flash Cache. If the cache is not full, the limit can be exceeded. You specify the value for flashcachelimit in bytes. You can also use the suffixes M (megabytes), G (gigabytes), or T (terabytes) to specify larger values. For example, 300M, 150G, or 1T. The value for flashcachelimit must be at least 4 MB. The flashcachelimit and flashcachesize attributes cannot be specified in the same directive. The value for flashcachelimit cannot be smaller than flashcachemin, if it is specified.
     * 
     */
    public String flashCacheLimit() {
        return this.flashCacheLimit;
    }
    /**
     * @return Specifies a minimum guaranteed space allocation in Exadata Smart Flash Cache. You specify the value for flashcachemin in bytes. You can also use the suffixes M (megabytes), G (gigabytes), or T (terabytes) to specify larger values. For example, 300M, 150G, or 1T. The value for flashcachemin must be at least 4 MB. In any plan, the sum of all flashcachemin values cannot exceed the size of Exadata Smart Flash Cache. If flashcachelimit is specified, then the value for flashcachemin cannot exceed flashcachelimit. If flashcachesize is specified, then the value for flashcachemin cannot exceed flashcachesize.
     * 
     */
    public String flashCacheMin() {
        return this.flashCacheMin;
    }
    /**
     * @return Defines a hard limit for space usage in Exadata Smart Flash Cache. The limit cannot be exceeded, even if the cache is not full. In an IORM plan, if the size of Exadata Smart Flash Cache can accommodate all of the flashcachemin and flashcachesize allocations, then each flashcachesize definition represents a guaranteed space allocation. However, starting with Oracle Exadata System Software release 19.2.0 you can use the flashcachesize attribute to over-provision space in Exadata Smart Flash Cache. Consequently, if the size of Exadata Smart Flash Cache cannot accommodate all of the flashcachemin and flashcachesize allocations, then only flashcachemin is guaranteed.
     * 
     */
    public String flashCacheSize() {
        return this.flashCacheSize;
    }
    /**
     * @return Controls use of Exadata Smart Flash Cache by a database. This ensures that cache space is reserved for mission-critical databases. flashcache=off is invalid in a directive that contains the flashcachemin, flashcachelimit, or flashcachesize attributes.
     * 
     */
    public Boolean isFlashCacheOn() {
        return this.isFlashCacheOn;
    }
    /**
     * @return Controls use of Exadata Smart Flash Log by a database. This ensures that Exadata Smart Flash Log is reserved for mission-critical databases.
     * 
     */
    public Boolean isFlashLogOn() {
        return this.isFlashLogOn;
    }
    /**
     * @return Controls use of the persistent memory (PMEM) cache by a database. This ensures that cache space is reserved for mission-critical databases. pmemcache=off is invalid in a directive that contains the pmemcachemin, pmemcachelimit, or pmemcachesize attributes.
     * 
     */
    public Boolean isPmemCacheOn() {
        return this.isPmemCacheOn;
    }
    /**
     * @return Controls use of persistent memory logging (PMEM log) by a database. This ensures that PMEM log is reserved for mission-critical databases.
     * 
     */
    public Boolean isPmemLogOn() {
        return this.isPmemLogOn;
    }
    /**
     * @return The allocation level. Valid values are from 1 to 8. Resources are allocated to level 1 first, and then remaining resources are allocated to level 2, and so on.
     * 
     */
    public Integer level() {
        return this.level;
    }
    /**
     * @return The name of a database or a profile.
     * 
     */
    public String name() {
        return this.name;
    }
    /**
     * @return Defines a soft limit for space usage in the persistent memory (PMEM) cache. If the cache is not full, the limit can be exceeded. You specify the value for pmemcachelimit in bytes. You can also use the suffixes M (megabytes), G (gigabytes), or T (terabytes) to specify larger values. For example, 300M, 150G, or 1T. The value for pmemcachelimit must be at least 4 MB. The pmemcachelimit and pmemcachesize attributes cannot be specified in the same directive. The value for pmemcachelimit cannot be smaller than pmemcachemin, if it is specified.
     * 
     */
    public String pmemCacheLimit() {
        return this.pmemCacheLimit;
    }
    /**
     * @return Specifies a minimum guaranteed space allocation in the persistent memory (PMEM) cache.
     * 
     */
    public String pmemCacheMin() {
        return this.pmemCacheMin;
    }
    /**
     * @return Defines a hard limit for space usage in the persistent memory (PMEM) cache. The limit cannot be exceeded, even if the cache is not full. In an IORM plan, if the size of the PMEM cache can accommodate all of the pmemcachemin and pmemcachesize allocations, then each pmemcachesize definition represents a guaranteed space allocation. However, you can use the pmemcachesize attribute to over-provision space in the PMEM cache. Consequently, if the PMEM cache size cannot accommodate all of the pmemcachemin and pmemcachesize allocations, then only pmemcachemin is guaranteed.
     * 
     */
    public String pmemCacheSize() {
        return this.pmemCacheSize;
    }
    /**
     * @return Enables you to specify different plan directives based on the Oracle Data Guard database role.
     * 
     */
    public String role() {
        return this.role;
    }
    /**
     * @return The relative priority of a database in the database plan. A higher share value implies higher priority and more access to the I/O resources. Use either share or (level, allocation). All plan directives in a database plan should use the same setting. Share-based resource allocation is the recommended method for a database plan.
     * 
     */
    public Integer share() {
        return this.share;
    }
    /**
     * @return Enables you to create a profile or template, to ease management and configuration of resource plans in environments with many databases.
     * * type=database: Specifies a directive that applies to a specific database. If type in not specified, then the directive defaults to the database type.
     * * type=profile: Specifies a directive that applies to a profile rather than a specific database.
     * 
     */
    public String type() {
        return this.type;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetCloudExadataStorageServerIormPlanDbPlanItem defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private Integer allocation;
        private String asmCluster;
        private String flashCacheLimit;
        private String flashCacheMin;
        private String flashCacheSize;
        private Boolean isFlashCacheOn;
        private Boolean isFlashLogOn;
        private Boolean isPmemCacheOn;
        private Boolean isPmemLogOn;
        private Integer level;
        private String name;
        private String pmemCacheLimit;
        private String pmemCacheMin;
        private String pmemCacheSize;
        private String role;
        private Integer share;
        private String type;
        public Builder() {}
        public Builder(GetCloudExadataStorageServerIormPlanDbPlanItem defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.allocation = defaults.allocation;
    	      this.asmCluster = defaults.asmCluster;
    	      this.flashCacheLimit = defaults.flashCacheLimit;
    	      this.flashCacheMin = defaults.flashCacheMin;
    	      this.flashCacheSize = defaults.flashCacheSize;
    	      this.isFlashCacheOn = defaults.isFlashCacheOn;
    	      this.isFlashLogOn = defaults.isFlashLogOn;
    	      this.isPmemCacheOn = defaults.isPmemCacheOn;
    	      this.isPmemLogOn = defaults.isPmemLogOn;
    	      this.level = defaults.level;
    	      this.name = defaults.name;
    	      this.pmemCacheLimit = defaults.pmemCacheLimit;
    	      this.pmemCacheMin = defaults.pmemCacheMin;
    	      this.pmemCacheSize = defaults.pmemCacheSize;
    	      this.role = defaults.role;
    	      this.share = defaults.share;
    	      this.type = defaults.type;
        }

        @CustomType.Setter
        public Builder allocation(Integer allocation) {
            if (allocation == null) {
              throw new MissingRequiredPropertyException("GetCloudExadataStorageServerIormPlanDbPlanItem", "allocation");
            }
            this.allocation = allocation;
            return this;
        }
        @CustomType.Setter
        public Builder asmCluster(String asmCluster) {
            if (asmCluster == null) {
              throw new MissingRequiredPropertyException("GetCloudExadataStorageServerIormPlanDbPlanItem", "asmCluster");
            }
            this.asmCluster = asmCluster;
            return this;
        }
        @CustomType.Setter
        public Builder flashCacheLimit(String flashCacheLimit) {
            if (flashCacheLimit == null) {
              throw new MissingRequiredPropertyException("GetCloudExadataStorageServerIormPlanDbPlanItem", "flashCacheLimit");
            }
            this.flashCacheLimit = flashCacheLimit;
            return this;
        }
        @CustomType.Setter
        public Builder flashCacheMin(String flashCacheMin) {
            if (flashCacheMin == null) {
              throw new MissingRequiredPropertyException("GetCloudExadataStorageServerIormPlanDbPlanItem", "flashCacheMin");
            }
            this.flashCacheMin = flashCacheMin;
            return this;
        }
        @CustomType.Setter
        public Builder flashCacheSize(String flashCacheSize) {
            if (flashCacheSize == null) {
              throw new MissingRequiredPropertyException("GetCloudExadataStorageServerIormPlanDbPlanItem", "flashCacheSize");
            }
            this.flashCacheSize = flashCacheSize;
            return this;
        }
        @CustomType.Setter
        public Builder isFlashCacheOn(Boolean isFlashCacheOn) {
            if (isFlashCacheOn == null) {
              throw new MissingRequiredPropertyException("GetCloudExadataStorageServerIormPlanDbPlanItem", "isFlashCacheOn");
            }
            this.isFlashCacheOn = isFlashCacheOn;
            return this;
        }
        @CustomType.Setter
        public Builder isFlashLogOn(Boolean isFlashLogOn) {
            if (isFlashLogOn == null) {
              throw new MissingRequiredPropertyException("GetCloudExadataStorageServerIormPlanDbPlanItem", "isFlashLogOn");
            }
            this.isFlashLogOn = isFlashLogOn;
            return this;
        }
        @CustomType.Setter
        public Builder isPmemCacheOn(Boolean isPmemCacheOn) {
            if (isPmemCacheOn == null) {
              throw new MissingRequiredPropertyException("GetCloudExadataStorageServerIormPlanDbPlanItem", "isPmemCacheOn");
            }
            this.isPmemCacheOn = isPmemCacheOn;
            return this;
        }
        @CustomType.Setter
        public Builder isPmemLogOn(Boolean isPmemLogOn) {
            if (isPmemLogOn == null) {
              throw new MissingRequiredPropertyException("GetCloudExadataStorageServerIormPlanDbPlanItem", "isPmemLogOn");
            }
            this.isPmemLogOn = isPmemLogOn;
            return this;
        }
        @CustomType.Setter
        public Builder level(Integer level) {
            if (level == null) {
              throw new MissingRequiredPropertyException("GetCloudExadataStorageServerIormPlanDbPlanItem", "level");
            }
            this.level = level;
            return this;
        }
        @CustomType.Setter
        public Builder name(String name) {
            if (name == null) {
              throw new MissingRequiredPropertyException("GetCloudExadataStorageServerIormPlanDbPlanItem", "name");
            }
            this.name = name;
            return this;
        }
        @CustomType.Setter
        public Builder pmemCacheLimit(String pmemCacheLimit) {
            if (pmemCacheLimit == null) {
              throw new MissingRequiredPropertyException("GetCloudExadataStorageServerIormPlanDbPlanItem", "pmemCacheLimit");
            }
            this.pmemCacheLimit = pmemCacheLimit;
            return this;
        }
        @CustomType.Setter
        public Builder pmemCacheMin(String pmemCacheMin) {
            if (pmemCacheMin == null) {
              throw new MissingRequiredPropertyException("GetCloudExadataStorageServerIormPlanDbPlanItem", "pmemCacheMin");
            }
            this.pmemCacheMin = pmemCacheMin;
            return this;
        }
        @CustomType.Setter
        public Builder pmemCacheSize(String pmemCacheSize) {
            if (pmemCacheSize == null) {
              throw new MissingRequiredPropertyException("GetCloudExadataStorageServerIormPlanDbPlanItem", "pmemCacheSize");
            }
            this.pmemCacheSize = pmemCacheSize;
            return this;
        }
        @CustomType.Setter
        public Builder role(String role) {
            if (role == null) {
              throw new MissingRequiredPropertyException("GetCloudExadataStorageServerIormPlanDbPlanItem", "role");
            }
            this.role = role;
            return this;
        }
        @CustomType.Setter
        public Builder share(Integer share) {
            if (share == null) {
              throw new MissingRequiredPropertyException("GetCloudExadataStorageServerIormPlanDbPlanItem", "share");
            }
            this.share = share;
            return this;
        }
        @CustomType.Setter
        public Builder type(String type) {
            if (type == null) {
              throw new MissingRequiredPropertyException("GetCloudExadataStorageServerIormPlanDbPlanItem", "type");
            }
            this.type = type;
            return this;
        }
        public GetCloudExadataStorageServerIormPlanDbPlanItem build() {
            final var _resultValue = new GetCloudExadataStorageServerIormPlanDbPlanItem();
            _resultValue.allocation = allocation;
            _resultValue.asmCluster = asmCluster;
            _resultValue.flashCacheLimit = flashCacheLimit;
            _resultValue.flashCacheMin = flashCacheMin;
            _resultValue.flashCacheSize = flashCacheSize;
            _resultValue.isFlashCacheOn = isFlashCacheOn;
            _resultValue.isFlashLogOn = isFlashLogOn;
            _resultValue.isPmemCacheOn = isPmemCacheOn;
            _resultValue.isPmemLogOn = isPmemLogOn;
            _resultValue.level = level;
            _resultValue.name = name;
            _resultValue.pmemCacheLimit = pmemCacheLimit;
            _resultValue.pmemCacheMin = pmemCacheMin;
            _resultValue.pmemCacheSize = pmemCacheSize;
            _resultValue.role = role;
            _resultValue.share = share;
            _resultValue.type = type;
            return _resultValue;
        }
    }
}
