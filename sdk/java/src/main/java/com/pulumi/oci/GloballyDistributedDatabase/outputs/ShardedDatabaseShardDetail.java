// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.oci.GloballyDistributedDatabase.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.oci.GloballyDistributedDatabase.outputs.ShardedDatabaseShardDetailEncryptionKeyDetails;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.String;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class ShardedDatabaseShardDetail {
    /**
     * @return Admin password for shard database.
     * 
     */
    private String adminPassword;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the cloud Autonomous Exadata VM Cluster.
     * 
     */
    private String cloudAutonomousVmClusterId;
    /**
     * @return The compute count for the shard database. It has to be in multiples of 2.
     * 
     */
    private Double computeCount;
    /**
     * @return Identifier of the underlying container database.
     * 
     */
    private @Nullable String containerDatabaseId;
    /**
     * @return Identifier of the underlying container database parent.
     * 
     */
    private @Nullable String containerDatabaseParentId;
    /**
     * @return The data disk group size to be allocated in GBs for the shard database.
     * 
     */
    private Double dataStorageSizeInGbs;
    /**
     * @return Details of encryption key to be used to encrypt data for shards and catalog for sharded database. For system-defined sharding type, all shards have to use same encryptionKeyDetails. For system-defined sharding, if encryptionKeyDetails are not specified for catalog, then Oracle managed key will be used for catalog. For user-defined sharding type, if encryptionKeyDetails are not provided for any shard or catalog, then Oracle managed key will be used for such shard or catalog. For system-defined or user-defined sharding type, if the shard or catalog has a peer in region other than primary shard or catalog region, then make sure to provide virtual vault for such shard or catalog, which is also replicated to peer region (the region where peer or standby shard or catalog exists).
     * 
     */
    private @Nullable ShardedDatabaseShardDetailEncryptionKeyDetails encryptionKeyDetails;
    /**
     * @return Determines the auto-scaling mode for the shard database.
     * 
     */
    private Boolean isAutoScalingEnabled;
    /**
     * @return Additional metadata related to shard&#39;s underlying supporting resource.
     * 
     */
    private @Nullable Map<String,String> metadata;
    /**
     * @return Name of the shard.
     * 
     */
    private @Nullable String name;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the peer cloud Autonomous Exadata VM Cluster.
     * 
     */
    private @Nullable String peerCloudAutonomousVmClusterId;
    /**
     * @return Name of the shard-group to which the shard belongs.
     * 
     */
    private @Nullable String shardGroup;
    /**
     * @return The shard space name for the shard database. Shard space for existing shard cannot be changed, once shard is created. Shard space name shall be used while creation of new shards. For User defined sharding, every shard must have a unique shard space name. For system defined sharding, shard space name is not required.
     * 
     */
    private @Nullable String shardSpace;
    /**
     * @return Status of shard or catalog or gsm for the sharded database.
     * 
     */
    private @Nullable String status;
    /**
     * @return Identifier of the underlying supporting resource.
     * 
     */
    private @Nullable String supportingResourceId;
    /**
     * @return The time the the Sharded Database was created. An RFC3339 formatted datetime string
     * 
     */
    private @Nullable String timeCreated;
    /**
     * @return The time the ssl certificate associated with shard expires. An RFC3339 formatted datetime string
     * 
     */
    private @Nullable String timeSslCertificateExpires;
    /**
     * @return The time the Sharded Database was last updated. An RFC3339 formatted datetime string
     * 
     */
    private @Nullable String timeUpdated;

    private ShardedDatabaseShardDetail() {}
    /**
     * @return Admin password for shard database.
     * 
     */
    public String adminPassword() {
        return this.adminPassword;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the cloud Autonomous Exadata VM Cluster.
     * 
     */
    public String cloudAutonomousVmClusterId() {
        return this.cloudAutonomousVmClusterId;
    }
    /**
     * @return The compute count for the shard database. It has to be in multiples of 2.
     * 
     */
    public Double computeCount() {
        return this.computeCount;
    }
    /**
     * @return Identifier of the underlying container database.
     * 
     */
    public Optional<String> containerDatabaseId() {
        return Optional.ofNullable(this.containerDatabaseId);
    }
    /**
     * @return Identifier of the underlying container database parent.
     * 
     */
    public Optional<String> containerDatabaseParentId() {
        return Optional.ofNullable(this.containerDatabaseParentId);
    }
    /**
     * @return The data disk group size to be allocated in GBs for the shard database.
     * 
     */
    public Double dataStorageSizeInGbs() {
        return this.dataStorageSizeInGbs;
    }
    /**
     * @return Details of encryption key to be used to encrypt data for shards and catalog for sharded database. For system-defined sharding type, all shards have to use same encryptionKeyDetails. For system-defined sharding, if encryptionKeyDetails are not specified for catalog, then Oracle managed key will be used for catalog. For user-defined sharding type, if encryptionKeyDetails are not provided for any shard or catalog, then Oracle managed key will be used for such shard or catalog. For system-defined or user-defined sharding type, if the shard or catalog has a peer in region other than primary shard or catalog region, then make sure to provide virtual vault for such shard or catalog, which is also replicated to peer region (the region where peer or standby shard or catalog exists).
     * 
     */
    public Optional<ShardedDatabaseShardDetailEncryptionKeyDetails> encryptionKeyDetails() {
        return Optional.ofNullable(this.encryptionKeyDetails);
    }
    /**
     * @return Determines the auto-scaling mode for the shard database.
     * 
     */
    public Boolean isAutoScalingEnabled() {
        return this.isAutoScalingEnabled;
    }
    /**
     * @return Additional metadata related to shard&#39;s underlying supporting resource.
     * 
     */
    public Map<String,String> metadata() {
        return this.metadata == null ? Map.of() : this.metadata;
    }
    /**
     * @return Name of the shard.
     * 
     */
    public Optional<String> name() {
        return Optional.ofNullable(this.name);
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the peer cloud Autonomous Exadata VM Cluster.
     * 
     */
    public Optional<String> peerCloudAutonomousVmClusterId() {
        return Optional.ofNullable(this.peerCloudAutonomousVmClusterId);
    }
    /**
     * @return Name of the shard-group to which the shard belongs.
     * 
     */
    public Optional<String> shardGroup() {
        return Optional.ofNullable(this.shardGroup);
    }
    /**
     * @return The shard space name for the shard database. Shard space for existing shard cannot be changed, once shard is created. Shard space name shall be used while creation of new shards. For User defined sharding, every shard must have a unique shard space name. For system defined sharding, shard space name is not required.
     * 
     */
    public Optional<String> shardSpace() {
        return Optional.ofNullable(this.shardSpace);
    }
    /**
     * @return Status of shard or catalog or gsm for the sharded database.
     * 
     */
    public Optional<String> status() {
        return Optional.ofNullable(this.status);
    }
    /**
     * @return Identifier of the underlying supporting resource.
     * 
     */
    public Optional<String> supportingResourceId() {
        return Optional.ofNullable(this.supportingResourceId);
    }
    /**
     * @return The time the the Sharded Database was created. An RFC3339 formatted datetime string
     * 
     */
    public Optional<String> timeCreated() {
        return Optional.ofNullable(this.timeCreated);
    }
    /**
     * @return The time the ssl certificate associated with shard expires. An RFC3339 formatted datetime string
     * 
     */
    public Optional<String> timeSslCertificateExpires() {
        return Optional.ofNullable(this.timeSslCertificateExpires);
    }
    /**
     * @return The time the Sharded Database was last updated. An RFC3339 formatted datetime string
     * 
     */
    public Optional<String> timeUpdated() {
        return Optional.ofNullable(this.timeUpdated);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(ShardedDatabaseShardDetail defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String adminPassword;
        private String cloudAutonomousVmClusterId;
        private Double computeCount;
        private @Nullable String containerDatabaseId;
        private @Nullable String containerDatabaseParentId;
        private Double dataStorageSizeInGbs;
        private @Nullable ShardedDatabaseShardDetailEncryptionKeyDetails encryptionKeyDetails;
        private Boolean isAutoScalingEnabled;
        private @Nullable Map<String,String> metadata;
        private @Nullable String name;
        private @Nullable String peerCloudAutonomousVmClusterId;
        private @Nullable String shardGroup;
        private @Nullable String shardSpace;
        private @Nullable String status;
        private @Nullable String supportingResourceId;
        private @Nullable String timeCreated;
        private @Nullable String timeSslCertificateExpires;
        private @Nullable String timeUpdated;
        public Builder() {}
        public Builder(ShardedDatabaseShardDetail defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.adminPassword = defaults.adminPassword;
    	      this.cloudAutonomousVmClusterId = defaults.cloudAutonomousVmClusterId;
    	      this.computeCount = defaults.computeCount;
    	      this.containerDatabaseId = defaults.containerDatabaseId;
    	      this.containerDatabaseParentId = defaults.containerDatabaseParentId;
    	      this.dataStorageSizeInGbs = defaults.dataStorageSizeInGbs;
    	      this.encryptionKeyDetails = defaults.encryptionKeyDetails;
    	      this.isAutoScalingEnabled = defaults.isAutoScalingEnabled;
    	      this.metadata = defaults.metadata;
    	      this.name = defaults.name;
    	      this.peerCloudAutonomousVmClusterId = defaults.peerCloudAutonomousVmClusterId;
    	      this.shardGroup = defaults.shardGroup;
    	      this.shardSpace = defaults.shardSpace;
    	      this.status = defaults.status;
    	      this.supportingResourceId = defaults.supportingResourceId;
    	      this.timeCreated = defaults.timeCreated;
    	      this.timeSslCertificateExpires = defaults.timeSslCertificateExpires;
    	      this.timeUpdated = defaults.timeUpdated;
        }

        @CustomType.Setter
        public Builder adminPassword(String adminPassword) {
            if (adminPassword == null) {
              throw new MissingRequiredPropertyException("ShardedDatabaseShardDetail", "adminPassword");
            }
            this.adminPassword = adminPassword;
            return this;
        }
        @CustomType.Setter
        public Builder cloudAutonomousVmClusterId(String cloudAutonomousVmClusterId) {
            if (cloudAutonomousVmClusterId == null) {
              throw new MissingRequiredPropertyException("ShardedDatabaseShardDetail", "cloudAutonomousVmClusterId");
            }
            this.cloudAutonomousVmClusterId = cloudAutonomousVmClusterId;
            return this;
        }
        @CustomType.Setter
        public Builder computeCount(Double computeCount) {
            if (computeCount == null) {
              throw new MissingRequiredPropertyException("ShardedDatabaseShardDetail", "computeCount");
            }
            this.computeCount = computeCount;
            return this;
        }
        @CustomType.Setter
        public Builder containerDatabaseId(@Nullable String containerDatabaseId) {

            this.containerDatabaseId = containerDatabaseId;
            return this;
        }
        @CustomType.Setter
        public Builder containerDatabaseParentId(@Nullable String containerDatabaseParentId) {

            this.containerDatabaseParentId = containerDatabaseParentId;
            return this;
        }
        @CustomType.Setter
        public Builder dataStorageSizeInGbs(Double dataStorageSizeInGbs) {
            if (dataStorageSizeInGbs == null) {
              throw new MissingRequiredPropertyException("ShardedDatabaseShardDetail", "dataStorageSizeInGbs");
            }
            this.dataStorageSizeInGbs = dataStorageSizeInGbs;
            return this;
        }
        @CustomType.Setter
        public Builder encryptionKeyDetails(@Nullable ShardedDatabaseShardDetailEncryptionKeyDetails encryptionKeyDetails) {

            this.encryptionKeyDetails = encryptionKeyDetails;
            return this;
        }
        @CustomType.Setter
        public Builder isAutoScalingEnabled(Boolean isAutoScalingEnabled) {
            if (isAutoScalingEnabled == null) {
              throw new MissingRequiredPropertyException("ShardedDatabaseShardDetail", "isAutoScalingEnabled");
            }
            this.isAutoScalingEnabled = isAutoScalingEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder metadata(@Nullable Map<String,String> metadata) {

            this.metadata = metadata;
            return this;
        }
        @CustomType.Setter
        public Builder name(@Nullable String name) {

            this.name = name;
            return this;
        }
        @CustomType.Setter
        public Builder peerCloudAutonomousVmClusterId(@Nullable String peerCloudAutonomousVmClusterId) {

            this.peerCloudAutonomousVmClusterId = peerCloudAutonomousVmClusterId;
            return this;
        }
        @CustomType.Setter
        public Builder shardGroup(@Nullable String shardGroup) {

            this.shardGroup = shardGroup;
            return this;
        }
        @CustomType.Setter
        public Builder shardSpace(@Nullable String shardSpace) {

            this.shardSpace = shardSpace;
            return this;
        }
        @CustomType.Setter
        public Builder status(@Nullable String status) {

            this.status = status;
            return this;
        }
        @CustomType.Setter
        public Builder supportingResourceId(@Nullable String supportingResourceId) {

            this.supportingResourceId = supportingResourceId;
            return this;
        }
        @CustomType.Setter
        public Builder timeCreated(@Nullable String timeCreated) {

            this.timeCreated = timeCreated;
            return this;
        }
        @CustomType.Setter
        public Builder timeSslCertificateExpires(@Nullable String timeSslCertificateExpires) {

            this.timeSslCertificateExpires = timeSslCertificateExpires;
            return this;
        }
        @CustomType.Setter
        public Builder timeUpdated(@Nullable String timeUpdated) {

            this.timeUpdated = timeUpdated;
            return this;
        }
        public ShardedDatabaseShardDetail build() {
            final var _resultValue = new ShardedDatabaseShardDetail();
            _resultValue.adminPassword = adminPassword;
            _resultValue.cloudAutonomousVmClusterId = cloudAutonomousVmClusterId;
            _resultValue.computeCount = computeCount;
            _resultValue.containerDatabaseId = containerDatabaseId;
            _resultValue.containerDatabaseParentId = containerDatabaseParentId;
            _resultValue.dataStorageSizeInGbs = dataStorageSizeInGbs;
            _resultValue.encryptionKeyDetails = encryptionKeyDetails;
            _resultValue.isAutoScalingEnabled = isAutoScalingEnabled;
            _resultValue.metadata = metadata;
            _resultValue.name = name;
            _resultValue.peerCloudAutonomousVmClusterId = peerCloudAutonomousVmClusterId;
            _resultValue.shardGroup = shardGroup;
            _resultValue.shardSpace = shardSpace;
            _resultValue.status = status;
            _resultValue.supportingResourceId = supportingResourceId;
            _resultValue.timeCreated = timeCreated;
            _resultValue.timeSslCertificateExpires = timeSslCertificateExpires;
            _resultValue.timeUpdated = timeUpdated;
            return _resultValue;
        }
    }
}
