// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.oci.GoldenGate.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.oci.GoldenGate.outputs.GetConnectionAdditionalAttribute;
import com.pulumi.oci.GoldenGate.outputs.GetConnectionBootstrapServer;
import com.pulumi.oci.GoldenGate.outputs.GetConnectionCatalog;
import com.pulumi.oci.GoldenGate.outputs.GetConnectionIngressIp;
import com.pulumi.oci.GoldenGate.outputs.GetConnectionLock;
import com.pulumi.oci.GoldenGate.outputs.GetConnectionStorage;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;

@CustomType
public final class GetConnectionResult {
    /**
     * @return Access key ID to access the Amazon S3 bucket.
     * 
     */
    private String accessKeyId;
    private String accountKey;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the account key is stored.
     * 
     */
    private String accountKeySecretId;
    /**
     * @return Sets the Azure storage account name.
     * 
     */
    private String accountName;
    /**
     * @return An array of name-value pair attribute entries. Used as additional parameters in connection string.
     * 
     */
    private List<GetConnectionAdditionalAttribute> additionalAttributes;
    /**
     * @return Authentication mode. It can be provided at creation of Oracle Autonomous Database Serverless connections, when a databaseId is provided. The default value is MTLS.
     * 
     */
    private String authenticationMode;
    /**
     * @return Used authentication mechanism to be provided for the following connection types:
     * * AZURE_DATA_LAKE_STORAGE, ELASTICSEARCH, KAFKA_SCHEMA_REGISTRY, REDIS, SNOWFLAKE
     * * JAVA_MESSAGE_SERVICE - If not provided, default is NONE. Optional until 2024-06-27, in the release after it will be made required.
     * * DATABRICKS - Required fields by authentication types:
     * * PERSONAL_ACCESS_TOKEN: username is always &#39;token&#39;, user must enter password
     * * OAUTH_M2M: user must enter clientId and clientSecret
     * 
     */
    private String authenticationType;
    /**
     * @return The endpoint used for authentication with Microsoft Entra ID (formerly Azure Active Directory). Default value: https://login.microsoftonline.com When connecting to a non-public Azure Cloud, the endpoint must be provided, eg:
     * * Azure China: https://login.chinacloudapi.cn/
     * * Azure US Government: https://login.microsoftonline.us/
     * 
     */
    private String azureAuthorityHost;
    /**
     * @return Azure tenant ID of the application. This property is required when &#39;authenticationType&#39; is set to &#39;AZURE_ACTIVE_DIRECTORY&#39;. e.g.: 14593954-d337-4a61-a364-9f758c64f97f
     * 
     */
    private String azureTenantId;
    /**
     * @return Kafka bootstrap. Equivalent of bootstrap.servers configuration property in Kafka: list of KafkaBootstrapServer objects specified by host/port. Used for establishing the initial connection to the Kafka cluster. Example: `&#34;server1.example.com:9092,server2.example.com:9092&#34;`
     * 
     */
    private List<GetConnectionBootstrapServer> bootstrapServers;
    /**
     * @return Represents the catalog of given type used in an Iceberg connection.
     * 
     */
    private List<GetConnectionCatalog> catalogs;
    /**
     * @return Azure client ID of the application. This property is required when &#39;authenticationType&#39; is set to &#39;AZURE_ACTIVE_DIRECTORY&#39;. e.g.: 06ecaabf-8b80-4ec8-a0ec-20cbf463703d
     * 
     */
    private String clientId;
    private String clientSecret;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the client secret is stored. Note: When provided, &#39;clientSecret&#39; field must not be provided.
     * 
     */
    private String clientSecretSecretId;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment being referenced.
     * 
     */
    private String compartmentId;
    /**
     * @return The of Java class implementing javax.jms.ConnectionFactory interface supplied by the Java Message Service provider. e.g.: &#39;com.stc.jmsjca.core.JConnectionFactoryXA&#39;
     * 
     */
    private String connectionFactory;
    private String connectionId;
    /**
     * @return * ORACLE: Connect descriptor or Easy Connect Naming method used to connect to a database.
     * * MONGODB: MongoDB connection string. e.g.: &#39;mongodb://mongodb0.example.com:27017/recordsrecords&#39;
     * * AZURE_SYNAPSE_ANALYTICS: JDBC connection string. e.g.: &#39;jdbc:sqlserver://&lt;synapse-workspace&gt;.sql.azuresynapse.net:1433;database=&lt;db-name&gt;;encrypt=true;trustServerCertificate=false;hostNameInCertificate=*.sql.azuresynapse.net;loginTimeout=300;&#39;
     * 
     */
    private String connectionString;
    /**
     * @return The connection type.
     * 
     */
    private String connectionType;
    /**
     * @return * JAVA_MESSAGE_SERVICE: Connection URL of the Java Message Service, specifying the protocol, host, and port. e.g.: &#39;mq://myjms.host.domain:7676&#39;
     * * SNOWFLAKE: JDBC connection URL. e.g.: &#39;jdbc:snowflake://&lt;account_name&gt;.snowflakecomputing.com/?warehouse=&lt;warehouse-name&gt;&amp;db=&lt;db-name&gt;&#39;
     * * AMAZON_REDSHIFT: Connection URL. e.g.: &#39;jdbc:redshift://aws-redshift-instance.aaaaaaaaaaaa.us-east-2.redshift.amazonaws.com:5439/mydb&#39;
     * * DATABRICKS: Connection URL. e.g.: &#39;jdbc:databricks://adb-33934.4.azuredatabricks.net:443/default;transportMode=http;ssl=1;httpPath=sql/protocolv1/o/3393########44/0##3-7-hlrb&#39;
     * 
     */
    private String connectionUrl;
    /**
     * @return The base64 encoded content of the consumer.properties file.
     * 
     */
    private String consumerProperties;
    /**
     * @return The base64 encoded content of the Hadoop Distributed File System configuration file (core-site.xml). It is not included in GET responses if the `view=COMPACT` query parameter is specified.
     * 
     */
    private String coreSiteXml;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database being referenced.
     * 
     */
    private String databaseId;
    /**
     * @return The name of the database.
     * 
     */
    private String databaseName;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database system being referenced.
     * 
     */
    private String dbSystemId;
    /**
     * @return Tags defined for this resource. Each key is predefined and scoped to a namespace.  Example: `{&#34;foo-namespace.bar-key&#34;: &#34;value&#34;}`
     * 
     */
    private Map<String,String> definedTags;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the deployment being referenced.
     * 
     */
    private String deploymentId;
    /**
     * @return Metadata about this specific object.
     * 
     */
    private String description;
    /**
     * @return An object&#39;s Display Name.
     * 
     */
    private String displayName;
    /**
     * @return Indicates that sensitive attributes are provided via Secrets.
     * 
     */
    private Boolean doesUseSecretIds;
    /**
     * @return The Azure Blob Storage endpoint where Iceberg data is stored. e.g.: &#39;https://my-azure-storage-account.blob.core.windows.net&#39;
     * 
     */
    private String endpoint;
    /**
     * @return Fingerprint required by TLS security protocol. Eg.: &#39;6152b2dfbff200f973c5074a5b91d06ab3b472c07c09a1ea57bb7fd406cdce9c&#39;
     * 
     */
    private String fingerprint;
    /**
     * @return A simple key-value pair that is applied without any predefined name, type, or scope. Exists for cross-compatibility only.  Example: `{&#34;bar-key&#34;: &#34;value&#34;}`
     * 
     */
    private Map<String,String> freeformTags;
    /**
     * @return The name or address of a host.
     * In case of Generic connection type it represents the Host and port separated by colon. Example: `&#34;server.example.com:1234&#34;`
     * For multiple hosts, provide a comma separated list. Example: `&#34;server1.example.com:1000,server1.example.com:2000&#34;`
     * 
     */
    private String host;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the connection being referenced.
     * 
     */
    private String id;
    /**
     * @return List of ingress IP addresses from where the GoldenGate deployment connects to this connection&#39;s privateIp.  Customers may optionally set up ingress security rules to restrict traffic from these IP addresses.
     * 
     */
    private List<GetConnectionIngressIp> ingressIps;
    private Boolean isLockOverride;
    /**
     * @return The Connection Factory can be looked up using this name. e.g.: &#39;ConnectionFactory&#39;
     * 
     */
    private String jndiConnectionFactory;
    /**
     * @return The implementation of javax.naming.spi.InitialContextFactory interface that the client uses to obtain initial naming context. e.g.: &#39;org.apache.activemq.jndi.ActiveMQInitialContextFactory&#39;
     * 
     */
    private String jndiInitialContextFactory;
    /**
     * @return The URL that Java Message Service will use to contact the JNDI provider. e.g.: &#39;tcp://myjms.host.domain:61616?jms.prefetchPolicy.all=1000&#39;
     * 
     */
    private String jndiProviderUrl;
    private String jndiSecurityCredentials;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the security credentials are stored associated to the principal. Note: When provided, &#39;jndiSecurityCredentials&#39; field must not be provided.
     * 
     */
    private String jndiSecurityCredentialsSecretId;
    /**
     * @return Specifies the identity of the principal (user) to be authenticated. e.g.: &#39;admin2&#39;
     * 
     */
    private String jndiSecurityPrincipal;
    /**
     * @return Refers to the customer&#39;s master key OCID.  If provided, it references a key to manage secrets. Customers must add policies to permit GoldenGate to use this key.
     * 
     */
    private String keyId;
    private String keyStore;
    private String keyStorePassword;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the kafka Ssl KeyStore password is stored. Note: When provided, &#39;keyStorePassword&#39; field must not be provided.
     * 
     */
    private String keyStorePasswordSecretId;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the content of the KeyStore file is stored. Note: When provided, &#39;keyStore&#39; field must not be provided.
     * 
     */
    private String keyStoreSecretId;
    /**
     * @return Describes the object&#39;s current state in detail. For example, it can be used to provide actionable information for a resource in a Failed state.
     * 
     */
    private String lifecycleDetails;
    /**
     * @return Locks associated with this resource.
     * 
     */
    private List<GetConnectionLock> locks;
    /**
     * @return An array of Network Security Group OCIDs used to define network access for either Deployments or Connections.
     * 
     */
    private List<String> nsgIds;
    private String password;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the password is stored. The password Oracle GoldenGate uses to connect the associated system of the given technology. It must conform to the specific security requirements including length, case sensitivity, and so on. Note: When provided, &#39;password&#39; field must not be provided.
     * 
     */
    private String passwordSecretId;
    /**
     * @return The port of an endpoint usually specified for a connection.
     * 
     */
    private Integer port;
    /**
     * @return Deprecated: this field will be removed in future versions. Either specify the private IP in the connectionString or host  field, or make sure the host name is resolvable in the target VCN.
     * The private IP address of the connection&#39;s endpoint in the customer&#39;s VCN, typically a database endpoint or a big data endpoint (e.g. Kafka bootstrap server). In case the privateIp is provided, the subnetId must also be provided. In case the privateIp (and the subnetId) is not provided it is assumed the datasource is publicly accessible. In case the connection is accessible only privately, the lack of privateIp will result in not being able to access the connection.
     * 
     */
    private String privateIp;
    private String privateKeyFile;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret that stores the content of the private key file (PEM file) corresponding to the API key of the fingerprint. See documentation: https://docs.oracle.com/en-us/iaas/Content/Identity/Tasks/managingcredentials.htm Note: When provided, &#39;privateKeyFile&#39; field must not be provided.
     * 
     */
    private String privateKeyFileSecretId;
    private String privateKeyPassphrase;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret that stores the password for the private key file. Note: When provided, &#39;privateKeyPassphrase&#39; field must not be provided.
     * 
     */
    private String privateKeyPassphraseSecretId;
    /**
     * @return The base64 encoded content of the producer.properties file.
     * 
     */
    private String producerProperties;
    /**
     * @return The fingerprint of the API Key of the user specified by the userId. See documentation: https://docs.oracle.com/en-us/iaas/Content/Identity/Tasks/managingcredentials.htm
     * 
     */
    private String publicKeyFingerprint;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Redis cluster.
     * 
     */
    private String redisClusterId;
    /**
     * @return The AMAZON region where the S3 bucket is hosted. e.g.: &#39;us-east-2&#39;
     * 
     */
    private String region;
    /**
     * @return Controls the network traffic direction to the target: SHARED_SERVICE_ENDPOINT: Traffic flows through the Goldengate Service&#39;s network to public hosts. Cannot be used for private targets.  SHARED_DEPLOYMENT_ENDPOINT: Network traffic flows from the assigned deployment&#39;s private endpoint through the deployment&#39;s subnet. DEDICATED_ENDPOINT: A dedicated private endpoint is created in the target VCN subnet for the connection. The subnetId is required when DEDICATED_ENDPOINT networking is selected.
     * 
     */
    private String routingMethod;
    private String sasToken;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the sas token is stored. Note: When provided, &#39;sasToken&#39; field must not be provided.
     * 
     */
    private String sasTokenSecretId;
    private String secretAccessKey;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the Secret Access Key is stored.
     * 
     */
    private String secretAccessKeySecretId;
    /**
     * @return Security Protocol to be provided for the following connection types:
     * * DB2, ELASTICSEARCH, KAFKA, MICROSOFT_SQLSERVER, MYSQL, POSTGRESQL, REDIS
     * * JAVA_MESSAGE_SERVICE - If not provided, default is PLAIN. Optional until 2024-06-27, in the release after it will be made required.
     * 
     */
    private String securityProtocol;
    /**
     * @return Comma separated list of server addresses, specified as host:port entries, where :port is optional. Example: `&#34;server1.example.com:4000,server2.example.com:4000&#34;`
     * If port is not specified, a default value is set, in case of ELASTICSEARCH: 9200, for REDIS 6379.
     * 
     */
    private String servers;
    private String serviceAccountKeyFile;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the content of the service account key file is stored, which contains the credentials required to use Google Cloud Storage.
     * 
     */
    private String serviceAccountKeyFileSecretId;
    /**
     * @return The mode of the database connection session to be established by the data client. &#39;REDIRECT&#39; - for a RAC database, &#39;DIRECT&#39; - for a non-RAC database. Connection to a RAC database involves a redirection received from the SCAN listeners to the database node to connect to. By default the mode would be DIRECT.
     * 
     */
    private String sessionMode;
    /**
     * @return If set to true, Java Naming and Directory Interface (JNDI) properties should be provided.
     * 
     */
    private Boolean shouldUseJndi;
    /**
     * @return Specifies that the user intends to authenticate to the instance using a resource principal. Default: false
     * 
     */
    private Boolean shouldUseResourcePrincipal;
    /**
     * @return If set to true, the driver validates the certificate that is sent by the database server.
     * 
     */
    private Boolean shouldValidateServerCertificate;
    /**
     * @return Database Certificate - The base64 encoded content of a .pem or .crt file. containing the server public key (for 1-way SSL). The supported file formats are .pem and .crt. In case of MYSQL and POSTGRESQL connections it is not included in GET responses if the `view=COMPACT` query parameter is specified.
     * 
     */
    private String sslCa;
    /**
     * @return Client Certificate - The base64 encoded content of a .pem or .crt file containing the client public key (for 2-way SSL). It is not included in GET responses if the `view=COMPACT` query parameter is specified.
     * 
     */
    private String sslCert;
    private String sslClientKeystash;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the keystash file is stored,  which contains the encrypted password to the key database file. This property is not supported for IBM Db2 for i, as client TLS mode is not available.
     * 
     */
    private String sslClientKeystashSecretId;
    private String sslClientKeystoredb;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the keystore file stored,  which created at the client containing the server certificate / CA root certificate. This property is not supported for IBM Db2 for i, as client TLS mode is not available.
     * 
     */
    private String sslClientKeystoredbSecretId;
    /**
     * @return The base64 encoded list of certificates revoked by the trusted certificate authorities (Trusted CA). Note: This is an optional property and only applicable if TLS/MTLS option is selected. It is not included in GET responses if the `view=COMPACT` query parameter is specified.
     * 
     */
    private String sslCrl;
    private String sslKey;
    private String sslKeyPassword;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the password is stored for the cert inside of the Keystore. In case it differs from the KeyStore password, it should be provided. Note: When provided, &#39;sslKeyPassword&#39; field must not be provided.
     * 
     */
    private String sslKeyPasswordSecretId;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret that stores the Client Key
     * * The content of a .pem or .crt file containing the client private key (for 2-way SSL). Note: When provided, &#39;sslKey&#39; field must not be provided.
     * 
     */
    private String sslKeySecretId;
    /**
     * @return SSL mode to be provided for the following connection types: MYSQL, POSTGRESQL.
     * 
     */
    private String sslMode;
    /**
     * @return The base64 encoded file which contains the self-signed server certificate / Certificate Authority (CA) certificate. It is not included in GET responses if the `view=COMPACT` query parameter is specified.
     * 
     */
    private String sslServerCertificate;
    /**
     * @return Possible lifecycle states for connection.
     * 
     */
    private String state;
    /**
     * @return Optional. External storage credential name to access files on object storage such as ADLS Gen2, S3 or GCS.
     * 
     */
    private String storageCredentialName;
    /**
     * @return Represents the storage of given type used in an Iceberg connection.
     * 
     */
    private List<GetConnectionStorage> storages;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the stream pool being referenced.
     * 
     */
    private String streamPoolId;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the target subnet of the dedicated connection.
     * 
     */
    private String subnetId;
    /**
     * @return The system tags associated with this resource, if any. The system tags are set by Oracle Cloud Infrastructure services. Each key is predefined and scoped to namespaces.  For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{orcl-cloud: {free-tier-retain: true}}`
     * 
     */
    private Map<String,String> systemTags;
    /**
     * @return The technology type.
     * 
     */
    private String technologyType;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the related Oracle Cloud Infrastructure tenancy.
     * 
     */
    private String tenancyId;
    /**
     * @return Azure tenant ID of the application. e.g.: 14593954-d337-4a61-a364-9f758c64f97f
     * 
     */
    private String tenantId;
    /**
     * @return The time the resource was created. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
     * 
     */
    private String timeCreated;
    /**
     * @return The time the resource was last updated. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
     * 
     */
    private String timeUpdated;
    /**
     * @return Database Certificate - The base64 encoded content of a .pem file, containing the server public key (for 1 and 2-way SSL). It is not included in GET responses if the `view=COMPACT` query parameter is specified.
     * 
     */
    private String tlsCaFile;
    private String tlsCertificateKeyFile;
    private String tlsCertificateKeyFilePassword;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret that stores the password of the tls certificate key file. Note: When provided, &#39;tlsCertificateKeyFilePassword&#39; field must not be provided.
     * 
     */
    private String tlsCertificateKeyFilePasswordSecretId;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret that stores the certificate key file of the mtls connection.
     * * The content of a .pem file containing the client private key (for 2-way SSL). Note: When provided, &#39;tlsCertificateKeyFile&#39; field must not be provided.
     * 
     */
    private String tlsCertificateKeyFileSecretId;
    private Boolean triggerRefresh;
    private String trustStore;
    private String trustStorePassword;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the kafka Ssl TrustStore password is stored. Note: When provided, &#39;trustStorePassword&#39; field must not be provided.
     * 
     */
    private String trustStorePasswordSecretId;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the content of the TrustStore file is stored. Note: When provided, &#39;trustStore&#39; field must not be provided.
     * 
     */
    private String trustStoreSecretId;
    /**
     * @return Kafka Schema Registry URL. e.g.: &#39;https://server1.us.oracle.com:8081&#39;
     * 
     */
    private String url;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure user who will access the Oracle NoSQL database. The user must have write access to the table they want to connect to. If the user is not provided, backend will default to the user who is calling the API endpoint.
     * 
     */
    private String userId;
    /**
     * @return The username Oracle GoldenGate uses to connect the associated system of the given technology. This username must already exist and be available by the system/application to be connected to and must conform to the case sensitivty requirments defined in it.
     * 
     */
    private String username;
    /**
     * @return Refers to the customer&#39;s vault OCID.  If provided, it references a vault where GoldenGate can manage secrets. Customers must add policies to permit GoldenGate to manage secrets contained within this vault.
     * 
     */
    private String vaultId;
    private String wallet;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the wallet file is stored.  The wallet contents Oracle GoldenGate uses to make connections to a database. Note: When provided, &#39;wallet&#39; field must not be provided.
     * 
     */
    private String walletSecretId;

    private GetConnectionResult() {}
    /**
     * @return Access key ID to access the Amazon S3 bucket.
     * 
     */
    public String accessKeyId() {
        return this.accessKeyId;
    }
    public String accountKey() {
        return this.accountKey;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the account key is stored.
     * 
     */
    public String accountKeySecretId() {
        return this.accountKeySecretId;
    }
    /**
     * @return Sets the Azure storage account name.
     * 
     */
    public String accountName() {
        return this.accountName;
    }
    /**
     * @return An array of name-value pair attribute entries. Used as additional parameters in connection string.
     * 
     */
    public List<GetConnectionAdditionalAttribute> additionalAttributes() {
        return this.additionalAttributes;
    }
    /**
     * @return Authentication mode. It can be provided at creation of Oracle Autonomous Database Serverless connections, when a databaseId is provided. The default value is MTLS.
     * 
     */
    public String authenticationMode() {
        return this.authenticationMode;
    }
    /**
     * @return Used authentication mechanism to be provided for the following connection types:
     * * AZURE_DATA_LAKE_STORAGE, ELASTICSEARCH, KAFKA_SCHEMA_REGISTRY, REDIS, SNOWFLAKE
     * * JAVA_MESSAGE_SERVICE - If not provided, default is NONE. Optional until 2024-06-27, in the release after it will be made required.
     * * DATABRICKS - Required fields by authentication types:
     * * PERSONAL_ACCESS_TOKEN: username is always &#39;token&#39;, user must enter password
     * * OAUTH_M2M: user must enter clientId and clientSecret
     * 
     */
    public String authenticationType() {
        return this.authenticationType;
    }
    /**
     * @return The endpoint used for authentication with Microsoft Entra ID (formerly Azure Active Directory). Default value: https://login.microsoftonline.com When connecting to a non-public Azure Cloud, the endpoint must be provided, eg:
     * * Azure China: https://login.chinacloudapi.cn/
     * * Azure US Government: https://login.microsoftonline.us/
     * 
     */
    public String azureAuthorityHost() {
        return this.azureAuthorityHost;
    }
    /**
     * @return Azure tenant ID of the application. This property is required when &#39;authenticationType&#39; is set to &#39;AZURE_ACTIVE_DIRECTORY&#39;. e.g.: 14593954-d337-4a61-a364-9f758c64f97f
     * 
     */
    public String azureTenantId() {
        return this.azureTenantId;
    }
    /**
     * @return Kafka bootstrap. Equivalent of bootstrap.servers configuration property in Kafka: list of KafkaBootstrapServer objects specified by host/port. Used for establishing the initial connection to the Kafka cluster. Example: `&#34;server1.example.com:9092,server2.example.com:9092&#34;`
     * 
     */
    public List<GetConnectionBootstrapServer> bootstrapServers() {
        return this.bootstrapServers;
    }
    /**
     * @return Represents the catalog of given type used in an Iceberg connection.
     * 
     */
    public List<GetConnectionCatalog> catalogs() {
        return this.catalogs;
    }
    /**
     * @return Azure client ID of the application. This property is required when &#39;authenticationType&#39; is set to &#39;AZURE_ACTIVE_DIRECTORY&#39;. e.g.: 06ecaabf-8b80-4ec8-a0ec-20cbf463703d
     * 
     */
    public String clientId() {
        return this.clientId;
    }
    public String clientSecret() {
        return this.clientSecret;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the client secret is stored. Note: When provided, &#39;clientSecret&#39; field must not be provided.
     * 
     */
    public String clientSecretSecretId() {
        return this.clientSecretSecretId;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment being referenced.
     * 
     */
    public String compartmentId() {
        return this.compartmentId;
    }
    /**
     * @return The of Java class implementing javax.jms.ConnectionFactory interface supplied by the Java Message Service provider. e.g.: &#39;com.stc.jmsjca.core.JConnectionFactoryXA&#39;
     * 
     */
    public String connectionFactory() {
        return this.connectionFactory;
    }
    public String connectionId() {
        return this.connectionId;
    }
    /**
     * @return * ORACLE: Connect descriptor or Easy Connect Naming method used to connect to a database.
     * * MONGODB: MongoDB connection string. e.g.: &#39;mongodb://mongodb0.example.com:27017/recordsrecords&#39;
     * * AZURE_SYNAPSE_ANALYTICS: JDBC connection string. e.g.: &#39;jdbc:sqlserver://&lt;synapse-workspace&gt;.sql.azuresynapse.net:1433;database=&lt;db-name&gt;;encrypt=true;trustServerCertificate=false;hostNameInCertificate=*.sql.azuresynapse.net;loginTimeout=300;&#39;
     * 
     */
    public String connectionString() {
        return this.connectionString;
    }
    /**
     * @return The connection type.
     * 
     */
    public String connectionType() {
        return this.connectionType;
    }
    /**
     * @return * JAVA_MESSAGE_SERVICE: Connection URL of the Java Message Service, specifying the protocol, host, and port. e.g.: &#39;mq://myjms.host.domain:7676&#39;
     * * SNOWFLAKE: JDBC connection URL. e.g.: &#39;jdbc:snowflake://&lt;account_name&gt;.snowflakecomputing.com/?warehouse=&lt;warehouse-name&gt;&amp;db=&lt;db-name&gt;&#39;
     * * AMAZON_REDSHIFT: Connection URL. e.g.: &#39;jdbc:redshift://aws-redshift-instance.aaaaaaaaaaaa.us-east-2.redshift.amazonaws.com:5439/mydb&#39;
     * * DATABRICKS: Connection URL. e.g.: &#39;jdbc:databricks://adb-33934.4.azuredatabricks.net:443/default;transportMode=http;ssl=1;httpPath=sql/protocolv1/o/3393########44/0##3-7-hlrb&#39;
     * 
     */
    public String connectionUrl() {
        return this.connectionUrl;
    }
    /**
     * @return The base64 encoded content of the consumer.properties file.
     * 
     */
    public String consumerProperties() {
        return this.consumerProperties;
    }
    /**
     * @return The base64 encoded content of the Hadoop Distributed File System configuration file (core-site.xml). It is not included in GET responses if the `view=COMPACT` query parameter is specified.
     * 
     */
    public String coreSiteXml() {
        return this.coreSiteXml;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database being referenced.
     * 
     */
    public String databaseId() {
        return this.databaseId;
    }
    /**
     * @return The name of the database.
     * 
     */
    public String databaseName() {
        return this.databaseName;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database system being referenced.
     * 
     */
    public String dbSystemId() {
        return this.dbSystemId;
    }
    /**
     * @return Tags defined for this resource. Each key is predefined and scoped to a namespace.  Example: `{&#34;foo-namespace.bar-key&#34;: &#34;value&#34;}`
     * 
     */
    public Map<String,String> definedTags() {
        return this.definedTags;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the deployment being referenced.
     * 
     */
    public String deploymentId() {
        return this.deploymentId;
    }
    /**
     * @return Metadata about this specific object.
     * 
     */
    public String description() {
        return this.description;
    }
    /**
     * @return An object&#39;s Display Name.
     * 
     */
    public String displayName() {
        return this.displayName;
    }
    /**
     * @return Indicates that sensitive attributes are provided via Secrets.
     * 
     */
    public Boolean doesUseSecretIds() {
        return this.doesUseSecretIds;
    }
    /**
     * @return The Azure Blob Storage endpoint where Iceberg data is stored. e.g.: &#39;https://my-azure-storage-account.blob.core.windows.net&#39;
     * 
     */
    public String endpoint() {
        return this.endpoint;
    }
    /**
     * @return Fingerprint required by TLS security protocol. Eg.: &#39;6152b2dfbff200f973c5074a5b91d06ab3b472c07c09a1ea57bb7fd406cdce9c&#39;
     * 
     */
    public String fingerprint() {
        return this.fingerprint;
    }
    /**
     * @return A simple key-value pair that is applied without any predefined name, type, or scope. Exists for cross-compatibility only.  Example: `{&#34;bar-key&#34;: &#34;value&#34;}`
     * 
     */
    public Map<String,String> freeformTags() {
        return this.freeformTags;
    }
    /**
     * @return The name or address of a host.
     * In case of Generic connection type it represents the Host and port separated by colon. Example: `&#34;server.example.com:1234&#34;`
     * For multiple hosts, provide a comma separated list. Example: `&#34;server1.example.com:1000,server1.example.com:2000&#34;`
     * 
     */
    public String host() {
        return this.host;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the connection being referenced.
     * 
     */
    public String id() {
        return this.id;
    }
    /**
     * @return List of ingress IP addresses from where the GoldenGate deployment connects to this connection&#39;s privateIp.  Customers may optionally set up ingress security rules to restrict traffic from these IP addresses.
     * 
     */
    public List<GetConnectionIngressIp> ingressIps() {
        return this.ingressIps;
    }
    public Boolean isLockOverride() {
        return this.isLockOverride;
    }
    /**
     * @return The Connection Factory can be looked up using this name. e.g.: &#39;ConnectionFactory&#39;
     * 
     */
    public String jndiConnectionFactory() {
        return this.jndiConnectionFactory;
    }
    /**
     * @return The implementation of javax.naming.spi.InitialContextFactory interface that the client uses to obtain initial naming context. e.g.: &#39;org.apache.activemq.jndi.ActiveMQInitialContextFactory&#39;
     * 
     */
    public String jndiInitialContextFactory() {
        return this.jndiInitialContextFactory;
    }
    /**
     * @return The URL that Java Message Service will use to contact the JNDI provider. e.g.: &#39;tcp://myjms.host.domain:61616?jms.prefetchPolicy.all=1000&#39;
     * 
     */
    public String jndiProviderUrl() {
        return this.jndiProviderUrl;
    }
    public String jndiSecurityCredentials() {
        return this.jndiSecurityCredentials;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the security credentials are stored associated to the principal. Note: When provided, &#39;jndiSecurityCredentials&#39; field must not be provided.
     * 
     */
    public String jndiSecurityCredentialsSecretId() {
        return this.jndiSecurityCredentialsSecretId;
    }
    /**
     * @return Specifies the identity of the principal (user) to be authenticated. e.g.: &#39;admin2&#39;
     * 
     */
    public String jndiSecurityPrincipal() {
        return this.jndiSecurityPrincipal;
    }
    /**
     * @return Refers to the customer&#39;s master key OCID.  If provided, it references a key to manage secrets. Customers must add policies to permit GoldenGate to use this key.
     * 
     */
    public String keyId() {
        return this.keyId;
    }
    public String keyStore() {
        return this.keyStore;
    }
    public String keyStorePassword() {
        return this.keyStorePassword;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the kafka Ssl KeyStore password is stored. Note: When provided, &#39;keyStorePassword&#39; field must not be provided.
     * 
     */
    public String keyStorePasswordSecretId() {
        return this.keyStorePasswordSecretId;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the content of the KeyStore file is stored. Note: When provided, &#39;keyStore&#39; field must not be provided.
     * 
     */
    public String keyStoreSecretId() {
        return this.keyStoreSecretId;
    }
    /**
     * @return Describes the object&#39;s current state in detail. For example, it can be used to provide actionable information for a resource in a Failed state.
     * 
     */
    public String lifecycleDetails() {
        return this.lifecycleDetails;
    }
    /**
     * @return Locks associated with this resource.
     * 
     */
    public List<GetConnectionLock> locks() {
        return this.locks;
    }
    /**
     * @return An array of Network Security Group OCIDs used to define network access for either Deployments or Connections.
     * 
     */
    public List<String> nsgIds() {
        return this.nsgIds;
    }
    public String password() {
        return this.password;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the password is stored. The password Oracle GoldenGate uses to connect the associated system of the given technology. It must conform to the specific security requirements including length, case sensitivity, and so on. Note: When provided, &#39;password&#39; field must not be provided.
     * 
     */
    public String passwordSecretId() {
        return this.passwordSecretId;
    }
    /**
     * @return The port of an endpoint usually specified for a connection.
     * 
     */
    public Integer port() {
        return this.port;
    }
    /**
     * @return Deprecated: this field will be removed in future versions. Either specify the private IP in the connectionString or host  field, or make sure the host name is resolvable in the target VCN.
     * The private IP address of the connection&#39;s endpoint in the customer&#39;s VCN, typically a database endpoint or a big data endpoint (e.g. Kafka bootstrap server). In case the privateIp is provided, the subnetId must also be provided. In case the privateIp (and the subnetId) is not provided it is assumed the datasource is publicly accessible. In case the connection is accessible only privately, the lack of privateIp will result in not being able to access the connection.
     * 
     */
    public String privateIp() {
        return this.privateIp;
    }
    public String privateKeyFile() {
        return this.privateKeyFile;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret that stores the content of the private key file (PEM file) corresponding to the API key of the fingerprint. See documentation: https://docs.oracle.com/en-us/iaas/Content/Identity/Tasks/managingcredentials.htm Note: When provided, &#39;privateKeyFile&#39; field must not be provided.
     * 
     */
    public String privateKeyFileSecretId() {
        return this.privateKeyFileSecretId;
    }
    public String privateKeyPassphrase() {
        return this.privateKeyPassphrase;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret that stores the password for the private key file. Note: When provided, &#39;privateKeyPassphrase&#39; field must not be provided.
     * 
     */
    public String privateKeyPassphraseSecretId() {
        return this.privateKeyPassphraseSecretId;
    }
    /**
     * @return The base64 encoded content of the producer.properties file.
     * 
     */
    public String producerProperties() {
        return this.producerProperties;
    }
    /**
     * @return The fingerprint of the API Key of the user specified by the userId. See documentation: https://docs.oracle.com/en-us/iaas/Content/Identity/Tasks/managingcredentials.htm
     * 
     */
    public String publicKeyFingerprint() {
        return this.publicKeyFingerprint;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Redis cluster.
     * 
     */
    public String redisClusterId() {
        return this.redisClusterId;
    }
    /**
     * @return The AMAZON region where the S3 bucket is hosted. e.g.: &#39;us-east-2&#39;
     * 
     */
    public String region() {
        return this.region;
    }
    /**
     * @return Controls the network traffic direction to the target: SHARED_SERVICE_ENDPOINT: Traffic flows through the Goldengate Service&#39;s network to public hosts. Cannot be used for private targets.  SHARED_DEPLOYMENT_ENDPOINT: Network traffic flows from the assigned deployment&#39;s private endpoint through the deployment&#39;s subnet. DEDICATED_ENDPOINT: A dedicated private endpoint is created in the target VCN subnet for the connection. The subnetId is required when DEDICATED_ENDPOINT networking is selected.
     * 
     */
    public String routingMethod() {
        return this.routingMethod;
    }
    public String sasToken() {
        return this.sasToken;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the sas token is stored. Note: When provided, &#39;sasToken&#39; field must not be provided.
     * 
     */
    public String sasTokenSecretId() {
        return this.sasTokenSecretId;
    }
    public String secretAccessKey() {
        return this.secretAccessKey;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the Secret Access Key is stored.
     * 
     */
    public String secretAccessKeySecretId() {
        return this.secretAccessKeySecretId;
    }
    /**
     * @return Security Protocol to be provided for the following connection types:
     * * DB2, ELASTICSEARCH, KAFKA, MICROSOFT_SQLSERVER, MYSQL, POSTGRESQL, REDIS
     * * JAVA_MESSAGE_SERVICE - If not provided, default is PLAIN. Optional until 2024-06-27, in the release after it will be made required.
     * 
     */
    public String securityProtocol() {
        return this.securityProtocol;
    }
    /**
     * @return Comma separated list of server addresses, specified as host:port entries, where :port is optional. Example: `&#34;server1.example.com:4000,server2.example.com:4000&#34;`
     * If port is not specified, a default value is set, in case of ELASTICSEARCH: 9200, for REDIS 6379.
     * 
     */
    public String servers() {
        return this.servers;
    }
    public String serviceAccountKeyFile() {
        return this.serviceAccountKeyFile;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the content of the service account key file is stored, which contains the credentials required to use Google Cloud Storage.
     * 
     */
    public String serviceAccountKeyFileSecretId() {
        return this.serviceAccountKeyFileSecretId;
    }
    /**
     * @return The mode of the database connection session to be established by the data client. &#39;REDIRECT&#39; - for a RAC database, &#39;DIRECT&#39; - for a non-RAC database. Connection to a RAC database involves a redirection received from the SCAN listeners to the database node to connect to. By default the mode would be DIRECT.
     * 
     */
    public String sessionMode() {
        return this.sessionMode;
    }
    /**
     * @return If set to true, Java Naming and Directory Interface (JNDI) properties should be provided.
     * 
     */
    public Boolean shouldUseJndi() {
        return this.shouldUseJndi;
    }
    /**
     * @return Specifies that the user intends to authenticate to the instance using a resource principal. Default: false
     * 
     */
    public Boolean shouldUseResourcePrincipal() {
        return this.shouldUseResourcePrincipal;
    }
    /**
     * @return If set to true, the driver validates the certificate that is sent by the database server.
     * 
     */
    public Boolean shouldValidateServerCertificate() {
        return this.shouldValidateServerCertificate;
    }
    /**
     * @return Database Certificate - The base64 encoded content of a .pem or .crt file. containing the server public key (for 1-way SSL). The supported file formats are .pem and .crt. In case of MYSQL and POSTGRESQL connections it is not included in GET responses if the `view=COMPACT` query parameter is specified.
     * 
     */
    public String sslCa() {
        return this.sslCa;
    }
    /**
     * @return Client Certificate - The base64 encoded content of a .pem or .crt file containing the client public key (for 2-way SSL). It is not included in GET responses if the `view=COMPACT` query parameter is specified.
     * 
     */
    public String sslCert() {
        return this.sslCert;
    }
    public String sslClientKeystash() {
        return this.sslClientKeystash;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the keystash file is stored,  which contains the encrypted password to the key database file. This property is not supported for IBM Db2 for i, as client TLS mode is not available.
     * 
     */
    public String sslClientKeystashSecretId() {
        return this.sslClientKeystashSecretId;
    }
    public String sslClientKeystoredb() {
        return this.sslClientKeystoredb;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the keystore file stored,  which created at the client containing the server certificate / CA root certificate. This property is not supported for IBM Db2 for i, as client TLS mode is not available.
     * 
     */
    public String sslClientKeystoredbSecretId() {
        return this.sslClientKeystoredbSecretId;
    }
    /**
     * @return The base64 encoded list of certificates revoked by the trusted certificate authorities (Trusted CA). Note: This is an optional property and only applicable if TLS/MTLS option is selected. It is not included in GET responses if the `view=COMPACT` query parameter is specified.
     * 
     */
    public String sslCrl() {
        return this.sslCrl;
    }
    public String sslKey() {
        return this.sslKey;
    }
    public String sslKeyPassword() {
        return this.sslKeyPassword;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the password is stored for the cert inside of the Keystore. In case it differs from the KeyStore password, it should be provided. Note: When provided, &#39;sslKeyPassword&#39; field must not be provided.
     * 
     */
    public String sslKeyPasswordSecretId() {
        return this.sslKeyPasswordSecretId;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret that stores the Client Key
     * * The content of a .pem or .crt file containing the client private key (for 2-way SSL). Note: When provided, &#39;sslKey&#39; field must not be provided.
     * 
     */
    public String sslKeySecretId() {
        return this.sslKeySecretId;
    }
    /**
     * @return SSL mode to be provided for the following connection types: MYSQL, POSTGRESQL.
     * 
     */
    public String sslMode() {
        return this.sslMode;
    }
    /**
     * @return The base64 encoded file which contains the self-signed server certificate / Certificate Authority (CA) certificate. It is not included in GET responses if the `view=COMPACT` query parameter is specified.
     * 
     */
    public String sslServerCertificate() {
        return this.sslServerCertificate;
    }
    /**
     * @return Possible lifecycle states for connection.
     * 
     */
    public String state() {
        return this.state;
    }
    /**
     * @return Optional. External storage credential name to access files on object storage such as ADLS Gen2, S3 or GCS.
     * 
     */
    public String storageCredentialName() {
        return this.storageCredentialName;
    }
    /**
     * @return Represents the storage of given type used in an Iceberg connection.
     * 
     */
    public List<GetConnectionStorage> storages() {
        return this.storages;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the stream pool being referenced.
     * 
     */
    public String streamPoolId() {
        return this.streamPoolId;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the target subnet of the dedicated connection.
     * 
     */
    public String subnetId() {
        return this.subnetId;
    }
    /**
     * @return The system tags associated with this resource, if any. The system tags are set by Oracle Cloud Infrastructure services. Each key is predefined and scoped to namespaces.  For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{orcl-cloud: {free-tier-retain: true}}`
     * 
     */
    public Map<String,String> systemTags() {
        return this.systemTags;
    }
    /**
     * @return The technology type.
     * 
     */
    public String technologyType() {
        return this.technologyType;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the related Oracle Cloud Infrastructure tenancy.
     * 
     */
    public String tenancyId() {
        return this.tenancyId;
    }
    /**
     * @return Azure tenant ID of the application. e.g.: 14593954-d337-4a61-a364-9f758c64f97f
     * 
     */
    public String tenantId() {
        return this.tenantId;
    }
    /**
     * @return The time the resource was created. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
     * 
     */
    public String timeCreated() {
        return this.timeCreated;
    }
    /**
     * @return The time the resource was last updated. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
     * 
     */
    public String timeUpdated() {
        return this.timeUpdated;
    }
    /**
     * @return Database Certificate - The base64 encoded content of a .pem file, containing the server public key (for 1 and 2-way SSL). It is not included in GET responses if the `view=COMPACT` query parameter is specified.
     * 
     */
    public String tlsCaFile() {
        return this.tlsCaFile;
    }
    public String tlsCertificateKeyFile() {
        return this.tlsCertificateKeyFile;
    }
    public String tlsCertificateKeyFilePassword() {
        return this.tlsCertificateKeyFilePassword;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret that stores the password of the tls certificate key file. Note: When provided, &#39;tlsCertificateKeyFilePassword&#39; field must not be provided.
     * 
     */
    public String tlsCertificateKeyFilePasswordSecretId() {
        return this.tlsCertificateKeyFilePasswordSecretId;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret that stores the certificate key file of the mtls connection.
     * * The content of a .pem file containing the client private key (for 2-way SSL). Note: When provided, &#39;tlsCertificateKeyFile&#39; field must not be provided.
     * 
     */
    public String tlsCertificateKeyFileSecretId() {
        return this.tlsCertificateKeyFileSecretId;
    }
    public Boolean triggerRefresh() {
        return this.triggerRefresh;
    }
    public String trustStore() {
        return this.trustStore;
    }
    public String trustStorePassword() {
        return this.trustStorePassword;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the kafka Ssl TrustStore password is stored. Note: When provided, &#39;trustStorePassword&#39; field must not be provided.
     * 
     */
    public String trustStorePasswordSecretId() {
        return this.trustStorePasswordSecretId;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the content of the TrustStore file is stored. Note: When provided, &#39;trustStore&#39; field must not be provided.
     * 
     */
    public String trustStoreSecretId() {
        return this.trustStoreSecretId;
    }
    /**
     * @return Kafka Schema Registry URL. e.g.: &#39;https://server1.us.oracle.com:8081&#39;
     * 
     */
    public String url() {
        return this.url;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure user who will access the Oracle NoSQL database. The user must have write access to the table they want to connect to. If the user is not provided, backend will default to the user who is calling the API endpoint.
     * 
     */
    public String userId() {
        return this.userId;
    }
    /**
     * @return The username Oracle GoldenGate uses to connect the associated system of the given technology. This username must already exist and be available by the system/application to be connected to and must conform to the case sensitivty requirments defined in it.
     * 
     */
    public String username() {
        return this.username;
    }
    /**
     * @return Refers to the customer&#39;s vault OCID.  If provided, it references a vault where GoldenGate can manage secrets. Customers must add policies to permit GoldenGate to manage secrets contained within this vault.
     * 
     */
    public String vaultId() {
        return this.vaultId;
    }
    public String wallet() {
        return this.wallet;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Secret where the wallet file is stored.  The wallet contents Oracle GoldenGate uses to make connections to a database. Note: When provided, &#39;wallet&#39; field must not be provided.
     * 
     */
    public String walletSecretId() {
        return this.walletSecretId;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetConnectionResult defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String accessKeyId;
        private String accountKey;
        private String accountKeySecretId;
        private String accountName;
        private List<GetConnectionAdditionalAttribute> additionalAttributes;
        private String authenticationMode;
        private String authenticationType;
        private String azureAuthorityHost;
        private String azureTenantId;
        private List<GetConnectionBootstrapServer> bootstrapServers;
        private List<GetConnectionCatalog> catalogs;
        private String clientId;
        private String clientSecret;
        private String clientSecretSecretId;
        private String compartmentId;
        private String connectionFactory;
        private String connectionId;
        private String connectionString;
        private String connectionType;
        private String connectionUrl;
        private String consumerProperties;
        private String coreSiteXml;
        private String databaseId;
        private String databaseName;
        private String dbSystemId;
        private Map<String,String> definedTags;
        private String deploymentId;
        private String description;
        private String displayName;
        private Boolean doesUseSecretIds;
        private String endpoint;
        private String fingerprint;
        private Map<String,String> freeformTags;
        private String host;
        private String id;
        private List<GetConnectionIngressIp> ingressIps;
        private Boolean isLockOverride;
        private String jndiConnectionFactory;
        private String jndiInitialContextFactory;
        private String jndiProviderUrl;
        private String jndiSecurityCredentials;
        private String jndiSecurityCredentialsSecretId;
        private String jndiSecurityPrincipal;
        private String keyId;
        private String keyStore;
        private String keyStorePassword;
        private String keyStorePasswordSecretId;
        private String keyStoreSecretId;
        private String lifecycleDetails;
        private List<GetConnectionLock> locks;
        private List<String> nsgIds;
        private String password;
        private String passwordSecretId;
        private Integer port;
        private String privateIp;
        private String privateKeyFile;
        private String privateKeyFileSecretId;
        private String privateKeyPassphrase;
        private String privateKeyPassphraseSecretId;
        private String producerProperties;
        private String publicKeyFingerprint;
        private String redisClusterId;
        private String region;
        private String routingMethod;
        private String sasToken;
        private String sasTokenSecretId;
        private String secretAccessKey;
        private String secretAccessKeySecretId;
        private String securityProtocol;
        private String servers;
        private String serviceAccountKeyFile;
        private String serviceAccountKeyFileSecretId;
        private String sessionMode;
        private Boolean shouldUseJndi;
        private Boolean shouldUseResourcePrincipal;
        private Boolean shouldValidateServerCertificate;
        private String sslCa;
        private String sslCert;
        private String sslClientKeystash;
        private String sslClientKeystashSecretId;
        private String sslClientKeystoredb;
        private String sslClientKeystoredbSecretId;
        private String sslCrl;
        private String sslKey;
        private String sslKeyPassword;
        private String sslKeyPasswordSecretId;
        private String sslKeySecretId;
        private String sslMode;
        private String sslServerCertificate;
        private String state;
        private String storageCredentialName;
        private List<GetConnectionStorage> storages;
        private String streamPoolId;
        private String subnetId;
        private Map<String,String> systemTags;
        private String technologyType;
        private String tenancyId;
        private String tenantId;
        private String timeCreated;
        private String timeUpdated;
        private String tlsCaFile;
        private String tlsCertificateKeyFile;
        private String tlsCertificateKeyFilePassword;
        private String tlsCertificateKeyFilePasswordSecretId;
        private String tlsCertificateKeyFileSecretId;
        private Boolean triggerRefresh;
        private String trustStore;
        private String trustStorePassword;
        private String trustStorePasswordSecretId;
        private String trustStoreSecretId;
        private String url;
        private String userId;
        private String username;
        private String vaultId;
        private String wallet;
        private String walletSecretId;
        public Builder() {}
        public Builder(GetConnectionResult defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.accessKeyId = defaults.accessKeyId;
    	      this.accountKey = defaults.accountKey;
    	      this.accountKeySecretId = defaults.accountKeySecretId;
    	      this.accountName = defaults.accountName;
    	      this.additionalAttributes = defaults.additionalAttributes;
    	      this.authenticationMode = defaults.authenticationMode;
    	      this.authenticationType = defaults.authenticationType;
    	      this.azureAuthorityHost = defaults.azureAuthorityHost;
    	      this.azureTenantId = defaults.azureTenantId;
    	      this.bootstrapServers = defaults.bootstrapServers;
    	      this.catalogs = defaults.catalogs;
    	      this.clientId = defaults.clientId;
    	      this.clientSecret = defaults.clientSecret;
    	      this.clientSecretSecretId = defaults.clientSecretSecretId;
    	      this.compartmentId = defaults.compartmentId;
    	      this.connectionFactory = defaults.connectionFactory;
    	      this.connectionId = defaults.connectionId;
    	      this.connectionString = defaults.connectionString;
    	      this.connectionType = defaults.connectionType;
    	      this.connectionUrl = defaults.connectionUrl;
    	      this.consumerProperties = defaults.consumerProperties;
    	      this.coreSiteXml = defaults.coreSiteXml;
    	      this.databaseId = defaults.databaseId;
    	      this.databaseName = defaults.databaseName;
    	      this.dbSystemId = defaults.dbSystemId;
    	      this.definedTags = defaults.definedTags;
    	      this.deploymentId = defaults.deploymentId;
    	      this.description = defaults.description;
    	      this.displayName = defaults.displayName;
    	      this.doesUseSecretIds = defaults.doesUseSecretIds;
    	      this.endpoint = defaults.endpoint;
    	      this.fingerprint = defaults.fingerprint;
    	      this.freeformTags = defaults.freeformTags;
    	      this.host = defaults.host;
    	      this.id = defaults.id;
    	      this.ingressIps = defaults.ingressIps;
    	      this.isLockOverride = defaults.isLockOverride;
    	      this.jndiConnectionFactory = defaults.jndiConnectionFactory;
    	      this.jndiInitialContextFactory = defaults.jndiInitialContextFactory;
    	      this.jndiProviderUrl = defaults.jndiProviderUrl;
    	      this.jndiSecurityCredentials = defaults.jndiSecurityCredentials;
    	      this.jndiSecurityCredentialsSecretId = defaults.jndiSecurityCredentialsSecretId;
    	      this.jndiSecurityPrincipal = defaults.jndiSecurityPrincipal;
    	      this.keyId = defaults.keyId;
    	      this.keyStore = defaults.keyStore;
    	      this.keyStorePassword = defaults.keyStorePassword;
    	      this.keyStorePasswordSecretId = defaults.keyStorePasswordSecretId;
    	      this.keyStoreSecretId = defaults.keyStoreSecretId;
    	      this.lifecycleDetails = defaults.lifecycleDetails;
    	      this.locks = defaults.locks;
    	      this.nsgIds = defaults.nsgIds;
    	      this.password = defaults.password;
    	      this.passwordSecretId = defaults.passwordSecretId;
    	      this.port = defaults.port;
    	      this.privateIp = defaults.privateIp;
    	      this.privateKeyFile = defaults.privateKeyFile;
    	      this.privateKeyFileSecretId = defaults.privateKeyFileSecretId;
    	      this.privateKeyPassphrase = defaults.privateKeyPassphrase;
    	      this.privateKeyPassphraseSecretId = defaults.privateKeyPassphraseSecretId;
    	      this.producerProperties = defaults.producerProperties;
    	      this.publicKeyFingerprint = defaults.publicKeyFingerprint;
    	      this.redisClusterId = defaults.redisClusterId;
    	      this.region = defaults.region;
    	      this.routingMethod = defaults.routingMethod;
    	      this.sasToken = defaults.sasToken;
    	      this.sasTokenSecretId = defaults.sasTokenSecretId;
    	      this.secretAccessKey = defaults.secretAccessKey;
    	      this.secretAccessKeySecretId = defaults.secretAccessKeySecretId;
    	      this.securityProtocol = defaults.securityProtocol;
    	      this.servers = defaults.servers;
    	      this.serviceAccountKeyFile = defaults.serviceAccountKeyFile;
    	      this.serviceAccountKeyFileSecretId = defaults.serviceAccountKeyFileSecretId;
    	      this.sessionMode = defaults.sessionMode;
    	      this.shouldUseJndi = defaults.shouldUseJndi;
    	      this.shouldUseResourcePrincipal = defaults.shouldUseResourcePrincipal;
    	      this.shouldValidateServerCertificate = defaults.shouldValidateServerCertificate;
    	      this.sslCa = defaults.sslCa;
    	      this.sslCert = defaults.sslCert;
    	      this.sslClientKeystash = defaults.sslClientKeystash;
    	      this.sslClientKeystashSecretId = defaults.sslClientKeystashSecretId;
    	      this.sslClientKeystoredb = defaults.sslClientKeystoredb;
    	      this.sslClientKeystoredbSecretId = defaults.sslClientKeystoredbSecretId;
    	      this.sslCrl = defaults.sslCrl;
    	      this.sslKey = defaults.sslKey;
    	      this.sslKeyPassword = defaults.sslKeyPassword;
    	      this.sslKeyPasswordSecretId = defaults.sslKeyPasswordSecretId;
    	      this.sslKeySecretId = defaults.sslKeySecretId;
    	      this.sslMode = defaults.sslMode;
    	      this.sslServerCertificate = defaults.sslServerCertificate;
    	      this.state = defaults.state;
    	      this.storageCredentialName = defaults.storageCredentialName;
    	      this.storages = defaults.storages;
    	      this.streamPoolId = defaults.streamPoolId;
    	      this.subnetId = defaults.subnetId;
    	      this.systemTags = defaults.systemTags;
    	      this.technologyType = defaults.technologyType;
    	      this.tenancyId = defaults.tenancyId;
    	      this.tenantId = defaults.tenantId;
    	      this.timeCreated = defaults.timeCreated;
    	      this.timeUpdated = defaults.timeUpdated;
    	      this.tlsCaFile = defaults.tlsCaFile;
    	      this.tlsCertificateKeyFile = defaults.tlsCertificateKeyFile;
    	      this.tlsCertificateKeyFilePassword = defaults.tlsCertificateKeyFilePassword;
    	      this.tlsCertificateKeyFilePasswordSecretId = defaults.tlsCertificateKeyFilePasswordSecretId;
    	      this.tlsCertificateKeyFileSecretId = defaults.tlsCertificateKeyFileSecretId;
    	      this.triggerRefresh = defaults.triggerRefresh;
    	      this.trustStore = defaults.trustStore;
    	      this.trustStorePassword = defaults.trustStorePassword;
    	      this.trustStorePasswordSecretId = defaults.trustStorePasswordSecretId;
    	      this.trustStoreSecretId = defaults.trustStoreSecretId;
    	      this.url = defaults.url;
    	      this.userId = defaults.userId;
    	      this.username = defaults.username;
    	      this.vaultId = defaults.vaultId;
    	      this.wallet = defaults.wallet;
    	      this.walletSecretId = defaults.walletSecretId;
        }

        @CustomType.Setter
        public Builder accessKeyId(String accessKeyId) {
            if (accessKeyId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "accessKeyId");
            }
            this.accessKeyId = accessKeyId;
            return this;
        }
        @CustomType.Setter
        public Builder accountKey(String accountKey) {
            if (accountKey == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "accountKey");
            }
            this.accountKey = accountKey;
            return this;
        }
        @CustomType.Setter
        public Builder accountKeySecretId(String accountKeySecretId) {
            if (accountKeySecretId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "accountKeySecretId");
            }
            this.accountKeySecretId = accountKeySecretId;
            return this;
        }
        @CustomType.Setter
        public Builder accountName(String accountName) {
            if (accountName == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "accountName");
            }
            this.accountName = accountName;
            return this;
        }
        @CustomType.Setter
        public Builder additionalAttributes(List<GetConnectionAdditionalAttribute> additionalAttributes) {
            if (additionalAttributes == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "additionalAttributes");
            }
            this.additionalAttributes = additionalAttributes;
            return this;
        }
        public Builder additionalAttributes(GetConnectionAdditionalAttribute... additionalAttributes) {
            return additionalAttributes(List.of(additionalAttributes));
        }
        @CustomType.Setter
        public Builder authenticationMode(String authenticationMode) {
            if (authenticationMode == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "authenticationMode");
            }
            this.authenticationMode = authenticationMode;
            return this;
        }
        @CustomType.Setter
        public Builder authenticationType(String authenticationType) {
            if (authenticationType == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "authenticationType");
            }
            this.authenticationType = authenticationType;
            return this;
        }
        @CustomType.Setter
        public Builder azureAuthorityHost(String azureAuthorityHost) {
            if (azureAuthorityHost == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "azureAuthorityHost");
            }
            this.azureAuthorityHost = azureAuthorityHost;
            return this;
        }
        @CustomType.Setter
        public Builder azureTenantId(String azureTenantId) {
            if (azureTenantId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "azureTenantId");
            }
            this.azureTenantId = azureTenantId;
            return this;
        }
        @CustomType.Setter
        public Builder bootstrapServers(List<GetConnectionBootstrapServer> bootstrapServers) {
            if (bootstrapServers == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "bootstrapServers");
            }
            this.bootstrapServers = bootstrapServers;
            return this;
        }
        public Builder bootstrapServers(GetConnectionBootstrapServer... bootstrapServers) {
            return bootstrapServers(List.of(bootstrapServers));
        }
        @CustomType.Setter
        public Builder catalogs(List<GetConnectionCatalog> catalogs) {
            if (catalogs == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "catalogs");
            }
            this.catalogs = catalogs;
            return this;
        }
        public Builder catalogs(GetConnectionCatalog... catalogs) {
            return catalogs(List.of(catalogs));
        }
        @CustomType.Setter
        public Builder clientId(String clientId) {
            if (clientId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "clientId");
            }
            this.clientId = clientId;
            return this;
        }
        @CustomType.Setter
        public Builder clientSecret(String clientSecret) {
            if (clientSecret == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "clientSecret");
            }
            this.clientSecret = clientSecret;
            return this;
        }
        @CustomType.Setter
        public Builder clientSecretSecretId(String clientSecretSecretId) {
            if (clientSecretSecretId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "clientSecretSecretId");
            }
            this.clientSecretSecretId = clientSecretSecretId;
            return this;
        }
        @CustomType.Setter
        public Builder compartmentId(String compartmentId) {
            if (compartmentId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "compartmentId");
            }
            this.compartmentId = compartmentId;
            return this;
        }
        @CustomType.Setter
        public Builder connectionFactory(String connectionFactory) {
            if (connectionFactory == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "connectionFactory");
            }
            this.connectionFactory = connectionFactory;
            return this;
        }
        @CustomType.Setter
        public Builder connectionId(String connectionId) {
            if (connectionId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "connectionId");
            }
            this.connectionId = connectionId;
            return this;
        }
        @CustomType.Setter
        public Builder connectionString(String connectionString) {
            if (connectionString == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "connectionString");
            }
            this.connectionString = connectionString;
            return this;
        }
        @CustomType.Setter
        public Builder connectionType(String connectionType) {
            if (connectionType == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "connectionType");
            }
            this.connectionType = connectionType;
            return this;
        }
        @CustomType.Setter
        public Builder connectionUrl(String connectionUrl) {
            if (connectionUrl == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "connectionUrl");
            }
            this.connectionUrl = connectionUrl;
            return this;
        }
        @CustomType.Setter
        public Builder consumerProperties(String consumerProperties) {
            if (consumerProperties == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "consumerProperties");
            }
            this.consumerProperties = consumerProperties;
            return this;
        }
        @CustomType.Setter
        public Builder coreSiteXml(String coreSiteXml) {
            if (coreSiteXml == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "coreSiteXml");
            }
            this.coreSiteXml = coreSiteXml;
            return this;
        }
        @CustomType.Setter
        public Builder databaseId(String databaseId) {
            if (databaseId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "databaseId");
            }
            this.databaseId = databaseId;
            return this;
        }
        @CustomType.Setter
        public Builder databaseName(String databaseName) {
            if (databaseName == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "databaseName");
            }
            this.databaseName = databaseName;
            return this;
        }
        @CustomType.Setter
        public Builder dbSystemId(String dbSystemId) {
            if (dbSystemId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "dbSystemId");
            }
            this.dbSystemId = dbSystemId;
            return this;
        }
        @CustomType.Setter
        public Builder definedTags(Map<String,String> definedTags) {
            if (definedTags == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "definedTags");
            }
            this.definedTags = definedTags;
            return this;
        }
        @CustomType.Setter
        public Builder deploymentId(String deploymentId) {
            if (deploymentId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "deploymentId");
            }
            this.deploymentId = deploymentId;
            return this;
        }
        @CustomType.Setter
        public Builder description(String description) {
            if (description == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "description");
            }
            this.description = description;
            return this;
        }
        @CustomType.Setter
        public Builder displayName(String displayName) {
            if (displayName == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "displayName");
            }
            this.displayName = displayName;
            return this;
        }
        @CustomType.Setter
        public Builder doesUseSecretIds(Boolean doesUseSecretIds) {
            if (doesUseSecretIds == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "doesUseSecretIds");
            }
            this.doesUseSecretIds = doesUseSecretIds;
            return this;
        }
        @CustomType.Setter
        public Builder endpoint(String endpoint) {
            if (endpoint == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "endpoint");
            }
            this.endpoint = endpoint;
            return this;
        }
        @CustomType.Setter
        public Builder fingerprint(String fingerprint) {
            if (fingerprint == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "fingerprint");
            }
            this.fingerprint = fingerprint;
            return this;
        }
        @CustomType.Setter
        public Builder freeformTags(Map<String,String> freeformTags) {
            if (freeformTags == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "freeformTags");
            }
            this.freeformTags = freeformTags;
            return this;
        }
        @CustomType.Setter
        public Builder host(String host) {
            if (host == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "host");
            }
            this.host = host;
            return this;
        }
        @CustomType.Setter
        public Builder id(String id) {
            if (id == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "id");
            }
            this.id = id;
            return this;
        }
        @CustomType.Setter
        public Builder ingressIps(List<GetConnectionIngressIp> ingressIps) {
            if (ingressIps == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "ingressIps");
            }
            this.ingressIps = ingressIps;
            return this;
        }
        public Builder ingressIps(GetConnectionIngressIp... ingressIps) {
            return ingressIps(List.of(ingressIps));
        }
        @CustomType.Setter
        public Builder isLockOverride(Boolean isLockOverride) {
            if (isLockOverride == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "isLockOverride");
            }
            this.isLockOverride = isLockOverride;
            return this;
        }
        @CustomType.Setter
        public Builder jndiConnectionFactory(String jndiConnectionFactory) {
            if (jndiConnectionFactory == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "jndiConnectionFactory");
            }
            this.jndiConnectionFactory = jndiConnectionFactory;
            return this;
        }
        @CustomType.Setter
        public Builder jndiInitialContextFactory(String jndiInitialContextFactory) {
            if (jndiInitialContextFactory == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "jndiInitialContextFactory");
            }
            this.jndiInitialContextFactory = jndiInitialContextFactory;
            return this;
        }
        @CustomType.Setter
        public Builder jndiProviderUrl(String jndiProviderUrl) {
            if (jndiProviderUrl == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "jndiProviderUrl");
            }
            this.jndiProviderUrl = jndiProviderUrl;
            return this;
        }
        @CustomType.Setter
        public Builder jndiSecurityCredentials(String jndiSecurityCredentials) {
            if (jndiSecurityCredentials == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "jndiSecurityCredentials");
            }
            this.jndiSecurityCredentials = jndiSecurityCredentials;
            return this;
        }
        @CustomType.Setter
        public Builder jndiSecurityCredentialsSecretId(String jndiSecurityCredentialsSecretId) {
            if (jndiSecurityCredentialsSecretId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "jndiSecurityCredentialsSecretId");
            }
            this.jndiSecurityCredentialsSecretId = jndiSecurityCredentialsSecretId;
            return this;
        }
        @CustomType.Setter
        public Builder jndiSecurityPrincipal(String jndiSecurityPrincipal) {
            if (jndiSecurityPrincipal == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "jndiSecurityPrincipal");
            }
            this.jndiSecurityPrincipal = jndiSecurityPrincipal;
            return this;
        }
        @CustomType.Setter
        public Builder keyId(String keyId) {
            if (keyId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "keyId");
            }
            this.keyId = keyId;
            return this;
        }
        @CustomType.Setter
        public Builder keyStore(String keyStore) {
            if (keyStore == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "keyStore");
            }
            this.keyStore = keyStore;
            return this;
        }
        @CustomType.Setter
        public Builder keyStorePassword(String keyStorePassword) {
            if (keyStorePassword == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "keyStorePassword");
            }
            this.keyStorePassword = keyStorePassword;
            return this;
        }
        @CustomType.Setter
        public Builder keyStorePasswordSecretId(String keyStorePasswordSecretId) {
            if (keyStorePasswordSecretId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "keyStorePasswordSecretId");
            }
            this.keyStorePasswordSecretId = keyStorePasswordSecretId;
            return this;
        }
        @CustomType.Setter
        public Builder keyStoreSecretId(String keyStoreSecretId) {
            if (keyStoreSecretId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "keyStoreSecretId");
            }
            this.keyStoreSecretId = keyStoreSecretId;
            return this;
        }
        @CustomType.Setter
        public Builder lifecycleDetails(String lifecycleDetails) {
            if (lifecycleDetails == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "lifecycleDetails");
            }
            this.lifecycleDetails = lifecycleDetails;
            return this;
        }
        @CustomType.Setter
        public Builder locks(List<GetConnectionLock> locks) {
            if (locks == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "locks");
            }
            this.locks = locks;
            return this;
        }
        public Builder locks(GetConnectionLock... locks) {
            return locks(List.of(locks));
        }
        @CustomType.Setter
        public Builder nsgIds(List<String> nsgIds) {
            if (nsgIds == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "nsgIds");
            }
            this.nsgIds = nsgIds;
            return this;
        }
        public Builder nsgIds(String... nsgIds) {
            return nsgIds(List.of(nsgIds));
        }
        @CustomType.Setter
        public Builder password(String password) {
            if (password == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "password");
            }
            this.password = password;
            return this;
        }
        @CustomType.Setter
        public Builder passwordSecretId(String passwordSecretId) {
            if (passwordSecretId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "passwordSecretId");
            }
            this.passwordSecretId = passwordSecretId;
            return this;
        }
        @CustomType.Setter
        public Builder port(Integer port) {
            if (port == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "port");
            }
            this.port = port;
            return this;
        }
        @CustomType.Setter
        public Builder privateIp(String privateIp) {
            if (privateIp == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "privateIp");
            }
            this.privateIp = privateIp;
            return this;
        }
        @CustomType.Setter
        public Builder privateKeyFile(String privateKeyFile) {
            if (privateKeyFile == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "privateKeyFile");
            }
            this.privateKeyFile = privateKeyFile;
            return this;
        }
        @CustomType.Setter
        public Builder privateKeyFileSecretId(String privateKeyFileSecretId) {
            if (privateKeyFileSecretId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "privateKeyFileSecretId");
            }
            this.privateKeyFileSecretId = privateKeyFileSecretId;
            return this;
        }
        @CustomType.Setter
        public Builder privateKeyPassphrase(String privateKeyPassphrase) {
            if (privateKeyPassphrase == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "privateKeyPassphrase");
            }
            this.privateKeyPassphrase = privateKeyPassphrase;
            return this;
        }
        @CustomType.Setter
        public Builder privateKeyPassphraseSecretId(String privateKeyPassphraseSecretId) {
            if (privateKeyPassphraseSecretId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "privateKeyPassphraseSecretId");
            }
            this.privateKeyPassphraseSecretId = privateKeyPassphraseSecretId;
            return this;
        }
        @CustomType.Setter
        public Builder producerProperties(String producerProperties) {
            if (producerProperties == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "producerProperties");
            }
            this.producerProperties = producerProperties;
            return this;
        }
        @CustomType.Setter
        public Builder publicKeyFingerprint(String publicKeyFingerprint) {
            if (publicKeyFingerprint == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "publicKeyFingerprint");
            }
            this.publicKeyFingerprint = publicKeyFingerprint;
            return this;
        }
        @CustomType.Setter
        public Builder redisClusterId(String redisClusterId) {
            if (redisClusterId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "redisClusterId");
            }
            this.redisClusterId = redisClusterId;
            return this;
        }
        @CustomType.Setter
        public Builder region(String region) {
            if (region == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "region");
            }
            this.region = region;
            return this;
        }
        @CustomType.Setter
        public Builder routingMethod(String routingMethod) {
            if (routingMethod == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "routingMethod");
            }
            this.routingMethod = routingMethod;
            return this;
        }
        @CustomType.Setter
        public Builder sasToken(String sasToken) {
            if (sasToken == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "sasToken");
            }
            this.sasToken = sasToken;
            return this;
        }
        @CustomType.Setter
        public Builder sasTokenSecretId(String sasTokenSecretId) {
            if (sasTokenSecretId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "sasTokenSecretId");
            }
            this.sasTokenSecretId = sasTokenSecretId;
            return this;
        }
        @CustomType.Setter
        public Builder secretAccessKey(String secretAccessKey) {
            if (secretAccessKey == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "secretAccessKey");
            }
            this.secretAccessKey = secretAccessKey;
            return this;
        }
        @CustomType.Setter
        public Builder secretAccessKeySecretId(String secretAccessKeySecretId) {
            if (secretAccessKeySecretId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "secretAccessKeySecretId");
            }
            this.secretAccessKeySecretId = secretAccessKeySecretId;
            return this;
        }
        @CustomType.Setter
        public Builder securityProtocol(String securityProtocol) {
            if (securityProtocol == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "securityProtocol");
            }
            this.securityProtocol = securityProtocol;
            return this;
        }
        @CustomType.Setter
        public Builder servers(String servers) {
            if (servers == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "servers");
            }
            this.servers = servers;
            return this;
        }
        @CustomType.Setter
        public Builder serviceAccountKeyFile(String serviceAccountKeyFile) {
            if (serviceAccountKeyFile == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "serviceAccountKeyFile");
            }
            this.serviceAccountKeyFile = serviceAccountKeyFile;
            return this;
        }
        @CustomType.Setter
        public Builder serviceAccountKeyFileSecretId(String serviceAccountKeyFileSecretId) {
            if (serviceAccountKeyFileSecretId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "serviceAccountKeyFileSecretId");
            }
            this.serviceAccountKeyFileSecretId = serviceAccountKeyFileSecretId;
            return this;
        }
        @CustomType.Setter
        public Builder sessionMode(String sessionMode) {
            if (sessionMode == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "sessionMode");
            }
            this.sessionMode = sessionMode;
            return this;
        }
        @CustomType.Setter
        public Builder shouldUseJndi(Boolean shouldUseJndi) {
            if (shouldUseJndi == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "shouldUseJndi");
            }
            this.shouldUseJndi = shouldUseJndi;
            return this;
        }
        @CustomType.Setter
        public Builder shouldUseResourcePrincipal(Boolean shouldUseResourcePrincipal) {
            if (shouldUseResourcePrincipal == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "shouldUseResourcePrincipal");
            }
            this.shouldUseResourcePrincipal = shouldUseResourcePrincipal;
            return this;
        }
        @CustomType.Setter
        public Builder shouldValidateServerCertificate(Boolean shouldValidateServerCertificate) {
            if (shouldValidateServerCertificate == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "shouldValidateServerCertificate");
            }
            this.shouldValidateServerCertificate = shouldValidateServerCertificate;
            return this;
        }
        @CustomType.Setter
        public Builder sslCa(String sslCa) {
            if (sslCa == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "sslCa");
            }
            this.sslCa = sslCa;
            return this;
        }
        @CustomType.Setter
        public Builder sslCert(String sslCert) {
            if (sslCert == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "sslCert");
            }
            this.sslCert = sslCert;
            return this;
        }
        @CustomType.Setter
        public Builder sslClientKeystash(String sslClientKeystash) {
            if (sslClientKeystash == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "sslClientKeystash");
            }
            this.sslClientKeystash = sslClientKeystash;
            return this;
        }
        @CustomType.Setter
        public Builder sslClientKeystashSecretId(String sslClientKeystashSecretId) {
            if (sslClientKeystashSecretId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "sslClientKeystashSecretId");
            }
            this.sslClientKeystashSecretId = sslClientKeystashSecretId;
            return this;
        }
        @CustomType.Setter
        public Builder sslClientKeystoredb(String sslClientKeystoredb) {
            if (sslClientKeystoredb == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "sslClientKeystoredb");
            }
            this.sslClientKeystoredb = sslClientKeystoredb;
            return this;
        }
        @CustomType.Setter
        public Builder sslClientKeystoredbSecretId(String sslClientKeystoredbSecretId) {
            if (sslClientKeystoredbSecretId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "sslClientKeystoredbSecretId");
            }
            this.sslClientKeystoredbSecretId = sslClientKeystoredbSecretId;
            return this;
        }
        @CustomType.Setter
        public Builder sslCrl(String sslCrl) {
            if (sslCrl == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "sslCrl");
            }
            this.sslCrl = sslCrl;
            return this;
        }
        @CustomType.Setter
        public Builder sslKey(String sslKey) {
            if (sslKey == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "sslKey");
            }
            this.sslKey = sslKey;
            return this;
        }
        @CustomType.Setter
        public Builder sslKeyPassword(String sslKeyPassword) {
            if (sslKeyPassword == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "sslKeyPassword");
            }
            this.sslKeyPassword = sslKeyPassword;
            return this;
        }
        @CustomType.Setter
        public Builder sslKeyPasswordSecretId(String sslKeyPasswordSecretId) {
            if (sslKeyPasswordSecretId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "sslKeyPasswordSecretId");
            }
            this.sslKeyPasswordSecretId = sslKeyPasswordSecretId;
            return this;
        }
        @CustomType.Setter
        public Builder sslKeySecretId(String sslKeySecretId) {
            if (sslKeySecretId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "sslKeySecretId");
            }
            this.sslKeySecretId = sslKeySecretId;
            return this;
        }
        @CustomType.Setter
        public Builder sslMode(String sslMode) {
            if (sslMode == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "sslMode");
            }
            this.sslMode = sslMode;
            return this;
        }
        @CustomType.Setter
        public Builder sslServerCertificate(String sslServerCertificate) {
            if (sslServerCertificate == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "sslServerCertificate");
            }
            this.sslServerCertificate = sslServerCertificate;
            return this;
        }
        @CustomType.Setter
        public Builder state(String state) {
            if (state == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "state");
            }
            this.state = state;
            return this;
        }
        @CustomType.Setter
        public Builder storageCredentialName(String storageCredentialName) {
            if (storageCredentialName == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "storageCredentialName");
            }
            this.storageCredentialName = storageCredentialName;
            return this;
        }
        @CustomType.Setter
        public Builder storages(List<GetConnectionStorage> storages) {
            if (storages == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "storages");
            }
            this.storages = storages;
            return this;
        }
        public Builder storages(GetConnectionStorage... storages) {
            return storages(List.of(storages));
        }
        @CustomType.Setter
        public Builder streamPoolId(String streamPoolId) {
            if (streamPoolId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "streamPoolId");
            }
            this.streamPoolId = streamPoolId;
            return this;
        }
        @CustomType.Setter
        public Builder subnetId(String subnetId) {
            if (subnetId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "subnetId");
            }
            this.subnetId = subnetId;
            return this;
        }
        @CustomType.Setter
        public Builder systemTags(Map<String,String> systemTags) {
            if (systemTags == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "systemTags");
            }
            this.systemTags = systemTags;
            return this;
        }
        @CustomType.Setter
        public Builder technologyType(String technologyType) {
            if (technologyType == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "technologyType");
            }
            this.technologyType = technologyType;
            return this;
        }
        @CustomType.Setter
        public Builder tenancyId(String tenancyId) {
            if (tenancyId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "tenancyId");
            }
            this.tenancyId = tenancyId;
            return this;
        }
        @CustomType.Setter
        public Builder tenantId(String tenantId) {
            if (tenantId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "tenantId");
            }
            this.tenantId = tenantId;
            return this;
        }
        @CustomType.Setter
        public Builder timeCreated(String timeCreated) {
            if (timeCreated == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "timeCreated");
            }
            this.timeCreated = timeCreated;
            return this;
        }
        @CustomType.Setter
        public Builder timeUpdated(String timeUpdated) {
            if (timeUpdated == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "timeUpdated");
            }
            this.timeUpdated = timeUpdated;
            return this;
        }
        @CustomType.Setter
        public Builder tlsCaFile(String tlsCaFile) {
            if (tlsCaFile == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "tlsCaFile");
            }
            this.tlsCaFile = tlsCaFile;
            return this;
        }
        @CustomType.Setter
        public Builder tlsCertificateKeyFile(String tlsCertificateKeyFile) {
            if (tlsCertificateKeyFile == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "tlsCertificateKeyFile");
            }
            this.tlsCertificateKeyFile = tlsCertificateKeyFile;
            return this;
        }
        @CustomType.Setter
        public Builder tlsCertificateKeyFilePassword(String tlsCertificateKeyFilePassword) {
            if (tlsCertificateKeyFilePassword == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "tlsCertificateKeyFilePassword");
            }
            this.tlsCertificateKeyFilePassword = tlsCertificateKeyFilePassword;
            return this;
        }
        @CustomType.Setter
        public Builder tlsCertificateKeyFilePasswordSecretId(String tlsCertificateKeyFilePasswordSecretId) {
            if (tlsCertificateKeyFilePasswordSecretId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "tlsCertificateKeyFilePasswordSecretId");
            }
            this.tlsCertificateKeyFilePasswordSecretId = tlsCertificateKeyFilePasswordSecretId;
            return this;
        }
        @CustomType.Setter
        public Builder tlsCertificateKeyFileSecretId(String tlsCertificateKeyFileSecretId) {
            if (tlsCertificateKeyFileSecretId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "tlsCertificateKeyFileSecretId");
            }
            this.tlsCertificateKeyFileSecretId = tlsCertificateKeyFileSecretId;
            return this;
        }
        @CustomType.Setter
        public Builder triggerRefresh(Boolean triggerRefresh) {
            if (triggerRefresh == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "triggerRefresh");
            }
            this.triggerRefresh = triggerRefresh;
            return this;
        }
        @CustomType.Setter
        public Builder trustStore(String trustStore) {
            if (trustStore == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "trustStore");
            }
            this.trustStore = trustStore;
            return this;
        }
        @CustomType.Setter
        public Builder trustStorePassword(String trustStorePassword) {
            if (trustStorePassword == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "trustStorePassword");
            }
            this.trustStorePassword = trustStorePassword;
            return this;
        }
        @CustomType.Setter
        public Builder trustStorePasswordSecretId(String trustStorePasswordSecretId) {
            if (trustStorePasswordSecretId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "trustStorePasswordSecretId");
            }
            this.trustStorePasswordSecretId = trustStorePasswordSecretId;
            return this;
        }
        @CustomType.Setter
        public Builder trustStoreSecretId(String trustStoreSecretId) {
            if (trustStoreSecretId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "trustStoreSecretId");
            }
            this.trustStoreSecretId = trustStoreSecretId;
            return this;
        }
        @CustomType.Setter
        public Builder url(String url) {
            if (url == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "url");
            }
            this.url = url;
            return this;
        }
        @CustomType.Setter
        public Builder userId(String userId) {
            if (userId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "userId");
            }
            this.userId = userId;
            return this;
        }
        @CustomType.Setter
        public Builder username(String username) {
            if (username == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "username");
            }
            this.username = username;
            return this;
        }
        @CustomType.Setter
        public Builder vaultId(String vaultId) {
            if (vaultId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "vaultId");
            }
            this.vaultId = vaultId;
            return this;
        }
        @CustomType.Setter
        public Builder wallet(String wallet) {
            if (wallet == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "wallet");
            }
            this.wallet = wallet;
            return this;
        }
        @CustomType.Setter
        public Builder walletSecretId(String walletSecretId) {
            if (walletSecretId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "walletSecretId");
            }
            this.walletSecretId = walletSecretId;
            return this;
        }
        public GetConnectionResult build() {
            final var _resultValue = new GetConnectionResult();
            _resultValue.accessKeyId = accessKeyId;
            _resultValue.accountKey = accountKey;
            _resultValue.accountKeySecretId = accountKeySecretId;
            _resultValue.accountName = accountName;
            _resultValue.additionalAttributes = additionalAttributes;
            _resultValue.authenticationMode = authenticationMode;
            _resultValue.authenticationType = authenticationType;
            _resultValue.azureAuthorityHost = azureAuthorityHost;
            _resultValue.azureTenantId = azureTenantId;
            _resultValue.bootstrapServers = bootstrapServers;
            _resultValue.catalogs = catalogs;
            _resultValue.clientId = clientId;
            _resultValue.clientSecret = clientSecret;
            _resultValue.clientSecretSecretId = clientSecretSecretId;
            _resultValue.compartmentId = compartmentId;
            _resultValue.connectionFactory = connectionFactory;
            _resultValue.connectionId = connectionId;
            _resultValue.connectionString = connectionString;
            _resultValue.connectionType = connectionType;
            _resultValue.connectionUrl = connectionUrl;
            _resultValue.consumerProperties = consumerProperties;
            _resultValue.coreSiteXml = coreSiteXml;
            _resultValue.databaseId = databaseId;
            _resultValue.databaseName = databaseName;
            _resultValue.dbSystemId = dbSystemId;
            _resultValue.definedTags = definedTags;
            _resultValue.deploymentId = deploymentId;
            _resultValue.description = description;
            _resultValue.displayName = displayName;
            _resultValue.doesUseSecretIds = doesUseSecretIds;
            _resultValue.endpoint = endpoint;
            _resultValue.fingerprint = fingerprint;
            _resultValue.freeformTags = freeformTags;
            _resultValue.host = host;
            _resultValue.id = id;
            _resultValue.ingressIps = ingressIps;
            _resultValue.isLockOverride = isLockOverride;
            _resultValue.jndiConnectionFactory = jndiConnectionFactory;
            _resultValue.jndiInitialContextFactory = jndiInitialContextFactory;
            _resultValue.jndiProviderUrl = jndiProviderUrl;
            _resultValue.jndiSecurityCredentials = jndiSecurityCredentials;
            _resultValue.jndiSecurityCredentialsSecretId = jndiSecurityCredentialsSecretId;
            _resultValue.jndiSecurityPrincipal = jndiSecurityPrincipal;
            _resultValue.keyId = keyId;
            _resultValue.keyStore = keyStore;
            _resultValue.keyStorePassword = keyStorePassword;
            _resultValue.keyStorePasswordSecretId = keyStorePasswordSecretId;
            _resultValue.keyStoreSecretId = keyStoreSecretId;
            _resultValue.lifecycleDetails = lifecycleDetails;
            _resultValue.locks = locks;
            _resultValue.nsgIds = nsgIds;
            _resultValue.password = password;
            _resultValue.passwordSecretId = passwordSecretId;
            _resultValue.port = port;
            _resultValue.privateIp = privateIp;
            _resultValue.privateKeyFile = privateKeyFile;
            _resultValue.privateKeyFileSecretId = privateKeyFileSecretId;
            _resultValue.privateKeyPassphrase = privateKeyPassphrase;
            _resultValue.privateKeyPassphraseSecretId = privateKeyPassphraseSecretId;
            _resultValue.producerProperties = producerProperties;
            _resultValue.publicKeyFingerprint = publicKeyFingerprint;
            _resultValue.redisClusterId = redisClusterId;
            _resultValue.region = region;
            _resultValue.routingMethod = routingMethod;
            _resultValue.sasToken = sasToken;
            _resultValue.sasTokenSecretId = sasTokenSecretId;
            _resultValue.secretAccessKey = secretAccessKey;
            _resultValue.secretAccessKeySecretId = secretAccessKeySecretId;
            _resultValue.securityProtocol = securityProtocol;
            _resultValue.servers = servers;
            _resultValue.serviceAccountKeyFile = serviceAccountKeyFile;
            _resultValue.serviceAccountKeyFileSecretId = serviceAccountKeyFileSecretId;
            _resultValue.sessionMode = sessionMode;
            _resultValue.shouldUseJndi = shouldUseJndi;
            _resultValue.shouldUseResourcePrincipal = shouldUseResourcePrincipal;
            _resultValue.shouldValidateServerCertificate = shouldValidateServerCertificate;
            _resultValue.sslCa = sslCa;
            _resultValue.sslCert = sslCert;
            _resultValue.sslClientKeystash = sslClientKeystash;
            _resultValue.sslClientKeystashSecretId = sslClientKeystashSecretId;
            _resultValue.sslClientKeystoredb = sslClientKeystoredb;
            _resultValue.sslClientKeystoredbSecretId = sslClientKeystoredbSecretId;
            _resultValue.sslCrl = sslCrl;
            _resultValue.sslKey = sslKey;
            _resultValue.sslKeyPassword = sslKeyPassword;
            _resultValue.sslKeyPasswordSecretId = sslKeyPasswordSecretId;
            _resultValue.sslKeySecretId = sslKeySecretId;
            _resultValue.sslMode = sslMode;
            _resultValue.sslServerCertificate = sslServerCertificate;
            _resultValue.state = state;
            _resultValue.storageCredentialName = storageCredentialName;
            _resultValue.storages = storages;
            _resultValue.streamPoolId = streamPoolId;
            _resultValue.subnetId = subnetId;
            _resultValue.systemTags = systemTags;
            _resultValue.technologyType = technologyType;
            _resultValue.tenancyId = tenancyId;
            _resultValue.tenantId = tenantId;
            _resultValue.timeCreated = timeCreated;
            _resultValue.timeUpdated = timeUpdated;
            _resultValue.tlsCaFile = tlsCaFile;
            _resultValue.tlsCertificateKeyFile = tlsCertificateKeyFile;
            _resultValue.tlsCertificateKeyFilePassword = tlsCertificateKeyFilePassword;
            _resultValue.tlsCertificateKeyFilePasswordSecretId = tlsCertificateKeyFilePasswordSecretId;
            _resultValue.tlsCertificateKeyFileSecretId = tlsCertificateKeyFileSecretId;
            _resultValue.triggerRefresh = triggerRefresh;
            _resultValue.trustStore = trustStore;
            _resultValue.trustStorePassword = trustStorePassword;
            _resultValue.trustStorePasswordSecretId = trustStorePasswordSecretId;
            _resultValue.trustStoreSecretId = trustStoreSecretId;
            _resultValue.url = url;
            _resultValue.userId = userId;
            _resultValue.username = username;
            _resultValue.vaultId = vaultId;
            _resultValue.wallet = wallet;
            _resultValue.walletSecretId = walletSecretId;
            return _resultValue;
        }
    }
}
