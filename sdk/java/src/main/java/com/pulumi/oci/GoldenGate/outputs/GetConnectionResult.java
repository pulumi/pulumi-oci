// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.oci.GoldenGate.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.oci.GoldenGate.outputs.GetConnectionAdditionalAttribute;
import com.pulumi.oci.GoldenGate.outputs.GetConnectionBootstrapServer;
import com.pulumi.oci.GoldenGate.outputs.GetConnectionIngressIp;
import com.pulumi.oci.GoldenGate.outputs.GetConnectionLock;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;

@CustomType
public final class GetConnectionResult {
    /**
     * @return Access key ID to access the Amazon S3 bucket. e.g.: &#34;this-is-not-the-secret&#34;
     * 
     */
    private String accessKeyId;
    private String accountKey;
    /**
     * @return Sets the Azure storage account name.
     * 
     */
    private String accountName;
    /**
     * @return An array of name-value pair attribute entries. Used as additional parameters in connection string.
     * 
     */
    private List<GetConnectionAdditionalAttribute> additionalAttributes;
    /**
     * @return Authentication mode. It can be provided at creation of Oracle Autonomous Database Serverless connections, when a databaseId is provided. The default value is MTLS.
     * 
     */
    private String authenticationMode;
    /**
     * @return Used authentication mechanism to be provided for the following connection types:
     * * AZURE_DATA_LAKE_STORAGE, ELASTICSEARCH, KAFKA_SCHEMA_REGISTRY, REDIS, SNOWFLAKE
     * * JAVA_MESSAGE_SERVICE - If not provided, default is NONE. Optional until 2024-06-27, in the release after it will be made required.
     * 
     */
    private String authenticationType;
    /**
     * @return Azure tenant ID of the application. This property is required when &#39;authenticationType&#39; is set to &#39;AZURE_ACTIVE_DIRECTORY&#39;. e.g.: 14593954-d337-4a61-a364-9f758c64f97f
     * 
     */
    private String azureTenantId;
    /**
     * @return Kafka bootstrap. Equivalent of bootstrap.servers configuration property in Kafka: list of KafkaBootstrapServer objects specified by host/port. Used for establishing the initial connection to the Kafka cluster. Example: `&#34;server1.example.com:9092,server2.example.com:9092&#34;`
     * 
     */
    private List<GetConnectionBootstrapServer> bootstrapServers;
    /**
     * @return Azure client ID of the application. This property is required when &#39;authenticationType&#39; is set to &#39;AZURE_ACTIVE_DIRECTORY&#39;. e.g.: 06ecaabf-8b80-4ec8-a0ec-20cbf463703d
     * 
     */
    private String clientId;
    private String clientSecret;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment being referenced.
     * 
     */
    private String compartmentId;
    /**
     * @return The of Java class implementing javax.jms.ConnectionFactory interface supplied by the Java Message Service provider. e.g.: &#39;com.stc.jmsjca.core.JConnectionFactoryXA&#39;
     * 
     */
    private String connectionFactory;
    private String connectionId;
    /**
     * @return * ORACLE: Connect descriptor or Easy Connect Naming method used to connect to a database.
     * * MONGODB: MongoDB connection string. e.g.: &#39;mongodb://mongodb0.example.com:27017/recordsrecords&#39;
     * * AZURE_SYNAPSE_ANALYTICS: JDBC connection string. e.g.: &#39;jdbc:sqlserver://&lt;synapse-workspace&gt;.sql.azuresynapse.net:1433;database=&lt;db-name&gt;;encrypt=true;trustServerCertificate=false;hostNameInCertificate=*.sql.azuresynapse.net;loginTimeout=300;&#39;
     * 
     */
    private String connectionString;
    /**
     * @return The connection type.
     * 
     */
    private String connectionType;
    /**
     * @return * JAVA_MESSAGE_SERVICE: Connection URL of the Java Message Service, specifying the protocol, host, and port. e.g.: &#39;mq://myjms.host.domain:7676&#39;
     * * SNOWFLAKE: JDBC connection URL. e.g.: &#39;jdbc:snowflake://&lt;account_name&gt;.snowflakecomputing.com/?warehouse=&lt;warehouse-name&gt;&amp;db=&lt;db-name&gt;&#39;
     * * AMAZON_REDSHIFT: Connection URL. e.g.: &#39;jdbc:redshift://aws-redshift-instance.aaaaaaaaaaaa.us-east-2.redshift.amazonaws.com:5439/mydb&#39;
     * 
     */
    private String connectionUrl;
    private String consumerProperties;
    private String coreSiteXml;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database being referenced.
     * 
     */
    private String databaseId;
    /**
     * @return The name of the database.
     * 
     */
    private String databaseName;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database system being referenced.
     * 
     */
    private String dbSystemId;
    /**
     * @return Tags defined for this resource. Each key is predefined and scoped to a namespace.  Example: `{&#34;foo-namespace.bar-key&#34;: &#34;value&#34;}`
     * 
     */
    private Map<String,String> definedTags;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the deployment being referenced.
     * 
     */
    private String deploymentId;
    /**
     * @return Metadata about this specific object.
     * 
     */
    private String description;
    /**
     * @return An object&#39;s Display Name.
     * 
     */
    private String displayName;
    /**
     * @return Azure Storage service endpoint. e.g: https://test.blob.core.windows.net
     * 
     */
    private String endpoint;
    private String fingerprint;
    /**
     * @return A simple key-value pair that is applied without any predefined name, type, or scope. Exists for cross-compatibility only.  Example: `{&#34;bar-key&#34;: &#34;value&#34;}`
     * 
     */
    private Map<String,String> freeformTags;
    /**
     * @return The name or address of a host.
     * In case of Generic connection type it represents the Host and port separated by colon. Example: `&#34;server.example.com:1234&#34;`
     * For multiple hosts, provide a comma separated list. Example: `&#34;server1.example.com:1000,server1.example.com:2000&#34;`
     * 
     */
    private String host;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the connection being referenced.
     * 
     */
    private String id;
    /**
     * @return List of ingress IP addresses from where the GoldenGate deployment connects to this connection&#39;s privateIp.  Customers may optionally set up ingress security rules to restrict traffic from these IP addresses.
     * 
     */
    private List<GetConnectionIngressIp> ingressIps;
    private Boolean isLockOverride;
    /**
     * @return The Connection Factory can be looked up using this name. e.g.: &#39;ConnectionFactory&#39;
     * 
     */
    private String jndiConnectionFactory;
    /**
     * @return The implementation of javax.naming.spi.InitialContextFactory interface that the client uses to obtain initial naming context. e.g.: &#39;org.apache.activemq.jndi.ActiveMQInitialContextFactory&#39;
     * 
     */
    private String jndiInitialContextFactory;
    /**
     * @return The URL that Java Message Service will use to contact the JNDI provider. e.g.: &#39;tcp://myjms.host.domain:61616?jms.prefetchPolicy.all=1000&#39;
     * 
     */
    private String jndiProviderUrl;
    private String jndiSecurityCredentials;
    /**
     * @return Specifies the identity of the principal (user) to be authenticated. e.g.: &#39;admin2&#39;
     * 
     */
    private String jndiSecurityPrincipal;
    /**
     * @return Refers to the customer&#39;s master key OCID.  If provided, it references a key to manage secrets. Customers must add policies to permit GoldenGate to use this key.
     * 
     */
    private String keyId;
    private String keyStore;
    private String keyStorePassword;
    /**
     * @return Describes the object&#39;s current state in detail. For example, it can be used to provide actionable information for a resource in a Failed state.
     * 
     */
    private String lifecycleDetails;
    /**
     * @return Locks associated with this resource.
     * 
     */
    private List<GetConnectionLock> locks;
    /**
     * @return An array of Network Security Group OCIDs used to define network access for either Deployments or Connections.
     * 
     */
    private List<String> nsgIds;
    private String password;
    /**
     * @return The port of an endpoint usually specified for a connection.
     * 
     */
    private Integer port;
    /**
     * @return Deprecated: this field will be removed in future versions. Either specify the private IP in the connectionString or host  field, or make sure the host name is resolvable in the target VCN.
     * The private IP address of the connection&#39;s endpoint in the customer&#39;s VCN, typically a database endpoint or a big data endpoint (e.g. Kafka bootstrap server). In case the privateIp is provided, the subnetId must also be provided. In case the privateIp (and the subnetId) is not provided it is assumed the datasource is publicly accessible. In case the connection is accessible only privately, the lack of privateIp will result in not being able to access the connection.
     * 
     */
    private String privateIp;
    private String privateKeyFile;
    private String privateKeyPassphrase;
    private String producerProperties;
    private String publicKeyFingerprint;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Redis cluster.
     * 
     */
    private String redisClusterId;
    /**
     * @return The name of the region. e.g.: us-ashburn-1
     * 
     */
    private String region;
    /**
     * @return Controls the network traffic direction to the target: SHARED_SERVICE_ENDPOINT: Traffic flows through the Goldengate Service&#39;s network to public hosts. Cannot be used for private targets.  SHARED_DEPLOYMENT_ENDPOINT: Network traffic flows from the assigned deployment&#39;s private endpoint through the deployment&#39;s subnet. DEDICATED_ENDPOINT: A dedicated private endpoint is created in the target VCN subnet for the connection. The subnetId is required when DEDICATED_ENDPOINT networking is selected.
     * 
     */
    private String routingMethod;
    private String sasToken;
    private String secretAccessKey;
    /**
     * @return Security Protocol to be provided for the following connection types:
     * * ELASTICSEARCH, KAFKA, MICROSOFT_SQLSERVER, MYSQL, POSTGRESQL, REDIS
     * * JAVA_MESSAGE_SERVICE - If not provided, default is NONE. Optional until 2024-06-27, in the release after it will be made required.
     * 
     */
    private String securityProtocol;
    /**
     * @return Comma separated list of server addresses, specified as host:port entries, where :port is optional. Example: `&#34;server1.example.com:4000,server2.example.com:4000&#34;`
     * If port is not specified, a default value is set, in case of ELASTICSEARCH: 9200, for REDIS 6379.
     * 
     */
    private String servers;
    private String serviceAccountKeyFile;
    /**
     * @return The mode of the database connection session to be established by the data client. &#39;REDIRECT&#39; - for a RAC database, &#39;DIRECT&#39; - for a non-RAC database. Connection to a RAC database involves a redirection received from the SCAN listeners to the database node to connect to. By default the mode would be DIRECT.
     * 
     */
    private String sessionMode;
    /**
     * @return If set to true, Java Naming and Directory Interface (JNDI) properties should be provided.
     * 
     */
    private Boolean shouldUseJndi;
    /**
     * @return If set to true, the driver validates the certificate that is sent by the database server.
     * 
     */
    private Boolean shouldValidateServerCertificate;
    /**
     * @return Database Certificate - The base64 encoded content of pem file containing the server public key (for 1-way SSL).
     * 
     */
    private String sslCa;
    private String sslCert;
    private String sslClientKeystash;
    private String sslClientKeystoredb;
    private String sslCrl;
    private String sslKey;
    private String sslKeyPassword;
    /**
     * @return SSL mode to be provided for the following connection types: MYSQL, POSTGRESQL.
     * 
     */
    private String sslMode;
    private String sslServerCertificate;
    /**
     * @return Possible lifecycle states for connection.
     * 
     */
    private String state;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the stream pool being referenced.
     * 
     */
    private String streamPoolId;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the target subnet of the dedicated connection.
     * 
     */
    private String subnetId;
    /**
     * @return The system tags associated with this resource, if any. The system tags are set by Oracle Cloud Infrastructure services. Each key is predefined and scoped to namespaces.  For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{orcl-cloud: {free-tier-retain: true}}`
     * 
     */
    private Map<String,String> systemTags;
    /**
     * @return The technology type.
     * 
     */
    private String technologyType;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the related Oracle Cloud Infrastructure tenancy.
     * 
     */
    private String tenancyId;
    /**
     * @return The time the resource was created. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
     * 
     */
    private String timeCreated;
    /**
     * @return The time the resource was last updated. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
     * 
     */
    private String timeUpdated;
    private String trustStore;
    private String trustStorePassword;
    /**
     * @return Kafka Schema Registry URL. e.g.: &#39;https://server1.us.oracle.com:8081&#39;
     * 
     */
    private String url;
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure user who will access the Oracle NoSQL database/Object Storage. The user must have write access to the table they want to connect to.
     * 
     */
    private String userId;
    /**
     * @return The username Oracle GoldenGate uses to connect the associated system of the given technology. This username must already exist and be available by the system/application to be connected to and must conform to the case sensitivity requirements defined in it.
     * 
     */
    private String username;
    /**
     * @return Refers to the customer&#39;s vault OCID.  If provided, it references a vault where GoldenGate can manage secrets. Customers must add policies to permit GoldenGate to manage secrets contained within this vault.
     * 
     */
    private String vaultId;
    private String wallet;

    private GetConnectionResult() {}
    /**
     * @return Access key ID to access the Amazon S3 bucket. e.g.: &#34;this-is-not-the-secret&#34;
     * 
     */
    public String accessKeyId() {
        return this.accessKeyId;
    }
    public String accountKey() {
        return this.accountKey;
    }
    /**
     * @return Sets the Azure storage account name.
     * 
     */
    public String accountName() {
        return this.accountName;
    }
    /**
     * @return An array of name-value pair attribute entries. Used as additional parameters in connection string.
     * 
     */
    public List<GetConnectionAdditionalAttribute> additionalAttributes() {
        return this.additionalAttributes;
    }
    /**
     * @return Authentication mode. It can be provided at creation of Oracle Autonomous Database Serverless connections, when a databaseId is provided. The default value is MTLS.
     * 
     */
    public String authenticationMode() {
        return this.authenticationMode;
    }
    /**
     * @return Used authentication mechanism to be provided for the following connection types:
     * * AZURE_DATA_LAKE_STORAGE, ELASTICSEARCH, KAFKA_SCHEMA_REGISTRY, REDIS, SNOWFLAKE
     * * JAVA_MESSAGE_SERVICE - If not provided, default is NONE. Optional until 2024-06-27, in the release after it will be made required.
     * 
     */
    public String authenticationType() {
        return this.authenticationType;
    }
    /**
     * @return Azure tenant ID of the application. This property is required when &#39;authenticationType&#39; is set to &#39;AZURE_ACTIVE_DIRECTORY&#39;. e.g.: 14593954-d337-4a61-a364-9f758c64f97f
     * 
     */
    public String azureTenantId() {
        return this.azureTenantId;
    }
    /**
     * @return Kafka bootstrap. Equivalent of bootstrap.servers configuration property in Kafka: list of KafkaBootstrapServer objects specified by host/port. Used for establishing the initial connection to the Kafka cluster. Example: `&#34;server1.example.com:9092,server2.example.com:9092&#34;`
     * 
     */
    public List<GetConnectionBootstrapServer> bootstrapServers() {
        return this.bootstrapServers;
    }
    /**
     * @return Azure client ID of the application. This property is required when &#39;authenticationType&#39; is set to &#39;AZURE_ACTIVE_DIRECTORY&#39;. e.g.: 06ecaabf-8b80-4ec8-a0ec-20cbf463703d
     * 
     */
    public String clientId() {
        return this.clientId;
    }
    public String clientSecret() {
        return this.clientSecret;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment being referenced.
     * 
     */
    public String compartmentId() {
        return this.compartmentId;
    }
    /**
     * @return The of Java class implementing javax.jms.ConnectionFactory interface supplied by the Java Message Service provider. e.g.: &#39;com.stc.jmsjca.core.JConnectionFactoryXA&#39;
     * 
     */
    public String connectionFactory() {
        return this.connectionFactory;
    }
    public String connectionId() {
        return this.connectionId;
    }
    /**
     * @return * ORACLE: Connect descriptor or Easy Connect Naming method used to connect to a database.
     * * MONGODB: MongoDB connection string. e.g.: &#39;mongodb://mongodb0.example.com:27017/recordsrecords&#39;
     * * AZURE_SYNAPSE_ANALYTICS: JDBC connection string. e.g.: &#39;jdbc:sqlserver://&lt;synapse-workspace&gt;.sql.azuresynapse.net:1433;database=&lt;db-name&gt;;encrypt=true;trustServerCertificate=false;hostNameInCertificate=*.sql.azuresynapse.net;loginTimeout=300;&#39;
     * 
     */
    public String connectionString() {
        return this.connectionString;
    }
    /**
     * @return The connection type.
     * 
     */
    public String connectionType() {
        return this.connectionType;
    }
    /**
     * @return * JAVA_MESSAGE_SERVICE: Connection URL of the Java Message Service, specifying the protocol, host, and port. e.g.: &#39;mq://myjms.host.domain:7676&#39;
     * * SNOWFLAKE: JDBC connection URL. e.g.: &#39;jdbc:snowflake://&lt;account_name&gt;.snowflakecomputing.com/?warehouse=&lt;warehouse-name&gt;&amp;db=&lt;db-name&gt;&#39;
     * * AMAZON_REDSHIFT: Connection URL. e.g.: &#39;jdbc:redshift://aws-redshift-instance.aaaaaaaaaaaa.us-east-2.redshift.amazonaws.com:5439/mydb&#39;
     * 
     */
    public String connectionUrl() {
        return this.connectionUrl;
    }
    public String consumerProperties() {
        return this.consumerProperties;
    }
    public String coreSiteXml() {
        return this.coreSiteXml;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database being referenced.
     * 
     */
    public String databaseId() {
        return this.databaseId;
    }
    /**
     * @return The name of the database.
     * 
     */
    public String databaseName() {
        return this.databaseName;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database system being referenced.
     * 
     */
    public String dbSystemId() {
        return this.dbSystemId;
    }
    /**
     * @return Tags defined for this resource. Each key is predefined and scoped to a namespace.  Example: `{&#34;foo-namespace.bar-key&#34;: &#34;value&#34;}`
     * 
     */
    public Map<String,String> definedTags() {
        return this.definedTags;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the deployment being referenced.
     * 
     */
    public String deploymentId() {
        return this.deploymentId;
    }
    /**
     * @return Metadata about this specific object.
     * 
     */
    public String description() {
        return this.description;
    }
    /**
     * @return An object&#39;s Display Name.
     * 
     */
    public String displayName() {
        return this.displayName;
    }
    /**
     * @return Azure Storage service endpoint. e.g: https://test.blob.core.windows.net
     * 
     */
    public String endpoint() {
        return this.endpoint;
    }
    public String fingerprint() {
        return this.fingerprint;
    }
    /**
     * @return A simple key-value pair that is applied without any predefined name, type, or scope. Exists for cross-compatibility only.  Example: `{&#34;bar-key&#34;: &#34;value&#34;}`
     * 
     */
    public Map<String,String> freeformTags() {
        return this.freeformTags;
    }
    /**
     * @return The name or address of a host.
     * In case of Generic connection type it represents the Host and port separated by colon. Example: `&#34;server.example.com:1234&#34;`
     * For multiple hosts, provide a comma separated list. Example: `&#34;server1.example.com:1000,server1.example.com:2000&#34;`
     * 
     */
    public String host() {
        return this.host;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the connection being referenced.
     * 
     */
    public String id() {
        return this.id;
    }
    /**
     * @return List of ingress IP addresses from where the GoldenGate deployment connects to this connection&#39;s privateIp.  Customers may optionally set up ingress security rules to restrict traffic from these IP addresses.
     * 
     */
    public List<GetConnectionIngressIp> ingressIps() {
        return this.ingressIps;
    }
    public Boolean isLockOverride() {
        return this.isLockOverride;
    }
    /**
     * @return The Connection Factory can be looked up using this name. e.g.: &#39;ConnectionFactory&#39;
     * 
     */
    public String jndiConnectionFactory() {
        return this.jndiConnectionFactory;
    }
    /**
     * @return The implementation of javax.naming.spi.InitialContextFactory interface that the client uses to obtain initial naming context. e.g.: &#39;org.apache.activemq.jndi.ActiveMQInitialContextFactory&#39;
     * 
     */
    public String jndiInitialContextFactory() {
        return this.jndiInitialContextFactory;
    }
    /**
     * @return The URL that Java Message Service will use to contact the JNDI provider. e.g.: &#39;tcp://myjms.host.domain:61616?jms.prefetchPolicy.all=1000&#39;
     * 
     */
    public String jndiProviderUrl() {
        return this.jndiProviderUrl;
    }
    public String jndiSecurityCredentials() {
        return this.jndiSecurityCredentials;
    }
    /**
     * @return Specifies the identity of the principal (user) to be authenticated. e.g.: &#39;admin2&#39;
     * 
     */
    public String jndiSecurityPrincipal() {
        return this.jndiSecurityPrincipal;
    }
    /**
     * @return Refers to the customer&#39;s master key OCID.  If provided, it references a key to manage secrets. Customers must add policies to permit GoldenGate to use this key.
     * 
     */
    public String keyId() {
        return this.keyId;
    }
    public String keyStore() {
        return this.keyStore;
    }
    public String keyStorePassword() {
        return this.keyStorePassword;
    }
    /**
     * @return Describes the object&#39;s current state in detail. For example, it can be used to provide actionable information for a resource in a Failed state.
     * 
     */
    public String lifecycleDetails() {
        return this.lifecycleDetails;
    }
    /**
     * @return Locks associated with this resource.
     * 
     */
    public List<GetConnectionLock> locks() {
        return this.locks;
    }
    /**
     * @return An array of Network Security Group OCIDs used to define network access for either Deployments or Connections.
     * 
     */
    public List<String> nsgIds() {
        return this.nsgIds;
    }
    public String password() {
        return this.password;
    }
    /**
     * @return The port of an endpoint usually specified for a connection.
     * 
     */
    public Integer port() {
        return this.port;
    }
    /**
     * @return Deprecated: this field will be removed in future versions. Either specify the private IP in the connectionString or host  field, or make sure the host name is resolvable in the target VCN.
     * The private IP address of the connection&#39;s endpoint in the customer&#39;s VCN, typically a database endpoint or a big data endpoint (e.g. Kafka bootstrap server). In case the privateIp is provided, the subnetId must also be provided. In case the privateIp (and the subnetId) is not provided it is assumed the datasource is publicly accessible. In case the connection is accessible only privately, the lack of privateIp will result in not being able to access the connection.
     * 
     */
    public String privateIp() {
        return this.privateIp;
    }
    public String privateKeyFile() {
        return this.privateKeyFile;
    }
    public String privateKeyPassphrase() {
        return this.privateKeyPassphrase;
    }
    public String producerProperties() {
        return this.producerProperties;
    }
    public String publicKeyFingerprint() {
        return this.publicKeyFingerprint;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Redis cluster.
     * 
     */
    public String redisClusterId() {
        return this.redisClusterId;
    }
    /**
     * @return The name of the region. e.g.: us-ashburn-1
     * 
     */
    public String region() {
        return this.region;
    }
    /**
     * @return Controls the network traffic direction to the target: SHARED_SERVICE_ENDPOINT: Traffic flows through the Goldengate Service&#39;s network to public hosts. Cannot be used for private targets.  SHARED_DEPLOYMENT_ENDPOINT: Network traffic flows from the assigned deployment&#39;s private endpoint through the deployment&#39;s subnet. DEDICATED_ENDPOINT: A dedicated private endpoint is created in the target VCN subnet for the connection. The subnetId is required when DEDICATED_ENDPOINT networking is selected.
     * 
     */
    public String routingMethod() {
        return this.routingMethod;
    }
    public String sasToken() {
        return this.sasToken;
    }
    public String secretAccessKey() {
        return this.secretAccessKey;
    }
    /**
     * @return Security Protocol to be provided for the following connection types:
     * * ELASTICSEARCH, KAFKA, MICROSOFT_SQLSERVER, MYSQL, POSTGRESQL, REDIS
     * * JAVA_MESSAGE_SERVICE - If not provided, default is NONE. Optional until 2024-06-27, in the release after it will be made required.
     * 
     */
    public String securityProtocol() {
        return this.securityProtocol;
    }
    /**
     * @return Comma separated list of server addresses, specified as host:port entries, where :port is optional. Example: `&#34;server1.example.com:4000,server2.example.com:4000&#34;`
     * If port is not specified, a default value is set, in case of ELASTICSEARCH: 9200, for REDIS 6379.
     * 
     */
    public String servers() {
        return this.servers;
    }
    public String serviceAccountKeyFile() {
        return this.serviceAccountKeyFile;
    }
    /**
     * @return The mode of the database connection session to be established by the data client. &#39;REDIRECT&#39; - for a RAC database, &#39;DIRECT&#39; - for a non-RAC database. Connection to a RAC database involves a redirection received from the SCAN listeners to the database node to connect to. By default the mode would be DIRECT.
     * 
     */
    public String sessionMode() {
        return this.sessionMode;
    }
    /**
     * @return If set to true, Java Naming and Directory Interface (JNDI) properties should be provided.
     * 
     */
    public Boolean shouldUseJndi() {
        return this.shouldUseJndi;
    }
    /**
     * @return If set to true, the driver validates the certificate that is sent by the database server.
     * 
     */
    public Boolean shouldValidateServerCertificate() {
        return this.shouldValidateServerCertificate;
    }
    /**
     * @return Database Certificate - The base64 encoded content of pem file containing the server public key (for 1-way SSL).
     * 
     */
    public String sslCa() {
        return this.sslCa;
    }
    public String sslCert() {
        return this.sslCert;
    }
    public String sslClientKeystash() {
        return this.sslClientKeystash;
    }
    public String sslClientKeystoredb() {
        return this.sslClientKeystoredb;
    }
    public String sslCrl() {
        return this.sslCrl;
    }
    public String sslKey() {
        return this.sslKey;
    }
    public String sslKeyPassword() {
        return this.sslKeyPassword;
    }
    /**
     * @return SSL mode to be provided for the following connection types: MYSQL, POSTGRESQL.
     * 
     */
    public String sslMode() {
        return this.sslMode;
    }
    public String sslServerCertificate() {
        return this.sslServerCertificate;
    }
    /**
     * @return Possible lifecycle states for connection.
     * 
     */
    public String state() {
        return this.state;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the stream pool being referenced.
     * 
     */
    public String streamPoolId() {
        return this.streamPoolId;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the target subnet of the dedicated connection.
     * 
     */
    public String subnetId() {
        return this.subnetId;
    }
    /**
     * @return The system tags associated with this resource, if any. The system tags are set by Oracle Cloud Infrastructure services. Each key is predefined and scoped to namespaces.  For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{orcl-cloud: {free-tier-retain: true}}`
     * 
     */
    public Map<String,String> systemTags() {
        return this.systemTags;
    }
    /**
     * @return The technology type.
     * 
     */
    public String technologyType() {
        return this.technologyType;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the related Oracle Cloud Infrastructure tenancy.
     * 
     */
    public String tenancyId() {
        return this.tenancyId;
    }
    /**
     * @return The time the resource was created. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
     * 
     */
    public String timeCreated() {
        return this.timeCreated;
    }
    /**
     * @return The time the resource was last updated. The format is defined by [RFC3339](https://tools.ietf.org/html/rfc3339), such as `2016-08-25T21:10:29.600Z`.
     * 
     */
    public String timeUpdated() {
        return this.timeUpdated;
    }
    public String trustStore() {
        return this.trustStore;
    }
    public String trustStorePassword() {
        return this.trustStorePassword;
    }
    /**
     * @return Kafka Schema Registry URL. e.g.: &#39;https://server1.us.oracle.com:8081&#39;
     * 
     */
    public String url() {
        return this.url;
    }
    /**
     * @return The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure user who will access the Oracle NoSQL database/Object Storage. The user must have write access to the table they want to connect to.
     * 
     */
    public String userId() {
        return this.userId;
    }
    /**
     * @return The username Oracle GoldenGate uses to connect the associated system of the given technology. This username must already exist and be available by the system/application to be connected to and must conform to the case sensitivity requirements defined in it.
     * 
     */
    public String username() {
        return this.username;
    }
    /**
     * @return Refers to the customer&#39;s vault OCID.  If provided, it references a vault where GoldenGate can manage secrets. Customers must add policies to permit GoldenGate to manage secrets contained within this vault.
     * 
     */
    public String vaultId() {
        return this.vaultId;
    }
    public String wallet() {
        return this.wallet;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetConnectionResult defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String accessKeyId;
        private String accountKey;
        private String accountName;
        private List<GetConnectionAdditionalAttribute> additionalAttributes;
        private String authenticationMode;
        private String authenticationType;
        private String azureTenantId;
        private List<GetConnectionBootstrapServer> bootstrapServers;
        private String clientId;
        private String clientSecret;
        private String compartmentId;
        private String connectionFactory;
        private String connectionId;
        private String connectionString;
        private String connectionType;
        private String connectionUrl;
        private String consumerProperties;
        private String coreSiteXml;
        private String databaseId;
        private String databaseName;
        private String dbSystemId;
        private Map<String,String> definedTags;
        private String deploymentId;
        private String description;
        private String displayName;
        private String endpoint;
        private String fingerprint;
        private Map<String,String> freeformTags;
        private String host;
        private String id;
        private List<GetConnectionIngressIp> ingressIps;
        private Boolean isLockOverride;
        private String jndiConnectionFactory;
        private String jndiInitialContextFactory;
        private String jndiProviderUrl;
        private String jndiSecurityCredentials;
        private String jndiSecurityPrincipal;
        private String keyId;
        private String keyStore;
        private String keyStorePassword;
        private String lifecycleDetails;
        private List<GetConnectionLock> locks;
        private List<String> nsgIds;
        private String password;
        private Integer port;
        private String privateIp;
        private String privateKeyFile;
        private String privateKeyPassphrase;
        private String producerProperties;
        private String publicKeyFingerprint;
        private String redisClusterId;
        private String region;
        private String routingMethod;
        private String sasToken;
        private String secretAccessKey;
        private String securityProtocol;
        private String servers;
        private String serviceAccountKeyFile;
        private String sessionMode;
        private Boolean shouldUseJndi;
        private Boolean shouldValidateServerCertificate;
        private String sslCa;
        private String sslCert;
        private String sslClientKeystash;
        private String sslClientKeystoredb;
        private String sslCrl;
        private String sslKey;
        private String sslKeyPassword;
        private String sslMode;
        private String sslServerCertificate;
        private String state;
        private String streamPoolId;
        private String subnetId;
        private Map<String,String> systemTags;
        private String technologyType;
        private String tenancyId;
        private String timeCreated;
        private String timeUpdated;
        private String trustStore;
        private String trustStorePassword;
        private String url;
        private String userId;
        private String username;
        private String vaultId;
        private String wallet;
        public Builder() {}
        public Builder(GetConnectionResult defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.accessKeyId = defaults.accessKeyId;
    	      this.accountKey = defaults.accountKey;
    	      this.accountName = defaults.accountName;
    	      this.additionalAttributes = defaults.additionalAttributes;
    	      this.authenticationMode = defaults.authenticationMode;
    	      this.authenticationType = defaults.authenticationType;
    	      this.azureTenantId = defaults.azureTenantId;
    	      this.bootstrapServers = defaults.bootstrapServers;
    	      this.clientId = defaults.clientId;
    	      this.clientSecret = defaults.clientSecret;
    	      this.compartmentId = defaults.compartmentId;
    	      this.connectionFactory = defaults.connectionFactory;
    	      this.connectionId = defaults.connectionId;
    	      this.connectionString = defaults.connectionString;
    	      this.connectionType = defaults.connectionType;
    	      this.connectionUrl = defaults.connectionUrl;
    	      this.consumerProperties = defaults.consumerProperties;
    	      this.coreSiteXml = defaults.coreSiteXml;
    	      this.databaseId = defaults.databaseId;
    	      this.databaseName = defaults.databaseName;
    	      this.dbSystemId = defaults.dbSystemId;
    	      this.definedTags = defaults.definedTags;
    	      this.deploymentId = defaults.deploymentId;
    	      this.description = defaults.description;
    	      this.displayName = defaults.displayName;
    	      this.endpoint = defaults.endpoint;
    	      this.fingerprint = defaults.fingerprint;
    	      this.freeformTags = defaults.freeformTags;
    	      this.host = defaults.host;
    	      this.id = defaults.id;
    	      this.ingressIps = defaults.ingressIps;
    	      this.isLockOverride = defaults.isLockOverride;
    	      this.jndiConnectionFactory = defaults.jndiConnectionFactory;
    	      this.jndiInitialContextFactory = defaults.jndiInitialContextFactory;
    	      this.jndiProviderUrl = defaults.jndiProviderUrl;
    	      this.jndiSecurityCredentials = defaults.jndiSecurityCredentials;
    	      this.jndiSecurityPrincipal = defaults.jndiSecurityPrincipal;
    	      this.keyId = defaults.keyId;
    	      this.keyStore = defaults.keyStore;
    	      this.keyStorePassword = defaults.keyStorePassword;
    	      this.lifecycleDetails = defaults.lifecycleDetails;
    	      this.locks = defaults.locks;
    	      this.nsgIds = defaults.nsgIds;
    	      this.password = defaults.password;
    	      this.port = defaults.port;
    	      this.privateIp = defaults.privateIp;
    	      this.privateKeyFile = defaults.privateKeyFile;
    	      this.privateKeyPassphrase = defaults.privateKeyPassphrase;
    	      this.producerProperties = defaults.producerProperties;
    	      this.publicKeyFingerprint = defaults.publicKeyFingerprint;
    	      this.redisClusterId = defaults.redisClusterId;
    	      this.region = defaults.region;
    	      this.routingMethod = defaults.routingMethod;
    	      this.sasToken = defaults.sasToken;
    	      this.secretAccessKey = defaults.secretAccessKey;
    	      this.securityProtocol = defaults.securityProtocol;
    	      this.servers = defaults.servers;
    	      this.serviceAccountKeyFile = defaults.serviceAccountKeyFile;
    	      this.sessionMode = defaults.sessionMode;
    	      this.shouldUseJndi = defaults.shouldUseJndi;
    	      this.shouldValidateServerCertificate = defaults.shouldValidateServerCertificate;
    	      this.sslCa = defaults.sslCa;
    	      this.sslCert = defaults.sslCert;
    	      this.sslClientKeystash = defaults.sslClientKeystash;
    	      this.sslClientKeystoredb = defaults.sslClientKeystoredb;
    	      this.sslCrl = defaults.sslCrl;
    	      this.sslKey = defaults.sslKey;
    	      this.sslKeyPassword = defaults.sslKeyPassword;
    	      this.sslMode = defaults.sslMode;
    	      this.sslServerCertificate = defaults.sslServerCertificate;
    	      this.state = defaults.state;
    	      this.streamPoolId = defaults.streamPoolId;
    	      this.subnetId = defaults.subnetId;
    	      this.systemTags = defaults.systemTags;
    	      this.technologyType = defaults.technologyType;
    	      this.tenancyId = defaults.tenancyId;
    	      this.timeCreated = defaults.timeCreated;
    	      this.timeUpdated = defaults.timeUpdated;
    	      this.trustStore = defaults.trustStore;
    	      this.trustStorePassword = defaults.trustStorePassword;
    	      this.url = defaults.url;
    	      this.userId = defaults.userId;
    	      this.username = defaults.username;
    	      this.vaultId = defaults.vaultId;
    	      this.wallet = defaults.wallet;
        }

        @CustomType.Setter
        public Builder accessKeyId(String accessKeyId) {
            if (accessKeyId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "accessKeyId");
            }
            this.accessKeyId = accessKeyId;
            return this;
        }
        @CustomType.Setter
        public Builder accountKey(String accountKey) {
            if (accountKey == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "accountKey");
            }
            this.accountKey = accountKey;
            return this;
        }
        @CustomType.Setter
        public Builder accountName(String accountName) {
            if (accountName == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "accountName");
            }
            this.accountName = accountName;
            return this;
        }
        @CustomType.Setter
        public Builder additionalAttributes(List<GetConnectionAdditionalAttribute> additionalAttributes) {
            if (additionalAttributes == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "additionalAttributes");
            }
            this.additionalAttributes = additionalAttributes;
            return this;
        }
        public Builder additionalAttributes(GetConnectionAdditionalAttribute... additionalAttributes) {
            return additionalAttributes(List.of(additionalAttributes));
        }
        @CustomType.Setter
        public Builder authenticationMode(String authenticationMode) {
            if (authenticationMode == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "authenticationMode");
            }
            this.authenticationMode = authenticationMode;
            return this;
        }
        @CustomType.Setter
        public Builder authenticationType(String authenticationType) {
            if (authenticationType == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "authenticationType");
            }
            this.authenticationType = authenticationType;
            return this;
        }
        @CustomType.Setter
        public Builder azureTenantId(String azureTenantId) {
            if (azureTenantId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "azureTenantId");
            }
            this.azureTenantId = azureTenantId;
            return this;
        }
        @CustomType.Setter
        public Builder bootstrapServers(List<GetConnectionBootstrapServer> bootstrapServers) {
            if (bootstrapServers == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "bootstrapServers");
            }
            this.bootstrapServers = bootstrapServers;
            return this;
        }
        public Builder bootstrapServers(GetConnectionBootstrapServer... bootstrapServers) {
            return bootstrapServers(List.of(bootstrapServers));
        }
        @CustomType.Setter
        public Builder clientId(String clientId) {
            if (clientId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "clientId");
            }
            this.clientId = clientId;
            return this;
        }
        @CustomType.Setter
        public Builder clientSecret(String clientSecret) {
            if (clientSecret == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "clientSecret");
            }
            this.clientSecret = clientSecret;
            return this;
        }
        @CustomType.Setter
        public Builder compartmentId(String compartmentId) {
            if (compartmentId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "compartmentId");
            }
            this.compartmentId = compartmentId;
            return this;
        }
        @CustomType.Setter
        public Builder connectionFactory(String connectionFactory) {
            if (connectionFactory == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "connectionFactory");
            }
            this.connectionFactory = connectionFactory;
            return this;
        }
        @CustomType.Setter
        public Builder connectionId(String connectionId) {
            if (connectionId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "connectionId");
            }
            this.connectionId = connectionId;
            return this;
        }
        @CustomType.Setter
        public Builder connectionString(String connectionString) {
            if (connectionString == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "connectionString");
            }
            this.connectionString = connectionString;
            return this;
        }
        @CustomType.Setter
        public Builder connectionType(String connectionType) {
            if (connectionType == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "connectionType");
            }
            this.connectionType = connectionType;
            return this;
        }
        @CustomType.Setter
        public Builder connectionUrl(String connectionUrl) {
            if (connectionUrl == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "connectionUrl");
            }
            this.connectionUrl = connectionUrl;
            return this;
        }
        @CustomType.Setter
        public Builder consumerProperties(String consumerProperties) {
            if (consumerProperties == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "consumerProperties");
            }
            this.consumerProperties = consumerProperties;
            return this;
        }
        @CustomType.Setter
        public Builder coreSiteXml(String coreSiteXml) {
            if (coreSiteXml == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "coreSiteXml");
            }
            this.coreSiteXml = coreSiteXml;
            return this;
        }
        @CustomType.Setter
        public Builder databaseId(String databaseId) {
            if (databaseId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "databaseId");
            }
            this.databaseId = databaseId;
            return this;
        }
        @CustomType.Setter
        public Builder databaseName(String databaseName) {
            if (databaseName == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "databaseName");
            }
            this.databaseName = databaseName;
            return this;
        }
        @CustomType.Setter
        public Builder dbSystemId(String dbSystemId) {
            if (dbSystemId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "dbSystemId");
            }
            this.dbSystemId = dbSystemId;
            return this;
        }
        @CustomType.Setter
        public Builder definedTags(Map<String,String> definedTags) {
            if (definedTags == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "definedTags");
            }
            this.definedTags = definedTags;
            return this;
        }
        @CustomType.Setter
        public Builder deploymentId(String deploymentId) {
            if (deploymentId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "deploymentId");
            }
            this.deploymentId = deploymentId;
            return this;
        }
        @CustomType.Setter
        public Builder description(String description) {
            if (description == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "description");
            }
            this.description = description;
            return this;
        }
        @CustomType.Setter
        public Builder displayName(String displayName) {
            if (displayName == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "displayName");
            }
            this.displayName = displayName;
            return this;
        }
        @CustomType.Setter
        public Builder endpoint(String endpoint) {
            if (endpoint == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "endpoint");
            }
            this.endpoint = endpoint;
            return this;
        }
        @CustomType.Setter
        public Builder fingerprint(String fingerprint) {
            if (fingerprint == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "fingerprint");
            }
            this.fingerprint = fingerprint;
            return this;
        }
        @CustomType.Setter
        public Builder freeformTags(Map<String,String> freeformTags) {
            if (freeformTags == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "freeformTags");
            }
            this.freeformTags = freeformTags;
            return this;
        }
        @CustomType.Setter
        public Builder host(String host) {
            if (host == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "host");
            }
            this.host = host;
            return this;
        }
        @CustomType.Setter
        public Builder id(String id) {
            if (id == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "id");
            }
            this.id = id;
            return this;
        }
        @CustomType.Setter
        public Builder ingressIps(List<GetConnectionIngressIp> ingressIps) {
            if (ingressIps == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "ingressIps");
            }
            this.ingressIps = ingressIps;
            return this;
        }
        public Builder ingressIps(GetConnectionIngressIp... ingressIps) {
            return ingressIps(List.of(ingressIps));
        }
        @CustomType.Setter
        public Builder isLockOverride(Boolean isLockOverride) {
            if (isLockOverride == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "isLockOverride");
            }
            this.isLockOverride = isLockOverride;
            return this;
        }
        @CustomType.Setter
        public Builder jndiConnectionFactory(String jndiConnectionFactory) {
            if (jndiConnectionFactory == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "jndiConnectionFactory");
            }
            this.jndiConnectionFactory = jndiConnectionFactory;
            return this;
        }
        @CustomType.Setter
        public Builder jndiInitialContextFactory(String jndiInitialContextFactory) {
            if (jndiInitialContextFactory == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "jndiInitialContextFactory");
            }
            this.jndiInitialContextFactory = jndiInitialContextFactory;
            return this;
        }
        @CustomType.Setter
        public Builder jndiProviderUrl(String jndiProviderUrl) {
            if (jndiProviderUrl == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "jndiProviderUrl");
            }
            this.jndiProviderUrl = jndiProviderUrl;
            return this;
        }
        @CustomType.Setter
        public Builder jndiSecurityCredentials(String jndiSecurityCredentials) {
            if (jndiSecurityCredentials == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "jndiSecurityCredentials");
            }
            this.jndiSecurityCredentials = jndiSecurityCredentials;
            return this;
        }
        @CustomType.Setter
        public Builder jndiSecurityPrincipal(String jndiSecurityPrincipal) {
            if (jndiSecurityPrincipal == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "jndiSecurityPrincipal");
            }
            this.jndiSecurityPrincipal = jndiSecurityPrincipal;
            return this;
        }
        @CustomType.Setter
        public Builder keyId(String keyId) {
            if (keyId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "keyId");
            }
            this.keyId = keyId;
            return this;
        }
        @CustomType.Setter
        public Builder keyStore(String keyStore) {
            if (keyStore == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "keyStore");
            }
            this.keyStore = keyStore;
            return this;
        }
        @CustomType.Setter
        public Builder keyStorePassword(String keyStorePassword) {
            if (keyStorePassword == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "keyStorePassword");
            }
            this.keyStorePassword = keyStorePassword;
            return this;
        }
        @CustomType.Setter
        public Builder lifecycleDetails(String lifecycleDetails) {
            if (lifecycleDetails == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "lifecycleDetails");
            }
            this.lifecycleDetails = lifecycleDetails;
            return this;
        }
        @CustomType.Setter
        public Builder locks(List<GetConnectionLock> locks) {
            if (locks == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "locks");
            }
            this.locks = locks;
            return this;
        }
        public Builder locks(GetConnectionLock... locks) {
            return locks(List.of(locks));
        }
        @CustomType.Setter
        public Builder nsgIds(List<String> nsgIds) {
            if (nsgIds == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "nsgIds");
            }
            this.nsgIds = nsgIds;
            return this;
        }
        public Builder nsgIds(String... nsgIds) {
            return nsgIds(List.of(nsgIds));
        }
        @CustomType.Setter
        public Builder password(String password) {
            if (password == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "password");
            }
            this.password = password;
            return this;
        }
        @CustomType.Setter
        public Builder port(Integer port) {
            if (port == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "port");
            }
            this.port = port;
            return this;
        }
        @CustomType.Setter
        public Builder privateIp(String privateIp) {
            if (privateIp == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "privateIp");
            }
            this.privateIp = privateIp;
            return this;
        }
        @CustomType.Setter
        public Builder privateKeyFile(String privateKeyFile) {
            if (privateKeyFile == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "privateKeyFile");
            }
            this.privateKeyFile = privateKeyFile;
            return this;
        }
        @CustomType.Setter
        public Builder privateKeyPassphrase(String privateKeyPassphrase) {
            if (privateKeyPassphrase == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "privateKeyPassphrase");
            }
            this.privateKeyPassphrase = privateKeyPassphrase;
            return this;
        }
        @CustomType.Setter
        public Builder producerProperties(String producerProperties) {
            if (producerProperties == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "producerProperties");
            }
            this.producerProperties = producerProperties;
            return this;
        }
        @CustomType.Setter
        public Builder publicKeyFingerprint(String publicKeyFingerprint) {
            if (publicKeyFingerprint == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "publicKeyFingerprint");
            }
            this.publicKeyFingerprint = publicKeyFingerprint;
            return this;
        }
        @CustomType.Setter
        public Builder redisClusterId(String redisClusterId) {
            if (redisClusterId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "redisClusterId");
            }
            this.redisClusterId = redisClusterId;
            return this;
        }
        @CustomType.Setter
        public Builder region(String region) {
            if (region == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "region");
            }
            this.region = region;
            return this;
        }
        @CustomType.Setter
        public Builder routingMethod(String routingMethod) {
            if (routingMethod == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "routingMethod");
            }
            this.routingMethod = routingMethod;
            return this;
        }
        @CustomType.Setter
        public Builder sasToken(String sasToken) {
            if (sasToken == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "sasToken");
            }
            this.sasToken = sasToken;
            return this;
        }
        @CustomType.Setter
        public Builder secretAccessKey(String secretAccessKey) {
            if (secretAccessKey == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "secretAccessKey");
            }
            this.secretAccessKey = secretAccessKey;
            return this;
        }
        @CustomType.Setter
        public Builder securityProtocol(String securityProtocol) {
            if (securityProtocol == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "securityProtocol");
            }
            this.securityProtocol = securityProtocol;
            return this;
        }
        @CustomType.Setter
        public Builder servers(String servers) {
            if (servers == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "servers");
            }
            this.servers = servers;
            return this;
        }
        @CustomType.Setter
        public Builder serviceAccountKeyFile(String serviceAccountKeyFile) {
            if (serviceAccountKeyFile == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "serviceAccountKeyFile");
            }
            this.serviceAccountKeyFile = serviceAccountKeyFile;
            return this;
        }
        @CustomType.Setter
        public Builder sessionMode(String sessionMode) {
            if (sessionMode == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "sessionMode");
            }
            this.sessionMode = sessionMode;
            return this;
        }
        @CustomType.Setter
        public Builder shouldUseJndi(Boolean shouldUseJndi) {
            if (shouldUseJndi == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "shouldUseJndi");
            }
            this.shouldUseJndi = shouldUseJndi;
            return this;
        }
        @CustomType.Setter
        public Builder shouldValidateServerCertificate(Boolean shouldValidateServerCertificate) {
            if (shouldValidateServerCertificate == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "shouldValidateServerCertificate");
            }
            this.shouldValidateServerCertificate = shouldValidateServerCertificate;
            return this;
        }
        @CustomType.Setter
        public Builder sslCa(String sslCa) {
            if (sslCa == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "sslCa");
            }
            this.sslCa = sslCa;
            return this;
        }
        @CustomType.Setter
        public Builder sslCert(String sslCert) {
            if (sslCert == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "sslCert");
            }
            this.sslCert = sslCert;
            return this;
        }
        @CustomType.Setter
        public Builder sslClientKeystash(String sslClientKeystash) {
            if (sslClientKeystash == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "sslClientKeystash");
            }
            this.sslClientKeystash = sslClientKeystash;
            return this;
        }
        @CustomType.Setter
        public Builder sslClientKeystoredb(String sslClientKeystoredb) {
            if (sslClientKeystoredb == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "sslClientKeystoredb");
            }
            this.sslClientKeystoredb = sslClientKeystoredb;
            return this;
        }
        @CustomType.Setter
        public Builder sslCrl(String sslCrl) {
            if (sslCrl == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "sslCrl");
            }
            this.sslCrl = sslCrl;
            return this;
        }
        @CustomType.Setter
        public Builder sslKey(String sslKey) {
            if (sslKey == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "sslKey");
            }
            this.sslKey = sslKey;
            return this;
        }
        @CustomType.Setter
        public Builder sslKeyPassword(String sslKeyPassword) {
            if (sslKeyPassword == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "sslKeyPassword");
            }
            this.sslKeyPassword = sslKeyPassword;
            return this;
        }
        @CustomType.Setter
        public Builder sslMode(String sslMode) {
            if (sslMode == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "sslMode");
            }
            this.sslMode = sslMode;
            return this;
        }
        @CustomType.Setter
        public Builder sslServerCertificate(String sslServerCertificate) {
            if (sslServerCertificate == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "sslServerCertificate");
            }
            this.sslServerCertificate = sslServerCertificate;
            return this;
        }
        @CustomType.Setter
        public Builder state(String state) {
            if (state == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "state");
            }
            this.state = state;
            return this;
        }
        @CustomType.Setter
        public Builder streamPoolId(String streamPoolId) {
            if (streamPoolId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "streamPoolId");
            }
            this.streamPoolId = streamPoolId;
            return this;
        }
        @CustomType.Setter
        public Builder subnetId(String subnetId) {
            if (subnetId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "subnetId");
            }
            this.subnetId = subnetId;
            return this;
        }
        @CustomType.Setter
        public Builder systemTags(Map<String,String> systemTags) {
            if (systemTags == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "systemTags");
            }
            this.systemTags = systemTags;
            return this;
        }
        @CustomType.Setter
        public Builder technologyType(String technologyType) {
            if (technologyType == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "technologyType");
            }
            this.technologyType = technologyType;
            return this;
        }
        @CustomType.Setter
        public Builder tenancyId(String tenancyId) {
            if (tenancyId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "tenancyId");
            }
            this.tenancyId = tenancyId;
            return this;
        }
        @CustomType.Setter
        public Builder timeCreated(String timeCreated) {
            if (timeCreated == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "timeCreated");
            }
            this.timeCreated = timeCreated;
            return this;
        }
        @CustomType.Setter
        public Builder timeUpdated(String timeUpdated) {
            if (timeUpdated == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "timeUpdated");
            }
            this.timeUpdated = timeUpdated;
            return this;
        }
        @CustomType.Setter
        public Builder trustStore(String trustStore) {
            if (trustStore == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "trustStore");
            }
            this.trustStore = trustStore;
            return this;
        }
        @CustomType.Setter
        public Builder trustStorePassword(String trustStorePassword) {
            if (trustStorePassword == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "trustStorePassword");
            }
            this.trustStorePassword = trustStorePassword;
            return this;
        }
        @CustomType.Setter
        public Builder url(String url) {
            if (url == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "url");
            }
            this.url = url;
            return this;
        }
        @CustomType.Setter
        public Builder userId(String userId) {
            if (userId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "userId");
            }
            this.userId = userId;
            return this;
        }
        @CustomType.Setter
        public Builder username(String username) {
            if (username == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "username");
            }
            this.username = username;
            return this;
        }
        @CustomType.Setter
        public Builder vaultId(String vaultId) {
            if (vaultId == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "vaultId");
            }
            this.vaultId = vaultId;
            return this;
        }
        @CustomType.Setter
        public Builder wallet(String wallet) {
            if (wallet == null) {
              throw new MissingRequiredPropertyException("GetConnectionResult", "wallet");
            }
            this.wallet = wallet;
            return this;
        }
        public GetConnectionResult build() {
            final var _resultValue = new GetConnectionResult();
            _resultValue.accessKeyId = accessKeyId;
            _resultValue.accountKey = accountKey;
            _resultValue.accountName = accountName;
            _resultValue.additionalAttributes = additionalAttributes;
            _resultValue.authenticationMode = authenticationMode;
            _resultValue.authenticationType = authenticationType;
            _resultValue.azureTenantId = azureTenantId;
            _resultValue.bootstrapServers = bootstrapServers;
            _resultValue.clientId = clientId;
            _resultValue.clientSecret = clientSecret;
            _resultValue.compartmentId = compartmentId;
            _resultValue.connectionFactory = connectionFactory;
            _resultValue.connectionId = connectionId;
            _resultValue.connectionString = connectionString;
            _resultValue.connectionType = connectionType;
            _resultValue.connectionUrl = connectionUrl;
            _resultValue.consumerProperties = consumerProperties;
            _resultValue.coreSiteXml = coreSiteXml;
            _resultValue.databaseId = databaseId;
            _resultValue.databaseName = databaseName;
            _resultValue.dbSystemId = dbSystemId;
            _resultValue.definedTags = definedTags;
            _resultValue.deploymentId = deploymentId;
            _resultValue.description = description;
            _resultValue.displayName = displayName;
            _resultValue.endpoint = endpoint;
            _resultValue.fingerprint = fingerprint;
            _resultValue.freeformTags = freeformTags;
            _resultValue.host = host;
            _resultValue.id = id;
            _resultValue.ingressIps = ingressIps;
            _resultValue.isLockOverride = isLockOverride;
            _resultValue.jndiConnectionFactory = jndiConnectionFactory;
            _resultValue.jndiInitialContextFactory = jndiInitialContextFactory;
            _resultValue.jndiProviderUrl = jndiProviderUrl;
            _resultValue.jndiSecurityCredentials = jndiSecurityCredentials;
            _resultValue.jndiSecurityPrincipal = jndiSecurityPrincipal;
            _resultValue.keyId = keyId;
            _resultValue.keyStore = keyStore;
            _resultValue.keyStorePassword = keyStorePassword;
            _resultValue.lifecycleDetails = lifecycleDetails;
            _resultValue.locks = locks;
            _resultValue.nsgIds = nsgIds;
            _resultValue.password = password;
            _resultValue.port = port;
            _resultValue.privateIp = privateIp;
            _resultValue.privateKeyFile = privateKeyFile;
            _resultValue.privateKeyPassphrase = privateKeyPassphrase;
            _resultValue.producerProperties = producerProperties;
            _resultValue.publicKeyFingerprint = publicKeyFingerprint;
            _resultValue.redisClusterId = redisClusterId;
            _resultValue.region = region;
            _resultValue.routingMethod = routingMethod;
            _resultValue.sasToken = sasToken;
            _resultValue.secretAccessKey = secretAccessKey;
            _resultValue.securityProtocol = securityProtocol;
            _resultValue.servers = servers;
            _resultValue.serviceAccountKeyFile = serviceAccountKeyFile;
            _resultValue.sessionMode = sessionMode;
            _resultValue.shouldUseJndi = shouldUseJndi;
            _resultValue.shouldValidateServerCertificate = shouldValidateServerCertificate;
            _resultValue.sslCa = sslCa;
            _resultValue.sslCert = sslCert;
            _resultValue.sslClientKeystash = sslClientKeystash;
            _resultValue.sslClientKeystoredb = sslClientKeystoredb;
            _resultValue.sslCrl = sslCrl;
            _resultValue.sslKey = sslKey;
            _resultValue.sslKeyPassword = sslKeyPassword;
            _resultValue.sslMode = sslMode;
            _resultValue.sslServerCertificate = sslServerCertificate;
            _resultValue.state = state;
            _resultValue.streamPoolId = streamPoolId;
            _resultValue.subnetId = subnetId;
            _resultValue.systemTags = systemTags;
            _resultValue.technologyType = technologyType;
            _resultValue.tenancyId = tenancyId;
            _resultValue.timeCreated = timeCreated;
            _resultValue.timeUpdated = timeUpdated;
            _resultValue.trustStore = trustStore;
            _resultValue.trustStorePassword = trustStorePassword;
            _resultValue.url = url;
            _resultValue.userId = userId;
            _resultValue.username = username;
            _resultValue.vaultId = vaultId;
            _resultValue.wallet = wallet;
            return _resultValue;
        }
    }
}
