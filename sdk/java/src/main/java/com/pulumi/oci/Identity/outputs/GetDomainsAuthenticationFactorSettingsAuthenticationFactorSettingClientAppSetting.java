// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.oci.Identity.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;

@CustomType
public final class GetDomainsAuthenticationFactorSettingsAuthenticationFactorSettingClientAppSetting {
    /**
     * @return Indicates what protection policy that the system applies on a device. By default, the value is NONE, which indicates that the system applies no protection policy. A value of APP_PIN indicates that the system requires a Personal Identification Number (PIN). A value of DEVICE_BIOMETRIC_OR_APP_PIN indicates that either a PIN or a biometric authentication factor is required.
     * 
     */
    private String deviceProtectionPolicy;
    /**
     * @return The period of time in seconds that the system will lock a user out of the service after that user exceeds the maximum number of login failures
     * 
     */
    private Integer initialLockoutPeriodInSecs;
    /**
     * @return The size of the key that the system uses to generate the public-private key pair
     * 
     */
    private Integer keyPairLength;
    /**
     * @return The pattern of escalation that the system follows, in locking a particular user out of the service.
     * 
     */
    private String lockoutEscalationPattern;
    /**
     * @return The maximum number of times that a particular user can fail to login before the system locks that user out of the service
     * 
     */
    private Integer maxFailuresBeforeLockout;
    /**
     * @return The maximum number of login failures that the system will allow before raising a warning and sending an alert via email
     * 
     */
    private Integer maxFailuresBeforeWarning;
    /**
     * @return The maximum period of time that the system will lock a particular user out of the service regardless of what the configured pattern of escalation would otherwise dictate
     * 
     */
    private Integer maxLockoutIntervalInSecs;
    /**
     * @return Minimum length of the Personal Identification Number (PIN)
     * 
     */
    private Integer minPinLength;
    /**
     * @return The period of time in days after which a client should refresh its policy by re-reading that policy from the server
     * 
     */
    private Integer policyUpdateFreqInDays;
    /**
     * @return Indicates which algorithm the system will use to sign requests
     * 
     */
    private String requestSigningAlgo;
    /**
     * @return Indicates the type of encoding that the system should use to generate a shared secret
     * 
     */
    private String sharedSecretEncoding;
    /**
     * @return If true, indicates that the system should require the user to unlock the client app for each request. In order to unlock the App, the user must supply a Personal Identification Number (PIN) or a biometric authentication-factor.
     * 
     */
    private Boolean unlockAppForEachRequestEnabled;
    /**
     * @return Specifies the period of time in seconds after which the client App should require the user to unlock the App. In order to unlock the App, the user must supply a Personal Identification Number (PIN) or a biometric authentication-factor. A value of zero means that it is disabled.
     * 
     */
    private Integer unlockAppIntervalInSecs;
    /**
     * @return If true, indicates that the system should require the user to unlock the client App, when the client App comes to the foreground in the display of the device. In order to unlock the App, the user must supply a Personal Identification Number (PIN) or a biometric authentication-factor.
     * 
     */
    private Boolean unlockOnAppForegroundEnabled;
    /**
     * @return If true, indicates that the system should require the user to unlock the client App whenever the App is started. In order to unlock the App, the user must supply a Personal Identification Number (PIN) or a biometric authentication-factor.
     * 
     */
    private Boolean unlockOnAppStartEnabled;

    private GetDomainsAuthenticationFactorSettingsAuthenticationFactorSettingClientAppSetting() {}
    /**
     * @return Indicates what protection policy that the system applies on a device. By default, the value is NONE, which indicates that the system applies no protection policy. A value of APP_PIN indicates that the system requires a Personal Identification Number (PIN). A value of DEVICE_BIOMETRIC_OR_APP_PIN indicates that either a PIN or a biometric authentication factor is required.
     * 
     */
    public String deviceProtectionPolicy() {
        return this.deviceProtectionPolicy;
    }
    /**
     * @return The period of time in seconds that the system will lock a user out of the service after that user exceeds the maximum number of login failures
     * 
     */
    public Integer initialLockoutPeriodInSecs() {
        return this.initialLockoutPeriodInSecs;
    }
    /**
     * @return The size of the key that the system uses to generate the public-private key pair
     * 
     */
    public Integer keyPairLength() {
        return this.keyPairLength;
    }
    /**
     * @return The pattern of escalation that the system follows, in locking a particular user out of the service.
     * 
     */
    public String lockoutEscalationPattern() {
        return this.lockoutEscalationPattern;
    }
    /**
     * @return The maximum number of times that a particular user can fail to login before the system locks that user out of the service
     * 
     */
    public Integer maxFailuresBeforeLockout() {
        return this.maxFailuresBeforeLockout;
    }
    /**
     * @return The maximum number of login failures that the system will allow before raising a warning and sending an alert via email
     * 
     */
    public Integer maxFailuresBeforeWarning() {
        return this.maxFailuresBeforeWarning;
    }
    /**
     * @return The maximum period of time that the system will lock a particular user out of the service regardless of what the configured pattern of escalation would otherwise dictate
     * 
     */
    public Integer maxLockoutIntervalInSecs() {
        return this.maxLockoutIntervalInSecs;
    }
    /**
     * @return Minimum length of the Personal Identification Number (PIN)
     * 
     */
    public Integer minPinLength() {
        return this.minPinLength;
    }
    /**
     * @return The period of time in days after which a client should refresh its policy by re-reading that policy from the server
     * 
     */
    public Integer policyUpdateFreqInDays() {
        return this.policyUpdateFreqInDays;
    }
    /**
     * @return Indicates which algorithm the system will use to sign requests
     * 
     */
    public String requestSigningAlgo() {
        return this.requestSigningAlgo;
    }
    /**
     * @return Indicates the type of encoding that the system should use to generate a shared secret
     * 
     */
    public String sharedSecretEncoding() {
        return this.sharedSecretEncoding;
    }
    /**
     * @return If true, indicates that the system should require the user to unlock the client app for each request. In order to unlock the App, the user must supply a Personal Identification Number (PIN) or a biometric authentication-factor.
     * 
     */
    public Boolean unlockAppForEachRequestEnabled() {
        return this.unlockAppForEachRequestEnabled;
    }
    /**
     * @return Specifies the period of time in seconds after which the client App should require the user to unlock the App. In order to unlock the App, the user must supply a Personal Identification Number (PIN) or a biometric authentication-factor. A value of zero means that it is disabled.
     * 
     */
    public Integer unlockAppIntervalInSecs() {
        return this.unlockAppIntervalInSecs;
    }
    /**
     * @return If true, indicates that the system should require the user to unlock the client App, when the client App comes to the foreground in the display of the device. In order to unlock the App, the user must supply a Personal Identification Number (PIN) or a biometric authentication-factor.
     * 
     */
    public Boolean unlockOnAppForegroundEnabled() {
        return this.unlockOnAppForegroundEnabled;
    }
    /**
     * @return If true, indicates that the system should require the user to unlock the client App whenever the App is started. In order to unlock the App, the user must supply a Personal Identification Number (PIN) or a biometric authentication-factor.
     * 
     */
    public Boolean unlockOnAppStartEnabled() {
        return this.unlockOnAppStartEnabled;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetDomainsAuthenticationFactorSettingsAuthenticationFactorSettingClientAppSetting defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String deviceProtectionPolicy;
        private Integer initialLockoutPeriodInSecs;
        private Integer keyPairLength;
        private String lockoutEscalationPattern;
        private Integer maxFailuresBeforeLockout;
        private Integer maxFailuresBeforeWarning;
        private Integer maxLockoutIntervalInSecs;
        private Integer minPinLength;
        private Integer policyUpdateFreqInDays;
        private String requestSigningAlgo;
        private String sharedSecretEncoding;
        private Boolean unlockAppForEachRequestEnabled;
        private Integer unlockAppIntervalInSecs;
        private Boolean unlockOnAppForegroundEnabled;
        private Boolean unlockOnAppStartEnabled;
        public Builder() {}
        public Builder(GetDomainsAuthenticationFactorSettingsAuthenticationFactorSettingClientAppSetting defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.deviceProtectionPolicy = defaults.deviceProtectionPolicy;
    	      this.initialLockoutPeriodInSecs = defaults.initialLockoutPeriodInSecs;
    	      this.keyPairLength = defaults.keyPairLength;
    	      this.lockoutEscalationPattern = defaults.lockoutEscalationPattern;
    	      this.maxFailuresBeforeLockout = defaults.maxFailuresBeforeLockout;
    	      this.maxFailuresBeforeWarning = defaults.maxFailuresBeforeWarning;
    	      this.maxLockoutIntervalInSecs = defaults.maxLockoutIntervalInSecs;
    	      this.minPinLength = defaults.minPinLength;
    	      this.policyUpdateFreqInDays = defaults.policyUpdateFreqInDays;
    	      this.requestSigningAlgo = defaults.requestSigningAlgo;
    	      this.sharedSecretEncoding = defaults.sharedSecretEncoding;
    	      this.unlockAppForEachRequestEnabled = defaults.unlockAppForEachRequestEnabled;
    	      this.unlockAppIntervalInSecs = defaults.unlockAppIntervalInSecs;
    	      this.unlockOnAppForegroundEnabled = defaults.unlockOnAppForegroundEnabled;
    	      this.unlockOnAppStartEnabled = defaults.unlockOnAppStartEnabled;
        }

        @CustomType.Setter
        public Builder deviceProtectionPolicy(String deviceProtectionPolicy) {
            if (deviceProtectionPolicy == null) {
              throw new MissingRequiredPropertyException("GetDomainsAuthenticationFactorSettingsAuthenticationFactorSettingClientAppSetting", "deviceProtectionPolicy");
            }
            this.deviceProtectionPolicy = deviceProtectionPolicy;
            return this;
        }
        @CustomType.Setter
        public Builder initialLockoutPeriodInSecs(Integer initialLockoutPeriodInSecs) {
            if (initialLockoutPeriodInSecs == null) {
              throw new MissingRequiredPropertyException("GetDomainsAuthenticationFactorSettingsAuthenticationFactorSettingClientAppSetting", "initialLockoutPeriodInSecs");
            }
            this.initialLockoutPeriodInSecs = initialLockoutPeriodInSecs;
            return this;
        }
        @CustomType.Setter
        public Builder keyPairLength(Integer keyPairLength) {
            if (keyPairLength == null) {
              throw new MissingRequiredPropertyException("GetDomainsAuthenticationFactorSettingsAuthenticationFactorSettingClientAppSetting", "keyPairLength");
            }
            this.keyPairLength = keyPairLength;
            return this;
        }
        @CustomType.Setter
        public Builder lockoutEscalationPattern(String lockoutEscalationPattern) {
            if (lockoutEscalationPattern == null) {
              throw new MissingRequiredPropertyException("GetDomainsAuthenticationFactorSettingsAuthenticationFactorSettingClientAppSetting", "lockoutEscalationPattern");
            }
            this.lockoutEscalationPattern = lockoutEscalationPattern;
            return this;
        }
        @CustomType.Setter
        public Builder maxFailuresBeforeLockout(Integer maxFailuresBeforeLockout) {
            if (maxFailuresBeforeLockout == null) {
              throw new MissingRequiredPropertyException("GetDomainsAuthenticationFactorSettingsAuthenticationFactorSettingClientAppSetting", "maxFailuresBeforeLockout");
            }
            this.maxFailuresBeforeLockout = maxFailuresBeforeLockout;
            return this;
        }
        @CustomType.Setter
        public Builder maxFailuresBeforeWarning(Integer maxFailuresBeforeWarning) {
            if (maxFailuresBeforeWarning == null) {
              throw new MissingRequiredPropertyException("GetDomainsAuthenticationFactorSettingsAuthenticationFactorSettingClientAppSetting", "maxFailuresBeforeWarning");
            }
            this.maxFailuresBeforeWarning = maxFailuresBeforeWarning;
            return this;
        }
        @CustomType.Setter
        public Builder maxLockoutIntervalInSecs(Integer maxLockoutIntervalInSecs) {
            if (maxLockoutIntervalInSecs == null) {
              throw new MissingRequiredPropertyException("GetDomainsAuthenticationFactorSettingsAuthenticationFactorSettingClientAppSetting", "maxLockoutIntervalInSecs");
            }
            this.maxLockoutIntervalInSecs = maxLockoutIntervalInSecs;
            return this;
        }
        @CustomType.Setter
        public Builder minPinLength(Integer minPinLength) {
            if (minPinLength == null) {
              throw new MissingRequiredPropertyException("GetDomainsAuthenticationFactorSettingsAuthenticationFactorSettingClientAppSetting", "minPinLength");
            }
            this.minPinLength = minPinLength;
            return this;
        }
        @CustomType.Setter
        public Builder policyUpdateFreqInDays(Integer policyUpdateFreqInDays) {
            if (policyUpdateFreqInDays == null) {
              throw new MissingRequiredPropertyException("GetDomainsAuthenticationFactorSettingsAuthenticationFactorSettingClientAppSetting", "policyUpdateFreqInDays");
            }
            this.policyUpdateFreqInDays = policyUpdateFreqInDays;
            return this;
        }
        @CustomType.Setter
        public Builder requestSigningAlgo(String requestSigningAlgo) {
            if (requestSigningAlgo == null) {
              throw new MissingRequiredPropertyException("GetDomainsAuthenticationFactorSettingsAuthenticationFactorSettingClientAppSetting", "requestSigningAlgo");
            }
            this.requestSigningAlgo = requestSigningAlgo;
            return this;
        }
        @CustomType.Setter
        public Builder sharedSecretEncoding(String sharedSecretEncoding) {
            if (sharedSecretEncoding == null) {
              throw new MissingRequiredPropertyException("GetDomainsAuthenticationFactorSettingsAuthenticationFactorSettingClientAppSetting", "sharedSecretEncoding");
            }
            this.sharedSecretEncoding = sharedSecretEncoding;
            return this;
        }
        @CustomType.Setter
        public Builder unlockAppForEachRequestEnabled(Boolean unlockAppForEachRequestEnabled) {
            if (unlockAppForEachRequestEnabled == null) {
              throw new MissingRequiredPropertyException("GetDomainsAuthenticationFactorSettingsAuthenticationFactorSettingClientAppSetting", "unlockAppForEachRequestEnabled");
            }
            this.unlockAppForEachRequestEnabled = unlockAppForEachRequestEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder unlockAppIntervalInSecs(Integer unlockAppIntervalInSecs) {
            if (unlockAppIntervalInSecs == null) {
              throw new MissingRequiredPropertyException("GetDomainsAuthenticationFactorSettingsAuthenticationFactorSettingClientAppSetting", "unlockAppIntervalInSecs");
            }
            this.unlockAppIntervalInSecs = unlockAppIntervalInSecs;
            return this;
        }
        @CustomType.Setter
        public Builder unlockOnAppForegroundEnabled(Boolean unlockOnAppForegroundEnabled) {
            if (unlockOnAppForegroundEnabled == null) {
              throw new MissingRequiredPropertyException("GetDomainsAuthenticationFactorSettingsAuthenticationFactorSettingClientAppSetting", "unlockOnAppForegroundEnabled");
            }
            this.unlockOnAppForegroundEnabled = unlockOnAppForegroundEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder unlockOnAppStartEnabled(Boolean unlockOnAppStartEnabled) {
            if (unlockOnAppStartEnabled == null) {
              throw new MissingRequiredPropertyException("GetDomainsAuthenticationFactorSettingsAuthenticationFactorSettingClientAppSetting", "unlockOnAppStartEnabled");
            }
            this.unlockOnAppStartEnabled = unlockOnAppStartEnabled;
            return this;
        }
        public GetDomainsAuthenticationFactorSettingsAuthenticationFactorSettingClientAppSetting build() {
            final var _resultValue = new GetDomainsAuthenticationFactorSettingsAuthenticationFactorSettingClientAppSetting();
            _resultValue.deviceProtectionPolicy = deviceProtectionPolicy;
            _resultValue.initialLockoutPeriodInSecs = initialLockoutPeriodInSecs;
            _resultValue.keyPairLength = keyPairLength;
            _resultValue.lockoutEscalationPattern = lockoutEscalationPattern;
            _resultValue.maxFailuresBeforeLockout = maxFailuresBeforeLockout;
            _resultValue.maxFailuresBeforeWarning = maxFailuresBeforeWarning;
            _resultValue.maxLockoutIntervalInSecs = maxLockoutIntervalInSecs;
            _resultValue.minPinLength = minPinLength;
            _resultValue.policyUpdateFreqInDays = policyUpdateFreqInDays;
            _resultValue.requestSigningAlgo = requestSigningAlgo;
            _resultValue.sharedSecretEncoding = sharedSecretEncoding;
            _resultValue.unlockAppForEachRequestEnabled = unlockAppForEachRequestEnabled;
            _resultValue.unlockAppIntervalInSecs = unlockAppIntervalInSecs;
            _resultValue.unlockOnAppForegroundEnabled = unlockOnAppForegroundEnabled;
            _resultValue.unlockOnAppStartEnabled = unlockOnAppStartEnabled;
            return _resultValue;
        }
    }
}
