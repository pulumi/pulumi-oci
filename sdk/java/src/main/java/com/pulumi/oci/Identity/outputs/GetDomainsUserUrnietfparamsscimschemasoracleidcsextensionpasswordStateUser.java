// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.oci.Identity.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.oci.Identity.outputs.GetDomainsUserUrnietfparamsscimschemasoracleidcsextensionpasswordStateUserApplicablePasswordPolicy;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Objects;

@CustomType
public final class GetDomainsUserUrnietfparamsscimschemasoracleidcsextensionpasswordStateUser {
    /**
     * @return Applicable Password Policy
     * 
     */
    private List<GetDomainsUserUrnietfparamsscimschemasoracleidcsextensionpasswordStateUserApplicablePasswordPolicy> applicablePasswordPolicies;
    /**
     * @return Indicates that the current password MAY NOT be changed and all other password expiry settings SHALL be ignored
     * 
     */
    private Boolean cantChange;
    /**
     * @return Indicates that the password expiry policy will not be applied for the current Resource
     * 
     */
    private Boolean cantExpire;
    /**
     * @return Indicates whether the user password is expired. If this value is false, password expiry is still evaluated during user login.
     * 
     */
    private Boolean expired;
    /**
     * @return A DateTime that specifies the date and time when last failed password validation was set
     * 
     */
    private String lastFailedValidationDate;
    /**
     * @return A DateTime that specifies the date and time when the current password was set
     * 
     */
    private String lastSuccessfulSetDate;
    /**
     * @return A DateTime that specifies the date and time when last successful password validation was set
     * 
     */
    private String lastSuccessfulValidationDate;
    /**
     * @return Indicates that the subject password value MUST change on next login. If not changed, typically the account is locked. The value may be set indirectly when the subject&#39;s current password expires or directly set by an administrator.
     * 
     */
    private Boolean mustChange;

    private GetDomainsUserUrnietfparamsscimschemasoracleidcsextensionpasswordStateUser() {}
    /**
     * @return Applicable Password Policy
     * 
     */
    public List<GetDomainsUserUrnietfparamsscimschemasoracleidcsextensionpasswordStateUserApplicablePasswordPolicy> applicablePasswordPolicies() {
        return this.applicablePasswordPolicies;
    }
    /**
     * @return Indicates that the current password MAY NOT be changed and all other password expiry settings SHALL be ignored
     * 
     */
    public Boolean cantChange() {
        return this.cantChange;
    }
    /**
     * @return Indicates that the password expiry policy will not be applied for the current Resource
     * 
     */
    public Boolean cantExpire() {
        return this.cantExpire;
    }
    /**
     * @return Indicates whether the user password is expired. If this value is false, password expiry is still evaluated during user login.
     * 
     */
    public Boolean expired() {
        return this.expired;
    }
    /**
     * @return A DateTime that specifies the date and time when last failed password validation was set
     * 
     */
    public String lastFailedValidationDate() {
        return this.lastFailedValidationDate;
    }
    /**
     * @return A DateTime that specifies the date and time when the current password was set
     * 
     */
    public String lastSuccessfulSetDate() {
        return this.lastSuccessfulSetDate;
    }
    /**
     * @return A DateTime that specifies the date and time when last successful password validation was set
     * 
     */
    public String lastSuccessfulValidationDate() {
        return this.lastSuccessfulValidationDate;
    }
    /**
     * @return Indicates that the subject password value MUST change on next login. If not changed, typically the account is locked. The value may be set indirectly when the subject&#39;s current password expires or directly set by an administrator.
     * 
     */
    public Boolean mustChange() {
        return this.mustChange;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetDomainsUserUrnietfparamsscimschemasoracleidcsextensionpasswordStateUser defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private List<GetDomainsUserUrnietfparamsscimschemasoracleidcsextensionpasswordStateUserApplicablePasswordPolicy> applicablePasswordPolicies;
        private Boolean cantChange;
        private Boolean cantExpire;
        private Boolean expired;
        private String lastFailedValidationDate;
        private String lastSuccessfulSetDate;
        private String lastSuccessfulValidationDate;
        private Boolean mustChange;
        public Builder() {}
        public Builder(GetDomainsUserUrnietfparamsscimschemasoracleidcsextensionpasswordStateUser defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.applicablePasswordPolicies = defaults.applicablePasswordPolicies;
    	      this.cantChange = defaults.cantChange;
    	      this.cantExpire = defaults.cantExpire;
    	      this.expired = defaults.expired;
    	      this.lastFailedValidationDate = defaults.lastFailedValidationDate;
    	      this.lastSuccessfulSetDate = defaults.lastSuccessfulSetDate;
    	      this.lastSuccessfulValidationDate = defaults.lastSuccessfulValidationDate;
    	      this.mustChange = defaults.mustChange;
        }

        @CustomType.Setter
        public Builder applicablePasswordPolicies(List<GetDomainsUserUrnietfparamsscimschemasoracleidcsextensionpasswordStateUserApplicablePasswordPolicy> applicablePasswordPolicies) {
            if (applicablePasswordPolicies == null) {
              throw new MissingRequiredPropertyException("GetDomainsUserUrnietfparamsscimschemasoracleidcsextensionpasswordStateUser", "applicablePasswordPolicies");
            }
            this.applicablePasswordPolicies = applicablePasswordPolicies;
            return this;
        }
        public Builder applicablePasswordPolicies(GetDomainsUserUrnietfparamsscimschemasoracleidcsextensionpasswordStateUserApplicablePasswordPolicy... applicablePasswordPolicies) {
            return applicablePasswordPolicies(List.of(applicablePasswordPolicies));
        }
        @CustomType.Setter
        public Builder cantChange(Boolean cantChange) {
            if (cantChange == null) {
              throw new MissingRequiredPropertyException("GetDomainsUserUrnietfparamsscimschemasoracleidcsextensionpasswordStateUser", "cantChange");
            }
            this.cantChange = cantChange;
            return this;
        }
        @CustomType.Setter
        public Builder cantExpire(Boolean cantExpire) {
            if (cantExpire == null) {
              throw new MissingRequiredPropertyException("GetDomainsUserUrnietfparamsscimschemasoracleidcsextensionpasswordStateUser", "cantExpire");
            }
            this.cantExpire = cantExpire;
            return this;
        }
        @CustomType.Setter
        public Builder expired(Boolean expired) {
            if (expired == null) {
              throw new MissingRequiredPropertyException("GetDomainsUserUrnietfparamsscimschemasoracleidcsextensionpasswordStateUser", "expired");
            }
            this.expired = expired;
            return this;
        }
        @CustomType.Setter
        public Builder lastFailedValidationDate(String lastFailedValidationDate) {
            if (lastFailedValidationDate == null) {
              throw new MissingRequiredPropertyException("GetDomainsUserUrnietfparamsscimschemasoracleidcsextensionpasswordStateUser", "lastFailedValidationDate");
            }
            this.lastFailedValidationDate = lastFailedValidationDate;
            return this;
        }
        @CustomType.Setter
        public Builder lastSuccessfulSetDate(String lastSuccessfulSetDate) {
            if (lastSuccessfulSetDate == null) {
              throw new MissingRequiredPropertyException("GetDomainsUserUrnietfparamsscimschemasoracleidcsextensionpasswordStateUser", "lastSuccessfulSetDate");
            }
            this.lastSuccessfulSetDate = lastSuccessfulSetDate;
            return this;
        }
        @CustomType.Setter
        public Builder lastSuccessfulValidationDate(String lastSuccessfulValidationDate) {
            if (lastSuccessfulValidationDate == null) {
              throw new MissingRequiredPropertyException("GetDomainsUserUrnietfparamsscimschemasoracleidcsextensionpasswordStateUser", "lastSuccessfulValidationDate");
            }
            this.lastSuccessfulValidationDate = lastSuccessfulValidationDate;
            return this;
        }
        @CustomType.Setter
        public Builder mustChange(Boolean mustChange) {
            if (mustChange == null) {
              throw new MissingRequiredPropertyException("GetDomainsUserUrnietfparamsscimschemasoracleidcsextensionpasswordStateUser", "mustChange");
            }
            this.mustChange = mustChange;
            return this;
        }
        public GetDomainsUserUrnietfparamsscimschemasoracleidcsextensionpasswordStateUser build() {
            final var _resultValue = new GetDomainsUserUrnietfparamsscimschemasoracleidcsextensionpasswordStateUser();
            _resultValue.applicablePasswordPolicies = applicablePasswordPolicies;
            _resultValue.cantChange = cantChange;
            _resultValue.cantExpire = cantExpire;
            _resultValue.expired = expired;
            _resultValue.lastFailedValidationDate = lastFailedValidationDate;
            _resultValue.lastSuccessfulSetDate = lastSuccessfulSetDate;
            _resultValue.lastSuccessfulValidationDate = lastSuccessfulValidationDate;
            _resultValue.mustChange = mustChange;
            return _resultValue;
        }
    }
}
