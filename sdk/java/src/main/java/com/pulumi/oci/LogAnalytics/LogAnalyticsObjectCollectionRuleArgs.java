// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.oci.LogAnalytics;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.oci.LogAnalytics.inputs.LogAnalyticsObjectCollectionRuleOverrideArgs;
import java.lang.Boolean;
import java.lang.Object;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class LogAnalyticsObjectCollectionRuleArgs extends com.pulumi.resources.ResourceArgs {

    public static final LogAnalyticsObjectCollectionRuleArgs Empty = new LogAnalyticsObjectCollectionRuleArgs();

    /**
     * (Updatable) An optional character encoding to aid in detecting the character encoding of the contents of the objects while processing. It is recommended to set this value as ISO_8589_1 when configuring content of the objects having more numeric characters, and very few alphabets. For e.g. this applies when configuring VCN Flow Logs.
     * 
     */
    @Import(name="charEncoding")
    private @Nullable Output<String> charEncoding;

    /**
     * @return (Updatable) An optional character encoding to aid in detecting the character encoding of the contents of the objects while processing. It is recommended to set this value as ISO_8589_1 when configuring content of the objects having more numeric characters, and very few alphabets. For e.g. this applies when configuring VCN Flow Logs.
     * 
     */
    public Optional<Output<String>> charEncoding() {
        return Optional.ofNullable(this.charEncoding);
    }

    /**
     * The type of collection. Supported collection types: LIVE, HISTORIC, HISTORIC_LIVE
     * 
     */
    @Import(name="collectionType")
    private @Nullable Output<String> collectionType;

    /**
     * @return The type of collection. Supported collection types: LIVE, HISTORIC, HISTORIC_LIVE
     * 
     */
    public Optional<Output<String>> collectionType() {
        return Optional.ofNullable(this.collectionType);
    }

    /**
     * (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment to which this rule belongs.
     * 
     */
    @Import(name="compartmentId", required=true)
    private Output<String> compartmentId;

    /**
     * @return (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment to which this rule belongs.
     * 
     */
    public Output<String> compartmentId() {
        return this.compartmentId;
    }

    /**
     * (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{&#34;foo-namespace.bar-key&#34;: &#34;value&#34;}`
     * 
     */
    @Import(name="definedTags")
    private @Nullable Output<Map<String,Object>> definedTags;

    /**
     * @return (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{&#34;foo-namespace.bar-key&#34;: &#34;value&#34;}`
     * 
     */
    public Optional<Output<Map<String,Object>>> definedTags() {
        return Optional.ofNullable(this.definedTags);
    }

    /**
     * (Updatable) A string that describes the details of the rule. It does not have to be unique, and can be changed. Avoid entering confidential information.
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    /**
     * @return (Updatable) A string that describes the details of the rule. It does not have to be unique, and can be changed. Avoid entering confidential information.
     * 
     */
    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * (Updatable) Logging Analytics entity OCID. Associates the processed logs with the given entity (optional).
     * 
     */
    @Import(name="entityId")
    private @Nullable Output<String> entityId;

    /**
     * @return (Updatable) Logging Analytics entity OCID. Associates the processed logs with the given entity (optional).
     * 
     */
    public Optional<Output<String>> entityId() {
        return Optional.ofNullable(this.entityId);
    }

    /**
     * (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{&#34;bar-key&#34;: &#34;value&#34;}`
     * 
     */
    @Import(name="freeformTags")
    private @Nullable Output<Map<String,Object>> freeformTags;

    /**
     * @return (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{&#34;bar-key&#34;: &#34;value&#34;}`
     * 
     */
    public Optional<Output<Map<String,Object>>> freeformTags() {
        return Optional.ofNullable(this.freeformTags);
    }

    /**
     * (Updatable) Whether or not this rule is currently enabled.
     * 
     */
    @Import(name="isEnabled")
    private @Nullable Output<Boolean> isEnabled;

    /**
     * @return (Updatable) Whether or not this rule is currently enabled.
     * 
     */
    public Optional<Output<Boolean>> isEnabled() {
        return Optional.ofNullable(this.isEnabled);
    }

    /**
     * Flag to allow historic collection if poll period overlaps with existing ACTIVE collection rule
     * 
     */
    @Import(name="isForceHistoricCollection")
    private @Nullable Output<Boolean> isForceHistoricCollection;

    /**
     * @return Flag to allow historic collection if poll period overlaps with existing ACTIVE collection rule
     * 
     */
    public Optional<Output<Boolean>> isForceHistoricCollection() {
        return Optional.ofNullable(this.isForceHistoricCollection);
    }

    /**
     * (Updatable) Logging Analytics Log group OCID to associate the processed logs with.
     * 
     */
    @Import(name="logGroupId", required=true)
    private Output<String> logGroupId;

    /**
     * @return (Updatable) Logging Analytics Log group OCID to associate the processed logs with.
     * 
     */
    public Output<String> logGroupId() {
        return this.logGroupId;
    }

    /**
     * (Updatable) The logSet to be associated with the processed logs. The logSet feature can be used by customers with high volume of data  and this feature has to be enabled for a given tenancy prior to its usage. When logSetExtRegex value is provided, it will take precedence over this logSet value and logSet will be computed dynamically  using logSetKey and logSetExtRegex.
     * 
     */
    @Import(name="logSet")
    private @Nullable Output<String> logSet;

    /**
     * @return (Updatable) The logSet to be associated with the processed logs. The logSet feature can be used by customers with high volume of data  and this feature has to be enabled for a given tenancy prior to its usage. When logSetExtRegex value is provided, it will take precedence over this logSet value and logSet will be computed dynamically  using logSetKey and logSetExtRegex.
     * 
     */
    public Optional<Output<String>> logSet() {
        return Optional.ofNullable(this.logSet);
    }

    /**
     * (Updatable) The regex to be applied against given logSetKey. Regex has to be in string escaped format.
     * 
     */
    @Import(name="logSetExtRegex")
    private @Nullable Output<String> logSetExtRegex;

    /**
     * @return (Updatable) The regex to be applied against given logSetKey. Regex has to be in string escaped format.
     * 
     */
    public Optional<Output<String>> logSetExtRegex() {
        return Optional.ofNullable(this.logSetExtRegex);
    }

    /**
     * (Updatable) An optional parameter to indicate from where the logSet to be extracted using logSetExtRegex. Default value is OBJECT_PATH (e.g. /n/&lt;namespace&gt;/b/&lt;bucketname&gt;/o/&lt;objectname&gt;).
     * 
     */
    @Import(name="logSetKey")
    private @Nullable Output<String> logSetKey;

    /**
     * @return (Updatable) An optional parameter to indicate from where the logSet to be extracted using logSetExtRegex. Default value is OBJECT_PATH (e.g. /n/&lt;namespace&gt;/b/&lt;bucketname&gt;/o/&lt;objectname&gt;).
     * 
     */
    public Optional<Output<String>> logSetKey() {
        return Optional.ofNullable(this.logSetKey);
    }

    /**
     * (Updatable) Name of the Logging Analytics Source to use for the processing.
     * 
     */
    @Import(name="logSourceName", required=true)
    private Output<String> logSourceName;

    /**
     * @return (Updatable) Name of the Logging Analytics Source to use for the processing.
     * 
     */
    public Output<String> logSourceName() {
        return this.logSourceName;
    }

    /**
     * Type of files/objects in this object collection rule.
     * 
     */
    @Import(name="logType")
    private @Nullable Output<String> logType;

    /**
     * @return Type of files/objects in this object collection rule.
     * 
     */
    public Optional<Output<String>> logType() {
        return Optional.ofNullable(this.logType);
    }

    /**
     * A unique name given to the rule. The name must be unique within the tenancy, and cannot be modified.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return A unique name given to the rule. The name must be unique within the tenancy, and cannot be modified.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * The Logging Analytics namespace used for the request.
     * 
     */
    @Import(name="namespace", required=true)
    private Output<String> namespace;

    /**
     * @return The Logging Analytics namespace used for the request.
     * 
     */
    public Output<String> namespace() {
        return this.namespace;
    }

    /**
     * (Updatable) When the filters are provided, only the objects matching the filters are picked up for processing. The matchType supported is exact match and accommodates wildcard &#34;*&#34;. For more information on filters, see [Event Filters](https://docs.oracle.com/en-us/iaas/Content/Events/Concepts/filterevents.htm).
     * 
     */
    @Import(name="objectNameFilters")
    private @Nullable Output<List<String>> objectNameFilters;

    /**
     * @return (Updatable) When the filters are provided, only the objects matching the filters are picked up for processing. The matchType supported is exact match and accommodates wildcard &#34;*&#34;. For more information on filters, see [Event Filters](https://docs.oracle.com/en-us/iaas/Content/Events/Concepts/filterevents.htm).
     * 
     */
    public Optional<Output<List<String>>> objectNameFilters() {
        return Optional.ofNullable(this.objectNameFilters);
    }

    /**
     * Name of the Object Storage bucket.
     * 
     */
    @Import(name="osBucketName", required=true)
    private Output<String> osBucketName;

    /**
     * @return Name of the Object Storage bucket.
     * 
     */
    public Output<String> osBucketName() {
        return this.osBucketName;
    }

    /**
     * Object Storage namespace.
     * 
     */
    @Import(name="osNamespace", required=true)
    private Output<String> osNamespace;

    /**
     * @return Object Storage namespace.
     * 
     */
    public Output<String> osNamespace() {
        return this.osNamespace;
    }

    /**
     * (Updatable) The override is used to modify some important configuration properties for objects matching a specific pattern inside the bucket. Supported propeties for override are: logSourceName, charEncoding, entityId. Supported matchType for override are &#34;contains&#34;.
     * 
     */
    @Import(name="overrides")
    private @Nullable Output<List<LogAnalyticsObjectCollectionRuleOverrideArgs>> overrides;

    /**
     * @return (Updatable) The override is used to modify some important configuration properties for objects matching a specific pattern inside the bucket. Supported propeties for override are: logSourceName, charEncoding, entityId. Supported matchType for override are &#34;contains&#34;.
     * 
     */
    public Optional<Output<List<LogAnalyticsObjectCollectionRuleOverrideArgs>>> overrides() {
        return Optional.ofNullable(this.overrides);
    }

    /**
     * The oldest time of the file in the bucket to consider for collection. Accepted values are: BEGINNING or CURRENT_TIME or RFC3339 formatted datetime string. Use this for HISTORIC or HISTORIC_LIVE collection types. When collectionType is LIVE, specifying pollSince value other than CURRENT_TIME will result in error.
     * 
     */
    @Import(name="pollSince")
    private @Nullable Output<String> pollSince;

    /**
     * @return The oldest time of the file in the bucket to consider for collection. Accepted values are: BEGINNING or CURRENT_TIME or RFC3339 formatted datetime string. Use this for HISTORIC or HISTORIC_LIVE collection types. When collectionType is LIVE, specifying pollSince value other than CURRENT_TIME will result in error.
     * 
     */
    public Optional<Output<String>> pollSince() {
        return Optional.ofNullable(this.pollSince);
    }

    /**
     * The newest time of the file in the bucket to consider for collection. Accepted values are: CURRENT_TIME or RFC3339 formatted datetime string. Use this for HISTORIC collection type. When collectionType is LIVE or HISTORIC_LIVE, specifying pollTill will result in error.
     * 
     */
    @Import(name="pollTill")
    private @Nullable Output<String> pollTill;

    /**
     * @return The newest time of the file in the bucket to consider for collection. Accepted values are: CURRENT_TIME or RFC3339 formatted datetime string. Use this for HISTORIC collection type. When collectionType is LIVE or HISTORIC_LIVE, specifying pollTill will result in error.
     * 
     */
    public Optional<Output<String>> pollTill() {
        return Optional.ofNullable(this.pollTill);
    }

    /**
     * (Updatable) Timezone to be used when processing log entries whose timestamps do not include an explicit timezone.  When this property is not specified, the timezone of the entity specified is used.  If the entity is also not specified or do not have a valid timezone then UTC is used.
     * 
     * ** IMPORTANT **
     * Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
     * 
     */
    @Import(name="timezone")
    private @Nullable Output<String> timezone;

    /**
     * @return (Updatable) Timezone to be used when processing log entries whose timestamps do not include an explicit timezone.  When this property is not specified, the timezone of the entity specified is used.  If the entity is also not specified or do not have a valid timezone then UTC is used.
     * 
     * ** IMPORTANT **
     * Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
     * 
     */
    public Optional<Output<String>> timezone() {
        return Optional.ofNullable(this.timezone);
    }

    private LogAnalyticsObjectCollectionRuleArgs() {}

    private LogAnalyticsObjectCollectionRuleArgs(LogAnalyticsObjectCollectionRuleArgs $) {
        this.charEncoding = $.charEncoding;
        this.collectionType = $.collectionType;
        this.compartmentId = $.compartmentId;
        this.definedTags = $.definedTags;
        this.description = $.description;
        this.entityId = $.entityId;
        this.freeformTags = $.freeformTags;
        this.isEnabled = $.isEnabled;
        this.isForceHistoricCollection = $.isForceHistoricCollection;
        this.logGroupId = $.logGroupId;
        this.logSet = $.logSet;
        this.logSetExtRegex = $.logSetExtRegex;
        this.logSetKey = $.logSetKey;
        this.logSourceName = $.logSourceName;
        this.logType = $.logType;
        this.name = $.name;
        this.namespace = $.namespace;
        this.objectNameFilters = $.objectNameFilters;
        this.osBucketName = $.osBucketName;
        this.osNamespace = $.osNamespace;
        this.overrides = $.overrides;
        this.pollSince = $.pollSince;
        this.pollTill = $.pollTill;
        this.timezone = $.timezone;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(LogAnalyticsObjectCollectionRuleArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private LogAnalyticsObjectCollectionRuleArgs $;

        public Builder() {
            $ = new LogAnalyticsObjectCollectionRuleArgs();
        }

        public Builder(LogAnalyticsObjectCollectionRuleArgs defaults) {
            $ = new LogAnalyticsObjectCollectionRuleArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param charEncoding (Updatable) An optional character encoding to aid in detecting the character encoding of the contents of the objects while processing. It is recommended to set this value as ISO_8589_1 when configuring content of the objects having more numeric characters, and very few alphabets. For e.g. this applies when configuring VCN Flow Logs.
         * 
         * @return builder
         * 
         */
        public Builder charEncoding(@Nullable Output<String> charEncoding) {
            $.charEncoding = charEncoding;
            return this;
        }

        /**
         * @param charEncoding (Updatable) An optional character encoding to aid in detecting the character encoding of the contents of the objects while processing. It is recommended to set this value as ISO_8589_1 when configuring content of the objects having more numeric characters, and very few alphabets. For e.g. this applies when configuring VCN Flow Logs.
         * 
         * @return builder
         * 
         */
        public Builder charEncoding(String charEncoding) {
            return charEncoding(Output.of(charEncoding));
        }

        /**
         * @param collectionType The type of collection. Supported collection types: LIVE, HISTORIC, HISTORIC_LIVE
         * 
         * @return builder
         * 
         */
        public Builder collectionType(@Nullable Output<String> collectionType) {
            $.collectionType = collectionType;
            return this;
        }

        /**
         * @param collectionType The type of collection. Supported collection types: LIVE, HISTORIC, HISTORIC_LIVE
         * 
         * @return builder
         * 
         */
        public Builder collectionType(String collectionType) {
            return collectionType(Output.of(collectionType));
        }

        /**
         * @param compartmentId (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment to which this rule belongs.
         * 
         * @return builder
         * 
         */
        public Builder compartmentId(Output<String> compartmentId) {
            $.compartmentId = compartmentId;
            return this;
        }

        /**
         * @param compartmentId (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment to which this rule belongs.
         * 
         * @return builder
         * 
         */
        public Builder compartmentId(String compartmentId) {
            return compartmentId(Output.of(compartmentId));
        }

        /**
         * @param definedTags (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{&#34;foo-namespace.bar-key&#34;: &#34;value&#34;}`
         * 
         * @return builder
         * 
         */
        public Builder definedTags(@Nullable Output<Map<String,Object>> definedTags) {
            $.definedTags = definedTags;
            return this;
        }

        /**
         * @param definedTags (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{&#34;foo-namespace.bar-key&#34;: &#34;value&#34;}`
         * 
         * @return builder
         * 
         */
        public Builder definedTags(Map<String,Object> definedTags) {
            return definedTags(Output.of(definedTags));
        }

        /**
         * @param description (Updatable) A string that describes the details of the rule. It does not have to be unique, and can be changed. Avoid entering confidential information.
         * 
         * @return builder
         * 
         */
        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        /**
         * @param description (Updatable) A string that describes the details of the rule. It does not have to be unique, and can be changed. Avoid entering confidential information.
         * 
         * @return builder
         * 
         */
        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param entityId (Updatable) Logging Analytics entity OCID. Associates the processed logs with the given entity (optional).
         * 
         * @return builder
         * 
         */
        public Builder entityId(@Nullable Output<String> entityId) {
            $.entityId = entityId;
            return this;
        }

        /**
         * @param entityId (Updatable) Logging Analytics entity OCID. Associates the processed logs with the given entity (optional).
         * 
         * @return builder
         * 
         */
        public Builder entityId(String entityId) {
            return entityId(Output.of(entityId));
        }

        /**
         * @param freeformTags (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{&#34;bar-key&#34;: &#34;value&#34;}`
         * 
         * @return builder
         * 
         */
        public Builder freeformTags(@Nullable Output<Map<String,Object>> freeformTags) {
            $.freeformTags = freeformTags;
            return this;
        }

        /**
         * @param freeformTags (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{&#34;bar-key&#34;: &#34;value&#34;}`
         * 
         * @return builder
         * 
         */
        public Builder freeformTags(Map<String,Object> freeformTags) {
            return freeformTags(Output.of(freeformTags));
        }

        /**
         * @param isEnabled (Updatable) Whether or not this rule is currently enabled.
         * 
         * @return builder
         * 
         */
        public Builder isEnabled(@Nullable Output<Boolean> isEnabled) {
            $.isEnabled = isEnabled;
            return this;
        }

        /**
         * @param isEnabled (Updatable) Whether or not this rule is currently enabled.
         * 
         * @return builder
         * 
         */
        public Builder isEnabled(Boolean isEnabled) {
            return isEnabled(Output.of(isEnabled));
        }

        /**
         * @param isForceHistoricCollection Flag to allow historic collection if poll period overlaps with existing ACTIVE collection rule
         * 
         * @return builder
         * 
         */
        public Builder isForceHistoricCollection(@Nullable Output<Boolean> isForceHistoricCollection) {
            $.isForceHistoricCollection = isForceHistoricCollection;
            return this;
        }

        /**
         * @param isForceHistoricCollection Flag to allow historic collection if poll period overlaps with existing ACTIVE collection rule
         * 
         * @return builder
         * 
         */
        public Builder isForceHistoricCollection(Boolean isForceHistoricCollection) {
            return isForceHistoricCollection(Output.of(isForceHistoricCollection));
        }

        /**
         * @param logGroupId (Updatable) Logging Analytics Log group OCID to associate the processed logs with.
         * 
         * @return builder
         * 
         */
        public Builder logGroupId(Output<String> logGroupId) {
            $.logGroupId = logGroupId;
            return this;
        }

        /**
         * @param logGroupId (Updatable) Logging Analytics Log group OCID to associate the processed logs with.
         * 
         * @return builder
         * 
         */
        public Builder logGroupId(String logGroupId) {
            return logGroupId(Output.of(logGroupId));
        }

        /**
         * @param logSet (Updatable) The logSet to be associated with the processed logs. The logSet feature can be used by customers with high volume of data  and this feature has to be enabled for a given tenancy prior to its usage. When logSetExtRegex value is provided, it will take precedence over this logSet value and logSet will be computed dynamically  using logSetKey and logSetExtRegex.
         * 
         * @return builder
         * 
         */
        public Builder logSet(@Nullable Output<String> logSet) {
            $.logSet = logSet;
            return this;
        }

        /**
         * @param logSet (Updatable) The logSet to be associated with the processed logs. The logSet feature can be used by customers with high volume of data  and this feature has to be enabled for a given tenancy prior to its usage. When logSetExtRegex value is provided, it will take precedence over this logSet value and logSet will be computed dynamically  using logSetKey and logSetExtRegex.
         * 
         * @return builder
         * 
         */
        public Builder logSet(String logSet) {
            return logSet(Output.of(logSet));
        }

        /**
         * @param logSetExtRegex (Updatable) The regex to be applied against given logSetKey. Regex has to be in string escaped format.
         * 
         * @return builder
         * 
         */
        public Builder logSetExtRegex(@Nullable Output<String> logSetExtRegex) {
            $.logSetExtRegex = logSetExtRegex;
            return this;
        }

        /**
         * @param logSetExtRegex (Updatable) The regex to be applied against given logSetKey. Regex has to be in string escaped format.
         * 
         * @return builder
         * 
         */
        public Builder logSetExtRegex(String logSetExtRegex) {
            return logSetExtRegex(Output.of(logSetExtRegex));
        }

        /**
         * @param logSetKey (Updatable) An optional parameter to indicate from where the logSet to be extracted using logSetExtRegex. Default value is OBJECT_PATH (e.g. /n/&lt;namespace&gt;/b/&lt;bucketname&gt;/o/&lt;objectname&gt;).
         * 
         * @return builder
         * 
         */
        public Builder logSetKey(@Nullable Output<String> logSetKey) {
            $.logSetKey = logSetKey;
            return this;
        }

        /**
         * @param logSetKey (Updatable) An optional parameter to indicate from where the logSet to be extracted using logSetExtRegex. Default value is OBJECT_PATH (e.g. /n/&lt;namespace&gt;/b/&lt;bucketname&gt;/o/&lt;objectname&gt;).
         * 
         * @return builder
         * 
         */
        public Builder logSetKey(String logSetKey) {
            return logSetKey(Output.of(logSetKey));
        }

        /**
         * @param logSourceName (Updatable) Name of the Logging Analytics Source to use for the processing.
         * 
         * @return builder
         * 
         */
        public Builder logSourceName(Output<String> logSourceName) {
            $.logSourceName = logSourceName;
            return this;
        }

        /**
         * @param logSourceName (Updatable) Name of the Logging Analytics Source to use for the processing.
         * 
         * @return builder
         * 
         */
        public Builder logSourceName(String logSourceName) {
            return logSourceName(Output.of(logSourceName));
        }

        /**
         * @param logType Type of files/objects in this object collection rule.
         * 
         * @return builder
         * 
         */
        public Builder logType(@Nullable Output<String> logType) {
            $.logType = logType;
            return this;
        }

        /**
         * @param logType Type of files/objects in this object collection rule.
         * 
         * @return builder
         * 
         */
        public Builder logType(String logType) {
            return logType(Output.of(logType));
        }

        /**
         * @param name A unique name given to the rule. The name must be unique within the tenancy, and cannot be modified.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name A unique name given to the rule. The name must be unique within the tenancy, and cannot be modified.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param namespace The Logging Analytics namespace used for the request.
         * 
         * @return builder
         * 
         */
        public Builder namespace(Output<String> namespace) {
            $.namespace = namespace;
            return this;
        }

        /**
         * @param namespace The Logging Analytics namespace used for the request.
         * 
         * @return builder
         * 
         */
        public Builder namespace(String namespace) {
            return namespace(Output.of(namespace));
        }

        /**
         * @param objectNameFilters (Updatable) When the filters are provided, only the objects matching the filters are picked up for processing. The matchType supported is exact match and accommodates wildcard &#34;*&#34;. For more information on filters, see [Event Filters](https://docs.oracle.com/en-us/iaas/Content/Events/Concepts/filterevents.htm).
         * 
         * @return builder
         * 
         */
        public Builder objectNameFilters(@Nullable Output<List<String>> objectNameFilters) {
            $.objectNameFilters = objectNameFilters;
            return this;
        }

        /**
         * @param objectNameFilters (Updatable) When the filters are provided, only the objects matching the filters are picked up for processing. The matchType supported is exact match and accommodates wildcard &#34;*&#34;. For more information on filters, see [Event Filters](https://docs.oracle.com/en-us/iaas/Content/Events/Concepts/filterevents.htm).
         * 
         * @return builder
         * 
         */
        public Builder objectNameFilters(List<String> objectNameFilters) {
            return objectNameFilters(Output.of(objectNameFilters));
        }

        /**
         * @param objectNameFilters (Updatable) When the filters are provided, only the objects matching the filters are picked up for processing. The matchType supported is exact match and accommodates wildcard &#34;*&#34;. For more information on filters, see [Event Filters](https://docs.oracle.com/en-us/iaas/Content/Events/Concepts/filterevents.htm).
         * 
         * @return builder
         * 
         */
        public Builder objectNameFilters(String... objectNameFilters) {
            return objectNameFilters(List.of(objectNameFilters));
        }

        /**
         * @param osBucketName Name of the Object Storage bucket.
         * 
         * @return builder
         * 
         */
        public Builder osBucketName(Output<String> osBucketName) {
            $.osBucketName = osBucketName;
            return this;
        }

        /**
         * @param osBucketName Name of the Object Storage bucket.
         * 
         * @return builder
         * 
         */
        public Builder osBucketName(String osBucketName) {
            return osBucketName(Output.of(osBucketName));
        }

        /**
         * @param osNamespace Object Storage namespace.
         * 
         * @return builder
         * 
         */
        public Builder osNamespace(Output<String> osNamespace) {
            $.osNamespace = osNamespace;
            return this;
        }

        /**
         * @param osNamespace Object Storage namespace.
         * 
         * @return builder
         * 
         */
        public Builder osNamespace(String osNamespace) {
            return osNamespace(Output.of(osNamespace));
        }

        /**
         * @param overrides (Updatable) The override is used to modify some important configuration properties for objects matching a specific pattern inside the bucket. Supported propeties for override are: logSourceName, charEncoding, entityId. Supported matchType for override are &#34;contains&#34;.
         * 
         * @return builder
         * 
         */
        public Builder overrides(@Nullable Output<List<LogAnalyticsObjectCollectionRuleOverrideArgs>> overrides) {
            $.overrides = overrides;
            return this;
        }

        /**
         * @param overrides (Updatable) The override is used to modify some important configuration properties for objects matching a specific pattern inside the bucket. Supported propeties for override are: logSourceName, charEncoding, entityId. Supported matchType for override are &#34;contains&#34;.
         * 
         * @return builder
         * 
         */
        public Builder overrides(List<LogAnalyticsObjectCollectionRuleOverrideArgs> overrides) {
            return overrides(Output.of(overrides));
        }

        /**
         * @param overrides (Updatable) The override is used to modify some important configuration properties for objects matching a specific pattern inside the bucket. Supported propeties for override are: logSourceName, charEncoding, entityId. Supported matchType for override are &#34;contains&#34;.
         * 
         * @return builder
         * 
         */
        public Builder overrides(LogAnalyticsObjectCollectionRuleOverrideArgs... overrides) {
            return overrides(List.of(overrides));
        }

        /**
         * @param pollSince The oldest time of the file in the bucket to consider for collection. Accepted values are: BEGINNING or CURRENT_TIME or RFC3339 formatted datetime string. Use this for HISTORIC or HISTORIC_LIVE collection types. When collectionType is LIVE, specifying pollSince value other than CURRENT_TIME will result in error.
         * 
         * @return builder
         * 
         */
        public Builder pollSince(@Nullable Output<String> pollSince) {
            $.pollSince = pollSince;
            return this;
        }

        /**
         * @param pollSince The oldest time of the file in the bucket to consider for collection. Accepted values are: BEGINNING or CURRENT_TIME or RFC3339 formatted datetime string. Use this for HISTORIC or HISTORIC_LIVE collection types. When collectionType is LIVE, specifying pollSince value other than CURRENT_TIME will result in error.
         * 
         * @return builder
         * 
         */
        public Builder pollSince(String pollSince) {
            return pollSince(Output.of(pollSince));
        }

        /**
         * @param pollTill The newest time of the file in the bucket to consider for collection. Accepted values are: CURRENT_TIME or RFC3339 formatted datetime string. Use this for HISTORIC collection type. When collectionType is LIVE or HISTORIC_LIVE, specifying pollTill will result in error.
         * 
         * @return builder
         * 
         */
        public Builder pollTill(@Nullable Output<String> pollTill) {
            $.pollTill = pollTill;
            return this;
        }

        /**
         * @param pollTill The newest time of the file in the bucket to consider for collection. Accepted values are: CURRENT_TIME or RFC3339 formatted datetime string. Use this for HISTORIC collection type. When collectionType is LIVE or HISTORIC_LIVE, specifying pollTill will result in error.
         * 
         * @return builder
         * 
         */
        public Builder pollTill(String pollTill) {
            return pollTill(Output.of(pollTill));
        }

        /**
         * @param timezone (Updatable) Timezone to be used when processing log entries whose timestamps do not include an explicit timezone.  When this property is not specified, the timezone of the entity specified is used.  If the entity is also not specified or do not have a valid timezone then UTC is used.
         * 
         * ** IMPORTANT **
         * Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
         * 
         * @return builder
         * 
         */
        public Builder timezone(@Nullable Output<String> timezone) {
            $.timezone = timezone;
            return this;
        }

        /**
         * @param timezone (Updatable) Timezone to be used when processing log entries whose timestamps do not include an explicit timezone.  When this property is not specified, the timezone of the entity specified is used.  If the entity is also not specified or do not have a valid timezone then UTC is used.
         * 
         * ** IMPORTANT **
         * Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
         * 
         * @return builder
         * 
         */
        public Builder timezone(String timezone) {
            return timezone(Output.of(timezone));
        }

        public LogAnalyticsObjectCollectionRuleArgs build() {
            if ($.compartmentId == null) {
                throw new MissingRequiredPropertyException("LogAnalyticsObjectCollectionRuleArgs", "compartmentId");
            }
            if ($.logGroupId == null) {
                throw new MissingRequiredPropertyException("LogAnalyticsObjectCollectionRuleArgs", "logGroupId");
            }
            if ($.logSourceName == null) {
                throw new MissingRequiredPropertyException("LogAnalyticsObjectCollectionRuleArgs", "logSourceName");
            }
            if ($.namespace == null) {
                throw new MissingRequiredPropertyException("LogAnalyticsObjectCollectionRuleArgs", "namespace");
            }
            if ($.osBucketName == null) {
                throw new MissingRequiredPropertyException("LogAnalyticsObjectCollectionRuleArgs", "osBucketName");
            }
            if ($.osNamespace == null) {
                throw new MissingRequiredPropertyException("LogAnalyticsObjectCollectionRuleArgs", "osNamespace");
            }
            return $;
        }
    }

}
