// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.oci.Logging.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.oci.Logging.inputs.UnifiedAgentConfigurationServiceConfigurationApplicationConfigurationSourceParserNestedParserArgs;
import com.pulumi.oci.Logging.inputs.UnifiedAgentConfigurationServiceConfigurationApplicationConfigurationSourceParserPatternArgs;
import com.pulumi.oci.Logging.inputs.UnifiedAgentConfigurationServiceConfigurationApplicationConfigurationSourceParserRecordInputArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.Object;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class UnifiedAgentConfigurationServiceConfigurationApplicationConfigurationSourceParserArgs extends com.pulumi.resources.ResourceArgs {

    public static final UnifiedAgentConfigurationServiceConfigurationApplicationConfigurationSourceParserArgs Empty = new UnifiedAgentConfigurationServiceConfigurationApplicationConfigurationSourceParserArgs();

    /**
     * (Updatable) CSV delimiter.
     * 
     */
    @Import(name="delimiter")
    private @Nullable Output<String> delimiter;

    /**
     * @return (Updatable) CSV delimiter.
     * 
     */
    public Optional<Output<String>> delimiter() {
        return Optional.ofNullable(this.delimiter);
    }

    /**
     * (Updatable) Regex pattern.
     * 
     */
    @Import(name="expression")
    private @Nullable Output<String> expression;

    /**
     * @return (Updatable) Regex pattern.
     * 
     */
    public Optional<Output<String>> expression() {
        return Optional.ofNullable(this.expression);
    }

    /**
     * (Updatable) Specifies the time field for the event time. If the event doesn&#39;t have this field, the current time is used.
     * 
     */
    @Import(name="fieldTimeKey")
    private @Nullable Output<String> fieldTimeKey;

    /**
     * @return (Updatable) Specifies the time field for the event time. If the event doesn&#39;t have this field, the current time is used.
     * 
     */
    public Optional<Output<String>> fieldTimeKey() {
        return Optional.ofNullable(this.fieldTimeKey);
    }

    /**
     * (Updatable) First line pattern format.
     * 
     */
    @Import(name="formatFirstline")
    private @Nullable Output<String> formatFirstline;

    /**
     * @return (Updatable) First line pattern format.
     * 
     */
    public Optional<Output<String>> formatFirstline() {
        return Optional.ofNullable(this.formatFirstline);
    }

    /**
     * (Updatable) Mutiline pattern format.
     * 
     */
    @Import(name="formats")
    private @Nullable Output<List<String>> formats;

    /**
     * @return (Updatable) Mutiline pattern format.
     * 
     */
    public Optional<Output<List<String>>> formats() {
        return Optional.ofNullable(this.formats);
    }

    /**
     * (Updatable) Grok failure key.
     * 
     */
    @Import(name="grokFailureKey")
    private @Nullable Output<String> grokFailureKey;

    /**
     * @return (Updatable) Grok failure key.
     * 
     */
    public Optional<Output<String>> grokFailureKey() {
        return Optional.ofNullable(this.grokFailureKey);
    }

    /**
     * (Updatable) Grok name key.
     * 
     */
    @Import(name="grokNameKey")
    private @Nullable Output<String> grokNameKey;

    /**
     * @return (Updatable) Grok name key.
     * 
     */
    public Optional<Output<String>> grokNameKey() {
        return Optional.ofNullable(this.grokNameKey);
    }

    /**
     * (Updatable) If true, use Fluent::EventTime.now(current time) as a timestamp when the time_key is specified.
     * 
     */
    @Import(name="isEstimateCurrentEvent")
    private @Nullable Output<Boolean> isEstimateCurrentEvent;

    /**
     * @return (Updatable) If true, use Fluent::EventTime.now(current time) as a timestamp when the time_key is specified.
     * 
     */
    public Optional<Output<Boolean>> isEstimateCurrentEvent() {
        return Optional.ofNullable(this.isEstimateCurrentEvent);
    }

    /**
     * (Updatable) If true, keep the time field in the record.
     * 
     */
    @Import(name="isKeepTimeKey")
    private @Nullable Output<Boolean> isKeepTimeKey;

    /**
     * @return (Updatable) If true, keep the time field in the record.
     * 
     */
    public Optional<Output<Boolean>> isKeepTimeKey() {
        return Optional.ofNullable(this.isKeepTimeKey);
    }

    /**
     * (Updatable) If you don&#39;t need stream or logtag fields, set this to false.
     * 
     */
    @Import(name="isMergeCriFields")
    private @Nullable Output<Boolean> isMergeCriFields;

    /**
     * @return (Updatable) If you don&#39;t need stream or logtag fields, set this to false.
     * 
     */
    public Optional<Output<Boolean>> isMergeCriFields() {
        return Optional.ofNullable(this.isMergeCriFields);
    }

    /**
     * (Updatable) If true, an empty string field is replaced with a null value.
     * 
     */
    @Import(name="isNullEmptyString")
    private @Nullable Output<Boolean> isNullEmptyString;

    /**
     * @return (Updatable) If true, an empty string field is replaced with a null value.
     * 
     */
    public Optional<Output<Boolean>> isNullEmptyString() {
        return Optional.ofNullable(this.isNullEmptyString);
    }

    /**
     * (Updatable) Specifies whether or not to support colonless ident. Corresponds to the Fluentd support_colonless_ident parameter.
     * 
     */
    @Import(name="isSupportColonlessIdent")
    private @Nullable Output<Boolean> isSupportColonlessIdent;

    /**
     * @return (Updatable) Specifies whether or not to support colonless ident. Corresponds to the Fluentd support_colonless_ident parameter.
     * 
     */
    public Optional<Output<Boolean>> isSupportColonlessIdent() {
        return Optional.ofNullable(this.isSupportColonlessIdent);
    }

    /**
     * (Updatable) Specifies with priority or not. Corresponds to the Fluentd with_priority parameter.
     * 
     */
    @Import(name="isWithPriority")
    private @Nullable Output<Boolean> isWithPriority;

    /**
     * @return (Updatable) Specifies with priority or not. Corresponds to the Fluentd with_priority parameter.
     * 
     */
    public Optional<Output<Boolean>> isWithPriority() {
        return Optional.ofNullable(this.isWithPriority);
    }

    /**
     * (Updatable) CSV keys.
     * 
     */
    @Import(name="keys")
    private @Nullable Output<List<String>> keys;

    /**
     * @return (Updatable) CSV keys.
     * 
     */
    public Optional<Output<List<String>>> keys() {
        return Optional.ofNullable(this.keys);
    }

    /**
     * (Updatable) Syslog message format.
     * 
     */
    @Import(name="messageFormat")
    private @Nullable Output<String> messageFormat;

    /**
     * @return (Updatable) Syslog message format.
     * 
     */
    public Optional<Output<String>> messageFormat() {
        return Optional.ofNullable(this.messageFormat);
    }

    /**
     * (Updatable) Specifies the field name to contain logs.
     * 
     */
    @Import(name="messageKey")
    private @Nullable Output<String> messageKey;

    /**
     * @return (Updatable) Specifies the field name to contain logs.
     * 
     */
    public Optional<Output<String>> messageKey() {
        return Optional.ofNullable(this.messageKey);
    }

    /**
     * (Updatable) Multiline start regexp pattern.
     * 
     */
    @Import(name="multiLineStartRegexp")
    private @Nullable Output<String> multiLineStartRegexp;

    /**
     * @return (Updatable) Multiline start regexp pattern.
     * 
     */
    public Optional<Output<String>> multiLineStartRegexp() {
        return Optional.ofNullable(this.multiLineStartRegexp);
    }

    /**
     * (Updatable) Optional nested JSON Parser for CRI. Supported fields are fieldTimeKey, timeFormat, and isKeepTimeKey.
     * 
     */
    @Import(name="nestedParser")
    private @Nullable Output<UnifiedAgentConfigurationServiceConfigurationApplicationConfigurationSourceParserNestedParserArgs> nestedParser;

    /**
     * @return (Updatable) Optional nested JSON Parser for CRI. Supported fields are fieldTimeKey, timeFormat, and isKeepTimeKey.
     * 
     */
    public Optional<Output<UnifiedAgentConfigurationServiceConfigurationApplicationConfigurationSourceParserNestedParserArgs>> nestedParser() {
        return Optional.ofNullable(this.nestedParser);
    }

    /**
     * (Updatable) Specify the null value pattern.
     * 
     */
    @Import(name="nullValuePattern")
    private @Nullable Output<String> nullValuePattern;

    /**
     * @return (Updatable) Specify the null value pattern.
     * 
     */
    public Optional<Output<String>> nullValuePattern() {
        return Optional.ofNullable(this.nullValuePattern);
    }

    /**
     * (Updatable) If true, a separator parameter can be further defined.
     * 
     */
    @Import(name="parseNested")
    private @Nullable Output<Boolean> parseNested;

    /**
     * @return (Updatable) If true, a separator parameter can be further defined.
     * 
     */
    public Optional<Output<Boolean>> parseNested() {
        return Optional.ofNullable(this.parseNested);
    }

    /**
     * (Updatable) Type of fluent parser.
     * 
     */
    @Import(name="parserType", required=true)
    private Output<String> parserType;

    /**
     * @return (Updatable) Type of fluent parser.
     * 
     */
    public Output<String> parserType() {
        return this.parserType;
    }

    /**
     * (Updatable) Grok pattern object.
     * 
     */
    @Import(name="patterns")
    private @Nullable Output<List<UnifiedAgentConfigurationServiceConfigurationApplicationConfigurationSourceParserPatternArgs>> patterns;

    /**
     * @return (Updatable) Grok pattern object.
     * 
     */
    public Optional<Output<List<UnifiedAgentConfigurationServiceConfigurationApplicationConfigurationSourceParserPatternArgs>>> patterns() {
        return Optional.ofNullable(this.patterns);
    }

    /**
     * (Updatable) record section of openmetrics parser.
     * 
     */
    @Import(name="recordInput")
    private @Nullable Output<UnifiedAgentConfigurationServiceConfigurationApplicationConfigurationSourceParserRecordInputArgs> recordInput;

    /**
     * @return (Updatable) record section of openmetrics parser.
     * 
     */
    public Optional<Output<UnifiedAgentConfigurationServiceConfigurationApplicationConfigurationSourceParserRecordInputArgs>> recordInput() {
        return Optional.ofNullable(this.recordInput);
    }

    /**
     * (Updatable) RFC 5424 time format.
     * 
     */
    @Import(name="rfc5424timeFormat")
    private @Nullable Output<String> rfc5424timeFormat;

    /**
     * @return (Updatable) RFC 5424 time format.
     * 
     */
    public Optional<Output<String>> rfc5424timeFormat() {
        return Optional.ofNullable(this.rfc5424timeFormat);
    }

    /**
     * (Updatable) Keys of adjacent levels are joined by the separator.
     * 
     */
    @Import(name="separator")
    private @Nullable Output<String> separator;

    /**
     * @return (Updatable) Keys of adjacent levels are joined by the separator.
     * 
     */
    public Optional<Output<String>> separator() {
        return Optional.ofNullable(this.separator);
    }

    /**
     * (Updatable) Syslog parser type.
     * 
     */
    @Import(name="syslogParserType")
    private @Nullable Output<String> syslogParserType;

    /**
     * @return (Updatable) Syslog parser type.
     * 
     */
    public Optional<Output<String>> syslogParserType() {
        return Optional.ofNullable(this.syslogParserType);
    }

    /**
     * (Updatable) Process time value using the specified format.
     * 
     */
    @Import(name="timeFormat")
    private @Nullable Output<String> timeFormat;

    /**
     * @return (Updatable) Process time value using the specified format.
     * 
     */
    public Optional<Output<String>> timeFormat() {
        return Optional.ofNullable(this.timeFormat);
    }

    /**
     * (Updatable) JSON parser time type.
     * 
     */
    @Import(name="timeType")
    private @Nullable Output<String> timeType;

    /**
     * @return (Updatable) JSON parser time type.
     * 
     */
    public Optional<Output<String>> timeType() {
        return Optional.ofNullable(this.timeType);
    }

    /**
     * (Updatable) Specify the timeout for parse processing. This is mainly for detecting an incorrect regexp pattern.
     * 
     */
    @Import(name="timeoutInMilliseconds")
    private @Nullable Output<Integer> timeoutInMilliseconds;

    /**
     * @return (Updatable) Specify the timeout for parse processing. This is mainly for detecting an incorrect regexp pattern.
     * 
     */
    public Optional<Output<Integer>> timeoutInMilliseconds() {
        return Optional.ofNullable(this.timeoutInMilliseconds);
    }

    /**
     * (Updatable) Specify types for converting a field into another type. For example, With this configuration: &lt;parse&gt; {@literal @}type csv keys time,host,req_id,user time_key time &lt;/parse&gt;
     * 
     * This incoming event: &#34;2013/02/28 12:00:00,192.168.0.1,111,-&#34;
     * 
     * is parsed as: 1362020400 (2013/02/28/ 12:00:00)
     * 
     * record: { &#34;host&#34;   : &#34;192.168.0.1&#34;, &#34;req_id&#34; : &#34;111&#34;, &#34;user&#34;   : &#34;-&#34; }
     * 
     */
    @Import(name="types")
    private @Nullable Output<Map<String,Object>> types;

    /**
     * @return (Updatable) Specify types for converting a field into another type. For example, With this configuration: &lt;parse&gt; {@literal @}type csv keys time,host,req_id,user time_key time &lt;/parse&gt;
     * 
     * This incoming event: &#34;2013/02/28 12:00:00,192.168.0.1,111,-&#34;
     * 
     * is parsed as: 1362020400 (2013/02/28/ 12:00:00)
     * 
     * record: { &#34;host&#34;   : &#34;192.168.0.1&#34;, &#34;req_id&#34; : &#34;111&#34;, &#34;user&#34;   : &#34;-&#34; }
     * 
     */
    public Optional<Output<Map<String,Object>>> types() {
        return Optional.ofNullable(this.types);
    }

    private UnifiedAgentConfigurationServiceConfigurationApplicationConfigurationSourceParserArgs() {}

    private UnifiedAgentConfigurationServiceConfigurationApplicationConfigurationSourceParserArgs(UnifiedAgentConfigurationServiceConfigurationApplicationConfigurationSourceParserArgs $) {
        this.delimiter = $.delimiter;
        this.expression = $.expression;
        this.fieldTimeKey = $.fieldTimeKey;
        this.formatFirstline = $.formatFirstline;
        this.formats = $.formats;
        this.grokFailureKey = $.grokFailureKey;
        this.grokNameKey = $.grokNameKey;
        this.isEstimateCurrentEvent = $.isEstimateCurrentEvent;
        this.isKeepTimeKey = $.isKeepTimeKey;
        this.isMergeCriFields = $.isMergeCriFields;
        this.isNullEmptyString = $.isNullEmptyString;
        this.isSupportColonlessIdent = $.isSupportColonlessIdent;
        this.isWithPriority = $.isWithPriority;
        this.keys = $.keys;
        this.messageFormat = $.messageFormat;
        this.messageKey = $.messageKey;
        this.multiLineStartRegexp = $.multiLineStartRegexp;
        this.nestedParser = $.nestedParser;
        this.nullValuePattern = $.nullValuePattern;
        this.parseNested = $.parseNested;
        this.parserType = $.parserType;
        this.patterns = $.patterns;
        this.recordInput = $.recordInput;
        this.rfc5424timeFormat = $.rfc5424timeFormat;
        this.separator = $.separator;
        this.syslogParserType = $.syslogParserType;
        this.timeFormat = $.timeFormat;
        this.timeType = $.timeType;
        this.timeoutInMilliseconds = $.timeoutInMilliseconds;
        this.types = $.types;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(UnifiedAgentConfigurationServiceConfigurationApplicationConfigurationSourceParserArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private UnifiedAgentConfigurationServiceConfigurationApplicationConfigurationSourceParserArgs $;

        public Builder() {
            $ = new UnifiedAgentConfigurationServiceConfigurationApplicationConfigurationSourceParserArgs();
        }

        public Builder(UnifiedAgentConfigurationServiceConfigurationApplicationConfigurationSourceParserArgs defaults) {
            $ = new UnifiedAgentConfigurationServiceConfigurationApplicationConfigurationSourceParserArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param delimiter (Updatable) CSV delimiter.
         * 
         * @return builder
         * 
         */
        public Builder delimiter(@Nullable Output<String> delimiter) {
            $.delimiter = delimiter;
            return this;
        }

        /**
         * @param delimiter (Updatable) CSV delimiter.
         * 
         * @return builder
         * 
         */
        public Builder delimiter(String delimiter) {
            return delimiter(Output.of(delimiter));
        }

        /**
         * @param expression (Updatable) Regex pattern.
         * 
         * @return builder
         * 
         */
        public Builder expression(@Nullable Output<String> expression) {
            $.expression = expression;
            return this;
        }

        /**
         * @param expression (Updatable) Regex pattern.
         * 
         * @return builder
         * 
         */
        public Builder expression(String expression) {
            return expression(Output.of(expression));
        }

        /**
         * @param fieldTimeKey (Updatable) Specifies the time field for the event time. If the event doesn&#39;t have this field, the current time is used.
         * 
         * @return builder
         * 
         */
        public Builder fieldTimeKey(@Nullable Output<String> fieldTimeKey) {
            $.fieldTimeKey = fieldTimeKey;
            return this;
        }

        /**
         * @param fieldTimeKey (Updatable) Specifies the time field for the event time. If the event doesn&#39;t have this field, the current time is used.
         * 
         * @return builder
         * 
         */
        public Builder fieldTimeKey(String fieldTimeKey) {
            return fieldTimeKey(Output.of(fieldTimeKey));
        }

        /**
         * @param formatFirstline (Updatable) First line pattern format.
         * 
         * @return builder
         * 
         */
        public Builder formatFirstline(@Nullable Output<String> formatFirstline) {
            $.formatFirstline = formatFirstline;
            return this;
        }

        /**
         * @param formatFirstline (Updatable) First line pattern format.
         * 
         * @return builder
         * 
         */
        public Builder formatFirstline(String formatFirstline) {
            return formatFirstline(Output.of(formatFirstline));
        }

        /**
         * @param formats (Updatable) Mutiline pattern format.
         * 
         * @return builder
         * 
         */
        public Builder formats(@Nullable Output<List<String>> formats) {
            $.formats = formats;
            return this;
        }

        /**
         * @param formats (Updatable) Mutiline pattern format.
         * 
         * @return builder
         * 
         */
        public Builder formats(List<String> formats) {
            return formats(Output.of(formats));
        }

        /**
         * @param formats (Updatable) Mutiline pattern format.
         * 
         * @return builder
         * 
         */
        public Builder formats(String... formats) {
            return formats(List.of(formats));
        }

        /**
         * @param grokFailureKey (Updatable) Grok failure key.
         * 
         * @return builder
         * 
         */
        public Builder grokFailureKey(@Nullable Output<String> grokFailureKey) {
            $.grokFailureKey = grokFailureKey;
            return this;
        }

        /**
         * @param grokFailureKey (Updatable) Grok failure key.
         * 
         * @return builder
         * 
         */
        public Builder grokFailureKey(String grokFailureKey) {
            return grokFailureKey(Output.of(grokFailureKey));
        }

        /**
         * @param grokNameKey (Updatable) Grok name key.
         * 
         * @return builder
         * 
         */
        public Builder grokNameKey(@Nullable Output<String> grokNameKey) {
            $.grokNameKey = grokNameKey;
            return this;
        }

        /**
         * @param grokNameKey (Updatable) Grok name key.
         * 
         * @return builder
         * 
         */
        public Builder grokNameKey(String grokNameKey) {
            return grokNameKey(Output.of(grokNameKey));
        }

        /**
         * @param isEstimateCurrentEvent (Updatable) If true, use Fluent::EventTime.now(current time) as a timestamp when the time_key is specified.
         * 
         * @return builder
         * 
         */
        public Builder isEstimateCurrentEvent(@Nullable Output<Boolean> isEstimateCurrentEvent) {
            $.isEstimateCurrentEvent = isEstimateCurrentEvent;
            return this;
        }

        /**
         * @param isEstimateCurrentEvent (Updatable) If true, use Fluent::EventTime.now(current time) as a timestamp when the time_key is specified.
         * 
         * @return builder
         * 
         */
        public Builder isEstimateCurrentEvent(Boolean isEstimateCurrentEvent) {
            return isEstimateCurrentEvent(Output.of(isEstimateCurrentEvent));
        }

        /**
         * @param isKeepTimeKey (Updatable) If true, keep the time field in the record.
         * 
         * @return builder
         * 
         */
        public Builder isKeepTimeKey(@Nullable Output<Boolean> isKeepTimeKey) {
            $.isKeepTimeKey = isKeepTimeKey;
            return this;
        }

        /**
         * @param isKeepTimeKey (Updatable) If true, keep the time field in the record.
         * 
         * @return builder
         * 
         */
        public Builder isKeepTimeKey(Boolean isKeepTimeKey) {
            return isKeepTimeKey(Output.of(isKeepTimeKey));
        }

        /**
         * @param isMergeCriFields (Updatable) If you don&#39;t need stream or logtag fields, set this to false.
         * 
         * @return builder
         * 
         */
        public Builder isMergeCriFields(@Nullable Output<Boolean> isMergeCriFields) {
            $.isMergeCriFields = isMergeCriFields;
            return this;
        }

        /**
         * @param isMergeCriFields (Updatable) If you don&#39;t need stream or logtag fields, set this to false.
         * 
         * @return builder
         * 
         */
        public Builder isMergeCriFields(Boolean isMergeCriFields) {
            return isMergeCriFields(Output.of(isMergeCriFields));
        }

        /**
         * @param isNullEmptyString (Updatable) If true, an empty string field is replaced with a null value.
         * 
         * @return builder
         * 
         */
        public Builder isNullEmptyString(@Nullable Output<Boolean> isNullEmptyString) {
            $.isNullEmptyString = isNullEmptyString;
            return this;
        }

        /**
         * @param isNullEmptyString (Updatable) If true, an empty string field is replaced with a null value.
         * 
         * @return builder
         * 
         */
        public Builder isNullEmptyString(Boolean isNullEmptyString) {
            return isNullEmptyString(Output.of(isNullEmptyString));
        }

        /**
         * @param isSupportColonlessIdent (Updatable) Specifies whether or not to support colonless ident. Corresponds to the Fluentd support_colonless_ident parameter.
         * 
         * @return builder
         * 
         */
        public Builder isSupportColonlessIdent(@Nullable Output<Boolean> isSupportColonlessIdent) {
            $.isSupportColonlessIdent = isSupportColonlessIdent;
            return this;
        }

        /**
         * @param isSupportColonlessIdent (Updatable) Specifies whether or not to support colonless ident. Corresponds to the Fluentd support_colonless_ident parameter.
         * 
         * @return builder
         * 
         */
        public Builder isSupportColonlessIdent(Boolean isSupportColonlessIdent) {
            return isSupportColonlessIdent(Output.of(isSupportColonlessIdent));
        }

        /**
         * @param isWithPriority (Updatable) Specifies with priority or not. Corresponds to the Fluentd with_priority parameter.
         * 
         * @return builder
         * 
         */
        public Builder isWithPriority(@Nullable Output<Boolean> isWithPriority) {
            $.isWithPriority = isWithPriority;
            return this;
        }

        /**
         * @param isWithPriority (Updatable) Specifies with priority or not. Corresponds to the Fluentd with_priority parameter.
         * 
         * @return builder
         * 
         */
        public Builder isWithPriority(Boolean isWithPriority) {
            return isWithPriority(Output.of(isWithPriority));
        }

        /**
         * @param keys (Updatable) CSV keys.
         * 
         * @return builder
         * 
         */
        public Builder keys(@Nullable Output<List<String>> keys) {
            $.keys = keys;
            return this;
        }

        /**
         * @param keys (Updatable) CSV keys.
         * 
         * @return builder
         * 
         */
        public Builder keys(List<String> keys) {
            return keys(Output.of(keys));
        }

        /**
         * @param keys (Updatable) CSV keys.
         * 
         * @return builder
         * 
         */
        public Builder keys(String... keys) {
            return keys(List.of(keys));
        }

        /**
         * @param messageFormat (Updatable) Syslog message format.
         * 
         * @return builder
         * 
         */
        public Builder messageFormat(@Nullable Output<String> messageFormat) {
            $.messageFormat = messageFormat;
            return this;
        }

        /**
         * @param messageFormat (Updatable) Syslog message format.
         * 
         * @return builder
         * 
         */
        public Builder messageFormat(String messageFormat) {
            return messageFormat(Output.of(messageFormat));
        }

        /**
         * @param messageKey (Updatable) Specifies the field name to contain logs.
         * 
         * @return builder
         * 
         */
        public Builder messageKey(@Nullable Output<String> messageKey) {
            $.messageKey = messageKey;
            return this;
        }

        /**
         * @param messageKey (Updatable) Specifies the field name to contain logs.
         * 
         * @return builder
         * 
         */
        public Builder messageKey(String messageKey) {
            return messageKey(Output.of(messageKey));
        }

        /**
         * @param multiLineStartRegexp (Updatable) Multiline start regexp pattern.
         * 
         * @return builder
         * 
         */
        public Builder multiLineStartRegexp(@Nullable Output<String> multiLineStartRegexp) {
            $.multiLineStartRegexp = multiLineStartRegexp;
            return this;
        }

        /**
         * @param multiLineStartRegexp (Updatable) Multiline start regexp pattern.
         * 
         * @return builder
         * 
         */
        public Builder multiLineStartRegexp(String multiLineStartRegexp) {
            return multiLineStartRegexp(Output.of(multiLineStartRegexp));
        }

        /**
         * @param nestedParser (Updatable) Optional nested JSON Parser for CRI. Supported fields are fieldTimeKey, timeFormat, and isKeepTimeKey.
         * 
         * @return builder
         * 
         */
        public Builder nestedParser(@Nullable Output<UnifiedAgentConfigurationServiceConfigurationApplicationConfigurationSourceParserNestedParserArgs> nestedParser) {
            $.nestedParser = nestedParser;
            return this;
        }

        /**
         * @param nestedParser (Updatable) Optional nested JSON Parser for CRI. Supported fields are fieldTimeKey, timeFormat, and isKeepTimeKey.
         * 
         * @return builder
         * 
         */
        public Builder nestedParser(UnifiedAgentConfigurationServiceConfigurationApplicationConfigurationSourceParserNestedParserArgs nestedParser) {
            return nestedParser(Output.of(nestedParser));
        }

        /**
         * @param nullValuePattern (Updatable) Specify the null value pattern.
         * 
         * @return builder
         * 
         */
        public Builder nullValuePattern(@Nullable Output<String> nullValuePattern) {
            $.nullValuePattern = nullValuePattern;
            return this;
        }

        /**
         * @param nullValuePattern (Updatable) Specify the null value pattern.
         * 
         * @return builder
         * 
         */
        public Builder nullValuePattern(String nullValuePattern) {
            return nullValuePattern(Output.of(nullValuePattern));
        }

        /**
         * @param parseNested (Updatable) If true, a separator parameter can be further defined.
         * 
         * @return builder
         * 
         */
        public Builder parseNested(@Nullable Output<Boolean> parseNested) {
            $.parseNested = parseNested;
            return this;
        }

        /**
         * @param parseNested (Updatable) If true, a separator parameter can be further defined.
         * 
         * @return builder
         * 
         */
        public Builder parseNested(Boolean parseNested) {
            return parseNested(Output.of(parseNested));
        }

        /**
         * @param parserType (Updatable) Type of fluent parser.
         * 
         * @return builder
         * 
         */
        public Builder parserType(Output<String> parserType) {
            $.parserType = parserType;
            return this;
        }

        /**
         * @param parserType (Updatable) Type of fluent parser.
         * 
         * @return builder
         * 
         */
        public Builder parserType(String parserType) {
            return parserType(Output.of(parserType));
        }

        /**
         * @param patterns (Updatable) Grok pattern object.
         * 
         * @return builder
         * 
         */
        public Builder patterns(@Nullable Output<List<UnifiedAgentConfigurationServiceConfigurationApplicationConfigurationSourceParserPatternArgs>> patterns) {
            $.patterns = patterns;
            return this;
        }

        /**
         * @param patterns (Updatable) Grok pattern object.
         * 
         * @return builder
         * 
         */
        public Builder patterns(List<UnifiedAgentConfigurationServiceConfigurationApplicationConfigurationSourceParserPatternArgs> patterns) {
            return patterns(Output.of(patterns));
        }

        /**
         * @param patterns (Updatable) Grok pattern object.
         * 
         * @return builder
         * 
         */
        public Builder patterns(UnifiedAgentConfigurationServiceConfigurationApplicationConfigurationSourceParserPatternArgs... patterns) {
            return patterns(List.of(patterns));
        }

        /**
         * @param recordInput (Updatable) record section of openmetrics parser.
         * 
         * @return builder
         * 
         */
        public Builder recordInput(@Nullable Output<UnifiedAgentConfigurationServiceConfigurationApplicationConfigurationSourceParserRecordInputArgs> recordInput) {
            $.recordInput = recordInput;
            return this;
        }

        /**
         * @param recordInput (Updatable) record section of openmetrics parser.
         * 
         * @return builder
         * 
         */
        public Builder recordInput(UnifiedAgentConfigurationServiceConfigurationApplicationConfigurationSourceParserRecordInputArgs recordInput) {
            return recordInput(Output.of(recordInput));
        }

        /**
         * @param rfc5424timeFormat (Updatable) RFC 5424 time format.
         * 
         * @return builder
         * 
         */
        public Builder rfc5424timeFormat(@Nullable Output<String> rfc5424timeFormat) {
            $.rfc5424timeFormat = rfc5424timeFormat;
            return this;
        }

        /**
         * @param rfc5424timeFormat (Updatable) RFC 5424 time format.
         * 
         * @return builder
         * 
         */
        public Builder rfc5424timeFormat(String rfc5424timeFormat) {
            return rfc5424timeFormat(Output.of(rfc5424timeFormat));
        }

        /**
         * @param separator (Updatable) Keys of adjacent levels are joined by the separator.
         * 
         * @return builder
         * 
         */
        public Builder separator(@Nullable Output<String> separator) {
            $.separator = separator;
            return this;
        }

        /**
         * @param separator (Updatable) Keys of adjacent levels are joined by the separator.
         * 
         * @return builder
         * 
         */
        public Builder separator(String separator) {
            return separator(Output.of(separator));
        }

        /**
         * @param syslogParserType (Updatable) Syslog parser type.
         * 
         * @return builder
         * 
         */
        public Builder syslogParserType(@Nullable Output<String> syslogParserType) {
            $.syslogParserType = syslogParserType;
            return this;
        }

        /**
         * @param syslogParserType (Updatable) Syslog parser type.
         * 
         * @return builder
         * 
         */
        public Builder syslogParserType(String syslogParserType) {
            return syslogParserType(Output.of(syslogParserType));
        }

        /**
         * @param timeFormat (Updatable) Process time value using the specified format.
         * 
         * @return builder
         * 
         */
        public Builder timeFormat(@Nullable Output<String> timeFormat) {
            $.timeFormat = timeFormat;
            return this;
        }

        /**
         * @param timeFormat (Updatable) Process time value using the specified format.
         * 
         * @return builder
         * 
         */
        public Builder timeFormat(String timeFormat) {
            return timeFormat(Output.of(timeFormat));
        }

        /**
         * @param timeType (Updatable) JSON parser time type.
         * 
         * @return builder
         * 
         */
        public Builder timeType(@Nullable Output<String> timeType) {
            $.timeType = timeType;
            return this;
        }

        /**
         * @param timeType (Updatable) JSON parser time type.
         * 
         * @return builder
         * 
         */
        public Builder timeType(String timeType) {
            return timeType(Output.of(timeType));
        }

        /**
         * @param timeoutInMilliseconds (Updatable) Specify the timeout for parse processing. This is mainly for detecting an incorrect regexp pattern.
         * 
         * @return builder
         * 
         */
        public Builder timeoutInMilliseconds(@Nullable Output<Integer> timeoutInMilliseconds) {
            $.timeoutInMilliseconds = timeoutInMilliseconds;
            return this;
        }

        /**
         * @param timeoutInMilliseconds (Updatable) Specify the timeout for parse processing. This is mainly for detecting an incorrect regexp pattern.
         * 
         * @return builder
         * 
         */
        public Builder timeoutInMilliseconds(Integer timeoutInMilliseconds) {
            return timeoutInMilliseconds(Output.of(timeoutInMilliseconds));
        }

        /**
         * @param types (Updatable) Specify types for converting a field into another type. For example, With this configuration: &lt;parse&gt; {@literal @}type csv keys time,host,req_id,user time_key time &lt;/parse&gt;
         * 
         * This incoming event: &#34;2013/02/28 12:00:00,192.168.0.1,111,-&#34;
         * 
         * is parsed as: 1362020400 (2013/02/28/ 12:00:00)
         * 
         * record: { &#34;host&#34;   : &#34;192.168.0.1&#34;, &#34;req_id&#34; : &#34;111&#34;, &#34;user&#34;   : &#34;-&#34; }
         * 
         * @return builder
         * 
         */
        public Builder types(@Nullable Output<Map<String,Object>> types) {
            $.types = types;
            return this;
        }

        /**
         * @param types (Updatable) Specify types for converting a field into another type. For example, With this configuration: &lt;parse&gt; {@literal @}type csv keys time,host,req_id,user time_key time &lt;/parse&gt;
         * 
         * This incoming event: &#34;2013/02/28 12:00:00,192.168.0.1,111,-&#34;
         * 
         * is parsed as: 1362020400 (2013/02/28/ 12:00:00)
         * 
         * record: { &#34;host&#34;   : &#34;192.168.0.1&#34;, &#34;req_id&#34; : &#34;111&#34;, &#34;user&#34;   : &#34;-&#34; }
         * 
         * @return builder
         * 
         */
        public Builder types(Map<String,Object> types) {
            return types(Output.of(types));
        }

        public UnifiedAgentConfigurationServiceConfigurationApplicationConfigurationSourceParserArgs build() {
            if ($.parserType == null) {
                throw new MissingRequiredPropertyException("UnifiedAgentConfigurationServiceConfigurationApplicationConfigurationSourceParserArgs", "parserType");
            }
            return $;
        }
    }

}
