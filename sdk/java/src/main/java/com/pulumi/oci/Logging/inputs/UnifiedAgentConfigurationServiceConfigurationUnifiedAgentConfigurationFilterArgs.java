// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.oci.Logging.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.oci.Logging.inputs.UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterAllowListArgs;
import com.pulumi.oci.Logging.inputs.UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterCustomSectionArgs;
import com.pulumi.oci.Logging.inputs.UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterDenyListArgs;
import com.pulumi.oci.Logging.inputs.UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserArgs;
import com.pulumi.oci.Logging.inputs.UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterRecordListArgs;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterArgs extends com.pulumi.resources.ResourceArgs {

    public static final UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterArgs Empty = new UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterArgs();

    /**
     * (Updatable) A list of filtering rules to include logs
     * 
     */
    @Import(name="allowLists")
    private @Nullable Output<List<UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterAllowListArgs>> allowLists;

    /**
     * @return (Updatable) A list of filtering rules to include logs
     * 
     */
    public Optional<Output<List<UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterAllowListArgs>>> allowLists() {
        return Optional.ofNullable(this.allowLists);
    }

    /**
     * (Updatable) Type of the custom filter
     * 
     */
    @Import(name="customFilterType")
    private @Nullable Output<String> customFilterType;

    /**
     * @return (Updatable) Type of the custom filter
     * 
     */
    public Optional<Output<String>> customFilterType() {
        return Optional.ofNullable(this.customFilterType);
    }

    /**
     * (Updatable) List of custom sections in custom filter
     * 
     */
    @Import(name="customSections")
    private @Nullable Output<List<UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterCustomSectionArgs>> customSections;

    /**
     * @return (Updatable) List of custom sections in custom filter
     * 
     */
    public Optional<Output<List<UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterCustomSectionArgs>>> customSections() {
        return Optional.ofNullable(this.customSections);
    }

    /**
     * (Updatable) A list of filtering rules to reject logs
     * 
     */
    @Import(name="denyLists")
    private @Nullable Output<List<UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterDenyListArgs>> denyLists;

    /**
     * @return (Updatable) A list of filtering rules to reject logs
     * 
     */
    public Optional<Output<List<UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterDenyListArgs>>> denyLists() {
        return Optional.ofNullable(this.denyLists);
    }

    /**
     * (Updatable) If true, emit invalid record to {@literal @}ERROR label. Invalid cases are: 1) key does not exist; 2) the format does not match; or 3) an unexpected error. You can rescue unexpected format logs in the {@literal @}ERROR lable. If you want to ignore these errors, set this to false.
     * 
     */
    @Import(name="emitInvalidRecordToError")
    private @Nullable Output<Boolean> emitInvalidRecordToError;

    /**
     * @return (Updatable) If true, emit invalid record to {@literal @}ERROR label. Invalid cases are: 1) key does not exist; 2) the format does not match; or 3) an unexpected error. You can rescue unexpected format logs in the {@literal @}ERROR lable. If you want to ignore these errors, set this to false.
     * 
     */
    public Optional<Output<Boolean>> emitInvalidRecordToError() {
        return Optional.ofNullable(this.emitInvalidRecordToError);
    }

    /**
     * (Updatable) Unified schema logging filter type.
     * 
     */
    @Import(name="filterType", required=true)
    private Output<String> filterType;

    /**
     * @return (Updatable) Unified schema logging filter type.
     * 
     */
    public Output<String> filterType() {
        return this.filterType;
    }

    /**
     * (Updatable) Store the parsed values as a hash value in a field.
     * 
     */
    @Import(name="hashValueField")
    private @Nullable Output<String> hashValueField;

    /**
     * @return (Updatable) Store the parsed values as a hash value in a field.
     * 
     */
    public Optional<Output<String>> hashValueField() {
        return Optional.ofNullable(this.hashValueField);
    }

    /**
     * (Updatable) Store the parsed values with the specified key name prefix.
     * 
     */
    @Import(name="injectKeyPrefix")
    private @Nullable Output<String> injectKeyPrefix;

    /**
     * @return (Updatable) Store the parsed values with the specified key name prefix.
     * 
     */
    public Optional<Output<String>> injectKeyPrefix() {
        return Optional.ofNullable(this.injectKeyPrefix);
    }

    /**
     * (Updatable) If true, automatically casts the field types.
     * 
     */
    @Import(name="isAutoTypecastEnabled")
    private @Nullable Output<Boolean> isAutoTypecastEnabled;

    /**
     * @return (Updatable) If true, automatically casts the field types.
     * 
     */
    public Optional<Output<Boolean>> isAutoTypecastEnabled() {
        return Optional.ofNullable(this.isAutoTypecastEnabled);
    }

    /**
     * (Updatable) If true, it modifies a new empty hash
     * 
     */
    @Import(name="isRenewRecordEnabled")
    private @Nullable Output<Boolean> isRenewRecordEnabled;

    /**
     * @return (Updatable) If true, it modifies a new empty hash
     * 
     */
    public Optional<Output<Boolean>> isRenewRecordEnabled() {
        return Optional.ofNullable(this.isRenewRecordEnabled);
    }

    /**
     * (Updatable) When set to true, the full Ruby syntax is enabled in the ${} expression.
     * 
     */
    @Import(name="isRubyEnabled")
    private @Nullable Output<Boolean> isRubyEnabled;

    /**
     * @return (Updatable) When set to true, the full Ruby syntax is enabled in the ${} expression.
     * 
     */
    public Optional<Output<Boolean>> isRubyEnabled() {
        return Optional.ofNullable(this.isRubyEnabled);
    }

    /**
     * (Updatable) A list of keys to keep. Only relevant if isRenewRecordEnabled is set to true
     * 
     */
    @Import(name="keepKeys")
    private @Nullable Output<List<String>> keepKeys;

    /**
     * @return (Updatable) A list of keys to keep. Only relevant if isRenewRecordEnabled is set to true
     * 
     */
    public Optional<Output<List<String>>> keepKeys() {
        return Optional.ofNullable(this.keepKeys);
    }

    /**
     * (Updatable) The field name in the record to parse.
     * 
     */
    @Import(name="keyName")
    private @Nullable Output<String> keyName;

    /**
     * @return (Updatable) The field name in the record to parse.
     * 
     */
    public Optional<Output<String>> keyName() {
        return Optional.ofNullable(this.keyName);
    }

    /**
     * (Updatable) Unique name for the filter.
     * 
     */
    @Import(name="name", required=true)
    private Output<String> name;

    /**
     * @return (Updatable) Unique name for the filter.
     * 
     */
    public Output<String> name() {
        return this.name;
    }

    /**
     * (Updatable) Parameters of the custom filter
     * 
     */
    @Import(name="params")
    private @Nullable Output<Map<String,String>> params;

    /**
     * @return (Updatable) Parameters of the custom filter
     * 
     */
    public Optional<Output<Map<String,String>>> params() {
        return Optional.ofNullable(this.params);
    }

    /**
     * (Updatable) Source parser object.
     * 
     */
    @Import(name="parser")
    private @Nullable Output<UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserArgs> parser;

    /**
     * @return (Updatable) Source parser object.
     * 
     */
    public Optional<Output<UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserArgs>> parser() {
        return Optional.ofNullable(this.parser);
    }

    /**
     * (Updatable) Add new key-value pairs in logs
     * 
     */
    @Import(name="recordLists")
    private @Nullable Output<List<UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterRecordListArgs>> recordLists;

    /**
     * @return (Updatable) Add new key-value pairs in logs
     * 
     */
    public Optional<Output<List<UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterRecordListArgs>>> recordLists() {
        return Optional.ofNullable(this.recordLists);
    }

    /**
     * (Updatable) If true, remove the keyName field when parsing is succeeded.
     * 
     */
    @Import(name="removeKeyNameField")
    private @Nullable Output<Boolean> removeKeyNameField;

    /**
     * @return (Updatable) If true, remove the keyName field when parsing is succeeded.
     * 
     */
    public Optional<Output<Boolean>> removeKeyNameField() {
        return Optional.ofNullable(this.removeKeyNameField);
    }

    /**
     * (Updatable) A list of keys to delete
     * 
     */
    @Import(name="removeKeys")
    private @Nullable Output<List<String>> removeKeys;

    /**
     * @return (Updatable) A list of keys to delete
     * 
     */
    public Optional<Output<List<String>>> removeKeys() {
        return Optional.ofNullable(this.removeKeys);
    }

    /**
     * (Updatable) Overwrites the time of logs with this value, this value must be a Unix timestamp.
     * 
     */
    @Import(name="renewTimeKey")
    private @Nullable Output<String> renewTimeKey;

    /**
     * @return (Updatable) Overwrites the time of logs with this value, this value must be a Unix timestamp.
     * 
     */
    public Optional<Output<String>> renewTimeKey() {
        return Optional.ofNullable(this.renewTimeKey);
    }

    /**
     * (Updatable) If true, the invalid string is replaced with safe characters and is re-parsed.
     * 
     */
    @Import(name="replaceInvalidSequence")
    private @Nullable Output<Boolean> replaceInvalidSequence;

    /**
     * @return (Updatable) If true, the invalid string is replaced with safe characters and is re-parsed.
     * 
     */
    public Optional<Output<Boolean>> replaceInvalidSequence() {
        return Optional.ofNullable(this.replaceInvalidSequence);
    }

    /**
     * (Updatable) If true, keep the original key-value pair in the parsed result.
     * 
     */
    @Import(name="reserveData")
    private @Nullable Output<Boolean> reserveData;

    /**
     * @return (Updatable) If true, keep the original key-value pair in the parsed result.
     * 
     */
    public Optional<Output<Boolean>> reserveData() {
        return Optional.ofNullable(this.reserveData);
    }

    /**
     * (Updatable) If true, keep the original event time in the parsed result.
     * 
     * ** IMPORTANT **
     * Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
     * 
     */
    @Import(name="reserveTime")
    private @Nullable Output<Boolean> reserveTime;

    /**
     * @return (Updatable) If true, keep the original event time in the parsed result.
     * 
     * ** IMPORTANT **
     * Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
     * 
     */
    public Optional<Output<Boolean>> reserveTime() {
        return Optional.ofNullable(this.reserveTime);
    }

    private UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterArgs() {}

    private UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterArgs(UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterArgs $) {
        this.allowLists = $.allowLists;
        this.customFilterType = $.customFilterType;
        this.customSections = $.customSections;
        this.denyLists = $.denyLists;
        this.emitInvalidRecordToError = $.emitInvalidRecordToError;
        this.filterType = $.filterType;
        this.hashValueField = $.hashValueField;
        this.injectKeyPrefix = $.injectKeyPrefix;
        this.isAutoTypecastEnabled = $.isAutoTypecastEnabled;
        this.isRenewRecordEnabled = $.isRenewRecordEnabled;
        this.isRubyEnabled = $.isRubyEnabled;
        this.keepKeys = $.keepKeys;
        this.keyName = $.keyName;
        this.name = $.name;
        this.params = $.params;
        this.parser = $.parser;
        this.recordLists = $.recordLists;
        this.removeKeyNameField = $.removeKeyNameField;
        this.removeKeys = $.removeKeys;
        this.renewTimeKey = $.renewTimeKey;
        this.replaceInvalidSequence = $.replaceInvalidSequence;
        this.reserveData = $.reserveData;
        this.reserveTime = $.reserveTime;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterArgs $;

        public Builder() {
            $ = new UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterArgs();
        }

        public Builder(UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterArgs defaults) {
            $ = new UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param allowLists (Updatable) A list of filtering rules to include logs
         * 
         * @return builder
         * 
         */
        public Builder allowLists(@Nullable Output<List<UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterAllowListArgs>> allowLists) {
            $.allowLists = allowLists;
            return this;
        }

        /**
         * @param allowLists (Updatable) A list of filtering rules to include logs
         * 
         * @return builder
         * 
         */
        public Builder allowLists(List<UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterAllowListArgs> allowLists) {
            return allowLists(Output.of(allowLists));
        }

        /**
         * @param allowLists (Updatable) A list of filtering rules to include logs
         * 
         * @return builder
         * 
         */
        public Builder allowLists(UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterAllowListArgs... allowLists) {
            return allowLists(List.of(allowLists));
        }

        /**
         * @param customFilterType (Updatable) Type of the custom filter
         * 
         * @return builder
         * 
         */
        public Builder customFilterType(@Nullable Output<String> customFilterType) {
            $.customFilterType = customFilterType;
            return this;
        }

        /**
         * @param customFilterType (Updatable) Type of the custom filter
         * 
         * @return builder
         * 
         */
        public Builder customFilterType(String customFilterType) {
            return customFilterType(Output.of(customFilterType));
        }

        /**
         * @param customSections (Updatable) List of custom sections in custom filter
         * 
         * @return builder
         * 
         */
        public Builder customSections(@Nullable Output<List<UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterCustomSectionArgs>> customSections) {
            $.customSections = customSections;
            return this;
        }

        /**
         * @param customSections (Updatable) List of custom sections in custom filter
         * 
         * @return builder
         * 
         */
        public Builder customSections(List<UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterCustomSectionArgs> customSections) {
            return customSections(Output.of(customSections));
        }

        /**
         * @param customSections (Updatable) List of custom sections in custom filter
         * 
         * @return builder
         * 
         */
        public Builder customSections(UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterCustomSectionArgs... customSections) {
            return customSections(List.of(customSections));
        }

        /**
         * @param denyLists (Updatable) A list of filtering rules to reject logs
         * 
         * @return builder
         * 
         */
        public Builder denyLists(@Nullable Output<List<UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterDenyListArgs>> denyLists) {
            $.denyLists = denyLists;
            return this;
        }

        /**
         * @param denyLists (Updatable) A list of filtering rules to reject logs
         * 
         * @return builder
         * 
         */
        public Builder denyLists(List<UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterDenyListArgs> denyLists) {
            return denyLists(Output.of(denyLists));
        }

        /**
         * @param denyLists (Updatable) A list of filtering rules to reject logs
         * 
         * @return builder
         * 
         */
        public Builder denyLists(UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterDenyListArgs... denyLists) {
            return denyLists(List.of(denyLists));
        }

        /**
         * @param emitInvalidRecordToError (Updatable) If true, emit invalid record to {@literal @}ERROR label. Invalid cases are: 1) key does not exist; 2) the format does not match; or 3) an unexpected error. You can rescue unexpected format logs in the {@literal @}ERROR lable. If you want to ignore these errors, set this to false.
         * 
         * @return builder
         * 
         */
        public Builder emitInvalidRecordToError(@Nullable Output<Boolean> emitInvalidRecordToError) {
            $.emitInvalidRecordToError = emitInvalidRecordToError;
            return this;
        }

        /**
         * @param emitInvalidRecordToError (Updatable) If true, emit invalid record to {@literal @}ERROR label. Invalid cases are: 1) key does not exist; 2) the format does not match; or 3) an unexpected error. You can rescue unexpected format logs in the {@literal @}ERROR lable. If you want to ignore these errors, set this to false.
         * 
         * @return builder
         * 
         */
        public Builder emitInvalidRecordToError(Boolean emitInvalidRecordToError) {
            return emitInvalidRecordToError(Output.of(emitInvalidRecordToError));
        }

        /**
         * @param filterType (Updatable) Unified schema logging filter type.
         * 
         * @return builder
         * 
         */
        public Builder filterType(Output<String> filterType) {
            $.filterType = filterType;
            return this;
        }

        /**
         * @param filterType (Updatable) Unified schema logging filter type.
         * 
         * @return builder
         * 
         */
        public Builder filterType(String filterType) {
            return filterType(Output.of(filterType));
        }

        /**
         * @param hashValueField (Updatable) Store the parsed values as a hash value in a field.
         * 
         * @return builder
         * 
         */
        public Builder hashValueField(@Nullable Output<String> hashValueField) {
            $.hashValueField = hashValueField;
            return this;
        }

        /**
         * @param hashValueField (Updatable) Store the parsed values as a hash value in a field.
         * 
         * @return builder
         * 
         */
        public Builder hashValueField(String hashValueField) {
            return hashValueField(Output.of(hashValueField));
        }

        /**
         * @param injectKeyPrefix (Updatable) Store the parsed values with the specified key name prefix.
         * 
         * @return builder
         * 
         */
        public Builder injectKeyPrefix(@Nullable Output<String> injectKeyPrefix) {
            $.injectKeyPrefix = injectKeyPrefix;
            return this;
        }

        /**
         * @param injectKeyPrefix (Updatable) Store the parsed values with the specified key name prefix.
         * 
         * @return builder
         * 
         */
        public Builder injectKeyPrefix(String injectKeyPrefix) {
            return injectKeyPrefix(Output.of(injectKeyPrefix));
        }

        /**
         * @param isAutoTypecastEnabled (Updatable) If true, automatically casts the field types.
         * 
         * @return builder
         * 
         */
        public Builder isAutoTypecastEnabled(@Nullable Output<Boolean> isAutoTypecastEnabled) {
            $.isAutoTypecastEnabled = isAutoTypecastEnabled;
            return this;
        }

        /**
         * @param isAutoTypecastEnabled (Updatable) If true, automatically casts the field types.
         * 
         * @return builder
         * 
         */
        public Builder isAutoTypecastEnabled(Boolean isAutoTypecastEnabled) {
            return isAutoTypecastEnabled(Output.of(isAutoTypecastEnabled));
        }

        /**
         * @param isRenewRecordEnabled (Updatable) If true, it modifies a new empty hash
         * 
         * @return builder
         * 
         */
        public Builder isRenewRecordEnabled(@Nullable Output<Boolean> isRenewRecordEnabled) {
            $.isRenewRecordEnabled = isRenewRecordEnabled;
            return this;
        }

        /**
         * @param isRenewRecordEnabled (Updatable) If true, it modifies a new empty hash
         * 
         * @return builder
         * 
         */
        public Builder isRenewRecordEnabled(Boolean isRenewRecordEnabled) {
            return isRenewRecordEnabled(Output.of(isRenewRecordEnabled));
        }

        /**
         * @param isRubyEnabled (Updatable) When set to true, the full Ruby syntax is enabled in the ${} expression.
         * 
         * @return builder
         * 
         */
        public Builder isRubyEnabled(@Nullable Output<Boolean> isRubyEnabled) {
            $.isRubyEnabled = isRubyEnabled;
            return this;
        }

        /**
         * @param isRubyEnabled (Updatable) When set to true, the full Ruby syntax is enabled in the ${} expression.
         * 
         * @return builder
         * 
         */
        public Builder isRubyEnabled(Boolean isRubyEnabled) {
            return isRubyEnabled(Output.of(isRubyEnabled));
        }

        /**
         * @param keepKeys (Updatable) A list of keys to keep. Only relevant if isRenewRecordEnabled is set to true
         * 
         * @return builder
         * 
         */
        public Builder keepKeys(@Nullable Output<List<String>> keepKeys) {
            $.keepKeys = keepKeys;
            return this;
        }

        /**
         * @param keepKeys (Updatable) A list of keys to keep. Only relevant if isRenewRecordEnabled is set to true
         * 
         * @return builder
         * 
         */
        public Builder keepKeys(List<String> keepKeys) {
            return keepKeys(Output.of(keepKeys));
        }

        /**
         * @param keepKeys (Updatable) A list of keys to keep. Only relevant if isRenewRecordEnabled is set to true
         * 
         * @return builder
         * 
         */
        public Builder keepKeys(String... keepKeys) {
            return keepKeys(List.of(keepKeys));
        }

        /**
         * @param keyName (Updatable) The field name in the record to parse.
         * 
         * @return builder
         * 
         */
        public Builder keyName(@Nullable Output<String> keyName) {
            $.keyName = keyName;
            return this;
        }

        /**
         * @param keyName (Updatable) The field name in the record to parse.
         * 
         * @return builder
         * 
         */
        public Builder keyName(String keyName) {
            return keyName(Output.of(keyName));
        }

        /**
         * @param name (Updatable) Unique name for the filter.
         * 
         * @return builder
         * 
         */
        public Builder name(Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name (Updatable) Unique name for the filter.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param params (Updatable) Parameters of the custom filter
         * 
         * @return builder
         * 
         */
        public Builder params(@Nullable Output<Map<String,String>> params) {
            $.params = params;
            return this;
        }

        /**
         * @param params (Updatable) Parameters of the custom filter
         * 
         * @return builder
         * 
         */
        public Builder params(Map<String,String> params) {
            return params(Output.of(params));
        }

        /**
         * @param parser (Updatable) Source parser object.
         * 
         * @return builder
         * 
         */
        public Builder parser(@Nullable Output<UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserArgs> parser) {
            $.parser = parser;
            return this;
        }

        /**
         * @param parser (Updatable) Source parser object.
         * 
         * @return builder
         * 
         */
        public Builder parser(UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserArgs parser) {
            return parser(Output.of(parser));
        }

        /**
         * @param recordLists (Updatable) Add new key-value pairs in logs
         * 
         * @return builder
         * 
         */
        public Builder recordLists(@Nullable Output<List<UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterRecordListArgs>> recordLists) {
            $.recordLists = recordLists;
            return this;
        }

        /**
         * @param recordLists (Updatable) Add new key-value pairs in logs
         * 
         * @return builder
         * 
         */
        public Builder recordLists(List<UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterRecordListArgs> recordLists) {
            return recordLists(Output.of(recordLists));
        }

        /**
         * @param recordLists (Updatable) Add new key-value pairs in logs
         * 
         * @return builder
         * 
         */
        public Builder recordLists(UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterRecordListArgs... recordLists) {
            return recordLists(List.of(recordLists));
        }

        /**
         * @param removeKeyNameField (Updatable) If true, remove the keyName field when parsing is succeeded.
         * 
         * @return builder
         * 
         */
        public Builder removeKeyNameField(@Nullable Output<Boolean> removeKeyNameField) {
            $.removeKeyNameField = removeKeyNameField;
            return this;
        }

        /**
         * @param removeKeyNameField (Updatable) If true, remove the keyName field when parsing is succeeded.
         * 
         * @return builder
         * 
         */
        public Builder removeKeyNameField(Boolean removeKeyNameField) {
            return removeKeyNameField(Output.of(removeKeyNameField));
        }

        /**
         * @param removeKeys (Updatable) A list of keys to delete
         * 
         * @return builder
         * 
         */
        public Builder removeKeys(@Nullable Output<List<String>> removeKeys) {
            $.removeKeys = removeKeys;
            return this;
        }

        /**
         * @param removeKeys (Updatable) A list of keys to delete
         * 
         * @return builder
         * 
         */
        public Builder removeKeys(List<String> removeKeys) {
            return removeKeys(Output.of(removeKeys));
        }

        /**
         * @param removeKeys (Updatable) A list of keys to delete
         * 
         * @return builder
         * 
         */
        public Builder removeKeys(String... removeKeys) {
            return removeKeys(List.of(removeKeys));
        }

        /**
         * @param renewTimeKey (Updatable) Overwrites the time of logs with this value, this value must be a Unix timestamp.
         * 
         * @return builder
         * 
         */
        public Builder renewTimeKey(@Nullable Output<String> renewTimeKey) {
            $.renewTimeKey = renewTimeKey;
            return this;
        }

        /**
         * @param renewTimeKey (Updatable) Overwrites the time of logs with this value, this value must be a Unix timestamp.
         * 
         * @return builder
         * 
         */
        public Builder renewTimeKey(String renewTimeKey) {
            return renewTimeKey(Output.of(renewTimeKey));
        }

        /**
         * @param replaceInvalidSequence (Updatable) If true, the invalid string is replaced with safe characters and is re-parsed.
         * 
         * @return builder
         * 
         */
        public Builder replaceInvalidSequence(@Nullable Output<Boolean> replaceInvalidSequence) {
            $.replaceInvalidSequence = replaceInvalidSequence;
            return this;
        }

        /**
         * @param replaceInvalidSequence (Updatable) If true, the invalid string is replaced with safe characters and is re-parsed.
         * 
         * @return builder
         * 
         */
        public Builder replaceInvalidSequence(Boolean replaceInvalidSequence) {
            return replaceInvalidSequence(Output.of(replaceInvalidSequence));
        }

        /**
         * @param reserveData (Updatable) If true, keep the original key-value pair in the parsed result.
         * 
         * @return builder
         * 
         */
        public Builder reserveData(@Nullable Output<Boolean> reserveData) {
            $.reserveData = reserveData;
            return this;
        }

        /**
         * @param reserveData (Updatable) If true, keep the original key-value pair in the parsed result.
         * 
         * @return builder
         * 
         */
        public Builder reserveData(Boolean reserveData) {
            return reserveData(Output.of(reserveData));
        }

        /**
         * @param reserveTime (Updatable) If true, keep the original event time in the parsed result.
         * 
         * ** IMPORTANT **
         * Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
         * 
         * @return builder
         * 
         */
        public Builder reserveTime(@Nullable Output<Boolean> reserveTime) {
            $.reserveTime = reserveTime;
            return this;
        }

        /**
         * @param reserveTime (Updatable) If true, keep the original event time in the parsed result.
         * 
         * ** IMPORTANT **
         * Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
         * 
         * @return builder
         * 
         */
        public Builder reserveTime(Boolean reserveTime) {
            return reserveTime(Output.of(reserveTime));
        }

        public UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterArgs build() {
            if ($.filterType == null) {
                throw new MissingRequiredPropertyException("UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterArgs", "filterType");
            }
            if ($.name == null) {
                throw new MissingRequiredPropertyException("UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterArgs", "name");
            }
            return $;
        }
    }

}
