// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.oci.Logging.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.oci.Logging.outputs.GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserNestedParser;
import com.pulumi.oci.Logging.outputs.GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserPattern;
import com.pulumi.oci.Logging.outputs.GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserRecordInput;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.Object;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;

@CustomType
public final class GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser {
    /**
     * @return CSV delimiter.
     * 
     */
    private String delimiter;
    /**
     * @return Regex pattern.
     * 
     */
    private String expression;
    /**
     * @return Specify the time field for the event time. If the event doesn&#39;t have this field, the current time is used.
     * 
     */
    private String fieldTimeKey;
    /**
     * @return First line pattern format.
     * 
     */
    private String formatFirstline;
    /**
     * @return Mutiline pattern format.
     * 
     */
    private List<String> formats;
    /**
     * @return Grok failure key.
     * 
     */
    private String grokFailureKey;
    /**
     * @return Grok name key.
     * 
     */
    private String grokNameKey;
    /**
     * @return If true, use Fluent::EventTime.now(current time) as a timestamp when the time_key is specified.
     * 
     */
    private Boolean isEstimateCurrentEvent;
    /**
     * @return If true, keep the time field in the record.
     * 
     */
    private Boolean isKeepTimeKey;
    /**
     * @return If you don&#39;t need stream or logtag fields, set this to false.
     * 
     */
    private Boolean isMergeCriFields;
    /**
     * @return If true, an empty string field is replaced with a null value.
     * 
     */
    private Boolean isNullEmptyString;
    /**
     * @return Specifies whether or not to support colonless ident. Corresponds to the Fluentd support_colonless_ident parameter.
     * 
     */
    private Boolean isSupportColonlessIdent;
    /**
     * @return Specifies with priority or not. Corresponds to the Fluentd with_priority parameter.
     * 
     */
    private Boolean isWithPriority;
    /**
     * @return CSV keys.
     * 
     */
    private List<String> keys;
    /**
     * @return Syslog message format.
     * 
     */
    private String messageFormat;
    /**
     * @return Specifies the field name to contain logs.
     * 
     */
    private String messageKey;
    /**
     * @return Multiline start regexp pattern.
     * 
     */
    private String multiLineStartRegexp;
    /**
     * @return Optional nested JSON Parser for CRI. Supported fields are fieldTimeKey, timeFormat, and isKeepTimeKey.
     * 
     */
    private List<GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserNestedParser> nestedParsers;
    /**
     * @return Specify the null value pattern.
     * 
     */
    private String nullValuePattern;
    /**
     * @return If true, a separator parameter can be further defined.
     * 
     */
    private Boolean parseNested;
    /**
     * @return Type of fluent parser.
     * 
     */
    private String parserType;
    /**
     * @return Grok pattern object.
     * 
     */
    private List<GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserPattern> patterns;
    /**
     * @return record section of openmetrics parser.
     * 
     */
    private List<GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserRecordInput> recordInputs;
    /**
     * @return RFC 5424 time format.
     * 
     */
    private String rfc5424timeFormat;
    /**
     * @return Keys of adjacent levels are joined by the separator.
     * 
     */
    private String separator;
    /**
     * @return Syslog parser type.
     * 
     */
    private String syslogParserType;
    /**
     * @return Process time value using the specified format.
     * 
     */
    private String timeFormat;
    /**
     * @return JSON parser time type.
     * 
     */
    private String timeType;
    /**
     * @return Specify the timeout for parse processing. This is mainly for detecting an incorrect regexp pattern.
     * 
     */
    private Integer timeoutInMilliseconds;
    /**
     * @return Specify types for converting a field into another type. For example, With this configuration: &lt;parse&gt; @type csv keys time,host,req_id,user time_key time &lt;/parse&gt;
     * 
     */
    private Map<String,Object> types;

    private GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser() {}
    /**
     * @return CSV delimiter.
     * 
     */
    public String delimiter() {
        return this.delimiter;
    }
    /**
     * @return Regex pattern.
     * 
     */
    public String expression() {
        return this.expression;
    }
    /**
     * @return Specify the time field for the event time. If the event doesn&#39;t have this field, the current time is used.
     * 
     */
    public String fieldTimeKey() {
        return this.fieldTimeKey;
    }
    /**
     * @return First line pattern format.
     * 
     */
    public String formatFirstline() {
        return this.formatFirstline;
    }
    /**
     * @return Mutiline pattern format.
     * 
     */
    public List<String> formats() {
        return this.formats;
    }
    /**
     * @return Grok failure key.
     * 
     */
    public String grokFailureKey() {
        return this.grokFailureKey;
    }
    /**
     * @return Grok name key.
     * 
     */
    public String grokNameKey() {
        return this.grokNameKey;
    }
    /**
     * @return If true, use Fluent::EventTime.now(current time) as a timestamp when the time_key is specified.
     * 
     */
    public Boolean isEstimateCurrentEvent() {
        return this.isEstimateCurrentEvent;
    }
    /**
     * @return If true, keep the time field in the record.
     * 
     */
    public Boolean isKeepTimeKey() {
        return this.isKeepTimeKey;
    }
    /**
     * @return If you don&#39;t need stream or logtag fields, set this to false.
     * 
     */
    public Boolean isMergeCriFields() {
        return this.isMergeCriFields;
    }
    /**
     * @return If true, an empty string field is replaced with a null value.
     * 
     */
    public Boolean isNullEmptyString() {
        return this.isNullEmptyString;
    }
    /**
     * @return Specifies whether or not to support colonless ident. Corresponds to the Fluentd support_colonless_ident parameter.
     * 
     */
    public Boolean isSupportColonlessIdent() {
        return this.isSupportColonlessIdent;
    }
    /**
     * @return Specifies with priority or not. Corresponds to the Fluentd with_priority parameter.
     * 
     */
    public Boolean isWithPriority() {
        return this.isWithPriority;
    }
    /**
     * @return CSV keys.
     * 
     */
    public List<String> keys() {
        return this.keys;
    }
    /**
     * @return Syslog message format.
     * 
     */
    public String messageFormat() {
        return this.messageFormat;
    }
    /**
     * @return Specifies the field name to contain logs.
     * 
     */
    public String messageKey() {
        return this.messageKey;
    }
    /**
     * @return Multiline start regexp pattern.
     * 
     */
    public String multiLineStartRegexp() {
        return this.multiLineStartRegexp;
    }
    /**
     * @return Optional nested JSON Parser for CRI. Supported fields are fieldTimeKey, timeFormat, and isKeepTimeKey.
     * 
     */
    public List<GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserNestedParser> nestedParsers() {
        return this.nestedParsers;
    }
    /**
     * @return Specify the null value pattern.
     * 
     */
    public String nullValuePattern() {
        return this.nullValuePattern;
    }
    /**
     * @return If true, a separator parameter can be further defined.
     * 
     */
    public Boolean parseNested() {
        return this.parseNested;
    }
    /**
     * @return Type of fluent parser.
     * 
     */
    public String parserType() {
        return this.parserType;
    }
    /**
     * @return Grok pattern object.
     * 
     */
    public List<GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserPattern> patterns() {
        return this.patterns;
    }
    /**
     * @return record section of openmetrics parser.
     * 
     */
    public List<GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserRecordInput> recordInputs() {
        return this.recordInputs;
    }
    /**
     * @return RFC 5424 time format.
     * 
     */
    public String rfc5424timeFormat() {
        return this.rfc5424timeFormat;
    }
    /**
     * @return Keys of adjacent levels are joined by the separator.
     * 
     */
    public String separator() {
        return this.separator;
    }
    /**
     * @return Syslog parser type.
     * 
     */
    public String syslogParserType() {
        return this.syslogParserType;
    }
    /**
     * @return Process time value using the specified format.
     * 
     */
    public String timeFormat() {
        return this.timeFormat;
    }
    /**
     * @return JSON parser time type.
     * 
     */
    public String timeType() {
        return this.timeType;
    }
    /**
     * @return Specify the timeout for parse processing. This is mainly for detecting an incorrect regexp pattern.
     * 
     */
    public Integer timeoutInMilliseconds() {
        return this.timeoutInMilliseconds;
    }
    /**
     * @return Specify types for converting a field into another type. For example, With this configuration: &lt;parse&gt; @type csv keys time,host,req_id,user time_key time &lt;/parse&gt;
     * 
     */
    public Map<String,Object> types() {
        return this.types;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String delimiter;
        private String expression;
        private String fieldTimeKey;
        private String formatFirstline;
        private List<String> formats;
        private String grokFailureKey;
        private String grokNameKey;
        private Boolean isEstimateCurrentEvent;
        private Boolean isKeepTimeKey;
        private Boolean isMergeCriFields;
        private Boolean isNullEmptyString;
        private Boolean isSupportColonlessIdent;
        private Boolean isWithPriority;
        private List<String> keys;
        private String messageFormat;
        private String messageKey;
        private String multiLineStartRegexp;
        private List<GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserNestedParser> nestedParsers;
        private String nullValuePattern;
        private Boolean parseNested;
        private String parserType;
        private List<GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserPattern> patterns;
        private List<GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserRecordInput> recordInputs;
        private String rfc5424timeFormat;
        private String separator;
        private String syslogParserType;
        private String timeFormat;
        private String timeType;
        private Integer timeoutInMilliseconds;
        private Map<String,Object> types;
        public Builder() {}
        public Builder(GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.delimiter = defaults.delimiter;
    	      this.expression = defaults.expression;
    	      this.fieldTimeKey = defaults.fieldTimeKey;
    	      this.formatFirstline = defaults.formatFirstline;
    	      this.formats = defaults.formats;
    	      this.grokFailureKey = defaults.grokFailureKey;
    	      this.grokNameKey = defaults.grokNameKey;
    	      this.isEstimateCurrentEvent = defaults.isEstimateCurrentEvent;
    	      this.isKeepTimeKey = defaults.isKeepTimeKey;
    	      this.isMergeCriFields = defaults.isMergeCriFields;
    	      this.isNullEmptyString = defaults.isNullEmptyString;
    	      this.isSupportColonlessIdent = defaults.isSupportColonlessIdent;
    	      this.isWithPriority = defaults.isWithPriority;
    	      this.keys = defaults.keys;
    	      this.messageFormat = defaults.messageFormat;
    	      this.messageKey = defaults.messageKey;
    	      this.multiLineStartRegexp = defaults.multiLineStartRegexp;
    	      this.nestedParsers = defaults.nestedParsers;
    	      this.nullValuePattern = defaults.nullValuePattern;
    	      this.parseNested = defaults.parseNested;
    	      this.parserType = defaults.parserType;
    	      this.patterns = defaults.patterns;
    	      this.recordInputs = defaults.recordInputs;
    	      this.rfc5424timeFormat = defaults.rfc5424timeFormat;
    	      this.separator = defaults.separator;
    	      this.syslogParserType = defaults.syslogParserType;
    	      this.timeFormat = defaults.timeFormat;
    	      this.timeType = defaults.timeType;
    	      this.timeoutInMilliseconds = defaults.timeoutInMilliseconds;
    	      this.types = defaults.types;
        }

        @CustomType.Setter
        public Builder delimiter(String delimiter) {
            if (delimiter == null) {
              throw new MissingRequiredPropertyException("GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser", "delimiter");
            }
            this.delimiter = delimiter;
            return this;
        }
        @CustomType.Setter
        public Builder expression(String expression) {
            if (expression == null) {
              throw new MissingRequiredPropertyException("GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser", "expression");
            }
            this.expression = expression;
            return this;
        }
        @CustomType.Setter
        public Builder fieldTimeKey(String fieldTimeKey) {
            if (fieldTimeKey == null) {
              throw new MissingRequiredPropertyException("GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser", "fieldTimeKey");
            }
            this.fieldTimeKey = fieldTimeKey;
            return this;
        }
        @CustomType.Setter
        public Builder formatFirstline(String formatFirstline) {
            if (formatFirstline == null) {
              throw new MissingRequiredPropertyException("GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser", "formatFirstline");
            }
            this.formatFirstline = formatFirstline;
            return this;
        }
        @CustomType.Setter
        public Builder formats(List<String> formats) {
            if (formats == null) {
              throw new MissingRequiredPropertyException("GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser", "formats");
            }
            this.formats = formats;
            return this;
        }
        public Builder formats(String... formats) {
            return formats(List.of(formats));
        }
        @CustomType.Setter
        public Builder grokFailureKey(String grokFailureKey) {
            if (grokFailureKey == null) {
              throw new MissingRequiredPropertyException("GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser", "grokFailureKey");
            }
            this.grokFailureKey = grokFailureKey;
            return this;
        }
        @CustomType.Setter
        public Builder grokNameKey(String grokNameKey) {
            if (grokNameKey == null) {
              throw new MissingRequiredPropertyException("GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser", "grokNameKey");
            }
            this.grokNameKey = grokNameKey;
            return this;
        }
        @CustomType.Setter
        public Builder isEstimateCurrentEvent(Boolean isEstimateCurrentEvent) {
            if (isEstimateCurrentEvent == null) {
              throw new MissingRequiredPropertyException("GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser", "isEstimateCurrentEvent");
            }
            this.isEstimateCurrentEvent = isEstimateCurrentEvent;
            return this;
        }
        @CustomType.Setter
        public Builder isKeepTimeKey(Boolean isKeepTimeKey) {
            if (isKeepTimeKey == null) {
              throw new MissingRequiredPropertyException("GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser", "isKeepTimeKey");
            }
            this.isKeepTimeKey = isKeepTimeKey;
            return this;
        }
        @CustomType.Setter
        public Builder isMergeCriFields(Boolean isMergeCriFields) {
            if (isMergeCriFields == null) {
              throw new MissingRequiredPropertyException("GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser", "isMergeCriFields");
            }
            this.isMergeCriFields = isMergeCriFields;
            return this;
        }
        @CustomType.Setter
        public Builder isNullEmptyString(Boolean isNullEmptyString) {
            if (isNullEmptyString == null) {
              throw new MissingRequiredPropertyException("GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser", "isNullEmptyString");
            }
            this.isNullEmptyString = isNullEmptyString;
            return this;
        }
        @CustomType.Setter
        public Builder isSupportColonlessIdent(Boolean isSupportColonlessIdent) {
            if (isSupportColonlessIdent == null) {
              throw new MissingRequiredPropertyException("GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser", "isSupportColonlessIdent");
            }
            this.isSupportColonlessIdent = isSupportColonlessIdent;
            return this;
        }
        @CustomType.Setter
        public Builder isWithPriority(Boolean isWithPriority) {
            if (isWithPriority == null) {
              throw new MissingRequiredPropertyException("GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser", "isWithPriority");
            }
            this.isWithPriority = isWithPriority;
            return this;
        }
        @CustomType.Setter
        public Builder keys(List<String> keys) {
            if (keys == null) {
              throw new MissingRequiredPropertyException("GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser", "keys");
            }
            this.keys = keys;
            return this;
        }
        public Builder keys(String... keys) {
            return keys(List.of(keys));
        }
        @CustomType.Setter
        public Builder messageFormat(String messageFormat) {
            if (messageFormat == null) {
              throw new MissingRequiredPropertyException("GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser", "messageFormat");
            }
            this.messageFormat = messageFormat;
            return this;
        }
        @CustomType.Setter
        public Builder messageKey(String messageKey) {
            if (messageKey == null) {
              throw new MissingRequiredPropertyException("GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser", "messageKey");
            }
            this.messageKey = messageKey;
            return this;
        }
        @CustomType.Setter
        public Builder multiLineStartRegexp(String multiLineStartRegexp) {
            if (multiLineStartRegexp == null) {
              throw new MissingRequiredPropertyException("GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser", "multiLineStartRegexp");
            }
            this.multiLineStartRegexp = multiLineStartRegexp;
            return this;
        }
        @CustomType.Setter
        public Builder nestedParsers(List<GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserNestedParser> nestedParsers) {
            if (nestedParsers == null) {
              throw new MissingRequiredPropertyException("GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser", "nestedParsers");
            }
            this.nestedParsers = nestedParsers;
            return this;
        }
        public Builder nestedParsers(GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserNestedParser... nestedParsers) {
            return nestedParsers(List.of(nestedParsers));
        }
        @CustomType.Setter
        public Builder nullValuePattern(String nullValuePattern) {
            if (nullValuePattern == null) {
              throw new MissingRequiredPropertyException("GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser", "nullValuePattern");
            }
            this.nullValuePattern = nullValuePattern;
            return this;
        }
        @CustomType.Setter
        public Builder parseNested(Boolean parseNested) {
            if (parseNested == null) {
              throw new MissingRequiredPropertyException("GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser", "parseNested");
            }
            this.parseNested = parseNested;
            return this;
        }
        @CustomType.Setter
        public Builder parserType(String parserType) {
            if (parserType == null) {
              throw new MissingRequiredPropertyException("GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser", "parserType");
            }
            this.parserType = parserType;
            return this;
        }
        @CustomType.Setter
        public Builder patterns(List<GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserPattern> patterns) {
            if (patterns == null) {
              throw new MissingRequiredPropertyException("GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser", "patterns");
            }
            this.patterns = patterns;
            return this;
        }
        public Builder patterns(GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserPattern... patterns) {
            return patterns(List.of(patterns));
        }
        @CustomType.Setter
        public Builder recordInputs(List<GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserRecordInput> recordInputs) {
            if (recordInputs == null) {
              throw new MissingRequiredPropertyException("GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser", "recordInputs");
            }
            this.recordInputs = recordInputs;
            return this;
        }
        public Builder recordInputs(GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserRecordInput... recordInputs) {
            return recordInputs(List.of(recordInputs));
        }
        @CustomType.Setter
        public Builder rfc5424timeFormat(String rfc5424timeFormat) {
            if (rfc5424timeFormat == null) {
              throw new MissingRequiredPropertyException("GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser", "rfc5424timeFormat");
            }
            this.rfc5424timeFormat = rfc5424timeFormat;
            return this;
        }
        @CustomType.Setter
        public Builder separator(String separator) {
            if (separator == null) {
              throw new MissingRequiredPropertyException("GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser", "separator");
            }
            this.separator = separator;
            return this;
        }
        @CustomType.Setter
        public Builder syslogParserType(String syslogParserType) {
            if (syslogParserType == null) {
              throw new MissingRequiredPropertyException("GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser", "syslogParserType");
            }
            this.syslogParserType = syslogParserType;
            return this;
        }
        @CustomType.Setter
        public Builder timeFormat(String timeFormat) {
            if (timeFormat == null) {
              throw new MissingRequiredPropertyException("GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser", "timeFormat");
            }
            this.timeFormat = timeFormat;
            return this;
        }
        @CustomType.Setter
        public Builder timeType(String timeType) {
            if (timeType == null) {
              throw new MissingRequiredPropertyException("GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser", "timeType");
            }
            this.timeType = timeType;
            return this;
        }
        @CustomType.Setter
        public Builder timeoutInMilliseconds(Integer timeoutInMilliseconds) {
            if (timeoutInMilliseconds == null) {
              throw new MissingRequiredPropertyException("GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser", "timeoutInMilliseconds");
            }
            this.timeoutInMilliseconds = timeoutInMilliseconds;
            return this;
        }
        @CustomType.Setter
        public Builder types(Map<String,Object> types) {
            if (types == null) {
              throw new MissingRequiredPropertyException("GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser", "types");
            }
            this.types = types;
            return this;
        }
        public GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser build() {
            final var _resultValue = new GetUnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser();
            _resultValue.delimiter = delimiter;
            _resultValue.expression = expression;
            _resultValue.fieldTimeKey = fieldTimeKey;
            _resultValue.formatFirstline = formatFirstline;
            _resultValue.formats = formats;
            _resultValue.grokFailureKey = grokFailureKey;
            _resultValue.grokNameKey = grokNameKey;
            _resultValue.isEstimateCurrentEvent = isEstimateCurrentEvent;
            _resultValue.isKeepTimeKey = isKeepTimeKey;
            _resultValue.isMergeCriFields = isMergeCriFields;
            _resultValue.isNullEmptyString = isNullEmptyString;
            _resultValue.isSupportColonlessIdent = isSupportColonlessIdent;
            _resultValue.isWithPriority = isWithPriority;
            _resultValue.keys = keys;
            _resultValue.messageFormat = messageFormat;
            _resultValue.messageKey = messageKey;
            _resultValue.multiLineStartRegexp = multiLineStartRegexp;
            _resultValue.nestedParsers = nestedParsers;
            _resultValue.nullValuePattern = nullValuePattern;
            _resultValue.parseNested = parseNested;
            _resultValue.parserType = parserType;
            _resultValue.patterns = patterns;
            _resultValue.recordInputs = recordInputs;
            _resultValue.rfc5424timeFormat = rfc5424timeFormat;
            _resultValue.separator = separator;
            _resultValue.syslogParserType = syslogParserType;
            _resultValue.timeFormat = timeFormat;
            _resultValue.timeType = timeType;
            _resultValue.timeoutInMilliseconds = timeoutInMilliseconds;
            _resultValue.types = types;
            return _resultValue;
        }
    }
}
