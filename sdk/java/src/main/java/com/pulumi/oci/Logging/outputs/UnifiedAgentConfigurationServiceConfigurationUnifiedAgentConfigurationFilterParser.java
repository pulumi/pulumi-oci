// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.oci.Logging.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.oci.Logging.outputs.UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserNestedParser;
import com.pulumi.oci.Logging.outputs.UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserPattern;
import com.pulumi.oci.Logging.outputs.UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserRecordInput;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.Object;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser {
    /**
     * @return (Updatable) CSV delimiter.
     * 
     */
    private @Nullable String delimiter;
    /**
     * @return (Updatable) Regex pattern.
     * 
     */
    private @Nullable String expression;
    /**
     * @return (Updatable) Specifies the time field for the event time. If the event doesn&#39;t have this field, the current time is used.
     * 
     */
    private @Nullable String fieldTimeKey;
    /**
     * @return (Updatable) First line pattern format.
     * 
     */
    private @Nullable String formatFirstline;
    /**
     * @return (Updatable) Mutiline pattern format.
     * 
     */
    private @Nullable List<String> formats;
    /**
     * @return (Updatable) Grok failure key.
     * 
     */
    private @Nullable String grokFailureKey;
    /**
     * @return (Updatable) Grok name key.
     * 
     */
    private @Nullable String grokNameKey;
    /**
     * @return (Updatable) If true, use Fluent::EventTime.now(current time) as a timestamp when the time_key is specified.
     * 
     */
    private @Nullable Boolean isEstimateCurrentEvent;
    /**
     * @return (Updatable) If true, keep the time field in the record.
     * 
     */
    private @Nullable Boolean isKeepTimeKey;
    /**
     * @return (Updatable) If you don&#39;t need stream or logtag fields, set this to false.
     * 
     */
    private @Nullable Boolean isMergeCriFields;
    /**
     * @return (Updatable) If true, an empty string field is replaced with a null value.
     * 
     */
    private @Nullable Boolean isNullEmptyString;
    /**
     * @return (Updatable) Specifies whether or not to support colonless ident. Corresponds to the Fluentd support_colonless_ident parameter.
     * 
     */
    private @Nullable Boolean isSupportColonlessIdent;
    /**
     * @return (Updatable) Specifies with priority or not. Corresponds to the Fluentd with_priority parameter.
     * 
     */
    private @Nullable Boolean isWithPriority;
    /**
     * @return (Updatable) CSV keys.
     * 
     */
    private @Nullable List<String> keys;
    /**
     * @return (Updatable) Syslog message format.
     * 
     */
    private @Nullable String messageFormat;
    /**
     * @return (Updatable) Specifies the field name to contain logs.
     * 
     */
    private @Nullable String messageKey;
    /**
     * @return (Updatable) Multiline start regexp pattern.
     * 
     */
    private @Nullable String multiLineStartRegexp;
    /**
     * @return (Updatable) Optional nested JSON Parser for CRI. Supported fields are fieldTimeKey, timeFormat, and isKeepTimeKey.
     * 
     */
    private @Nullable UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserNestedParser nestedParser;
    /**
     * @return (Updatable) Specify the null value pattern.
     * 
     */
    private @Nullable String nullValuePattern;
    /**
     * @return (Updatable) If true, a separator parameter can be further defined.
     * 
     */
    private @Nullable Boolean parseNested;
    /**
     * @return (Updatable) Type of fluent parser.
     * 
     */
    private String parserType;
    /**
     * @return (Updatable) Grok pattern object.
     * 
     */
    private @Nullable List<UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserPattern> patterns;
    /**
     * @return (Updatable) record section of openmetrics parser.
     * 
     */
    private @Nullable UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserRecordInput recordInput;
    /**
     * @return (Updatable) RFC 5424 time format.
     * 
     */
    private @Nullable String rfc5424timeFormat;
    /**
     * @return (Updatable) Keys of adjacent levels are joined by the separator.
     * 
     */
    private @Nullable String separator;
    /**
     * @return (Updatable) Syslog parser type.
     * 
     */
    private @Nullable String syslogParserType;
    /**
     * @return (Updatable) Process time value using the specified format.
     * 
     */
    private @Nullable String timeFormat;
    /**
     * @return (Updatable) JSON parser time type.
     * 
     */
    private @Nullable String timeType;
    /**
     * @return (Updatable) Specify the timeout for parse processing. This is mainly for detecting an incorrect regexp pattern.
     * 
     */
    private @Nullable Integer timeoutInMilliseconds;
    /**
     * @return (Updatable) Specify types for converting a field into another type. For example, With this configuration: &lt;parse&gt;{@literal @}type csv keys time,host,req_id,user time_key time &lt;/parse&gt;
     * 
     * This incoming event: &#34;2013/02/28 12:00:00,192.168.0.1,111,-&#34;
     * 
     * is parsed as: 1362020400 (2013/02/28/ 12:00:00)
     * 
     * record: { &#34;host&#34;   : &#34;192.168.0.1&#34;, &#34;req_id&#34; : &#34;111&#34;, &#34;user&#34;   : &#34;-&#34; }
     * 
     */
    private @Nullable Map<String,Object> types;

    private UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser() {}
    /**
     * @return (Updatable) CSV delimiter.
     * 
     */
    public Optional<String> delimiter() {
        return Optional.ofNullable(this.delimiter);
    }
    /**
     * @return (Updatable) Regex pattern.
     * 
     */
    public Optional<String> expression() {
        return Optional.ofNullable(this.expression);
    }
    /**
     * @return (Updatable) Specifies the time field for the event time. If the event doesn&#39;t have this field, the current time is used.
     * 
     */
    public Optional<String> fieldTimeKey() {
        return Optional.ofNullable(this.fieldTimeKey);
    }
    /**
     * @return (Updatable) First line pattern format.
     * 
     */
    public Optional<String> formatFirstline() {
        return Optional.ofNullable(this.formatFirstline);
    }
    /**
     * @return (Updatable) Mutiline pattern format.
     * 
     */
    public List<String> formats() {
        return this.formats == null ? List.of() : this.formats;
    }
    /**
     * @return (Updatable) Grok failure key.
     * 
     */
    public Optional<String> grokFailureKey() {
        return Optional.ofNullable(this.grokFailureKey);
    }
    /**
     * @return (Updatable) Grok name key.
     * 
     */
    public Optional<String> grokNameKey() {
        return Optional.ofNullable(this.grokNameKey);
    }
    /**
     * @return (Updatable) If true, use Fluent::EventTime.now(current time) as a timestamp when the time_key is specified.
     * 
     */
    public Optional<Boolean> isEstimateCurrentEvent() {
        return Optional.ofNullable(this.isEstimateCurrentEvent);
    }
    /**
     * @return (Updatable) If true, keep the time field in the record.
     * 
     */
    public Optional<Boolean> isKeepTimeKey() {
        return Optional.ofNullable(this.isKeepTimeKey);
    }
    /**
     * @return (Updatable) If you don&#39;t need stream or logtag fields, set this to false.
     * 
     */
    public Optional<Boolean> isMergeCriFields() {
        return Optional.ofNullable(this.isMergeCriFields);
    }
    /**
     * @return (Updatable) If true, an empty string field is replaced with a null value.
     * 
     */
    public Optional<Boolean> isNullEmptyString() {
        return Optional.ofNullable(this.isNullEmptyString);
    }
    /**
     * @return (Updatable) Specifies whether or not to support colonless ident. Corresponds to the Fluentd support_colonless_ident parameter.
     * 
     */
    public Optional<Boolean> isSupportColonlessIdent() {
        return Optional.ofNullable(this.isSupportColonlessIdent);
    }
    /**
     * @return (Updatable) Specifies with priority or not. Corresponds to the Fluentd with_priority parameter.
     * 
     */
    public Optional<Boolean> isWithPriority() {
        return Optional.ofNullable(this.isWithPriority);
    }
    /**
     * @return (Updatable) CSV keys.
     * 
     */
    public List<String> keys() {
        return this.keys == null ? List.of() : this.keys;
    }
    /**
     * @return (Updatable) Syslog message format.
     * 
     */
    public Optional<String> messageFormat() {
        return Optional.ofNullable(this.messageFormat);
    }
    /**
     * @return (Updatable) Specifies the field name to contain logs.
     * 
     */
    public Optional<String> messageKey() {
        return Optional.ofNullable(this.messageKey);
    }
    /**
     * @return (Updatable) Multiline start regexp pattern.
     * 
     */
    public Optional<String> multiLineStartRegexp() {
        return Optional.ofNullable(this.multiLineStartRegexp);
    }
    /**
     * @return (Updatable) Optional nested JSON Parser for CRI. Supported fields are fieldTimeKey, timeFormat, and isKeepTimeKey.
     * 
     */
    public Optional<UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserNestedParser> nestedParser() {
        return Optional.ofNullable(this.nestedParser);
    }
    /**
     * @return (Updatable) Specify the null value pattern.
     * 
     */
    public Optional<String> nullValuePattern() {
        return Optional.ofNullable(this.nullValuePattern);
    }
    /**
     * @return (Updatable) If true, a separator parameter can be further defined.
     * 
     */
    public Optional<Boolean> parseNested() {
        return Optional.ofNullable(this.parseNested);
    }
    /**
     * @return (Updatable) Type of fluent parser.
     * 
     */
    public String parserType() {
        return this.parserType;
    }
    /**
     * @return (Updatable) Grok pattern object.
     * 
     */
    public List<UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserPattern> patterns() {
        return this.patterns == null ? List.of() : this.patterns;
    }
    /**
     * @return (Updatable) record section of openmetrics parser.
     * 
     */
    public Optional<UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserRecordInput> recordInput() {
        return Optional.ofNullable(this.recordInput);
    }
    /**
     * @return (Updatable) RFC 5424 time format.
     * 
     */
    public Optional<String> rfc5424timeFormat() {
        return Optional.ofNullable(this.rfc5424timeFormat);
    }
    /**
     * @return (Updatable) Keys of adjacent levels are joined by the separator.
     * 
     */
    public Optional<String> separator() {
        return Optional.ofNullable(this.separator);
    }
    /**
     * @return (Updatable) Syslog parser type.
     * 
     */
    public Optional<String> syslogParserType() {
        return Optional.ofNullable(this.syslogParserType);
    }
    /**
     * @return (Updatable) Process time value using the specified format.
     * 
     */
    public Optional<String> timeFormat() {
        return Optional.ofNullable(this.timeFormat);
    }
    /**
     * @return (Updatable) JSON parser time type.
     * 
     */
    public Optional<String> timeType() {
        return Optional.ofNullable(this.timeType);
    }
    /**
     * @return (Updatable) Specify the timeout for parse processing. This is mainly for detecting an incorrect regexp pattern.
     * 
     */
    public Optional<Integer> timeoutInMilliseconds() {
        return Optional.ofNullable(this.timeoutInMilliseconds);
    }
    /**
     * @return (Updatable) Specify types for converting a field into another type. For example, With this configuration: &lt;parse&gt;{@literal @}type csv keys time,host,req_id,user time_key time &lt;/parse&gt;
     * 
     * This incoming event: &#34;2013/02/28 12:00:00,192.168.0.1,111,-&#34;
     * 
     * is parsed as: 1362020400 (2013/02/28/ 12:00:00)
     * 
     * record: { &#34;host&#34;   : &#34;192.168.0.1&#34;, &#34;req_id&#34; : &#34;111&#34;, &#34;user&#34;   : &#34;-&#34; }
     * 
     */
    public Map<String,Object> types() {
        return this.types == null ? Map.of() : this.types;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable String delimiter;
        private @Nullable String expression;
        private @Nullable String fieldTimeKey;
        private @Nullable String formatFirstline;
        private @Nullable List<String> formats;
        private @Nullable String grokFailureKey;
        private @Nullable String grokNameKey;
        private @Nullable Boolean isEstimateCurrentEvent;
        private @Nullable Boolean isKeepTimeKey;
        private @Nullable Boolean isMergeCriFields;
        private @Nullable Boolean isNullEmptyString;
        private @Nullable Boolean isSupportColonlessIdent;
        private @Nullable Boolean isWithPriority;
        private @Nullable List<String> keys;
        private @Nullable String messageFormat;
        private @Nullable String messageKey;
        private @Nullable String multiLineStartRegexp;
        private @Nullable UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserNestedParser nestedParser;
        private @Nullable String nullValuePattern;
        private @Nullable Boolean parseNested;
        private String parserType;
        private @Nullable List<UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserPattern> patterns;
        private @Nullable UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserRecordInput recordInput;
        private @Nullable String rfc5424timeFormat;
        private @Nullable String separator;
        private @Nullable String syslogParserType;
        private @Nullable String timeFormat;
        private @Nullable String timeType;
        private @Nullable Integer timeoutInMilliseconds;
        private @Nullable Map<String,Object> types;
        public Builder() {}
        public Builder(UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.delimiter = defaults.delimiter;
    	      this.expression = defaults.expression;
    	      this.fieldTimeKey = defaults.fieldTimeKey;
    	      this.formatFirstline = defaults.formatFirstline;
    	      this.formats = defaults.formats;
    	      this.grokFailureKey = defaults.grokFailureKey;
    	      this.grokNameKey = defaults.grokNameKey;
    	      this.isEstimateCurrentEvent = defaults.isEstimateCurrentEvent;
    	      this.isKeepTimeKey = defaults.isKeepTimeKey;
    	      this.isMergeCriFields = defaults.isMergeCriFields;
    	      this.isNullEmptyString = defaults.isNullEmptyString;
    	      this.isSupportColonlessIdent = defaults.isSupportColonlessIdent;
    	      this.isWithPriority = defaults.isWithPriority;
    	      this.keys = defaults.keys;
    	      this.messageFormat = defaults.messageFormat;
    	      this.messageKey = defaults.messageKey;
    	      this.multiLineStartRegexp = defaults.multiLineStartRegexp;
    	      this.nestedParser = defaults.nestedParser;
    	      this.nullValuePattern = defaults.nullValuePattern;
    	      this.parseNested = defaults.parseNested;
    	      this.parserType = defaults.parserType;
    	      this.patterns = defaults.patterns;
    	      this.recordInput = defaults.recordInput;
    	      this.rfc5424timeFormat = defaults.rfc5424timeFormat;
    	      this.separator = defaults.separator;
    	      this.syslogParserType = defaults.syslogParserType;
    	      this.timeFormat = defaults.timeFormat;
    	      this.timeType = defaults.timeType;
    	      this.timeoutInMilliseconds = defaults.timeoutInMilliseconds;
    	      this.types = defaults.types;
        }

        @CustomType.Setter
        public Builder delimiter(@Nullable String delimiter) {

            this.delimiter = delimiter;
            return this;
        }
        @CustomType.Setter
        public Builder expression(@Nullable String expression) {

            this.expression = expression;
            return this;
        }
        @CustomType.Setter
        public Builder fieldTimeKey(@Nullable String fieldTimeKey) {

            this.fieldTimeKey = fieldTimeKey;
            return this;
        }
        @CustomType.Setter
        public Builder formatFirstline(@Nullable String formatFirstline) {

            this.formatFirstline = formatFirstline;
            return this;
        }
        @CustomType.Setter
        public Builder formats(@Nullable List<String> formats) {

            this.formats = formats;
            return this;
        }
        public Builder formats(String... formats) {
            return formats(List.of(formats));
        }
        @CustomType.Setter
        public Builder grokFailureKey(@Nullable String grokFailureKey) {

            this.grokFailureKey = grokFailureKey;
            return this;
        }
        @CustomType.Setter
        public Builder grokNameKey(@Nullable String grokNameKey) {

            this.grokNameKey = grokNameKey;
            return this;
        }
        @CustomType.Setter
        public Builder isEstimateCurrentEvent(@Nullable Boolean isEstimateCurrentEvent) {

            this.isEstimateCurrentEvent = isEstimateCurrentEvent;
            return this;
        }
        @CustomType.Setter
        public Builder isKeepTimeKey(@Nullable Boolean isKeepTimeKey) {

            this.isKeepTimeKey = isKeepTimeKey;
            return this;
        }
        @CustomType.Setter
        public Builder isMergeCriFields(@Nullable Boolean isMergeCriFields) {

            this.isMergeCriFields = isMergeCriFields;
            return this;
        }
        @CustomType.Setter
        public Builder isNullEmptyString(@Nullable Boolean isNullEmptyString) {

            this.isNullEmptyString = isNullEmptyString;
            return this;
        }
        @CustomType.Setter
        public Builder isSupportColonlessIdent(@Nullable Boolean isSupportColonlessIdent) {

            this.isSupportColonlessIdent = isSupportColonlessIdent;
            return this;
        }
        @CustomType.Setter
        public Builder isWithPriority(@Nullable Boolean isWithPriority) {

            this.isWithPriority = isWithPriority;
            return this;
        }
        @CustomType.Setter
        public Builder keys(@Nullable List<String> keys) {

            this.keys = keys;
            return this;
        }
        public Builder keys(String... keys) {
            return keys(List.of(keys));
        }
        @CustomType.Setter
        public Builder messageFormat(@Nullable String messageFormat) {

            this.messageFormat = messageFormat;
            return this;
        }
        @CustomType.Setter
        public Builder messageKey(@Nullable String messageKey) {

            this.messageKey = messageKey;
            return this;
        }
        @CustomType.Setter
        public Builder multiLineStartRegexp(@Nullable String multiLineStartRegexp) {

            this.multiLineStartRegexp = multiLineStartRegexp;
            return this;
        }
        @CustomType.Setter
        public Builder nestedParser(@Nullable UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserNestedParser nestedParser) {

            this.nestedParser = nestedParser;
            return this;
        }
        @CustomType.Setter
        public Builder nullValuePattern(@Nullable String nullValuePattern) {

            this.nullValuePattern = nullValuePattern;
            return this;
        }
        @CustomType.Setter
        public Builder parseNested(@Nullable Boolean parseNested) {

            this.parseNested = parseNested;
            return this;
        }
        @CustomType.Setter
        public Builder parserType(String parserType) {
            if (parserType == null) {
              throw new MissingRequiredPropertyException("UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser", "parserType");
            }
            this.parserType = parserType;
            return this;
        }
        @CustomType.Setter
        public Builder patterns(@Nullable List<UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserPattern> patterns) {

            this.patterns = patterns;
            return this;
        }
        public Builder patterns(UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserPattern... patterns) {
            return patterns(List.of(patterns));
        }
        @CustomType.Setter
        public Builder recordInput(@Nullable UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParserRecordInput recordInput) {

            this.recordInput = recordInput;
            return this;
        }
        @CustomType.Setter
        public Builder rfc5424timeFormat(@Nullable String rfc5424timeFormat) {

            this.rfc5424timeFormat = rfc5424timeFormat;
            return this;
        }
        @CustomType.Setter
        public Builder separator(@Nullable String separator) {

            this.separator = separator;
            return this;
        }
        @CustomType.Setter
        public Builder syslogParserType(@Nullable String syslogParserType) {

            this.syslogParserType = syslogParserType;
            return this;
        }
        @CustomType.Setter
        public Builder timeFormat(@Nullable String timeFormat) {

            this.timeFormat = timeFormat;
            return this;
        }
        @CustomType.Setter
        public Builder timeType(@Nullable String timeType) {

            this.timeType = timeType;
            return this;
        }
        @CustomType.Setter
        public Builder timeoutInMilliseconds(@Nullable Integer timeoutInMilliseconds) {

            this.timeoutInMilliseconds = timeoutInMilliseconds;
            return this;
        }
        @CustomType.Setter
        public Builder types(@Nullable Map<String,Object> types) {

            this.types = types;
            return this;
        }
        public UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser build() {
            final var _resultValue = new UnifiedAgentConfigurationServiceConfigurationUnifiedAgentConfigurationFilterParser();
            _resultValue.delimiter = delimiter;
            _resultValue.expression = expression;
            _resultValue.fieldTimeKey = fieldTimeKey;
            _resultValue.formatFirstline = formatFirstline;
            _resultValue.formats = formats;
            _resultValue.grokFailureKey = grokFailureKey;
            _resultValue.grokNameKey = grokNameKey;
            _resultValue.isEstimateCurrentEvent = isEstimateCurrentEvent;
            _resultValue.isKeepTimeKey = isKeepTimeKey;
            _resultValue.isMergeCriFields = isMergeCriFields;
            _resultValue.isNullEmptyString = isNullEmptyString;
            _resultValue.isSupportColonlessIdent = isSupportColonlessIdent;
            _resultValue.isWithPriority = isWithPriority;
            _resultValue.keys = keys;
            _resultValue.messageFormat = messageFormat;
            _resultValue.messageKey = messageKey;
            _resultValue.multiLineStartRegexp = multiLineStartRegexp;
            _resultValue.nestedParser = nestedParser;
            _resultValue.nullValuePattern = nullValuePattern;
            _resultValue.parseNested = parseNested;
            _resultValue.parserType = parserType;
            _resultValue.patterns = patterns;
            _resultValue.recordInput = recordInput;
            _resultValue.rfc5424timeFormat = rfc5424timeFormat;
            _resultValue.separator = separator;
            _resultValue.syslogParserType = syslogParserType;
            _resultValue.timeFormat = timeFormat;
            _resultValue.timeType = timeType;
            _resultValue.timeoutInMilliseconds = timeoutInMilliseconds;
            _resultValue.types = types;
            return _resultValue;
        }
    }
}
