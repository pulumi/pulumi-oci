// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.oci.Nosql.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.oci.Nosql.inputs.TableReplicaArgs;
import com.pulumi.oci.Nosql.inputs.TableSchemaArgs;
import com.pulumi.oci.Nosql.inputs.TableTableLimitsArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class TableState extends com.pulumi.resources.ResourceArgs {

    public static final TableState Empty = new TableState();

    /**
     * (Updatable) Compartment Identifier.
     * 
     */
    @Import(name="compartmentId")
    private @Nullable Output<String> compartmentId;

    /**
     * @return (Updatable) Compartment Identifier.
     * 
     */
    public Optional<Output<String>> compartmentId() {
        return Optional.ofNullable(this.compartmentId);
    }

    /**
     * (Updatable) CREATE TABLE DDL statement. While updating an existing table, note that the column order should not be changed, and new columns can only be appended at the end of the table.
     * 
     */
    @Import(name="ddlStatement")
    private @Nullable Output<String> ddlStatement;

    /**
     * @return (Updatable) CREATE TABLE DDL statement. While updating an existing table, note that the column order should not be changed, and new columns can only be appended at the end of the table.
     * 
     */
    public Optional<Output<String>> ddlStatement() {
        return Optional.ofNullable(this.ddlStatement);
    }

    /**
     * (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace.  Example: `{&#34;foo-namespace&#34;: {&#34;bar-key&#34;: &#34;value&#34;}}`
     * 
     */
    @Import(name="definedTags")
    private @Nullable Output<Map<String,String>> definedTags;

    /**
     * @return (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace.  Example: `{&#34;foo-namespace&#34;: {&#34;bar-key&#34;: &#34;value&#34;}}`
     * 
     */
    public Optional<Output<Map<String,String>>> definedTags() {
        return Optional.ofNullable(this.definedTags);
    }

    /**
     * (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{&#34;bar-key&#34;: &#34;value&#34;}`
     * 
     */
    @Import(name="freeformTags")
    private @Nullable Output<Map<String,String>> freeformTags;

    /**
     * @return (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{&#34;bar-key&#34;: &#34;value&#34;}`
     * 
     */
    public Optional<Output<Map<String,String>>> freeformTags() {
        return Optional.ofNullable(this.freeformTags);
    }

    /**
     * True if table can be reclaimed after an idle period.
     * 
     */
    @Import(name="isAutoReclaimable")
    private @Nullable Output<Boolean> isAutoReclaimable;

    /**
     * @return True if table can be reclaimed after an idle period.
     * 
     */
    public Optional<Output<Boolean>> isAutoReclaimable() {
        return Optional.ofNullable(this.isAutoReclaimable);
    }

    /**
     * True if this table is currently a member of a replication set.
     * 
     */
    @Import(name="isMultiRegion")
    private @Nullable Output<Boolean> isMultiRegion;

    /**
     * @return True if this table is currently a member of a replication set.
     * 
     */
    public Optional<Output<Boolean>> isMultiRegion() {
        return Optional.ofNullable(this.isMultiRegion);
    }

    /**
     * A message describing the current state in more detail.
     * 
     */
    @Import(name="lifecycleDetails")
    private @Nullable Output<String> lifecycleDetails;

    /**
     * @return A message describing the current state in more detail.
     * 
     */
    public Optional<Output<String>> lifecycleDetails() {
        return Optional.ofNullable(this.lifecycleDetails);
    }

    /**
     * If this table is in a replication set, this value represents the progress of the initialization of the replica&#39;s data.  A value of 100 indicates that initialization has completed.
     * 
     */
    @Import(name="localReplicaInitializationInPercent")
    private @Nullable Output<Integer> localReplicaInitializationInPercent;

    /**
     * @return If this table is in a replication set, this value represents the progress of the initialization of the replica&#39;s data.  A value of 100 indicates that initialization has completed.
     * 
     */
    public Optional<Output<Integer>> localReplicaInitializationInPercent() {
        return Optional.ofNullable(this.localReplicaInitializationInPercent);
    }

    /**
     * Table name.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return Table name.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * An array of Replica listing this table&#39;s replicas, if any
     * 
     */
    @Import(name="replicas")
    private @Nullable Output<List<TableReplicaArgs>> replicas;

    /**
     * @return An array of Replica listing this table&#39;s replicas, if any
     * 
     */
    public Optional<Output<List<TableReplicaArgs>>> replicas() {
        return Optional.ofNullable(this.replicas);
    }

    /**
     * The current state of this table&#39;s schema. Available states are MUTABLE - The schema can be changed. The table is not eligible for replication. FROZEN - The schema is immutable. The table is eligible for replication.
     * 
     */
    @Import(name="schemaState")
    private @Nullable Output<String> schemaState;

    /**
     * @return The current state of this table&#39;s schema. Available states are MUTABLE - The schema can be changed. The table is not eligible for replication. FROZEN - The schema is immutable. The table is eligible for replication.
     * 
     */
    public Optional<Output<String>> schemaState() {
        return Optional.ofNullable(this.schemaState);
    }

    /**
     * The table schema information as a JSON object.
     * 
     */
    @Import(name="schemas")
    private @Nullable Output<List<TableSchemaArgs>> schemas;

    /**
     * @return The table schema information as a JSON object.
     * 
     */
    public Optional<Output<List<TableSchemaArgs>>> schemas() {
        return Optional.ofNullable(this.schemas);
    }

    /**
     * The state of a table.
     * 
     */
    @Import(name="state")
    private @Nullable Output<String> state;

    /**
     * @return The state of a table.
     * 
     */
    public Optional<Output<String>> state() {
        return Optional.ofNullable(this.state);
    }

    /**
     * Read-only system tag. These predefined keys are scoped to namespaces.  At present the only supported namespace is `&#34;orcl-cloud&#34;`; and the only key in that namespace is `&#34;free-tier-retained&#34;`. Example: `{&#34;orcl-cloud&#34;&#34;: {&#34;free-tier-retained&#34;: &#34;true&#34;}}`
     * 
     */
    @Import(name="systemTags")
    private @Nullable Output<Map<String,String>> systemTags;

    /**
     * @return Read-only system tag. These predefined keys are scoped to namespaces.  At present the only supported namespace is `&#34;orcl-cloud&#34;`; and the only key in that namespace is `&#34;free-tier-retained&#34;`. Example: `{&#34;orcl-cloud&#34;&#34;: {&#34;free-tier-retained&#34;: &#34;true&#34;}}`
     * 
     */
    public Optional<Output<Map<String,String>>> systemTags() {
        return Optional.ofNullable(this.systemTags);
    }

    /**
     * (Updatable) Throughput and storage limits configuration of a table. It is required for top level table, must be null for child table as child table shares its top parent table&#39;s limits.
     * 
     */
    @Import(name="tableLimits")
    private @Nullable Output<TableTableLimitsArgs> tableLimits;

    /**
     * @return (Updatable) Throughput and storage limits configuration of a table. It is required for top level table, must be null for child table as child table shares its top parent table&#39;s limits.
     * 
     */
    public Optional<Output<TableTableLimitsArgs>> tableLimits() {
        return Optional.ofNullable(this.tableLimits);
    }

    /**
     * The time the the table was created. An RFC3339 formatted datetime string.
     * 
     */
    @Import(name="timeCreated")
    private @Nullable Output<String> timeCreated;

    /**
     * @return The time the the table was created. An RFC3339 formatted datetime string.
     * 
     */
    public Optional<Output<String>> timeCreated() {
        return Optional.ofNullable(this.timeCreated);
    }

    /**
     * If lifecycleState is INACTIVE, indicates when this table will be automatically removed. An RFC3339 formatted datetime string.
     * 
     */
    @Import(name="timeOfExpiration")
    private @Nullable Output<String> timeOfExpiration;

    /**
     * @return If lifecycleState is INACTIVE, indicates when this table will be automatically removed. An RFC3339 formatted datetime string.
     * 
     */
    public Optional<Output<String>> timeOfExpiration() {
        return Optional.ofNullable(this.timeOfExpiration);
    }

    /**
     * The time the the table&#39;s metadata was last updated. An RFC3339 formatted datetime string.
     * 
     */
    @Import(name="timeUpdated")
    private @Nullable Output<String> timeUpdated;

    /**
     * @return The time the the table&#39;s metadata was last updated. An RFC3339 formatted datetime string.
     * 
     */
    public Optional<Output<String>> timeUpdated() {
        return Optional.ofNullable(this.timeUpdated);
    }

    private TableState() {}

    private TableState(TableState $) {
        this.compartmentId = $.compartmentId;
        this.ddlStatement = $.ddlStatement;
        this.definedTags = $.definedTags;
        this.freeformTags = $.freeformTags;
        this.isAutoReclaimable = $.isAutoReclaimable;
        this.isMultiRegion = $.isMultiRegion;
        this.lifecycleDetails = $.lifecycleDetails;
        this.localReplicaInitializationInPercent = $.localReplicaInitializationInPercent;
        this.name = $.name;
        this.replicas = $.replicas;
        this.schemaState = $.schemaState;
        this.schemas = $.schemas;
        this.state = $.state;
        this.systemTags = $.systemTags;
        this.tableLimits = $.tableLimits;
        this.timeCreated = $.timeCreated;
        this.timeOfExpiration = $.timeOfExpiration;
        this.timeUpdated = $.timeUpdated;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(TableState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private TableState $;

        public Builder() {
            $ = new TableState();
        }

        public Builder(TableState defaults) {
            $ = new TableState(Objects.requireNonNull(defaults));
        }

        /**
         * @param compartmentId (Updatable) Compartment Identifier.
         * 
         * @return builder
         * 
         */
        public Builder compartmentId(@Nullable Output<String> compartmentId) {
            $.compartmentId = compartmentId;
            return this;
        }

        /**
         * @param compartmentId (Updatable) Compartment Identifier.
         * 
         * @return builder
         * 
         */
        public Builder compartmentId(String compartmentId) {
            return compartmentId(Output.of(compartmentId));
        }

        /**
         * @param ddlStatement (Updatable) CREATE TABLE DDL statement. While updating an existing table, note that the column order should not be changed, and new columns can only be appended at the end of the table.
         * 
         * @return builder
         * 
         */
        public Builder ddlStatement(@Nullable Output<String> ddlStatement) {
            $.ddlStatement = ddlStatement;
            return this;
        }

        /**
         * @param ddlStatement (Updatable) CREATE TABLE DDL statement. While updating an existing table, note that the column order should not be changed, and new columns can only be appended at the end of the table.
         * 
         * @return builder
         * 
         */
        public Builder ddlStatement(String ddlStatement) {
            return ddlStatement(Output.of(ddlStatement));
        }

        /**
         * @param definedTags (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace.  Example: `{&#34;foo-namespace&#34;: {&#34;bar-key&#34;: &#34;value&#34;}}`
         * 
         * @return builder
         * 
         */
        public Builder definedTags(@Nullable Output<Map<String,String>> definedTags) {
            $.definedTags = definedTags;
            return this;
        }

        /**
         * @param definedTags (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace.  Example: `{&#34;foo-namespace&#34;: {&#34;bar-key&#34;: &#34;value&#34;}}`
         * 
         * @return builder
         * 
         */
        public Builder definedTags(Map<String,String> definedTags) {
            return definedTags(Output.of(definedTags));
        }

        /**
         * @param freeformTags (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{&#34;bar-key&#34;: &#34;value&#34;}`
         * 
         * @return builder
         * 
         */
        public Builder freeformTags(@Nullable Output<Map<String,String>> freeformTags) {
            $.freeformTags = freeformTags;
            return this;
        }

        /**
         * @param freeformTags (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{&#34;bar-key&#34;: &#34;value&#34;}`
         * 
         * @return builder
         * 
         */
        public Builder freeformTags(Map<String,String> freeformTags) {
            return freeformTags(Output.of(freeformTags));
        }

        /**
         * @param isAutoReclaimable True if table can be reclaimed after an idle period.
         * 
         * @return builder
         * 
         */
        public Builder isAutoReclaimable(@Nullable Output<Boolean> isAutoReclaimable) {
            $.isAutoReclaimable = isAutoReclaimable;
            return this;
        }

        /**
         * @param isAutoReclaimable True if table can be reclaimed after an idle period.
         * 
         * @return builder
         * 
         */
        public Builder isAutoReclaimable(Boolean isAutoReclaimable) {
            return isAutoReclaimable(Output.of(isAutoReclaimable));
        }

        /**
         * @param isMultiRegion True if this table is currently a member of a replication set.
         * 
         * @return builder
         * 
         */
        public Builder isMultiRegion(@Nullable Output<Boolean> isMultiRegion) {
            $.isMultiRegion = isMultiRegion;
            return this;
        }

        /**
         * @param isMultiRegion True if this table is currently a member of a replication set.
         * 
         * @return builder
         * 
         */
        public Builder isMultiRegion(Boolean isMultiRegion) {
            return isMultiRegion(Output.of(isMultiRegion));
        }

        /**
         * @param lifecycleDetails A message describing the current state in more detail.
         * 
         * @return builder
         * 
         */
        public Builder lifecycleDetails(@Nullable Output<String> lifecycleDetails) {
            $.lifecycleDetails = lifecycleDetails;
            return this;
        }

        /**
         * @param lifecycleDetails A message describing the current state in more detail.
         * 
         * @return builder
         * 
         */
        public Builder lifecycleDetails(String lifecycleDetails) {
            return lifecycleDetails(Output.of(lifecycleDetails));
        }

        /**
         * @param localReplicaInitializationInPercent If this table is in a replication set, this value represents the progress of the initialization of the replica&#39;s data.  A value of 100 indicates that initialization has completed.
         * 
         * @return builder
         * 
         */
        public Builder localReplicaInitializationInPercent(@Nullable Output<Integer> localReplicaInitializationInPercent) {
            $.localReplicaInitializationInPercent = localReplicaInitializationInPercent;
            return this;
        }

        /**
         * @param localReplicaInitializationInPercent If this table is in a replication set, this value represents the progress of the initialization of the replica&#39;s data.  A value of 100 indicates that initialization has completed.
         * 
         * @return builder
         * 
         */
        public Builder localReplicaInitializationInPercent(Integer localReplicaInitializationInPercent) {
            return localReplicaInitializationInPercent(Output.of(localReplicaInitializationInPercent));
        }

        /**
         * @param name Table name.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name Table name.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param replicas An array of Replica listing this table&#39;s replicas, if any
         * 
         * @return builder
         * 
         */
        public Builder replicas(@Nullable Output<List<TableReplicaArgs>> replicas) {
            $.replicas = replicas;
            return this;
        }

        /**
         * @param replicas An array of Replica listing this table&#39;s replicas, if any
         * 
         * @return builder
         * 
         */
        public Builder replicas(List<TableReplicaArgs> replicas) {
            return replicas(Output.of(replicas));
        }

        /**
         * @param replicas An array of Replica listing this table&#39;s replicas, if any
         * 
         * @return builder
         * 
         */
        public Builder replicas(TableReplicaArgs... replicas) {
            return replicas(List.of(replicas));
        }

        /**
         * @param schemaState The current state of this table&#39;s schema. Available states are MUTABLE - The schema can be changed. The table is not eligible for replication. FROZEN - The schema is immutable. The table is eligible for replication.
         * 
         * @return builder
         * 
         */
        public Builder schemaState(@Nullable Output<String> schemaState) {
            $.schemaState = schemaState;
            return this;
        }

        /**
         * @param schemaState The current state of this table&#39;s schema. Available states are MUTABLE - The schema can be changed. The table is not eligible for replication. FROZEN - The schema is immutable. The table is eligible for replication.
         * 
         * @return builder
         * 
         */
        public Builder schemaState(String schemaState) {
            return schemaState(Output.of(schemaState));
        }

        /**
         * @param schemas The table schema information as a JSON object.
         * 
         * @return builder
         * 
         */
        public Builder schemas(@Nullable Output<List<TableSchemaArgs>> schemas) {
            $.schemas = schemas;
            return this;
        }

        /**
         * @param schemas The table schema information as a JSON object.
         * 
         * @return builder
         * 
         */
        public Builder schemas(List<TableSchemaArgs> schemas) {
            return schemas(Output.of(schemas));
        }

        /**
         * @param schemas The table schema information as a JSON object.
         * 
         * @return builder
         * 
         */
        public Builder schemas(TableSchemaArgs... schemas) {
            return schemas(List.of(schemas));
        }

        /**
         * @param state The state of a table.
         * 
         * @return builder
         * 
         */
        public Builder state(@Nullable Output<String> state) {
            $.state = state;
            return this;
        }

        /**
         * @param state The state of a table.
         * 
         * @return builder
         * 
         */
        public Builder state(String state) {
            return state(Output.of(state));
        }

        /**
         * @param systemTags Read-only system tag. These predefined keys are scoped to namespaces.  At present the only supported namespace is `&#34;orcl-cloud&#34;`; and the only key in that namespace is `&#34;free-tier-retained&#34;`. Example: `{&#34;orcl-cloud&#34;&#34;: {&#34;free-tier-retained&#34;: &#34;true&#34;}}`
         * 
         * @return builder
         * 
         */
        public Builder systemTags(@Nullable Output<Map<String,String>> systemTags) {
            $.systemTags = systemTags;
            return this;
        }

        /**
         * @param systemTags Read-only system tag. These predefined keys are scoped to namespaces.  At present the only supported namespace is `&#34;orcl-cloud&#34;`; and the only key in that namespace is `&#34;free-tier-retained&#34;`. Example: `{&#34;orcl-cloud&#34;&#34;: {&#34;free-tier-retained&#34;: &#34;true&#34;}}`
         * 
         * @return builder
         * 
         */
        public Builder systemTags(Map<String,String> systemTags) {
            return systemTags(Output.of(systemTags));
        }

        /**
         * @param tableLimits (Updatable) Throughput and storage limits configuration of a table. It is required for top level table, must be null for child table as child table shares its top parent table&#39;s limits.
         * 
         * @return builder
         * 
         */
        public Builder tableLimits(@Nullable Output<TableTableLimitsArgs> tableLimits) {
            $.tableLimits = tableLimits;
            return this;
        }

        /**
         * @param tableLimits (Updatable) Throughput and storage limits configuration of a table. It is required for top level table, must be null for child table as child table shares its top parent table&#39;s limits.
         * 
         * @return builder
         * 
         */
        public Builder tableLimits(TableTableLimitsArgs tableLimits) {
            return tableLimits(Output.of(tableLimits));
        }

        /**
         * @param timeCreated The time the the table was created. An RFC3339 formatted datetime string.
         * 
         * @return builder
         * 
         */
        public Builder timeCreated(@Nullable Output<String> timeCreated) {
            $.timeCreated = timeCreated;
            return this;
        }

        /**
         * @param timeCreated The time the the table was created. An RFC3339 formatted datetime string.
         * 
         * @return builder
         * 
         */
        public Builder timeCreated(String timeCreated) {
            return timeCreated(Output.of(timeCreated));
        }

        /**
         * @param timeOfExpiration If lifecycleState is INACTIVE, indicates when this table will be automatically removed. An RFC3339 formatted datetime string.
         * 
         * @return builder
         * 
         */
        public Builder timeOfExpiration(@Nullable Output<String> timeOfExpiration) {
            $.timeOfExpiration = timeOfExpiration;
            return this;
        }

        /**
         * @param timeOfExpiration If lifecycleState is INACTIVE, indicates when this table will be automatically removed. An RFC3339 formatted datetime string.
         * 
         * @return builder
         * 
         */
        public Builder timeOfExpiration(String timeOfExpiration) {
            return timeOfExpiration(Output.of(timeOfExpiration));
        }

        /**
         * @param timeUpdated The time the the table&#39;s metadata was last updated. An RFC3339 formatted datetime string.
         * 
         * @return builder
         * 
         */
        public Builder timeUpdated(@Nullable Output<String> timeUpdated) {
            $.timeUpdated = timeUpdated;
            return this;
        }

        /**
         * @param timeUpdated The time the the table&#39;s metadata was last updated. An RFC3339 formatted datetime string.
         * 
         * @return builder
         * 
         */
        public Builder timeUpdated(String timeUpdated) {
            return timeUpdated(Output.of(timeUpdated));
        }

        public TableState build() {
            return $;
        }
    }

}
