// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.oci.Vault.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.String;
import java.util.Objects;

@CustomType
public final class GetSecretsSecretSecretRule {
    /**
     * @return A property indicating whether the rule is applied even if the secret version with the content you are trying to reuse was deleted.
     * 
     */
    private Boolean isEnforcedOnDeletedSecretVersions;
    /**
     * @return A property indicating whether to block retrieval of the secret content, on expiry. The default is false. If the secret has already expired and you would like to retrieve the secret contents, you need to edit the secret rule to disable this property, to allow reading the secret content.
     * 
     */
    private Boolean isSecretContentRetrievalBlockedOnExpiry;
    /**
     * @return The type of rule, which either controls when the secret contents expire or whether they can be reused.
     * 
     */
    private String ruleType;
    /**
     * @return A property indicating how long the secret contents will be considered valid, expressed in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Time_intervals) format. The secret needs to be updated when the secret content expires. The timer resets after you update the secret contents. The minimum value is 1 day and the maximum value is 90 days for this property. Currently, only intervals expressed in days are supported. For example, pass `P3D` to have the secret version expire every 3 days.
     * 
     */
    private String secretVersionExpiryInterval;
    /**
     * @return An optional property indicating the absolute time when this secret will expire, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. The minimum number of days from current time is 1 day and the maximum number of days from current time is 365 days. Example: `2019-04-03T21:10:29.600Z`
     * 
     */
    private String timeOfAbsoluteExpiry;

    private GetSecretsSecretSecretRule() {}
    /**
     * @return A property indicating whether the rule is applied even if the secret version with the content you are trying to reuse was deleted.
     * 
     */
    public Boolean isEnforcedOnDeletedSecretVersions() {
        return this.isEnforcedOnDeletedSecretVersions;
    }
    /**
     * @return A property indicating whether to block retrieval of the secret content, on expiry. The default is false. If the secret has already expired and you would like to retrieve the secret contents, you need to edit the secret rule to disable this property, to allow reading the secret content.
     * 
     */
    public Boolean isSecretContentRetrievalBlockedOnExpiry() {
        return this.isSecretContentRetrievalBlockedOnExpiry;
    }
    /**
     * @return The type of rule, which either controls when the secret contents expire or whether they can be reused.
     * 
     */
    public String ruleType() {
        return this.ruleType;
    }
    /**
     * @return A property indicating how long the secret contents will be considered valid, expressed in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Time_intervals) format. The secret needs to be updated when the secret content expires. The timer resets after you update the secret contents. The minimum value is 1 day and the maximum value is 90 days for this property. Currently, only intervals expressed in days are supported. For example, pass `P3D` to have the secret version expire every 3 days.
     * 
     */
    public String secretVersionExpiryInterval() {
        return this.secretVersionExpiryInterval;
    }
    /**
     * @return An optional property indicating the absolute time when this secret will expire, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. The minimum number of days from current time is 1 day and the maximum number of days from current time is 365 days. Example: `2019-04-03T21:10:29.600Z`
     * 
     */
    public String timeOfAbsoluteExpiry() {
        return this.timeOfAbsoluteExpiry;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetSecretsSecretSecretRule defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private Boolean isEnforcedOnDeletedSecretVersions;
        private Boolean isSecretContentRetrievalBlockedOnExpiry;
        private String ruleType;
        private String secretVersionExpiryInterval;
        private String timeOfAbsoluteExpiry;
        public Builder() {}
        public Builder(GetSecretsSecretSecretRule defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.isEnforcedOnDeletedSecretVersions = defaults.isEnforcedOnDeletedSecretVersions;
    	      this.isSecretContentRetrievalBlockedOnExpiry = defaults.isSecretContentRetrievalBlockedOnExpiry;
    	      this.ruleType = defaults.ruleType;
    	      this.secretVersionExpiryInterval = defaults.secretVersionExpiryInterval;
    	      this.timeOfAbsoluteExpiry = defaults.timeOfAbsoluteExpiry;
        }

        @CustomType.Setter
        public Builder isEnforcedOnDeletedSecretVersions(Boolean isEnforcedOnDeletedSecretVersions) {
            if (isEnforcedOnDeletedSecretVersions == null) {
              throw new MissingRequiredPropertyException("GetSecretsSecretSecretRule", "isEnforcedOnDeletedSecretVersions");
            }
            this.isEnforcedOnDeletedSecretVersions = isEnforcedOnDeletedSecretVersions;
            return this;
        }
        @CustomType.Setter
        public Builder isSecretContentRetrievalBlockedOnExpiry(Boolean isSecretContentRetrievalBlockedOnExpiry) {
            if (isSecretContentRetrievalBlockedOnExpiry == null) {
              throw new MissingRequiredPropertyException("GetSecretsSecretSecretRule", "isSecretContentRetrievalBlockedOnExpiry");
            }
            this.isSecretContentRetrievalBlockedOnExpiry = isSecretContentRetrievalBlockedOnExpiry;
            return this;
        }
        @CustomType.Setter
        public Builder ruleType(String ruleType) {
            if (ruleType == null) {
              throw new MissingRequiredPropertyException("GetSecretsSecretSecretRule", "ruleType");
            }
            this.ruleType = ruleType;
            return this;
        }
        @CustomType.Setter
        public Builder secretVersionExpiryInterval(String secretVersionExpiryInterval) {
            if (secretVersionExpiryInterval == null) {
              throw new MissingRequiredPropertyException("GetSecretsSecretSecretRule", "secretVersionExpiryInterval");
            }
            this.secretVersionExpiryInterval = secretVersionExpiryInterval;
            return this;
        }
        @CustomType.Setter
        public Builder timeOfAbsoluteExpiry(String timeOfAbsoluteExpiry) {
            if (timeOfAbsoluteExpiry == null) {
              throw new MissingRequiredPropertyException("GetSecretsSecretSecretRule", "timeOfAbsoluteExpiry");
            }
            this.timeOfAbsoluteExpiry = timeOfAbsoluteExpiry;
            return this;
        }
        public GetSecretsSecretSecretRule build() {
            final var _resultValue = new GetSecretsSecretSecretRule();
            _resultValue.isEnforcedOnDeletedSecretVersions = isEnforcedOnDeletedSecretVersions;
            _resultValue.isSecretContentRetrievalBlockedOnExpiry = isSecretContentRetrievalBlockedOnExpiry;
            _resultValue.ruleType = ruleType;
            _resultValue.secretVersionExpiryInterval = secretVersionExpiryInterval;
            _resultValue.timeOfAbsoluteExpiry = timeOfAbsoluteExpiry;
            return _resultValue;
        }
    }
}
