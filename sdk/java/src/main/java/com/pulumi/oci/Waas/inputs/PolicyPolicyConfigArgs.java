// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.oci.Waas.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.oci.Waas.inputs.PolicyPolicyConfigHealthChecksArgs;
import com.pulumi.oci.Waas.inputs.PolicyPolicyConfigLoadBalancingMethodArgs;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class PolicyPolicyConfigArgs extends com.pulumi.resources.ResourceArgs {

    public static final PolicyPolicyConfigArgs Empty = new PolicyPolicyConfigArgs();

    /**
     * (Updatable) The OCID of the SSL certificate to use if HTTPS is supported.
     * 
     */
    @Import(name="certificateId")
    private @Nullable Output<String> certificateId;

    /**
     * @return (Updatable) The OCID of the SSL certificate to use if HTTPS is supported.
     * 
     */
    public Optional<Output<String>> certificateId() {
        return Optional.ofNullable(this.certificateId);
    }

    /**
     * (Updatable) The set cipher group for the configured TLS protocol. This sets the configuration for the TLS connections between clients and edge nodes only.
     * * **DEFAULT:** Cipher group supports TLS 1.0, TLS 1.1, TLS 1.2, TLS 1.3 protocols. It has the following ciphers enabled: `ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:!DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA`
     * 
     */
    @Import(name="cipherGroup")
    private @Nullable Output<String> cipherGroup;

    /**
     * @return (Updatable) The set cipher group for the configured TLS protocol. This sets the configuration for the TLS connections between clients and edge nodes only.
     * * **DEFAULT:** Cipher group supports TLS 1.0, TLS 1.1, TLS 1.2, TLS 1.3 protocols. It has the following ciphers enabled: `ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:!DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA`
     * 
     */
    public Optional<Output<String>> cipherGroup() {
        return Optional.ofNullable(this.cipherGroup);
    }

    /**
     * (Updatable) Specifies an HTTP header name which is treated as the connecting client&#39;s IP address. Applicable only if `isBehindCdn` is enabled.
     * 
     * The edge node reads this header and its value and sets the client IP address as specified. It does not create the header if the header is not present in the request. If the header is not present, the connecting IP address will be used as the client&#39;s true IP address. It uses the last IP address in the header&#39;s value as the true IP address.
     * 
     * Example: `X-Client-Ip: 11.1.1.1, 13.3.3.3`
     * 
     * In the case of multiple headers with the same name, only the first header will be used. It is assumed that CDN sets the correct client IP address to prevent spoofing.
     * * **X_FORWARDED_FOR:** Corresponds to `X-Forwarded-For` header name.
     * * **X_CLIENT_IP:** Corresponds to `X-Client-Ip` header name.
     * * **X_REAL_IP:** Corresponds to `X-Real-Ip` header name.
     * * **CLIENT_IP:** Corresponds to `Client-Ip` header name.
     * * **TRUE_CLIENT_IP:** Corresponds to `True-Client-Ip` header name.
     * 
     */
    @Import(name="clientAddressHeader")
    private @Nullable Output<String> clientAddressHeader;

    /**
     * @return (Updatable) Specifies an HTTP header name which is treated as the connecting client&#39;s IP address. Applicable only if `isBehindCdn` is enabled.
     * 
     * The edge node reads this header and its value and sets the client IP address as specified. It does not create the header if the header is not present in the request. If the header is not present, the connecting IP address will be used as the client&#39;s true IP address. It uses the last IP address in the header&#39;s value as the true IP address.
     * 
     * Example: `X-Client-Ip: 11.1.1.1, 13.3.3.3`
     * 
     * In the case of multiple headers with the same name, only the first header will be used. It is assumed that CDN sets the correct client IP address to prevent spoofing.
     * * **X_FORWARDED_FOR:** Corresponds to `X-Forwarded-For` header name.
     * * **X_CLIENT_IP:** Corresponds to `X-Client-Ip` header name.
     * * **X_REAL_IP:** Corresponds to `X-Real-Ip` header name.
     * * **CLIENT_IP:** Corresponds to `Client-Ip` header name.
     * * **TRUE_CLIENT_IP:** Corresponds to `True-Client-Ip` header name.
     * 
     */
    public Optional<Output<String>> clientAddressHeader() {
        return Optional.ofNullable(this.clientAddressHeader);
    }

    /**
     * (Updatable) Health checks monitor the status of your origin servers and only route traffic to the origins that pass the health check. If the health check fails, origin is automatically removed from the load balancing. There is roughly one health check per EDGE POP per period. Any checks that pass will be reported as &#34;healthy&#34;.
     * 
     */
    @Import(name="healthChecks")
    private @Nullable Output<PolicyPolicyConfigHealthChecksArgs> healthChecks;

    /**
     * @return (Updatable) Health checks monitor the status of your origin servers and only route traffic to the origins that pass the health check. If the health check fails, origin is automatically removed from the load balancing. There is roughly one health check per EDGE POP per period. Any checks that pass will be reported as &#34;healthy&#34;.
     * 
     */
    public Optional<Output<PolicyPolicyConfigHealthChecksArgs>> healthChecks() {
        return Optional.ofNullable(this.healthChecks);
    }

    /**
     * (Updatable) Enabling `isBehindCdn` allows for the collection of IP addresses from client requests if the WAF is connected to a CDN.
     * 
     */
    @Import(name="isBehindCdn")
    private @Nullable Output<Boolean> isBehindCdn;

    /**
     * @return (Updatable) Enabling `isBehindCdn` allows for the collection of IP addresses from client requests if the WAF is connected to a CDN.
     * 
     */
    public Optional<Output<Boolean>> isBehindCdn() {
        return Optional.ofNullable(this.isBehindCdn);
    }

    /**
     * (Updatable) Enable or disable automatic content caching based on the response `cache-control` header. This feature enables the origin to act as a proxy cache. Caching is usually defined using `cache-control` header. For example `cache-control: max-age=120` means that the returned resource is valid for 120 seconds. Caching rules will overwrite this setting.
     * 
     */
    @Import(name="isCacheControlRespected")
    private @Nullable Output<Boolean> isCacheControlRespected;

    /**
     * @return (Updatable) Enable or disable automatic content caching based on the response `cache-control` header. This feature enables the origin to act as a proxy cache. Caching is usually defined using `cache-control` header. For example `cache-control: max-age=120` means that the returned resource is valid for 120 seconds. Caching rules will overwrite this setting.
     * 
     */
    public Optional<Output<Boolean>> isCacheControlRespected() {
        return Optional.ofNullable(this.isCacheControlRespected);
    }

    /**
     * (Updatable) Enable or disable HTTPS support. If true, a `certificateId` is required. If unspecified, defaults to `false`.
     * 
     */
    @Import(name="isHttpsEnabled")
    private @Nullable Output<Boolean> isHttpsEnabled;

    /**
     * @return (Updatable) Enable or disable HTTPS support. If true, a `certificateId` is required. If unspecified, defaults to `false`.
     * 
     */
    public Optional<Output<Boolean>> isHttpsEnabled() {
        return Optional.ofNullable(this.isHttpsEnabled);
    }

    /**
     * (Updatable) Force HTTP to HTTPS redirection. If unspecified, defaults to `false`.
     * 
     */
    @Import(name="isHttpsForced")
    private @Nullable Output<Boolean> isHttpsForced;

    /**
     * @return (Updatable) Force HTTP to HTTPS redirection. If unspecified, defaults to `false`.
     * 
     */
    public Optional<Output<Boolean>> isHttpsForced() {
        return Optional.ofNullable(this.isHttpsForced);
    }

    /**
     * (Updatable) Enable or disable GZIP compression of origin responses. If enabled, the header `Accept-Encoding: gzip` is sent to origin, otherwise, the empty `Accept-Encoding:` header is used.
     * 
     */
    @Import(name="isOriginCompressionEnabled")
    private @Nullable Output<Boolean> isOriginCompressionEnabled;

    /**
     * @return (Updatable) Enable or disable GZIP compression of origin responses. If enabled, the header `Accept-Encoding: gzip` is sent to origin, otherwise, the empty `Accept-Encoding:` header is used.
     * 
     */
    public Optional<Output<Boolean>> isOriginCompressionEnabled() {
        return Optional.ofNullable(this.isOriginCompressionEnabled);
    }

    /**
     * (Updatable) Enable or disable buffering of responses from the origin. Buffering improves overall stability in case of network issues, but slightly increases Time To First Byte.
     * 
     */
    @Import(name="isResponseBufferingEnabled")
    private @Nullable Output<Boolean> isResponseBufferingEnabled;

    /**
     * @return (Updatable) Enable or disable buffering of responses from the origin. Buffering improves overall stability in case of network issues, but slightly increases Time To First Byte.
     * 
     */
    public Optional<Output<Boolean>> isResponseBufferingEnabled() {
        return Optional.ofNullable(this.isResponseBufferingEnabled);
    }

    /**
     * (Updatable) SNI stands for Server Name Indication and is an extension of the TLS protocol. It indicates which hostname is being contacted by the browser at the beginning of the &#39;handshake&#39;-process. This allows a server to connect multiple SSL Certificates to one IP address and port.
     * 
     */
    @Import(name="isSniEnabled")
    private @Nullable Output<Boolean> isSniEnabled;

    /**
     * @return (Updatable) SNI stands for Server Name Indication and is an extension of the TLS protocol. It indicates which hostname is being contacted by the browser at the beginning of the &#39;handshake&#39;-process. This allows a server to connect multiple SSL Certificates to one IP address and port.
     * 
     */
    public Optional<Output<Boolean>> isSniEnabled() {
        return Optional.ofNullable(this.isSniEnabled);
    }

    /**
     * (Updatable) An object that represents a load balancing method and its properties.
     * 
     */
    @Import(name="loadBalancingMethod")
    private @Nullable Output<PolicyPolicyConfigLoadBalancingMethodArgs> loadBalancingMethod;

    /**
     * @return (Updatable) An object that represents a load balancing method and its properties.
     * 
     */
    public Optional<Output<PolicyPolicyConfigLoadBalancingMethodArgs>> loadBalancingMethod() {
        return Optional.ofNullable(this.loadBalancingMethod);
    }

    /**
     * (Updatable) A list of allowed TLS protocols. Only applicable when HTTPS support is enabled. The TLS protocol is negotiated while the request is connecting and the most recent protocol supported by both the edge node and client browser will be selected. If no such version exists, the connection will be aborted.
     * * **TLS_V1:** corresponds to TLS 1.0 specification.
     * * **TLS_V1_1:** corresponds to TLS 1.1 specification.
     * * **TLS_V1_2:** corresponds to TLS 1.2 specification.
     * * **TLS_V1_3:** corresponds to TLS 1.3 specification.
     * 
     * Enabled TLS protocols must go in a row. For example if `TLS_v1_1` and `TLS_V1_3` are enabled, `TLS_V1_2` must be enabled too.
     * 
     */
    @Import(name="tlsProtocols")
    private @Nullable Output<List<String>> tlsProtocols;

    /**
     * @return (Updatable) A list of allowed TLS protocols. Only applicable when HTTPS support is enabled. The TLS protocol is negotiated while the request is connecting and the most recent protocol supported by both the edge node and client browser will be selected. If no such version exists, the connection will be aborted.
     * * **TLS_V1:** corresponds to TLS 1.0 specification.
     * * **TLS_V1_1:** corresponds to TLS 1.1 specification.
     * * **TLS_V1_2:** corresponds to TLS 1.2 specification.
     * * **TLS_V1_3:** corresponds to TLS 1.3 specification.
     * 
     * Enabled TLS protocols must go in a row. For example if `TLS_v1_1` and `TLS_V1_3` are enabled, `TLS_V1_2` must be enabled too.
     * 
     */
    public Optional<Output<List<String>>> tlsProtocols() {
        return Optional.ofNullable(this.tlsProtocols);
    }

    /**
     * (Updatable) ModSecurity is not capable to inspect WebSockets. Therefore paths specified here have WAF disabled if Connection request header from the client has the value Upgrade (case insensitive matching) and Upgrade request header has the value websocket (case insensitive matching). Paths matches if the concatenation of request URL path and query starts with the contents of the one of `websocketPathPrefixes` array value. In All other cases challenges, like JSC, HIC and etc., remain active.
     * 
     */
    @Import(name="websocketPathPrefixes")
    private @Nullable Output<List<String>> websocketPathPrefixes;

    /**
     * @return (Updatable) ModSecurity is not capable to inspect WebSockets. Therefore paths specified here have WAF disabled if Connection request header from the client has the value Upgrade (case insensitive matching) and Upgrade request header has the value websocket (case insensitive matching). Paths matches if the concatenation of request URL path and query starts with the contents of the one of `websocketPathPrefixes` array value. In All other cases challenges, like JSC, HIC and etc., remain active.
     * 
     */
    public Optional<Output<List<String>>> websocketPathPrefixes() {
        return Optional.ofNullable(this.websocketPathPrefixes);
    }

    private PolicyPolicyConfigArgs() {}

    private PolicyPolicyConfigArgs(PolicyPolicyConfigArgs $) {
        this.certificateId = $.certificateId;
        this.cipherGroup = $.cipherGroup;
        this.clientAddressHeader = $.clientAddressHeader;
        this.healthChecks = $.healthChecks;
        this.isBehindCdn = $.isBehindCdn;
        this.isCacheControlRespected = $.isCacheControlRespected;
        this.isHttpsEnabled = $.isHttpsEnabled;
        this.isHttpsForced = $.isHttpsForced;
        this.isOriginCompressionEnabled = $.isOriginCompressionEnabled;
        this.isResponseBufferingEnabled = $.isResponseBufferingEnabled;
        this.isSniEnabled = $.isSniEnabled;
        this.loadBalancingMethod = $.loadBalancingMethod;
        this.tlsProtocols = $.tlsProtocols;
        this.websocketPathPrefixes = $.websocketPathPrefixes;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(PolicyPolicyConfigArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private PolicyPolicyConfigArgs $;

        public Builder() {
            $ = new PolicyPolicyConfigArgs();
        }

        public Builder(PolicyPolicyConfigArgs defaults) {
            $ = new PolicyPolicyConfigArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param certificateId (Updatable) The OCID of the SSL certificate to use if HTTPS is supported.
         * 
         * @return builder
         * 
         */
        public Builder certificateId(@Nullable Output<String> certificateId) {
            $.certificateId = certificateId;
            return this;
        }

        /**
         * @param certificateId (Updatable) The OCID of the SSL certificate to use if HTTPS is supported.
         * 
         * @return builder
         * 
         */
        public Builder certificateId(String certificateId) {
            return certificateId(Output.of(certificateId));
        }

        /**
         * @param cipherGroup (Updatable) The set cipher group for the configured TLS protocol. This sets the configuration for the TLS connections between clients and edge nodes only.
         * * **DEFAULT:** Cipher group supports TLS 1.0, TLS 1.1, TLS 1.2, TLS 1.3 protocols. It has the following ciphers enabled: `ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:!DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA`
         * 
         * @return builder
         * 
         */
        public Builder cipherGroup(@Nullable Output<String> cipherGroup) {
            $.cipherGroup = cipherGroup;
            return this;
        }

        /**
         * @param cipherGroup (Updatable) The set cipher group for the configured TLS protocol. This sets the configuration for the TLS connections between clients and edge nodes only.
         * * **DEFAULT:** Cipher group supports TLS 1.0, TLS 1.1, TLS 1.2, TLS 1.3 protocols. It has the following ciphers enabled: `ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:!DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA`
         * 
         * @return builder
         * 
         */
        public Builder cipherGroup(String cipherGroup) {
            return cipherGroup(Output.of(cipherGroup));
        }

        /**
         * @param clientAddressHeader (Updatable) Specifies an HTTP header name which is treated as the connecting client&#39;s IP address. Applicable only if `isBehindCdn` is enabled.
         * 
         * The edge node reads this header and its value and sets the client IP address as specified. It does not create the header if the header is not present in the request. If the header is not present, the connecting IP address will be used as the client&#39;s true IP address. It uses the last IP address in the header&#39;s value as the true IP address.
         * 
         * Example: `X-Client-Ip: 11.1.1.1, 13.3.3.3`
         * 
         * In the case of multiple headers with the same name, only the first header will be used. It is assumed that CDN sets the correct client IP address to prevent spoofing.
         * * **X_FORWARDED_FOR:** Corresponds to `X-Forwarded-For` header name.
         * * **X_CLIENT_IP:** Corresponds to `X-Client-Ip` header name.
         * * **X_REAL_IP:** Corresponds to `X-Real-Ip` header name.
         * * **CLIENT_IP:** Corresponds to `Client-Ip` header name.
         * * **TRUE_CLIENT_IP:** Corresponds to `True-Client-Ip` header name.
         * 
         * @return builder
         * 
         */
        public Builder clientAddressHeader(@Nullable Output<String> clientAddressHeader) {
            $.clientAddressHeader = clientAddressHeader;
            return this;
        }

        /**
         * @param clientAddressHeader (Updatable) Specifies an HTTP header name which is treated as the connecting client&#39;s IP address. Applicable only if `isBehindCdn` is enabled.
         * 
         * The edge node reads this header and its value and sets the client IP address as specified. It does not create the header if the header is not present in the request. If the header is not present, the connecting IP address will be used as the client&#39;s true IP address. It uses the last IP address in the header&#39;s value as the true IP address.
         * 
         * Example: `X-Client-Ip: 11.1.1.1, 13.3.3.3`
         * 
         * In the case of multiple headers with the same name, only the first header will be used. It is assumed that CDN sets the correct client IP address to prevent spoofing.
         * * **X_FORWARDED_FOR:** Corresponds to `X-Forwarded-For` header name.
         * * **X_CLIENT_IP:** Corresponds to `X-Client-Ip` header name.
         * * **X_REAL_IP:** Corresponds to `X-Real-Ip` header name.
         * * **CLIENT_IP:** Corresponds to `Client-Ip` header name.
         * * **TRUE_CLIENT_IP:** Corresponds to `True-Client-Ip` header name.
         * 
         * @return builder
         * 
         */
        public Builder clientAddressHeader(String clientAddressHeader) {
            return clientAddressHeader(Output.of(clientAddressHeader));
        }

        /**
         * @param healthChecks (Updatable) Health checks monitor the status of your origin servers and only route traffic to the origins that pass the health check. If the health check fails, origin is automatically removed from the load balancing. There is roughly one health check per EDGE POP per period. Any checks that pass will be reported as &#34;healthy&#34;.
         * 
         * @return builder
         * 
         */
        public Builder healthChecks(@Nullable Output<PolicyPolicyConfigHealthChecksArgs> healthChecks) {
            $.healthChecks = healthChecks;
            return this;
        }

        /**
         * @param healthChecks (Updatable) Health checks monitor the status of your origin servers and only route traffic to the origins that pass the health check. If the health check fails, origin is automatically removed from the load balancing. There is roughly one health check per EDGE POP per period. Any checks that pass will be reported as &#34;healthy&#34;.
         * 
         * @return builder
         * 
         */
        public Builder healthChecks(PolicyPolicyConfigHealthChecksArgs healthChecks) {
            return healthChecks(Output.of(healthChecks));
        }

        /**
         * @param isBehindCdn (Updatable) Enabling `isBehindCdn` allows for the collection of IP addresses from client requests if the WAF is connected to a CDN.
         * 
         * @return builder
         * 
         */
        public Builder isBehindCdn(@Nullable Output<Boolean> isBehindCdn) {
            $.isBehindCdn = isBehindCdn;
            return this;
        }

        /**
         * @param isBehindCdn (Updatable) Enabling `isBehindCdn` allows for the collection of IP addresses from client requests if the WAF is connected to a CDN.
         * 
         * @return builder
         * 
         */
        public Builder isBehindCdn(Boolean isBehindCdn) {
            return isBehindCdn(Output.of(isBehindCdn));
        }

        /**
         * @param isCacheControlRespected (Updatable) Enable or disable automatic content caching based on the response `cache-control` header. This feature enables the origin to act as a proxy cache. Caching is usually defined using `cache-control` header. For example `cache-control: max-age=120` means that the returned resource is valid for 120 seconds. Caching rules will overwrite this setting.
         * 
         * @return builder
         * 
         */
        public Builder isCacheControlRespected(@Nullable Output<Boolean> isCacheControlRespected) {
            $.isCacheControlRespected = isCacheControlRespected;
            return this;
        }

        /**
         * @param isCacheControlRespected (Updatable) Enable or disable automatic content caching based on the response `cache-control` header. This feature enables the origin to act as a proxy cache. Caching is usually defined using `cache-control` header. For example `cache-control: max-age=120` means that the returned resource is valid for 120 seconds. Caching rules will overwrite this setting.
         * 
         * @return builder
         * 
         */
        public Builder isCacheControlRespected(Boolean isCacheControlRespected) {
            return isCacheControlRespected(Output.of(isCacheControlRespected));
        }

        /**
         * @param isHttpsEnabled (Updatable) Enable or disable HTTPS support. If true, a `certificateId` is required. If unspecified, defaults to `false`.
         * 
         * @return builder
         * 
         */
        public Builder isHttpsEnabled(@Nullable Output<Boolean> isHttpsEnabled) {
            $.isHttpsEnabled = isHttpsEnabled;
            return this;
        }

        /**
         * @param isHttpsEnabled (Updatable) Enable or disable HTTPS support. If true, a `certificateId` is required. If unspecified, defaults to `false`.
         * 
         * @return builder
         * 
         */
        public Builder isHttpsEnabled(Boolean isHttpsEnabled) {
            return isHttpsEnabled(Output.of(isHttpsEnabled));
        }

        /**
         * @param isHttpsForced (Updatable) Force HTTP to HTTPS redirection. If unspecified, defaults to `false`.
         * 
         * @return builder
         * 
         */
        public Builder isHttpsForced(@Nullable Output<Boolean> isHttpsForced) {
            $.isHttpsForced = isHttpsForced;
            return this;
        }

        /**
         * @param isHttpsForced (Updatable) Force HTTP to HTTPS redirection. If unspecified, defaults to `false`.
         * 
         * @return builder
         * 
         */
        public Builder isHttpsForced(Boolean isHttpsForced) {
            return isHttpsForced(Output.of(isHttpsForced));
        }

        /**
         * @param isOriginCompressionEnabled (Updatable) Enable or disable GZIP compression of origin responses. If enabled, the header `Accept-Encoding: gzip` is sent to origin, otherwise, the empty `Accept-Encoding:` header is used.
         * 
         * @return builder
         * 
         */
        public Builder isOriginCompressionEnabled(@Nullable Output<Boolean> isOriginCompressionEnabled) {
            $.isOriginCompressionEnabled = isOriginCompressionEnabled;
            return this;
        }

        /**
         * @param isOriginCompressionEnabled (Updatable) Enable or disable GZIP compression of origin responses. If enabled, the header `Accept-Encoding: gzip` is sent to origin, otherwise, the empty `Accept-Encoding:` header is used.
         * 
         * @return builder
         * 
         */
        public Builder isOriginCompressionEnabled(Boolean isOriginCompressionEnabled) {
            return isOriginCompressionEnabled(Output.of(isOriginCompressionEnabled));
        }

        /**
         * @param isResponseBufferingEnabled (Updatable) Enable or disable buffering of responses from the origin. Buffering improves overall stability in case of network issues, but slightly increases Time To First Byte.
         * 
         * @return builder
         * 
         */
        public Builder isResponseBufferingEnabled(@Nullable Output<Boolean> isResponseBufferingEnabled) {
            $.isResponseBufferingEnabled = isResponseBufferingEnabled;
            return this;
        }

        /**
         * @param isResponseBufferingEnabled (Updatable) Enable or disable buffering of responses from the origin. Buffering improves overall stability in case of network issues, but slightly increases Time To First Byte.
         * 
         * @return builder
         * 
         */
        public Builder isResponseBufferingEnabled(Boolean isResponseBufferingEnabled) {
            return isResponseBufferingEnabled(Output.of(isResponseBufferingEnabled));
        }

        /**
         * @param isSniEnabled (Updatable) SNI stands for Server Name Indication and is an extension of the TLS protocol. It indicates which hostname is being contacted by the browser at the beginning of the &#39;handshake&#39;-process. This allows a server to connect multiple SSL Certificates to one IP address and port.
         * 
         * @return builder
         * 
         */
        public Builder isSniEnabled(@Nullable Output<Boolean> isSniEnabled) {
            $.isSniEnabled = isSniEnabled;
            return this;
        }

        /**
         * @param isSniEnabled (Updatable) SNI stands for Server Name Indication and is an extension of the TLS protocol. It indicates which hostname is being contacted by the browser at the beginning of the &#39;handshake&#39;-process. This allows a server to connect multiple SSL Certificates to one IP address and port.
         * 
         * @return builder
         * 
         */
        public Builder isSniEnabled(Boolean isSniEnabled) {
            return isSniEnabled(Output.of(isSniEnabled));
        }

        /**
         * @param loadBalancingMethod (Updatable) An object that represents a load balancing method and its properties.
         * 
         * @return builder
         * 
         */
        public Builder loadBalancingMethod(@Nullable Output<PolicyPolicyConfigLoadBalancingMethodArgs> loadBalancingMethod) {
            $.loadBalancingMethod = loadBalancingMethod;
            return this;
        }

        /**
         * @param loadBalancingMethod (Updatable) An object that represents a load balancing method and its properties.
         * 
         * @return builder
         * 
         */
        public Builder loadBalancingMethod(PolicyPolicyConfigLoadBalancingMethodArgs loadBalancingMethod) {
            return loadBalancingMethod(Output.of(loadBalancingMethod));
        }

        /**
         * @param tlsProtocols (Updatable) A list of allowed TLS protocols. Only applicable when HTTPS support is enabled. The TLS protocol is negotiated while the request is connecting and the most recent protocol supported by both the edge node and client browser will be selected. If no such version exists, the connection will be aborted.
         * * **TLS_V1:** corresponds to TLS 1.0 specification.
         * * **TLS_V1_1:** corresponds to TLS 1.1 specification.
         * * **TLS_V1_2:** corresponds to TLS 1.2 specification.
         * * **TLS_V1_3:** corresponds to TLS 1.3 specification.
         * 
         * Enabled TLS protocols must go in a row. For example if `TLS_v1_1` and `TLS_V1_3` are enabled, `TLS_V1_2` must be enabled too.
         * 
         * @return builder
         * 
         */
        public Builder tlsProtocols(@Nullable Output<List<String>> tlsProtocols) {
            $.tlsProtocols = tlsProtocols;
            return this;
        }

        /**
         * @param tlsProtocols (Updatable) A list of allowed TLS protocols. Only applicable when HTTPS support is enabled. The TLS protocol is negotiated while the request is connecting and the most recent protocol supported by both the edge node and client browser will be selected. If no such version exists, the connection will be aborted.
         * * **TLS_V1:** corresponds to TLS 1.0 specification.
         * * **TLS_V1_1:** corresponds to TLS 1.1 specification.
         * * **TLS_V1_2:** corresponds to TLS 1.2 specification.
         * * **TLS_V1_3:** corresponds to TLS 1.3 specification.
         * 
         * Enabled TLS protocols must go in a row. For example if `TLS_v1_1` and `TLS_V1_3` are enabled, `TLS_V1_2` must be enabled too.
         * 
         * @return builder
         * 
         */
        public Builder tlsProtocols(List<String> tlsProtocols) {
            return tlsProtocols(Output.of(tlsProtocols));
        }

        /**
         * @param tlsProtocols (Updatable) A list of allowed TLS protocols. Only applicable when HTTPS support is enabled. The TLS protocol is negotiated while the request is connecting and the most recent protocol supported by both the edge node and client browser will be selected. If no such version exists, the connection will be aborted.
         * * **TLS_V1:** corresponds to TLS 1.0 specification.
         * * **TLS_V1_1:** corresponds to TLS 1.1 specification.
         * * **TLS_V1_2:** corresponds to TLS 1.2 specification.
         * * **TLS_V1_3:** corresponds to TLS 1.3 specification.
         * 
         * Enabled TLS protocols must go in a row. For example if `TLS_v1_1` and `TLS_V1_3` are enabled, `TLS_V1_2` must be enabled too.
         * 
         * @return builder
         * 
         */
        public Builder tlsProtocols(String... tlsProtocols) {
            return tlsProtocols(List.of(tlsProtocols));
        }

        /**
         * @param websocketPathPrefixes (Updatable) ModSecurity is not capable to inspect WebSockets. Therefore paths specified here have WAF disabled if Connection request header from the client has the value Upgrade (case insensitive matching) and Upgrade request header has the value websocket (case insensitive matching). Paths matches if the concatenation of request URL path and query starts with the contents of the one of `websocketPathPrefixes` array value. In All other cases challenges, like JSC, HIC and etc., remain active.
         * 
         * @return builder
         * 
         */
        public Builder websocketPathPrefixes(@Nullable Output<List<String>> websocketPathPrefixes) {
            $.websocketPathPrefixes = websocketPathPrefixes;
            return this;
        }

        /**
         * @param websocketPathPrefixes (Updatable) ModSecurity is not capable to inspect WebSockets. Therefore paths specified here have WAF disabled if Connection request header from the client has the value Upgrade (case insensitive matching) and Upgrade request header has the value websocket (case insensitive matching). Paths matches if the concatenation of request URL path and query starts with the contents of the one of `websocketPathPrefixes` array value. In All other cases challenges, like JSC, HIC and etc., remain active.
         * 
         * @return builder
         * 
         */
        public Builder websocketPathPrefixes(List<String> websocketPathPrefixes) {
            return websocketPathPrefixes(Output.of(websocketPathPrefixes));
        }

        /**
         * @param websocketPathPrefixes (Updatable) ModSecurity is not capable to inspect WebSockets. Therefore paths specified here have WAF disabled if Connection request header from the client has the value Upgrade (case insensitive matching) and Upgrade request header has the value websocket (case insensitive matching). Paths matches if the concatenation of request URL path and query starts with the contents of the one of `websocketPathPrefixes` array value. In All other cases challenges, like JSC, HIC and etc., remain active.
         * 
         * @return builder
         * 
         */
        public Builder websocketPathPrefixes(String... websocketPathPrefixes) {
            return websocketPathPrefixes(List.of(websocketPathPrefixes));
        }

        public PolicyPolicyConfigArgs build() {
            return $;
        }
    }

}
