// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.oci.Waas.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.oci.Waas.outputs.GetWaasPolicyPolicyConfigHealthChecks;
import com.pulumi.oci.Waas.outputs.GetWaasPolicyPolicyConfigLoadBalancingMethod;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Objects;

@CustomType
public final class GetWaasPolicyPolicyConfig {
    /**
     * @return The OCID of the SSL certificate to use if HTTPS is supported.
     * 
     */
    private String certificateId;
    /**
     * @return The set cipher group for the configured TLS protocol. This sets the configuration for the TLS connections between clients and edge nodes only.
     * * **DEFAULT:** Cipher group supports TLS 1.0, TLS 1.1, TLS 1.2, TLS 1.3 protocols. It has the following ciphers enabled: `ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:!DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA`
     * 
     */
    private String cipherGroup;
    /**
     * @return Specifies an HTTP header name which is treated as the connecting client&#39;s IP address. Applicable only if `isBehindCdn` is enabled.
     * 
     */
    private String clientAddressHeader;
    /**
     * @return Health checks monitor the status of your origin servers and only route traffic to the origins that pass the health check. If the health check fails, origin is automatically removed from the load balancing. There is roughly one health check per EDGE POP per period. Any checks that pass will be reported as &#34;healthy&#34;.
     * 
     */
    private GetWaasPolicyPolicyConfigHealthChecks healthChecks;
    /**
     * @return Enabling `isBehindCdn` allows for the collection of IP addresses from client requests if the WAF is connected to a CDN.
     * 
     */
    private Boolean isBehindCdn;
    /**
     * @return Enable or disable automatic content caching based on the response `cache-control` header. This feature enables the origin to act as a proxy cache. Caching is usually defined using `cache-control` header. For example `cache-control: max-age=120` means that the returned resource is valid for 120 seconds. Caching rules will overwrite this setting.
     * 
     */
    private Boolean isCacheControlRespected;
    /**
     * @return Enable or disable HTTPS support. If true, a `certificateId` is required. If unspecified, defaults to `false`.
     * 
     */
    private Boolean isHttpsEnabled;
    /**
     * @return Force HTTP to HTTPS redirection. If unspecified, defaults to `false`.
     * 
     */
    private Boolean isHttpsForced;
    /**
     * @return Enable or disable GZIP compression of origin responses. If enabled, the header `Accept-Encoding: gzip` is sent to origin, otherwise, the empty `Accept-Encoding:` header is used.
     * 
     */
    private Boolean isOriginCompressionEnabled;
    /**
     * @return Enable or disable buffering of responses from the origin. Buffering improves overall stability in case of network issues, but slightly increases Time To First Byte.
     * 
     */
    private Boolean isResponseBufferingEnabled;
    /**
     * @return SNI stands for Server Name Indication and is an extension of the TLS protocol. It indicates which hostname is being contacted by the browser at the beginning of the &#39;handshake&#39;-process. This allows a server to connect multiple SSL Certificates to one IP address and port.
     * 
     */
    private Boolean isSniEnabled;
    /**
     * @return An object that represents a load balancing method and its properties.
     * 
     */
    private GetWaasPolicyPolicyConfigLoadBalancingMethod loadBalancingMethod;
    /**
     * @return A list of allowed TLS protocols. Only applicable when HTTPS support is enabled. The TLS protocol is negotiated while the request is connecting and the most recent protocol supported by both the edge node and client browser will be selected. If no such version exists, the connection will be aborted.
     * * **TLS_V1:** corresponds to TLS 1.0 specification.
     * * **TLS_V1_1:** corresponds to TLS 1.1 specification.
     * * **TLS_V1_2:** corresponds to TLS 1.2 specification.
     * * **TLS_V1_3:** corresponds to TLS 1.3 specification.
     * 
     */
    private List<String> tlsProtocols;
    /**
     * @return ModSecurity is not capable to inspect WebSockets. Therefore paths specified here have WAF disabled if Connection request header from the client has the value Upgrade (case insensitive matching) and Upgrade request header has the value websocket (case insensitive matching). Paths matches if the concatenation of request URL path and query starts with the contents of the one of `websocketPathPrefixes` array value. In All other cases challenges, like JSC, HIC and etc., remain active.
     * 
     */
    private List<String> websocketPathPrefixes;

    private GetWaasPolicyPolicyConfig() {}
    /**
     * @return The OCID of the SSL certificate to use if HTTPS is supported.
     * 
     */
    public String certificateId() {
        return this.certificateId;
    }
    /**
     * @return The set cipher group for the configured TLS protocol. This sets the configuration for the TLS connections between clients and edge nodes only.
     * * **DEFAULT:** Cipher group supports TLS 1.0, TLS 1.1, TLS 1.2, TLS 1.3 protocols. It has the following ciphers enabled: `ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:!DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA`
     * 
     */
    public String cipherGroup() {
        return this.cipherGroup;
    }
    /**
     * @return Specifies an HTTP header name which is treated as the connecting client&#39;s IP address. Applicable only if `isBehindCdn` is enabled.
     * 
     */
    public String clientAddressHeader() {
        return this.clientAddressHeader;
    }
    /**
     * @return Health checks monitor the status of your origin servers and only route traffic to the origins that pass the health check. If the health check fails, origin is automatically removed from the load balancing. There is roughly one health check per EDGE POP per period. Any checks that pass will be reported as &#34;healthy&#34;.
     * 
     */
    public GetWaasPolicyPolicyConfigHealthChecks healthChecks() {
        return this.healthChecks;
    }
    /**
     * @return Enabling `isBehindCdn` allows for the collection of IP addresses from client requests if the WAF is connected to a CDN.
     * 
     */
    public Boolean isBehindCdn() {
        return this.isBehindCdn;
    }
    /**
     * @return Enable or disable automatic content caching based on the response `cache-control` header. This feature enables the origin to act as a proxy cache. Caching is usually defined using `cache-control` header. For example `cache-control: max-age=120` means that the returned resource is valid for 120 seconds. Caching rules will overwrite this setting.
     * 
     */
    public Boolean isCacheControlRespected() {
        return this.isCacheControlRespected;
    }
    /**
     * @return Enable or disable HTTPS support. If true, a `certificateId` is required. If unspecified, defaults to `false`.
     * 
     */
    public Boolean isHttpsEnabled() {
        return this.isHttpsEnabled;
    }
    /**
     * @return Force HTTP to HTTPS redirection. If unspecified, defaults to `false`.
     * 
     */
    public Boolean isHttpsForced() {
        return this.isHttpsForced;
    }
    /**
     * @return Enable or disable GZIP compression of origin responses. If enabled, the header `Accept-Encoding: gzip` is sent to origin, otherwise, the empty `Accept-Encoding:` header is used.
     * 
     */
    public Boolean isOriginCompressionEnabled() {
        return this.isOriginCompressionEnabled;
    }
    /**
     * @return Enable or disable buffering of responses from the origin. Buffering improves overall stability in case of network issues, but slightly increases Time To First Byte.
     * 
     */
    public Boolean isResponseBufferingEnabled() {
        return this.isResponseBufferingEnabled;
    }
    /**
     * @return SNI stands for Server Name Indication and is an extension of the TLS protocol. It indicates which hostname is being contacted by the browser at the beginning of the &#39;handshake&#39;-process. This allows a server to connect multiple SSL Certificates to one IP address and port.
     * 
     */
    public Boolean isSniEnabled() {
        return this.isSniEnabled;
    }
    /**
     * @return An object that represents a load balancing method and its properties.
     * 
     */
    public GetWaasPolicyPolicyConfigLoadBalancingMethod loadBalancingMethod() {
        return this.loadBalancingMethod;
    }
    /**
     * @return A list of allowed TLS protocols. Only applicable when HTTPS support is enabled. The TLS protocol is negotiated while the request is connecting and the most recent protocol supported by both the edge node and client browser will be selected. If no such version exists, the connection will be aborted.
     * * **TLS_V1:** corresponds to TLS 1.0 specification.
     * * **TLS_V1_1:** corresponds to TLS 1.1 specification.
     * * **TLS_V1_2:** corresponds to TLS 1.2 specification.
     * * **TLS_V1_3:** corresponds to TLS 1.3 specification.
     * 
     */
    public List<String> tlsProtocols() {
        return this.tlsProtocols;
    }
    /**
     * @return ModSecurity is not capable to inspect WebSockets. Therefore paths specified here have WAF disabled if Connection request header from the client has the value Upgrade (case insensitive matching) and Upgrade request header has the value websocket (case insensitive matching). Paths matches if the concatenation of request URL path and query starts with the contents of the one of `websocketPathPrefixes` array value. In All other cases challenges, like JSC, HIC and etc., remain active.
     * 
     */
    public List<String> websocketPathPrefixes() {
        return this.websocketPathPrefixes;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetWaasPolicyPolicyConfig defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String certificateId;
        private String cipherGroup;
        private String clientAddressHeader;
        private GetWaasPolicyPolicyConfigHealthChecks healthChecks;
        private Boolean isBehindCdn;
        private Boolean isCacheControlRespected;
        private Boolean isHttpsEnabled;
        private Boolean isHttpsForced;
        private Boolean isOriginCompressionEnabled;
        private Boolean isResponseBufferingEnabled;
        private Boolean isSniEnabled;
        private GetWaasPolicyPolicyConfigLoadBalancingMethod loadBalancingMethod;
        private List<String> tlsProtocols;
        private List<String> websocketPathPrefixes;
        public Builder() {}
        public Builder(GetWaasPolicyPolicyConfig defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.certificateId = defaults.certificateId;
    	      this.cipherGroup = defaults.cipherGroup;
    	      this.clientAddressHeader = defaults.clientAddressHeader;
    	      this.healthChecks = defaults.healthChecks;
    	      this.isBehindCdn = defaults.isBehindCdn;
    	      this.isCacheControlRespected = defaults.isCacheControlRespected;
    	      this.isHttpsEnabled = defaults.isHttpsEnabled;
    	      this.isHttpsForced = defaults.isHttpsForced;
    	      this.isOriginCompressionEnabled = defaults.isOriginCompressionEnabled;
    	      this.isResponseBufferingEnabled = defaults.isResponseBufferingEnabled;
    	      this.isSniEnabled = defaults.isSniEnabled;
    	      this.loadBalancingMethod = defaults.loadBalancingMethod;
    	      this.tlsProtocols = defaults.tlsProtocols;
    	      this.websocketPathPrefixes = defaults.websocketPathPrefixes;
        }

        @CustomType.Setter
        public Builder certificateId(String certificateId) {
            if (certificateId == null) {
              throw new MissingRequiredPropertyException("GetWaasPolicyPolicyConfig", "certificateId");
            }
            this.certificateId = certificateId;
            return this;
        }
        @CustomType.Setter
        public Builder cipherGroup(String cipherGroup) {
            if (cipherGroup == null) {
              throw new MissingRequiredPropertyException("GetWaasPolicyPolicyConfig", "cipherGroup");
            }
            this.cipherGroup = cipherGroup;
            return this;
        }
        @CustomType.Setter
        public Builder clientAddressHeader(String clientAddressHeader) {
            if (clientAddressHeader == null) {
              throw new MissingRequiredPropertyException("GetWaasPolicyPolicyConfig", "clientAddressHeader");
            }
            this.clientAddressHeader = clientAddressHeader;
            return this;
        }
        @CustomType.Setter
        public Builder healthChecks(GetWaasPolicyPolicyConfigHealthChecks healthChecks) {
            if (healthChecks == null) {
              throw new MissingRequiredPropertyException("GetWaasPolicyPolicyConfig", "healthChecks");
            }
            this.healthChecks = healthChecks;
            return this;
        }
        @CustomType.Setter
        public Builder isBehindCdn(Boolean isBehindCdn) {
            if (isBehindCdn == null) {
              throw new MissingRequiredPropertyException("GetWaasPolicyPolicyConfig", "isBehindCdn");
            }
            this.isBehindCdn = isBehindCdn;
            return this;
        }
        @CustomType.Setter
        public Builder isCacheControlRespected(Boolean isCacheControlRespected) {
            if (isCacheControlRespected == null) {
              throw new MissingRequiredPropertyException("GetWaasPolicyPolicyConfig", "isCacheControlRespected");
            }
            this.isCacheControlRespected = isCacheControlRespected;
            return this;
        }
        @CustomType.Setter
        public Builder isHttpsEnabled(Boolean isHttpsEnabled) {
            if (isHttpsEnabled == null) {
              throw new MissingRequiredPropertyException("GetWaasPolicyPolicyConfig", "isHttpsEnabled");
            }
            this.isHttpsEnabled = isHttpsEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder isHttpsForced(Boolean isHttpsForced) {
            if (isHttpsForced == null) {
              throw new MissingRequiredPropertyException("GetWaasPolicyPolicyConfig", "isHttpsForced");
            }
            this.isHttpsForced = isHttpsForced;
            return this;
        }
        @CustomType.Setter
        public Builder isOriginCompressionEnabled(Boolean isOriginCompressionEnabled) {
            if (isOriginCompressionEnabled == null) {
              throw new MissingRequiredPropertyException("GetWaasPolicyPolicyConfig", "isOriginCompressionEnabled");
            }
            this.isOriginCompressionEnabled = isOriginCompressionEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder isResponseBufferingEnabled(Boolean isResponseBufferingEnabled) {
            if (isResponseBufferingEnabled == null) {
              throw new MissingRequiredPropertyException("GetWaasPolicyPolicyConfig", "isResponseBufferingEnabled");
            }
            this.isResponseBufferingEnabled = isResponseBufferingEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder isSniEnabled(Boolean isSniEnabled) {
            if (isSniEnabled == null) {
              throw new MissingRequiredPropertyException("GetWaasPolicyPolicyConfig", "isSniEnabled");
            }
            this.isSniEnabled = isSniEnabled;
            return this;
        }
        @CustomType.Setter
        public Builder loadBalancingMethod(GetWaasPolicyPolicyConfigLoadBalancingMethod loadBalancingMethod) {
            if (loadBalancingMethod == null) {
              throw new MissingRequiredPropertyException("GetWaasPolicyPolicyConfig", "loadBalancingMethod");
            }
            this.loadBalancingMethod = loadBalancingMethod;
            return this;
        }
        @CustomType.Setter
        public Builder tlsProtocols(List<String> tlsProtocols) {
            if (tlsProtocols == null) {
              throw new MissingRequiredPropertyException("GetWaasPolicyPolicyConfig", "tlsProtocols");
            }
            this.tlsProtocols = tlsProtocols;
            return this;
        }
        public Builder tlsProtocols(String... tlsProtocols) {
            return tlsProtocols(List.of(tlsProtocols));
        }
        @CustomType.Setter
        public Builder websocketPathPrefixes(List<String> websocketPathPrefixes) {
            if (websocketPathPrefixes == null) {
              throw new MissingRequiredPropertyException("GetWaasPolicyPolicyConfig", "websocketPathPrefixes");
            }
            this.websocketPathPrefixes = websocketPathPrefixes;
            return this;
        }
        public Builder websocketPathPrefixes(String... websocketPathPrefixes) {
            return websocketPathPrefixes(List.of(websocketPathPrefixes));
        }
        public GetWaasPolicyPolicyConfig build() {
            final var _resultValue = new GetWaasPolicyPolicyConfig();
            _resultValue.certificateId = certificateId;
            _resultValue.cipherGroup = cipherGroup;
            _resultValue.clientAddressHeader = clientAddressHeader;
            _resultValue.healthChecks = healthChecks;
            _resultValue.isBehindCdn = isBehindCdn;
            _resultValue.isCacheControlRespected = isCacheControlRespected;
            _resultValue.isHttpsEnabled = isHttpsEnabled;
            _resultValue.isHttpsForced = isHttpsForced;
            _resultValue.isOriginCompressionEnabled = isOriginCompressionEnabled;
            _resultValue.isResponseBufferingEnabled = isResponseBufferingEnabled;
            _resultValue.isSniEnabled = isSniEnabled;
            _resultValue.loadBalancingMethod = loadBalancingMethod;
            _resultValue.tlsProtocols = tlsProtocols;
            _resultValue.websocketPathPrefixes = websocketPathPrefixes;
            return _resultValue;
        }
    }
}
