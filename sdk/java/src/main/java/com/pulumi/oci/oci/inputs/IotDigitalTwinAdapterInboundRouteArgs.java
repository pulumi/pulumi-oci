// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.oci.oci.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.oci.oci.inputs.IotDigitalTwinAdapterInboundRouteReferencePayloadArgs;
import java.lang.String;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class IotDigitalTwinAdapterInboundRouteArgs extends com.pulumi.resources.ResourceArgs {

    public static final IotDigitalTwinAdapterInboundRouteArgs Empty = new IotDigitalTwinAdapterInboundRouteArgs();

    /**
     * (Updatable) A boolean expression used to determine whether the following transformation should be processed for the incoming payload. This expression is typically based on fields defined at the inbound Envelope and is evaluated before applying the `payloadMapping`.
     * 
     */
    @Import(name="condition", required=true)
    private Output<String> condition;

    /**
     * @return (Updatable) A boolean expression used to determine whether the following transformation should be processed for the incoming payload. This expression is typically based on fields defined at the inbound Envelope and is evaluated before applying the `payloadMapping`.
     * 
     */
    public Output<String> condition() {
        return this.condition;
    }

    /**
     * (Updatable) Meaningful write up about the inbound route.
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    /**
     * @return (Updatable) Meaningful write up about the inbound route.
     * 
     */
    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * (Updatable) A set of key-value JQ expressions used to transform the incoming payload into a shape compatible with the digital twin model&#39;s context or schema.
     * 
     * The keys are target fields (in the digital twin model), and values are JQ expressions pointing to data in the reference payload.
     * 
     * Example: Given payload: { &#34;time&#34;: &#34;&lt;timestamp&gt;&#34;, &#34;temp&#34;: 65, &#34;hum&#34;: 55 } And mapping: { &#34;temperature&#34;: &#34;$.temp&#34;, &#34;humidity&#34;: &#34;$.hum&#34;, &#34;timeObserved&#34;: &#34;$.time&#34; } The output will be: { &#34;temperature&#34;: 65, &#34;humidity&#34;: 55, &#34;timeObserved&#34;: &#34;&lt;timestamp&gt;&#34; }
     * 
     */
    @Import(name="payloadMapping")
    private @Nullable Output<Map<String,String>> payloadMapping;

    /**
     * @return (Updatable) A set of key-value JQ expressions used to transform the incoming payload into a shape compatible with the digital twin model&#39;s context or schema.
     * 
     * The keys are target fields (in the digital twin model), and values are JQ expressions pointing to data in the reference payload.
     * 
     * Example: Given payload: { &#34;time&#34;: &#34;&lt;timestamp&gt;&#34;, &#34;temp&#34;: 65, &#34;hum&#34;: 55 } And mapping: { &#34;temperature&#34;: &#34;$.temp&#34;, &#34;humidity&#34;: &#34;$.hum&#34;, &#34;timeObserved&#34;: &#34;$.time&#34; } The output will be: { &#34;temperature&#34;: 65, &#34;humidity&#34;: 55, &#34;timeObserved&#34;: &#34;&lt;timestamp&gt;&#34; }
     * 
     */
    public Optional<Output<Map<String,String>>> payloadMapping() {
        return Optional.ofNullable(this.payloadMapping);
    }

    /**
     * (Updatable) Reference payload structure template received from IoT device. This payload must specify its content type using the `dataFormat` property.
     * 
     */
    @Import(name="referencePayload")
    private @Nullable Output<IotDigitalTwinAdapterInboundRouteReferencePayloadArgs> referencePayload;

    /**
     * @return (Updatable) Reference payload structure template received from IoT device. This payload must specify its content type using the `dataFormat` property.
     * 
     */
    public Optional<Output<IotDigitalTwinAdapterInboundRouteReferencePayloadArgs>> referencePayload() {
        return Optional.ofNullable(this.referencePayload);
    }

    private IotDigitalTwinAdapterInboundRouteArgs() {}

    private IotDigitalTwinAdapterInboundRouteArgs(IotDigitalTwinAdapterInboundRouteArgs $) {
        this.condition = $.condition;
        this.description = $.description;
        this.payloadMapping = $.payloadMapping;
        this.referencePayload = $.referencePayload;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(IotDigitalTwinAdapterInboundRouteArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private IotDigitalTwinAdapterInboundRouteArgs $;

        public Builder() {
            $ = new IotDigitalTwinAdapterInboundRouteArgs();
        }

        public Builder(IotDigitalTwinAdapterInboundRouteArgs defaults) {
            $ = new IotDigitalTwinAdapterInboundRouteArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param condition (Updatable) A boolean expression used to determine whether the following transformation should be processed for the incoming payload. This expression is typically based on fields defined at the inbound Envelope and is evaluated before applying the `payloadMapping`.
         * 
         * @return builder
         * 
         */
        public Builder condition(Output<String> condition) {
            $.condition = condition;
            return this;
        }

        /**
         * @param condition (Updatable) A boolean expression used to determine whether the following transformation should be processed for the incoming payload. This expression is typically based on fields defined at the inbound Envelope and is evaluated before applying the `payloadMapping`.
         * 
         * @return builder
         * 
         */
        public Builder condition(String condition) {
            return condition(Output.of(condition));
        }

        /**
         * @param description (Updatable) Meaningful write up about the inbound route.
         * 
         * @return builder
         * 
         */
        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        /**
         * @param description (Updatable) Meaningful write up about the inbound route.
         * 
         * @return builder
         * 
         */
        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param payloadMapping (Updatable) A set of key-value JQ expressions used to transform the incoming payload into a shape compatible with the digital twin model&#39;s context or schema.
         * 
         * The keys are target fields (in the digital twin model), and values are JQ expressions pointing to data in the reference payload.
         * 
         * Example: Given payload: { &#34;time&#34;: &#34;&lt;timestamp&gt;&#34;, &#34;temp&#34;: 65, &#34;hum&#34;: 55 } And mapping: { &#34;temperature&#34;: &#34;$.temp&#34;, &#34;humidity&#34;: &#34;$.hum&#34;, &#34;timeObserved&#34;: &#34;$.time&#34; } The output will be: { &#34;temperature&#34;: 65, &#34;humidity&#34;: 55, &#34;timeObserved&#34;: &#34;&lt;timestamp&gt;&#34; }
         * 
         * @return builder
         * 
         */
        public Builder payloadMapping(@Nullable Output<Map<String,String>> payloadMapping) {
            $.payloadMapping = payloadMapping;
            return this;
        }

        /**
         * @param payloadMapping (Updatable) A set of key-value JQ expressions used to transform the incoming payload into a shape compatible with the digital twin model&#39;s context or schema.
         * 
         * The keys are target fields (in the digital twin model), and values are JQ expressions pointing to data in the reference payload.
         * 
         * Example: Given payload: { &#34;time&#34;: &#34;&lt;timestamp&gt;&#34;, &#34;temp&#34;: 65, &#34;hum&#34;: 55 } And mapping: { &#34;temperature&#34;: &#34;$.temp&#34;, &#34;humidity&#34;: &#34;$.hum&#34;, &#34;timeObserved&#34;: &#34;$.time&#34; } The output will be: { &#34;temperature&#34;: 65, &#34;humidity&#34;: 55, &#34;timeObserved&#34;: &#34;&lt;timestamp&gt;&#34; }
         * 
         * @return builder
         * 
         */
        public Builder payloadMapping(Map<String,String> payloadMapping) {
            return payloadMapping(Output.of(payloadMapping));
        }

        /**
         * @param referencePayload (Updatable) Reference payload structure template received from IoT device. This payload must specify its content type using the `dataFormat` property.
         * 
         * @return builder
         * 
         */
        public Builder referencePayload(@Nullable Output<IotDigitalTwinAdapterInboundRouteReferencePayloadArgs> referencePayload) {
            $.referencePayload = referencePayload;
            return this;
        }

        /**
         * @param referencePayload (Updatable) Reference payload structure template received from IoT device. This payload must specify its content type using the `dataFormat` property.
         * 
         * @return builder
         * 
         */
        public Builder referencePayload(IotDigitalTwinAdapterInboundRouteReferencePayloadArgs referencePayload) {
            return referencePayload(Output.of(referencePayload));
        }

        public IotDigitalTwinAdapterInboundRouteArgs build() {
            if ($.condition == null) {
                throw new MissingRequiredPropertyException("IotDigitalTwinAdapterInboundRouteArgs", "condition");
            }
            return $;
        }
    }

}
