// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";
import * as utilities from "../utilities";

/**
 * This resource provides the Ip Sec Connection Tunnel Management resource in Oracle Cloud Infrastructure Core service.
 *
 * Updates the specified tunnel. This operation lets you change tunnel attributes such as the
 * routing type (BGP dynamic routing or static routing). Here are some important notes:
 *
 *     * If you change the tunnel's routing type or BGP session configuration, the tunnel will go
 *     down while it's reprovisioned.
 *     
 *     * If you want to switch the tunnel's `routing` from `STATIC` to `BGP`, make sure the tunnel's
 *     BGP session configuration attributes have been set (bgpSessionConfig).
 *     
 *     * If you want to switch the tunnel's `routing` from `BGP` to `STATIC`, make sure the
 *     IPSecConnection already has at least one valid CIDR
 *     static route.
 *
 * ** IMPORTANT **
 * Destroying the `oci.Core.IpsecConnectionTunnelManagement` leaves the resource in its existing state. It will not destroy the tunnel and it will not return the tunnel to its default values.
 *
 * ## Example Usage
 *
 * <!--Start PulumiCodeChooser -->
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as oci from "@pulumi/oci";
 *
 * const testIpSecConnectionTunnel = new oci.core.IpsecConnectionTunnelManagement("testIpSecConnectionTunnel", {
 *     ipsecId: oci_core_ipsec.test_ipsec.id,
 *     tunnelId: data.oci_core_ipsec_connection_tunnels.test_ip_sec_connection_tunnels.ip_sec_connection_tunnels[0].id,
 *     routing: _var.ip_sec_connection_tunnel_management_routing,
 *     bgpSessionInfos: [{
 *         customerBgpAsn: _var.ip_sec_connection_tunnel_management_bgp_session_info_customer_bgp_asn,
 *         customerInterfaceIp: _var.ip_sec_connection_tunnel_management_bgp_session_info_customer_interface_ip,
 *         oracleInterfaceIp: _var.ip_sec_connection_tunnel_management_bgp_session_info_oracle_interface_ip,
 *     }],
 *     displayName: _var.ip_sec_connection_tunnel_management_display_name,
 *     encryptionDomainConfig: {
 *         cpeTrafficSelectors: _var.ip_sec_connection_tunnel_management_encryption_domain_config_cpe_traffic_selector,
 *         oracleTrafficSelectors: _var.ip_sec_connection_tunnel_management_encryption_domain_config_oracle_traffic_selector,
 *     },
 *     sharedSecret: _var.ip_sec_connection_tunnel_management_shared_secret,
 *     ikeVersion: "V1",
 * });
 * ```
 * <!--End PulumiCodeChooser -->
 */
export class IpsecConnectionTunnelManagement extends pulumi.CustomResource {
    /**
     * Get an existing IpsecConnectionTunnelManagement resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: IpsecConnectionTunnelManagementState, opts?: pulumi.CustomResourceOptions): IpsecConnectionTunnelManagement {
        return new IpsecConnectionTunnelManagement(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'oci:Core/ipsecConnectionTunnelManagement:IpsecConnectionTunnelManagement';

    /**
     * Returns true if the given object is an instance of IpsecConnectionTunnelManagement.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is IpsecConnectionTunnelManagement {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === IpsecConnectionTunnelManagement.__pulumiType;
    }

    /**
     * The list of virtual circuit [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)s over which your network can reach this tunnel.
     */
    public /*out*/ readonly associatedVirtualCircuits!: pulumi.Output<string[]>;
    /**
     * Information for establishing a BGP session for the IPSec tunnel. Required if the tunnel uses BGP dynamic routing.
     *
     * If the tunnel instead uses static routing, you may optionally provide this object and set an IP address for one or both ends of the IPSec tunnel for the purposes of troubleshooting or monitoring the tunnel.
     */
    public readonly bgpSessionInfos!: pulumi.Output<outputs.Core.IpsecConnectionTunnelManagementBgpSessionInfo[]>;
    /**
     * The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment containing the tunnel.
     */
    public /*out*/ readonly compartmentId!: pulumi.Output<string>;
    /**
     * The IP address of the CPE device's VPN headend.  Example: `203.0.113.22`
     */
    public /*out*/ readonly cpeIp!: pulumi.Output<string>;
    /**
     * A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
     */
    public readonly displayName!: pulumi.Output<string>;
    public readonly dpdConfigs!: pulumi.Output<outputs.Core.IpsecConnectionTunnelManagementDpdConfig[] | undefined>;
    /**
     * This option defines whether DPD can be initiated from the Oracle side of the connection. `INITIATE_AND_RESPOND` or `RESPOND_ONLY`
     */
    public /*out*/ readonly dpdMode!: pulumi.Output<string>;
    /**
     * DPD timeout in seconds. This sets the longest interval between CPE device health messages before the IPSec connection indicates it has lost contact with the CPE. The default is 20 seconds.
     */
    public /*out*/ readonly dpdTimeoutInSec!: pulumi.Output<number>;
    /**
     * Configuration information used by the encryption domain policy. Required if the tunnel uses POLICY routing.
     */
    public readonly encryptionDomainConfig!: pulumi.Output<outputs.Core.IpsecConnectionTunnelManagementEncryptionDomainConfig>;
    /**
     * Internet Key Exchange protocol version.
     */
    public readonly ikeVersion!: pulumi.Output<string>;
    /**
     * The OCID of the IPSec connection.
     */
    public readonly ipsecId!: pulumi.Output<string>;
    /**
     * By default (the `AUTO` setting), IKE sends packets with a source and destination port set to 500, and when it detects that the port used to forward packets has changed (most likely because a NAT device is between the CPE device and the Oracle VPN headend) it will try to negotiate the use of NAT-T.
     *
     * The `ENABLED` option sets the IKE protocol to use port 4500 instead of 500 and forces encapsulating traffic with the ESP protocol inside UDP packets.
     *
     * The `DISABLED` option directs IKE to completely refuse to negotiate NAT-T even if it senses there may be a NAT device in use.
     */
    public readonly natTranslationEnabled!: pulumi.Output<string>;
    /**
     * Indicates whether Oracle can only respond to a request to start an IPSec tunnel from the CPE device (`RESPONDER_ONLY`), or both respond to and initiate requests (`INITIATOR_OR_RESPONDER`).
     */
    public readonly oracleCanInitiate!: pulumi.Output<string>;
    /**
     * Configuration details for IKE phase one (ISAKMP) configuration parameters. 
     *
     * See [PhaseOneConfigDetails](https://docs.oracle.com/en-us/iaas/api/#/en/iaas/20160918/datatypes/PhaseOneConfigDetails) for allowed values but note naming scheme follows [TunnelPhaseOneDetails](https://docs.oracle.com/en-us/iaas/api/#/en/iaas/20160918/datatypes/TunnelPhaseOneDetails).
     */
    public readonly phaseOneDetails!: pulumi.Output<outputs.Core.IpsecConnectionTunnelManagementPhaseOneDetail[]>;
    /**
     * Configuration details for IPSec phase two configuration parameters.
     *
     * See [PhaseTwoConfigDetails](https://docs.oracle.com/en-us/iaas/api/#/en/iaas/20160918/datatypes/PhaseTwoConfigDetails) for allowed values, but note naming scheme follows [TunnelPhaseTwoDetails](https://docs.oracle.com/en-us/iaas/api/#/en/iaas/20160918/datatypes/TunnelPhaseTwoDetails).
     */
    public readonly phaseTwoDetails!: pulumi.Output<outputs.Core.IpsecConnectionTunnelManagementPhaseTwoDetail[]>;
    /**
     * The type of routing to use for this tunnel (either BGP dynamic routing, STATIC routing or POLICY routing).
     */
    public readonly routing!: pulumi.Output<string>;
    /**
     * The shared secret (pre-shared key) to use for the IPSec tunnel. If you don't provide a value, Oracle generates a value for you. You can specify your own shared secret later if you like with [UpdateIPSecConnectionTunnelSharedSecret](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/IPSecConnectionTunnelSharedSecret/UpdateIPSecConnectionTunnelSharedSecret).  Example: `EXAMPLEToUis6j1c.p8G.dVQxcmdfMO0yXMLi.lZTbYCMDGu4V8o`
     */
    public readonly sharedSecret!: pulumi.Output<string>;
    /**
     * The IPSec connection's tunnel's lifecycle state.
     */
    public /*out*/ readonly state!: pulumi.Output<string>;
    /**
     * The tunnel's current state.
     */
    public /*out*/ readonly status!: pulumi.Output<string>;
    /**
     * The date and time the IPSec connection tunnel was created, in the format defined by RFC3339.  Example: `2016-08-25T21:10:29.600Z`
     */
    public /*out*/ readonly timeCreated!: pulumi.Output<string>;
    /**
     * When the status of the tunnel last changed, in the format defined by RFC3339.  Example: `2016-08-25T21:10:29.600Z`
     */
    public /*out*/ readonly timeStatusUpdated!: pulumi.Output<string>;
    /**
     * The OCID of the IPSec connection's tunnel.
     */
    public readonly tunnelId!: pulumi.Output<string>;
    /**
     * The IP address of Oracle's VPN headend.  Example: `129.146.17.50`
     */
    public /*out*/ readonly vpnIp!: pulumi.Output<string>;

    /**
     * Create a IpsecConnectionTunnelManagement resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: IpsecConnectionTunnelManagementArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: IpsecConnectionTunnelManagementArgs | IpsecConnectionTunnelManagementState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as IpsecConnectionTunnelManagementState | undefined;
            resourceInputs["associatedVirtualCircuits"] = state ? state.associatedVirtualCircuits : undefined;
            resourceInputs["bgpSessionInfos"] = state ? state.bgpSessionInfos : undefined;
            resourceInputs["compartmentId"] = state ? state.compartmentId : undefined;
            resourceInputs["cpeIp"] = state ? state.cpeIp : undefined;
            resourceInputs["displayName"] = state ? state.displayName : undefined;
            resourceInputs["dpdConfigs"] = state ? state.dpdConfigs : undefined;
            resourceInputs["dpdMode"] = state ? state.dpdMode : undefined;
            resourceInputs["dpdTimeoutInSec"] = state ? state.dpdTimeoutInSec : undefined;
            resourceInputs["encryptionDomainConfig"] = state ? state.encryptionDomainConfig : undefined;
            resourceInputs["ikeVersion"] = state ? state.ikeVersion : undefined;
            resourceInputs["ipsecId"] = state ? state.ipsecId : undefined;
            resourceInputs["natTranslationEnabled"] = state ? state.natTranslationEnabled : undefined;
            resourceInputs["oracleCanInitiate"] = state ? state.oracleCanInitiate : undefined;
            resourceInputs["phaseOneDetails"] = state ? state.phaseOneDetails : undefined;
            resourceInputs["phaseTwoDetails"] = state ? state.phaseTwoDetails : undefined;
            resourceInputs["routing"] = state ? state.routing : undefined;
            resourceInputs["sharedSecret"] = state ? state.sharedSecret : undefined;
            resourceInputs["state"] = state ? state.state : undefined;
            resourceInputs["status"] = state ? state.status : undefined;
            resourceInputs["timeCreated"] = state ? state.timeCreated : undefined;
            resourceInputs["timeStatusUpdated"] = state ? state.timeStatusUpdated : undefined;
            resourceInputs["tunnelId"] = state ? state.tunnelId : undefined;
            resourceInputs["vpnIp"] = state ? state.vpnIp : undefined;
        } else {
            const args = argsOrState as IpsecConnectionTunnelManagementArgs | undefined;
            if ((!args || args.ipsecId === undefined) && !opts.urn) {
                throw new Error("Missing required property 'ipsecId'");
            }
            if ((!args || args.tunnelId === undefined) && !opts.urn) {
                throw new Error("Missing required property 'tunnelId'");
            }
            resourceInputs["bgpSessionInfos"] = args ? args.bgpSessionInfos : undefined;
            resourceInputs["displayName"] = args ? args.displayName : undefined;
            resourceInputs["dpdConfigs"] = args ? args.dpdConfigs : undefined;
            resourceInputs["encryptionDomainConfig"] = args ? args.encryptionDomainConfig : undefined;
            resourceInputs["ikeVersion"] = args ? args.ikeVersion : undefined;
            resourceInputs["ipsecId"] = args ? args.ipsecId : undefined;
            resourceInputs["natTranslationEnabled"] = args ? args.natTranslationEnabled : undefined;
            resourceInputs["oracleCanInitiate"] = args ? args.oracleCanInitiate : undefined;
            resourceInputs["phaseOneDetails"] = args ? args.phaseOneDetails : undefined;
            resourceInputs["phaseTwoDetails"] = args ? args.phaseTwoDetails : undefined;
            resourceInputs["routing"] = args ? args.routing : undefined;
            resourceInputs["sharedSecret"] = args?.sharedSecret ? pulumi.secret(args.sharedSecret) : undefined;
            resourceInputs["tunnelId"] = args ? args.tunnelId : undefined;
            resourceInputs["associatedVirtualCircuits"] = undefined /*out*/;
            resourceInputs["compartmentId"] = undefined /*out*/;
            resourceInputs["cpeIp"] = undefined /*out*/;
            resourceInputs["dpdMode"] = undefined /*out*/;
            resourceInputs["dpdTimeoutInSec"] = undefined /*out*/;
            resourceInputs["state"] = undefined /*out*/;
            resourceInputs["status"] = undefined /*out*/;
            resourceInputs["timeCreated"] = undefined /*out*/;
            resourceInputs["timeStatusUpdated"] = undefined /*out*/;
            resourceInputs["vpnIp"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        const secretOpts = { additionalSecretOutputs: ["sharedSecret"] };
        opts = pulumi.mergeOptions(opts, secretOpts);
        super(IpsecConnectionTunnelManagement.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering IpsecConnectionTunnelManagement resources.
 */
export interface IpsecConnectionTunnelManagementState {
    /**
     * The list of virtual circuit [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)s over which your network can reach this tunnel.
     */
    associatedVirtualCircuits?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Information for establishing a BGP session for the IPSec tunnel. Required if the tunnel uses BGP dynamic routing.
     *
     * If the tunnel instead uses static routing, you may optionally provide this object and set an IP address for one or both ends of the IPSec tunnel for the purposes of troubleshooting or monitoring the tunnel.
     */
    bgpSessionInfos?: pulumi.Input<pulumi.Input<inputs.Core.IpsecConnectionTunnelManagementBgpSessionInfo>[]>;
    /**
     * The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment containing the tunnel.
     */
    compartmentId?: pulumi.Input<string>;
    /**
     * The IP address of the CPE device's VPN headend.  Example: `203.0.113.22`
     */
    cpeIp?: pulumi.Input<string>;
    /**
     * A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
     */
    displayName?: pulumi.Input<string>;
    dpdConfigs?: pulumi.Input<pulumi.Input<inputs.Core.IpsecConnectionTunnelManagementDpdConfig>[]>;
    /**
     * This option defines whether DPD can be initiated from the Oracle side of the connection. `INITIATE_AND_RESPOND` or `RESPOND_ONLY`
     */
    dpdMode?: pulumi.Input<string>;
    /**
     * DPD timeout in seconds. This sets the longest interval between CPE device health messages before the IPSec connection indicates it has lost contact with the CPE. The default is 20 seconds.
     */
    dpdTimeoutInSec?: pulumi.Input<number>;
    /**
     * Configuration information used by the encryption domain policy. Required if the tunnel uses POLICY routing.
     */
    encryptionDomainConfig?: pulumi.Input<inputs.Core.IpsecConnectionTunnelManagementEncryptionDomainConfig>;
    /**
     * Internet Key Exchange protocol version.
     */
    ikeVersion?: pulumi.Input<string>;
    /**
     * The OCID of the IPSec connection.
     */
    ipsecId?: pulumi.Input<string>;
    /**
     * By default (the `AUTO` setting), IKE sends packets with a source and destination port set to 500, and when it detects that the port used to forward packets has changed (most likely because a NAT device is between the CPE device and the Oracle VPN headend) it will try to negotiate the use of NAT-T.
     *
     * The `ENABLED` option sets the IKE protocol to use port 4500 instead of 500 and forces encapsulating traffic with the ESP protocol inside UDP packets.
     *
     * The `DISABLED` option directs IKE to completely refuse to negotiate NAT-T even if it senses there may be a NAT device in use.
     */
    natTranslationEnabled?: pulumi.Input<string>;
    /**
     * Indicates whether Oracle can only respond to a request to start an IPSec tunnel from the CPE device (`RESPONDER_ONLY`), or both respond to and initiate requests (`INITIATOR_OR_RESPONDER`).
     */
    oracleCanInitiate?: pulumi.Input<string>;
    /**
     * Configuration details for IKE phase one (ISAKMP) configuration parameters. 
     *
     * See [PhaseOneConfigDetails](https://docs.oracle.com/en-us/iaas/api/#/en/iaas/20160918/datatypes/PhaseOneConfigDetails) for allowed values but note naming scheme follows [TunnelPhaseOneDetails](https://docs.oracle.com/en-us/iaas/api/#/en/iaas/20160918/datatypes/TunnelPhaseOneDetails).
     */
    phaseOneDetails?: pulumi.Input<pulumi.Input<inputs.Core.IpsecConnectionTunnelManagementPhaseOneDetail>[]>;
    /**
     * Configuration details for IPSec phase two configuration parameters.
     *
     * See [PhaseTwoConfigDetails](https://docs.oracle.com/en-us/iaas/api/#/en/iaas/20160918/datatypes/PhaseTwoConfigDetails) for allowed values, but note naming scheme follows [TunnelPhaseTwoDetails](https://docs.oracle.com/en-us/iaas/api/#/en/iaas/20160918/datatypes/TunnelPhaseTwoDetails).
     */
    phaseTwoDetails?: pulumi.Input<pulumi.Input<inputs.Core.IpsecConnectionTunnelManagementPhaseTwoDetail>[]>;
    /**
     * The type of routing to use for this tunnel (either BGP dynamic routing, STATIC routing or POLICY routing).
     */
    routing?: pulumi.Input<string>;
    /**
     * The shared secret (pre-shared key) to use for the IPSec tunnel. If you don't provide a value, Oracle generates a value for you. You can specify your own shared secret later if you like with [UpdateIPSecConnectionTunnelSharedSecret](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/IPSecConnectionTunnelSharedSecret/UpdateIPSecConnectionTunnelSharedSecret).  Example: `EXAMPLEToUis6j1c.p8G.dVQxcmdfMO0yXMLi.lZTbYCMDGu4V8o`
     */
    sharedSecret?: pulumi.Input<string>;
    /**
     * The IPSec connection's tunnel's lifecycle state.
     */
    state?: pulumi.Input<string>;
    /**
     * The tunnel's current state.
     */
    status?: pulumi.Input<string>;
    /**
     * The date and time the IPSec connection tunnel was created, in the format defined by RFC3339.  Example: `2016-08-25T21:10:29.600Z`
     */
    timeCreated?: pulumi.Input<string>;
    /**
     * When the status of the tunnel last changed, in the format defined by RFC3339.  Example: `2016-08-25T21:10:29.600Z`
     */
    timeStatusUpdated?: pulumi.Input<string>;
    /**
     * The OCID of the IPSec connection's tunnel.
     */
    tunnelId?: pulumi.Input<string>;
    /**
     * The IP address of Oracle's VPN headend.  Example: `129.146.17.50`
     */
    vpnIp?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a IpsecConnectionTunnelManagement resource.
 */
export interface IpsecConnectionTunnelManagementArgs {
    /**
     * Information for establishing a BGP session for the IPSec tunnel. Required if the tunnel uses BGP dynamic routing.
     *
     * If the tunnel instead uses static routing, you may optionally provide this object and set an IP address for one or both ends of the IPSec tunnel for the purposes of troubleshooting or monitoring the tunnel.
     */
    bgpSessionInfos?: pulumi.Input<pulumi.Input<inputs.Core.IpsecConnectionTunnelManagementBgpSessionInfo>[]>;
    /**
     * A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
     */
    displayName?: pulumi.Input<string>;
    dpdConfigs?: pulumi.Input<pulumi.Input<inputs.Core.IpsecConnectionTunnelManagementDpdConfig>[]>;
    /**
     * Configuration information used by the encryption domain policy. Required if the tunnel uses POLICY routing.
     */
    encryptionDomainConfig?: pulumi.Input<inputs.Core.IpsecConnectionTunnelManagementEncryptionDomainConfig>;
    /**
     * Internet Key Exchange protocol version.
     */
    ikeVersion?: pulumi.Input<string>;
    /**
     * The OCID of the IPSec connection.
     */
    ipsecId: pulumi.Input<string>;
    /**
     * By default (the `AUTO` setting), IKE sends packets with a source and destination port set to 500, and when it detects that the port used to forward packets has changed (most likely because a NAT device is between the CPE device and the Oracle VPN headend) it will try to negotiate the use of NAT-T.
     *
     * The `ENABLED` option sets the IKE protocol to use port 4500 instead of 500 and forces encapsulating traffic with the ESP protocol inside UDP packets.
     *
     * The `DISABLED` option directs IKE to completely refuse to negotiate NAT-T even if it senses there may be a NAT device in use.
     */
    natTranslationEnabled?: pulumi.Input<string>;
    /**
     * Indicates whether Oracle can only respond to a request to start an IPSec tunnel from the CPE device (`RESPONDER_ONLY`), or both respond to and initiate requests (`INITIATOR_OR_RESPONDER`).
     */
    oracleCanInitiate?: pulumi.Input<string>;
    /**
     * Configuration details for IKE phase one (ISAKMP) configuration parameters. 
     *
     * See [PhaseOneConfigDetails](https://docs.oracle.com/en-us/iaas/api/#/en/iaas/20160918/datatypes/PhaseOneConfigDetails) for allowed values but note naming scheme follows [TunnelPhaseOneDetails](https://docs.oracle.com/en-us/iaas/api/#/en/iaas/20160918/datatypes/TunnelPhaseOneDetails).
     */
    phaseOneDetails?: pulumi.Input<pulumi.Input<inputs.Core.IpsecConnectionTunnelManagementPhaseOneDetail>[]>;
    /**
     * Configuration details for IPSec phase two configuration parameters.
     *
     * See [PhaseTwoConfigDetails](https://docs.oracle.com/en-us/iaas/api/#/en/iaas/20160918/datatypes/PhaseTwoConfigDetails) for allowed values, but note naming scheme follows [TunnelPhaseTwoDetails](https://docs.oracle.com/en-us/iaas/api/#/en/iaas/20160918/datatypes/TunnelPhaseTwoDetails).
     */
    phaseTwoDetails?: pulumi.Input<pulumi.Input<inputs.Core.IpsecConnectionTunnelManagementPhaseTwoDetail>[]>;
    /**
     * The type of routing to use for this tunnel (either BGP dynamic routing, STATIC routing or POLICY routing).
     */
    routing?: pulumi.Input<string>;
    /**
     * The shared secret (pre-shared key) to use for the IPSec tunnel. If you don't provide a value, Oracle generates a value for you. You can specify your own shared secret later if you like with [UpdateIPSecConnectionTunnelSharedSecret](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/IPSecConnectionTunnelSharedSecret/UpdateIPSecConnectionTunnelSharedSecret).  Example: `EXAMPLEToUis6j1c.p8G.dVQxcmdfMO0yXMLi.lZTbYCMDGu4V8o`
     */
    sharedSecret?: pulumi.Input<string>;
    /**
     * The OCID of the IPSec connection's tunnel.
     */
    tunnelId: pulumi.Input<string>;
}
