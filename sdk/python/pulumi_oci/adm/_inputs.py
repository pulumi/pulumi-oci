# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'RemediationRecipeDetectConfigurationArgs',
    'RemediationRecipeDetectConfigurationArgsDict',
    'RemediationRecipeNetworkConfigurationArgs',
    'RemediationRecipeNetworkConfigurationArgsDict',
    'RemediationRecipeScmConfigurationArgs',
    'RemediationRecipeScmConfigurationArgsDict',
    'RemediationRecipeVerifyConfigurationArgs',
    'RemediationRecipeVerifyConfigurationArgsDict',
    'RemediationRunStageArgs',
    'RemediationRunStageArgsDict',
    'VulnerabilityAuditApplicationDependencyArgs',
    'VulnerabilityAuditApplicationDependencyArgsDict',
    'VulnerabilityAuditConfigurationArgs',
    'VulnerabilityAuditConfigurationArgsDict',
    'VulnerabilityAuditSourceArgs',
    'VulnerabilityAuditSourceArgsDict',
    'VulnerabilityAuditUsageDataArgs',
    'VulnerabilityAuditUsageDataArgsDict',
    'VulnerabilityAuditVulnerabilityArgs',
    'VulnerabilityAuditVulnerabilityArgsDict',
    'GetKnowledgebasesFilterArgs',
    'GetKnowledgebasesFilterArgsDict',
    'GetRemediationRecipesFilterArgs',
    'GetRemediationRecipesFilterArgsDict',
    'GetRemediationRunApplicationDependencyRecommendationsFilterArgs',
    'GetRemediationRunApplicationDependencyRecommendationsFilterArgsDict',
    'GetRemediationRunStagesFilterArgs',
    'GetRemediationRunStagesFilterArgsDict',
    'GetRemediationRunsFilterArgs',
    'GetRemediationRunsFilterArgsDict',
    'GetVulnerabilityAuditApplicationDependencyVulnerabilitiesFilterArgs',
    'GetVulnerabilityAuditApplicationDependencyVulnerabilitiesFilterArgsDict',
    'GetVulnerabilityAuditsFilterArgs',
    'GetVulnerabilityAuditsFilterArgsDict',
]

MYPY = False

if not MYPY:
    class RemediationRecipeDetectConfigurationArgsDict(TypedDict):
        exclusions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The list of dependencies to be ignored by the recommendation algorithm. The dependency pattern is matched against the 'group:artifact:version' or the purl of a dependency. An asterisk (*) at the end in the dependency pattern acts as a wildcard and matches zero or more characters.
        """
        max_permissible_cvss_v2score: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Updatable) The maximum Common Vulnerability Scoring System Version 2 (CVSS V2) score. A vulnerability with a CVSS V2 score below this value is not considered for remediation.
        """
        max_permissible_cvss_v3score: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Updatable) The maximum Common Vulnerability Scoring System Version 3 (CVSS V3) score. A vulnerability with a CVSS V3 score below this value is not considered for patching.
        """
        max_permissible_severity: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The maximum ADM Severity. A vulnerability with an severity below this value is not considered for remediation.
        """
        upgrade_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The upgrade policy for recommendations. The `Nearest` upgrade policy upgrades a dependency to the oldest version that meets both of the following criteria: it is newer than the current version and it is not affected by a vulnerability.
        """
elif False:
    RemediationRecipeDetectConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemediationRecipeDetectConfigurationArgs:
    def __init__(__self__, *,
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 max_permissible_cvss_v2score: Optional[pulumi.Input[_builtins.float]] = None,
                 max_permissible_cvss_v3score: Optional[pulumi.Input[_builtins.float]] = None,
                 max_permissible_severity: Optional[pulumi.Input[_builtins.str]] = None,
                 upgrade_policy: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclusions: (Updatable) The list of dependencies to be ignored by the recommendation algorithm. The dependency pattern is matched against the 'group:artifact:version' or the purl of a dependency. An asterisk (*) at the end in the dependency pattern acts as a wildcard and matches zero or more characters.
        :param pulumi.Input[_builtins.float] max_permissible_cvss_v2score: (Updatable) The maximum Common Vulnerability Scoring System Version 2 (CVSS V2) score. A vulnerability with a CVSS V2 score below this value is not considered for remediation.
        :param pulumi.Input[_builtins.float] max_permissible_cvss_v3score: (Updatable) The maximum Common Vulnerability Scoring System Version 3 (CVSS V3) score. A vulnerability with a CVSS V3 score below this value is not considered for patching.
        :param pulumi.Input[_builtins.str] max_permissible_severity: (Updatable) The maximum ADM Severity. A vulnerability with an severity below this value is not considered for remediation.
        :param pulumi.Input[_builtins.str] upgrade_policy: (Updatable) The upgrade policy for recommendations. The `Nearest` upgrade policy upgrades a dependency to the oldest version that meets both of the following criteria: it is newer than the current version and it is not affected by a vulnerability.
        """
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if max_permissible_cvss_v2score is not None:
            pulumi.set(__self__, "max_permissible_cvss_v2score", max_permissible_cvss_v2score)
        if max_permissible_cvss_v3score is not None:
            pulumi.set(__self__, "max_permissible_cvss_v3score", max_permissible_cvss_v3score)
        if max_permissible_severity is not None:
            pulumi.set(__self__, "max_permissible_severity", max_permissible_severity)
        if upgrade_policy is not None:
            pulumi.set(__self__, "upgrade_policy", upgrade_policy)

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The list of dependencies to be ignored by the recommendation algorithm. The dependency pattern is matched against the 'group:artifact:version' or the purl of a dependency. An asterisk (*) at the end in the dependency pattern acts as a wildcard and matches zero or more characters.
        """
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclusions", value)

    @_builtins.property
    @pulumi.getter(name="maxPermissibleCvssV2score")
    def max_permissible_cvss_v2score(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Updatable) The maximum Common Vulnerability Scoring System Version 2 (CVSS V2) score. A vulnerability with a CVSS V2 score below this value is not considered for remediation.
        """
        return pulumi.get(self, "max_permissible_cvss_v2score")

    @max_permissible_cvss_v2score.setter
    def max_permissible_cvss_v2score(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max_permissible_cvss_v2score", value)

    @_builtins.property
    @pulumi.getter(name="maxPermissibleCvssV3score")
    def max_permissible_cvss_v3score(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Updatable) The maximum Common Vulnerability Scoring System Version 3 (CVSS V3) score. A vulnerability with a CVSS V3 score below this value is not considered for patching.
        """
        return pulumi.get(self, "max_permissible_cvss_v3score")

    @max_permissible_cvss_v3score.setter
    def max_permissible_cvss_v3score(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max_permissible_cvss_v3score", value)

    @_builtins.property
    @pulumi.getter(name="maxPermissibleSeverity")
    def max_permissible_severity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The maximum ADM Severity. A vulnerability with an severity below this value is not considered for remediation.
        """
        return pulumi.get(self, "max_permissible_severity")

    @max_permissible_severity.setter
    def max_permissible_severity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_permissible_severity", value)

    @_builtins.property
    @pulumi.getter(name="upgradePolicy")
    def upgrade_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The upgrade policy for recommendations. The `Nearest` upgrade policy upgrades a dependency to the oldest version that meets both of the following criteria: it is newer than the current version and it is not affected by a vulnerability.
        """
        return pulumi.get(self, "upgrade_policy")

    @upgrade_policy.setter
    def upgrade_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "upgrade_policy", value)


if not MYPY:
    class RemediationRecipeNetworkConfigurationArgsDict(TypedDict):
        subnet_id: pulumi.Input[_builtins.str]
        """
        (Updatable) The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the subnet.
        """
        nsg_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The list of Oracle Cloud Identifiers ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) corresponding to Network Security Groups.
        """
elif False:
    RemediationRecipeNetworkConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemediationRecipeNetworkConfigurationArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[_builtins.str],
                 nsg_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] subnet_id: (Updatable) The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the subnet.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] nsg_ids: (Updatable) The list of Oracle Cloud Identifiers ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) corresponding to Network Security Groups.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        if nsg_ids is not None:
            pulumi.set(__self__, "nsg_ids", nsg_ids)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the subnet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The list of Oracle Cloud Identifiers ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) corresponding to Network Security Groups.
        """
        return pulumi.get(self, "nsg_ids")

    @nsg_ids.setter
    def nsg_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "nsg_ids", value)


if not MYPY:
    class RemediationRecipeScmConfigurationArgsDict(TypedDict):
        branch: pulumi.Input[_builtins.str]
        """
        (Updatable) The branch used by ADM to patch vulnerabilities.
        """
        is_automerge_enabled: pulumi.Input[_builtins.bool]
        """
        (Updatable) If true, the Pull Request (PR) will be merged after the verify stage completes successfully     If false, the PR with the proposed changes must be reviewed and manually merged.
        """
        scm_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The type of Source Code Management.
        """
        build_file_location: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The location of the build file relative to the root of the repository. Only Maven build files (POM) are currently supported. If this property is not specified, ADM will use the build file located at the root of the repository.
        """
        external_scm_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The type of External Source Code Management.
        """
        oci_code_repository_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Oracle Cloud Infrastructure DevOps repository.
        """
        pat_secret_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Private Access Token (PAT) Secret. The secret provides the credentials necessary to authenticate against the SCM.
        """
        repository_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The repository URL for the SCM. For Non-Enterprise GitHub the expected format is https://github.com/[owner]/[repoName] For Enterprise GitHub the expected format is http(s)://[hostname]/api/v3/repos/[owner]/[repoName] For GitLab the expected format is https://gitlab.com/[groupName]/[repoName]
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The username for the SCM (to perform operations such as cloning or pushing via HTTP).
        """
elif False:
    RemediationRecipeScmConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemediationRecipeScmConfigurationArgs:
    def __init__(__self__, *,
                 branch: pulumi.Input[_builtins.str],
                 is_automerge_enabled: pulumi.Input[_builtins.bool],
                 scm_type: pulumi.Input[_builtins.str],
                 build_file_location: Optional[pulumi.Input[_builtins.str]] = None,
                 external_scm_type: Optional[pulumi.Input[_builtins.str]] = None,
                 oci_code_repository_id: Optional[pulumi.Input[_builtins.str]] = None,
                 pat_secret_id: Optional[pulumi.Input[_builtins.str]] = None,
                 repository_url: Optional[pulumi.Input[_builtins.str]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] branch: (Updatable) The branch used by ADM to patch vulnerabilities.
        :param pulumi.Input[_builtins.bool] is_automerge_enabled: (Updatable) If true, the Pull Request (PR) will be merged after the verify stage completes successfully     If false, the PR with the proposed changes must be reviewed and manually merged.
        :param pulumi.Input[_builtins.str] scm_type: (Updatable) The type of Source Code Management.
        :param pulumi.Input[_builtins.str] build_file_location: (Updatable) The location of the build file relative to the root of the repository. Only Maven build files (POM) are currently supported. If this property is not specified, ADM will use the build file located at the root of the repository.
        :param pulumi.Input[_builtins.str] external_scm_type: (Updatable) The type of External Source Code Management.
        :param pulumi.Input[_builtins.str] oci_code_repository_id: (Updatable) The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Oracle Cloud Infrastructure DevOps repository.
        :param pulumi.Input[_builtins.str] pat_secret_id: (Updatable) The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Private Access Token (PAT) Secret. The secret provides the credentials necessary to authenticate against the SCM.
        :param pulumi.Input[_builtins.str] repository_url: (Updatable) The repository URL for the SCM. For Non-Enterprise GitHub the expected format is https://github.com/[owner]/[repoName] For Enterprise GitHub the expected format is http(s)://[hostname]/api/v3/repos/[owner]/[repoName] For GitLab the expected format is https://gitlab.com/[groupName]/[repoName]
        :param pulumi.Input[_builtins.str] username: (Updatable) The username for the SCM (to perform operations such as cloning or pushing via HTTP).
        """
        pulumi.set(__self__, "branch", branch)
        pulumi.set(__self__, "is_automerge_enabled", is_automerge_enabled)
        pulumi.set(__self__, "scm_type", scm_type)
        if build_file_location is not None:
            pulumi.set(__self__, "build_file_location", build_file_location)
        if external_scm_type is not None:
            pulumi.set(__self__, "external_scm_type", external_scm_type)
        if oci_code_repository_id is not None:
            pulumi.set(__self__, "oci_code_repository_id", oci_code_repository_id)
        if pat_secret_id is not None:
            pulumi.set(__self__, "pat_secret_id", pat_secret_id)
        if repository_url is not None:
            pulumi.set(__self__, "repository_url", repository_url)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The branch used by ADM to patch vulnerabilities.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "branch", value)

    @_builtins.property
    @pulumi.getter(name="isAutomergeEnabled")
    def is_automerge_enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        (Updatable) If true, the Pull Request (PR) will be merged after the verify stage completes successfully     If false, the PR with the proposed changes must be reviewed and manually merged.
        """
        return pulumi.get(self, "is_automerge_enabled")

    @is_automerge_enabled.setter
    def is_automerge_enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "is_automerge_enabled", value)

    @_builtins.property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The type of Source Code Management.
        """
        return pulumi.get(self, "scm_type")

    @scm_type.setter
    def scm_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "scm_type", value)

    @_builtins.property
    @pulumi.getter(name="buildFileLocation")
    def build_file_location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The location of the build file relative to the root of the repository. Only Maven build files (POM) are currently supported. If this property is not specified, ADM will use the build file located at the root of the repository.
        """
        return pulumi.get(self, "build_file_location")

    @build_file_location.setter
    def build_file_location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "build_file_location", value)

    @_builtins.property
    @pulumi.getter(name="externalScmType")
    def external_scm_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The type of External Source Code Management.
        """
        return pulumi.get(self, "external_scm_type")

    @external_scm_type.setter
    def external_scm_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_scm_type", value)

    @_builtins.property
    @pulumi.getter(name="ociCodeRepositoryId")
    def oci_code_repository_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Oracle Cloud Infrastructure DevOps repository.
        """
        return pulumi.get(self, "oci_code_repository_id")

    @oci_code_repository_id.setter
    def oci_code_repository_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oci_code_repository_id", value)

    @_builtins.property
    @pulumi.getter(name="patSecretId")
    def pat_secret_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Private Access Token (PAT) Secret. The secret provides the credentials necessary to authenticate against the SCM.
        """
        return pulumi.get(self, "pat_secret_id")

    @pat_secret_id.setter
    def pat_secret_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pat_secret_id", value)

    @_builtins.property
    @pulumi.getter(name="repositoryUrl")
    def repository_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The repository URL for the SCM. For Non-Enterprise GitHub the expected format is https://github.com/[owner]/[repoName] For Enterprise GitHub the expected format is http(s)://[hostname]/api/v3/repos/[owner]/[repoName] For GitLab the expected format is https://gitlab.com/[groupName]/[repoName]
        """
        return pulumi.get(self, "repository_url")

    @repository_url.setter
    def repository_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repository_url", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The username for the SCM (to perform operations such as cloning or pushing via HTTP).
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class RemediationRecipeVerifyConfigurationArgsDict(TypedDict):
        build_service_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The type of Build Service.
        """
        additional_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        (Updatable) Additional key-value pairs passed as parameters to the build service when running an experiment.
        """
        jenkins_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The URL that locates the Jenkins pipeline.
        """
        job_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the Jenkins pipeline job that identifies the build pipeline.
        """
        pat_secret_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Private Access Token (PAT) Secret. The PAT provides the credentials to access the Jenkins Pipeline.
        """
        pipeline_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the user's DevOps Build Pipeline.
        """
        repository_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The location of the repository where the GitHub Actions is defined. For Non-Enterprise GitHub the expected format is https://github.com/[owner]/[repoName] For Enterprise GitHub the expected format is http(s)://[hostname]/api/v3/repos/[owner]/[repoName]
        """
        trigger_secret_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the trigger Secret. The Secret provides access to the trigger for a GitLab pipeline.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The username that will be used to authenticate with Jenkins.
        """
        workflow_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the GitHub Actions workflow that defines the build pipeline.
        """
elif False:
    RemediationRecipeVerifyConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemediationRecipeVerifyConfigurationArgs:
    def __init__(__self__, *,
                 build_service_type: pulumi.Input[_builtins.str],
                 additional_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 jenkins_url: Optional[pulumi.Input[_builtins.str]] = None,
                 job_name: Optional[pulumi.Input[_builtins.str]] = None,
                 pat_secret_id: Optional[pulumi.Input[_builtins.str]] = None,
                 pipeline_id: Optional[pulumi.Input[_builtins.str]] = None,
                 repository_url: Optional[pulumi.Input[_builtins.str]] = None,
                 trigger_secret_id: Optional[pulumi.Input[_builtins.str]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None,
                 workflow_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] build_service_type: (Updatable) The type of Build Service.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] additional_parameters: (Updatable) Additional key-value pairs passed as parameters to the build service when running an experiment.
        :param pulumi.Input[_builtins.str] jenkins_url: (Updatable) The URL that locates the Jenkins pipeline.
        :param pulumi.Input[_builtins.str] job_name: (Updatable) The name of the Jenkins pipeline job that identifies the build pipeline.
        :param pulumi.Input[_builtins.str] pat_secret_id: (Updatable) The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Private Access Token (PAT) Secret. The PAT provides the credentials to access the Jenkins Pipeline.
        :param pulumi.Input[_builtins.str] pipeline_id: (Updatable) The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the user's DevOps Build Pipeline.
        :param pulumi.Input[_builtins.str] repository_url: (Updatable) The location of the repository where the GitHub Actions is defined. For Non-Enterprise GitHub the expected format is https://github.com/[owner]/[repoName] For Enterprise GitHub the expected format is http(s)://[hostname]/api/v3/repos/[owner]/[repoName]
        :param pulumi.Input[_builtins.str] trigger_secret_id: (Updatable) The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the trigger Secret. The Secret provides access to the trigger for a GitLab pipeline.
        :param pulumi.Input[_builtins.str] username: (Updatable) The username that will be used to authenticate with Jenkins.
        :param pulumi.Input[_builtins.str] workflow_name: (Updatable) The name of the GitHub Actions workflow that defines the build pipeline.
        """
        pulumi.set(__self__, "build_service_type", build_service_type)
        if additional_parameters is not None:
            pulumi.set(__self__, "additional_parameters", additional_parameters)
        if jenkins_url is not None:
            pulumi.set(__self__, "jenkins_url", jenkins_url)
        if job_name is not None:
            pulumi.set(__self__, "job_name", job_name)
        if pat_secret_id is not None:
            pulumi.set(__self__, "pat_secret_id", pat_secret_id)
        if pipeline_id is not None:
            pulumi.set(__self__, "pipeline_id", pipeline_id)
        if repository_url is not None:
            pulumi.set(__self__, "repository_url", repository_url)
        if trigger_secret_id is not None:
            pulumi.set(__self__, "trigger_secret_id", trigger_secret_id)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if workflow_name is not None:
            pulumi.set(__self__, "workflow_name", workflow_name)

    @_builtins.property
    @pulumi.getter(name="buildServiceType")
    def build_service_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The type of Build Service.
        """
        return pulumi.get(self, "build_service_type")

    @build_service_type.setter
    def build_service_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "build_service_type", value)

    @_builtins.property
    @pulumi.getter(name="additionalParameters")
    def additional_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) Additional key-value pairs passed as parameters to the build service when running an experiment.
        """
        return pulumi.get(self, "additional_parameters")

    @additional_parameters.setter
    def additional_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "additional_parameters", value)

    @_builtins.property
    @pulumi.getter(name="jenkinsUrl")
    def jenkins_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The URL that locates the Jenkins pipeline.
        """
        return pulumi.get(self, "jenkins_url")

    @jenkins_url.setter
    def jenkins_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "jenkins_url", value)

    @_builtins.property
    @pulumi.getter(name="jobName")
    def job_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the Jenkins pipeline job that identifies the build pipeline.
        """
        return pulumi.get(self, "job_name")

    @job_name.setter
    def job_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "job_name", value)

    @_builtins.property
    @pulumi.getter(name="patSecretId")
    def pat_secret_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Private Access Token (PAT) Secret. The PAT provides the credentials to access the Jenkins Pipeline.
        """
        return pulumi.get(self, "pat_secret_id")

    @pat_secret_id.setter
    def pat_secret_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pat_secret_id", value)

    @_builtins.property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the user's DevOps Build Pipeline.
        """
        return pulumi.get(self, "pipeline_id")

    @pipeline_id.setter
    def pipeline_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pipeline_id", value)

    @_builtins.property
    @pulumi.getter(name="repositoryUrl")
    def repository_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The location of the repository where the GitHub Actions is defined. For Non-Enterprise GitHub the expected format is https://github.com/[owner]/[repoName] For Enterprise GitHub the expected format is http(s)://[hostname]/api/v3/repos/[owner]/[repoName]
        """
        return pulumi.get(self, "repository_url")

    @repository_url.setter
    def repository_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repository_url", value)

    @_builtins.property
    @pulumi.getter(name="triggerSecretId")
    def trigger_secret_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the trigger Secret. The Secret provides access to the trigger for a GitLab pipeline.
        """
        return pulumi.get(self, "trigger_secret_id")

    @trigger_secret_id.setter
    def trigger_secret_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trigger_secret_id", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The username that will be used to authenticate with Jenkins.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)

    @_builtins.property
    @pulumi.getter(name="workflowName")
    def workflow_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the GitHub Actions workflow that defines the build pipeline.
        """
        return pulumi.get(self, "workflow_name")

    @workflow_name.setter
    def workflow_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "workflow_name", value)


if not MYPY:
    class RemediationRunStageArgsDict(TypedDict):
        summary: NotRequired[pulumi.Input[_builtins.str]]
        """
        Information about the current step within the given stage.
        """
        time_created: NotRequired[pulumi.Input[_builtins.str]]
        """
        The creation date and time of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        """
        time_finished: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time of the finish of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        """
        time_started: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time of the start of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of stage.
        """
elif False:
    RemediationRunStageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemediationRunStageArgs:
    def __init__(__self__, *,
                 summary: Optional[pulumi.Input[_builtins.str]] = None,
                 time_created: Optional[pulumi.Input[_builtins.str]] = None,
                 time_finished: Optional[pulumi.Input[_builtins.str]] = None,
                 time_started: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] summary: Information about the current step within the given stage.
        :param pulumi.Input[_builtins.str] time_created: The creation date and time of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        :param pulumi.Input[_builtins.str] time_finished: The date and time of the finish of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        :param pulumi.Input[_builtins.str] time_started: The date and time of the start of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        :param pulumi.Input[_builtins.str] type: The type of stage.
        """
        if summary is not None:
            pulumi.set(__self__, "summary", summary)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_finished is not None:
            pulumi.set(__self__, "time_finished", time_finished)
        if time_started is not None:
            pulumi.set(__self__, "time_started", time_started)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def summary(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Information about the current step within the given stage.
        """
        return pulumi.get(self, "summary")

    @summary.setter
    def summary(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "summary", value)

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The creation date and time of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_created", value)

    @_builtins.property
    @pulumi.getter(name="timeFinished")
    def time_finished(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time of the finish of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        """
        return pulumi.get(self, "time_finished")

    @time_finished.setter
    def time_finished(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_finished", value)

    @_builtins.property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time of the start of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        """
        return pulumi.get(self, "time_started")

    @time_started.setter
    def time_started(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_started", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of stage.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class VulnerabilityAuditApplicationDependencyArgsDict(TypedDict):
        node_id: pulumi.Input[_builtins.str]
        """
        Unique identifier of an application dependency, for example nodeId1. The nodeId can be generated by assigning a unique id to each application dependency in the tree of application dependencies. Every node, even those who share the same GAV, should have a different nodeId. The preferred way of constructing a nodeId is to assign incremental integers during a breadth first or depth first search. A nodeId can be reused only it refers to the same subtree of application dependencies. (This is not equivalent to referring to the same GAV, that is, a GAV can have multiple transitive dependencies.)
        """
        application_dependency_node_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of application dependencies on which this application dependency depends, each identified by its nodeId.
        """
        gav: NotRequired[pulumi.Input[_builtins.str]]
        """
        Group Artifact Version (GAV) identifier (Group:Artifact:Version). Example: org.graalvm.nativeimage:svm:21.1.0. "N/A" for non-maven artifacts.
        """
        purl: NotRequired[pulumi.Input[_builtins.str]]
        """
        Package URL identifier, e.g. pkg:maven/org.graalvm.nativeimage/svm@21.1.0
        """
elif False:
    VulnerabilityAuditApplicationDependencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityAuditApplicationDependencyArgs:
    def __init__(__self__, *,
                 node_id: pulumi.Input[_builtins.str],
                 application_dependency_node_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 gav: Optional[pulumi.Input[_builtins.str]] = None,
                 purl: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] node_id: Unique identifier of an application dependency, for example nodeId1. The nodeId can be generated by assigning a unique id to each application dependency in the tree of application dependencies. Every node, even those who share the same GAV, should have a different nodeId. The preferred way of constructing a nodeId is to assign incremental integers during a breadth first or depth first search. A nodeId can be reused only it refers to the same subtree of application dependencies. (This is not equivalent to referring to the same GAV, that is, a GAV can have multiple transitive dependencies.)
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] application_dependency_node_ids: List of application dependencies on which this application dependency depends, each identified by its nodeId.
        :param pulumi.Input[_builtins.str] gav: Group Artifact Version (GAV) identifier (Group:Artifact:Version). Example: org.graalvm.nativeimage:svm:21.1.0. "N/A" for non-maven artifacts.
        :param pulumi.Input[_builtins.str] purl: Package URL identifier, e.g. pkg:maven/org.graalvm.nativeimage/svm@21.1.0
        """
        pulumi.set(__self__, "node_id", node_id)
        if application_dependency_node_ids is not None:
            pulumi.set(__self__, "application_dependency_node_ids", application_dependency_node_ids)
        if gav is not None:
            pulumi.set(__self__, "gav", gav)
        if purl is not None:
            pulumi.set(__self__, "purl", purl)

    @_builtins.property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> pulumi.Input[_builtins.str]:
        """
        Unique identifier of an application dependency, for example nodeId1. The nodeId can be generated by assigning a unique id to each application dependency in the tree of application dependencies. Every node, even those who share the same GAV, should have a different nodeId. The preferred way of constructing a nodeId is to assign incremental integers during a breadth first or depth first search. A nodeId can be reused only it refers to the same subtree of application dependencies. (This is not equivalent to referring to the same GAV, that is, a GAV can have multiple transitive dependencies.)
        """
        return pulumi.get(self, "node_id")

    @node_id.setter
    def node_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "node_id", value)

    @_builtins.property
    @pulumi.getter(name="applicationDependencyNodeIds")
    def application_dependency_node_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of application dependencies on which this application dependency depends, each identified by its nodeId.
        """
        return pulumi.get(self, "application_dependency_node_ids")

    @application_dependency_node_ids.setter
    def application_dependency_node_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "application_dependency_node_ids", value)

    @_builtins.property
    @pulumi.getter
    def gav(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Group Artifact Version (GAV) identifier (Group:Artifact:Version). Example: org.graalvm.nativeimage:svm:21.1.0. "N/A" for non-maven artifacts.
        """
        return pulumi.get(self, "gav")

    @gav.setter
    def gav(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gav", value)

    @_builtins.property
    @pulumi.getter
    def purl(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Package URL identifier, e.g. pkg:maven/org.graalvm.nativeimage/svm@21.1.0
        """
        return pulumi.get(self, "purl")

    @purl.setter
    def purl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "purl", value)


if not MYPY:
    class VulnerabilityAuditConfigurationArgsDict(TypedDict):
        exclusions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A vulnerable application dependency is ignored if its name matches any of the items in `exclusions`. An asterisk (*) in the dependency pattern acts as a wildcard and matches zero or more characters.
        """
        max_permissible_cvss_v2score: NotRequired[pulumi.Input[_builtins.float]]
        """
        A vulnerable application dependency is ignored if the score of its associated Vulnerability is below maxPermissibleCvssV2Score and below maxPermissibleCvssV3Score.
        """
        max_permissible_cvss_v3score: NotRequired[pulumi.Input[_builtins.float]]
        """
        A vulnerable application dependency is ignored if the score of its associated Vulnerability is below maxPermissibleCvssV2Score and below maxPermissibleCvssV3Score.
        """
        max_permissible_severity: NotRequired[pulumi.Input[_builtins.str]]
        """
        A vulnerable application dependency is ignored if the score of its associated Vulnerability is below maxPermissibleSeverity.
        """
elif False:
    VulnerabilityAuditConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityAuditConfigurationArgs:
    def __init__(__self__, *,
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 max_permissible_cvss_v2score: Optional[pulumi.Input[_builtins.float]] = None,
                 max_permissible_cvss_v3score: Optional[pulumi.Input[_builtins.float]] = None,
                 max_permissible_severity: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclusions: A vulnerable application dependency is ignored if its name matches any of the items in `exclusions`. An asterisk (*) in the dependency pattern acts as a wildcard and matches zero or more characters.
        :param pulumi.Input[_builtins.float] max_permissible_cvss_v2score: A vulnerable application dependency is ignored if the score of its associated Vulnerability is below maxPermissibleCvssV2Score and below maxPermissibleCvssV3Score.
        :param pulumi.Input[_builtins.float] max_permissible_cvss_v3score: A vulnerable application dependency is ignored if the score of its associated Vulnerability is below maxPermissibleCvssV2Score and below maxPermissibleCvssV3Score.
        :param pulumi.Input[_builtins.str] max_permissible_severity: A vulnerable application dependency is ignored if the score of its associated Vulnerability is below maxPermissibleSeverity.
        """
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if max_permissible_cvss_v2score is not None:
            pulumi.set(__self__, "max_permissible_cvss_v2score", max_permissible_cvss_v2score)
        if max_permissible_cvss_v3score is not None:
            pulumi.set(__self__, "max_permissible_cvss_v3score", max_permissible_cvss_v3score)
        if max_permissible_severity is not None:
            pulumi.set(__self__, "max_permissible_severity", max_permissible_severity)

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A vulnerable application dependency is ignored if its name matches any of the items in `exclusions`. An asterisk (*) in the dependency pattern acts as a wildcard and matches zero or more characters.
        """
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclusions", value)

    @_builtins.property
    @pulumi.getter(name="maxPermissibleCvssV2score")
    def max_permissible_cvss_v2score(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        A vulnerable application dependency is ignored if the score of its associated Vulnerability is below maxPermissibleCvssV2Score and below maxPermissibleCvssV3Score.
        """
        return pulumi.get(self, "max_permissible_cvss_v2score")

    @max_permissible_cvss_v2score.setter
    def max_permissible_cvss_v2score(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max_permissible_cvss_v2score", value)

    @_builtins.property
    @pulumi.getter(name="maxPermissibleCvssV3score")
    def max_permissible_cvss_v3score(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        A vulnerable application dependency is ignored if the score of its associated Vulnerability is below maxPermissibleCvssV2Score and below maxPermissibleCvssV3Score.
        """
        return pulumi.get(self, "max_permissible_cvss_v3score")

    @max_permissible_cvss_v3score.setter
    def max_permissible_cvss_v3score(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max_permissible_cvss_v3score", value)

    @_builtins.property
    @pulumi.getter(name="maxPermissibleSeverity")
    def max_permissible_severity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A vulnerable application dependency is ignored if the score of its associated Vulnerability is below maxPermissibleSeverity.
        """
        return pulumi.get(self, "max_permissible_severity")

    @max_permissible_severity.setter
    def max_permissible_severity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_permissible_severity", value)


if not MYPY:
    class VulnerabilityAuditSourceArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Source type of the vulnerability audit.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the external resource source.
        """
        oci_resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Oracle Cloud identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Oracle Cloud Infrastructure resource that triggered the vulnerability audit.
        """
elif False:
    VulnerabilityAuditSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityAuditSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 oci_resource_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Source type of the vulnerability audit.
        :param pulumi.Input[_builtins.str] description: Description of the external resource source.
        :param pulumi.Input[_builtins.str] oci_resource_id: The Oracle Cloud identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Oracle Cloud Infrastructure resource that triggered the vulnerability audit.
        """
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if oci_resource_id is not None:
            pulumi.set(__self__, "oci_resource_id", oci_resource_id)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Source type of the vulnerability audit.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the external resource source.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="ociResourceId")
    def oci_resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Oracle Cloud identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Oracle Cloud Infrastructure resource that triggered the vulnerability audit.
        """
        return pulumi.get(self, "oci_resource_id")

    @oci_resource_id.setter
    def oci_resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oci_resource_id", value)


if not MYPY:
    class VulnerabilityAuditUsageDataArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        """
        The Object Storage bucket to read the usage data from.
        """
        namespace: pulumi.Input[_builtins.str]
        """
        The Object Storage namespace to read the usage data from.
        """
        object: pulumi.Input[_builtins.str]
        """
        The Object Storage object name to read the usage data from.
        """
        source_type: pulumi.Input[_builtins.str]
        """
        The destination type. Use `objectStorageTuple` when specifying the namespace, bucket name, and object name. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    VulnerabilityAuditUsageDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityAuditUsageDataArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 namespace: pulumi.Input[_builtins.str],
                 object: pulumi.Input[_builtins.str],
                 source_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] bucket: The Object Storage bucket to read the usage data from.
        :param pulumi.Input[_builtins.str] namespace: The Object Storage namespace to read the usage data from.
        :param pulumi.Input[_builtins.str] object: The Object Storage object name to read the usage data from.
        :param pulumi.Input[_builtins.str] source_type: The destination type. Use `objectStorageTuple` when specifying the namespace, bucket name, and object name. 
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "object", object)
        pulumi.set(__self__, "source_type", source_type)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        The Object Storage bucket to read the usage data from.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        The Object Storage namespace to read the usage data from.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def object(self) -> pulumi.Input[_builtins.str]:
        """
        The Object Storage object name to read the usage data from.
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "object", value)

    @_builtins.property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[_builtins.str]:
        """
        The destination type. Use `objectStorageTuple` when specifying the namespace, bucket name, and object name. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_type", value)


if not MYPY:
    class VulnerabilityAuditVulnerabilityArgsDict(TypedDict):
        cvss_v2score: NotRequired[pulumi.Input[_builtins.float]]
        """
        Common Vulnerability Scoring System (CVSS) Version 2, calculated from the metrics provided in the CVSS vector provided from the vulnerability source. This field is deprecated and will be removed in the future. The cvssV2Score can be obtained from the metrics field of the listVulnerabilities endpoint.
        """
        cvss_v3score: NotRequired[pulumi.Input[_builtins.float]]
        """
        Common Vulnerability Scoring System (CVSS) Version 3, calculated from the metrics provided in the CVSS vector provided from the vulnerability source. This field is deprecated and will be removed in the future. The cvssV3Score can be obtained from the metrics field of the listVulnerabilities endpoint.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique vulnerability identifier, e.g. CVE-1999-0067.
        """
        is_false_positive: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates if the vulnerability is a false positive according to the usage data. If no usage data was provided or the service cannot infer usage of the vulnerable code then this property is `null`.
        """
        is_ignored: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates if the vulnerability was ignored according to the audit configuration.
        """
        severity: NotRequired[pulumi.Input[_builtins.str]]
        """
        ADM qualitative severity score. Can be either NONE, LOW, MEDIUM, HIGH or CRITICAL.
        """
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        vulnerability audit source.
        """
elif False:
    VulnerabilityAuditVulnerabilityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VulnerabilityAuditVulnerabilityArgs:
    def __init__(__self__, *,
                 cvss_v2score: Optional[pulumi.Input[_builtins.float]] = None,
                 cvss_v3score: Optional[pulumi.Input[_builtins.float]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_false_positive: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_ignored: Optional[pulumi.Input[_builtins.bool]] = None,
                 severity: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.float] cvss_v2score: Common Vulnerability Scoring System (CVSS) Version 2, calculated from the metrics provided in the CVSS vector provided from the vulnerability source. This field is deprecated and will be removed in the future. The cvssV2Score can be obtained from the metrics field of the listVulnerabilities endpoint.
        :param pulumi.Input[_builtins.float] cvss_v3score: Common Vulnerability Scoring System (CVSS) Version 3, calculated from the metrics provided in the CVSS vector provided from the vulnerability source. This field is deprecated and will be removed in the future. The cvssV3Score can be obtained from the metrics field of the listVulnerabilities endpoint.
        :param pulumi.Input[_builtins.str] id: Unique vulnerability identifier, e.g. CVE-1999-0067.
        :param pulumi.Input[_builtins.bool] is_false_positive: Indicates if the vulnerability is a false positive according to the usage data. If no usage data was provided or the service cannot infer usage of the vulnerable code then this property is `null`.
        :param pulumi.Input[_builtins.bool] is_ignored: Indicates if the vulnerability was ignored according to the audit configuration.
        :param pulumi.Input[_builtins.str] severity: ADM qualitative severity score. Can be either NONE, LOW, MEDIUM, HIGH or CRITICAL.
        :param pulumi.Input[_builtins.str] source: vulnerability audit source.
        """
        if cvss_v2score is not None:
            pulumi.set(__self__, "cvss_v2score", cvss_v2score)
        if cvss_v3score is not None:
            pulumi.set(__self__, "cvss_v3score", cvss_v3score)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_false_positive is not None:
            pulumi.set(__self__, "is_false_positive", is_false_positive)
        if is_ignored is not None:
            pulumi.set(__self__, "is_ignored", is_ignored)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter(name="cvssV2score")
    def cvss_v2score(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Common Vulnerability Scoring System (CVSS) Version 2, calculated from the metrics provided in the CVSS vector provided from the vulnerability source. This field is deprecated and will be removed in the future. The cvssV2Score can be obtained from the metrics field of the listVulnerabilities endpoint.
        """
        return pulumi.get(self, "cvss_v2score")

    @cvss_v2score.setter
    def cvss_v2score(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "cvss_v2score", value)

    @_builtins.property
    @pulumi.getter(name="cvssV3score")
    def cvss_v3score(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Common Vulnerability Scoring System (CVSS) Version 3, calculated from the metrics provided in the CVSS vector provided from the vulnerability source. This field is deprecated and will be removed in the future. The cvssV3Score can be obtained from the metrics field of the listVulnerabilities endpoint.
        """
        return pulumi.get(self, "cvss_v3score")

    @cvss_v3score.setter
    def cvss_v3score(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "cvss_v3score", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique vulnerability identifier, e.g. CVE-1999-0067.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isFalsePositive")
    def is_false_positive(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates if the vulnerability is a false positive according to the usage data. If no usage data was provided or the service cannot infer usage of the vulnerable code then this property is `null`.
        """
        return pulumi.get(self, "is_false_positive")

    @is_false_positive.setter
    def is_false_positive(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_false_positive", value)

    @_builtins.property
    @pulumi.getter(name="isIgnored")
    def is_ignored(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates if the vulnerability was ignored according to the audit configuration.
        """
        return pulumi.get(self, "is_ignored")

    @is_ignored.setter
    def is_ignored(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_ignored", value)

    @_builtins.property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ADM qualitative severity score. Can be either NONE, LOW, MEDIUM, HIGH or CRITICAL.
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "severity", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        vulnerability audit source.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class GetKnowledgebasesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetKnowledgebasesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetKnowledgebasesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetRemediationRecipesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetRemediationRecipesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemediationRecipesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetRemediationRunApplicationDependencyRecommendationsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetRemediationRunApplicationDependencyRecommendationsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemediationRunApplicationDependencyRecommendationsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetRemediationRunStagesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetRemediationRunStagesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemediationRunStagesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetRemediationRunsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetRemediationRunsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemediationRunsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetVulnerabilityAuditApplicationDependencyVulnerabilitiesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetVulnerabilityAuditApplicationDependencyVulnerabilitiesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVulnerabilityAuditApplicationDependencyVulnerabilitiesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetVulnerabilityAuditsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetVulnerabilityAuditsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVulnerabilityAuditsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


