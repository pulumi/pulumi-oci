# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'RemediationRecipeDetectConfiguration',
    'RemediationRecipeNetworkConfiguration',
    'RemediationRecipeScmConfiguration',
    'RemediationRecipeVerifyConfiguration',
    'RemediationRunStage',
    'VulnerabilityAuditApplicationDependency',
    'VulnerabilityAuditConfiguration',
    'VulnerabilityAuditSource',
    'VulnerabilityAuditVulnerability',
    'GetKnowledgebasesFilterResult',
    'GetKnowledgebasesKnowledgeBaseCollectionResult',
    'GetKnowledgebasesKnowledgeBaseCollectionItemResult',
    'GetRemediationRecipeDetectConfigurationResult',
    'GetRemediationRecipeNetworkConfigurationResult',
    'GetRemediationRecipeScmConfigurationResult',
    'GetRemediationRecipeVerifyConfigurationResult',
    'GetRemediationRecipesFilterResult',
    'GetRemediationRecipesRemediationRecipeCollectionResult',
    'GetRemediationRecipesRemediationRecipeCollectionItemResult',
    'GetRemediationRecipesRemediationRecipeCollectionItemDetectConfigurationResult',
    'GetRemediationRecipesRemediationRecipeCollectionItemNetworkConfigurationResult',
    'GetRemediationRecipesRemediationRecipeCollectionItemScmConfigurationResult',
    'GetRemediationRecipesRemediationRecipeCollectionItemVerifyConfigurationResult',
    'GetRemediationRunApplicationDependencyRecommendationsApplicationDependencyRecommendationCollectionResult',
    'GetRemediationRunApplicationDependencyRecommendationsApplicationDependencyRecommendationCollectionItemResult',
    'GetRemediationRunApplicationDependencyRecommendationsFilterResult',
    'GetRemediationRunStageResult',
    'GetRemediationRunStagePipelinePropertyResult',
    'GetRemediationRunStagePullRequestPropertyResult',
    'GetRemediationRunStagesFilterResult',
    'GetRemediationRunStagesRemediationRunStageCollectionResult',
    'GetRemediationRunStagesRemediationRunStageCollectionItemResult',
    'GetRemediationRunStagesRemediationRunStageCollectionItemPipelinePropertyResult',
    'GetRemediationRunStagesRemediationRunStageCollectionItemPullRequestPropertyResult',
    'GetRemediationRunsFilterResult',
    'GetRemediationRunsRemediationRunCollectionResult',
    'GetRemediationRunsRemediationRunCollectionItemResult',
    'GetRemediationRunsRemediationRunCollectionItemStageResult',
    'GetVulnerabilityAuditApplicationDependencyResult',
    'GetVulnerabilityAuditApplicationDependencyVulnerabilitiesApplicationDependencyVulnerabilityCollectionResult',
    'GetVulnerabilityAuditApplicationDependencyVulnerabilitiesApplicationDependencyVulnerabilityCollectionItemResult',
    'GetVulnerabilityAuditApplicationDependencyVulnerabilitiesApplicationDependencyVulnerabilityCollectionItemVulnerabilityResult',
    'GetVulnerabilityAuditApplicationDependencyVulnerabilitiesFilterResult',
    'GetVulnerabilityAuditApplicationDependencyVulnerabilityItemResult',
    'GetVulnerabilityAuditApplicationDependencyVulnerabilityItemVulnerabilityResult',
    'GetVulnerabilityAuditConfigurationResult',
    'GetVulnerabilityAuditSourceResult',
    'GetVulnerabilityAuditVulnerabilityResult',
    'GetVulnerabilityAuditsFilterResult',
    'GetVulnerabilityAuditsVulnerabilityAuditCollectionResult',
    'GetVulnerabilityAuditsVulnerabilityAuditCollectionItemResult',
    'GetVulnerabilityAuditsVulnerabilityAuditCollectionItemApplicationDependencyResult',
    'GetVulnerabilityAuditsVulnerabilityAuditCollectionItemConfigurationResult',
    'GetVulnerabilityAuditsVulnerabilityAuditCollectionItemSourceResult',
    'GetVulnerabilityAuditsVulnerabilityAuditCollectionItemVulnerabilityResult',
]

@pulumi.output_type
class RemediationRecipeDetectConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxPermissibleCvssV2score":
            suggest = "max_permissible_cvss_v2score"
        elif key == "maxPermissibleCvssV3score":
            suggest = "max_permissible_cvss_v3score"
        elif key == "upgradePolicy":
            suggest = "upgrade_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemediationRecipeDetectConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemediationRecipeDetectConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemediationRecipeDetectConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclusions: Optional[Sequence[str]] = None,
                 max_permissible_cvss_v2score: Optional[float] = None,
                 max_permissible_cvss_v3score: Optional[float] = None,
                 upgrade_policy: Optional[str] = None):
        """
        :param Sequence[str] exclusions: (Updatable) The list of dependencies to be ignored by the recommendation algorithm. The dependency pattern is matched against the 'group:artifact:version' or the purl of a dependency. An asterisk (*) at the end in the dependency pattern acts as a wildcard and matches zero or more characters.
        :param float max_permissible_cvss_v2score: (Updatable) The maximum Common Vulnerability Scoring System Version 2 (CVSS V2) score. An artifact with a CVSS V2 score below this value is not considered for patching.
        :param float max_permissible_cvss_v3score: (Updatable) The maximum Common Vulnerability Scoring System Version 3 (CVSS V3) score. An artifact with a CVSS V3 score below this value is not considered for patching.
        :param str upgrade_policy: (Updatable) The upgrade policy for recommendations. The `Nearest` upgrade policy upgrades a dependency to the oldest version that meets both of the following criteria: it is newer than the current version and it is not affected by a vulnerability.
        """
        RemediationRecipeDetectConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exclusions=exclusions,
            max_permissible_cvss_v2score=max_permissible_cvss_v2score,
            max_permissible_cvss_v3score=max_permissible_cvss_v3score,
            upgrade_policy=upgrade_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exclusions: Optional[Sequence[str]] = None,
             max_permissible_cvss_v2score: Optional[float] = None,
             max_permissible_cvss_v3score: Optional[float] = None,
             upgrade_policy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if max_permissible_cvss_v2score is None and 'maxPermissibleCvssV2score' in kwargs:
            max_permissible_cvss_v2score = kwargs['maxPermissibleCvssV2score']
        if max_permissible_cvss_v3score is None and 'maxPermissibleCvssV3score' in kwargs:
            max_permissible_cvss_v3score = kwargs['maxPermissibleCvssV3score']
        if upgrade_policy is None and 'upgradePolicy' in kwargs:
            upgrade_policy = kwargs['upgradePolicy']

        if exclusions is not None:
            _setter("exclusions", exclusions)
        if max_permissible_cvss_v2score is not None:
            _setter("max_permissible_cvss_v2score", max_permissible_cvss_v2score)
        if max_permissible_cvss_v3score is not None:
            _setter("max_permissible_cvss_v3score", max_permissible_cvss_v3score)
        if upgrade_policy is not None:
            _setter("upgrade_policy", upgrade_policy)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[str]]:
        """
        (Updatable) The list of dependencies to be ignored by the recommendation algorithm. The dependency pattern is matched against the 'group:artifact:version' or the purl of a dependency. An asterisk (*) at the end in the dependency pattern acts as a wildcard and matches zero or more characters.
        """
        return pulumi.get(self, "exclusions")

    @property
    @pulumi.getter(name="maxPermissibleCvssV2score")
    def max_permissible_cvss_v2score(self) -> Optional[float]:
        """
        (Updatable) The maximum Common Vulnerability Scoring System Version 2 (CVSS V2) score. An artifact with a CVSS V2 score below this value is not considered for patching.
        """
        return pulumi.get(self, "max_permissible_cvss_v2score")

    @property
    @pulumi.getter(name="maxPermissibleCvssV3score")
    def max_permissible_cvss_v3score(self) -> Optional[float]:
        """
        (Updatable) The maximum Common Vulnerability Scoring System Version 3 (CVSS V3) score. An artifact with a CVSS V3 score below this value is not considered for patching.
        """
        return pulumi.get(self, "max_permissible_cvss_v3score")

    @property
    @pulumi.getter(name="upgradePolicy")
    def upgrade_policy(self) -> Optional[str]:
        """
        (Updatable) The upgrade policy for recommendations. The `Nearest` upgrade policy upgrades a dependency to the oldest version that meets both of the following criteria: it is newer than the current version and it is not affected by a vulnerability.
        """
        return pulumi.get(self, "upgrade_policy")


@pulumi.output_type
class RemediationRecipeNetworkConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"
        elif key == "nsgIds":
            suggest = "nsg_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemediationRecipeNetworkConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemediationRecipeNetworkConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemediationRecipeNetworkConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: str,
                 nsg_ids: Optional[Sequence[str]] = None):
        """
        :param str subnet_id: (Updatable) The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the subnet.
        :param Sequence[str] nsg_ids: (Updatable) The list of Oracle Cloud Identifiers ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) corresponding to Network Security Groups.
        """
        RemediationRecipeNetworkConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subnet_id=subnet_id,
            nsg_ids=nsg_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subnet_id: Optional[str] = None,
             nsg_ids: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if subnet_id is None and 'subnetId' in kwargs:
            subnet_id = kwargs['subnetId']
        if subnet_id is None:
            raise TypeError("Missing 'subnet_id' argument")
        if nsg_ids is None and 'nsgIds' in kwargs:
            nsg_ids = kwargs['nsgIds']

        _setter("subnet_id", subnet_id)
        if nsg_ids is not None:
            _setter("nsg_ids", nsg_ids)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        (Updatable) The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the subnet.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Optional[Sequence[str]]:
        """
        (Updatable) The list of Oracle Cloud Identifiers ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) corresponding to Network Security Groups.
        """
        return pulumi.get(self, "nsg_ids")


@pulumi.output_type
class RemediationRecipeScmConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isAutomergeEnabled":
            suggest = "is_automerge_enabled"
        elif key == "scmType":
            suggest = "scm_type"
        elif key == "buildFileLocation":
            suggest = "build_file_location"
        elif key == "externalScmType":
            suggest = "external_scm_type"
        elif key == "ociCodeRepositoryId":
            suggest = "oci_code_repository_id"
        elif key == "patSecretId":
            suggest = "pat_secret_id"
        elif key == "repositoryUrl":
            suggest = "repository_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemediationRecipeScmConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemediationRecipeScmConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemediationRecipeScmConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: str,
                 is_automerge_enabled: bool,
                 scm_type: str,
                 build_file_location: Optional[str] = None,
                 external_scm_type: Optional[str] = None,
                 oci_code_repository_id: Optional[str] = None,
                 pat_secret_id: Optional[str] = None,
                 repository_url: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str branch: (Updatable) The branch used by ADM to patch vulnerabilities.
        :param bool is_automerge_enabled: (Updatable) If true, the Pull Request (PR) will be merged after the verify stage completes successfully     If false, the PR with the proposed changes must be reviewed and manually merged.
        :param str scm_type: (Updatable) The type of Source Code Management.
        :param str build_file_location: (Updatable) The location of the build file relative to the root of the repository. Only Maven build files (POM) are currently supported. If this property is not specified, ADM will use the build file located at the root of the repository.
        :param str external_scm_type: (Updatable) The type of External Source Code Management.
        :param str oci_code_repository_id: (Updatable) The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Oracle Cloud Infrastructure DevOps repository.
        :param str pat_secret_id: (Updatable) The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Private Access Token (PAT) Secret. The PAT provides the credentials to access the Jenkins Pipeline.
        :param str repository_url: (Updatable) The location of the repository where the GitHub Actions is defined. For Non-Enterprise GitHub the expected format is https://github.com/[owner]/[repoName] For Enterprise GitHub the expected format is http(s)://[hostname]/api/v3/repos/[owner]/[repoName]
        :param str username: (Updatable) The username that will be used to authenticate with Jenkins.
        """
        RemediationRecipeScmConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            branch=branch,
            is_automerge_enabled=is_automerge_enabled,
            scm_type=scm_type,
            build_file_location=build_file_location,
            external_scm_type=external_scm_type,
            oci_code_repository_id=oci_code_repository_id,
            pat_secret_id=pat_secret_id,
            repository_url=repository_url,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             branch: Optional[str] = None,
             is_automerge_enabled: Optional[bool] = None,
             scm_type: Optional[str] = None,
             build_file_location: Optional[str] = None,
             external_scm_type: Optional[str] = None,
             oci_code_repository_id: Optional[str] = None,
             pat_secret_id: Optional[str] = None,
             repository_url: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if branch is None:
            raise TypeError("Missing 'branch' argument")
        if is_automerge_enabled is None and 'isAutomergeEnabled' in kwargs:
            is_automerge_enabled = kwargs['isAutomergeEnabled']
        if is_automerge_enabled is None:
            raise TypeError("Missing 'is_automerge_enabled' argument")
        if scm_type is None and 'scmType' in kwargs:
            scm_type = kwargs['scmType']
        if scm_type is None:
            raise TypeError("Missing 'scm_type' argument")
        if build_file_location is None and 'buildFileLocation' in kwargs:
            build_file_location = kwargs['buildFileLocation']
        if external_scm_type is None and 'externalScmType' in kwargs:
            external_scm_type = kwargs['externalScmType']
        if oci_code_repository_id is None and 'ociCodeRepositoryId' in kwargs:
            oci_code_repository_id = kwargs['ociCodeRepositoryId']
        if pat_secret_id is None and 'patSecretId' in kwargs:
            pat_secret_id = kwargs['patSecretId']
        if repository_url is None and 'repositoryUrl' in kwargs:
            repository_url = kwargs['repositoryUrl']

        _setter("branch", branch)
        _setter("is_automerge_enabled", is_automerge_enabled)
        _setter("scm_type", scm_type)
        if build_file_location is not None:
            _setter("build_file_location", build_file_location)
        if external_scm_type is not None:
            _setter("external_scm_type", external_scm_type)
        if oci_code_repository_id is not None:
            _setter("oci_code_repository_id", oci_code_repository_id)
        if pat_secret_id is not None:
            _setter("pat_secret_id", pat_secret_id)
        if repository_url is not None:
            _setter("repository_url", repository_url)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter
    def branch(self) -> str:
        """
        (Updatable) The branch used by ADM to patch vulnerabilities.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter(name="isAutomergeEnabled")
    def is_automerge_enabled(self) -> bool:
        """
        (Updatable) If true, the Pull Request (PR) will be merged after the verify stage completes successfully     If false, the PR with the proposed changes must be reviewed and manually merged.
        """
        return pulumi.get(self, "is_automerge_enabled")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> str:
        """
        (Updatable) The type of Source Code Management.
        """
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="buildFileLocation")
    def build_file_location(self) -> Optional[str]:
        """
        (Updatable) The location of the build file relative to the root of the repository. Only Maven build files (POM) are currently supported. If this property is not specified, ADM will use the build file located at the root of the repository.
        """
        return pulumi.get(self, "build_file_location")

    @property
    @pulumi.getter(name="externalScmType")
    def external_scm_type(self) -> Optional[str]:
        """
        (Updatable) The type of External Source Code Management.
        """
        return pulumi.get(self, "external_scm_type")

    @property
    @pulumi.getter(name="ociCodeRepositoryId")
    def oci_code_repository_id(self) -> Optional[str]:
        """
        (Updatable) The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Oracle Cloud Infrastructure DevOps repository.
        """
        return pulumi.get(self, "oci_code_repository_id")

    @property
    @pulumi.getter(name="patSecretId")
    def pat_secret_id(self) -> Optional[str]:
        """
        (Updatable) The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Private Access Token (PAT) Secret. The PAT provides the credentials to access the Jenkins Pipeline.
        """
        return pulumi.get(self, "pat_secret_id")

    @property
    @pulumi.getter(name="repositoryUrl")
    def repository_url(self) -> Optional[str]:
        """
        (Updatable) The location of the repository where the GitHub Actions is defined. For Non-Enterprise GitHub the expected format is https://github.com/[owner]/[repoName] For Enterprise GitHub the expected format is http(s)://[hostname]/api/v3/repos/[owner]/[repoName]
        """
        return pulumi.get(self, "repository_url")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        (Updatable) The username that will be used to authenticate with Jenkins.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class RemediationRecipeVerifyConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buildServiceType":
            suggest = "build_service_type"
        elif key == "additionalParameters":
            suggest = "additional_parameters"
        elif key == "jenkinsUrl":
            suggest = "jenkins_url"
        elif key == "jobName":
            suggest = "job_name"
        elif key == "patSecretId":
            suggest = "pat_secret_id"
        elif key == "pipelineId":
            suggest = "pipeline_id"
        elif key == "repositoryUrl":
            suggest = "repository_url"
        elif key == "triggerSecretId":
            suggest = "trigger_secret_id"
        elif key == "workflowName":
            suggest = "workflow_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemediationRecipeVerifyConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemediationRecipeVerifyConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemediationRecipeVerifyConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 build_service_type: str,
                 additional_parameters: Optional[Mapping[str, Any]] = None,
                 jenkins_url: Optional[str] = None,
                 job_name: Optional[str] = None,
                 pat_secret_id: Optional[str] = None,
                 pipeline_id: Optional[str] = None,
                 repository_url: Optional[str] = None,
                 trigger_secret_id: Optional[str] = None,
                 username: Optional[str] = None,
                 workflow_name: Optional[str] = None):
        """
        :param str build_service_type: (Updatable) The type of Build Service.
        :param Mapping[str, Any] additional_parameters: (Updatable) Additional key-value pairs passed as parameters to the build service when running an experiment.
        :param str jenkins_url: (Updatable) The URL that locates the Jenkins pipeline.
        :param str job_name: (Updatable) The name of the Jenkins pipeline job that identifies the build pipeline.
        :param str pat_secret_id: (Updatable) The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Private Access Token (PAT) Secret. The PAT provides the credentials to access the Jenkins Pipeline.
        :param str pipeline_id: (Updatable) The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the user's DevOps Build Pipeline.
        :param str repository_url: (Updatable) The location of the repository where the GitHub Actions is defined. For Non-Enterprise GitHub the expected format is https://github.com/[owner]/[repoName] For Enterprise GitHub the expected format is http(s)://[hostname]/api/v3/repos/[owner]/[repoName]
        :param str trigger_secret_id: (Updatable) The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the trigger Secret. The Secret provides access to the trigger for a GitLab pipeline.
        :param str username: (Updatable) The username that will be used to authenticate with Jenkins.
        :param str workflow_name: (Updatable) The name of the GitHub Actions workflow that defines the build pipeline.
        """
        RemediationRecipeVerifyConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            build_service_type=build_service_type,
            additional_parameters=additional_parameters,
            jenkins_url=jenkins_url,
            job_name=job_name,
            pat_secret_id=pat_secret_id,
            pipeline_id=pipeline_id,
            repository_url=repository_url,
            trigger_secret_id=trigger_secret_id,
            username=username,
            workflow_name=workflow_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             build_service_type: Optional[str] = None,
             additional_parameters: Optional[Mapping[str, Any]] = None,
             jenkins_url: Optional[str] = None,
             job_name: Optional[str] = None,
             pat_secret_id: Optional[str] = None,
             pipeline_id: Optional[str] = None,
             repository_url: Optional[str] = None,
             trigger_secret_id: Optional[str] = None,
             username: Optional[str] = None,
             workflow_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if build_service_type is None and 'buildServiceType' in kwargs:
            build_service_type = kwargs['buildServiceType']
        if build_service_type is None:
            raise TypeError("Missing 'build_service_type' argument")
        if additional_parameters is None and 'additionalParameters' in kwargs:
            additional_parameters = kwargs['additionalParameters']
        if jenkins_url is None and 'jenkinsUrl' in kwargs:
            jenkins_url = kwargs['jenkinsUrl']
        if job_name is None and 'jobName' in kwargs:
            job_name = kwargs['jobName']
        if pat_secret_id is None and 'patSecretId' in kwargs:
            pat_secret_id = kwargs['patSecretId']
        if pipeline_id is None and 'pipelineId' in kwargs:
            pipeline_id = kwargs['pipelineId']
        if repository_url is None and 'repositoryUrl' in kwargs:
            repository_url = kwargs['repositoryUrl']
        if trigger_secret_id is None and 'triggerSecretId' in kwargs:
            trigger_secret_id = kwargs['triggerSecretId']
        if workflow_name is None and 'workflowName' in kwargs:
            workflow_name = kwargs['workflowName']

        _setter("build_service_type", build_service_type)
        if additional_parameters is not None:
            _setter("additional_parameters", additional_parameters)
        if jenkins_url is not None:
            _setter("jenkins_url", jenkins_url)
        if job_name is not None:
            _setter("job_name", job_name)
        if pat_secret_id is not None:
            _setter("pat_secret_id", pat_secret_id)
        if pipeline_id is not None:
            _setter("pipeline_id", pipeline_id)
        if repository_url is not None:
            _setter("repository_url", repository_url)
        if trigger_secret_id is not None:
            _setter("trigger_secret_id", trigger_secret_id)
        if username is not None:
            _setter("username", username)
        if workflow_name is not None:
            _setter("workflow_name", workflow_name)

    @property
    @pulumi.getter(name="buildServiceType")
    def build_service_type(self) -> str:
        """
        (Updatable) The type of Build Service.
        """
        return pulumi.get(self, "build_service_type")

    @property
    @pulumi.getter(name="additionalParameters")
    def additional_parameters(self) -> Optional[Mapping[str, Any]]:
        """
        (Updatable) Additional key-value pairs passed as parameters to the build service when running an experiment.
        """
        return pulumi.get(self, "additional_parameters")

    @property
    @pulumi.getter(name="jenkinsUrl")
    def jenkins_url(self) -> Optional[str]:
        """
        (Updatable) The URL that locates the Jenkins pipeline.
        """
        return pulumi.get(self, "jenkins_url")

    @property
    @pulumi.getter(name="jobName")
    def job_name(self) -> Optional[str]:
        """
        (Updatable) The name of the Jenkins pipeline job that identifies the build pipeline.
        """
        return pulumi.get(self, "job_name")

    @property
    @pulumi.getter(name="patSecretId")
    def pat_secret_id(self) -> Optional[str]:
        """
        (Updatable) The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Private Access Token (PAT) Secret. The PAT provides the credentials to access the Jenkins Pipeline.
        """
        return pulumi.get(self, "pat_secret_id")

    @property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> Optional[str]:
        """
        (Updatable) The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the user's DevOps Build Pipeline.
        """
        return pulumi.get(self, "pipeline_id")

    @property
    @pulumi.getter(name="repositoryUrl")
    def repository_url(self) -> Optional[str]:
        """
        (Updatable) The location of the repository where the GitHub Actions is defined. For Non-Enterprise GitHub the expected format is https://github.com/[owner]/[repoName] For Enterprise GitHub the expected format is http(s)://[hostname]/api/v3/repos/[owner]/[repoName]
        """
        return pulumi.get(self, "repository_url")

    @property
    @pulumi.getter(name="triggerSecretId")
    def trigger_secret_id(self) -> Optional[str]:
        """
        (Updatable) The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the trigger Secret. The Secret provides access to the trigger for a GitLab pipeline.
        """
        return pulumi.get(self, "trigger_secret_id")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        (Updatable) The username that will be used to authenticate with Jenkins.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="workflowName")
    def workflow_name(self) -> Optional[str]:
        """
        (Updatable) The name of the GitHub Actions workflow that defines the build pipeline.
        """
        return pulumi.get(self, "workflow_name")


@pulumi.output_type
class RemediationRunStage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeCreated":
            suggest = "time_created"
        elif key == "timeFinished":
            suggest = "time_finished"
        elif key == "timeStarted":
            suggest = "time_started"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemediationRunStage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemediationRunStage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemediationRunStage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 summary: Optional[str] = None,
                 time_created: Optional[str] = None,
                 time_finished: Optional[str] = None,
                 time_started: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str summary: Information about the current step within the given stage.
        :param str time_created: The creation date and time of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        :param str time_finished: The date and time of the finish of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        :param str time_started: The date and time of the start of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        :param str type: The type of stage.
        """
        RemediationRunStage._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            summary=summary,
            time_created=time_created,
            time_finished=time_finished,
            time_started=time_started,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             summary: Optional[str] = None,
             time_created: Optional[str] = None,
             time_finished: Optional[str] = None,
             time_started: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_finished is None and 'timeFinished' in kwargs:
            time_finished = kwargs['timeFinished']
        if time_started is None and 'timeStarted' in kwargs:
            time_started = kwargs['timeStarted']

        if summary is not None:
            _setter("summary", summary)
        if time_created is not None:
            _setter("time_created", time_created)
        if time_finished is not None:
            _setter("time_finished", time_finished)
        if time_started is not None:
            _setter("time_started", time_started)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def summary(self) -> Optional[str]:
        """
        Information about the current step within the given stage.
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[str]:
        """
        The creation date and time of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeFinished")
    def time_finished(self) -> Optional[str]:
        """
        The date and time of the finish of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        """
        return pulumi.get(self, "time_finished")

    @property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> Optional[str]:
        """
        The date and time of the start of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        """
        return pulumi.get(self, "time_started")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of stage.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class VulnerabilityAuditApplicationDependency(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeId":
            suggest = "node_id"
        elif key == "applicationDependencyNodeIds":
            suggest = "application_dependency_node_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VulnerabilityAuditApplicationDependency. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VulnerabilityAuditApplicationDependency.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VulnerabilityAuditApplicationDependency.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gav: str,
                 node_id: str,
                 application_dependency_node_ids: Optional[Sequence[str]] = None):
        """
        :param str gav: Group Artifact Version (GAV) identifier (Group:Artifact:Version), e.g. org.graalvm.nativeimage:svm:21.1.0.
        :param str node_id: Unique identifier of an application dependency, for example nodeId1. The nodeId can be generated by assigning a unique id to each application dependency in the tree of application dependencies. Every node, even those who share the same GAV, should have a different nodeId. The preferred way of constructing a nodeId is to assign incremental integers during a breadth first or depth first search. A nodeId can be reused only it refers to the same subtree of application dependencies. (This is not equivalent to referring to the same GAV, that is, a GAV can have multiple transitive dependencies.)
        :param Sequence[str] application_dependency_node_ids: List of application dependencies on which this application dependency depends, each identified by its nodeId.
        """
        VulnerabilityAuditApplicationDependency._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            gav=gav,
            node_id=node_id,
            application_dependency_node_ids=application_dependency_node_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             gav: Optional[str] = None,
             node_id: Optional[str] = None,
             application_dependency_node_ids: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if gav is None:
            raise TypeError("Missing 'gav' argument")
        if node_id is None and 'nodeId' in kwargs:
            node_id = kwargs['nodeId']
        if node_id is None:
            raise TypeError("Missing 'node_id' argument")
        if application_dependency_node_ids is None and 'applicationDependencyNodeIds' in kwargs:
            application_dependency_node_ids = kwargs['applicationDependencyNodeIds']

        _setter("gav", gav)
        _setter("node_id", node_id)
        if application_dependency_node_ids is not None:
            _setter("application_dependency_node_ids", application_dependency_node_ids)

    @property
    @pulumi.getter
    def gav(self) -> str:
        """
        Group Artifact Version (GAV) identifier (Group:Artifact:Version), e.g. org.graalvm.nativeimage:svm:21.1.0.
        """
        return pulumi.get(self, "gav")

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> str:
        """
        Unique identifier of an application dependency, for example nodeId1. The nodeId can be generated by assigning a unique id to each application dependency in the tree of application dependencies. Every node, even those who share the same GAV, should have a different nodeId. The preferred way of constructing a nodeId is to assign incremental integers during a breadth first or depth first search. A nodeId can be reused only it refers to the same subtree of application dependencies. (This is not equivalent to referring to the same GAV, that is, a GAV can have multiple transitive dependencies.)
        """
        return pulumi.get(self, "node_id")

    @property
    @pulumi.getter(name="applicationDependencyNodeIds")
    def application_dependency_node_ids(self) -> Optional[Sequence[str]]:
        """
        List of application dependencies on which this application dependency depends, each identified by its nodeId.
        """
        return pulumi.get(self, "application_dependency_node_ids")


@pulumi.output_type
class VulnerabilityAuditConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxPermissibleCvssV2score":
            suggest = "max_permissible_cvss_v2score"
        elif key == "maxPermissibleCvssV3score":
            suggest = "max_permissible_cvss_v3score"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VulnerabilityAuditConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VulnerabilityAuditConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VulnerabilityAuditConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclusions: Optional[Sequence[str]] = None,
                 max_permissible_cvss_v2score: Optional[float] = None,
                 max_permissible_cvss_v3score: Optional[float] = None):
        """
        :param Sequence[str] exclusions: A vulnerable application dependency is ignored if its name matches any of the items in `exclusions`. An asterisk (*) in the dependency pattern acts as a wildcard and matches zero or more characters.
        :param float max_permissible_cvss_v2score: A vulnerable application dependency is ignored if the score of its associated Vulnerability is below maxPermissibleCvssV2Score and below maxPermissibleCvssV3Score.
        :param float max_permissible_cvss_v3score: A vulnerable application dependency is ignored if the score of its associated Vulnerability is below maxPermissibleCvssV2Score and below maxPermissibleCvssV3Score.
        """
        VulnerabilityAuditConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exclusions=exclusions,
            max_permissible_cvss_v2score=max_permissible_cvss_v2score,
            max_permissible_cvss_v3score=max_permissible_cvss_v3score,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exclusions: Optional[Sequence[str]] = None,
             max_permissible_cvss_v2score: Optional[float] = None,
             max_permissible_cvss_v3score: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if max_permissible_cvss_v2score is None and 'maxPermissibleCvssV2score' in kwargs:
            max_permissible_cvss_v2score = kwargs['maxPermissibleCvssV2score']
        if max_permissible_cvss_v3score is None and 'maxPermissibleCvssV3score' in kwargs:
            max_permissible_cvss_v3score = kwargs['maxPermissibleCvssV3score']

        if exclusions is not None:
            _setter("exclusions", exclusions)
        if max_permissible_cvss_v2score is not None:
            _setter("max_permissible_cvss_v2score", max_permissible_cvss_v2score)
        if max_permissible_cvss_v3score is not None:
            _setter("max_permissible_cvss_v3score", max_permissible_cvss_v3score)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[str]]:
        """
        A vulnerable application dependency is ignored if its name matches any of the items in `exclusions`. An asterisk (*) in the dependency pattern acts as a wildcard and matches zero or more characters.
        """
        return pulumi.get(self, "exclusions")

    @property
    @pulumi.getter(name="maxPermissibleCvssV2score")
    def max_permissible_cvss_v2score(self) -> Optional[float]:
        """
        A vulnerable application dependency is ignored if the score of its associated Vulnerability is below maxPermissibleCvssV2Score and below maxPermissibleCvssV3Score.
        """
        return pulumi.get(self, "max_permissible_cvss_v2score")

    @property
    @pulumi.getter(name="maxPermissibleCvssV3score")
    def max_permissible_cvss_v3score(self) -> Optional[float]:
        """
        A vulnerable application dependency is ignored if the score of its associated Vulnerability is below maxPermissibleCvssV2Score and below maxPermissibleCvssV3Score.
        """
        return pulumi.get(self, "max_permissible_cvss_v3score")


@pulumi.output_type
class VulnerabilityAuditSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ociResourceId":
            suggest = "oci_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VulnerabilityAuditSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VulnerabilityAuditSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VulnerabilityAuditSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 description: Optional[str] = None,
                 oci_resource_id: Optional[str] = None):
        """
        :param str type: Source type of the vulnerability audit.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param str description: Description of the external resource source.
        :param str oci_resource_id: The Oracle Cloud identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Oracle Cloud Infrastructure resource that triggered the vulnerability audit.
        """
        VulnerabilityAuditSource._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            description=description,
            oci_resource_id=oci_resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[str] = None,
             description: Optional[str] = None,
             oci_resource_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")
        if oci_resource_id is None and 'ociResourceId' in kwargs:
            oci_resource_id = kwargs['ociResourceId']

        _setter("type", type)
        if description is not None:
            _setter("description", description)
        if oci_resource_id is not None:
            _setter("oci_resource_id", oci_resource_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Source type of the vulnerability audit.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the external resource source.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="ociResourceId")
    def oci_resource_id(self) -> Optional[str]:
        """
        The Oracle Cloud identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Oracle Cloud Infrastructure resource that triggered the vulnerability audit.
        """
        return pulumi.get(self, "oci_resource_id")


@pulumi.output_type
class VulnerabilityAuditVulnerability(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cvssV2score":
            suggest = "cvss_v2score"
        elif key == "cvssV3score":
            suggest = "cvss_v3score"
        elif key == "isIgnored":
            suggest = "is_ignored"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VulnerabilityAuditVulnerability. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VulnerabilityAuditVulnerability.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VulnerabilityAuditVulnerability.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cvss_v2score: Optional[float] = None,
                 cvss_v3score: Optional[float] = None,
                 id: Optional[str] = None,
                 is_ignored: Optional[bool] = None):
        """
        :param float cvss_v2score: Common Vulnerability Scoring System (CVSS) Version 2.
        :param float cvss_v3score: Common Vulnerability Scoring System (CVSS) Version 3.
        :param str id: Unique vulnerability identifier, e.g. CVE-1999-0067.
        :param bool is_ignored: Indicates if the vulnerability was ignored according to the audit configuration.
        """
        VulnerabilityAuditVulnerability._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cvss_v2score=cvss_v2score,
            cvss_v3score=cvss_v3score,
            id=id,
            is_ignored=is_ignored,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cvss_v2score: Optional[float] = None,
             cvss_v3score: Optional[float] = None,
             id: Optional[str] = None,
             is_ignored: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if cvss_v2score is None and 'cvssV2score' in kwargs:
            cvss_v2score = kwargs['cvssV2score']
        if cvss_v3score is None and 'cvssV3score' in kwargs:
            cvss_v3score = kwargs['cvssV3score']
        if is_ignored is None and 'isIgnored' in kwargs:
            is_ignored = kwargs['isIgnored']

        if cvss_v2score is not None:
            _setter("cvss_v2score", cvss_v2score)
        if cvss_v3score is not None:
            _setter("cvss_v3score", cvss_v3score)
        if id is not None:
            _setter("id", id)
        if is_ignored is not None:
            _setter("is_ignored", is_ignored)

    @property
    @pulumi.getter(name="cvssV2score")
    def cvss_v2score(self) -> Optional[float]:
        """
        Common Vulnerability Scoring System (CVSS) Version 2.
        """
        return pulumi.get(self, "cvss_v2score")

    @property
    @pulumi.getter(name="cvssV3score")
    def cvss_v3score(self) -> Optional[float]:
        """
        Common Vulnerability Scoring System (CVSS) Version 3.
        """
        return pulumi.get(self, "cvss_v3score")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique vulnerability identifier, e.g. CVE-1999-0067.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isIgnored")
    def is_ignored(self) -> Optional[bool]:
        """
        Indicates if the vulnerability was ignored according to the audit configuration.
        """
        return pulumi.get(self, "is_ignored")


@pulumi.output_type
class GetKnowledgebasesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetKnowledgebasesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetKnowledgebasesKnowledgeBaseCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetKnowledgebasesKnowledgeBaseCollectionItemResult']):
        GetKnowledgebasesKnowledgeBaseCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetKnowledgebasesKnowledgeBaseCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetKnowledgebasesKnowledgeBaseCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetKnowledgebasesKnowledgeBaseCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 state: str,
                 system_tags: Mapping[str, Any],
                 time_created: str,
                 time_updated: str):
        """
        :param str compartment_id: A filter to return only resources that belong to the specified compartment identifier. Required only if the id query param is not specified.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param Mapping[str, Any] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param str id: A filter to return only resources that match the specified identifier. Required only if the compartmentId query parameter is not specified.
        :param str state: A filter to return only Knowledge Bases that match the specified lifecycleState.
        :param Mapping[str, Any] system_tags: Usage of system tag keys. These predefined keys are scoped to namespaces. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param str time_created: The creation date and time of the knowledge base (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        :param str time_updated: The date and time the knowledge base was last updated (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        """
        GetKnowledgebasesKnowledgeBaseCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            state=state,
            system_tags=system_tags,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             display_name: Optional[str] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             state: Optional[str] = None,
             system_tags: Optional[Mapping[str, Any]] = None,
             time_created: Optional[str] = None,
             time_updated: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if defined_tags is None:
            raise TypeError("Missing 'defined_tags' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if freeform_tags is None:
            raise TypeError("Missing 'freeform_tags' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if system_tags is None and 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if system_tags is None:
            raise TypeError("Missing 'system_tags' argument")
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_created is None:
            raise TypeError("Missing 'time_created' argument")
        if time_updated is None and 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']
        if time_updated is None:
            raise TypeError("Missing 'time_updated' argument")

        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("state", state)
        _setter("system_tags", system_tags)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        A filter to return only resources that belong to the specified compartment identifier. Required only if the id query param is not specified.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        A filter to return only resources that match the specified identifier. Required only if the compartmentId query parameter is not specified.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only Knowledge Bases that match the specified lifecycleState.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        Usage of system tag keys. These predefined keys are scoped to namespaces. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The creation date and time of the knowledge base (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the knowledge base was last updated (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetRemediationRecipeDetectConfigurationResult(dict):
    def __init__(__self__, *,
                 exclusions: Sequence[str],
                 max_permissible_cvss_v2score: float,
                 max_permissible_cvss_v3score: float,
                 upgrade_policy: str):
        """
        :param Sequence[str] exclusions: The list of dependencies to be ignored by the recommendation algorithm. The dependency pattern is matched against the 'group:artifact:version' or the purl of a dependency. An asterisk (*) at the end in the dependency pattern acts as a wildcard and matches zero or more characters.
        :param float max_permissible_cvss_v2score: The maximum Common Vulnerability Scoring System Version 2 (CVSS V2) score. An artifact with a CVSS V2 score below this value is not considered for patching.
        :param float max_permissible_cvss_v3score: The maximum Common Vulnerability Scoring System Version 3 (CVSS V3) score. An artifact with a CVSS V3 score below this value is not considered for patching.
        :param str upgrade_policy: The upgrade policy for recommendations. The `Nearest` upgrade policy upgrades a dependency to the oldest version that meets both of the following criteria: it is newer than the current version and it is not affected by a vulnerability.
        """
        GetRemediationRecipeDetectConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exclusions=exclusions,
            max_permissible_cvss_v2score=max_permissible_cvss_v2score,
            max_permissible_cvss_v3score=max_permissible_cvss_v3score,
            upgrade_policy=upgrade_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exclusions: Optional[Sequence[str]] = None,
             max_permissible_cvss_v2score: Optional[float] = None,
             max_permissible_cvss_v3score: Optional[float] = None,
             upgrade_policy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if exclusions is None:
            raise TypeError("Missing 'exclusions' argument")
        if max_permissible_cvss_v2score is None and 'maxPermissibleCvssV2score' in kwargs:
            max_permissible_cvss_v2score = kwargs['maxPermissibleCvssV2score']
        if max_permissible_cvss_v2score is None:
            raise TypeError("Missing 'max_permissible_cvss_v2score' argument")
        if max_permissible_cvss_v3score is None and 'maxPermissibleCvssV3score' in kwargs:
            max_permissible_cvss_v3score = kwargs['maxPermissibleCvssV3score']
        if max_permissible_cvss_v3score is None:
            raise TypeError("Missing 'max_permissible_cvss_v3score' argument")
        if upgrade_policy is None and 'upgradePolicy' in kwargs:
            upgrade_policy = kwargs['upgradePolicy']
        if upgrade_policy is None:
            raise TypeError("Missing 'upgrade_policy' argument")

        _setter("exclusions", exclusions)
        _setter("max_permissible_cvss_v2score", max_permissible_cvss_v2score)
        _setter("max_permissible_cvss_v3score", max_permissible_cvss_v3score)
        _setter("upgrade_policy", upgrade_policy)

    @property
    @pulumi.getter
    def exclusions(self) -> Sequence[str]:
        """
        The list of dependencies to be ignored by the recommendation algorithm. The dependency pattern is matched against the 'group:artifact:version' or the purl of a dependency. An asterisk (*) at the end in the dependency pattern acts as a wildcard and matches zero or more characters.
        """
        return pulumi.get(self, "exclusions")

    @property
    @pulumi.getter(name="maxPermissibleCvssV2score")
    def max_permissible_cvss_v2score(self) -> float:
        """
        The maximum Common Vulnerability Scoring System Version 2 (CVSS V2) score. An artifact with a CVSS V2 score below this value is not considered for patching.
        """
        return pulumi.get(self, "max_permissible_cvss_v2score")

    @property
    @pulumi.getter(name="maxPermissibleCvssV3score")
    def max_permissible_cvss_v3score(self) -> float:
        """
        The maximum Common Vulnerability Scoring System Version 3 (CVSS V3) score. An artifact with a CVSS V3 score below this value is not considered for patching.
        """
        return pulumi.get(self, "max_permissible_cvss_v3score")

    @property
    @pulumi.getter(name="upgradePolicy")
    def upgrade_policy(self) -> str:
        """
        The upgrade policy for recommendations. The `Nearest` upgrade policy upgrades a dependency to the oldest version that meets both of the following criteria: it is newer than the current version and it is not affected by a vulnerability.
        """
        return pulumi.get(self, "upgrade_policy")


@pulumi.output_type
class GetRemediationRecipeNetworkConfigurationResult(dict):
    def __init__(__self__, *,
                 nsg_ids: Sequence[str],
                 subnet_id: str):
        """
        :param Sequence[str] nsg_ids: The list of Oracle Cloud Identifiers ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) corresponding to Network Security Groups.
        :param str subnet_id: The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the subnet.
        """
        GetRemediationRecipeNetworkConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            nsg_ids=nsg_ids,
            subnet_id=subnet_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             nsg_ids: Optional[Sequence[str]] = None,
             subnet_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if nsg_ids is None and 'nsgIds' in kwargs:
            nsg_ids = kwargs['nsgIds']
        if nsg_ids is None:
            raise TypeError("Missing 'nsg_ids' argument")
        if subnet_id is None and 'subnetId' in kwargs:
            subnet_id = kwargs['subnetId']
        if subnet_id is None:
            raise TypeError("Missing 'subnet_id' argument")

        _setter("nsg_ids", nsg_ids)
        _setter("subnet_id", subnet_id)

    @property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Sequence[str]:
        """
        The list of Oracle Cloud Identifiers ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) corresponding to Network Security Groups.
        """
        return pulumi.get(self, "nsg_ids")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the subnet.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetRemediationRecipeScmConfigurationResult(dict):
    def __init__(__self__, *,
                 branch: str,
                 build_file_location: str,
                 external_scm_type: str,
                 is_automerge_enabled: bool,
                 oci_code_repository_id: str,
                 pat_secret_id: str,
                 repository_url: str,
                 scm_type: str,
                 username: str):
        """
        :param str branch: The branch used by ADM to patch vulnerabilities.
        :param str build_file_location: The location of the build file relative to the root of the repository. Only Maven build files (POM) are currently supported. If this property is not specified, ADM will use the build file located at the root of the repository.
        :param str external_scm_type: The type of External Source Code Management.
        :param bool is_automerge_enabled: If true, the Pull Request (PR) will be merged after the verify stage completes successfully     If false, the PR with the proposed changes must be reviewed and manually merged.
        :param str oci_code_repository_id: The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Oracle Cloud Infrastructure DevOps repository.
        :param str pat_secret_id: The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Private Access Token (PAT) Secret. The PAT provides the credentials to access the Jenkins Pipeline.
        :param str repository_url: The location of the repository where the GitHub Actions is defined. For Non-Enterprise GitHub the expected format is https://github.com/[owner]/[repoName] For Enterprise GitHub the expected format is http(s)://[hostname]/api/v3/repos/[owner]/[repoName]
        :param str scm_type: The type of Source Code Management.
        :param str username: The username that will be used to authenticate with Jenkins.
        """
        GetRemediationRecipeScmConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            branch=branch,
            build_file_location=build_file_location,
            external_scm_type=external_scm_type,
            is_automerge_enabled=is_automerge_enabled,
            oci_code_repository_id=oci_code_repository_id,
            pat_secret_id=pat_secret_id,
            repository_url=repository_url,
            scm_type=scm_type,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             branch: Optional[str] = None,
             build_file_location: Optional[str] = None,
             external_scm_type: Optional[str] = None,
             is_automerge_enabled: Optional[bool] = None,
             oci_code_repository_id: Optional[str] = None,
             pat_secret_id: Optional[str] = None,
             repository_url: Optional[str] = None,
             scm_type: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if branch is None:
            raise TypeError("Missing 'branch' argument")
        if build_file_location is None and 'buildFileLocation' in kwargs:
            build_file_location = kwargs['buildFileLocation']
        if build_file_location is None:
            raise TypeError("Missing 'build_file_location' argument")
        if external_scm_type is None and 'externalScmType' in kwargs:
            external_scm_type = kwargs['externalScmType']
        if external_scm_type is None:
            raise TypeError("Missing 'external_scm_type' argument")
        if is_automerge_enabled is None and 'isAutomergeEnabled' in kwargs:
            is_automerge_enabled = kwargs['isAutomergeEnabled']
        if is_automerge_enabled is None:
            raise TypeError("Missing 'is_automerge_enabled' argument")
        if oci_code_repository_id is None and 'ociCodeRepositoryId' in kwargs:
            oci_code_repository_id = kwargs['ociCodeRepositoryId']
        if oci_code_repository_id is None:
            raise TypeError("Missing 'oci_code_repository_id' argument")
        if pat_secret_id is None and 'patSecretId' in kwargs:
            pat_secret_id = kwargs['patSecretId']
        if pat_secret_id is None:
            raise TypeError("Missing 'pat_secret_id' argument")
        if repository_url is None and 'repositoryUrl' in kwargs:
            repository_url = kwargs['repositoryUrl']
        if repository_url is None:
            raise TypeError("Missing 'repository_url' argument")
        if scm_type is None and 'scmType' in kwargs:
            scm_type = kwargs['scmType']
        if scm_type is None:
            raise TypeError("Missing 'scm_type' argument")
        if username is None:
            raise TypeError("Missing 'username' argument")

        _setter("branch", branch)
        _setter("build_file_location", build_file_location)
        _setter("external_scm_type", external_scm_type)
        _setter("is_automerge_enabled", is_automerge_enabled)
        _setter("oci_code_repository_id", oci_code_repository_id)
        _setter("pat_secret_id", pat_secret_id)
        _setter("repository_url", repository_url)
        _setter("scm_type", scm_type)
        _setter("username", username)

    @property
    @pulumi.getter
    def branch(self) -> str:
        """
        The branch used by ADM to patch vulnerabilities.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter(name="buildFileLocation")
    def build_file_location(self) -> str:
        """
        The location of the build file relative to the root of the repository. Only Maven build files (POM) are currently supported. If this property is not specified, ADM will use the build file located at the root of the repository.
        """
        return pulumi.get(self, "build_file_location")

    @property
    @pulumi.getter(name="externalScmType")
    def external_scm_type(self) -> str:
        """
        The type of External Source Code Management.
        """
        return pulumi.get(self, "external_scm_type")

    @property
    @pulumi.getter(name="isAutomergeEnabled")
    def is_automerge_enabled(self) -> bool:
        """
        If true, the Pull Request (PR) will be merged after the verify stage completes successfully     If false, the PR with the proposed changes must be reviewed and manually merged.
        """
        return pulumi.get(self, "is_automerge_enabled")

    @property
    @pulumi.getter(name="ociCodeRepositoryId")
    def oci_code_repository_id(self) -> str:
        """
        The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Oracle Cloud Infrastructure DevOps repository.
        """
        return pulumi.get(self, "oci_code_repository_id")

    @property
    @pulumi.getter(name="patSecretId")
    def pat_secret_id(self) -> str:
        """
        The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Private Access Token (PAT) Secret. The PAT provides the credentials to access the Jenkins Pipeline.
        """
        return pulumi.get(self, "pat_secret_id")

    @property
    @pulumi.getter(name="repositoryUrl")
    def repository_url(self) -> str:
        """
        The location of the repository where the GitHub Actions is defined. For Non-Enterprise GitHub the expected format is https://github.com/[owner]/[repoName] For Enterprise GitHub the expected format is http(s)://[hostname]/api/v3/repos/[owner]/[repoName]
        """
        return pulumi.get(self, "repository_url")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> str:
        """
        The type of Source Code Management.
        """
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username that will be used to authenticate with Jenkins.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetRemediationRecipeVerifyConfigurationResult(dict):
    def __init__(__self__, *,
                 additional_parameters: Mapping[str, Any],
                 build_service_type: str,
                 jenkins_url: str,
                 job_name: str,
                 pat_secret_id: str,
                 pipeline_id: str,
                 repository_url: str,
                 trigger_secret_id: str,
                 username: str,
                 workflow_name: str):
        """
        :param Mapping[str, Any] additional_parameters: Additional key-value pairs passed as parameters to the build service when running an experiment.
        :param str build_service_type: The type of Build Service.
        :param str jenkins_url: The URL that locates the Jenkins pipeline.
        :param str job_name: The name of the Jenkins pipeline job that identifies the build pipeline.
        :param str pat_secret_id: The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Private Access Token (PAT) Secret. The PAT provides the credentials to access the Jenkins Pipeline.
        :param str pipeline_id: The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the user's DevOps Build Pipeline.
        :param str repository_url: The location of the repository where the GitHub Actions is defined. For Non-Enterprise GitHub the expected format is https://github.com/[owner]/[repoName] For Enterprise GitHub the expected format is http(s)://[hostname]/api/v3/repos/[owner]/[repoName]
        :param str trigger_secret_id: The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the trigger Secret. The Secret provides access to the trigger for a GitLab pipeline.
        :param str username: The username that will be used to authenticate with Jenkins.
        :param str workflow_name: The name of the GitHub Actions workflow that defines the build pipeline.
        """
        GetRemediationRecipeVerifyConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            additional_parameters=additional_parameters,
            build_service_type=build_service_type,
            jenkins_url=jenkins_url,
            job_name=job_name,
            pat_secret_id=pat_secret_id,
            pipeline_id=pipeline_id,
            repository_url=repository_url,
            trigger_secret_id=trigger_secret_id,
            username=username,
            workflow_name=workflow_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             additional_parameters: Optional[Mapping[str, Any]] = None,
             build_service_type: Optional[str] = None,
             jenkins_url: Optional[str] = None,
             job_name: Optional[str] = None,
             pat_secret_id: Optional[str] = None,
             pipeline_id: Optional[str] = None,
             repository_url: Optional[str] = None,
             trigger_secret_id: Optional[str] = None,
             username: Optional[str] = None,
             workflow_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if additional_parameters is None and 'additionalParameters' in kwargs:
            additional_parameters = kwargs['additionalParameters']
        if additional_parameters is None:
            raise TypeError("Missing 'additional_parameters' argument")
        if build_service_type is None and 'buildServiceType' in kwargs:
            build_service_type = kwargs['buildServiceType']
        if build_service_type is None:
            raise TypeError("Missing 'build_service_type' argument")
        if jenkins_url is None and 'jenkinsUrl' in kwargs:
            jenkins_url = kwargs['jenkinsUrl']
        if jenkins_url is None:
            raise TypeError("Missing 'jenkins_url' argument")
        if job_name is None and 'jobName' in kwargs:
            job_name = kwargs['jobName']
        if job_name is None:
            raise TypeError("Missing 'job_name' argument")
        if pat_secret_id is None and 'patSecretId' in kwargs:
            pat_secret_id = kwargs['patSecretId']
        if pat_secret_id is None:
            raise TypeError("Missing 'pat_secret_id' argument")
        if pipeline_id is None and 'pipelineId' in kwargs:
            pipeline_id = kwargs['pipelineId']
        if pipeline_id is None:
            raise TypeError("Missing 'pipeline_id' argument")
        if repository_url is None and 'repositoryUrl' in kwargs:
            repository_url = kwargs['repositoryUrl']
        if repository_url is None:
            raise TypeError("Missing 'repository_url' argument")
        if trigger_secret_id is None and 'triggerSecretId' in kwargs:
            trigger_secret_id = kwargs['triggerSecretId']
        if trigger_secret_id is None:
            raise TypeError("Missing 'trigger_secret_id' argument")
        if username is None:
            raise TypeError("Missing 'username' argument")
        if workflow_name is None and 'workflowName' in kwargs:
            workflow_name = kwargs['workflowName']
        if workflow_name is None:
            raise TypeError("Missing 'workflow_name' argument")

        _setter("additional_parameters", additional_parameters)
        _setter("build_service_type", build_service_type)
        _setter("jenkins_url", jenkins_url)
        _setter("job_name", job_name)
        _setter("pat_secret_id", pat_secret_id)
        _setter("pipeline_id", pipeline_id)
        _setter("repository_url", repository_url)
        _setter("trigger_secret_id", trigger_secret_id)
        _setter("username", username)
        _setter("workflow_name", workflow_name)

    @property
    @pulumi.getter(name="additionalParameters")
    def additional_parameters(self) -> Mapping[str, Any]:
        """
        Additional key-value pairs passed as parameters to the build service when running an experiment.
        """
        return pulumi.get(self, "additional_parameters")

    @property
    @pulumi.getter(name="buildServiceType")
    def build_service_type(self) -> str:
        """
        The type of Build Service.
        """
        return pulumi.get(self, "build_service_type")

    @property
    @pulumi.getter(name="jenkinsUrl")
    def jenkins_url(self) -> str:
        """
        The URL that locates the Jenkins pipeline.
        """
        return pulumi.get(self, "jenkins_url")

    @property
    @pulumi.getter(name="jobName")
    def job_name(self) -> str:
        """
        The name of the Jenkins pipeline job that identifies the build pipeline.
        """
        return pulumi.get(self, "job_name")

    @property
    @pulumi.getter(name="patSecretId")
    def pat_secret_id(self) -> str:
        """
        The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Private Access Token (PAT) Secret. The PAT provides the credentials to access the Jenkins Pipeline.
        """
        return pulumi.get(self, "pat_secret_id")

    @property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> str:
        """
        The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the user's DevOps Build Pipeline.
        """
        return pulumi.get(self, "pipeline_id")

    @property
    @pulumi.getter(name="repositoryUrl")
    def repository_url(self) -> str:
        """
        The location of the repository where the GitHub Actions is defined. For Non-Enterprise GitHub the expected format is https://github.com/[owner]/[repoName] For Enterprise GitHub the expected format is http(s)://[hostname]/api/v3/repos/[owner]/[repoName]
        """
        return pulumi.get(self, "repository_url")

    @property
    @pulumi.getter(name="triggerSecretId")
    def trigger_secret_id(self) -> str:
        """
        The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the trigger Secret. The Secret provides access to the trigger for a GitLab pipeline.
        """
        return pulumi.get(self, "trigger_secret_id")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username that will be used to authenticate with Jenkins.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="workflowName")
    def workflow_name(self) -> str:
        """
        The name of the GitHub Actions workflow that defines the build pipeline.
        """
        return pulumi.get(self, "workflow_name")


@pulumi.output_type
class GetRemediationRecipesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetRemediationRecipesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetRemediationRecipesRemediationRecipeCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetRemediationRecipesRemediationRecipeCollectionItemResult']):
        GetRemediationRecipesRemediationRecipeCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetRemediationRecipesRemediationRecipeCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetRemediationRecipesRemediationRecipeCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetRemediationRecipesRemediationRecipeCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 detect_configurations: Sequence['outputs.GetRemediationRecipesRemediationRecipeCollectionItemDetectConfigurationResult'],
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 is_run_triggered_on_kb_change: bool,
                 knowledge_base_id: str,
                 network_configurations: Sequence['outputs.GetRemediationRecipesRemediationRecipeCollectionItemNetworkConfigurationResult'],
                 scm_configurations: Sequence['outputs.GetRemediationRecipesRemediationRecipeCollectionItemScmConfigurationResult'],
                 state: str,
                 system_tags: Mapping[str, Any],
                 time_created: str,
                 time_updated: str,
                 verify_configurations: Sequence['outputs.GetRemediationRecipesRemediationRecipeCollectionItemVerifyConfigurationResult']):
        """
        :param str compartment_id: A filter to return only resources that belong to the specified compartment identifier. Required only if the id query param is not specified.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param Sequence['GetRemediationRecipesRemediationRecipeCollectionItemDetectConfigurationArgs'] detect_configurations: A configuration to define the constraints when detecting vulnerable dependencies.
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param Mapping[str, Any] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param str id: A filter to return only resources that match the specified identifier. Required only if the compartmentId query parameter is not specified.
        :param bool is_run_triggered_on_kb_change: Boolean indicating if a run should be automatically triggered once the Knowledge Base contents are updated.
        :param str knowledge_base_id: The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the knowledge base.
        :param Sequence['GetRemediationRecipesRemediationRecipeCollectionItemNetworkConfigurationArgs'] network_configurations: A network configuration defines the required network characteristics for an ADM remediation recipe. A network configuration is required if the build service is one of: GitHub Actions, GitLab Pipeline, or Jenkins Pipeline.
        :param Sequence['GetRemediationRecipesRemediationRecipeCollectionItemScmConfigurationArgs'] scm_configurations: A configuration for the Source Code Management tool/platform used by a remediation recipe.
        :param str state: A filter to return only Remediation Recipes that match the specified lifecycleState.
        :param Mapping[str, Any] system_tags: Usage of system tag keys. These predefined keys are scoped to namespaces. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param str time_created: The creation date and time of the Remediation Recipe (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        :param str time_updated: The date and time the Remediation Recipe was last updated (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        :param Sequence['GetRemediationRecipesRemediationRecipeCollectionItemVerifyConfigurationArgs'] verify_configurations: The Verify stage configuration specifies a build service to run a pipeline for the recommended code changes. The build pipeline will be initiated to ensure that there is no breaking change after the dependency versions have been updated in source to avoid vulnerabilities.
        """
        GetRemediationRecipesRemediationRecipeCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            detect_configurations=detect_configurations,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            is_run_triggered_on_kb_change=is_run_triggered_on_kb_change,
            knowledge_base_id=knowledge_base_id,
            network_configurations=network_configurations,
            scm_configurations=scm_configurations,
            state=state,
            system_tags=system_tags,
            time_created=time_created,
            time_updated=time_updated,
            verify_configurations=verify_configurations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             detect_configurations: Optional[Sequence['outputs.GetRemediationRecipesRemediationRecipeCollectionItemDetectConfigurationResult']] = None,
             display_name: Optional[str] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             is_run_triggered_on_kb_change: Optional[bool] = None,
             knowledge_base_id: Optional[str] = None,
             network_configurations: Optional[Sequence['outputs.GetRemediationRecipesRemediationRecipeCollectionItemNetworkConfigurationResult']] = None,
             scm_configurations: Optional[Sequence['outputs.GetRemediationRecipesRemediationRecipeCollectionItemScmConfigurationResult']] = None,
             state: Optional[str] = None,
             system_tags: Optional[Mapping[str, Any]] = None,
             time_created: Optional[str] = None,
             time_updated: Optional[str] = None,
             verify_configurations: Optional[Sequence['outputs.GetRemediationRecipesRemediationRecipeCollectionItemVerifyConfigurationResult']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if defined_tags is None:
            raise TypeError("Missing 'defined_tags' argument")
        if detect_configurations is None and 'detectConfigurations' in kwargs:
            detect_configurations = kwargs['detectConfigurations']
        if detect_configurations is None:
            raise TypeError("Missing 'detect_configurations' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if freeform_tags is None:
            raise TypeError("Missing 'freeform_tags' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if is_run_triggered_on_kb_change is None and 'isRunTriggeredOnKbChange' in kwargs:
            is_run_triggered_on_kb_change = kwargs['isRunTriggeredOnKbChange']
        if is_run_triggered_on_kb_change is None:
            raise TypeError("Missing 'is_run_triggered_on_kb_change' argument")
        if knowledge_base_id is None and 'knowledgeBaseId' in kwargs:
            knowledge_base_id = kwargs['knowledgeBaseId']
        if knowledge_base_id is None:
            raise TypeError("Missing 'knowledge_base_id' argument")
        if network_configurations is None and 'networkConfigurations' in kwargs:
            network_configurations = kwargs['networkConfigurations']
        if network_configurations is None:
            raise TypeError("Missing 'network_configurations' argument")
        if scm_configurations is None and 'scmConfigurations' in kwargs:
            scm_configurations = kwargs['scmConfigurations']
        if scm_configurations is None:
            raise TypeError("Missing 'scm_configurations' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if system_tags is None and 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if system_tags is None:
            raise TypeError("Missing 'system_tags' argument")
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_created is None:
            raise TypeError("Missing 'time_created' argument")
        if time_updated is None and 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']
        if time_updated is None:
            raise TypeError("Missing 'time_updated' argument")
        if verify_configurations is None and 'verifyConfigurations' in kwargs:
            verify_configurations = kwargs['verifyConfigurations']
        if verify_configurations is None:
            raise TypeError("Missing 'verify_configurations' argument")

        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("detect_configurations", detect_configurations)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("is_run_triggered_on_kb_change", is_run_triggered_on_kb_change)
        _setter("knowledge_base_id", knowledge_base_id)
        _setter("network_configurations", network_configurations)
        _setter("scm_configurations", scm_configurations)
        _setter("state", state)
        _setter("system_tags", system_tags)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)
        _setter("verify_configurations", verify_configurations)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        A filter to return only resources that belong to the specified compartment identifier. Required only if the id query param is not specified.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="detectConfigurations")
    def detect_configurations(self) -> Sequence['outputs.GetRemediationRecipesRemediationRecipeCollectionItemDetectConfigurationResult']:
        """
        A configuration to define the constraints when detecting vulnerable dependencies.
        """
        return pulumi.get(self, "detect_configurations")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        A filter to return only resources that match the specified identifier. Required only if the compartmentId query parameter is not specified.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isRunTriggeredOnKbChange")
    def is_run_triggered_on_kb_change(self) -> bool:
        """
        Boolean indicating if a run should be automatically triggered once the Knowledge Base contents are updated.
        """
        return pulumi.get(self, "is_run_triggered_on_kb_change")

    @property
    @pulumi.getter(name="knowledgeBaseId")
    def knowledge_base_id(self) -> str:
        """
        The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the knowledge base.
        """
        return pulumi.get(self, "knowledge_base_id")

    @property
    @pulumi.getter(name="networkConfigurations")
    def network_configurations(self) -> Sequence['outputs.GetRemediationRecipesRemediationRecipeCollectionItemNetworkConfigurationResult']:
        """
        A network configuration defines the required network characteristics for an ADM remediation recipe. A network configuration is required if the build service is one of: GitHub Actions, GitLab Pipeline, or Jenkins Pipeline.
        """
        return pulumi.get(self, "network_configurations")

    @property
    @pulumi.getter(name="scmConfigurations")
    def scm_configurations(self) -> Sequence['outputs.GetRemediationRecipesRemediationRecipeCollectionItemScmConfigurationResult']:
        """
        A configuration for the Source Code Management tool/platform used by a remediation recipe.
        """
        return pulumi.get(self, "scm_configurations")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only Remediation Recipes that match the specified lifecycleState.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        Usage of system tag keys. These predefined keys are scoped to namespaces. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The creation date and time of the Remediation Recipe (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the Remediation Recipe was last updated (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        """
        return pulumi.get(self, "time_updated")

    @property
    @pulumi.getter(name="verifyConfigurations")
    def verify_configurations(self) -> Sequence['outputs.GetRemediationRecipesRemediationRecipeCollectionItemVerifyConfigurationResult']:
        """
        The Verify stage configuration specifies a build service to run a pipeline for the recommended code changes. The build pipeline will be initiated to ensure that there is no breaking change after the dependency versions have been updated in source to avoid vulnerabilities.
        """
        return pulumi.get(self, "verify_configurations")


@pulumi.output_type
class GetRemediationRecipesRemediationRecipeCollectionItemDetectConfigurationResult(dict):
    def __init__(__self__, *,
                 exclusions: Sequence[str],
                 max_permissible_cvss_v2score: float,
                 max_permissible_cvss_v3score: float,
                 upgrade_policy: str):
        """
        :param Sequence[str] exclusions: The list of dependencies to be ignored by the recommendation algorithm. The dependency pattern is matched against the 'group:artifact:version' or the purl of a dependency. An asterisk (*) at the end in the dependency pattern acts as a wildcard and matches zero or more characters.
        :param float max_permissible_cvss_v2score: The maximum Common Vulnerability Scoring System Version 2 (CVSS V2) score. An artifact with a CVSS V2 score below this value is not considered for patching.
        :param float max_permissible_cvss_v3score: The maximum Common Vulnerability Scoring System Version 3 (CVSS V3) score. An artifact with a CVSS V3 score below this value is not considered for patching.
        :param str upgrade_policy: The upgrade policy for recommendations. The `Nearest` upgrade policy upgrades a dependency to the oldest version that meets both of the following criteria: it is newer than the current version and it is not affected by a vulnerability.
        """
        GetRemediationRecipesRemediationRecipeCollectionItemDetectConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exclusions=exclusions,
            max_permissible_cvss_v2score=max_permissible_cvss_v2score,
            max_permissible_cvss_v3score=max_permissible_cvss_v3score,
            upgrade_policy=upgrade_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exclusions: Optional[Sequence[str]] = None,
             max_permissible_cvss_v2score: Optional[float] = None,
             max_permissible_cvss_v3score: Optional[float] = None,
             upgrade_policy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if exclusions is None:
            raise TypeError("Missing 'exclusions' argument")
        if max_permissible_cvss_v2score is None and 'maxPermissibleCvssV2score' in kwargs:
            max_permissible_cvss_v2score = kwargs['maxPermissibleCvssV2score']
        if max_permissible_cvss_v2score is None:
            raise TypeError("Missing 'max_permissible_cvss_v2score' argument")
        if max_permissible_cvss_v3score is None and 'maxPermissibleCvssV3score' in kwargs:
            max_permissible_cvss_v3score = kwargs['maxPermissibleCvssV3score']
        if max_permissible_cvss_v3score is None:
            raise TypeError("Missing 'max_permissible_cvss_v3score' argument")
        if upgrade_policy is None and 'upgradePolicy' in kwargs:
            upgrade_policy = kwargs['upgradePolicy']
        if upgrade_policy is None:
            raise TypeError("Missing 'upgrade_policy' argument")

        _setter("exclusions", exclusions)
        _setter("max_permissible_cvss_v2score", max_permissible_cvss_v2score)
        _setter("max_permissible_cvss_v3score", max_permissible_cvss_v3score)
        _setter("upgrade_policy", upgrade_policy)

    @property
    @pulumi.getter
    def exclusions(self) -> Sequence[str]:
        """
        The list of dependencies to be ignored by the recommendation algorithm. The dependency pattern is matched against the 'group:artifact:version' or the purl of a dependency. An asterisk (*) at the end in the dependency pattern acts as a wildcard and matches zero or more characters.
        """
        return pulumi.get(self, "exclusions")

    @property
    @pulumi.getter(name="maxPermissibleCvssV2score")
    def max_permissible_cvss_v2score(self) -> float:
        """
        The maximum Common Vulnerability Scoring System Version 2 (CVSS V2) score. An artifact with a CVSS V2 score below this value is not considered for patching.
        """
        return pulumi.get(self, "max_permissible_cvss_v2score")

    @property
    @pulumi.getter(name="maxPermissibleCvssV3score")
    def max_permissible_cvss_v3score(self) -> float:
        """
        The maximum Common Vulnerability Scoring System Version 3 (CVSS V3) score. An artifact with a CVSS V3 score below this value is not considered for patching.
        """
        return pulumi.get(self, "max_permissible_cvss_v3score")

    @property
    @pulumi.getter(name="upgradePolicy")
    def upgrade_policy(self) -> str:
        """
        The upgrade policy for recommendations. The `Nearest` upgrade policy upgrades a dependency to the oldest version that meets both of the following criteria: it is newer than the current version and it is not affected by a vulnerability.
        """
        return pulumi.get(self, "upgrade_policy")


@pulumi.output_type
class GetRemediationRecipesRemediationRecipeCollectionItemNetworkConfigurationResult(dict):
    def __init__(__self__, *,
                 nsg_ids: Sequence[str],
                 subnet_id: str):
        """
        :param Sequence[str] nsg_ids: The list of Oracle Cloud Identifiers ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) corresponding to Network Security Groups.
        :param str subnet_id: The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the subnet.
        """
        GetRemediationRecipesRemediationRecipeCollectionItemNetworkConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            nsg_ids=nsg_ids,
            subnet_id=subnet_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             nsg_ids: Optional[Sequence[str]] = None,
             subnet_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if nsg_ids is None and 'nsgIds' in kwargs:
            nsg_ids = kwargs['nsgIds']
        if nsg_ids is None:
            raise TypeError("Missing 'nsg_ids' argument")
        if subnet_id is None and 'subnetId' in kwargs:
            subnet_id = kwargs['subnetId']
        if subnet_id is None:
            raise TypeError("Missing 'subnet_id' argument")

        _setter("nsg_ids", nsg_ids)
        _setter("subnet_id", subnet_id)

    @property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Sequence[str]:
        """
        The list of Oracle Cloud Identifiers ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) corresponding to Network Security Groups.
        """
        return pulumi.get(self, "nsg_ids")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the subnet.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetRemediationRecipesRemediationRecipeCollectionItemScmConfigurationResult(dict):
    def __init__(__self__, *,
                 branch: str,
                 build_file_location: str,
                 external_scm_type: str,
                 is_automerge_enabled: bool,
                 oci_code_repository_id: str,
                 pat_secret_id: str,
                 repository_url: str,
                 scm_type: str,
                 username: str):
        """
        :param str branch: The branch used by ADM to patch vulnerabilities.
        :param str build_file_location: The location of the build file relative to the root of the repository. Only Maven build files (POM) are currently supported. If this property is not specified, ADM will use the build file located at the root of the repository.
        :param str external_scm_type: The type of External Source Code Management.
        :param bool is_automerge_enabled: If true, the Pull Request (PR) will be merged after the verify stage completes successfully     If false, the PR with the proposed changes must be reviewed and manually merged.
        :param str oci_code_repository_id: The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Oracle Cloud Infrastructure DevOps repository.
        :param str pat_secret_id: The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Private Access Token (PAT) Secret. The PAT provides the credentials to access the Jenkins Pipeline.
        :param str repository_url: The location of the repository where the GitHub Actions is defined. For Non-Enterprise GitHub the expected format is https://github.com/[owner]/[repoName] For Enterprise GitHub the expected format is http(s)://[hostname]/api/v3/repos/[owner]/[repoName]
        :param str scm_type: The type of Source Code Management.
        :param str username: The username that will be used to authenticate with Jenkins.
        """
        GetRemediationRecipesRemediationRecipeCollectionItemScmConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            branch=branch,
            build_file_location=build_file_location,
            external_scm_type=external_scm_type,
            is_automerge_enabled=is_automerge_enabled,
            oci_code_repository_id=oci_code_repository_id,
            pat_secret_id=pat_secret_id,
            repository_url=repository_url,
            scm_type=scm_type,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             branch: Optional[str] = None,
             build_file_location: Optional[str] = None,
             external_scm_type: Optional[str] = None,
             is_automerge_enabled: Optional[bool] = None,
             oci_code_repository_id: Optional[str] = None,
             pat_secret_id: Optional[str] = None,
             repository_url: Optional[str] = None,
             scm_type: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if branch is None:
            raise TypeError("Missing 'branch' argument")
        if build_file_location is None and 'buildFileLocation' in kwargs:
            build_file_location = kwargs['buildFileLocation']
        if build_file_location is None:
            raise TypeError("Missing 'build_file_location' argument")
        if external_scm_type is None and 'externalScmType' in kwargs:
            external_scm_type = kwargs['externalScmType']
        if external_scm_type is None:
            raise TypeError("Missing 'external_scm_type' argument")
        if is_automerge_enabled is None and 'isAutomergeEnabled' in kwargs:
            is_automerge_enabled = kwargs['isAutomergeEnabled']
        if is_automerge_enabled is None:
            raise TypeError("Missing 'is_automerge_enabled' argument")
        if oci_code_repository_id is None and 'ociCodeRepositoryId' in kwargs:
            oci_code_repository_id = kwargs['ociCodeRepositoryId']
        if oci_code_repository_id is None:
            raise TypeError("Missing 'oci_code_repository_id' argument")
        if pat_secret_id is None and 'patSecretId' in kwargs:
            pat_secret_id = kwargs['patSecretId']
        if pat_secret_id is None:
            raise TypeError("Missing 'pat_secret_id' argument")
        if repository_url is None and 'repositoryUrl' in kwargs:
            repository_url = kwargs['repositoryUrl']
        if repository_url is None:
            raise TypeError("Missing 'repository_url' argument")
        if scm_type is None and 'scmType' in kwargs:
            scm_type = kwargs['scmType']
        if scm_type is None:
            raise TypeError("Missing 'scm_type' argument")
        if username is None:
            raise TypeError("Missing 'username' argument")

        _setter("branch", branch)
        _setter("build_file_location", build_file_location)
        _setter("external_scm_type", external_scm_type)
        _setter("is_automerge_enabled", is_automerge_enabled)
        _setter("oci_code_repository_id", oci_code_repository_id)
        _setter("pat_secret_id", pat_secret_id)
        _setter("repository_url", repository_url)
        _setter("scm_type", scm_type)
        _setter("username", username)

    @property
    @pulumi.getter
    def branch(self) -> str:
        """
        The branch used by ADM to patch vulnerabilities.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter(name="buildFileLocation")
    def build_file_location(self) -> str:
        """
        The location of the build file relative to the root of the repository. Only Maven build files (POM) are currently supported. If this property is not specified, ADM will use the build file located at the root of the repository.
        """
        return pulumi.get(self, "build_file_location")

    @property
    @pulumi.getter(name="externalScmType")
    def external_scm_type(self) -> str:
        """
        The type of External Source Code Management.
        """
        return pulumi.get(self, "external_scm_type")

    @property
    @pulumi.getter(name="isAutomergeEnabled")
    def is_automerge_enabled(self) -> bool:
        """
        If true, the Pull Request (PR) will be merged after the verify stage completes successfully     If false, the PR with the proposed changes must be reviewed and manually merged.
        """
        return pulumi.get(self, "is_automerge_enabled")

    @property
    @pulumi.getter(name="ociCodeRepositoryId")
    def oci_code_repository_id(self) -> str:
        """
        The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Oracle Cloud Infrastructure DevOps repository.
        """
        return pulumi.get(self, "oci_code_repository_id")

    @property
    @pulumi.getter(name="patSecretId")
    def pat_secret_id(self) -> str:
        """
        The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Private Access Token (PAT) Secret. The PAT provides the credentials to access the Jenkins Pipeline.
        """
        return pulumi.get(self, "pat_secret_id")

    @property
    @pulumi.getter(name="repositoryUrl")
    def repository_url(self) -> str:
        """
        The location of the repository where the GitHub Actions is defined. For Non-Enterprise GitHub the expected format is https://github.com/[owner]/[repoName] For Enterprise GitHub the expected format is http(s)://[hostname]/api/v3/repos/[owner]/[repoName]
        """
        return pulumi.get(self, "repository_url")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> str:
        """
        The type of Source Code Management.
        """
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username that will be used to authenticate with Jenkins.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetRemediationRecipesRemediationRecipeCollectionItemVerifyConfigurationResult(dict):
    def __init__(__self__, *,
                 additional_parameters: Mapping[str, Any],
                 build_service_type: str,
                 jenkins_url: str,
                 job_name: str,
                 pat_secret_id: str,
                 pipeline_id: str,
                 repository_url: str,
                 trigger_secret_id: str,
                 username: str,
                 workflow_name: str):
        """
        :param Mapping[str, Any] additional_parameters: Additional key-value pairs passed as parameters to the build service when running an experiment.
        :param str build_service_type: The type of Build Service.
        :param str jenkins_url: The URL that locates the Jenkins pipeline.
        :param str job_name: The name of the Jenkins pipeline job that identifies the build pipeline.
        :param str pat_secret_id: The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Private Access Token (PAT) Secret. The PAT provides the credentials to access the Jenkins Pipeline.
        :param str pipeline_id: The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the user's DevOps Build Pipeline.
        :param str repository_url: The location of the repository where the GitHub Actions is defined. For Non-Enterprise GitHub the expected format is https://github.com/[owner]/[repoName] For Enterprise GitHub the expected format is http(s)://[hostname]/api/v3/repos/[owner]/[repoName]
        :param str trigger_secret_id: The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the trigger Secret. The Secret provides access to the trigger for a GitLab pipeline.
        :param str username: The username that will be used to authenticate with Jenkins.
        :param str workflow_name: The name of the GitHub Actions workflow that defines the build pipeline.
        """
        GetRemediationRecipesRemediationRecipeCollectionItemVerifyConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            additional_parameters=additional_parameters,
            build_service_type=build_service_type,
            jenkins_url=jenkins_url,
            job_name=job_name,
            pat_secret_id=pat_secret_id,
            pipeline_id=pipeline_id,
            repository_url=repository_url,
            trigger_secret_id=trigger_secret_id,
            username=username,
            workflow_name=workflow_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             additional_parameters: Optional[Mapping[str, Any]] = None,
             build_service_type: Optional[str] = None,
             jenkins_url: Optional[str] = None,
             job_name: Optional[str] = None,
             pat_secret_id: Optional[str] = None,
             pipeline_id: Optional[str] = None,
             repository_url: Optional[str] = None,
             trigger_secret_id: Optional[str] = None,
             username: Optional[str] = None,
             workflow_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if additional_parameters is None and 'additionalParameters' in kwargs:
            additional_parameters = kwargs['additionalParameters']
        if additional_parameters is None:
            raise TypeError("Missing 'additional_parameters' argument")
        if build_service_type is None and 'buildServiceType' in kwargs:
            build_service_type = kwargs['buildServiceType']
        if build_service_type is None:
            raise TypeError("Missing 'build_service_type' argument")
        if jenkins_url is None and 'jenkinsUrl' in kwargs:
            jenkins_url = kwargs['jenkinsUrl']
        if jenkins_url is None:
            raise TypeError("Missing 'jenkins_url' argument")
        if job_name is None and 'jobName' in kwargs:
            job_name = kwargs['jobName']
        if job_name is None:
            raise TypeError("Missing 'job_name' argument")
        if pat_secret_id is None and 'patSecretId' in kwargs:
            pat_secret_id = kwargs['patSecretId']
        if pat_secret_id is None:
            raise TypeError("Missing 'pat_secret_id' argument")
        if pipeline_id is None and 'pipelineId' in kwargs:
            pipeline_id = kwargs['pipelineId']
        if pipeline_id is None:
            raise TypeError("Missing 'pipeline_id' argument")
        if repository_url is None and 'repositoryUrl' in kwargs:
            repository_url = kwargs['repositoryUrl']
        if repository_url is None:
            raise TypeError("Missing 'repository_url' argument")
        if trigger_secret_id is None and 'triggerSecretId' in kwargs:
            trigger_secret_id = kwargs['triggerSecretId']
        if trigger_secret_id is None:
            raise TypeError("Missing 'trigger_secret_id' argument")
        if username is None:
            raise TypeError("Missing 'username' argument")
        if workflow_name is None and 'workflowName' in kwargs:
            workflow_name = kwargs['workflowName']
        if workflow_name is None:
            raise TypeError("Missing 'workflow_name' argument")

        _setter("additional_parameters", additional_parameters)
        _setter("build_service_type", build_service_type)
        _setter("jenkins_url", jenkins_url)
        _setter("job_name", job_name)
        _setter("pat_secret_id", pat_secret_id)
        _setter("pipeline_id", pipeline_id)
        _setter("repository_url", repository_url)
        _setter("trigger_secret_id", trigger_secret_id)
        _setter("username", username)
        _setter("workflow_name", workflow_name)

    @property
    @pulumi.getter(name="additionalParameters")
    def additional_parameters(self) -> Mapping[str, Any]:
        """
        Additional key-value pairs passed as parameters to the build service when running an experiment.
        """
        return pulumi.get(self, "additional_parameters")

    @property
    @pulumi.getter(name="buildServiceType")
    def build_service_type(self) -> str:
        """
        The type of Build Service.
        """
        return pulumi.get(self, "build_service_type")

    @property
    @pulumi.getter(name="jenkinsUrl")
    def jenkins_url(self) -> str:
        """
        The URL that locates the Jenkins pipeline.
        """
        return pulumi.get(self, "jenkins_url")

    @property
    @pulumi.getter(name="jobName")
    def job_name(self) -> str:
        """
        The name of the Jenkins pipeline job that identifies the build pipeline.
        """
        return pulumi.get(self, "job_name")

    @property
    @pulumi.getter(name="patSecretId")
    def pat_secret_id(self) -> str:
        """
        The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Private Access Token (PAT) Secret. The PAT provides the credentials to access the Jenkins Pipeline.
        """
        return pulumi.get(self, "pat_secret_id")

    @property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> str:
        """
        The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the user's DevOps Build Pipeline.
        """
        return pulumi.get(self, "pipeline_id")

    @property
    @pulumi.getter(name="repositoryUrl")
    def repository_url(self) -> str:
        """
        The location of the repository where the GitHub Actions is defined. For Non-Enterprise GitHub the expected format is https://github.com/[owner]/[repoName] For Enterprise GitHub the expected format is http(s)://[hostname]/api/v3/repos/[owner]/[repoName]
        """
        return pulumi.get(self, "repository_url")

    @property
    @pulumi.getter(name="triggerSecretId")
    def trigger_secret_id(self) -> str:
        """
        The Oracle Cloud Identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the trigger Secret. The Secret provides access to the trigger for a GitLab pipeline.
        """
        return pulumi.get(self, "trigger_secret_id")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username that will be used to authenticate with Jenkins.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="workflowName")
    def workflow_name(self) -> str:
        """
        The name of the GitHub Actions workflow that defines the build pipeline.
        """
        return pulumi.get(self, "workflow_name")


@pulumi.output_type
class GetRemediationRunApplicationDependencyRecommendationsApplicationDependencyRecommendationCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetRemediationRunApplicationDependencyRecommendationsApplicationDependencyRecommendationCollectionItemResult']):
        """
        :param Sequence['GetRemediationRunApplicationDependencyRecommendationsApplicationDependencyRecommendationCollectionItemArgs'] items: List of application recommendation summaries.
        """
        GetRemediationRunApplicationDependencyRecommendationsApplicationDependencyRecommendationCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetRemediationRunApplicationDependencyRecommendationsApplicationDependencyRecommendationCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetRemediationRunApplicationDependencyRecommendationsApplicationDependencyRecommendationCollectionItemResult']:
        """
        List of application recommendation summaries.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetRemediationRunApplicationDependencyRecommendationsApplicationDependencyRecommendationCollectionItemResult(dict):
    def __init__(__self__, *,
                 application_dependency_node_ids: Sequence[str],
                 gav: str,
                 node_id: str,
                 recommended_gav: str):
        """
        :param Sequence[str] application_dependency_node_ids: List of (application dependencies) node identifiers from which this node depends.
        :param str gav: A filter to return only resources that match the entire GAV (Group Artifact Version) identifier given.
        :param str node_id: Unique node identifier of an application dependency with an associated Recommendation, e.g. nodeId1.
        :param str recommended_gav: Recommended application dependency in "group:artifact:version" (GAV) format, e.g. org.graalvm.nativeimage:svm:21.2.0.
        """
        GetRemediationRunApplicationDependencyRecommendationsApplicationDependencyRecommendationCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            application_dependency_node_ids=application_dependency_node_ids,
            gav=gav,
            node_id=node_id,
            recommended_gav=recommended_gav,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             application_dependency_node_ids: Optional[Sequence[str]] = None,
             gav: Optional[str] = None,
             node_id: Optional[str] = None,
             recommended_gav: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if application_dependency_node_ids is None and 'applicationDependencyNodeIds' in kwargs:
            application_dependency_node_ids = kwargs['applicationDependencyNodeIds']
        if application_dependency_node_ids is None:
            raise TypeError("Missing 'application_dependency_node_ids' argument")
        if gav is None:
            raise TypeError("Missing 'gav' argument")
        if node_id is None and 'nodeId' in kwargs:
            node_id = kwargs['nodeId']
        if node_id is None:
            raise TypeError("Missing 'node_id' argument")
        if recommended_gav is None and 'recommendedGav' in kwargs:
            recommended_gav = kwargs['recommendedGav']
        if recommended_gav is None:
            raise TypeError("Missing 'recommended_gav' argument")

        _setter("application_dependency_node_ids", application_dependency_node_ids)
        _setter("gav", gav)
        _setter("node_id", node_id)
        _setter("recommended_gav", recommended_gav)

    @property
    @pulumi.getter(name="applicationDependencyNodeIds")
    def application_dependency_node_ids(self) -> Sequence[str]:
        """
        List of (application dependencies) node identifiers from which this node depends.
        """
        return pulumi.get(self, "application_dependency_node_ids")

    @property
    @pulumi.getter
    def gav(self) -> str:
        """
        A filter to return only resources that match the entire GAV (Group Artifact Version) identifier given.
        """
        return pulumi.get(self, "gav")

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> str:
        """
        Unique node identifier of an application dependency with an associated Recommendation, e.g. nodeId1.
        """
        return pulumi.get(self, "node_id")

    @property
    @pulumi.getter(name="recommendedGav")
    def recommended_gav(self) -> str:
        """
        Recommended application dependency in "group:artifact:version" (GAV) format, e.g. org.graalvm.nativeimage:svm:21.2.0.
        """
        return pulumi.get(self, "recommended_gav")


@pulumi.output_type
class GetRemediationRunApplicationDependencyRecommendationsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetRemediationRunApplicationDependencyRecommendationsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetRemediationRunStageResult(dict):
    def __init__(__self__, *,
                 summary: str,
                 time_created: str,
                 time_finished: str,
                 time_started: str,
                 type: str):
        """
        :param str summary: Information about the current step within the given stage.
        :param str time_created: The creation date and time of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        :param str time_finished: The date and time of the finish of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        :param str time_started: The date and time of the start of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        :param str type: The type of stage.
        """
        GetRemediationRunStageResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            summary=summary,
            time_created=time_created,
            time_finished=time_finished,
            time_started=time_started,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             summary: Optional[str] = None,
             time_created: Optional[str] = None,
             time_finished: Optional[str] = None,
             time_started: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if summary is None:
            raise TypeError("Missing 'summary' argument")
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_created is None:
            raise TypeError("Missing 'time_created' argument")
        if time_finished is None and 'timeFinished' in kwargs:
            time_finished = kwargs['timeFinished']
        if time_finished is None:
            raise TypeError("Missing 'time_finished' argument")
        if time_started is None and 'timeStarted' in kwargs:
            time_started = kwargs['timeStarted']
        if time_started is None:
            raise TypeError("Missing 'time_started' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("summary", summary)
        _setter("time_created", time_created)
        _setter("time_finished", time_finished)
        _setter("time_started", time_started)
        _setter("type", type)

    @property
    @pulumi.getter
    def summary(self) -> str:
        """
        Information about the current step within the given stage.
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The creation date and time of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeFinished")
    def time_finished(self) -> str:
        """
        The date and time of the finish of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        """
        return pulumi.get(self, "time_finished")

    @property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> str:
        """
        The date and time of the start of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        """
        return pulumi.get(self, "time_started")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of stage.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetRemediationRunStagePipelinePropertyResult(dict):
    def __init__(__self__, *,
                 pipeline_identifier: str,
                 pipeline_url: str):
        """
        :param str pipeline_identifier: Unique identifier for the pipeline or action created in the Verify stage.
        :param str pipeline_url: The web link to the pipeline from the Verify stage.
        """
        GetRemediationRunStagePipelinePropertyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pipeline_identifier=pipeline_identifier,
            pipeline_url=pipeline_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pipeline_identifier: Optional[str] = None,
             pipeline_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if pipeline_identifier is None and 'pipelineIdentifier' in kwargs:
            pipeline_identifier = kwargs['pipelineIdentifier']
        if pipeline_identifier is None:
            raise TypeError("Missing 'pipeline_identifier' argument")
        if pipeline_url is None and 'pipelineUrl' in kwargs:
            pipeline_url = kwargs['pipelineUrl']
        if pipeline_url is None:
            raise TypeError("Missing 'pipeline_url' argument")

        _setter("pipeline_identifier", pipeline_identifier)
        _setter("pipeline_url", pipeline_url)

    @property
    @pulumi.getter(name="pipelineIdentifier")
    def pipeline_identifier(self) -> str:
        """
        Unique identifier for the pipeline or action created in the Verify stage.
        """
        return pulumi.get(self, "pipeline_identifier")

    @property
    @pulumi.getter(name="pipelineUrl")
    def pipeline_url(self) -> str:
        """
        The web link to the pipeline from the Verify stage.
        """
        return pulumi.get(self, "pipeline_url")


@pulumi.output_type
class GetRemediationRunStagePullRequestPropertyResult(dict):
    def __init__(__self__, *,
                 pull_request_identifier: str,
                 pull_request_url: str):
        """
        :param str pull_request_identifier: Unique identifier for the pull or merge request created in the recommend stage.
        :param str pull_request_url: The web link to the pull or merge request created in the recommend stage.
        """
        GetRemediationRunStagePullRequestPropertyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pull_request_identifier=pull_request_identifier,
            pull_request_url=pull_request_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pull_request_identifier: Optional[str] = None,
             pull_request_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if pull_request_identifier is None and 'pullRequestIdentifier' in kwargs:
            pull_request_identifier = kwargs['pullRequestIdentifier']
        if pull_request_identifier is None:
            raise TypeError("Missing 'pull_request_identifier' argument")
        if pull_request_url is None and 'pullRequestUrl' in kwargs:
            pull_request_url = kwargs['pullRequestUrl']
        if pull_request_url is None:
            raise TypeError("Missing 'pull_request_url' argument")

        _setter("pull_request_identifier", pull_request_identifier)
        _setter("pull_request_url", pull_request_url)

    @property
    @pulumi.getter(name="pullRequestIdentifier")
    def pull_request_identifier(self) -> str:
        """
        Unique identifier for the pull or merge request created in the recommend stage.
        """
        return pulumi.get(self, "pull_request_identifier")

    @property
    @pulumi.getter(name="pullRequestUrl")
    def pull_request_url(self) -> str:
        """
        The web link to the pull or merge request created in the recommend stage.
        """
        return pulumi.get(self, "pull_request_url")


@pulumi.output_type
class GetRemediationRunStagesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetRemediationRunStagesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetRemediationRunStagesRemediationRunStageCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetRemediationRunStagesRemediationRunStageCollectionItemResult']):
        GetRemediationRunStagesRemediationRunStageCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetRemediationRunStagesRemediationRunStageCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetRemediationRunStagesRemediationRunStageCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetRemediationRunStagesRemediationRunStageCollectionItemResult(dict):
    def __init__(__self__, *,
                 audit_id: str,
                 next_stage_type: str,
                 pipeline_properties: Sequence['outputs.GetRemediationRunStagesRemediationRunStageCollectionItemPipelinePropertyResult'],
                 previous_stage_type: str,
                 pull_request_properties: Sequence['outputs.GetRemediationRunStagesRemediationRunStageCollectionItemPullRequestPropertyResult'],
                 recommended_updates_count: int,
                 remediation_run_id: str,
                 status: str,
                 summary: str,
                 time_created: str,
                 time_finished: str,
                 time_started: str,
                 type: str):
        """
        :param str audit_id: The Oracle Cloud identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the vulnerability audit.
        :param str next_stage_type: The next type of stage in the remediation run.
        :param Sequence['GetRemediationRunStagesRemediationRunStageCollectionItemPipelinePropertyArgs'] pipeline_properties: Pipeline properties which result from the run of the verify stage.
        :param str previous_stage_type: The previous type of stage in the remediation run.
        :param Sequence['GetRemediationRunStagesRemediationRunStageCollectionItemPullRequestPropertyArgs'] pull_request_properties: Pull request properties from recommend stage of the remediation run.
        :param int recommended_updates_count: Count of recommended application dependencies to update.
        :param str remediation_run_id: Unique Remediation Run identifier path parameter.
        :param str status: A filter to return only Stages that match the specified status.
        :param str summary: Information about the current step within the stage.
        :param str time_created: The creation date and time of the remediation run stage (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        :param str time_finished: The date and time of the finish of the remediation run stage (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        :param str time_started: The date and time of the start of the remediation run stage (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        :param str type: A filter to return only Stages that match the specified type.
        """
        GetRemediationRunStagesRemediationRunStageCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audit_id=audit_id,
            next_stage_type=next_stage_type,
            pipeline_properties=pipeline_properties,
            previous_stage_type=previous_stage_type,
            pull_request_properties=pull_request_properties,
            recommended_updates_count=recommended_updates_count,
            remediation_run_id=remediation_run_id,
            status=status,
            summary=summary,
            time_created=time_created,
            time_finished=time_finished,
            time_started=time_started,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audit_id: Optional[str] = None,
             next_stage_type: Optional[str] = None,
             pipeline_properties: Optional[Sequence['outputs.GetRemediationRunStagesRemediationRunStageCollectionItemPipelinePropertyResult']] = None,
             previous_stage_type: Optional[str] = None,
             pull_request_properties: Optional[Sequence['outputs.GetRemediationRunStagesRemediationRunStageCollectionItemPullRequestPropertyResult']] = None,
             recommended_updates_count: Optional[int] = None,
             remediation_run_id: Optional[str] = None,
             status: Optional[str] = None,
             summary: Optional[str] = None,
             time_created: Optional[str] = None,
             time_finished: Optional[str] = None,
             time_started: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if audit_id is None and 'auditId' in kwargs:
            audit_id = kwargs['auditId']
        if audit_id is None:
            raise TypeError("Missing 'audit_id' argument")
        if next_stage_type is None and 'nextStageType' in kwargs:
            next_stage_type = kwargs['nextStageType']
        if next_stage_type is None:
            raise TypeError("Missing 'next_stage_type' argument")
        if pipeline_properties is None and 'pipelineProperties' in kwargs:
            pipeline_properties = kwargs['pipelineProperties']
        if pipeline_properties is None:
            raise TypeError("Missing 'pipeline_properties' argument")
        if previous_stage_type is None and 'previousStageType' in kwargs:
            previous_stage_type = kwargs['previousStageType']
        if previous_stage_type is None:
            raise TypeError("Missing 'previous_stage_type' argument")
        if pull_request_properties is None and 'pullRequestProperties' in kwargs:
            pull_request_properties = kwargs['pullRequestProperties']
        if pull_request_properties is None:
            raise TypeError("Missing 'pull_request_properties' argument")
        if recommended_updates_count is None and 'recommendedUpdatesCount' in kwargs:
            recommended_updates_count = kwargs['recommendedUpdatesCount']
        if recommended_updates_count is None:
            raise TypeError("Missing 'recommended_updates_count' argument")
        if remediation_run_id is None and 'remediationRunId' in kwargs:
            remediation_run_id = kwargs['remediationRunId']
        if remediation_run_id is None:
            raise TypeError("Missing 'remediation_run_id' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if summary is None:
            raise TypeError("Missing 'summary' argument")
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_created is None:
            raise TypeError("Missing 'time_created' argument")
        if time_finished is None and 'timeFinished' in kwargs:
            time_finished = kwargs['timeFinished']
        if time_finished is None:
            raise TypeError("Missing 'time_finished' argument")
        if time_started is None and 'timeStarted' in kwargs:
            time_started = kwargs['timeStarted']
        if time_started is None:
            raise TypeError("Missing 'time_started' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("audit_id", audit_id)
        _setter("next_stage_type", next_stage_type)
        _setter("pipeline_properties", pipeline_properties)
        _setter("previous_stage_type", previous_stage_type)
        _setter("pull_request_properties", pull_request_properties)
        _setter("recommended_updates_count", recommended_updates_count)
        _setter("remediation_run_id", remediation_run_id)
        _setter("status", status)
        _setter("summary", summary)
        _setter("time_created", time_created)
        _setter("time_finished", time_finished)
        _setter("time_started", time_started)
        _setter("type", type)

    @property
    @pulumi.getter(name="auditId")
    def audit_id(self) -> str:
        """
        The Oracle Cloud identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the vulnerability audit.
        """
        return pulumi.get(self, "audit_id")

    @property
    @pulumi.getter(name="nextStageType")
    def next_stage_type(self) -> str:
        """
        The next type of stage in the remediation run.
        """
        return pulumi.get(self, "next_stage_type")

    @property
    @pulumi.getter(name="pipelineProperties")
    def pipeline_properties(self) -> Sequence['outputs.GetRemediationRunStagesRemediationRunStageCollectionItemPipelinePropertyResult']:
        """
        Pipeline properties which result from the run of the verify stage.
        """
        return pulumi.get(self, "pipeline_properties")

    @property
    @pulumi.getter(name="previousStageType")
    def previous_stage_type(self) -> str:
        """
        The previous type of stage in the remediation run.
        """
        return pulumi.get(self, "previous_stage_type")

    @property
    @pulumi.getter(name="pullRequestProperties")
    def pull_request_properties(self) -> Sequence['outputs.GetRemediationRunStagesRemediationRunStageCollectionItemPullRequestPropertyResult']:
        """
        Pull request properties from recommend stage of the remediation run.
        """
        return pulumi.get(self, "pull_request_properties")

    @property
    @pulumi.getter(name="recommendedUpdatesCount")
    def recommended_updates_count(self) -> int:
        """
        Count of recommended application dependencies to update.
        """
        return pulumi.get(self, "recommended_updates_count")

    @property
    @pulumi.getter(name="remediationRunId")
    def remediation_run_id(self) -> str:
        """
        Unique Remediation Run identifier path parameter.
        """
        return pulumi.get(self, "remediation_run_id")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        A filter to return only Stages that match the specified status.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def summary(self) -> str:
        """
        Information about the current step within the stage.
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The creation date and time of the remediation run stage (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeFinished")
    def time_finished(self) -> str:
        """
        The date and time of the finish of the remediation run stage (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        """
        return pulumi.get(self, "time_finished")

    @property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> str:
        """
        The date and time of the start of the remediation run stage (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        """
        return pulumi.get(self, "time_started")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        A filter to return only Stages that match the specified type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetRemediationRunStagesRemediationRunStageCollectionItemPipelinePropertyResult(dict):
    def __init__(__self__, *,
                 pipeline_identifier: str,
                 pipeline_url: str):
        """
        :param str pipeline_identifier: Unique identifier for the pipeline or action created in the Verify stage.
        :param str pipeline_url: The web link to the pipeline from the Verify stage.
        """
        GetRemediationRunStagesRemediationRunStageCollectionItemPipelinePropertyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pipeline_identifier=pipeline_identifier,
            pipeline_url=pipeline_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pipeline_identifier: Optional[str] = None,
             pipeline_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if pipeline_identifier is None and 'pipelineIdentifier' in kwargs:
            pipeline_identifier = kwargs['pipelineIdentifier']
        if pipeline_identifier is None:
            raise TypeError("Missing 'pipeline_identifier' argument")
        if pipeline_url is None and 'pipelineUrl' in kwargs:
            pipeline_url = kwargs['pipelineUrl']
        if pipeline_url is None:
            raise TypeError("Missing 'pipeline_url' argument")

        _setter("pipeline_identifier", pipeline_identifier)
        _setter("pipeline_url", pipeline_url)

    @property
    @pulumi.getter(name="pipelineIdentifier")
    def pipeline_identifier(self) -> str:
        """
        Unique identifier for the pipeline or action created in the Verify stage.
        """
        return pulumi.get(self, "pipeline_identifier")

    @property
    @pulumi.getter(name="pipelineUrl")
    def pipeline_url(self) -> str:
        """
        The web link to the pipeline from the Verify stage.
        """
        return pulumi.get(self, "pipeline_url")


@pulumi.output_type
class GetRemediationRunStagesRemediationRunStageCollectionItemPullRequestPropertyResult(dict):
    def __init__(__self__, *,
                 pull_request_identifier: str,
                 pull_request_url: str):
        """
        :param str pull_request_identifier: Unique identifier for the pull or merge request created in the recommend stage.
        :param str pull_request_url: The web link to the pull or merge request created in the recommend stage.
        """
        GetRemediationRunStagesRemediationRunStageCollectionItemPullRequestPropertyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pull_request_identifier=pull_request_identifier,
            pull_request_url=pull_request_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pull_request_identifier: Optional[str] = None,
             pull_request_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if pull_request_identifier is None and 'pullRequestIdentifier' in kwargs:
            pull_request_identifier = kwargs['pullRequestIdentifier']
        if pull_request_identifier is None:
            raise TypeError("Missing 'pull_request_identifier' argument")
        if pull_request_url is None and 'pullRequestUrl' in kwargs:
            pull_request_url = kwargs['pullRequestUrl']
        if pull_request_url is None:
            raise TypeError("Missing 'pull_request_url' argument")

        _setter("pull_request_identifier", pull_request_identifier)
        _setter("pull_request_url", pull_request_url)

    @property
    @pulumi.getter(name="pullRequestIdentifier")
    def pull_request_identifier(self) -> str:
        """
        Unique identifier for the pull or merge request created in the recommend stage.
        """
        return pulumi.get(self, "pull_request_identifier")

    @property
    @pulumi.getter(name="pullRequestUrl")
    def pull_request_url(self) -> str:
        """
        The web link to the pull or merge request created in the recommend stage.
        """
        return pulumi.get(self, "pull_request_url")


@pulumi.output_type
class GetRemediationRunsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetRemediationRunsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetRemediationRunsRemediationRunCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetRemediationRunsRemediationRunCollectionItemResult']):
        GetRemediationRunsRemediationRunCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetRemediationRunsRemediationRunCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetRemediationRunsRemediationRunCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetRemediationRunsRemediationRunCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 current_stage_type: str,
                 defined_tags: Mapping[str, Any],
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 remediation_recipe_id: str,
                 remediation_run_source: str,
                 stages: Sequence['outputs.GetRemediationRunsRemediationRunCollectionItemStageResult'],
                 state: str,
                 system_tags: Mapping[str, Any],
                 time_created: str,
                 time_finished: str,
                 time_started: str,
                 time_updated: str):
        """
        :param str compartment_id: A filter to return only resources that belong to the specified compartment identifier. Required only if the id query param is not specified.
        :param str current_stage_type: The type of the current stage of the remediation run.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param Mapping[str, Any] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param str id: A filter to return only resources that match the specified identifier. Required only if the compartmentId query parameter is not specified.
        :param str remediation_recipe_id: A filter to return only resources that match the specified Remediation Recipe identifier.
        :param str remediation_run_source: The source that triggered the Remediation Recipe.
        :param Sequence['GetRemediationRunsRemediationRunCollectionItemStageArgs'] stages: The list of remediation run stage summaries.
        :param str state: A filter to return only Remediation Runs that match the specified lifecycleState.
        :param Mapping[str, Any] system_tags: Usage of system tag keys. These predefined keys are scoped to namespaces. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param str time_created: The creation date and time of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        :param str time_finished: The date and time of the finish of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        :param str time_started: The date and time of the start of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        :param str time_updated: The date and time the remediation run was last updated (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        """
        GetRemediationRunsRemediationRunCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            current_stage_type=current_stage_type,
            defined_tags=defined_tags,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            remediation_recipe_id=remediation_recipe_id,
            remediation_run_source=remediation_run_source,
            stages=stages,
            state=state,
            system_tags=system_tags,
            time_created=time_created,
            time_finished=time_finished,
            time_started=time_started,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: Optional[str] = None,
             current_stage_type: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             display_name: Optional[str] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             remediation_recipe_id: Optional[str] = None,
             remediation_run_source: Optional[str] = None,
             stages: Optional[Sequence['outputs.GetRemediationRunsRemediationRunCollectionItemStageResult']] = None,
             state: Optional[str] = None,
             system_tags: Optional[Mapping[str, Any]] = None,
             time_created: Optional[str] = None,
             time_finished: Optional[str] = None,
             time_started: Optional[str] = None,
             time_updated: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if current_stage_type is None and 'currentStageType' in kwargs:
            current_stage_type = kwargs['currentStageType']
        if current_stage_type is None:
            raise TypeError("Missing 'current_stage_type' argument")
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if defined_tags is None:
            raise TypeError("Missing 'defined_tags' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if freeform_tags is None:
            raise TypeError("Missing 'freeform_tags' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if remediation_recipe_id is None and 'remediationRecipeId' in kwargs:
            remediation_recipe_id = kwargs['remediationRecipeId']
        if remediation_recipe_id is None:
            raise TypeError("Missing 'remediation_recipe_id' argument")
        if remediation_run_source is None and 'remediationRunSource' in kwargs:
            remediation_run_source = kwargs['remediationRunSource']
        if remediation_run_source is None:
            raise TypeError("Missing 'remediation_run_source' argument")
        if stages is None:
            raise TypeError("Missing 'stages' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if system_tags is None and 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if system_tags is None:
            raise TypeError("Missing 'system_tags' argument")
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_created is None:
            raise TypeError("Missing 'time_created' argument")
        if time_finished is None and 'timeFinished' in kwargs:
            time_finished = kwargs['timeFinished']
        if time_finished is None:
            raise TypeError("Missing 'time_finished' argument")
        if time_started is None and 'timeStarted' in kwargs:
            time_started = kwargs['timeStarted']
        if time_started is None:
            raise TypeError("Missing 'time_started' argument")
        if time_updated is None and 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']
        if time_updated is None:
            raise TypeError("Missing 'time_updated' argument")

        _setter("compartment_id", compartment_id)
        _setter("current_stage_type", current_stage_type)
        _setter("defined_tags", defined_tags)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("remediation_recipe_id", remediation_recipe_id)
        _setter("remediation_run_source", remediation_run_source)
        _setter("stages", stages)
        _setter("state", state)
        _setter("system_tags", system_tags)
        _setter("time_created", time_created)
        _setter("time_finished", time_finished)
        _setter("time_started", time_started)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        A filter to return only resources that belong to the specified compartment identifier. Required only if the id query param is not specified.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="currentStageType")
    def current_stage_type(self) -> str:
        """
        The type of the current stage of the remediation run.
        """
        return pulumi.get(self, "current_stage_type")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        A filter to return only resources that match the specified identifier. Required only if the compartmentId query parameter is not specified.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="remediationRecipeId")
    def remediation_recipe_id(self) -> str:
        """
        A filter to return only resources that match the specified Remediation Recipe identifier.
        """
        return pulumi.get(self, "remediation_recipe_id")

    @property
    @pulumi.getter(name="remediationRunSource")
    def remediation_run_source(self) -> str:
        """
        The source that triggered the Remediation Recipe.
        """
        return pulumi.get(self, "remediation_run_source")

    @property
    @pulumi.getter
    def stages(self) -> Sequence['outputs.GetRemediationRunsRemediationRunCollectionItemStageResult']:
        """
        The list of remediation run stage summaries.
        """
        return pulumi.get(self, "stages")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only Remediation Runs that match the specified lifecycleState.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        Usage of system tag keys. These predefined keys are scoped to namespaces. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The creation date and time of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeFinished")
    def time_finished(self) -> str:
        """
        The date and time of the finish of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        """
        return pulumi.get(self, "time_finished")

    @property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> str:
        """
        The date and time of the start of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        """
        return pulumi.get(self, "time_started")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the remediation run was last updated (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetRemediationRunsRemediationRunCollectionItemStageResult(dict):
    def __init__(__self__, *,
                 summary: str,
                 time_created: str,
                 time_finished: str,
                 time_started: str,
                 type: str):
        """
        :param str summary: Information about the current step within the given stage.
        :param str time_created: The creation date and time of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        :param str time_finished: The date and time of the finish of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        :param str time_started: The date and time of the start of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        :param str type: The type of stage.
        """
        GetRemediationRunsRemediationRunCollectionItemStageResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            summary=summary,
            time_created=time_created,
            time_finished=time_finished,
            time_started=time_started,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             summary: Optional[str] = None,
             time_created: Optional[str] = None,
             time_finished: Optional[str] = None,
             time_started: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if summary is None:
            raise TypeError("Missing 'summary' argument")
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_created is None:
            raise TypeError("Missing 'time_created' argument")
        if time_finished is None and 'timeFinished' in kwargs:
            time_finished = kwargs['timeFinished']
        if time_finished is None:
            raise TypeError("Missing 'time_finished' argument")
        if time_started is None and 'timeStarted' in kwargs:
            time_started = kwargs['timeStarted']
        if time_started is None:
            raise TypeError("Missing 'time_started' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("summary", summary)
        _setter("time_created", time_created)
        _setter("time_finished", time_finished)
        _setter("time_started", time_started)
        _setter("type", type)

    @property
    @pulumi.getter
    def summary(self) -> str:
        """
        Information about the current step within the given stage.
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The creation date and time of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeFinished")
    def time_finished(self) -> str:
        """
        The date and time of the finish of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        """
        return pulumi.get(self, "time_finished")

    @property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> str:
        """
        The date and time of the start of the remediation run (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        """
        return pulumi.get(self, "time_started")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of stage.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetVulnerabilityAuditApplicationDependencyResult(dict):
    def __init__(__self__, *,
                 application_dependency_node_ids: Sequence[str],
                 gav: str,
                 node_id: str):
        GetVulnerabilityAuditApplicationDependencyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            application_dependency_node_ids=application_dependency_node_ids,
            gav=gav,
            node_id=node_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             application_dependency_node_ids: Optional[Sequence[str]] = None,
             gav: Optional[str] = None,
             node_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if application_dependency_node_ids is None and 'applicationDependencyNodeIds' in kwargs:
            application_dependency_node_ids = kwargs['applicationDependencyNodeIds']
        if application_dependency_node_ids is None:
            raise TypeError("Missing 'application_dependency_node_ids' argument")
        if gav is None:
            raise TypeError("Missing 'gav' argument")
        if node_id is None and 'nodeId' in kwargs:
            node_id = kwargs['nodeId']
        if node_id is None:
            raise TypeError("Missing 'node_id' argument")

        _setter("application_dependency_node_ids", application_dependency_node_ids)
        _setter("gav", gav)
        _setter("node_id", node_id)

    @property
    @pulumi.getter(name="applicationDependencyNodeIds")
    def application_dependency_node_ids(self) -> Sequence[str]:
        return pulumi.get(self, "application_dependency_node_ids")

    @property
    @pulumi.getter
    def gav(self) -> str:
        return pulumi.get(self, "gav")

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> str:
        return pulumi.get(self, "node_id")


@pulumi.output_type
class GetVulnerabilityAuditApplicationDependencyVulnerabilitiesApplicationDependencyVulnerabilityCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetVulnerabilityAuditApplicationDependencyVulnerabilitiesApplicationDependencyVulnerabilityCollectionItemResult']):
        """
        :param Sequence['GetVulnerabilityAuditApplicationDependencyVulnerabilitiesApplicationDependencyVulnerabilityCollectionItemArgs'] items: List of vulnerability audit summaries.
        """
        GetVulnerabilityAuditApplicationDependencyVulnerabilitiesApplicationDependencyVulnerabilityCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetVulnerabilityAuditApplicationDependencyVulnerabilitiesApplicationDependencyVulnerabilityCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetVulnerabilityAuditApplicationDependencyVulnerabilitiesApplicationDependencyVulnerabilityCollectionItemResult']:
        """
        List of vulnerability audit summaries.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetVulnerabilityAuditApplicationDependencyVulnerabilitiesApplicationDependencyVulnerabilityCollectionItemResult(dict):
    def __init__(__self__, *,
                 application_dependency_node_ids: Sequence[str],
                 gav: str,
                 is_found_in_knowledge_base: bool,
                 node_id: str,
                 vulnerabilities: Sequence['outputs.GetVulnerabilityAuditApplicationDependencyVulnerabilitiesApplicationDependencyVulnerabilityCollectionItemVulnerabilityResult']):
        """
        :param Sequence[str] application_dependency_node_ids: List of application dependencies on which this application dependency depends, each identified by its nodeId.
        :param str gav: A filter to return only resources that match the entire GAV (Group Artifact Version) identifier given.
        :param bool is_found_in_knowledge_base: Indicates if the artifact is found in the knowledge base.
        :param str node_id: Unique identifier of an application dependency, for example nodeId1.
        :param Sequence['GetVulnerabilityAuditApplicationDependencyVulnerabilitiesApplicationDependencyVulnerabilityCollectionItemVulnerabilityArgs'] vulnerabilities: List of vulnerabilities for the application dependency.
        """
        GetVulnerabilityAuditApplicationDependencyVulnerabilitiesApplicationDependencyVulnerabilityCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            application_dependency_node_ids=application_dependency_node_ids,
            gav=gav,
            is_found_in_knowledge_base=is_found_in_knowledge_base,
            node_id=node_id,
            vulnerabilities=vulnerabilities,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             application_dependency_node_ids: Optional[Sequence[str]] = None,
             gav: Optional[str] = None,
             is_found_in_knowledge_base: Optional[bool] = None,
             node_id: Optional[str] = None,
             vulnerabilities: Optional[Sequence['outputs.GetVulnerabilityAuditApplicationDependencyVulnerabilitiesApplicationDependencyVulnerabilityCollectionItemVulnerabilityResult']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if application_dependency_node_ids is None and 'applicationDependencyNodeIds' in kwargs:
            application_dependency_node_ids = kwargs['applicationDependencyNodeIds']
        if application_dependency_node_ids is None:
            raise TypeError("Missing 'application_dependency_node_ids' argument")
        if gav is None:
            raise TypeError("Missing 'gav' argument")
        if is_found_in_knowledge_base is None and 'isFoundInKnowledgeBase' in kwargs:
            is_found_in_knowledge_base = kwargs['isFoundInKnowledgeBase']
        if is_found_in_knowledge_base is None:
            raise TypeError("Missing 'is_found_in_knowledge_base' argument")
        if node_id is None and 'nodeId' in kwargs:
            node_id = kwargs['nodeId']
        if node_id is None:
            raise TypeError("Missing 'node_id' argument")
        if vulnerabilities is None:
            raise TypeError("Missing 'vulnerabilities' argument")

        _setter("application_dependency_node_ids", application_dependency_node_ids)
        _setter("gav", gav)
        _setter("is_found_in_knowledge_base", is_found_in_knowledge_base)
        _setter("node_id", node_id)
        _setter("vulnerabilities", vulnerabilities)

    @property
    @pulumi.getter(name="applicationDependencyNodeIds")
    def application_dependency_node_ids(self) -> Sequence[str]:
        """
        List of application dependencies on which this application dependency depends, each identified by its nodeId.
        """
        return pulumi.get(self, "application_dependency_node_ids")

    @property
    @pulumi.getter
    def gav(self) -> str:
        """
        A filter to return only resources that match the entire GAV (Group Artifact Version) identifier given.
        """
        return pulumi.get(self, "gav")

    @property
    @pulumi.getter(name="isFoundInKnowledgeBase")
    def is_found_in_knowledge_base(self) -> bool:
        """
        Indicates if the artifact is found in the knowledge base.
        """
        return pulumi.get(self, "is_found_in_knowledge_base")

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> str:
        """
        Unique identifier of an application dependency, for example nodeId1.
        """
        return pulumi.get(self, "node_id")

    @property
    @pulumi.getter
    def vulnerabilities(self) -> Sequence['outputs.GetVulnerabilityAuditApplicationDependencyVulnerabilitiesApplicationDependencyVulnerabilityCollectionItemVulnerabilityResult']:
        """
        List of vulnerabilities for the application dependency.
        """
        return pulumi.get(self, "vulnerabilities")


@pulumi.output_type
class GetVulnerabilityAuditApplicationDependencyVulnerabilitiesApplicationDependencyVulnerabilityCollectionItemVulnerabilityResult(dict):
    def __init__(__self__, *,
                 cvss_v2score: float,
                 cvss_v3score: float,
                 id: str,
                 is_ignored: bool):
        """
        :param float cvss_v2score: Common Vulnerability Scoring System (CVSS) Version 2.
        :param float cvss_v3score: Common Vulnerability Scoring System (CVSS) Version 3.
        :param str id: Unique vulnerability identifier, e.g. CVE-1999-0067.
        :param bool is_ignored: Indicates if the vulnerability was ignored according to the audit configuration.
        """
        GetVulnerabilityAuditApplicationDependencyVulnerabilitiesApplicationDependencyVulnerabilityCollectionItemVulnerabilityResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cvss_v2score=cvss_v2score,
            cvss_v3score=cvss_v3score,
            id=id,
            is_ignored=is_ignored,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cvss_v2score: Optional[float] = None,
             cvss_v3score: Optional[float] = None,
             id: Optional[str] = None,
             is_ignored: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if cvss_v2score is None and 'cvssV2score' in kwargs:
            cvss_v2score = kwargs['cvssV2score']
        if cvss_v2score is None:
            raise TypeError("Missing 'cvss_v2score' argument")
        if cvss_v3score is None and 'cvssV3score' in kwargs:
            cvss_v3score = kwargs['cvssV3score']
        if cvss_v3score is None:
            raise TypeError("Missing 'cvss_v3score' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if is_ignored is None and 'isIgnored' in kwargs:
            is_ignored = kwargs['isIgnored']
        if is_ignored is None:
            raise TypeError("Missing 'is_ignored' argument")

        _setter("cvss_v2score", cvss_v2score)
        _setter("cvss_v3score", cvss_v3score)
        _setter("id", id)
        _setter("is_ignored", is_ignored)

    @property
    @pulumi.getter(name="cvssV2score")
    def cvss_v2score(self) -> float:
        """
        Common Vulnerability Scoring System (CVSS) Version 2.
        """
        return pulumi.get(self, "cvss_v2score")

    @property
    @pulumi.getter(name="cvssV3score")
    def cvss_v3score(self) -> float:
        """
        Common Vulnerability Scoring System (CVSS) Version 3.
        """
        return pulumi.get(self, "cvss_v3score")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique vulnerability identifier, e.g. CVE-1999-0067.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isIgnored")
    def is_ignored(self) -> bool:
        """
        Indicates if the vulnerability was ignored according to the audit configuration.
        """
        return pulumi.get(self, "is_ignored")


@pulumi.output_type
class GetVulnerabilityAuditApplicationDependencyVulnerabilitiesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetVulnerabilityAuditApplicationDependencyVulnerabilitiesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetVulnerabilityAuditApplicationDependencyVulnerabilityItemResult(dict):
    def __init__(__self__, *,
                 application_dependency_node_ids: Sequence[str],
                 gav: str,
                 is_found_in_knowledge_base: bool,
                 node_id: str,
                 vulnerabilities: Sequence['outputs.GetVulnerabilityAuditApplicationDependencyVulnerabilityItemVulnerabilityResult']):
        """
        :param Sequence[str] application_dependency_node_ids: List of Application Dependencies on which this Application Dependency depends, each identified by its nodeId.
        :param str gav: A filter to return only resources that match the entire GAV (Group Artifact Version) identifier given.
        :param bool is_found_in_knowledge_base: Indicates if the artifact is found in the knowledge base.
        :param str node_id: Unique identifier of an Application Dependency, for example nodeId1.
        :param Sequence['GetVulnerabilityAuditApplicationDependencyVulnerabilityItemVulnerabilityArgs'] vulnerabilities: List of vulnerabilities for the Application Dependency.
        """
        GetVulnerabilityAuditApplicationDependencyVulnerabilityItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            application_dependency_node_ids=application_dependency_node_ids,
            gav=gav,
            is_found_in_knowledge_base=is_found_in_knowledge_base,
            node_id=node_id,
            vulnerabilities=vulnerabilities,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             application_dependency_node_ids: Optional[Sequence[str]] = None,
             gav: Optional[str] = None,
             is_found_in_knowledge_base: Optional[bool] = None,
             node_id: Optional[str] = None,
             vulnerabilities: Optional[Sequence['outputs.GetVulnerabilityAuditApplicationDependencyVulnerabilityItemVulnerabilityResult']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if application_dependency_node_ids is None and 'applicationDependencyNodeIds' in kwargs:
            application_dependency_node_ids = kwargs['applicationDependencyNodeIds']
        if application_dependency_node_ids is None:
            raise TypeError("Missing 'application_dependency_node_ids' argument")
        if gav is None:
            raise TypeError("Missing 'gav' argument")
        if is_found_in_knowledge_base is None and 'isFoundInKnowledgeBase' in kwargs:
            is_found_in_knowledge_base = kwargs['isFoundInKnowledgeBase']
        if is_found_in_knowledge_base is None:
            raise TypeError("Missing 'is_found_in_knowledge_base' argument")
        if node_id is None and 'nodeId' in kwargs:
            node_id = kwargs['nodeId']
        if node_id is None:
            raise TypeError("Missing 'node_id' argument")
        if vulnerabilities is None:
            raise TypeError("Missing 'vulnerabilities' argument")

        _setter("application_dependency_node_ids", application_dependency_node_ids)
        _setter("gav", gav)
        _setter("is_found_in_knowledge_base", is_found_in_knowledge_base)
        _setter("node_id", node_id)
        _setter("vulnerabilities", vulnerabilities)

    @property
    @pulumi.getter(name="applicationDependencyNodeIds")
    def application_dependency_node_ids(self) -> Sequence[str]:
        """
        List of Application Dependencies on which this Application Dependency depends, each identified by its nodeId.
        """
        return pulumi.get(self, "application_dependency_node_ids")

    @property
    @pulumi.getter
    def gav(self) -> str:
        """
        A filter to return only resources that match the entire GAV (Group Artifact Version) identifier given.
        """
        return pulumi.get(self, "gav")

    @property
    @pulumi.getter(name="isFoundInKnowledgeBase")
    def is_found_in_knowledge_base(self) -> bool:
        """
        Indicates if the artifact is found in the knowledge base.
        """
        return pulumi.get(self, "is_found_in_knowledge_base")

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> str:
        """
        Unique identifier of an Application Dependency, for example nodeId1.
        """
        return pulumi.get(self, "node_id")

    @property
    @pulumi.getter
    def vulnerabilities(self) -> Sequence['outputs.GetVulnerabilityAuditApplicationDependencyVulnerabilityItemVulnerabilityResult']:
        """
        List of vulnerabilities for the Application Dependency.
        """
        return pulumi.get(self, "vulnerabilities")


@pulumi.output_type
class GetVulnerabilityAuditApplicationDependencyVulnerabilityItemVulnerabilityResult(dict):
    def __init__(__self__, *,
                 cvss_v2score: float,
                 cvss_v3score: float,
                 id: str,
                 is_ignored: bool):
        """
        :param float cvss_v2score: Common Vulnerability Scoring System (CVSS) Version 2.
        :param float cvss_v3score: Common Vulnerability Scoring System (CVSS) Version 3.
        :param str id: Unique vulnerability identifier, e.g. CVE-1999-0067.
        :param bool is_ignored: Indicates if the vulnerability was ignored according to the audit configuration.
        """
        GetVulnerabilityAuditApplicationDependencyVulnerabilityItemVulnerabilityResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cvss_v2score=cvss_v2score,
            cvss_v3score=cvss_v3score,
            id=id,
            is_ignored=is_ignored,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cvss_v2score: Optional[float] = None,
             cvss_v3score: Optional[float] = None,
             id: Optional[str] = None,
             is_ignored: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if cvss_v2score is None and 'cvssV2score' in kwargs:
            cvss_v2score = kwargs['cvssV2score']
        if cvss_v2score is None:
            raise TypeError("Missing 'cvss_v2score' argument")
        if cvss_v3score is None and 'cvssV3score' in kwargs:
            cvss_v3score = kwargs['cvssV3score']
        if cvss_v3score is None:
            raise TypeError("Missing 'cvss_v3score' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if is_ignored is None and 'isIgnored' in kwargs:
            is_ignored = kwargs['isIgnored']
        if is_ignored is None:
            raise TypeError("Missing 'is_ignored' argument")

        _setter("cvss_v2score", cvss_v2score)
        _setter("cvss_v3score", cvss_v3score)
        _setter("id", id)
        _setter("is_ignored", is_ignored)

    @property
    @pulumi.getter(name="cvssV2score")
    def cvss_v2score(self) -> float:
        """
        Common Vulnerability Scoring System (CVSS) Version 2.
        """
        return pulumi.get(self, "cvss_v2score")

    @property
    @pulumi.getter(name="cvssV3score")
    def cvss_v3score(self) -> float:
        """
        Common Vulnerability Scoring System (CVSS) Version 3.
        """
        return pulumi.get(self, "cvss_v3score")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique vulnerability identifier, e.g. CVE-1999-0067.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isIgnored")
    def is_ignored(self) -> bool:
        """
        Indicates if the vulnerability was ignored according to the audit configuration.
        """
        return pulumi.get(self, "is_ignored")


@pulumi.output_type
class GetVulnerabilityAuditConfigurationResult(dict):
    def __init__(__self__, *,
                 exclusions: Sequence[str],
                 max_permissible_cvss_v2score: float,
                 max_permissible_cvss_v3score: float):
        """
        :param Sequence[str] exclusions: A vulnerable application dependency is ignored if its name matches any of the items in `exclusions`. An asterisk (*) in the dependency pattern acts as a wildcard and matches zero or more characters.
        :param float max_permissible_cvss_v2score: A vulnerable application dependency is ignored if the score of its associated Vulnerability is below maxPermissibleCvssV2Score and below maxPermissibleCvssV3Score.
        :param float max_permissible_cvss_v3score: A vulnerable application dependency is ignored if the score of its associated Vulnerability is below maxPermissibleCvssV2Score and below maxPermissibleCvssV3Score.
        """
        GetVulnerabilityAuditConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exclusions=exclusions,
            max_permissible_cvss_v2score=max_permissible_cvss_v2score,
            max_permissible_cvss_v3score=max_permissible_cvss_v3score,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exclusions: Optional[Sequence[str]] = None,
             max_permissible_cvss_v2score: Optional[float] = None,
             max_permissible_cvss_v3score: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if exclusions is None:
            raise TypeError("Missing 'exclusions' argument")
        if max_permissible_cvss_v2score is None and 'maxPermissibleCvssV2score' in kwargs:
            max_permissible_cvss_v2score = kwargs['maxPermissibleCvssV2score']
        if max_permissible_cvss_v2score is None:
            raise TypeError("Missing 'max_permissible_cvss_v2score' argument")
        if max_permissible_cvss_v3score is None and 'maxPermissibleCvssV3score' in kwargs:
            max_permissible_cvss_v3score = kwargs['maxPermissibleCvssV3score']
        if max_permissible_cvss_v3score is None:
            raise TypeError("Missing 'max_permissible_cvss_v3score' argument")

        _setter("exclusions", exclusions)
        _setter("max_permissible_cvss_v2score", max_permissible_cvss_v2score)
        _setter("max_permissible_cvss_v3score", max_permissible_cvss_v3score)

    @property
    @pulumi.getter
    def exclusions(self) -> Sequence[str]:
        """
        A vulnerable application dependency is ignored if its name matches any of the items in `exclusions`. An asterisk (*) in the dependency pattern acts as a wildcard and matches zero or more characters.
        """
        return pulumi.get(self, "exclusions")

    @property
    @pulumi.getter(name="maxPermissibleCvssV2score")
    def max_permissible_cvss_v2score(self) -> float:
        """
        A vulnerable application dependency is ignored if the score of its associated Vulnerability is below maxPermissibleCvssV2Score and below maxPermissibleCvssV3Score.
        """
        return pulumi.get(self, "max_permissible_cvss_v2score")

    @property
    @pulumi.getter(name="maxPermissibleCvssV3score")
    def max_permissible_cvss_v3score(self) -> float:
        """
        A vulnerable application dependency is ignored if the score of its associated Vulnerability is below maxPermissibleCvssV2Score and below maxPermissibleCvssV3Score.
        """
        return pulumi.get(self, "max_permissible_cvss_v3score")


@pulumi.output_type
class GetVulnerabilityAuditSourceResult(dict):
    def __init__(__self__, *,
                 description: str,
                 oci_resource_id: str,
                 type: str):
        """
        :param str description: Description of the external resource source.
        :param str oci_resource_id: The Oracle Cloud identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Oracle Cloud Infrastructure resource that triggered the vulnerability audit.
        :param str type: Source type of the vulnerability audit.
        """
        GetVulnerabilityAuditSourceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            oci_resource_id=oci_resource_id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             oci_resource_id: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if oci_resource_id is None and 'ociResourceId' in kwargs:
            oci_resource_id = kwargs['ociResourceId']
        if oci_resource_id is None:
            raise TypeError("Missing 'oci_resource_id' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("description", description)
        _setter("oci_resource_id", oci_resource_id)
        _setter("type", type)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of the external resource source.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="ociResourceId")
    def oci_resource_id(self) -> str:
        """
        The Oracle Cloud identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Oracle Cloud Infrastructure resource that triggered the vulnerability audit.
        """
        return pulumi.get(self, "oci_resource_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Source type of the vulnerability audit.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetVulnerabilityAuditVulnerabilityResult(dict):
    def __init__(__self__, *,
                 cvss_v2score: float,
                 cvss_v3score: float,
                 id: str,
                 is_ignored: bool):
        """
        :param float cvss_v2score: Common Vulnerability Scoring System (CVSS) Version 2.
        :param float cvss_v3score: Common Vulnerability Scoring System (CVSS) Version 3.
        :param str id: Unique vulnerability identifier, e.g. CVE-1999-0067.
        :param bool is_ignored: Indicates if the vulnerability was ignored according to the audit configuration.
        """
        GetVulnerabilityAuditVulnerabilityResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cvss_v2score=cvss_v2score,
            cvss_v3score=cvss_v3score,
            id=id,
            is_ignored=is_ignored,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cvss_v2score: Optional[float] = None,
             cvss_v3score: Optional[float] = None,
             id: Optional[str] = None,
             is_ignored: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if cvss_v2score is None and 'cvssV2score' in kwargs:
            cvss_v2score = kwargs['cvssV2score']
        if cvss_v2score is None:
            raise TypeError("Missing 'cvss_v2score' argument")
        if cvss_v3score is None and 'cvssV3score' in kwargs:
            cvss_v3score = kwargs['cvssV3score']
        if cvss_v3score is None:
            raise TypeError("Missing 'cvss_v3score' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if is_ignored is None and 'isIgnored' in kwargs:
            is_ignored = kwargs['isIgnored']
        if is_ignored is None:
            raise TypeError("Missing 'is_ignored' argument")

        _setter("cvss_v2score", cvss_v2score)
        _setter("cvss_v3score", cvss_v3score)
        _setter("id", id)
        _setter("is_ignored", is_ignored)

    @property
    @pulumi.getter(name="cvssV2score")
    def cvss_v2score(self) -> float:
        """
        Common Vulnerability Scoring System (CVSS) Version 2.
        """
        return pulumi.get(self, "cvss_v2score")

    @property
    @pulumi.getter(name="cvssV3score")
    def cvss_v3score(self) -> float:
        """
        Common Vulnerability Scoring System (CVSS) Version 3.
        """
        return pulumi.get(self, "cvss_v3score")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique vulnerability identifier, e.g. CVE-1999-0067.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isIgnored")
    def is_ignored(self) -> bool:
        """
        Indicates if the vulnerability was ignored according to the audit configuration.
        """
        return pulumi.get(self, "is_ignored")


@pulumi.output_type
class GetVulnerabilityAuditsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetVulnerabilityAuditsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetVulnerabilityAuditsVulnerabilityAuditCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetVulnerabilityAuditsVulnerabilityAuditCollectionItemResult']):
        GetVulnerabilityAuditsVulnerabilityAuditCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Optional[Sequence['outputs.GetVulnerabilityAuditsVulnerabilityAuditCollectionItemResult']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if items is None:
            raise TypeError("Missing 'items' argument")

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetVulnerabilityAuditsVulnerabilityAuditCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetVulnerabilityAuditsVulnerabilityAuditCollectionItemResult(dict):
    def __init__(__self__, *,
                 application_dependencies: Sequence['outputs.GetVulnerabilityAuditsVulnerabilityAuditCollectionItemApplicationDependencyResult'],
                 build_type: str,
                 compartment_id: str,
                 configurations: Sequence['outputs.GetVulnerabilityAuditsVulnerabilityAuditCollectionItemConfigurationResult'],
                 defined_tags: Mapping[str, Any],
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 is_success: bool,
                 knowledge_base_id: str,
                 max_observed_cvss_v2score: float,
                 max_observed_cvss_v2score_with_ignored: float,
                 max_observed_cvss_v3score: float,
                 max_observed_cvss_v3score_with_ignored: float,
                 sources: Sequence['outputs.GetVulnerabilityAuditsVulnerabilityAuditCollectionItemSourceResult'],
                 state: str,
                 system_tags: Mapping[str, Any],
                 time_created: str,
                 time_updated: str,
                 vulnerabilities: Sequence['outputs.GetVulnerabilityAuditsVulnerabilityAuditCollectionItemVulnerabilityResult'],
                 vulnerable_artifacts_count: int,
                 vulnerable_artifacts_count_with_ignored: int):
        """
        :param str build_type: The type of the build tool.
        :param str compartment_id: A filter to return only resources that belong to the specified compartment identifier. Required only if the id query param is not specified.
        :param Sequence['GetVulnerabilityAuditsVulnerabilityAuditCollectionItemConfigurationArgs'] configurations: Configuration for a vulnerability audit. A vulnerable application dependency is ignored if its name does match any of the items in `exclusions`, or all of the associated Vulnerabilies have a CVSS v2 score below `maxPermissibleCvssV2Score` and a CVSS v3 score below `maxPermissibleCvssV3Score`. type: object
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param Mapping[str, Any] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param str id: A filter to return only resources that match the specified identifier. Required only if the compartmentId query parameter is not specified.
        :param bool is_success: A filter to return only successful or failed Vulnerability Audits.
        :param str knowledge_base_id: A filter to return only Vulnerability Audits that were created against the specified knowledge base.
        :param float max_observed_cvss_v2score: Maximum Common Vulnerability Scoring System Version 2 score observed for non-ignored vulnerable application dependencies.
        :param float max_observed_cvss_v2score_with_ignored: Maximum Common Vulnerability Scoring System Version 2 score observed for vulnerable application dependencies including ignored ones.
        :param float max_observed_cvss_v3score: Maximum Common Vulnerability Scoring System Version 3 score observed for non-ignored vulnerable application dependencies.
        :param float max_observed_cvss_v3score_with_ignored: Maximum Common Vulnerability Scoring System Version 3 score observed for vulnerable application dependencies including ignored ones.
        :param Sequence['GetVulnerabilityAuditsVulnerabilityAuditCollectionItemSourceArgs'] sources: vulnerability audit source.
        :param str state: A filter to return only Vulnerability Audits that match the specified lifecycleState.
        :param Mapping[str, Any] system_tags: Usage of system tag keys. These predefined keys are scoped to namespaces. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param str time_created: The creation date and time of the vulnerability audit (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        :param str time_updated: The update date and time of the vulnerability audit (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        :param Sequence['GetVulnerabilityAuditsVulnerabilityAuditCollectionItemVulnerabilityArgs'] vulnerabilities: List of vulnerabilities found in the vulnerability audit.
        :param int vulnerable_artifacts_count: Count of non-ignored vulnerable application dependencies.
        :param int vulnerable_artifacts_count_with_ignored: Count of all vulnerable application dependencies.
        """
        GetVulnerabilityAuditsVulnerabilityAuditCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            application_dependencies=application_dependencies,
            build_type=build_type,
            compartment_id=compartment_id,
            configurations=configurations,
            defined_tags=defined_tags,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            is_success=is_success,
            knowledge_base_id=knowledge_base_id,
            max_observed_cvss_v2score=max_observed_cvss_v2score,
            max_observed_cvss_v2score_with_ignored=max_observed_cvss_v2score_with_ignored,
            max_observed_cvss_v3score=max_observed_cvss_v3score,
            max_observed_cvss_v3score_with_ignored=max_observed_cvss_v3score_with_ignored,
            sources=sources,
            state=state,
            system_tags=system_tags,
            time_created=time_created,
            time_updated=time_updated,
            vulnerabilities=vulnerabilities,
            vulnerable_artifacts_count=vulnerable_artifacts_count,
            vulnerable_artifacts_count_with_ignored=vulnerable_artifacts_count_with_ignored,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             application_dependencies: Optional[Sequence['outputs.GetVulnerabilityAuditsVulnerabilityAuditCollectionItemApplicationDependencyResult']] = None,
             build_type: Optional[str] = None,
             compartment_id: Optional[str] = None,
             configurations: Optional[Sequence['outputs.GetVulnerabilityAuditsVulnerabilityAuditCollectionItemConfigurationResult']] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             display_name: Optional[str] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             is_success: Optional[bool] = None,
             knowledge_base_id: Optional[str] = None,
             max_observed_cvss_v2score: Optional[float] = None,
             max_observed_cvss_v2score_with_ignored: Optional[float] = None,
             max_observed_cvss_v3score: Optional[float] = None,
             max_observed_cvss_v3score_with_ignored: Optional[float] = None,
             sources: Optional[Sequence['outputs.GetVulnerabilityAuditsVulnerabilityAuditCollectionItemSourceResult']] = None,
             state: Optional[str] = None,
             system_tags: Optional[Mapping[str, Any]] = None,
             time_created: Optional[str] = None,
             time_updated: Optional[str] = None,
             vulnerabilities: Optional[Sequence['outputs.GetVulnerabilityAuditsVulnerabilityAuditCollectionItemVulnerabilityResult']] = None,
             vulnerable_artifacts_count: Optional[int] = None,
             vulnerable_artifacts_count_with_ignored: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if application_dependencies is None and 'applicationDependencies' in kwargs:
            application_dependencies = kwargs['applicationDependencies']
        if application_dependencies is None:
            raise TypeError("Missing 'application_dependencies' argument")
        if build_type is None and 'buildType' in kwargs:
            build_type = kwargs['buildType']
        if build_type is None:
            raise TypeError("Missing 'build_type' argument")
        if compartment_id is None and 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if compartment_id is None:
            raise TypeError("Missing 'compartment_id' argument")
        if configurations is None:
            raise TypeError("Missing 'configurations' argument")
        if defined_tags is None and 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if defined_tags is None:
            raise TypeError("Missing 'defined_tags' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if freeform_tags is None and 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if freeform_tags is None:
            raise TypeError("Missing 'freeform_tags' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if is_success is None and 'isSuccess' in kwargs:
            is_success = kwargs['isSuccess']
        if is_success is None:
            raise TypeError("Missing 'is_success' argument")
        if knowledge_base_id is None and 'knowledgeBaseId' in kwargs:
            knowledge_base_id = kwargs['knowledgeBaseId']
        if knowledge_base_id is None:
            raise TypeError("Missing 'knowledge_base_id' argument")
        if max_observed_cvss_v2score is None and 'maxObservedCvssV2score' in kwargs:
            max_observed_cvss_v2score = kwargs['maxObservedCvssV2score']
        if max_observed_cvss_v2score is None:
            raise TypeError("Missing 'max_observed_cvss_v2score' argument")
        if max_observed_cvss_v2score_with_ignored is None and 'maxObservedCvssV2scoreWithIgnored' in kwargs:
            max_observed_cvss_v2score_with_ignored = kwargs['maxObservedCvssV2scoreWithIgnored']
        if max_observed_cvss_v2score_with_ignored is None:
            raise TypeError("Missing 'max_observed_cvss_v2score_with_ignored' argument")
        if max_observed_cvss_v3score is None and 'maxObservedCvssV3score' in kwargs:
            max_observed_cvss_v3score = kwargs['maxObservedCvssV3score']
        if max_observed_cvss_v3score is None:
            raise TypeError("Missing 'max_observed_cvss_v3score' argument")
        if max_observed_cvss_v3score_with_ignored is None and 'maxObservedCvssV3scoreWithIgnored' in kwargs:
            max_observed_cvss_v3score_with_ignored = kwargs['maxObservedCvssV3scoreWithIgnored']
        if max_observed_cvss_v3score_with_ignored is None:
            raise TypeError("Missing 'max_observed_cvss_v3score_with_ignored' argument")
        if sources is None:
            raise TypeError("Missing 'sources' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if system_tags is None and 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if system_tags is None:
            raise TypeError("Missing 'system_tags' argument")
        if time_created is None and 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if time_created is None:
            raise TypeError("Missing 'time_created' argument")
        if time_updated is None and 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']
        if time_updated is None:
            raise TypeError("Missing 'time_updated' argument")
        if vulnerabilities is None:
            raise TypeError("Missing 'vulnerabilities' argument")
        if vulnerable_artifacts_count is None and 'vulnerableArtifactsCount' in kwargs:
            vulnerable_artifacts_count = kwargs['vulnerableArtifactsCount']
        if vulnerable_artifacts_count is None:
            raise TypeError("Missing 'vulnerable_artifacts_count' argument")
        if vulnerable_artifacts_count_with_ignored is None and 'vulnerableArtifactsCountWithIgnored' in kwargs:
            vulnerable_artifacts_count_with_ignored = kwargs['vulnerableArtifactsCountWithIgnored']
        if vulnerable_artifacts_count_with_ignored is None:
            raise TypeError("Missing 'vulnerable_artifacts_count_with_ignored' argument")

        _setter("application_dependencies", application_dependencies)
        _setter("build_type", build_type)
        _setter("compartment_id", compartment_id)
        _setter("configurations", configurations)
        _setter("defined_tags", defined_tags)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("is_success", is_success)
        _setter("knowledge_base_id", knowledge_base_id)
        _setter("max_observed_cvss_v2score", max_observed_cvss_v2score)
        _setter("max_observed_cvss_v2score_with_ignored", max_observed_cvss_v2score_with_ignored)
        _setter("max_observed_cvss_v3score", max_observed_cvss_v3score)
        _setter("max_observed_cvss_v3score_with_ignored", max_observed_cvss_v3score_with_ignored)
        _setter("sources", sources)
        _setter("state", state)
        _setter("system_tags", system_tags)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)
        _setter("vulnerabilities", vulnerabilities)
        _setter("vulnerable_artifacts_count", vulnerable_artifacts_count)
        _setter("vulnerable_artifacts_count_with_ignored", vulnerable_artifacts_count_with_ignored)

    @property
    @pulumi.getter(name="applicationDependencies")
    def application_dependencies(self) -> Sequence['outputs.GetVulnerabilityAuditsVulnerabilityAuditCollectionItemApplicationDependencyResult']:
        return pulumi.get(self, "application_dependencies")

    @property
    @pulumi.getter(name="buildType")
    def build_type(self) -> str:
        """
        The type of the build tool.
        """
        return pulumi.get(self, "build_type")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        A filter to return only resources that belong to the specified compartment identifier. Required only if the id query param is not specified.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def configurations(self) -> Sequence['outputs.GetVulnerabilityAuditsVulnerabilityAuditCollectionItemConfigurationResult']:
        """
        Configuration for a vulnerability audit. A vulnerable application dependency is ignored if its name does match any of the items in `exclusions`, or all of the associated Vulnerabilies have a CVSS v2 score below `maxPermissibleCvssV2Score` and a CVSS v3 score below `maxPermissibleCvssV3Score`. type: object
        """
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        A filter to return only resources that match the specified identifier. Required only if the compartmentId query parameter is not specified.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> bool:
        """
        A filter to return only successful or failed Vulnerability Audits.
        """
        return pulumi.get(self, "is_success")

    @property
    @pulumi.getter(name="knowledgeBaseId")
    def knowledge_base_id(self) -> str:
        """
        A filter to return only Vulnerability Audits that were created against the specified knowledge base.
        """
        return pulumi.get(self, "knowledge_base_id")

    @property
    @pulumi.getter(name="maxObservedCvssV2score")
    def max_observed_cvss_v2score(self) -> float:
        """
        Maximum Common Vulnerability Scoring System Version 2 score observed for non-ignored vulnerable application dependencies.
        """
        return pulumi.get(self, "max_observed_cvss_v2score")

    @property
    @pulumi.getter(name="maxObservedCvssV2scoreWithIgnored")
    def max_observed_cvss_v2score_with_ignored(self) -> float:
        """
        Maximum Common Vulnerability Scoring System Version 2 score observed for vulnerable application dependencies including ignored ones.
        """
        return pulumi.get(self, "max_observed_cvss_v2score_with_ignored")

    @property
    @pulumi.getter(name="maxObservedCvssV3score")
    def max_observed_cvss_v3score(self) -> float:
        """
        Maximum Common Vulnerability Scoring System Version 3 score observed for non-ignored vulnerable application dependencies.
        """
        return pulumi.get(self, "max_observed_cvss_v3score")

    @property
    @pulumi.getter(name="maxObservedCvssV3scoreWithIgnored")
    def max_observed_cvss_v3score_with_ignored(self) -> float:
        """
        Maximum Common Vulnerability Scoring System Version 3 score observed for vulnerable application dependencies including ignored ones.
        """
        return pulumi.get(self, "max_observed_cvss_v3score_with_ignored")

    @property
    @pulumi.getter
    def sources(self) -> Sequence['outputs.GetVulnerabilityAuditsVulnerabilityAuditCollectionItemSourceResult']:
        """
        vulnerability audit source.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only Vulnerability Audits that match the specified lifecycleState.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        Usage of system tag keys. These predefined keys are scoped to namespaces. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The creation date and time of the vulnerability audit (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The update date and time of the vulnerability audit (formatted according to [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339)).
        """
        return pulumi.get(self, "time_updated")

    @property
    @pulumi.getter
    def vulnerabilities(self) -> Sequence['outputs.GetVulnerabilityAuditsVulnerabilityAuditCollectionItemVulnerabilityResult']:
        """
        List of vulnerabilities found in the vulnerability audit.
        """
        return pulumi.get(self, "vulnerabilities")

    @property
    @pulumi.getter(name="vulnerableArtifactsCount")
    def vulnerable_artifacts_count(self) -> int:
        """
        Count of non-ignored vulnerable application dependencies.
        """
        return pulumi.get(self, "vulnerable_artifacts_count")

    @property
    @pulumi.getter(name="vulnerableArtifactsCountWithIgnored")
    def vulnerable_artifacts_count_with_ignored(self) -> int:
        """
        Count of all vulnerable application dependencies.
        """
        return pulumi.get(self, "vulnerable_artifacts_count_with_ignored")


@pulumi.output_type
class GetVulnerabilityAuditsVulnerabilityAuditCollectionItemApplicationDependencyResult(dict):
    def __init__(__self__, *,
                 application_dependency_node_ids: Sequence[str],
                 gav: str,
                 node_id: str):
        GetVulnerabilityAuditsVulnerabilityAuditCollectionItemApplicationDependencyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            application_dependency_node_ids=application_dependency_node_ids,
            gav=gav,
            node_id=node_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             application_dependency_node_ids: Optional[Sequence[str]] = None,
             gav: Optional[str] = None,
             node_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if application_dependency_node_ids is None and 'applicationDependencyNodeIds' in kwargs:
            application_dependency_node_ids = kwargs['applicationDependencyNodeIds']
        if application_dependency_node_ids is None:
            raise TypeError("Missing 'application_dependency_node_ids' argument")
        if gav is None:
            raise TypeError("Missing 'gav' argument")
        if node_id is None and 'nodeId' in kwargs:
            node_id = kwargs['nodeId']
        if node_id is None:
            raise TypeError("Missing 'node_id' argument")

        _setter("application_dependency_node_ids", application_dependency_node_ids)
        _setter("gav", gav)
        _setter("node_id", node_id)

    @property
    @pulumi.getter(name="applicationDependencyNodeIds")
    def application_dependency_node_ids(self) -> Sequence[str]:
        return pulumi.get(self, "application_dependency_node_ids")

    @property
    @pulumi.getter
    def gav(self) -> str:
        return pulumi.get(self, "gav")

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> str:
        return pulumi.get(self, "node_id")


@pulumi.output_type
class GetVulnerabilityAuditsVulnerabilityAuditCollectionItemConfigurationResult(dict):
    def __init__(__self__, *,
                 exclusions: Sequence[str],
                 max_permissible_cvss_v2score: float,
                 max_permissible_cvss_v3score: float):
        """
        :param Sequence[str] exclusions: A vulnerable application dependency is ignored if its name matches any of the items in `exclusions`. An asterisk (*) in the dependency pattern acts as a wildcard and matches zero or more characters.
        :param float max_permissible_cvss_v2score: A vulnerable application dependency is ignored if the score of its associated Vulnerability is below maxPermissibleCvssV2Score and below maxPermissibleCvssV3Score.
        :param float max_permissible_cvss_v3score: A vulnerable application dependency is ignored if the score of its associated Vulnerability is below maxPermissibleCvssV2Score and below maxPermissibleCvssV3Score.
        """
        GetVulnerabilityAuditsVulnerabilityAuditCollectionItemConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exclusions=exclusions,
            max_permissible_cvss_v2score=max_permissible_cvss_v2score,
            max_permissible_cvss_v3score=max_permissible_cvss_v3score,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exclusions: Optional[Sequence[str]] = None,
             max_permissible_cvss_v2score: Optional[float] = None,
             max_permissible_cvss_v3score: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if exclusions is None:
            raise TypeError("Missing 'exclusions' argument")
        if max_permissible_cvss_v2score is None and 'maxPermissibleCvssV2score' in kwargs:
            max_permissible_cvss_v2score = kwargs['maxPermissibleCvssV2score']
        if max_permissible_cvss_v2score is None:
            raise TypeError("Missing 'max_permissible_cvss_v2score' argument")
        if max_permissible_cvss_v3score is None and 'maxPermissibleCvssV3score' in kwargs:
            max_permissible_cvss_v3score = kwargs['maxPermissibleCvssV3score']
        if max_permissible_cvss_v3score is None:
            raise TypeError("Missing 'max_permissible_cvss_v3score' argument")

        _setter("exclusions", exclusions)
        _setter("max_permissible_cvss_v2score", max_permissible_cvss_v2score)
        _setter("max_permissible_cvss_v3score", max_permissible_cvss_v3score)

    @property
    @pulumi.getter
    def exclusions(self) -> Sequence[str]:
        """
        A vulnerable application dependency is ignored if its name matches any of the items in `exclusions`. An asterisk (*) in the dependency pattern acts as a wildcard and matches zero or more characters.
        """
        return pulumi.get(self, "exclusions")

    @property
    @pulumi.getter(name="maxPermissibleCvssV2score")
    def max_permissible_cvss_v2score(self) -> float:
        """
        A vulnerable application dependency is ignored if the score of its associated Vulnerability is below maxPermissibleCvssV2Score and below maxPermissibleCvssV3Score.
        """
        return pulumi.get(self, "max_permissible_cvss_v2score")

    @property
    @pulumi.getter(name="maxPermissibleCvssV3score")
    def max_permissible_cvss_v3score(self) -> float:
        """
        A vulnerable application dependency is ignored if the score of its associated Vulnerability is below maxPermissibleCvssV2Score and below maxPermissibleCvssV3Score.
        """
        return pulumi.get(self, "max_permissible_cvss_v3score")


@pulumi.output_type
class GetVulnerabilityAuditsVulnerabilityAuditCollectionItemSourceResult(dict):
    def __init__(__self__, *,
                 description: str,
                 oci_resource_id: str,
                 type: str):
        """
        :param str description: Description of the external resource source.
        :param str oci_resource_id: The Oracle Cloud identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Oracle Cloud Infrastructure resource that triggered the vulnerability audit.
        :param str type: Source type of the vulnerability audit.
        """
        GetVulnerabilityAuditsVulnerabilityAuditCollectionItemSourceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            oci_resource_id=oci_resource_id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             oci_resource_id: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if oci_resource_id is None and 'ociResourceId' in kwargs:
            oci_resource_id = kwargs['ociResourceId']
        if oci_resource_id is None:
            raise TypeError("Missing 'oci_resource_id' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("description", description)
        _setter("oci_resource_id", oci_resource_id)
        _setter("type", type)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of the external resource source.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="ociResourceId")
    def oci_resource_id(self) -> str:
        """
        The Oracle Cloud identifier ([OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)) of the Oracle Cloud Infrastructure resource that triggered the vulnerability audit.
        """
        return pulumi.get(self, "oci_resource_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Source type of the vulnerability audit.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetVulnerabilityAuditsVulnerabilityAuditCollectionItemVulnerabilityResult(dict):
    def __init__(__self__, *,
                 cvss_v2score: float,
                 cvss_v3score: float,
                 id: str,
                 is_ignored: bool):
        """
        :param float cvss_v2score: Common Vulnerability Scoring System (CVSS) Version 2.
        :param float cvss_v3score: Common Vulnerability Scoring System (CVSS) Version 3.
        :param str id: A filter to return only resources that match the specified identifier. Required only if the compartmentId query parameter is not specified.
        :param bool is_ignored: Indicates if the vulnerability was ignored according to the audit configuration.
        """
        GetVulnerabilityAuditsVulnerabilityAuditCollectionItemVulnerabilityResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cvss_v2score=cvss_v2score,
            cvss_v3score=cvss_v3score,
            id=id,
            is_ignored=is_ignored,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cvss_v2score: Optional[float] = None,
             cvss_v3score: Optional[float] = None,
             id: Optional[str] = None,
             is_ignored: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if cvss_v2score is None and 'cvssV2score' in kwargs:
            cvss_v2score = kwargs['cvssV2score']
        if cvss_v2score is None:
            raise TypeError("Missing 'cvss_v2score' argument")
        if cvss_v3score is None and 'cvssV3score' in kwargs:
            cvss_v3score = kwargs['cvssV3score']
        if cvss_v3score is None:
            raise TypeError("Missing 'cvss_v3score' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if is_ignored is None and 'isIgnored' in kwargs:
            is_ignored = kwargs['isIgnored']
        if is_ignored is None:
            raise TypeError("Missing 'is_ignored' argument")

        _setter("cvss_v2score", cvss_v2score)
        _setter("cvss_v3score", cvss_v3score)
        _setter("id", id)
        _setter("is_ignored", is_ignored)

    @property
    @pulumi.getter(name="cvssV2score")
    def cvss_v2score(self) -> float:
        """
        Common Vulnerability Scoring System (CVSS) Version 2.
        """
        return pulumi.get(self, "cvss_v2score")

    @property
    @pulumi.getter(name="cvssV3score")
    def cvss_v3score(self) -> float:
        """
        Common Vulnerability Scoring System (CVSS) Version 3.
        """
        return pulumi.get(self, "cvss_v3score")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        A filter to return only resources that match the specified identifier. Required only if the compartmentId query parameter is not specified.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isIgnored")
    def is_ignored(self) -> bool:
        """
        Indicates if the vulnerability was ignored according to the audit configuration.
        """
        return pulumi.get(self, "is_ignored")


