# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'JobInputConfiguration',
    'JobInputLocation',
    'JobModelMetadataDetail',
    'JobOutputLocation',
    'ModelEvaluationResult',
    'ModelEvaluationResultClassMetric',
    'ModelEvaluationResultEntityMetric',
    'ModelEvaluationResultMetric',
    'ModelModelDetails',
    'ModelModelDetailsClassificationMode',
    'ModelTestStrategy',
    'ModelTestStrategyTestingDataset',
    'ModelTestStrategyTestingDatasetLocationDetails',
    'ModelTestStrategyValidationDataset',
    'ModelTestStrategyValidationDatasetLocationDetails',
    'ModelTrainingDataset',
    'ModelTrainingDatasetLocationDetails',
    'GetEndpointsEndpointCollectionResult',
    'GetEndpointsEndpointCollectionItemResult',
    'GetEndpointsFilterResult',
    'GetJobInputConfigurationResult',
    'GetJobInputLocationResult',
    'GetJobModelMetadataDetailResult',
    'GetJobOutputLocationResult',
    'GetJobsFilterResult',
    'GetJobsJobCollectionResult',
    'GetJobsJobCollectionItemResult',
    'GetJobsJobCollectionItemInputConfigurationResult',
    'GetJobsJobCollectionItemInputLocationResult',
    'GetJobsJobCollectionItemModelMetadataDetailResult',
    'GetJobsJobCollectionItemOutputLocationResult',
    'GetModelEvaluationResultResult',
    'GetModelEvaluationResultClassMetricResult',
    'GetModelEvaluationResultEntityMetricResult',
    'GetModelEvaluationResultMetricResult',
    'GetModelEvaluationResultsEvaluationResultCollectionResult',
    'GetModelEvaluationResultsEvaluationResultCollectionItemResult',
    'GetModelEvaluationResultsEvaluationResultCollectionItemPredictedEntityResult',
    'GetModelEvaluationResultsEvaluationResultCollectionItemTrueEntityResult',
    'GetModelEvaluationResultsFilterResult',
    'GetModelModelDetailResult',
    'GetModelModelDetailClassificationModeResult',
    'GetModelTestStrategyResult',
    'GetModelTestStrategyTestingDatasetResult',
    'GetModelTestStrategyTestingDatasetLocationDetailResult',
    'GetModelTestStrategyValidationDatasetResult',
    'GetModelTestStrategyValidationDatasetLocationDetailResult',
    'GetModelTrainingDatasetResult',
    'GetModelTrainingDatasetLocationDetailResult',
    'GetModelsFilterResult',
    'GetModelsModelCollectionResult',
    'GetModelsModelCollectionItemResult',
    'GetModelsModelCollectionItemEvaluationResultResult',
    'GetModelsModelCollectionItemEvaluationResultClassMetricResult',
    'GetModelsModelCollectionItemEvaluationResultEntityMetricResult',
    'GetModelsModelCollectionItemEvaluationResultMetricResult',
    'GetModelsModelCollectionItemModelDetailResult',
    'GetModelsModelCollectionItemModelDetailClassificationModeResult',
    'GetModelsModelCollectionItemTestStrategyResult',
    'GetModelsModelCollectionItemTestStrategyTestingDatasetResult',
    'GetModelsModelCollectionItemTestStrategyTestingDatasetLocationDetailResult',
    'GetModelsModelCollectionItemTestStrategyValidationDatasetResult',
    'GetModelsModelCollectionItemTestStrategyValidationDatasetLocationDetailResult',
    'GetModelsModelCollectionItemTrainingDatasetResult',
    'GetModelsModelCollectionItemTrainingDatasetLocationDetailResult',
    'GetProjectsFilterResult',
    'GetProjectsProjectCollectionResult',
    'GetProjectsProjectCollectionItemResult',
]

@pulumi.output_type
class JobInputConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "documentTypes":
            suggest = "document_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobInputConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobInputConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobInputConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 configuration: Optional[Mapping[str, Mapping[str, _builtins.str]]] = None,
                 document_types: Optional[Sequence[_builtins.str]] = None):
        """
        :param Mapping[str, Mapping[str, _builtins.str]] configuration: meta data about documents For CSV valid JSON format is {"CSV" :{inputColumn: "reviewDetails", rowId: "reviewId", copyColumnsToOutput: ["reviewId" "userId"] , delimiter: ","} Note: In future if new file types added we will update here in documentation about input file meta data
        :param Sequence[_builtins.str] document_types: Type of documents supported for this release only TXT,CSV  and one element is allowed here. for future scope this is marked as list
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if document_types is not None:
            pulumi.set(__self__, "document_types", document_types)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[Mapping[str, Mapping[str, _builtins.str]]]:
        """
        meta data about documents For CSV valid JSON format is {"CSV" :{inputColumn: "reviewDetails", rowId: "reviewId", copyColumnsToOutput: ["reviewId" "userId"] , delimiter: ","} Note: In future if new file types added we will update here in documentation about input file meta data
        """
        return pulumi.get(self, "configuration")

    @_builtins.property
    @pulumi.getter(name="documentTypes")
    def document_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        Type of documents supported for this release only TXT,CSV  and one element is allowed here. for future scope this is marked as list
        """
        return pulumi.get(self, "document_types")


@pulumi.output_type
class JobInputLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "locationType":
            suggest = "location_type"
        elif key == "objectNames":
            suggest = "object_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobInputLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobInputLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobInputLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: _builtins.str,
                 location_type: _builtins.str,
                 namespace: _builtins.str,
                 object_names: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str bucket: Object Storage bucket name.
        :param _builtins.str location_type: locationType
        :param _builtins.str namespace: Object Storage namespace name.
        :param Sequence[_builtins.str] object_names: List of objects to be processed
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "location_type", location_type)
        pulumi.set(__self__, "namespace", namespace)
        if object_names is not None:
            pulumi.set(__self__, "object_names", object_names)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        Object Storage bucket name.
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="locationType")
    def location_type(self) -> _builtins.str:
        """
        locationType
        """
        return pulumi.get(self, "location_type")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Object Storage namespace name.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="objectNames")
    def object_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of objects to be processed
        """
        return pulumi.get(self, "object_names")


@pulumi.output_type
class JobModelMetadataDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointId":
            suggest = "endpoint_id"
        elif key == "languageCode":
            suggest = "language_code"
        elif key == "modelId":
            suggest = "model_id"
        elif key == "modelType":
            suggest = "model_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobModelMetadataDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobModelMetadataDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobModelMetadataDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 configuration: Optional[Mapping[str, Mapping[str, _builtins.str]]] = None,
                 endpoint_id: Optional[_builtins.str] = None,
                 language_code: Optional[_builtins.str] = None,
                 model_id: Optional[_builtins.str] = None,
                 model_type: Optional[_builtins.str] = None):
        """
        :param Mapping[str, Mapping[str, _builtins.str]] configuration: model configuration details For PII :  < ENTITY_TYPE , ConfigurationDetails> ex."ORACLE":{ "mode" : "MASK","maskingCharacter" : "&","leaveCharactersUnmasked": 3,"isUnmaskedFromEnd" : true  } For language translation : { "targetLanguageCodes" : ConfigurationDetails}
        :param _builtins.str endpoint_id: Unique identifier endpoint OCID that should be used for inference
        :param _builtins.str language_code: Language code supported
               * auto : Automatically detect language
               * ar : Arabic
               * pt-BR : Brazilian Portuguese
               * cs : Czech
               * da : Danish
               * nl : Dutch
               * en : English
               * fi : Finnish
               * fr : French
               * fr-CA : Canadian French
               * de : German
               * it : Italian
               * ja : Japanese
               * ko : Korean
               * no : Norwegian
               * pl : Polish
               * ro : Romanian
               * zh-CN : Simplified Chinese
               * es : Spanish
               * sv : Swedish
               * zh-TW : Traditional Chinese
               * tr : Turkish
               * el : Greek
               * he : Hebrew
        :param _builtins.str model_id: Unique identifier model OCID that should be used for inference
        :param _builtins.str model_type: model type to used for inference allowed values are
               * LANGUAGE_SENTIMENT_ANALYSIS
               * LANGUAGE_DETECTION
               * TEXT_CLASSIFICATION
               * NAMED_ENTITY_RECOGNITION
               * KEY_PHRASE_EXTRACTION
               * LANGUAGE_PII_ENTITIES
               * LANGUAGE_TRANSLATION
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if endpoint_id is not None:
            pulumi.set(__self__, "endpoint_id", endpoint_id)
        if language_code is not None:
            pulumi.set(__self__, "language_code", language_code)
        if model_id is not None:
            pulumi.set(__self__, "model_id", model_id)
        if model_type is not None:
            pulumi.set(__self__, "model_type", model_type)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[Mapping[str, Mapping[str, _builtins.str]]]:
        """
        model configuration details For PII :  < ENTITY_TYPE , ConfigurationDetails> ex."ORACLE":{ "mode" : "MASK","maskingCharacter" : "&","leaveCharactersUnmasked": 3,"isUnmaskedFromEnd" : true  } For language translation : { "targetLanguageCodes" : ConfigurationDetails}
        """
        return pulumi.get(self, "configuration")

    @_builtins.property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[_builtins.str]:
        """
        Unique identifier endpoint OCID that should be used for inference
        """
        return pulumi.get(self, "endpoint_id")

    @_builtins.property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> Optional[_builtins.str]:
        """
        Language code supported
        * auto : Automatically detect language
        * ar : Arabic
        * pt-BR : Brazilian Portuguese
        * cs : Czech
        * da : Danish
        * nl : Dutch
        * en : English
        * fi : Finnish
        * fr : French
        * fr-CA : Canadian French
        * de : German
        * it : Italian
        * ja : Japanese
        * ko : Korean
        * no : Norwegian
        * pl : Polish
        * ro : Romanian
        * zh-CN : Simplified Chinese
        * es : Spanish
        * sv : Swedish
        * zh-TW : Traditional Chinese
        * tr : Turkish
        * el : Greek
        * he : Hebrew
        """
        return pulumi.get(self, "language_code")

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> Optional[_builtins.str]:
        """
        Unique identifier model OCID that should be used for inference
        """
        return pulumi.get(self, "model_id")

    @_builtins.property
    @pulumi.getter(name="modelType")
    def model_type(self) -> Optional[_builtins.str]:
        """
        model type to used for inference allowed values are
        * LANGUAGE_SENTIMENT_ANALYSIS
        * LANGUAGE_DETECTION
        * TEXT_CLASSIFICATION
        * NAMED_ENTITY_RECOGNITION
        * KEY_PHRASE_EXTRACTION
        * LANGUAGE_PII_ENTITIES
        * LANGUAGE_TRANSLATION
        """
        return pulumi.get(self, "model_type")


@pulumi.output_type
class JobOutputLocation(dict):
    def __init__(__self__, *,
                 bucket: _builtins.str,
                 namespace: _builtins.str,
                 prefix: Optional[_builtins.str] = None):
        """
        :param _builtins.str bucket: Object Storage bucket name.
        :param _builtins.str namespace: Object Storage namespace name.
        :param _builtins.str prefix: The prefix (directory) in an Object Storage bucket.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "namespace", namespace)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        Object Storage bucket name.
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Object Storage namespace name.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        The prefix (directory) in an Object Storage bucket.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class ModelEvaluationResult(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classMetrics":
            suggest = "class_metrics"
        elif key == "confusionMatrix":
            suggest = "confusion_matrix"
        elif key == "entityMetrics":
            suggest = "entity_metrics"
        elif key == "modelType":
            suggest = "model_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelEvaluationResult. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelEvaluationResult.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelEvaluationResult.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 class_metrics: Optional[Sequence['outputs.ModelEvaluationResultClassMetric']] = None,
                 confusion_matrix: Optional[_builtins.str] = None,
                 entity_metrics: Optional[Sequence['outputs.ModelEvaluationResultEntityMetric']] = None,
                 labels: Optional[Sequence[_builtins.str]] = None,
                 metrics: Optional[Sequence['outputs.ModelEvaluationResultMetric']] = None,
                 model_type: Optional[_builtins.str] = None):
        """
        :param Sequence['ModelEvaluationResultClassMetricArgs'] class_metrics: List of text classification metrics
        :param _builtins.str confusion_matrix: class level confusion matrix
        :param Sequence['ModelEvaluationResultEntityMetricArgs'] entity_metrics: List of entity metrics
        :param Sequence[_builtins.str] labels: labels
        :param Sequence['ModelEvaluationResultMetricArgs'] metrics: Model level named entity recognition metrics
        :param _builtins.str model_type: Model type
        """
        if class_metrics is not None:
            pulumi.set(__self__, "class_metrics", class_metrics)
        if confusion_matrix is not None:
            pulumi.set(__self__, "confusion_matrix", confusion_matrix)
        if entity_metrics is not None:
            pulumi.set(__self__, "entity_metrics", entity_metrics)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if model_type is not None:
            pulumi.set(__self__, "model_type", model_type)

    @_builtins.property
    @pulumi.getter(name="classMetrics")
    def class_metrics(self) -> Optional[Sequence['outputs.ModelEvaluationResultClassMetric']]:
        """
        List of text classification metrics
        """
        return pulumi.get(self, "class_metrics")

    @_builtins.property
    @pulumi.getter(name="confusionMatrix")
    def confusion_matrix(self) -> Optional[_builtins.str]:
        """
        class level confusion matrix
        """
        return pulumi.get(self, "confusion_matrix")

    @_builtins.property
    @pulumi.getter(name="entityMetrics")
    def entity_metrics(self) -> Optional[Sequence['outputs.ModelEvaluationResultEntityMetric']]:
        """
        List of entity metrics
        """
        return pulumi.get(self, "entity_metrics")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Sequence[_builtins.str]]:
        """
        labels
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Optional[Sequence['outputs.ModelEvaluationResultMetric']]:
        """
        Model level named entity recognition metrics
        """
        return pulumi.get(self, "metrics")

    @_builtins.property
    @pulumi.getter(name="modelType")
    def model_type(self) -> Optional[_builtins.str]:
        """
        Model type
        """
        return pulumi.get(self, "model_type")


@pulumi.output_type
class ModelEvaluationResultClassMetric(dict):
    def __init__(__self__, *,
                 f1: Optional[_builtins.float] = None,
                 label: Optional[_builtins.str] = None,
                 precision: Optional[_builtins.float] = None,
                 recall: Optional[_builtins.float] = None,
                 support: Optional[_builtins.float] = None):
        """
        :param _builtins.float f1: F1-score, is a measure of a model’s accuracy on a dataset
        :param _builtins.str label: Entity label
        :param _builtins.float precision: Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
        :param _builtins.float recall: Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
        :param _builtins.float support: number of samples in the test set
        """
        if f1 is not None:
            pulumi.set(__self__, "f1", f1)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if recall is not None:
            pulumi.set(__self__, "recall", recall)
        if support is not None:
            pulumi.set(__self__, "support", support)

    @_builtins.property
    @pulumi.getter
    def f1(self) -> Optional[_builtins.float]:
        """
        F1-score, is a measure of a model’s accuracy on a dataset
        """
        return pulumi.get(self, "f1")

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Entity label
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter
    def precision(self) -> Optional[_builtins.float]:
        """
        Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
        """
        return pulumi.get(self, "precision")

    @_builtins.property
    @pulumi.getter
    def recall(self) -> Optional[_builtins.float]:
        """
        Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
        """
        return pulumi.get(self, "recall")

    @_builtins.property
    @pulumi.getter
    def support(self) -> Optional[_builtins.float]:
        """
        number of samples in the test set
        """
        return pulumi.get(self, "support")


@pulumi.output_type
class ModelEvaluationResultEntityMetric(dict):
    def __init__(__self__, *,
                 f1: Optional[_builtins.float] = None,
                 label: Optional[_builtins.str] = None,
                 precision: Optional[_builtins.float] = None,
                 recall: Optional[_builtins.float] = None):
        """
        :param _builtins.float f1: F1-score, is a measure of a model’s accuracy on a dataset
        :param _builtins.str label: Entity label
        :param _builtins.float precision: Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
        :param _builtins.float recall: Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
        """
        if f1 is not None:
            pulumi.set(__self__, "f1", f1)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if recall is not None:
            pulumi.set(__self__, "recall", recall)

    @_builtins.property
    @pulumi.getter
    def f1(self) -> Optional[_builtins.float]:
        """
        F1-score, is a measure of a model’s accuracy on a dataset
        """
        return pulumi.get(self, "f1")

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Entity label
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter
    def precision(self) -> Optional[_builtins.float]:
        """
        Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
        """
        return pulumi.get(self, "precision")

    @_builtins.property
    @pulumi.getter
    def recall(self) -> Optional[_builtins.float]:
        """
        Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
        """
        return pulumi.get(self, "recall")


@pulumi.output_type
class ModelEvaluationResultMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "macroF1":
            suggest = "macro_f1"
        elif key == "macroPrecision":
            suggest = "macro_precision"
        elif key == "macroRecall":
            suggest = "macro_recall"
        elif key == "microF1":
            suggest = "micro_f1"
        elif key == "microPrecision":
            suggest = "micro_precision"
        elif key == "microRecall":
            suggest = "micro_recall"
        elif key == "weightedF1":
            suggest = "weighted_f1"
        elif key == "weightedPrecision":
            suggest = "weighted_precision"
        elif key == "weightedRecall":
            suggest = "weighted_recall"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelEvaluationResultMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelEvaluationResultMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelEvaluationResultMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accuracy: Optional[_builtins.float] = None,
                 macro_f1: Optional[_builtins.float] = None,
                 macro_precision: Optional[_builtins.float] = None,
                 macro_recall: Optional[_builtins.float] = None,
                 micro_f1: Optional[_builtins.float] = None,
                 micro_precision: Optional[_builtins.float] = None,
                 micro_recall: Optional[_builtins.float] = None,
                 weighted_f1: Optional[_builtins.float] = None,
                 weighted_precision: Optional[_builtins.float] = None,
                 weighted_recall: Optional[_builtins.float] = None):
        """
        :param _builtins.float accuracy: The fraction of the labels that were correctly recognised .
        :param _builtins.float macro_f1: F1-score, is a measure of a model’s accuracy on a dataset
        :param _builtins.float macro_precision: Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
        :param _builtins.float macro_recall: Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
        :param _builtins.float micro_f1: F1-score, is a measure of a model’s accuracy on a dataset
        :param _builtins.float micro_precision: Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
        :param _builtins.float micro_recall: Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
        :param _builtins.float weighted_f1: F1-score, is a measure of a model’s accuracy on a dataset
        :param _builtins.float weighted_precision: Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
        :param _builtins.float weighted_recall: Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
        """
        if accuracy is not None:
            pulumi.set(__self__, "accuracy", accuracy)
        if macro_f1 is not None:
            pulumi.set(__self__, "macro_f1", macro_f1)
        if macro_precision is not None:
            pulumi.set(__self__, "macro_precision", macro_precision)
        if macro_recall is not None:
            pulumi.set(__self__, "macro_recall", macro_recall)
        if micro_f1 is not None:
            pulumi.set(__self__, "micro_f1", micro_f1)
        if micro_precision is not None:
            pulumi.set(__self__, "micro_precision", micro_precision)
        if micro_recall is not None:
            pulumi.set(__self__, "micro_recall", micro_recall)
        if weighted_f1 is not None:
            pulumi.set(__self__, "weighted_f1", weighted_f1)
        if weighted_precision is not None:
            pulumi.set(__self__, "weighted_precision", weighted_precision)
        if weighted_recall is not None:
            pulumi.set(__self__, "weighted_recall", weighted_recall)

    @_builtins.property
    @pulumi.getter
    def accuracy(self) -> Optional[_builtins.float]:
        """
        The fraction of the labels that were correctly recognised .
        """
        return pulumi.get(self, "accuracy")

    @_builtins.property
    @pulumi.getter(name="macroF1")
    def macro_f1(self) -> Optional[_builtins.float]:
        """
        F1-score, is a measure of a model’s accuracy on a dataset
        """
        return pulumi.get(self, "macro_f1")

    @_builtins.property
    @pulumi.getter(name="macroPrecision")
    def macro_precision(self) -> Optional[_builtins.float]:
        """
        Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
        """
        return pulumi.get(self, "macro_precision")

    @_builtins.property
    @pulumi.getter(name="macroRecall")
    def macro_recall(self) -> Optional[_builtins.float]:
        """
        Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
        """
        return pulumi.get(self, "macro_recall")

    @_builtins.property
    @pulumi.getter(name="microF1")
    def micro_f1(self) -> Optional[_builtins.float]:
        """
        F1-score, is a measure of a model’s accuracy on a dataset
        """
        return pulumi.get(self, "micro_f1")

    @_builtins.property
    @pulumi.getter(name="microPrecision")
    def micro_precision(self) -> Optional[_builtins.float]:
        """
        Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
        """
        return pulumi.get(self, "micro_precision")

    @_builtins.property
    @pulumi.getter(name="microRecall")
    def micro_recall(self) -> Optional[_builtins.float]:
        """
        Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
        """
        return pulumi.get(self, "micro_recall")

    @_builtins.property
    @pulumi.getter(name="weightedF1")
    def weighted_f1(self) -> Optional[_builtins.float]:
        """
        F1-score, is a measure of a model’s accuracy on a dataset
        """
        return pulumi.get(self, "weighted_f1")

    @_builtins.property
    @pulumi.getter(name="weightedPrecision")
    def weighted_precision(self) -> Optional[_builtins.float]:
        """
        Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
        """
        return pulumi.get(self, "weighted_precision")

    @_builtins.property
    @pulumi.getter(name="weightedRecall")
    def weighted_recall(self) -> Optional[_builtins.float]:
        """
        Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
        """
        return pulumi.get(self, "weighted_recall")


@pulumi.output_type
class ModelModelDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modelType":
            suggest = "model_type"
        elif key == "classificationMode":
            suggest = "classification_mode"
        elif key == "languageCode":
            suggest = "language_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelModelDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelModelDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelModelDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 model_type: _builtins.str,
                 classification_mode: Optional['outputs.ModelModelDetailsClassificationMode'] = None,
                 language_code: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str model_type: Model type
        :param 'ModelModelDetailsClassificationModeArgs' classification_mode: possible text classification modes
        :param _builtins.str language_code: supported language default value is en
        :param _builtins.str version: Optional pre trained model version. if nothing specified latest pre trained model will be used.  Supported versions can be found at /modelTypes/{modelType}
        """
        pulumi.set(__self__, "model_type", model_type)
        if classification_mode is not None:
            pulumi.set(__self__, "classification_mode", classification_mode)
        if language_code is not None:
            pulumi.set(__self__, "language_code", language_code)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="modelType")
    def model_type(self) -> _builtins.str:
        """
        Model type
        """
        return pulumi.get(self, "model_type")

    @_builtins.property
    @pulumi.getter(name="classificationMode")
    def classification_mode(self) -> Optional['outputs.ModelModelDetailsClassificationMode']:
        """
        possible text classification modes
        """
        return pulumi.get(self, "classification_mode")

    @_builtins.property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> Optional[_builtins.str]:
        """
        supported language default value is en
        """
        return pulumi.get(self, "language_code")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        Optional pre trained model version. if nothing specified latest pre trained model will be used.  Supported versions can be found at /modelTypes/{modelType}
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class ModelModelDetailsClassificationMode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classificationMode":
            suggest = "classification_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelModelDetailsClassificationMode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelModelDetailsClassificationMode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelModelDetailsClassificationMode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 classification_mode: _builtins.str,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str classification_mode: classification Modes
        :param _builtins.str version: Optional if nothing specified latest base model will be used for training. Supported versions can be found at /modelTypes/{modelType}
        """
        pulumi.set(__self__, "classification_mode", classification_mode)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="classificationMode")
    def classification_mode(self) -> _builtins.str:
        """
        classification Modes
        """
        return pulumi.get(self, "classification_mode")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        Optional if nothing specified latest base model will be used for training. Supported versions can be found at /modelTypes/{modelType}
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class ModelTestStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "strategyType":
            suggest = "strategy_type"
        elif key == "testingDataset":
            suggest = "testing_dataset"
        elif key == "validationDataset":
            suggest = "validation_dataset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelTestStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelTestStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelTestStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 strategy_type: _builtins.str,
                 testing_dataset: 'outputs.ModelTestStrategyTestingDataset',
                 validation_dataset: Optional['outputs.ModelTestStrategyValidationDataset'] = None):
        """
        :param _builtins.str strategy_type: This information will define the test strategy different datasets for test and validation(optional) dataset.
        :param 'ModelTestStrategyTestingDatasetArgs' testing_dataset: Possible data set type
        :param 'ModelTestStrategyValidationDatasetArgs' validation_dataset: Possible data set type
        """
        pulumi.set(__self__, "strategy_type", strategy_type)
        pulumi.set(__self__, "testing_dataset", testing_dataset)
        if validation_dataset is not None:
            pulumi.set(__self__, "validation_dataset", validation_dataset)

    @_builtins.property
    @pulumi.getter(name="strategyType")
    def strategy_type(self) -> _builtins.str:
        """
        This information will define the test strategy different datasets for test and validation(optional) dataset.
        """
        return pulumi.get(self, "strategy_type")

    @_builtins.property
    @pulumi.getter(name="testingDataset")
    def testing_dataset(self) -> 'outputs.ModelTestStrategyTestingDataset':
        """
        Possible data set type
        """
        return pulumi.get(self, "testing_dataset")

    @_builtins.property
    @pulumi.getter(name="validationDataset")
    def validation_dataset(self) -> Optional['outputs.ModelTestStrategyValidationDataset']:
        """
        Possible data set type
        """
        return pulumi.get(self, "validation_dataset")


@pulumi.output_type
class ModelTestStrategyTestingDataset(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetType":
            suggest = "dataset_type"
        elif key == "datasetId":
            suggest = "dataset_id"
        elif key == "locationDetails":
            suggest = "location_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelTestStrategyTestingDataset. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelTestStrategyTestingDataset.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelTestStrategyTestingDataset.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dataset_type: _builtins.str,
                 dataset_id: Optional[_builtins.str] = None,
                 location_details: Optional['outputs.ModelTestStrategyTestingDatasetLocationDetails'] = None):
        """
        :param _builtins.str dataset_type: Possible data sets
        :param _builtins.str dataset_id: Data Science Labelling Service OCID
        :param 'ModelTestStrategyTestingDatasetLocationDetailsArgs' location_details: Possible object storage location types
        """
        pulumi.set(__self__, "dataset_type", dataset_type)
        if dataset_id is not None:
            pulumi.set(__self__, "dataset_id", dataset_id)
        if location_details is not None:
            pulumi.set(__self__, "location_details", location_details)

    @_builtins.property
    @pulumi.getter(name="datasetType")
    def dataset_type(self) -> _builtins.str:
        """
        Possible data sets
        """
        return pulumi.get(self, "dataset_type")

    @_builtins.property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> Optional[_builtins.str]:
        """
        Data Science Labelling Service OCID
        """
        return pulumi.get(self, "dataset_id")

    @_builtins.property
    @pulumi.getter(name="locationDetails")
    def location_details(self) -> Optional['outputs.ModelTestStrategyTestingDatasetLocationDetails']:
        """
        Possible object storage location types
        """
        return pulumi.get(self, "location_details")


@pulumi.output_type
class ModelTestStrategyTestingDatasetLocationDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "locationType":
            suggest = "location_type"
        elif key == "objectNames":
            suggest = "object_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelTestStrategyTestingDatasetLocationDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelTestStrategyTestingDatasetLocationDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelTestStrategyTestingDatasetLocationDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: _builtins.str,
                 location_type: _builtins.str,
                 namespace: _builtins.str,
                 object_names: Sequence[_builtins.str]):
        """
        :param _builtins.str bucket: Object storage bucket name
        :param _builtins.str location_type: Possible object storage location types
        :param _builtins.str namespace: Object storage namespace
        :param Sequence[_builtins.str] object_names: Array of files which need to be processed in the bucket
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "location_type", location_type)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "object_names", object_names)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        Object storage bucket name
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="locationType")
    def location_type(self) -> _builtins.str:
        """
        Possible object storage location types
        """
        return pulumi.get(self, "location_type")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Object storage namespace
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="objectNames")
    def object_names(self) -> Sequence[_builtins.str]:
        """
        Array of files which need to be processed in the bucket
        """
        return pulumi.get(self, "object_names")


@pulumi.output_type
class ModelTestStrategyValidationDataset(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetType":
            suggest = "dataset_type"
        elif key == "datasetId":
            suggest = "dataset_id"
        elif key == "locationDetails":
            suggest = "location_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelTestStrategyValidationDataset. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelTestStrategyValidationDataset.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelTestStrategyValidationDataset.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dataset_type: _builtins.str,
                 dataset_id: Optional[_builtins.str] = None,
                 location_details: Optional['outputs.ModelTestStrategyValidationDatasetLocationDetails'] = None):
        """
        :param _builtins.str dataset_type: Possible data sets
        :param _builtins.str dataset_id: Data Science Labelling Service OCID
        :param 'ModelTestStrategyValidationDatasetLocationDetailsArgs' location_details: Possible object storage location types
        """
        pulumi.set(__self__, "dataset_type", dataset_type)
        if dataset_id is not None:
            pulumi.set(__self__, "dataset_id", dataset_id)
        if location_details is not None:
            pulumi.set(__self__, "location_details", location_details)

    @_builtins.property
    @pulumi.getter(name="datasetType")
    def dataset_type(self) -> _builtins.str:
        """
        Possible data sets
        """
        return pulumi.get(self, "dataset_type")

    @_builtins.property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> Optional[_builtins.str]:
        """
        Data Science Labelling Service OCID
        """
        return pulumi.get(self, "dataset_id")

    @_builtins.property
    @pulumi.getter(name="locationDetails")
    def location_details(self) -> Optional['outputs.ModelTestStrategyValidationDatasetLocationDetails']:
        """
        Possible object storage location types
        """
        return pulumi.get(self, "location_details")


@pulumi.output_type
class ModelTestStrategyValidationDatasetLocationDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "locationType":
            suggest = "location_type"
        elif key == "objectNames":
            suggest = "object_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelTestStrategyValidationDatasetLocationDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelTestStrategyValidationDatasetLocationDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelTestStrategyValidationDatasetLocationDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: _builtins.str,
                 location_type: _builtins.str,
                 namespace: _builtins.str,
                 object_names: Sequence[_builtins.str]):
        """
        :param _builtins.str bucket: Object storage bucket name
        :param _builtins.str location_type: Possible object storage location types
        :param _builtins.str namespace: Object storage namespace
        :param Sequence[_builtins.str] object_names: Array of files which need to be processed in the bucket
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "location_type", location_type)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "object_names", object_names)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        Object storage bucket name
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="locationType")
    def location_type(self) -> _builtins.str:
        """
        Possible object storage location types
        """
        return pulumi.get(self, "location_type")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Object storage namespace
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="objectNames")
    def object_names(self) -> Sequence[_builtins.str]:
        """
        Array of files which need to be processed in the bucket
        """
        return pulumi.get(self, "object_names")


@pulumi.output_type
class ModelTrainingDataset(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetType":
            suggest = "dataset_type"
        elif key == "datasetId":
            suggest = "dataset_id"
        elif key == "locationDetails":
            suggest = "location_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelTrainingDataset. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelTrainingDataset.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelTrainingDataset.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dataset_type: _builtins.str,
                 dataset_id: Optional[_builtins.str] = None,
                 location_details: Optional['outputs.ModelTrainingDatasetLocationDetails'] = None):
        """
        :param _builtins.str dataset_type: Possible data sets
        :param _builtins.str dataset_id: Data Science Labelling Service OCID
        :param 'ModelTrainingDatasetLocationDetailsArgs' location_details: Possible object storage location types
        """
        pulumi.set(__self__, "dataset_type", dataset_type)
        if dataset_id is not None:
            pulumi.set(__self__, "dataset_id", dataset_id)
        if location_details is not None:
            pulumi.set(__self__, "location_details", location_details)

    @_builtins.property
    @pulumi.getter(name="datasetType")
    def dataset_type(self) -> _builtins.str:
        """
        Possible data sets
        """
        return pulumi.get(self, "dataset_type")

    @_builtins.property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> Optional[_builtins.str]:
        """
        Data Science Labelling Service OCID
        """
        return pulumi.get(self, "dataset_id")

    @_builtins.property
    @pulumi.getter(name="locationDetails")
    def location_details(self) -> Optional['outputs.ModelTrainingDatasetLocationDetails']:
        """
        Possible object storage location types
        """
        return pulumi.get(self, "location_details")


@pulumi.output_type
class ModelTrainingDatasetLocationDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "locationType":
            suggest = "location_type"
        elif key == "objectNames":
            suggest = "object_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelTrainingDatasetLocationDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelTrainingDatasetLocationDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelTrainingDatasetLocationDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: _builtins.str,
                 location_type: _builtins.str,
                 namespace: _builtins.str,
                 object_names: Sequence[_builtins.str]):
        """
        :param _builtins.str bucket: Object storage bucket name
        :param _builtins.str location_type: Possible object storage location types
        :param _builtins.str namespace: Object storage namespace
        :param Sequence[_builtins.str] object_names: Array of files which need to be processed in the bucket
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "location_type", location_type)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "object_names", object_names)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        Object storage bucket name
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="locationType")
    def location_type(self) -> _builtins.str:
        """
        Possible object storage location types
        """
        return pulumi.get(self, "location_type")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Object storage namespace
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="objectNames")
    def object_names(self) -> Sequence[_builtins.str]:
        """
        Array of files which need to be processed in the bucket


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "object_names")


@pulumi.output_type
class GetEndpointsEndpointCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetEndpointsEndpointCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetEndpointsEndpointCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetEndpointsEndpointCollectionItemResult(dict):
    def __init__(__self__, *,
                 alias: _builtins.str,
                 compartment_id: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 description: _builtins.str,
                 display_name: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 inference_units: _builtins.int,
                 lifecycle_details: _builtins.str,
                 model_id: _builtins.str,
                 project_id: _builtins.str,
                 state: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 time_created: _builtins.str,
                 time_updated: _builtins.str):
        """
        :param _builtins.str alias: Unique name across user tenancy in a region to identify an endpoint to be used for inferencing.
        :param _builtins.str compartment_id: The ID of the compartment in which to list resources.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param _builtins.str description: A short description of the endpoint.
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given.
        :param Mapping[str, _builtins.str] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param _builtins.str id: Unique identifier endpoint OCID of an endpoint that is immutable on creation.
        :param _builtins.int inference_units: Number of replicas required for this endpoint.
        :param _builtins.str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in failed state.
        :param _builtins.str model_id: The ID of the trained model for which to list the endpoints.
        :param _builtins.str project_id: The ID of the project for which to list the objects.
        :param _builtins.str state: <b>Filter</b> results by the specified lifecycle state. Must be a valid state for the resource type.
        :param Mapping[str, _builtins.str] system_tags: Usage of system tag keys. These predefined keys are scoped to namespaces. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param _builtins.str time_created: The time the the endpoint was created. An RFC3339 formatted datetime string.
        :param _builtins.str time_updated: The time the endpoint was updated. An RFC3339 formatted datetime string.
        """
        pulumi.set(__self__, "alias", alias)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "inference_units", inference_units)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "model_id", model_id)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> _builtins.str:
        """
        Unique name across user tenancy in a region to identify an endpoint to be used for inferencing.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        A short description of the endpoint.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique identifier endpoint OCID of an endpoint that is immutable on creation.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="inferenceUnits")
    def inference_units(self) -> _builtins.int:
        """
        Number of replicas required for this endpoint.
        """
        return pulumi.get(self, "inference_units")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> _builtins.str:
        """
        The ID of the trained model for which to list the endpoints.
        """
        return pulumi.get(self, "model_id")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        The ID of the project for which to list the objects.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        <b>Filter</b> results by the specified lifecycle state. Must be a valid state for the resource type.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        Usage of system tag keys. These predefined keys are scoped to namespaces. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The time the the endpoint was created. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The time the endpoint was updated. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetEndpointsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetJobInputConfigurationResult(dict):
    def __init__(__self__, *,
                 configuration: Mapping[str, Mapping[str, _builtins.str]],
                 document_types: Sequence[_builtins.str]):
        """
        :param Mapping[str, Mapping[str, _builtins.str]] configuration: model configuration details For PII :  < ENTITY_TYPE , ConfigurationDetails> ex."ORACLE":{ "mode" : "MASK","maskingCharacter" : "&","leaveCharactersUnmasked": 3,"isUnmaskedFromEnd" : true  } For language translation : { "targetLanguageCodes" : ConfigurationDetails}
        :param Sequence[_builtins.str] document_types: Type of documents supported for this release only TXT,CSV  and one element is allowed here. for future scope this is marked as list
        """
        pulumi.set(__self__, "configuration", configuration)
        pulumi.set(__self__, "document_types", document_types)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Mapping[str, Mapping[str, _builtins.str]]:
        """
        model configuration details For PII :  < ENTITY_TYPE , ConfigurationDetails> ex."ORACLE":{ "mode" : "MASK","maskingCharacter" : "&","leaveCharactersUnmasked": 3,"isUnmaskedFromEnd" : true  } For language translation : { "targetLanguageCodes" : ConfigurationDetails}
        """
        return pulumi.get(self, "configuration")

    @_builtins.property
    @pulumi.getter(name="documentTypes")
    def document_types(self) -> Sequence[_builtins.str]:
        """
        Type of documents supported for this release only TXT,CSV  and one element is allowed here. for future scope this is marked as list
        """
        return pulumi.get(self, "document_types")


@pulumi.output_type
class GetJobInputLocationResult(dict):
    def __init__(__self__, *,
                 bucket: _builtins.str,
                 location_type: _builtins.str,
                 namespace: _builtins.str,
                 object_names: Sequence[_builtins.str]):
        """
        :param _builtins.str bucket: Object Storage bucket name.
        :param _builtins.str location_type: locationType
        :param _builtins.str namespace: Object Storage namespace name.
        :param Sequence[_builtins.str] object_names: List of objects to be processed
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "location_type", location_type)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "object_names", object_names)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        Object Storage bucket name.
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="locationType")
    def location_type(self) -> _builtins.str:
        """
        locationType
        """
        return pulumi.get(self, "location_type")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Object Storage namespace name.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="objectNames")
    def object_names(self) -> Sequence[_builtins.str]:
        """
        List of objects to be processed
        """
        return pulumi.get(self, "object_names")


@pulumi.output_type
class GetJobModelMetadataDetailResult(dict):
    def __init__(__self__, *,
                 configuration: Mapping[str, Mapping[str, _builtins.str]],
                 endpoint_id: _builtins.str,
                 language_code: _builtins.str,
                 model_id: _builtins.str,
                 model_type: _builtins.str):
        """
        :param Mapping[str, Mapping[str, _builtins.str]] configuration: model configuration details For PII :  < ENTITY_TYPE , ConfigurationDetails> ex."ORACLE":{ "mode" : "MASK","maskingCharacter" : "&","leaveCharactersUnmasked": 3,"isUnmaskedFromEnd" : true  } For language translation : { "targetLanguageCodes" : ConfigurationDetails}
        :param _builtins.str endpoint_id: Unique identifier endpoint OCID that should be used for inference
        :param _builtins.str language_code: Language code supported
               * auto : Automatically detect language
               * ar : Arabic
               * pt-BR : Brazilian Portuguese
               * cs : Czech
               * da : Danish
               * nl : Dutch
               * en : English
               * fi : Finnish
               * fr : French
               * fr-CA : Canadian French
               * de : German
               * it : Italian
               * ja : Japanese
               * ko : Korean
               * no : Norwegian
               * pl : Polish
               * ro : Romanian
               * zh-CN : Simplified Chinese
               * es : Spanish
               * sv : Swedish
               * zh-TW : Traditional Chinese
               * tr : Turkish
               * el : Greek
               * he : Hebrew
        :param _builtins.str model_id: Unique identifier model OCID that should be used for inference
        :param _builtins.str model_type: model type to used for inference allowed values are
               * LANGUAGE_SENTIMENT_ANALYSIS
               * LANGUAGE_DETECTION
               * TEXT_CLASSIFICATION
               * NAMED_ENTITY_RECOGNITION
               * KEY_PHRASE_EXTRACTION
               * LANGUAGE_PII_ENTITIES
               * LANGUAGE_TRANSLATION
        """
        pulumi.set(__self__, "configuration", configuration)
        pulumi.set(__self__, "endpoint_id", endpoint_id)
        pulumi.set(__self__, "language_code", language_code)
        pulumi.set(__self__, "model_id", model_id)
        pulumi.set(__self__, "model_type", model_type)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Mapping[str, Mapping[str, _builtins.str]]:
        """
        model configuration details For PII :  < ENTITY_TYPE , ConfigurationDetails> ex."ORACLE":{ "mode" : "MASK","maskingCharacter" : "&","leaveCharactersUnmasked": 3,"isUnmaskedFromEnd" : true  } For language translation : { "targetLanguageCodes" : ConfigurationDetails}
        """
        return pulumi.get(self, "configuration")

    @_builtins.property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> _builtins.str:
        """
        Unique identifier endpoint OCID that should be used for inference
        """
        return pulumi.get(self, "endpoint_id")

    @_builtins.property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> _builtins.str:
        """
        Language code supported
        * auto : Automatically detect language
        * ar : Arabic
        * pt-BR : Brazilian Portuguese
        * cs : Czech
        * da : Danish
        * nl : Dutch
        * en : English
        * fi : Finnish
        * fr : French
        * fr-CA : Canadian French
        * de : German
        * it : Italian
        * ja : Japanese
        * ko : Korean
        * no : Norwegian
        * pl : Polish
        * ro : Romanian
        * zh-CN : Simplified Chinese
        * es : Spanish
        * sv : Swedish
        * zh-TW : Traditional Chinese
        * tr : Turkish
        * el : Greek
        * he : Hebrew
        """
        return pulumi.get(self, "language_code")

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> _builtins.str:
        """
        Unique identifier model OCID that should be used for inference
        """
        return pulumi.get(self, "model_id")

    @_builtins.property
    @pulumi.getter(name="modelType")
    def model_type(self) -> _builtins.str:
        """
        model type to used for inference allowed values are
        * LANGUAGE_SENTIMENT_ANALYSIS
        * LANGUAGE_DETECTION
        * TEXT_CLASSIFICATION
        * NAMED_ENTITY_RECOGNITION
        * KEY_PHRASE_EXTRACTION
        * LANGUAGE_PII_ENTITIES
        * LANGUAGE_TRANSLATION
        """
        return pulumi.get(self, "model_type")


@pulumi.output_type
class GetJobOutputLocationResult(dict):
    def __init__(__self__, *,
                 bucket: _builtins.str,
                 namespace: _builtins.str,
                 prefix: _builtins.str):
        """
        :param _builtins.str bucket: Object Storage bucket name.
        :param _builtins.str namespace: Object Storage namespace name.
        :param _builtins.str prefix: The prefix (directory) in an Object Storage bucket.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        Object Storage bucket name.
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Object Storage namespace name.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> _builtins.str:
        """
        The prefix (directory) in an Object Storage bucket.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class GetJobsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetJobsJobCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetJobsJobCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetJobsJobCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetJobsJobCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: _builtins.str,
                 completed_documents: _builtins.int,
                 created_by: _builtins.str,
                 description: _builtins.str,
                 display_name: _builtins.str,
                 failed_documents: _builtins.int,
                 id: _builtins.str,
                 input_configurations: Sequence['outputs.GetJobsJobCollectionItemInputConfigurationResult'],
                 input_locations: Sequence['outputs.GetJobsJobCollectionItemInputLocationResult'],
                 lifecycle_details: _builtins.str,
                 model_metadata_details: Sequence['outputs.GetJobsJobCollectionItemModelMetadataDetailResult'],
                 output_locations: Sequence['outputs.GetJobsJobCollectionItemOutputLocationResult'],
                 pending_documents: _builtins.int,
                 percent_complete: _builtins.int,
                 state: _builtins.str,
                 time_accepted: _builtins.str,
                 time_completed: _builtins.str,
                 time_started: _builtins.str,
                 total_documents: _builtins.int,
                 ttl_in_days: _builtins.int,
                 warnings_count: _builtins.int):
        """
        :param _builtins.str compartment_id: The ID of the compartment in which to list resources.
        :param _builtins.int completed_documents: Number of documents processed for prediction. For CSV this signifies number of rows and for TXT this signifies number of files.
        :param _builtins.str created_by: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the user who created the job.
        :param _builtins.str description: A short description of the job.
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given.
        :param _builtins.int failed_documents: Number of documents failed for prediction. For CSV this signifies number of rows and for TXT this signifies number of files.
        :param _builtins.str id: Unique identifier(OCID).
        :param Sequence['GetJobsJobCollectionItemInputConfigurationArgs'] input_configurations: input documents configuration by default TXT files will be processed and this behaviour will not change in future after adding new types
        :param Sequence['GetJobsJobCollectionItemInputLocationArgs'] input_locations: document location and other meta data about documents For TXT only ObjectStoragePrefixLocation supported For CSV only ObjectStorageFileNameLocation is supported For this release only one file is supported for ObjectStorageFileNameLocation i.e CSV file type
        :param _builtins.str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param Sequence['GetJobsJobCollectionItemModelMetadataDetailArgs'] model_metadata_details: training model details For this release only one model is allowed to be input here. One of the three modelType, ModelId, endpointId should be given other wise error will be thrown from API
        :param Sequence['GetJobsJobCollectionItemOutputLocationArgs'] output_locations: Object storage output location to write inference results
        :param _builtins.int pending_documents: Number of documents still to process. For CSV this signifies number of rows and for TXT this signifies number of files.
        :param _builtins.int percent_complete: How much progress the operation has made, vs the total amount of work that must be performed.
        :param _builtins.str state: A filter to return only resources whose lifecycleState matches the given lifecycleState.
        :param _builtins.str time_accepted: Job accepted time.
        :param _builtins.str time_completed: Job finished time.
        :param _builtins.str time_started: Job started time.
        :param _builtins.int total_documents: Total number of documents given as input for prediction. For CSV this signifies number of rows and for TXT this signifies number of files.
        :param _builtins.int ttl_in_days: Time to live duration in days for Job. Job will be available till max 90 days.
        :param _builtins.int warnings_count: warnings count
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "completed_documents", completed_documents)
        pulumi.set(__self__, "created_by", created_by)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "failed_documents", failed_documents)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "input_configurations", input_configurations)
        pulumi.set(__self__, "input_locations", input_locations)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "model_metadata_details", model_metadata_details)
        pulumi.set(__self__, "output_locations", output_locations)
        pulumi.set(__self__, "pending_documents", pending_documents)
        pulumi.set(__self__, "percent_complete", percent_complete)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_accepted", time_accepted)
        pulumi.set(__self__, "time_completed", time_completed)
        pulumi.set(__self__, "time_started", time_started)
        pulumi.set(__self__, "total_documents", total_documents)
        pulumi.set(__self__, "ttl_in_days", ttl_in_days)
        pulumi.set(__self__, "warnings_count", warnings_count)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="completedDocuments")
    def completed_documents(self) -> _builtins.int:
        """
        Number of documents processed for prediction. For CSV this signifies number of rows and for TXT this signifies number of files.
        """
        return pulumi.get(self, "completed_documents")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> _builtins.str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the user who created the job.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        A short description of the job.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="failedDocuments")
    def failed_documents(self) -> _builtins.int:
        """
        Number of documents failed for prediction. For CSV this signifies number of rows and for TXT this signifies number of files.
        """
        return pulumi.get(self, "failed_documents")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique identifier(OCID).
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="inputConfigurations")
    def input_configurations(self) -> Sequence['outputs.GetJobsJobCollectionItemInputConfigurationResult']:
        """
        input documents configuration by default TXT files will be processed and this behaviour will not change in future after adding new types
        """
        return pulumi.get(self, "input_configurations")

    @_builtins.property
    @pulumi.getter(name="inputLocations")
    def input_locations(self) -> Sequence['outputs.GetJobsJobCollectionItemInputLocationResult']:
        """
        document location and other meta data about documents For TXT only ObjectStoragePrefixLocation supported For CSV only ObjectStorageFileNameLocation is supported For this release only one file is supported for ObjectStorageFileNameLocation i.e CSV file type
        """
        return pulumi.get(self, "input_locations")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="modelMetadataDetails")
    def model_metadata_details(self) -> Sequence['outputs.GetJobsJobCollectionItemModelMetadataDetailResult']:
        """
        training model details For this release only one model is allowed to be input here. One of the three modelType, ModelId, endpointId should be given other wise error will be thrown from API
        """
        return pulumi.get(self, "model_metadata_details")

    @_builtins.property
    @pulumi.getter(name="outputLocations")
    def output_locations(self) -> Sequence['outputs.GetJobsJobCollectionItemOutputLocationResult']:
        """
        Object storage output location to write inference results
        """
        return pulumi.get(self, "output_locations")

    @_builtins.property
    @pulumi.getter(name="pendingDocuments")
    def pending_documents(self) -> _builtins.int:
        """
        Number of documents still to process. For CSV this signifies number of rows and for TXT this signifies number of files.
        """
        return pulumi.get(self, "pending_documents")

    @_builtins.property
    @pulumi.getter(name="percentComplete")
    def percent_complete(self) -> _builtins.int:
        """
        How much progress the operation has made, vs the total amount of work that must be performed.
        """
        return pulumi.get(self, "percent_complete")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        A filter to return only resources whose lifecycleState matches the given lifecycleState.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeAccepted")
    def time_accepted(self) -> _builtins.str:
        """
        Job accepted time.
        """
        return pulumi.get(self, "time_accepted")

    @_builtins.property
    @pulumi.getter(name="timeCompleted")
    def time_completed(self) -> _builtins.str:
        """
        Job finished time.
        """
        return pulumi.get(self, "time_completed")

    @_builtins.property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> _builtins.str:
        """
        Job started time.
        """
        return pulumi.get(self, "time_started")

    @_builtins.property
    @pulumi.getter(name="totalDocuments")
    def total_documents(self) -> _builtins.int:
        """
        Total number of documents given as input for prediction. For CSV this signifies number of rows and for TXT this signifies number of files.
        """
        return pulumi.get(self, "total_documents")

    @_builtins.property
    @pulumi.getter(name="ttlInDays")
    def ttl_in_days(self) -> _builtins.int:
        """
        Time to live duration in days for Job. Job will be available till max 90 days.
        """
        return pulumi.get(self, "ttl_in_days")

    @_builtins.property
    @pulumi.getter(name="warningsCount")
    def warnings_count(self) -> _builtins.int:
        """
        warnings count
        """
        return pulumi.get(self, "warnings_count")


@pulumi.output_type
class GetJobsJobCollectionItemInputConfigurationResult(dict):
    def __init__(__self__, *,
                 configuration: Mapping[str, Mapping[str, _builtins.str]],
                 document_types: Sequence[_builtins.str]):
        """
        :param Mapping[str, Mapping[str, _builtins.str]] configuration: model configuration details For PII :  < ENTITY_TYPE , ConfigurationDetails> ex."ORACLE":{ "mode" : "MASK","maskingCharacter" : "&","leaveCharactersUnmasked": 3,"isUnmaskedFromEnd" : true  } For language translation : { "targetLanguageCodes" : ConfigurationDetails}
        :param Sequence[_builtins.str] document_types: Type of documents supported for this release only TXT,CSV  and one element is allowed here. for future scope this is marked as list
        """
        pulumi.set(__self__, "configuration", configuration)
        pulumi.set(__self__, "document_types", document_types)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Mapping[str, Mapping[str, _builtins.str]]:
        """
        model configuration details For PII :  < ENTITY_TYPE , ConfigurationDetails> ex."ORACLE":{ "mode" : "MASK","maskingCharacter" : "&","leaveCharactersUnmasked": 3,"isUnmaskedFromEnd" : true  } For language translation : { "targetLanguageCodes" : ConfigurationDetails}
        """
        return pulumi.get(self, "configuration")

    @_builtins.property
    @pulumi.getter(name="documentTypes")
    def document_types(self) -> Sequence[_builtins.str]:
        """
        Type of documents supported for this release only TXT,CSV  and one element is allowed here. for future scope this is marked as list
        """
        return pulumi.get(self, "document_types")


@pulumi.output_type
class GetJobsJobCollectionItemInputLocationResult(dict):
    def __init__(__self__, *,
                 bucket: _builtins.str,
                 location_type: _builtins.str,
                 namespace: _builtins.str,
                 object_names: Sequence[_builtins.str]):
        """
        :param _builtins.str bucket: Object Storage bucket name.
        :param _builtins.str location_type: locationType
        :param _builtins.str namespace: Object Storage namespace name.
        :param Sequence[_builtins.str] object_names: List of objects to be processed
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "location_type", location_type)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "object_names", object_names)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        Object Storage bucket name.
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="locationType")
    def location_type(self) -> _builtins.str:
        """
        locationType
        """
        return pulumi.get(self, "location_type")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Object Storage namespace name.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="objectNames")
    def object_names(self) -> Sequence[_builtins.str]:
        """
        List of objects to be processed
        """
        return pulumi.get(self, "object_names")


@pulumi.output_type
class GetJobsJobCollectionItemModelMetadataDetailResult(dict):
    def __init__(__self__, *,
                 configuration: Mapping[str, Mapping[str, _builtins.str]],
                 endpoint_id: _builtins.str,
                 language_code: _builtins.str,
                 model_id: _builtins.str,
                 model_type: _builtins.str):
        """
        :param Mapping[str, Mapping[str, _builtins.str]] configuration: model configuration details For PII :  < ENTITY_TYPE , ConfigurationDetails> ex."ORACLE":{ "mode" : "MASK","maskingCharacter" : "&","leaveCharactersUnmasked": 3,"isUnmaskedFromEnd" : true  } For language translation : { "targetLanguageCodes" : ConfigurationDetails}
        :param _builtins.str endpoint_id: Unique identifier endpoint OCID that should be used for inference
        :param _builtins.str language_code: Language code supported
               * auto : Automatically detect language
               * ar : Arabic
               * pt-BR : Brazilian Portuguese
               * cs : Czech
               * da : Danish
               * nl : Dutch
               * en : English
               * fi : Finnish
               * fr : French
               * fr-CA : Canadian French
               * de : German
               * it : Italian
               * ja : Japanese
               * ko : Korean
               * no : Norwegian
               * pl : Polish
               * ro : Romanian
               * zh-CN : Simplified Chinese
               * es : Spanish
               * sv : Swedish
               * zh-TW : Traditional Chinese
               * tr : Turkish
               * el : Greek
               * he : Hebrew
        :param _builtins.str model_id: Unique identifier model OCID that should be used for inference
        :param _builtins.str model_type: model type to used for inference allowed values are
               * LANGUAGE_SENTIMENT_ANALYSIS
               * LANGUAGE_DETECTION
               * TEXT_CLASSIFICATION
               * NAMED_ENTITY_RECOGNITION
               * KEY_PHRASE_EXTRACTION
               * LANGUAGE_PII_ENTITIES
               * LANGUAGE_TRANSLATION
        """
        pulumi.set(__self__, "configuration", configuration)
        pulumi.set(__self__, "endpoint_id", endpoint_id)
        pulumi.set(__self__, "language_code", language_code)
        pulumi.set(__self__, "model_id", model_id)
        pulumi.set(__self__, "model_type", model_type)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Mapping[str, Mapping[str, _builtins.str]]:
        """
        model configuration details For PII :  < ENTITY_TYPE , ConfigurationDetails> ex."ORACLE":{ "mode" : "MASK","maskingCharacter" : "&","leaveCharactersUnmasked": 3,"isUnmaskedFromEnd" : true  } For language translation : { "targetLanguageCodes" : ConfigurationDetails}
        """
        return pulumi.get(self, "configuration")

    @_builtins.property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> _builtins.str:
        """
        Unique identifier endpoint OCID that should be used for inference
        """
        return pulumi.get(self, "endpoint_id")

    @_builtins.property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> _builtins.str:
        """
        Language code supported
        * auto : Automatically detect language
        * ar : Arabic
        * pt-BR : Brazilian Portuguese
        * cs : Czech
        * da : Danish
        * nl : Dutch
        * en : English
        * fi : Finnish
        * fr : French
        * fr-CA : Canadian French
        * de : German
        * it : Italian
        * ja : Japanese
        * ko : Korean
        * no : Norwegian
        * pl : Polish
        * ro : Romanian
        * zh-CN : Simplified Chinese
        * es : Spanish
        * sv : Swedish
        * zh-TW : Traditional Chinese
        * tr : Turkish
        * el : Greek
        * he : Hebrew
        """
        return pulumi.get(self, "language_code")

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> _builtins.str:
        """
        Unique identifier model OCID that should be used for inference
        """
        return pulumi.get(self, "model_id")

    @_builtins.property
    @pulumi.getter(name="modelType")
    def model_type(self) -> _builtins.str:
        """
        model type to used for inference allowed values are
        * LANGUAGE_SENTIMENT_ANALYSIS
        * LANGUAGE_DETECTION
        * TEXT_CLASSIFICATION
        * NAMED_ENTITY_RECOGNITION
        * KEY_PHRASE_EXTRACTION
        * LANGUAGE_PII_ENTITIES
        * LANGUAGE_TRANSLATION
        """
        return pulumi.get(self, "model_type")


@pulumi.output_type
class GetJobsJobCollectionItemOutputLocationResult(dict):
    def __init__(__self__, *,
                 bucket: _builtins.str,
                 namespace: _builtins.str,
                 prefix: _builtins.str):
        """
        :param _builtins.str bucket: Object Storage bucket name.
        :param _builtins.str namespace: Object Storage namespace name.
        :param _builtins.str prefix: The prefix (directory) in an Object Storage bucket.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        Object Storage bucket name.
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Object Storage namespace name.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> _builtins.str:
        """
        The prefix (directory) in an Object Storage bucket.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class GetModelEvaluationResultResult(dict):
    def __init__(__self__, *,
                 class_metrics: Sequence['outputs.GetModelEvaluationResultClassMetricResult'],
                 confusion_matrix: _builtins.str,
                 entity_metrics: Sequence['outputs.GetModelEvaluationResultEntityMetricResult'],
                 labels: Sequence[_builtins.str],
                 metrics: Sequence['outputs.GetModelEvaluationResultMetricResult'],
                 model_type: _builtins.str):
        """
        :param Sequence['GetModelEvaluationResultClassMetricArgs'] class_metrics: List of text classification metrics
        :param _builtins.str confusion_matrix: class level confusion matrix
        :param Sequence['GetModelEvaluationResultEntityMetricArgs'] entity_metrics: List of entity metrics
        :param Sequence[_builtins.str] labels: labels
        :param Sequence['GetModelEvaluationResultMetricArgs'] metrics: Model level named entity recognition metrics
        :param _builtins.str model_type: Model type
        """
        pulumi.set(__self__, "class_metrics", class_metrics)
        pulumi.set(__self__, "confusion_matrix", confusion_matrix)
        pulumi.set(__self__, "entity_metrics", entity_metrics)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "model_type", model_type)

    @_builtins.property
    @pulumi.getter(name="classMetrics")
    def class_metrics(self) -> Sequence['outputs.GetModelEvaluationResultClassMetricResult']:
        """
        List of text classification metrics
        """
        return pulumi.get(self, "class_metrics")

    @_builtins.property
    @pulumi.getter(name="confusionMatrix")
    def confusion_matrix(self) -> _builtins.str:
        """
        class level confusion matrix
        """
        return pulumi.get(self, "confusion_matrix")

    @_builtins.property
    @pulumi.getter(name="entityMetrics")
    def entity_metrics(self) -> Sequence['outputs.GetModelEvaluationResultEntityMetricResult']:
        """
        List of entity metrics
        """
        return pulumi.get(self, "entity_metrics")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Sequence[_builtins.str]:
        """
        labels
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Sequence['outputs.GetModelEvaluationResultMetricResult']:
        """
        Model level named entity recognition metrics
        """
        return pulumi.get(self, "metrics")

    @_builtins.property
    @pulumi.getter(name="modelType")
    def model_type(self) -> _builtins.str:
        """
        Model type
        """
        return pulumi.get(self, "model_type")


@pulumi.output_type
class GetModelEvaluationResultClassMetricResult(dict):
    def __init__(__self__, *,
                 f1: _builtins.float,
                 label: _builtins.str,
                 precision: _builtins.float,
                 recall: _builtins.float,
                 support: _builtins.float):
        """
        :param _builtins.float f1: F1-score, is a measure of a model’s accuracy on a dataset
        :param _builtins.str label: Entity label
        :param _builtins.float precision: Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
        :param _builtins.float recall: Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
        :param _builtins.float support: number of samples in the test set
        """
        pulumi.set(__self__, "f1", f1)
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "precision", precision)
        pulumi.set(__self__, "recall", recall)
        pulumi.set(__self__, "support", support)

    @_builtins.property
    @pulumi.getter
    def f1(self) -> _builtins.float:
        """
        F1-score, is a measure of a model’s accuracy on a dataset
        """
        return pulumi.get(self, "f1")

    @_builtins.property
    @pulumi.getter
    def label(self) -> _builtins.str:
        """
        Entity label
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter
    def precision(self) -> _builtins.float:
        """
        Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
        """
        return pulumi.get(self, "precision")

    @_builtins.property
    @pulumi.getter
    def recall(self) -> _builtins.float:
        """
        Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
        """
        return pulumi.get(self, "recall")

    @_builtins.property
    @pulumi.getter
    def support(self) -> _builtins.float:
        """
        number of samples in the test set
        """
        return pulumi.get(self, "support")


@pulumi.output_type
class GetModelEvaluationResultEntityMetricResult(dict):
    def __init__(__self__, *,
                 f1: _builtins.float,
                 label: _builtins.str,
                 precision: _builtins.float,
                 recall: _builtins.float):
        """
        :param _builtins.float f1: F1-score, is a measure of a model’s accuracy on a dataset
        :param _builtins.str label: Entity label
        :param _builtins.float precision: Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
        :param _builtins.float recall: Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
        """
        pulumi.set(__self__, "f1", f1)
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "precision", precision)
        pulumi.set(__self__, "recall", recall)

    @_builtins.property
    @pulumi.getter
    def f1(self) -> _builtins.float:
        """
        F1-score, is a measure of a model’s accuracy on a dataset
        """
        return pulumi.get(self, "f1")

    @_builtins.property
    @pulumi.getter
    def label(self) -> _builtins.str:
        """
        Entity label
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter
    def precision(self) -> _builtins.float:
        """
        Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
        """
        return pulumi.get(self, "precision")

    @_builtins.property
    @pulumi.getter
    def recall(self) -> _builtins.float:
        """
        Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
        """
        return pulumi.get(self, "recall")


@pulumi.output_type
class GetModelEvaluationResultMetricResult(dict):
    def __init__(__self__, *,
                 accuracy: _builtins.float,
                 macro_f1: _builtins.float,
                 macro_precision: _builtins.float,
                 macro_recall: _builtins.float,
                 micro_f1: _builtins.float,
                 micro_precision: _builtins.float,
                 micro_recall: _builtins.float,
                 weighted_f1: _builtins.float,
                 weighted_precision: _builtins.float,
                 weighted_recall: _builtins.float):
        """
        :param _builtins.float accuracy: The fraction of the labels that were correctly recognised .
        :param _builtins.float macro_f1: F1-score, is a measure of a model’s accuracy on a dataset
        :param _builtins.float macro_precision: Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
        :param _builtins.float macro_recall: Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
        :param _builtins.float micro_f1: F1-score, is a measure of a model’s accuracy on a dataset
        :param _builtins.float micro_precision: Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
        :param _builtins.float micro_recall: Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
        :param _builtins.float weighted_f1: F1-score, is a measure of a model’s accuracy on a dataset
        :param _builtins.float weighted_precision: Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
        :param _builtins.float weighted_recall: Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
        """
        pulumi.set(__self__, "accuracy", accuracy)
        pulumi.set(__self__, "macro_f1", macro_f1)
        pulumi.set(__self__, "macro_precision", macro_precision)
        pulumi.set(__self__, "macro_recall", macro_recall)
        pulumi.set(__self__, "micro_f1", micro_f1)
        pulumi.set(__self__, "micro_precision", micro_precision)
        pulumi.set(__self__, "micro_recall", micro_recall)
        pulumi.set(__self__, "weighted_f1", weighted_f1)
        pulumi.set(__self__, "weighted_precision", weighted_precision)
        pulumi.set(__self__, "weighted_recall", weighted_recall)

    @_builtins.property
    @pulumi.getter
    def accuracy(self) -> _builtins.float:
        """
        The fraction of the labels that were correctly recognised .
        """
        return pulumi.get(self, "accuracy")

    @_builtins.property
    @pulumi.getter(name="macroF1")
    def macro_f1(self) -> _builtins.float:
        """
        F1-score, is a measure of a model’s accuracy on a dataset
        """
        return pulumi.get(self, "macro_f1")

    @_builtins.property
    @pulumi.getter(name="macroPrecision")
    def macro_precision(self) -> _builtins.float:
        """
        Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
        """
        return pulumi.get(self, "macro_precision")

    @_builtins.property
    @pulumi.getter(name="macroRecall")
    def macro_recall(self) -> _builtins.float:
        """
        Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
        """
        return pulumi.get(self, "macro_recall")

    @_builtins.property
    @pulumi.getter(name="microF1")
    def micro_f1(self) -> _builtins.float:
        """
        F1-score, is a measure of a model’s accuracy on a dataset
        """
        return pulumi.get(self, "micro_f1")

    @_builtins.property
    @pulumi.getter(name="microPrecision")
    def micro_precision(self) -> _builtins.float:
        """
        Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
        """
        return pulumi.get(self, "micro_precision")

    @_builtins.property
    @pulumi.getter(name="microRecall")
    def micro_recall(self) -> _builtins.float:
        """
        Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
        """
        return pulumi.get(self, "micro_recall")

    @_builtins.property
    @pulumi.getter(name="weightedF1")
    def weighted_f1(self) -> _builtins.float:
        """
        F1-score, is a measure of a model’s accuracy on a dataset
        """
        return pulumi.get(self, "weighted_f1")

    @_builtins.property
    @pulumi.getter(name="weightedPrecision")
    def weighted_precision(self) -> _builtins.float:
        """
        Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
        """
        return pulumi.get(self, "weighted_precision")

    @_builtins.property
    @pulumi.getter(name="weightedRecall")
    def weighted_recall(self) -> _builtins.float:
        """
        Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
        """
        return pulumi.get(self, "weighted_recall")


@pulumi.output_type
class GetModelEvaluationResultsEvaluationResultCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetModelEvaluationResultsEvaluationResultCollectionItemResult']):
        """
        :param Sequence['GetModelEvaluationResultsEvaluationResultCollectionItemArgs'] items: List of model evaluation analysis
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetModelEvaluationResultsEvaluationResultCollectionItemResult']:
        """
        List of model evaluation analysis
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetModelEvaluationResultsEvaluationResultCollectionItemResult(dict):
    def __init__(__self__, *,
                 defined_tags: Mapping[str, _builtins.str],
                 freeform_tags: Mapping[str, _builtins.str],
                 location: _builtins.str,
                 model_type: _builtins.str,
                 predicted_entities: Sequence['outputs.GetModelEvaluationResultsEvaluationResultCollectionItemPredictedEntityResult'],
                 predicted_labels: Sequence[_builtins.str],
                 record: _builtins.str,
                 true_entities: Sequence['outputs.GetModelEvaluationResultsEvaluationResultCollectionItemTrueEntityResult'],
                 true_labels: Sequence[_builtins.str]):
        """
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param Mapping[str, _builtins.str] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param _builtins.str location: For CSV format location is rowId(1 is header) and for JSONL location is jsonL line sequence(1 is metadata)
        :param _builtins.str model_type: Model type
        :param Sequence['GetModelEvaluationResultsEvaluationResultCollectionItemPredictedEntityArgs'] predicted_entities: List of true(actual) entities in test data for NER model
        :param Sequence[_builtins.str] predicted_labels: List of predicted labels by custom multi class or multi label TextClassification model
        :param _builtins.str record: For CSV format location is rowId(1 is header) and for JSONL location is jsonL line sequence(1 is metadata)
        :param Sequence['GetModelEvaluationResultsEvaluationResultCollectionItemTrueEntityArgs'] true_entities: List of true(actual) entities in test data for NER model
        :param Sequence[_builtins.str] true_labels: List of true(actual) labels in test data for multi class or multi label TextClassification
        """
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "model_type", model_type)
        pulumi.set(__self__, "predicted_entities", predicted_entities)
        pulumi.set(__self__, "predicted_labels", predicted_labels)
        pulumi.set(__self__, "record", record)
        pulumi.set(__self__, "true_entities", true_entities)
        pulumi.set(__self__, "true_labels", true_labels)

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def location(self) -> _builtins.str:
        """
        For CSV format location is rowId(1 is header) and for JSONL location is jsonL line sequence(1 is metadata)
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter(name="modelType")
    def model_type(self) -> _builtins.str:
        """
        Model type
        """
        return pulumi.get(self, "model_type")

    @_builtins.property
    @pulumi.getter(name="predictedEntities")
    def predicted_entities(self) -> Sequence['outputs.GetModelEvaluationResultsEvaluationResultCollectionItemPredictedEntityResult']:
        """
        List of true(actual) entities in test data for NER model
        """
        return pulumi.get(self, "predicted_entities")

    @_builtins.property
    @pulumi.getter(name="predictedLabels")
    def predicted_labels(self) -> Sequence[_builtins.str]:
        """
        List of predicted labels by custom multi class or multi label TextClassification model
        """
        return pulumi.get(self, "predicted_labels")

    @_builtins.property
    @pulumi.getter
    def record(self) -> _builtins.str:
        """
        For CSV format location is rowId(1 is header) and for JSONL location is jsonL line sequence(1 is metadata)
        """
        return pulumi.get(self, "record")

    @_builtins.property
    @pulumi.getter(name="trueEntities")
    def true_entities(self) -> Sequence['outputs.GetModelEvaluationResultsEvaluationResultCollectionItemTrueEntityResult']:
        """
        List of true(actual) entities in test data for NER model
        """
        return pulumi.get(self, "true_entities")

    @_builtins.property
    @pulumi.getter(name="trueLabels")
    def true_labels(self) -> Sequence[_builtins.str]:
        """
        List of true(actual) labels in test data for multi class or multi label TextClassification
        """
        return pulumi.get(self, "true_labels")


@pulumi.output_type
class GetModelEvaluationResultsEvaluationResultCollectionItemPredictedEntityResult(dict):
    def __init__(__self__, *,
                 length: _builtins.int,
                 offset: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.int length: Length of text
        :param _builtins.int offset: Starting index on text.
        :param _builtins.str type: Type of entity text like PER, LOC, GPE, NOPE etc.
        """
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def length(self) -> _builtins.int:
        """
        Length of text
        """
        return pulumi.get(self, "length")

    @_builtins.property
    @pulumi.getter
    def offset(self) -> _builtins.int:
        """
        Starting index on text.
        """
        return pulumi.get(self, "offset")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of entity text like PER, LOC, GPE, NOPE etc.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetModelEvaluationResultsEvaluationResultCollectionItemTrueEntityResult(dict):
    def __init__(__self__, *,
                 length: _builtins.int,
                 offset: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.int length: Length of text
        :param _builtins.int offset: Starting index on text.
        :param _builtins.str type: Type of entity text like PER, LOC, GPE, NOPE etc.
        """
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def length(self) -> _builtins.int:
        """
        Length of text
        """
        return pulumi.get(self, "length")

    @_builtins.property
    @pulumi.getter
    def offset(self) -> _builtins.int:
        """
        Starting index on text.
        """
        return pulumi.get(self, "offset")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of entity text like PER, LOC, GPE, NOPE etc.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetModelEvaluationResultsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetModelModelDetailResult(dict):
    def __init__(__self__, *,
                 classification_modes: Sequence['outputs.GetModelModelDetailClassificationModeResult'],
                 language_code: _builtins.str,
                 model_type: _builtins.str,
                 version: _builtins.str):
        """
        :param Sequence['GetModelModelDetailClassificationModeArgs'] classification_modes: classification Modes
        :param _builtins.str language_code: supported language default value is en
        :param _builtins.str model_type: Model type
        :param _builtins.str version: For pre trained models this will identify model type version used for model creation For custom this will identify model type version used for model creation and custom model on which training has to be done <<service>>::<<service-name>>_<<model-type-version>>::<<custom model on which this training has to be done>> ex: ai-lang::NER_V1::CUSTOM-V0
        """
        pulumi.set(__self__, "classification_modes", classification_modes)
        pulumi.set(__self__, "language_code", language_code)
        pulumi.set(__self__, "model_type", model_type)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="classificationModes")
    def classification_modes(self) -> Sequence['outputs.GetModelModelDetailClassificationModeResult']:
        """
        classification Modes
        """
        return pulumi.get(self, "classification_modes")

    @_builtins.property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> _builtins.str:
        """
        supported language default value is en
        """
        return pulumi.get(self, "language_code")

    @_builtins.property
    @pulumi.getter(name="modelType")
    def model_type(self) -> _builtins.str:
        """
        Model type
        """
        return pulumi.get(self, "model_type")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        For pre trained models this will identify model type version used for model creation For custom this will identify model type version used for model creation and custom model on which training has to be done <<service>>::<<service-name>>_<<model-type-version>>::<<custom model on which this training has to be done>> ex: ai-lang::NER_V1::CUSTOM-V0
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetModelModelDetailClassificationModeResult(dict):
    def __init__(__self__, *,
                 classification_mode: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str classification_mode: classification Modes
        :param _builtins.str version: For pre trained models this will identify model type version used for model creation For custom this will identify model type version used for model creation and custom model on which training has to be done <<service>>::<<service-name>>_<<model-type-version>>::<<custom model on which this training has to be done>> ex: ai-lang::NER_V1::CUSTOM-V0
        """
        pulumi.set(__self__, "classification_mode", classification_mode)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="classificationMode")
    def classification_mode(self) -> _builtins.str:
        """
        classification Modes
        """
        return pulumi.get(self, "classification_mode")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        For pre trained models this will identify model type version used for model creation For custom this will identify model type version used for model creation and custom model on which training has to be done <<service>>::<<service-name>>_<<model-type-version>>::<<custom model on which this training has to be done>> ex: ai-lang::NER_V1::CUSTOM-V0
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetModelTestStrategyResult(dict):
    def __init__(__self__, *,
                 strategy_type: _builtins.str,
                 testing_datasets: Sequence['outputs.GetModelTestStrategyTestingDatasetResult'],
                 validation_datasets: Sequence['outputs.GetModelTestStrategyValidationDatasetResult']):
        """
        :param _builtins.str strategy_type: This information will define the test strategy different datasets for test and validation(optional) dataset.
        :param Sequence['GetModelTestStrategyTestingDatasetArgs'] testing_datasets: Possible data set type
        :param Sequence['GetModelTestStrategyValidationDatasetArgs'] validation_datasets: Possible data set type
        """
        pulumi.set(__self__, "strategy_type", strategy_type)
        pulumi.set(__self__, "testing_datasets", testing_datasets)
        pulumi.set(__self__, "validation_datasets", validation_datasets)

    @_builtins.property
    @pulumi.getter(name="strategyType")
    def strategy_type(self) -> _builtins.str:
        """
        This information will define the test strategy different datasets for test and validation(optional) dataset.
        """
        return pulumi.get(self, "strategy_type")

    @_builtins.property
    @pulumi.getter(name="testingDatasets")
    def testing_datasets(self) -> Sequence['outputs.GetModelTestStrategyTestingDatasetResult']:
        """
        Possible data set type
        """
        return pulumi.get(self, "testing_datasets")

    @_builtins.property
    @pulumi.getter(name="validationDatasets")
    def validation_datasets(self) -> Sequence['outputs.GetModelTestStrategyValidationDatasetResult']:
        """
        Possible data set type
        """
        return pulumi.get(self, "validation_datasets")


@pulumi.output_type
class GetModelTestStrategyTestingDatasetResult(dict):
    def __init__(__self__, *,
                 dataset_id: _builtins.str,
                 dataset_type: _builtins.str,
                 location_details: Sequence['outputs.GetModelTestStrategyTestingDatasetLocationDetailResult']):
        """
        :param _builtins.str dataset_id: Data Science Labelling Service OCID
        :param _builtins.str dataset_type: Possible data sets
        :param Sequence['GetModelTestStrategyTestingDatasetLocationDetailArgs'] location_details: Possible object storage location types
        """
        pulumi.set(__self__, "dataset_id", dataset_id)
        pulumi.set(__self__, "dataset_type", dataset_type)
        pulumi.set(__self__, "location_details", location_details)

    @_builtins.property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> _builtins.str:
        """
        Data Science Labelling Service OCID
        """
        return pulumi.get(self, "dataset_id")

    @_builtins.property
    @pulumi.getter(name="datasetType")
    def dataset_type(self) -> _builtins.str:
        """
        Possible data sets
        """
        return pulumi.get(self, "dataset_type")

    @_builtins.property
    @pulumi.getter(name="locationDetails")
    def location_details(self) -> Sequence['outputs.GetModelTestStrategyTestingDatasetLocationDetailResult']:
        """
        Possible object storage location types
        """
        return pulumi.get(self, "location_details")


@pulumi.output_type
class GetModelTestStrategyTestingDatasetLocationDetailResult(dict):
    def __init__(__self__, *,
                 bucket: _builtins.str,
                 location_type: _builtins.str,
                 namespace: _builtins.str,
                 object_names: Sequence[_builtins.str]):
        """
        :param _builtins.str bucket: Object storage bucket name
        :param _builtins.str location_type: Possible object storage location types
        :param _builtins.str namespace: Object storage namespace
        :param Sequence[_builtins.str] object_names: Array of files which need to be processed in the bucket
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "location_type", location_type)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "object_names", object_names)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        Object storage bucket name
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="locationType")
    def location_type(self) -> _builtins.str:
        """
        Possible object storage location types
        """
        return pulumi.get(self, "location_type")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Object storage namespace
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="objectNames")
    def object_names(self) -> Sequence[_builtins.str]:
        """
        Array of files which need to be processed in the bucket
        """
        return pulumi.get(self, "object_names")


@pulumi.output_type
class GetModelTestStrategyValidationDatasetResult(dict):
    def __init__(__self__, *,
                 dataset_id: _builtins.str,
                 dataset_type: _builtins.str,
                 location_details: Sequence['outputs.GetModelTestStrategyValidationDatasetLocationDetailResult']):
        """
        :param _builtins.str dataset_id: Data Science Labelling Service OCID
        :param _builtins.str dataset_type: Possible data sets
        :param Sequence['GetModelTestStrategyValidationDatasetLocationDetailArgs'] location_details: Possible object storage location types
        """
        pulumi.set(__self__, "dataset_id", dataset_id)
        pulumi.set(__self__, "dataset_type", dataset_type)
        pulumi.set(__self__, "location_details", location_details)

    @_builtins.property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> _builtins.str:
        """
        Data Science Labelling Service OCID
        """
        return pulumi.get(self, "dataset_id")

    @_builtins.property
    @pulumi.getter(name="datasetType")
    def dataset_type(self) -> _builtins.str:
        """
        Possible data sets
        """
        return pulumi.get(self, "dataset_type")

    @_builtins.property
    @pulumi.getter(name="locationDetails")
    def location_details(self) -> Sequence['outputs.GetModelTestStrategyValidationDatasetLocationDetailResult']:
        """
        Possible object storage location types
        """
        return pulumi.get(self, "location_details")


@pulumi.output_type
class GetModelTestStrategyValidationDatasetLocationDetailResult(dict):
    def __init__(__self__, *,
                 bucket: _builtins.str,
                 location_type: _builtins.str,
                 namespace: _builtins.str,
                 object_names: Sequence[_builtins.str]):
        """
        :param _builtins.str bucket: Object storage bucket name
        :param _builtins.str location_type: Possible object storage location types
        :param _builtins.str namespace: Object storage namespace
        :param Sequence[_builtins.str] object_names: Array of files which need to be processed in the bucket
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "location_type", location_type)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "object_names", object_names)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        Object storage bucket name
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="locationType")
    def location_type(self) -> _builtins.str:
        """
        Possible object storage location types
        """
        return pulumi.get(self, "location_type")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Object storage namespace
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="objectNames")
    def object_names(self) -> Sequence[_builtins.str]:
        """
        Array of files which need to be processed in the bucket
        """
        return pulumi.get(self, "object_names")


@pulumi.output_type
class GetModelTrainingDatasetResult(dict):
    def __init__(__self__, *,
                 dataset_id: _builtins.str,
                 dataset_type: _builtins.str,
                 location_details: Sequence['outputs.GetModelTrainingDatasetLocationDetailResult']):
        """
        :param _builtins.str dataset_id: Data Science Labelling Service OCID
        :param _builtins.str dataset_type: Possible data sets
        :param Sequence['GetModelTrainingDatasetLocationDetailArgs'] location_details: Possible object storage location types
        """
        pulumi.set(__self__, "dataset_id", dataset_id)
        pulumi.set(__self__, "dataset_type", dataset_type)
        pulumi.set(__self__, "location_details", location_details)

    @_builtins.property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> _builtins.str:
        """
        Data Science Labelling Service OCID
        """
        return pulumi.get(self, "dataset_id")

    @_builtins.property
    @pulumi.getter(name="datasetType")
    def dataset_type(self) -> _builtins.str:
        """
        Possible data sets
        """
        return pulumi.get(self, "dataset_type")

    @_builtins.property
    @pulumi.getter(name="locationDetails")
    def location_details(self) -> Sequence['outputs.GetModelTrainingDatasetLocationDetailResult']:
        """
        Possible object storage location types
        """
        return pulumi.get(self, "location_details")


@pulumi.output_type
class GetModelTrainingDatasetLocationDetailResult(dict):
    def __init__(__self__, *,
                 bucket: _builtins.str,
                 location_type: _builtins.str,
                 namespace: _builtins.str,
                 object_names: Sequence[_builtins.str]):
        """
        :param _builtins.str bucket: Object storage bucket name
        :param _builtins.str location_type: Possible object storage location types
        :param _builtins.str namespace: Object storage namespace
        :param Sequence[_builtins.str] object_names: Array of files which need to be processed in the bucket
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "location_type", location_type)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "object_names", object_names)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        Object storage bucket name
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="locationType")
    def location_type(self) -> _builtins.str:
        """
        Possible object storage location types
        """
        return pulumi.get(self, "location_type")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Object storage namespace
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="objectNames")
    def object_names(self) -> Sequence[_builtins.str]:
        """
        Array of files which need to be processed in the bucket
        """
        return pulumi.get(self, "object_names")


@pulumi.output_type
class GetModelsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetModelsModelCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetModelsModelCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetModelsModelCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetModelsModelCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 description: _builtins.str,
                 display_name: _builtins.str,
                 evaluation_results: Sequence['outputs.GetModelsModelCollectionItemEvaluationResultResult'],
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 model_details: Sequence['outputs.GetModelsModelCollectionItemModelDetailResult'],
                 project_id: _builtins.str,
                 state: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 test_strategies: Sequence['outputs.GetModelsModelCollectionItemTestStrategyResult'],
                 time_created: _builtins.str,
                 time_updated: _builtins.str,
                 training_datasets: Sequence['outputs.GetModelsModelCollectionItemTrainingDatasetResult'],
                 version: _builtins.str):
        """
        :param _builtins.str compartment_id: The ID of the compartment in which to list resources.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param _builtins.str description: A short description of the Model.
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given.
        :param Sequence['GetModelsModelCollectionItemEvaluationResultArgs'] evaluation_results: model training results of different models
        :param Mapping[str, _builtins.str] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param _builtins.str id: Unique identifier model OCID of a model that is immutable on creation
        :param _builtins.str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in failed state.
        :param Sequence['GetModelsModelCollectionItemModelDetailArgs'] model_details: Possible model types
        :param _builtins.str project_id: The ID of the project for which to list the objects.
        :param _builtins.str state: <b>Filter</b> results by the specified lifecycle state. Must be a valid state for the resource type.
        :param Mapping[str, _builtins.str] system_tags: Usage of system tag keys. These predefined keys are scoped to namespaces. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param Sequence['GetModelsModelCollectionItemTestStrategyArgs'] test_strategies: Possible strategy as testing and validation(optional) dataset.
        :param _builtins.str time_created: The time the the model was created. An RFC3339 formatted datetime string.
        :param _builtins.str time_updated: The time the model was updated. An RFC3339 formatted datetime string.
        :param Sequence['GetModelsModelCollectionItemTrainingDatasetArgs'] training_datasets: Possible data set type
        :param _builtins.str version: For pre trained models this will identify model type version used for model creation For custom this will identify model type version used for model creation and custom model on which training has to be done <<service>>::<<service-name>>_<<model-type-version>>::<<custom model on which this training has to be done>> ex: ai-lang::NER_V1::CUSTOM-V0
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "evaluation_results", evaluation_results)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "model_details", model_details)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "test_strategies", test_strategies)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)
        pulumi.set(__self__, "training_datasets", training_datasets)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        A short description of the Model.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="evaluationResults")
    def evaluation_results(self) -> Sequence['outputs.GetModelsModelCollectionItemEvaluationResultResult']:
        """
        model training results of different models
        """
        return pulumi.get(self, "evaluation_results")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique identifier model OCID of a model that is immutable on creation
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter(name="modelDetails")
    def model_details(self) -> Sequence['outputs.GetModelsModelCollectionItemModelDetailResult']:
        """
        Possible model types
        """
        return pulumi.get(self, "model_details")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        The ID of the project for which to list the objects.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        <b>Filter</b> results by the specified lifecycle state. Must be a valid state for the resource type.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        Usage of system tag keys. These predefined keys are scoped to namespaces. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="testStrategies")
    def test_strategies(self) -> Sequence['outputs.GetModelsModelCollectionItemTestStrategyResult']:
        """
        Possible strategy as testing and validation(optional) dataset.
        """
        return pulumi.get(self, "test_strategies")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The time the the model was created. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The time the model was updated. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_updated")

    @_builtins.property
    @pulumi.getter(name="trainingDatasets")
    def training_datasets(self) -> Sequence['outputs.GetModelsModelCollectionItemTrainingDatasetResult']:
        """
        Possible data set type
        """
        return pulumi.get(self, "training_datasets")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        For pre trained models this will identify model type version used for model creation For custom this will identify model type version used for model creation and custom model on which training has to be done <<service>>::<<service-name>>_<<model-type-version>>::<<custom model on which this training has to be done>> ex: ai-lang::NER_V1::CUSTOM-V0
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetModelsModelCollectionItemEvaluationResultResult(dict):
    def __init__(__self__, *,
                 class_metrics: Sequence['outputs.GetModelsModelCollectionItemEvaluationResultClassMetricResult'],
                 confusion_matrix: _builtins.str,
                 entity_metrics: Sequence['outputs.GetModelsModelCollectionItemEvaluationResultEntityMetricResult'],
                 labels: Sequence[_builtins.str],
                 metrics: Sequence['outputs.GetModelsModelCollectionItemEvaluationResultMetricResult'],
                 model_type: _builtins.str):
        """
        :param Sequence['GetModelsModelCollectionItemEvaluationResultClassMetricArgs'] class_metrics: List of text classification metrics
        :param _builtins.str confusion_matrix: class level confusion matrix
        :param Sequence['GetModelsModelCollectionItemEvaluationResultEntityMetricArgs'] entity_metrics: List of entity metrics
        :param Sequence[_builtins.str] labels: labels
        :param Sequence['GetModelsModelCollectionItemEvaluationResultMetricArgs'] metrics: Model level named entity recognition metrics
        :param _builtins.str model_type: Model type
        """
        pulumi.set(__self__, "class_metrics", class_metrics)
        pulumi.set(__self__, "confusion_matrix", confusion_matrix)
        pulumi.set(__self__, "entity_metrics", entity_metrics)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "model_type", model_type)

    @_builtins.property
    @pulumi.getter(name="classMetrics")
    def class_metrics(self) -> Sequence['outputs.GetModelsModelCollectionItemEvaluationResultClassMetricResult']:
        """
        List of text classification metrics
        """
        return pulumi.get(self, "class_metrics")

    @_builtins.property
    @pulumi.getter(name="confusionMatrix")
    def confusion_matrix(self) -> _builtins.str:
        """
        class level confusion matrix
        """
        return pulumi.get(self, "confusion_matrix")

    @_builtins.property
    @pulumi.getter(name="entityMetrics")
    def entity_metrics(self) -> Sequence['outputs.GetModelsModelCollectionItemEvaluationResultEntityMetricResult']:
        """
        List of entity metrics
        """
        return pulumi.get(self, "entity_metrics")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Sequence[_builtins.str]:
        """
        labels
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Sequence['outputs.GetModelsModelCollectionItemEvaluationResultMetricResult']:
        """
        Model level named entity recognition metrics
        """
        return pulumi.get(self, "metrics")

    @_builtins.property
    @pulumi.getter(name="modelType")
    def model_type(self) -> _builtins.str:
        """
        Model type
        """
        return pulumi.get(self, "model_type")


@pulumi.output_type
class GetModelsModelCollectionItemEvaluationResultClassMetricResult(dict):
    def __init__(__self__, *,
                 f1: _builtins.float,
                 label: _builtins.str,
                 precision: _builtins.float,
                 recall: _builtins.float,
                 support: _builtins.float):
        """
        :param _builtins.float f1: F1-score, is a measure of a model’s accuracy on a dataset
        :param _builtins.str label: Entity label
        :param _builtins.float precision: Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
        :param _builtins.float recall: Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
        :param _builtins.float support: number of samples in the test set
        """
        pulumi.set(__self__, "f1", f1)
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "precision", precision)
        pulumi.set(__self__, "recall", recall)
        pulumi.set(__self__, "support", support)

    @_builtins.property
    @pulumi.getter
    def f1(self) -> _builtins.float:
        """
        F1-score, is a measure of a model’s accuracy on a dataset
        """
        return pulumi.get(self, "f1")

    @_builtins.property
    @pulumi.getter
    def label(self) -> _builtins.str:
        """
        Entity label
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter
    def precision(self) -> _builtins.float:
        """
        Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
        """
        return pulumi.get(self, "precision")

    @_builtins.property
    @pulumi.getter
    def recall(self) -> _builtins.float:
        """
        Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
        """
        return pulumi.get(self, "recall")

    @_builtins.property
    @pulumi.getter
    def support(self) -> _builtins.float:
        """
        number of samples in the test set
        """
        return pulumi.get(self, "support")


@pulumi.output_type
class GetModelsModelCollectionItemEvaluationResultEntityMetricResult(dict):
    def __init__(__self__, *,
                 f1: _builtins.float,
                 label: _builtins.str,
                 precision: _builtins.float,
                 recall: _builtins.float):
        """
        :param _builtins.float f1: F1-score, is a measure of a model’s accuracy on a dataset
        :param _builtins.str label: Entity label
        :param _builtins.float precision: Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
        :param _builtins.float recall: Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
        """
        pulumi.set(__self__, "f1", f1)
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "precision", precision)
        pulumi.set(__self__, "recall", recall)

    @_builtins.property
    @pulumi.getter
    def f1(self) -> _builtins.float:
        """
        F1-score, is a measure of a model’s accuracy on a dataset
        """
        return pulumi.get(self, "f1")

    @_builtins.property
    @pulumi.getter
    def label(self) -> _builtins.str:
        """
        Entity label
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter
    def precision(self) -> _builtins.float:
        """
        Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
        """
        return pulumi.get(self, "precision")

    @_builtins.property
    @pulumi.getter
    def recall(self) -> _builtins.float:
        """
        Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
        """
        return pulumi.get(self, "recall")


@pulumi.output_type
class GetModelsModelCollectionItemEvaluationResultMetricResult(dict):
    def __init__(__self__, *,
                 accuracy: _builtins.float,
                 macro_f1: _builtins.float,
                 macro_precision: _builtins.float,
                 macro_recall: _builtins.float,
                 micro_f1: _builtins.float,
                 micro_precision: _builtins.float,
                 micro_recall: _builtins.float,
                 weighted_f1: _builtins.float,
                 weighted_precision: _builtins.float,
                 weighted_recall: _builtins.float):
        """
        :param _builtins.float accuracy: The fraction of the labels that were correctly recognised .
        :param _builtins.float macro_f1: F1-score, is a measure of a model’s accuracy on a dataset
        :param _builtins.float macro_precision: Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
        :param _builtins.float macro_recall: Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
        :param _builtins.float micro_f1: F1-score, is a measure of a model’s accuracy on a dataset
        :param _builtins.float micro_precision: Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
        :param _builtins.float micro_recall: Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
        :param _builtins.float weighted_f1: F1-score, is a measure of a model’s accuracy on a dataset
        :param _builtins.float weighted_precision: Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
        :param _builtins.float weighted_recall: Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
        """
        pulumi.set(__self__, "accuracy", accuracy)
        pulumi.set(__self__, "macro_f1", macro_f1)
        pulumi.set(__self__, "macro_precision", macro_precision)
        pulumi.set(__self__, "macro_recall", macro_recall)
        pulumi.set(__self__, "micro_f1", micro_f1)
        pulumi.set(__self__, "micro_precision", micro_precision)
        pulumi.set(__self__, "micro_recall", micro_recall)
        pulumi.set(__self__, "weighted_f1", weighted_f1)
        pulumi.set(__self__, "weighted_precision", weighted_precision)
        pulumi.set(__self__, "weighted_recall", weighted_recall)

    @_builtins.property
    @pulumi.getter
    def accuracy(self) -> _builtins.float:
        """
        The fraction of the labels that were correctly recognised .
        """
        return pulumi.get(self, "accuracy")

    @_builtins.property
    @pulumi.getter(name="macroF1")
    def macro_f1(self) -> _builtins.float:
        """
        F1-score, is a measure of a model’s accuracy on a dataset
        """
        return pulumi.get(self, "macro_f1")

    @_builtins.property
    @pulumi.getter(name="macroPrecision")
    def macro_precision(self) -> _builtins.float:
        """
        Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
        """
        return pulumi.get(self, "macro_precision")

    @_builtins.property
    @pulumi.getter(name="macroRecall")
    def macro_recall(self) -> _builtins.float:
        """
        Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
        """
        return pulumi.get(self, "macro_recall")

    @_builtins.property
    @pulumi.getter(name="microF1")
    def micro_f1(self) -> _builtins.float:
        """
        F1-score, is a measure of a model’s accuracy on a dataset
        """
        return pulumi.get(self, "micro_f1")

    @_builtins.property
    @pulumi.getter(name="microPrecision")
    def micro_precision(self) -> _builtins.float:
        """
        Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
        """
        return pulumi.get(self, "micro_precision")

    @_builtins.property
    @pulumi.getter(name="microRecall")
    def micro_recall(self) -> _builtins.float:
        """
        Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
        """
        return pulumi.get(self, "micro_recall")

    @_builtins.property
    @pulumi.getter(name="weightedF1")
    def weighted_f1(self) -> _builtins.float:
        """
        F1-score, is a measure of a model’s accuracy on a dataset
        """
        return pulumi.get(self, "weighted_f1")

    @_builtins.property
    @pulumi.getter(name="weightedPrecision")
    def weighted_precision(self) -> _builtins.float:
        """
        Precision refers to the number of true positives divided by the total number of positive predictions (i.e., the number of true positives plus the number of false positives)
        """
        return pulumi.get(self, "weighted_precision")

    @_builtins.property
    @pulumi.getter(name="weightedRecall")
    def weighted_recall(self) -> _builtins.float:
        """
        Measures the model's ability to predict actual positive classes. It is the ratio between the predicted true positives and what was actually tagged. The recall metric reveals how many of the predicted classes are correct.
        """
        return pulumi.get(self, "weighted_recall")


@pulumi.output_type
class GetModelsModelCollectionItemModelDetailResult(dict):
    def __init__(__self__, *,
                 classification_modes: Sequence['outputs.GetModelsModelCollectionItemModelDetailClassificationModeResult'],
                 language_code: _builtins.str,
                 model_type: _builtins.str,
                 version: _builtins.str):
        """
        :param Sequence['GetModelsModelCollectionItemModelDetailClassificationModeArgs'] classification_modes: classification Modes
        :param _builtins.str language_code: supported language default value is en
        :param _builtins.str model_type: Model type
        :param _builtins.str version: For pre trained models this will identify model type version used for model creation For custom this will identify model type version used for model creation and custom model on which training has to be done <<service>>::<<service-name>>_<<model-type-version>>::<<custom model on which this training has to be done>> ex: ai-lang::NER_V1::CUSTOM-V0
        """
        pulumi.set(__self__, "classification_modes", classification_modes)
        pulumi.set(__self__, "language_code", language_code)
        pulumi.set(__self__, "model_type", model_type)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="classificationModes")
    def classification_modes(self) -> Sequence['outputs.GetModelsModelCollectionItemModelDetailClassificationModeResult']:
        """
        classification Modes
        """
        return pulumi.get(self, "classification_modes")

    @_builtins.property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> _builtins.str:
        """
        supported language default value is en
        """
        return pulumi.get(self, "language_code")

    @_builtins.property
    @pulumi.getter(name="modelType")
    def model_type(self) -> _builtins.str:
        """
        Model type
        """
        return pulumi.get(self, "model_type")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        For pre trained models this will identify model type version used for model creation For custom this will identify model type version used for model creation and custom model on which training has to be done <<service>>::<<service-name>>_<<model-type-version>>::<<custom model on which this training has to be done>> ex: ai-lang::NER_V1::CUSTOM-V0
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetModelsModelCollectionItemModelDetailClassificationModeResult(dict):
    def __init__(__self__, *,
                 classification_mode: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str classification_mode: classification Modes
        :param _builtins.str version: For pre trained models this will identify model type version used for model creation For custom this will identify model type version used for model creation and custom model on which training has to be done <<service>>::<<service-name>>_<<model-type-version>>::<<custom model on which this training has to be done>> ex: ai-lang::NER_V1::CUSTOM-V0
        """
        pulumi.set(__self__, "classification_mode", classification_mode)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="classificationMode")
    def classification_mode(self) -> _builtins.str:
        """
        classification Modes
        """
        return pulumi.get(self, "classification_mode")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        For pre trained models this will identify model type version used for model creation For custom this will identify model type version used for model creation and custom model on which training has to be done <<service>>::<<service-name>>_<<model-type-version>>::<<custom model on which this training has to be done>> ex: ai-lang::NER_V1::CUSTOM-V0
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetModelsModelCollectionItemTestStrategyResult(dict):
    def __init__(__self__, *,
                 strategy_type: _builtins.str,
                 testing_datasets: Sequence['outputs.GetModelsModelCollectionItemTestStrategyTestingDatasetResult'],
                 validation_datasets: Sequence['outputs.GetModelsModelCollectionItemTestStrategyValidationDatasetResult']):
        """
        :param _builtins.str strategy_type: This information will define the test strategy different datasets for test and validation(optional) dataset.
        :param Sequence['GetModelsModelCollectionItemTestStrategyTestingDatasetArgs'] testing_datasets: Possible data set type
        :param Sequence['GetModelsModelCollectionItemTestStrategyValidationDatasetArgs'] validation_datasets: Possible data set type
        """
        pulumi.set(__self__, "strategy_type", strategy_type)
        pulumi.set(__self__, "testing_datasets", testing_datasets)
        pulumi.set(__self__, "validation_datasets", validation_datasets)

    @_builtins.property
    @pulumi.getter(name="strategyType")
    def strategy_type(self) -> _builtins.str:
        """
        This information will define the test strategy different datasets for test and validation(optional) dataset.
        """
        return pulumi.get(self, "strategy_type")

    @_builtins.property
    @pulumi.getter(name="testingDatasets")
    def testing_datasets(self) -> Sequence['outputs.GetModelsModelCollectionItemTestStrategyTestingDatasetResult']:
        """
        Possible data set type
        """
        return pulumi.get(self, "testing_datasets")

    @_builtins.property
    @pulumi.getter(name="validationDatasets")
    def validation_datasets(self) -> Sequence['outputs.GetModelsModelCollectionItemTestStrategyValidationDatasetResult']:
        """
        Possible data set type
        """
        return pulumi.get(self, "validation_datasets")


@pulumi.output_type
class GetModelsModelCollectionItemTestStrategyTestingDatasetResult(dict):
    def __init__(__self__, *,
                 dataset_id: _builtins.str,
                 dataset_type: _builtins.str,
                 location_details: Sequence['outputs.GetModelsModelCollectionItemTestStrategyTestingDatasetLocationDetailResult']):
        """
        :param _builtins.str dataset_id: Data Science Labelling Service OCID
        :param _builtins.str dataset_type: Possible data sets
        :param Sequence['GetModelsModelCollectionItemTestStrategyTestingDatasetLocationDetailArgs'] location_details: Possible object storage location types
        """
        pulumi.set(__self__, "dataset_id", dataset_id)
        pulumi.set(__self__, "dataset_type", dataset_type)
        pulumi.set(__self__, "location_details", location_details)

    @_builtins.property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> _builtins.str:
        """
        Data Science Labelling Service OCID
        """
        return pulumi.get(self, "dataset_id")

    @_builtins.property
    @pulumi.getter(name="datasetType")
    def dataset_type(self) -> _builtins.str:
        """
        Possible data sets
        """
        return pulumi.get(self, "dataset_type")

    @_builtins.property
    @pulumi.getter(name="locationDetails")
    def location_details(self) -> Sequence['outputs.GetModelsModelCollectionItemTestStrategyTestingDatasetLocationDetailResult']:
        """
        Possible object storage location types
        """
        return pulumi.get(self, "location_details")


@pulumi.output_type
class GetModelsModelCollectionItemTestStrategyTestingDatasetLocationDetailResult(dict):
    def __init__(__self__, *,
                 bucket: _builtins.str,
                 location_type: _builtins.str,
                 namespace: _builtins.str,
                 object_names: Sequence[_builtins.str]):
        """
        :param _builtins.str bucket: Object storage bucket name
        :param _builtins.str location_type: Possible object storage location types
        :param _builtins.str namespace: Object storage namespace
        :param Sequence[_builtins.str] object_names: Array of files which need to be processed in the bucket
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "location_type", location_type)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "object_names", object_names)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        Object storage bucket name
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="locationType")
    def location_type(self) -> _builtins.str:
        """
        Possible object storage location types
        """
        return pulumi.get(self, "location_type")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Object storage namespace
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="objectNames")
    def object_names(self) -> Sequence[_builtins.str]:
        """
        Array of files which need to be processed in the bucket
        """
        return pulumi.get(self, "object_names")


@pulumi.output_type
class GetModelsModelCollectionItemTestStrategyValidationDatasetResult(dict):
    def __init__(__self__, *,
                 dataset_id: _builtins.str,
                 dataset_type: _builtins.str,
                 location_details: Sequence['outputs.GetModelsModelCollectionItemTestStrategyValidationDatasetLocationDetailResult']):
        """
        :param _builtins.str dataset_id: Data Science Labelling Service OCID
        :param _builtins.str dataset_type: Possible data sets
        :param Sequence['GetModelsModelCollectionItemTestStrategyValidationDatasetLocationDetailArgs'] location_details: Possible object storage location types
        """
        pulumi.set(__self__, "dataset_id", dataset_id)
        pulumi.set(__self__, "dataset_type", dataset_type)
        pulumi.set(__self__, "location_details", location_details)

    @_builtins.property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> _builtins.str:
        """
        Data Science Labelling Service OCID
        """
        return pulumi.get(self, "dataset_id")

    @_builtins.property
    @pulumi.getter(name="datasetType")
    def dataset_type(self) -> _builtins.str:
        """
        Possible data sets
        """
        return pulumi.get(self, "dataset_type")

    @_builtins.property
    @pulumi.getter(name="locationDetails")
    def location_details(self) -> Sequence['outputs.GetModelsModelCollectionItemTestStrategyValidationDatasetLocationDetailResult']:
        """
        Possible object storage location types
        """
        return pulumi.get(self, "location_details")


@pulumi.output_type
class GetModelsModelCollectionItemTestStrategyValidationDatasetLocationDetailResult(dict):
    def __init__(__self__, *,
                 bucket: _builtins.str,
                 location_type: _builtins.str,
                 namespace: _builtins.str,
                 object_names: Sequence[_builtins.str]):
        """
        :param _builtins.str bucket: Object storage bucket name
        :param _builtins.str location_type: Possible object storage location types
        :param _builtins.str namespace: Object storage namespace
        :param Sequence[_builtins.str] object_names: Array of files which need to be processed in the bucket
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "location_type", location_type)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "object_names", object_names)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        Object storage bucket name
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="locationType")
    def location_type(self) -> _builtins.str:
        """
        Possible object storage location types
        """
        return pulumi.get(self, "location_type")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Object storage namespace
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="objectNames")
    def object_names(self) -> Sequence[_builtins.str]:
        """
        Array of files which need to be processed in the bucket
        """
        return pulumi.get(self, "object_names")


@pulumi.output_type
class GetModelsModelCollectionItemTrainingDatasetResult(dict):
    def __init__(__self__, *,
                 dataset_id: _builtins.str,
                 dataset_type: _builtins.str,
                 location_details: Sequence['outputs.GetModelsModelCollectionItemTrainingDatasetLocationDetailResult']):
        """
        :param _builtins.str dataset_id: Data Science Labelling Service OCID
        :param _builtins.str dataset_type: Possible data sets
        :param Sequence['GetModelsModelCollectionItemTrainingDatasetLocationDetailArgs'] location_details: Possible object storage location types
        """
        pulumi.set(__self__, "dataset_id", dataset_id)
        pulumi.set(__self__, "dataset_type", dataset_type)
        pulumi.set(__self__, "location_details", location_details)

    @_builtins.property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> _builtins.str:
        """
        Data Science Labelling Service OCID
        """
        return pulumi.get(self, "dataset_id")

    @_builtins.property
    @pulumi.getter(name="datasetType")
    def dataset_type(self) -> _builtins.str:
        """
        Possible data sets
        """
        return pulumi.get(self, "dataset_type")

    @_builtins.property
    @pulumi.getter(name="locationDetails")
    def location_details(self) -> Sequence['outputs.GetModelsModelCollectionItemTrainingDatasetLocationDetailResult']:
        """
        Possible object storage location types
        """
        return pulumi.get(self, "location_details")


@pulumi.output_type
class GetModelsModelCollectionItemTrainingDatasetLocationDetailResult(dict):
    def __init__(__self__, *,
                 bucket: _builtins.str,
                 location_type: _builtins.str,
                 namespace: _builtins.str,
                 object_names: Sequence[_builtins.str]):
        """
        :param _builtins.str bucket: Object storage bucket name
        :param _builtins.str location_type: Possible object storage location types
        :param _builtins.str namespace: Object storage namespace
        :param Sequence[_builtins.str] object_names: Array of files which need to be processed in the bucket
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "location_type", location_type)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "object_names", object_names)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        Object storage bucket name
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="locationType")
    def location_type(self) -> _builtins.str:
        """
        Possible object storage location types
        """
        return pulumi.get(self, "location_type")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Object storage namespace
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="objectNames")
    def object_names(self) -> Sequence[_builtins.str]:
        """
        Array of files which need to be processed in the bucket
        """
        return pulumi.get(self, "object_names")


@pulumi.output_type
class GetProjectsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetProjectsProjectCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetProjectsProjectCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetProjectsProjectCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetProjectsProjectCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 description: _builtins.str,
                 display_name: _builtins.str,
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 lifecycle_details: _builtins.str,
                 state: _builtins.str,
                 system_tags: Mapping[str, _builtins.str],
                 time_created: _builtins.str,
                 time_updated: _builtins.str):
        """
        :param _builtins.str compartment_id: The ID of the compartment in which to list resources.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param _builtins.str description: A short description of a project.
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given.
        :param Mapping[str, _builtins.str] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param _builtins.str id: Unique identifier OCID of the project
        :param _builtins.str lifecycle_details: A message describing the current state in more detail.
        :param _builtins.str state: <b>Filter</b> results by the specified lifecycle state. Must be a valid state for the resource type.
        :param Mapping[str, _builtins.str] system_tags: Usage of system tag keys. These predefined keys are scoped to namespaces. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param _builtins.str time_created: The date and time the resource was created in the timestamp format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        :param _builtins.str time_updated: The date and time the resource was updated in the timestamp format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "system_tags", system_tags)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        A short description of a project.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique identifier OCID of the project
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> _builtins.str:
        """
        A message describing the current state in more detail.
        """
        return pulumi.get(self, "lifecycle_details")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        <b>Filter</b> results by the specified lifecycle state. Must be a valid state for the resource type.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, _builtins.str]:
        """
        Usage of system tag keys. These predefined keys are scoped to namespaces. Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The date and time the resource was created in the timestamp format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The date and time the resource was updated in the timestamp format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_updated")


