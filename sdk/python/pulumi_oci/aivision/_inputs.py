# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ModelTestingDatasetArgs',
    'ModelTestingDatasetArgsDict',
    'ModelTrainingDatasetArgs',
    'ModelTrainingDatasetArgsDict',
    'ModelValidationDatasetArgs',
    'ModelValidationDatasetArgsDict',
    'StreamGroupStreamOverlapArgs',
    'StreamGroupStreamOverlapArgsDict',
    'StreamJobFeatureArgs',
    'StreamJobFeatureArgsDict',
    'StreamJobFeatureTrackingTypeArgs',
    'StreamJobFeatureTrackingTypeArgsDict',
    'StreamJobStreamOutputLocationArgs',
    'StreamJobStreamOutputLocationArgsDict',
    'StreamSourceStreamSourceDetailsArgs',
    'StreamSourceStreamSourceDetailsArgsDict',
    'StreamSourceStreamSourceDetailsStreamNetworkAccessDetailsArgs',
    'StreamSourceStreamSourceDetailsStreamNetworkAccessDetailsArgsDict',
    'GetModelsFilterArgs',
    'GetModelsFilterArgsDict',
    'GetProjectsFilterArgs',
    'GetProjectsFilterArgsDict',
    'GetStreamGroupsFilterArgs',
    'GetStreamGroupsFilterArgsDict',
    'GetStreamJobsFilterArgs',
    'GetStreamJobsFilterArgsDict',
    'GetStreamSourcesFilterArgs',
    'GetStreamSourcesFilterArgsDict',
    'GetVisionPrivateEndpointsFilterArgs',
    'GetVisionPrivateEndpointsFilterArgsDict',
]

MYPY = False

if not MYPY:
    class ModelTestingDatasetArgsDict(TypedDict):
        dataset_type: pulumi.Input[_builtins.str]
        """
        The dataset type, based on where it is stored.
        """
        bucket: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the Object Storage bucket that contains the input data file.
        """
        dataset_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        OCID of the Data Labeling dataset.
        """
        namespace_name: NotRequired[pulumi.Input[_builtins.str]]
        object: NotRequired[pulumi.Input[_builtins.str]]
        """
        The object name of the input data file.
        """
elif False:
    ModelTestingDatasetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelTestingDatasetArgs:
    def __init__(__self__, *,
                 dataset_type: pulumi.Input[_builtins.str],
                 bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 dataset_id: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace_name: Optional[pulumi.Input[_builtins.str]] = None,
                 object: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dataset_type: The dataset type, based on where it is stored.
        :param pulumi.Input[_builtins.str] bucket: The name of the Object Storage bucket that contains the input data file.
        :param pulumi.Input[_builtins.str] dataset_id: OCID of the Data Labeling dataset.
        :param pulumi.Input[_builtins.str] object: The object name of the input data file.
        """
        pulumi.set(__self__, "dataset_type", dataset_type)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if dataset_id is not None:
            pulumi.set(__self__, "dataset_id", dataset_id)
        if namespace_name is not None:
            pulumi.set(__self__, "namespace_name", namespace_name)
        if object is not None:
            pulumi.set(__self__, "object", object)

    @_builtins.property
    @pulumi.getter(name="datasetType")
    def dataset_type(self) -> pulumi.Input[_builtins.str]:
        """
        The dataset type, based on where it is stored.
        """
        return pulumi.get(self, "dataset_type")

    @dataset_type.setter
    def dataset_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "dataset_type", value)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the Object Storage bucket that contains the input data file.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OCID of the Data Labeling dataset.
        """
        return pulumi.get(self, "dataset_id")

    @dataset_id.setter
    def dataset_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dataset_id", value)

    @_builtins.property
    @pulumi.getter(name="namespaceName")
    def namespace_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "namespace_name")

    @namespace_name.setter
    def namespace_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace_name", value)

    @_builtins.property
    @pulumi.getter
    def object(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The object name of the input data file.
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "object", value)


if not MYPY:
    class ModelTrainingDatasetArgsDict(TypedDict):
        dataset_type: pulumi.Input[_builtins.str]
        """
        The dataset type, based on where it is stored.
        """
        bucket: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the Object Storage bucket that contains the input data file.
        """
        dataset_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        OCID of the Data Labeling dataset.
        """
        namespace_name: NotRequired[pulumi.Input[_builtins.str]]
        object: NotRequired[pulumi.Input[_builtins.str]]
        """
        The object name of the input data file.
        """
elif False:
    ModelTrainingDatasetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelTrainingDatasetArgs:
    def __init__(__self__, *,
                 dataset_type: pulumi.Input[_builtins.str],
                 bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 dataset_id: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace_name: Optional[pulumi.Input[_builtins.str]] = None,
                 object: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dataset_type: The dataset type, based on where it is stored.
        :param pulumi.Input[_builtins.str] bucket: The name of the Object Storage bucket that contains the input data file.
        :param pulumi.Input[_builtins.str] dataset_id: OCID of the Data Labeling dataset.
        :param pulumi.Input[_builtins.str] object: The object name of the input data file.
        """
        pulumi.set(__self__, "dataset_type", dataset_type)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if dataset_id is not None:
            pulumi.set(__self__, "dataset_id", dataset_id)
        if namespace_name is not None:
            pulumi.set(__self__, "namespace_name", namespace_name)
        if object is not None:
            pulumi.set(__self__, "object", object)

    @_builtins.property
    @pulumi.getter(name="datasetType")
    def dataset_type(self) -> pulumi.Input[_builtins.str]:
        """
        The dataset type, based on where it is stored.
        """
        return pulumi.get(self, "dataset_type")

    @dataset_type.setter
    def dataset_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "dataset_type", value)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the Object Storage bucket that contains the input data file.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OCID of the Data Labeling dataset.
        """
        return pulumi.get(self, "dataset_id")

    @dataset_id.setter
    def dataset_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dataset_id", value)

    @_builtins.property
    @pulumi.getter(name="namespaceName")
    def namespace_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "namespace_name")

    @namespace_name.setter
    def namespace_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace_name", value)

    @_builtins.property
    @pulumi.getter
    def object(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The object name of the input data file.
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "object", value)


if not MYPY:
    class ModelValidationDatasetArgsDict(TypedDict):
        dataset_type: pulumi.Input[_builtins.str]
        """
        The dataset type, based on where it is stored.
        """
        bucket: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the Object Storage bucket that contains the input data file.
        """
        dataset_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        OCID of the Data Labeling dataset.
        """
        namespace_name: NotRequired[pulumi.Input[_builtins.str]]
        object: NotRequired[pulumi.Input[_builtins.str]]
        """
        The object name of the input data file.

        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    ModelValidationDatasetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelValidationDatasetArgs:
    def __init__(__self__, *,
                 dataset_type: pulumi.Input[_builtins.str],
                 bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 dataset_id: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace_name: Optional[pulumi.Input[_builtins.str]] = None,
                 object: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dataset_type: The dataset type, based on where it is stored.
        :param pulumi.Input[_builtins.str] bucket: The name of the Object Storage bucket that contains the input data file.
        :param pulumi.Input[_builtins.str] dataset_id: OCID of the Data Labeling dataset.
        :param pulumi.Input[_builtins.str] object: The object name of the input data file.
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "dataset_type", dataset_type)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if dataset_id is not None:
            pulumi.set(__self__, "dataset_id", dataset_id)
        if namespace_name is not None:
            pulumi.set(__self__, "namespace_name", namespace_name)
        if object is not None:
            pulumi.set(__self__, "object", object)

    @_builtins.property
    @pulumi.getter(name="datasetType")
    def dataset_type(self) -> pulumi.Input[_builtins.str]:
        """
        The dataset type, based on where it is stored.
        """
        return pulumi.get(self, "dataset_type")

    @dataset_type.setter
    def dataset_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "dataset_type", value)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the Object Storage bucket that contains the input data file.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OCID of the Data Labeling dataset.
        """
        return pulumi.get(self, "dataset_id")

    @dataset_id.setter
    def dataset_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dataset_id", value)

    @_builtins.property
    @pulumi.getter(name="namespaceName")
    def namespace_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "namespace_name")

    @namespace_name.setter
    def namespace_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace_name", value)

    @_builtins.property
    @pulumi.getter
    def object(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The object name of the input data file.

        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "object", value)


if not MYPY:
    class StreamGroupStreamOverlapArgsDict(TypedDict):
        overlapping_streams: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) List of streamSource OCIDs.
        """
elif False:
    StreamGroupStreamOverlapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamGroupStreamOverlapArgs:
    def __init__(__self__, *,
                 overlapping_streams: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] overlapping_streams: (Updatable) List of streamSource OCIDs.
        """
        if overlapping_streams is not None:
            pulumi.set(__self__, "overlapping_streams", overlapping_streams)

    @_builtins.property
    @pulumi.getter(name="overlappingStreams")
    def overlapping_streams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) List of streamSource OCIDs.
        """
        return pulumi.get(self, "overlapping_streams")

    @overlapping_streams.setter
    def overlapping_streams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "overlapping_streams", value)


if not MYPY:
    class StreamJobFeatureArgsDict(TypedDict):
        feature_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The feature of video analysis. Allowed values are:
        * OBJECT_TRACKING: Object tracking feature(OT).
        * FACE_DETECTION: Face detection feature(FD).
        """
        max_results: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The maximum number of results to return.
        """
        should_return_landmarks: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Whether or not return face landmarks.
        """
        tracking_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['StreamJobFeatureTrackingTypeArgsDict']]]]
        """
        (Updatable) List of details of what to track.
        """
elif False:
    StreamJobFeatureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamJobFeatureArgs:
    def __init__(__self__, *,
                 feature_type: pulumi.Input[_builtins.str],
                 max_results: Optional[pulumi.Input[_builtins.int]] = None,
                 should_return_landmarks: Optional[pulumi.Input[_builtins.bool]] = None,
                 tracking_types: Optional[pulumi.Input[Sequence[pulumi.Input['StreamJobFeatureTrackingTypeArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] feature_type: (Updatable) The feature of video analysis. Allowed values are:
               * OBJECT_TRACKING: Object tracking feature(OT).
               * FACE_DETECTION: Face detection feature(FD).
        :param pulumi.Input[_builtins.int] max_results: (Updatable) The maximum number of results to return.
        :param pulumi.Input[_builtins.bool] should_return_landmarks: (Updatable) Whether or not return face landmarks.
        :param pulumi.Input[Sequence[pulumi.Input['StreamJobFeatureTrackingTypeArgs']]] tracking_types: (Updatable) List of details of what to track.
        """
        pulumi.set(__self__, "feature_type", feature_type)
        if max_results is not None:
            pulumi.set(__self__, "max_results", max_results)
        if should_return_landmarks is not None:
            pulumi.set(__self__, "should_return_landmarks", should_return_landmarks)
        if tracking_types is not None:
            pulumi.set(__self__, "tracking_types", tracking_types)

    @_builtins.property
    @pulumi.getter(name="featureType")
    def feature_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The feature of video analysis. Allowed values are:
        * OBJECT_TRACKING: Object tracking feature(OT).
        * FACE_DETECTION: Face detection feature(FD).
        """
        return pulumi.get(self, "feature_type")

    @feature_type.setter
    def feature_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "feature_type", value)

    @_builtins.property
    @pulumi.getter(name="maxResults")
    def max_results(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The maximum number of results to return.
        """
        return pulumi.get(self, "max_results")

    @max_results.setter
    def max_results(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_results", value)

    @_builtins.property
    @pulumi.getter(name="shouldReturnLandmarks")
    def should_return_landmarks(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Whether or not return face landmarks.
        """
        return pulumi.get(self, "should_return_landmarks")

    @should_return_landmarks.setter
    def should_return_landmarks(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "should_return_landmarks", value)

    @_builtins.property
    @pulumi.getter(name="trackingTypes")
    def tracking_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StreamJobFeatureTrackingTypeArgs']]]]:
        """
        (Updatable) List of details of what to track.
        """
        return pulumi.get(self, "tracking_types")

    @tracking_types.setter
    def tracking_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StreamJobFeatureTrackingTypeArgs']]]]):
        pulumi.set(self, "tracking_types", value)


if not MYPY:
    class StreamJobFeatureTrackingTypeArgsDict(TypedDict):
        biometric_store_compartment_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) compartment Id of biometric compartment.
        """
        biometric_store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Which biometric store user wants to do face recognition
        """
        detection_model_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The detection model OCID.
        """
        max_results: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The maximum number of results to return.
        """
        objects: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) List of the objects to be tracked.
        """
        should_return_landmarks: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Whether or not return face landmarks.
        """
        tracking_model_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The tracking model OCID.
        """
elif False:
    StreamJobFeatureTrackingTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamJobFeatureTrackingTypeArgs:
    def __init__(__self__, *,
                 biometric_store_compartment_id: Optional[pulumi.Input[_builtins.str]] = None,
                 biometric_store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 detection_model_id: Optional[pulumi.Input[_builtins.str]] = None,
                 max_results: Optional[pulumi.Input[_builtins.int]] = None,
                 objects: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 should_return_landmarks: Optional[pulumi.Input[_builtins.bool]] = None,
                 tracking_model_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] biometric_store_compartment_id: (Updatable) compartment Id of biometric compartment.
        :param pulumi.Input[_builtins.str] biometric_store_id: (Updatable) Which biometric store user wants to do face recognition
        :param pulumi.Input[_builtins.str] detection_model_id: (Updatable) The detection model OCID.
        :param pulumi.Input[_builtins.int] max_results: (Updatable) The maximum number of results to return.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] objects: (Updatable) List of the objects to be tracked.
        :param pulumi.Input[_builtins.bool] should_return_landmarks: (Updatable) Whether or not return face landmarks.
        :param pulumi.Input[_builtins.str] tracking_model_id: (Updatable) The tracking model OCID.
        """
        if biometric_store_compartment_id is not None:
            pulumi.set(__self__, "biometric_store_compartment_id", biometric_store_compartment_id)
        if biometric_store_id is not None:
            pulumi.set(__self__, "biometric_store_id", biometric_store_id)
        if detection_model_id is not None:
            pulumi.set(__self__, "detection_model_id", detection_model_id)
        if max_results is not None:
            pulumi.set(__self__, "max_results", max_results)
        if objects is not None:
            pulumi.set(__self__, "objects", objects)
        if should_return_landmarks is not None:
            pulumi.set(__self__, "should_return_landmarks", should_return_landmarks)
        if tracking_model_id is not None:
            pulumi.set(__self__, "tracking_model_id", tracking_model_id)

    @_builtins.property
    @pulumi.getter(name="biometricStoreCompartmentId")
    def biometric_store_compartment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) compartment Id of biometric compartment.
        """
        return pulumi.get(self, "biometric_store_compartment_id")

    @biometric_store_compartment_id.setter
    def biometric_store_compartment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "biometric_store_compartment_id", value)

    @_builtins.property
    @pulumi.getter(name="biometricStoreId")
    def biometric_store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Which biometric store user wants to do face recognition
        """
        return pulumi.get(self, "biometric_store_id")

    @biometric_store_id.setter
    def biometric_store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "biometric_store_id", value)

    @_builtins.property
    @pulumi.getter(name="detectionModelId")
    def detection_model_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The detection model OCID.
        """
        return pulumi.get(self, "detection_model_id")

    @detection_model_id.setter
    def detection_model_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "detection_model_id", value)

    @_builtins.property
    @pulumi.getter(name="maxResults")
    def max_results(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The maximum number of results to return.
        """
        return pulumi.get(self, "max_results")

    @max_results.setter
    def max_results(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_results", value)

    @_builtins.property
    @pulumi.getter
    def objects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) List of the objects to be tracked.
        """
        return pulumi.get(self, "objects")

    @objects.setter
    def objects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "objects", value)

    @_builtins.property
    @pulumi.getter(name="shouldReturnLandmarks")
    def should_return_landmarks(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Whether or not return face landmarks.
        """
        return pulumi.get(self, "should_return_landmarks")

    @should_return_landmarks.setter
    def should_return_landmarks(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "should_return_landmarks", value)

    @_builtins.property
    @pulumi.getter(name="trackingModelId")
    def tracking_model_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The tracking model OCID.
        """
        return pulumi.get(self, "tracking_model_id")

    @tracking_model_id.setter
    def tracking_model_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tracking_model_id", value)


if not MYPY:
    class StreamJobStreamOutputLocationArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        """
        (Updatable) The Object Storage bucket name.
        """
        namespace: pulumi.Input[_builtins.str]
        """
        (Updatable) The Object Storage namespace.
        """
        output_location_type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of device Allowed values are:
        * OBJECT_STORAGE
        * LIVEKIT_WEBRTC_AGENT
        """
        prefix: pulumi.Input[_builtins.str]
        """
        (Updatable) The Object Storage folder name.
        """
        obo_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Object storage output location
        """
elif False:
    StreamJobStreamOutputLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamJobStreamOutputLocationArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 namespace: pulumi.Input[_builtins.str],
                 output_location_type: pulumi.Input[_builtins.str],
                 prefix: pulumi.Input[_builtins.str],
                 obo_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket: (Updatable) The Object Storage bucket name.
        :param pulumi.Input[_builtins.str] namespace: (Updatable) The Object Storage namespace.
        :param pulumi.Input[_builtins.str] output_location_type: (Updatable) Type of device Allowed values are:
               * OBJECT_STORAGE
               * LIVEKIT_WEBRTC_AGENT
        :param pulumi.Input[_builtins.str] prefix: (Updatable) The Object Storage folder name.
        :param pulumi.Input[_builtins.str] obo_token: (Updatable) Object storage output location
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "output_location_type", output_location_type)
        pulumi.set(__self__, "prefix", prefix)
        if obo_token is not None:
            pulumi.set(__self__, "obo_token", obo_token)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The Object Storage bucket name.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The Object Storage namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter(name="outputLocationType")
    def output_location_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of device Allowed values are:
        * OBJECT_STORAGE
        * LIVEKIT_WEBRTC_AGENT
        """
        return pulumi.get(self, "output_location_type")

    @output_location_type.setter
    def output_location_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "output_location_type", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The Object Storage folder name.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter(name="oboToken")
    def obo_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Object storage output location
        """
        return pulumi.get(self, "obo_token")

    @obo_token.setter
    def obo_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "obo_token", value)


if not MYPY:
    class StreamSourceStreamSourceDetailsArgsDict(TypedDict):
        camera_url: pulumi.Input[_builtins.str]
        """
        (Updatable) url of camera
        """
        source_type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of source Allowed values are:
        * RTSP
        """
        stream_network_access_details: pulumi.Input['StreamSourceStreamSourceDetailsStreamNetworkAccessDetailsArgsDict']
        """
        (Updatable) Details about a stream Connection type
        """
        secret_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of secret where credentials are stored in username:password format.
        """
elif False:
    StreamSourceStreamSourceDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceStreamSourceDetailsArgs:
    def __init__(__self__, *,
                 camera_url: pulumi.Input[_builtins.str],
                 source_type: pulumi.Input[_builtins.str],
                 stream_network_access_details: pulumi.Input['StreamSourceStreamSourceDetailsStreamNetworkAccessDetailsArgs'],
                 secret_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] camera_url: (Updatable) url of camera
        :param pulumi.Input[_builtins.str] source_type: (Updatable) Type of source Allowed values are:
               * RTSP
        :param pulumi.Input['StreamSourceStreamSourceDetailsStreamNetworkAccessDetailsArgs'] stream_network_access_details: (Updatable) Details about a stream Connection type
        :param pulumi.Input[_builtins.str] secret_id: (Updatable) [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of secret where credentials are stored in username:password format.
        """
        pulumi.set(__self__, "camera_url", camera_url)
        pulumi.set(__self__, "source_type", source_type)
        pulumi.set(__self__, "stream_network_access_details", stream_network_access_details)
        if secret_id is not None:
            pulumi.set(__self__, "secret_id", secret_id)

    @_builtins.property
    @pulumi.getter(name="cameraUrl")
    def camera_url(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) url of camera
        """
        return pulumi.get(self, "camera_url")

    @camera_url.setter
    def camera_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "camera_url", value)

    @_builtins.property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of source Allowed values are:
        * RTSP
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_type", value)

    @_builtins.property
    @pulumi.getter(name="streamNetworkAccessDetails")
    def stream_network_access_details(self) -> pulumi.Input['StreamSourceStreamSourceDetailsStreamNetworkAccessDetailsArgs']:
        """
        (Updatable) Details about a stream Connection type
        """
        return pulumi.get(self, "stream_network_access_details")

    @stream_network_access_details.setter
    def stream_network_access_details(self, value: pulumi.Input['StreamSourceStreamSourceDetailsStreamNetworkAccessDetailsArgs']):
        pulumi.set(self, "stream_network_access_details", value)

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of secret where credentials are stored in username:password format.
        """
        return pulumi.get(self, "secret_id")

    @secret_id.setter
    def secret_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_id", value)


if not MYPY:
    class StreamSourceStreamSourceDetailsStreamNetworkAccessDetailsArgsDict(TypedDict):
        private_endpoint_id: pulumi.Input[_builtins.str]
        """
        (Updatable) [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the private Endpoint
        """
        stream_access_type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of access Allowed values are:
        * PRIVATE


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    StreamSourceStreamSourceDetailsStreamNetworkAccessDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceStreamSourceDetailsStreamNetworkAccessDetailsArgs:
    def __init__(__self__, *,
                 private_endpoint_id: pulumi.Input[_builtins.str],
                 stream_access_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] private_endpoint_id: (Updatable) [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the private Endpoint
        :param pulumi.Input[_builtins.str] stream_access_type: (Updatable) Type of access Allowed values are:
               * PRIVATE
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "private_endpoint_id", private_endpoint_id)
        pulumi.set(__self__, "stream_access_type", stream_access_type)

    @_builtins.property
    @pulumi.getter(name="privateEndpointId")
    def private_endpoint_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the private Endpoint
        """
        return pulumi.get(self, "private_endpoint_id")

    @private_endpoint_id.setter
    def private_endpoint_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_endpoint_id", value)

    @_builtins.property
    @pulumi.getter(name="streamAccessType")
    def stream_access_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of access Allowed values are:
        * PRIVATE


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "stream_access_type")

    @stream_access_type.setter
    def stream_access_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "stream_access_type", value)


if not MYPY:
    class GetModelsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetModelsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetModelsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetProjectsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetProjectsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProjectsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetStreamGroupsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetStreamGroupsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetStreamGroupsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetStreamJobsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetStreamJobsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetStreamJobsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetStreamSourcesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetStreamSourcesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetStreamSourcesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetVisionPrivateEndpointsFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetVisionPrivateEndpointsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVisionPrivateEndpointsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


