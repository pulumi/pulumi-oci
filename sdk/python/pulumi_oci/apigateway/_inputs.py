# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ApiLockArgs',
    'ApiLockArgsDict',
    'ApiValidationResultArgs',
    'ApiValidationResultArgsDict',
    'CertificateLockArgs',
    'CertificateLockArgsDict',
    'DeploymentLockArgs',
    'DeploymentLockArgsDict',
    'DeploymentSpecificationArgs',
    'DeploymentSpecificationArgsDict',
    'DeploymentSpecificationLoggingPoliciesArgs',
    'DeploymentSpecificationLoggingPoliciesArgsDict',
    'DeploymentSpecificationLoggingPoliciesAccessLogArgs',
    'DeploymentSpecificationLoggingPoliciesAccessLogArgsDict',
    'DeploymentSpecificationLoggingPoliciesExecutionLogArgs',
    'DeploymentSpecificationLoggingPoliciesExecutionLogArgsDict',
    'DeploymentSpecificationRequestPoliciesArgs',
    'DeploymentSpecificationRequestPoliciesArgsDict',
    'DeploymentSpecificationRequestPoliciesAuthenticationArgs',
    'DeploymentSpecificationRequestPoliciesAuthenticationArgsDict',
    'DeploymentSpecificationRequestPoliciesAuthenticationPublicKeysArgs',
    'DeploymentSpecificationRequestPoliciesAuthenticationPublicKeysArgsDict',
    'DeploymentSpecificationRequestPoliciesAuthenticationPublicKeysKeyArgs',
    'DeploymentSpecificationRequestPoliciesAuthenticationPublicKeysKeyArgsDict',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyArgs',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyArgsDict',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyClientDetailsArgs',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyClientDetailsArgsDict',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsArgs',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsArgsDict',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsFilterHeadersArgs',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsFilterHeadersArgsDict',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsFilterHeadersItemArgs',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsFilterHeadersItemArgsDict',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsRenameHeadersArgs',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsRenameHeadersArgsDict',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsRenameHeadersItemArgs',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsRenameHeadersItemArgsDict',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsSetHeadersArgs',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsSetHeadersArgsDict',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsSetHeadersItemArgs',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsSetHeadersItemArgsDict',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicySourceUriDetailsArgs',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicySourceUriDetailsArgsDict',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyArgs',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyArgsDict',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyAdditionalValidationPolicyArgs',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyAdditionalValidationPolicyArgsDict',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyAdditionalValidationPolicyVerifyClaimArgs',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyAdditionalValidationPolicyVerifyClaimArgsDict',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyClientDetailsArgs',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyClientDetailsArgsDict',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyKeyArgs',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyKeyArgsDict',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicySourceUriDetailsArgs',
    'DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicySourceUriDetailsArgsDict',
    'DeploymentSpecificationRequestPoliciesAuthenticationVerifyClaimArgs',
    'DeploymentSpecificationRequestPoliciesAuthenticationVerifyClaimArgsDict',
    'DeploymentSpecificationRequestPoliciesCorsArgs',
    'DeploymentSpecificationRequestPoliciesCorsArgsDict',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationArgs',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationArgsDict',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerArgs',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerArgsDict',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailArgs',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailArgsDict',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailPublicKeysArgs',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailPublicKeysArgsDict',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailPublicKeysKeyArgs',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailPublicKeysKeyArgsDict',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyArgs',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyArgsDict',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyClientDetailsArgs',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyClientDetailsArgsDict',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsArgs',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsArgsDict',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsFilterHeadersArgs',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsFilterHeadersArgsDict',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsFilterHeadersItemArgs',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsFilterHeadersItemArgsDict',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsRenameHeadersArgs',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsRenameHeadersArgsDict',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsRenameHeadersItemArgs',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsRenameHeadersItemArgsDict',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsSetHeadersArgs',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsSetHeadersArgsDict',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsSetHeadersItemArgs',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsSetHeadersItemArgsDict',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicySourceUriDetailsArgs',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicySourceUriDetailsArgsDict',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyArgs',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyArgsDict',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyAdditionalValidationPolicyArgs',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyAdditionalValidationPolicyArgsDict',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyAdditionalValidationPolicyVerifyClaimArgs',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyAdditionalValidationPolicyVerifyClaimArgsDict',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyClientDetailsArgs',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyClientDetailsArgsDict',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyKeyArgs',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyKeyArgsDict',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicySourceUriDetailsArgs',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicySourceUriDetailsArgsDict',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailVerifyClaimArgs',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailVerifyClaimArgsDict',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerKeyArgs',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerKeyArgsDict',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationSelectionSourceArgs',
    'DeploymentSpecificationRequestPoliciesDynamicAuthenticationSelectionSourceArgsDict',
    'DeploymentSpecificationRequestPoliciesMutualTlsArgs',
    'DeploymentSpecificationRequestPoliciesMutualTlsArgsDict',
    'DeploymentSpecificationRequestPoliciesRateLimitingArgs',
    'DeploymentSpecificationRequestPoliciesRateLimitingArgsDict',
    'DeploymentSpecificationRequestPoliciesUsagePlansArgs',
    'DeploymentSpecificationRequestPoliciesUsagePlansArgsDict',
    'DeploymentSpecificationRouteArgs',
    'DeploymentSpecificationRouteArgsDict',
    'DeploymentSpecificationRouteBackendArgs',
    'DeploymentSpecificationRouteBackendArgsDict',
    'DeploymentSpecificationRouteBackendHeaderArgs',
    'DeploymentSpecificationRouteBackendHeaderArgsDict',
    'DeploymentSpecificationRouteBackendRoutingBackendArgs',
    'DeploymentSpecificationRouteBackendRoutingBackendArgsDict',
    'DeploymentSpecificationRouteBackendRoutingBackendBackendArgs',
    'DeploymentSpecificationRouteBackendRoutingBackendBackendArgsDict',
    'DeploymentSpecificationRouteBackendRoutingBackendBackendHeaderArgs',
    'DeploymentSpecificationRouteBackendRoutingBackendBackendHeaderArgsDict',
    'DeploymentSpecificationRouteBackendRoutingBackendKeyArgs',
    'DeploymentSpecificationRouteBackendRoutingBackendKeyArgsDict',
    'DeploymentSpecificationRouteBackendSelectionSourceArgs',
    'DeploymentSpecificationRouteBackendSelectionSourceArgsDict',
    'DeploymentSpecificationRouteLoggingPoliciesArgs',
    'DeploymentSpecificationRouteLoggingPoliciesArgsDict',
    'DeploymentSpecificationRouteLoggingPoliciesAccessLogArgs',
    'DeploymentSpecificationRouteLoggingPoliciesAccessLogArgsDict',
    'DeploymentSpecificationRouteLoggingPoliciesExecutionLogArgs',
    'DeploymentSpecificationRouteLoggingPoliciesExecutionLogArgsDict',
    'DeploymentSpecificationRouteRequestPoliciesArgs',
    'DeploymentSpecificationRouteRequestPoliciesArgsDict',
    'DeploymentSpecificationRouteRequestPoliciesAuthorizationArgs',
    'DeploymentSpecificationRouteRequestPoliciesAuthorizationArgsDict',
    'DeploymentSpecificationRouteRequestPoliciesBodyValidationArgs',
    'DeploymentSpecificationRouteRequestPoliciesBodyValidationArgsDict',
    'DeploymentSpecificationRouteRequestPoliciesBodyValidationContentArgs',
    'DeploymentSpecificationRouteRequestPoliciesBodyValidationContentArgsDict',
    'DeploymentSpecificationRouteRequestPoliciesCorsArgs',
    'DeploymentSpecificationRouteRequestPoliciesCorsArgsDict',
    'DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsArgs',
    'DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsArgsDict',
    'DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersArgs',
    'DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersArgsDict',
    'DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersItemArgs',
    'DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersItemArgsDict',
    'DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersArgs',
    'DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersArgsDict',
    'DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersItemArgs',
    'DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersItemArgsDict',
    'DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersArgs',
    'DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersArgsDict',
    'DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersItemArgs',
    'DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersItemArgsDict',
    'DeploymentSpecificationRouteRequestPoliciesHeaderValidationsArgs',
    'DeploymentSpecificationRouteRequestPoliciesHeaderValidationsArgsDict',
    'DeploymentSpecificationRouteRequestPoliciesHeaderValidationsHeaderArgs',
    'DeploymentSpecificationRouteRequestPoliciesHeaderValidationsHeaderArgsDict',
    'DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsArgs',
    'DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsArgsDict',
    'DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersArgs',
    'DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersArgsDict',
    'DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersItemArgs',
    'DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersItemArgsDict',
    'DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersArgs',
    'DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersArgsDict',
    'DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersItemArgs',
    'DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersItemArgsDict',
    'DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersArgs',
    'DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersArgsDict',
    'DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersItemArgs',
    'DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersItemArgsDict',
    'DeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsArgs',
    'DeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsArgsDict',
    'DeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsParameterArgs',
    'DeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsParameterArgsDict',
    'DeploymentSpecificationRouteRequestPoliciesResponseCacheLookupArgs',
    'DeploymentSpecificationRouteRequestPoliciesResponseCacheLookupArgsDict',
    'DeploymentSpecificationRouteResponsePoliciesArgs',
    'DeploymentSpecificationRouteResponsePoliciesArgsDict',
    'DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsArgs',
    'DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsArgsDict',
    'DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersArgs',
    'DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersArgsDict',
    'DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersItemArgs',
    'DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersItemArgsDict',
    'DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersArgs',
    'DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersArgsDict',
    'DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersItemArgs',
    'DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersItemArgsDict',
    'DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersArgs',
    'DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersArgsDict',
    'DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersItemArgs',
    'DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersItemArgsDict',
    'DeploymentSpecificationRouteResponsePoliciesResponseCacheStoreArgs',
    'DeploymentSpecificationRouteResponsePoliciesResponseCacheStoreArgsDict',
    'GatewayCaBundleArgs',
    'GatewayCaBundleArgsDict',
    'GatewayIpAddressArgs',
    'GatewayIpAddressArgsDict',
    'GatewayLockArgs',
    'GatewayLockArgsDict',
    'GatewayResponseCacheDetailsArgs',
    'GatewayResponseCacheDetailsArgsDict',
    'GatewayResponseCacheDetailsServerArgs',
    'GatewayResponseCacheDetailsServerArgsDict',
    'SubscriberClientArgs',
    'SubscriberClientArgsDict',
    'SubscriberLockArgs',
    'SubscriberLockArgsDict',
    'UsagePlanEntitlementArgs',
    'UsagePlanEntitlementArgsDict',
    'UsagePlanEntitlementQuotaArgs',
    'UsagePlanEntitlementQuotaArgsDict',
    'UsagePlanEntitlementRateLimitArgs',
    'UsagePlanEntitlementRateLimitArgsDict',
    'UsagePlanEntitlementTargetArgs',
    'UsagePlanEntitlementTargetArgsDict',
    'UsagePlanLockArgs',
    'UsagePlanLockArgsDict',
    'GetApisFilterArgs',
    'GetApisFilterArgsDict',
    'GetCertificatesFilterArgs',
    'GetCertificatesFilterArgsDict',
    'GetDeploymentsFilterArgs',
    'GetDeploymentsFilterArgsDict',
    'GetGatewaysFilterArgs',
    'GetGatewaysFilterArgsDict',
    'GetSubscribersFilterArgs',
    'GetSubscribersFilterArgsDict',
    'GetUsagePlansFilterArgs',
    'GetUsagePlansFilterArgsDict',
]

MYPY = False

if not MYPY:
    class ApiLockArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of the lock.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        """
        related_resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        """
        time_created: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time this resource was created. An RFC3339 formatted datetime string.
        """
elif False:
    ApiLockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiLockArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 related_resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 time_created: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of the lock.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param pulumi.Input[_builtins.str] message: A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        :param pulumi.Input[_builtins.str] related_resource_id: The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        :param pulumi.Input[_builtins.str] time_created: The time this resource was created. An RFC3339 formatted datetime string.
        """
        pulumi.set(__self__, "type", type)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if related_resource_id is not None:
            pulumi.set(__self__, "related_resource_id", related_resource_id)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of the lock.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter(name="relatedResourceId")
    def related_resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        """
        return pulumi.get(self, "related_resource_id")

    @related_resource_id.setter
    def related_resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "related_resource_id", value)

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time this resource was created. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_created", value)


if not MYPY:
    class ApiValidationResultArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the validation.
        """
        result: NotRequired[pulumi.Input[_builtins.str]]
        """
        Result of the validation.
        """
elif False:
    ApiValidationResultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiValidationResultArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 result: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the validation.
        :param pulumi.Input[_builtins.str] result: Result of the validation.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if result is not None:
            pulumi.set(__self__, "result", result)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the validation.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def result(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Result of the validation.
        """
        return pulumi.get(self, "result")

    @result.setter
    def result(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "result", value)


if not MYPY:
    class CertificateLockArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of the lock.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        """
        related_resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        """
        time_created: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time this resource was created. An RFC3339 formatted datetime string.
        """
elif False:
    CertificateLockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CertificateLockArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 related_resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 time_created: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of the lock.
        :param pulumi.Input[_builtins.str] message: A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        :param pulumi.Input[_builtins.str] related_resource_id: The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        :param pulumi.Input[_builtins.str] time_created: The time this resource was created. An RFC3339 formatted datetime string.
        """
        pulumi.set(__self__, "type", type)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if related_resource_id is not None:
            pulumi.set(__self__, "related_resource_id", related_resource_id)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of the lock.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter(name="relatedResourceId")
    def related_resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        """
        return pulumi.get(self, "related_resource_id")

    @related_resource_id.setter
    def related_resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "related_resource_id", value)

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time this resource was created. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_created", value)


if not MYPY:
    class DeploymentLockArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of the lock.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        """
        related_resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        """
        time_created: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time this resource was created. An RFC3339 formatted datetime string.
        """
elif False:
    DeploymentLockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentLockArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 related_resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 time_created: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of the lock.
        :param pulumi.Input[_builtins.str] message: A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        :param pulumi.Input[_builtins.str] related_resource_id: The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        :param pulumi.Input[_builtins.str] time_created: The time this resource was created. An RFC3339 formatted datetime string.
        """
        pulumi.set(__self__, "type", type)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if related_resource_id is not None:
            pulumi.set(__self__, "related_resource_id", related_resource_id)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of the lock.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter(name="relatedResourceId")
    def related_resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        """
        return pulumi.get(self, "related_resource_id")

    @related_resource_id.setter
    def related_resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "related_resource_id", value)

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time this resource was created. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_created", value)


if not MYPY:
    class DeploymentSpecificationArgsDict(TypedDict):
        routes: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteArgsDict']]]
        """
        (Updatable) A list of routes that this API exposes.
        """
        logging_policies: NotRequired[pulumi.Input['DeploymentSpecificationLoggingPoliciesArgsDict']]
        """
        (Updatable) Policies controlling the pushing of logs to Oracle Cloud Infrastructure Public Logging.
        """
        request_policies: NotRequired[pulumi.Input['DeploymentSpecificationRequestPoliciesArgsDict']]
        """
        (Updatable) Global behavior applied to all requests received by the API.
        """
elif False:
    DeploymentSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationArgs:
    def __init__(__self__, *,
                 routes: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteArgs']]],
                 logging_policies: Optional[pulumi.Input['DeploymentSpecificationLoggingPoliciesArgs']] = None,
                 request_policies: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteArgs']]] routes: (Updatable) A list of routes that this API exposes.
        :param pulumi.Input['DeploymentSpecificationLoggingPoliciesArgs'] logging_policies: (Updatable) Policies controlling the pushing of logs to Oracle Cloud Infrastructure Public Logging.
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesArgs'] request_policies: (Updatable) Global behavior applied to all requests received by the API.
        """
        pulumi.set(__self__, "routes", routes)
        if logging_policies is not None:
            pulumi.set(__self__, "logging_policies", logging_policies)
        if request_policies is not None:
            pulumi.set(__self__, "request_policies", request_policies)

    @_builtins.property
    @pulumi.getter
    def routes(self) -> pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteArgs']]]:
        """
        (Updatable) A list of routes that this API exposes.
        """
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteArgs']]]):
        pulumi.set(self, "routes", value)

    @_builtins.property
    @pulumi.getter(name="loggingPolicies")
    def logging_policies(self) -> Optional[pulumi.Input['DeploymentSpecificationLoggingPoliciesArgs']]:
        """
        (Updatable) Policies controlling the pushing of logs to Oracle Cloud Infrastructure Public Logging.
        """
        return pulumi.get(self, "logging_policies")

    @logging_policies.setter
    def logging_policies(self, value: Optional[pulumi.Input['DeploymentSpecificationLoggingPoliciesArgs']]):
        pulumi.set(self, "logging_policies", value)

    @_builtins.property
    @pulumi.getter(name="requestPolicies")
    def request_policies(self) -> Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesArgs']]:
        """
        (Updatable) Global behavior applied to all requests received by the API.
        """
        return pulumi.get(self, "request_policies")

    @request_policies.setter
    def request_policies(self, value: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesArgs']]):
        pulumi.set(self, "request_policies", value)


if not MYPY:
    class DeploymentSpecificationLoggingPoliciesArgsDict(TypedDict):
        access_log: NotRequired[pulumi.Input['DeploymentSpecificationLoggingPoliciesAccessLogArgsDict']]
        """
        (Updatable) Configures the logging policies for the access logs of an API Deployment.
        """
        execution_log: NotRequired[pulumi.Input['DeploymentSpecificationLoggingPoliciesExecutionLogArgsDict']]
        """
        (Updatable) Configures the logging policies for the execution logs of an API Deployment.
        """
elif False:
    DeploymentSpecificationLoggingPoliciesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationLoggingPoliciesArgs:
    def __init__(__self__, *,
                 access_log: Optional[pulumi.Input['DeploymentSpecificationLoggingPoliciesAccessLogArgs']] = None,
                 execution_log: Optional[pulumi.Input['DeploymentSpecificationLoggingPoliciesExecutionLogArgs']] = None):
        """
        :param pulumi.Input['DeploymentSpecificationLoggingPoliciesAccessLogArgs'] access_log: (Updatable) Configures the logging policies for the access logs of an API Deployment.
        :param pulumi.Input['DeploymentSpecificationLoggingPoliciesExecutionLogArgs'] execution_log: (Updatable) Configures the logging policies for the execution logs of an API Deployment.
        """
        if access_log is not None:
            pulumi.set(__self__, "access_log", access_log)
        if execution_log is not None:
            pulumi.set(__self__, "execution_log", execution_log)

    @_builtins.property
    @pulumi.getter(name="accessLog")
    def access_log(self) -> Optional[pulumi.Input['DeploymentSpecificationLoggingPoliciesAccessLogArgs']]:
        """
        (Updatable) Configures the logging policies for the access logs of an API Deployment.
        """
        return pulumi.get(self, "access_log")

    @access_log.setter
    def access_log(self, value: Optional[pulumi.Input['DeploymentSpecificationLoggingPoliciesAccessLogArgs']]):
        pulumi.set(self, "access_log", value)

    @_builtins.property
    @pulumi.getter(name="executionLog")
    def execution_log(self) -> Optional[pulumi.Input['DeploymentSpecificationLoggingPoliciesExecutionLogArgs']]:
        """
        (Updatable) Configures the logging policies for the execution logs of an API Deployment.
        """
        return pulumi.get(self, "execution_log")

    @execution_log.setter
    def execution_log(self, value: Optional[pulumi.Input['DeploymentSpecificationLoggingPoliciesExecutionLogArgs']]):
        pulumi.set(self, "execution_log", value)


if not MYPY:
    class DeploymentSpecificationLoggingPoliciesAccessLogArgsDict(TypedDict):
        is_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Enables pushing of access logs to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket.

        Oracle recommends using the Oracle Cloud Infrastructure Logging service to enable, retrieve, and query access logs for an API Deployment. If there is an active log object for the API Deployment and its category is set to 'access' in Oracle Cloud Infrastructure Logging service, the logs will not be uploaded to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket.

        Please note that the functionality to push to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket has been deprecated and will be removed in the future.
        """
elif False:
    DeploymentSpecificationLoggingPoliciesAccessLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationLoggingPoliciesAccessLogArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_enabled: (Updatable) Enables pushing of access logs to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket.
               
               Oracle recommends using the Oracle Cloud Infrastructure Logging service to enable, retrieve, and query access logs for an API Deployment. If there is an active log object for the API Deployment and its category is set to 'access' in Oracle Cloud Infrastructure Logging service, the logs will not be uploaded to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket.
               
               Please note that the functionality to push to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket has been deprecated and will be removed in the future.
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Enables pushing of access logs to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket.

        Oracle recommends using the Oracle Cloud Infrastructure Logging service to enable, retrieve, and query access logs for an API Deployment. If there is an active log object for the API Deployment and its category is set to 'access' in Oracle Cloud Infrastructure Logging service, the logs will not be uploaded to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket.

        Please note that the functionality to push to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket has been deprecated and will be removed in the future.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_enabled", value)


if not MYPY:
    class DeploymentSpecificationLoggingPoliciesExecutionLogArgsDict(TypedDict):
        is_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Enables pushing of execution logs to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket.

        Oracle recommends using the Oracle Cloud Infrastructure Logging service to enable, retrieve, and query execution logs for an API Deployment. If there is an active log object for the API Deployment and its category is set to 'execution' in Oracle Cloud Infrastructure Logging service, the logs will not be uploaded to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket.

        Please note that the functionality to push to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket has been deprecated and will be removed in the future.
        """
        log_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Specifies the log level used to control logging output of execution logs. Enabling logging at a given level also enables logging at all higher levels.
        """
elif False:
    DeploymentSpecificationLoggingPoliciesExecutionLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationLoggingPoliciesExecutionLogArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 log_level: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_enabled: (Updatable) Enables pushing of execution logs to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket.
               
               Oracle recommends using the Oracle Cloud Infrastructure Logging service to enable, retrieve, and query execution logs for an API Deployment. If there is an active log object for the API Deployment and its category is set to 'execution' in Oracle Cloud Infrastructure Logging service, the logs will not be uploaded to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket.
               
               Please note that the functionality to push to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket has been deprecated and will be removed in the future.
        :param pulumi.Input[_builtins.str] log_level: (Updatable) Specifies the log level used to control logging output of execution logs. Enabling logging at a given level also enables logging at all higher levels.
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Enables pushing of execution logs to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket.

        Oracle recommends using the Oracle Cloud Infrastructure Logging service to enable, retrieve, and query execution logs for an API Deployment. If there is an active log object for the API Deployment and its category is set to 'execution' in Oracle Cloud Infrastructure Logging service, the logs will not be uploaded to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket.

        Please note that the functionality to push to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket has been deprecated and will be removed in the future.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_enabled", value)

    @_builtins.property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Specifies the log level used to control logging output of execution logs. Enabling logging at a given level also enables logging at all higher levels.
        """
        return pulumi.get(self, "log_level")

    @log_level.setter
    def log_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_level", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesArgsDict(TypedDict):
        authentication: NotRequired[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationArgsDict']]
        """
        (Updatable) Information on how to authenticate incoming requests.
        """
        cors: NotRequired[pulumi.Input['DeploymentSpecificationRequestPoliciesCorsArgsDict']]
        """
        (Updatable) Enable CORS (Cross-Origin-Resource-Sharing) request handling.
        """
        dynamic_authentication: NotRequired[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationArgsDict']]
        """
        (Updatable) Policy on how to authenticate requests when multiple authentication options are configured for a deployment. For an incoming request, the value of selector specified under selectionSource will be matched against the keys specified for each authentication server. The authentication server whose key matches the value of selector will be used for authentication.
        """
        mutual_tls: NotRequired[pulumi.Input['DeploymentSpecificationRequestPoliciesMutualTlsArgsDict']]
        """
        (Updatable) Properties used to configure client mTLS verification when API Consumer makes connection to the gateway.
        """
        rate_limiting: NotRequired[pulumi.Input['DeploymentSpecificationRequestPoliciesRateLimitingArgsDict']]
        """
        (Updatable) Limit the number of requests that should be handled for the specified window using a specfic key.
        """
        usage_plans: NotRequired[pulumi.Input['DeploymentSpecificationRequestPoliciesUsagePlansArgsDict']]
        """
        (Updatable) Usage plan policies for this deployment
        """
elif False:
    DeploymentSpecificationRequestPoliciesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesArgs:
    def __init__(__self__, *,
                 authentication: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationArgs']] = None,
                 cors: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesCorsArgs']] = None,
                 dynamic_authentication: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationArgs']] = None,
                 mutual_tls: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesMutualTlsArgs']] = None,
                 rate_limiting: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesRateLimitingArgs']] = None,
                 usage_plans: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesUsagePlansArgs']] = None):
        """
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationArgs'] authentication: (Updatable) Information on how to authenticate incoming requests.
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesCorsArgs'] cors: (Updatable) Enable CORS (Cross-Origin-Resource-Sharing) request handling.
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationArgs'] dynamic_authentication: (Updatable) Policy on how to authenticate requests when multiple authentication options are configured for a deployment. For an incoming request, the value of selector specified under selectionSource will be matched against the keys specified for each authentication server. The authentication server whose key matches the value of selector will be used for authentication.
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesMutualTlsArgs'] mutual_tls: (Updatable) Properties used to configure client mTLS verification when API Consumer makes connection to the gateway.
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesRateLimitingArgs'] rate_limiting: (Updatable) Limit the number of requests that should be handled for the specified window using a specfic key.
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesUsagePlansArgs'] usage_plans: (Updatable) Usage plan policies for this deployment
        """
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if dynamic_authentication is not None:
            pulumi.set(__self__, "dynamic_authentication", dynamic_authentication)
        if mutual_tls is not None:
            pulumi.set(__self__, "mutual_tls", mutual_tls)
        if rate_limiting is not None:
            pulumi.set(__self__, "rate_limiting", rate_limiting)
        if usage_plans is not None:
            pulumi.set(__self__, "usage_plans", usage_plans)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationArgs']]:
        """
        (Updatable) Information on how to authenticate incoming requests.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def cors(self) -> Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesCorsArgs']]:
        """
        (Updatable) Enable CORS (Cross-Origin-Resource-Sharing) request handling.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesCorsArgs']]):
        pulumi.set(self, "cors", value)

    @_builtins.property
    @pulumi.getter(name="dynamicAuthentication")
    def dynamic_authentication(self) -> Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationArgs']]:
        """
        (Updatable) Policy on how to authenticate requests when multiple authentication options are configured for a deployment. For an incoming request, the value of selector specified under selectionSource will be matched against the keys specified for each authentication server. The authentication server whose key matches the value of selector will be used for authentication.
        """
        return pulumi.get(self, "dynamic_authentication")

    @dynamic_authentication.setter
    def dynamic_authentication(self, value: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationArgs']]):
        pulumi.set(self, "dynamic_authentication", value)

    @_builtins.property
    @pulumi.getter(name="mutualTls")
    def mutual_tls(self) -> Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesMutualTlsArgs']]:
        """
        (Updatable) Properties used to configure client mTLS verification when API Consumer makes connection to the gateway.
        """
        return pulumi.get(self, "mutual_tls")

    @mutual_tls.setter
    def mutual_tls(self, value: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesMutualTlsArgs']]):
        pulumi.set(self, "mutual_tls", value)

    @_builtins.property
    @pulumi.getter(name="rateLimiting")
    def rate_limiting(self) -> Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesRateLimitingArgs']]:
        """
        (Updatable) Limit the number of requests that should be handled for the specified window using a specfic key.
        """
        return pulumi.get(self, "rate_limiting")

    @rate_limiting.setter
    def rate_limiting(self, value: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesRateLimitingArgs']]):
        pulumi.set(self, "rate_limiting", value)

    @_builtins.property
    @pulumi.getter(name="usagePlans")
    def usage_plans(self) -> Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesUsagePlansArgs']]:
        """
        (Updatable) Usage plan policies for this deployment
        """
        return pulumi.get(self, "usage_plans")

    @usage_plans.setter
    def usage_plans(self, value: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesUsagePlansArgs']]):
        pulumi.set(self, "usage_plans", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesAuthenticationArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of the authentication policy to use.
        """
        audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The list of intended recipients for the token.
        """
        cache_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) A list of keys from "parameters" attribute value whose values will be added to the cache key.
        """
        function_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Functions function resource.
        """
        is_anonymous_access_allowed: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Whether an unauthenticated user may access the API. Must be "true" to enable ANONYMOUS route authorization.
        """
        issuers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) A list of parties that could have issued the token.
        """
        max_clock_skew_in_seconds: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Updatable) The maximum expected time difference between the system clocks of the token issuer and the API Gateway.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        (Updatable) A map where key is a user defined string and value is a context expressions whose values will be sent to the custom auth function. Values should contain an expression. Example: `{"foo": "request.header[abc]"}`
        """
        public_keys: NotRequired[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationPublicKeysArgsDict']]
        """
        (Updatable) A set of Public Keys that will be used to verify the JWT signature.
        """
        token_auth_scheme: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The authentication scheme that is to be used when authenticating the token. This must to be provided if "tokenHeader" is specified.
        """
        token_header: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the header containing the authentication token.
        """
        token_query_param: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the query parameter containing the authentication token.
        """
        validation_failure_policy: NotRequired[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyArgsDict']]
        """
        (Updatable) Policy for defining behaviour on validation failure.
        """
        validation_policy: NotRequired[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyArgsDict']]
        """
        (Updatable) Authentication Policies for the Token Authentication types.
        """
        verify_claims: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationVerifyClaimArgsDict']]]]
        """
        (Updatable) A list of claims which should be validated to consider the token valid.
        """
elif False:
    DeploymentSpecificationRequestPoliciesAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesAuthenticationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 audiences: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 cache_keys: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 function_id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_anonymous_access_allowed: Optional[pulumi.Input[_builtins.bool]] = None,
                 issuers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 max_clock_skew_in_seconds: Optional[pulumi.Input[_builtins.float]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 public_keys: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationPublicKeysArgs']] = None,
                 token_auth_scheme: Optional[pulumi.Input[_builtins.str]] = None,
                 token_header: Optional[pulumi.Input[_builtins.str]] = None,
                 token_query_param: Optional[pulumi.Input[_builtins.str]] = None,
                 validation_failure_policy: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyArgs']] = None,
                 validation_policy: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyArgs']] = None,
                 verify_claims: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationVerifyClaimArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] type: (Updatable) Type of the authentication policy to use.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] audiences: (Updatable) The list of intended recipients for the token.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] cache_keys: (Updatable) A list of keys from "parameters" attribute value whose values will be added to the cache key.
        :param pulumi.Input[_builtins.str] function_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Functions function resource.
        :param pulumi.Input[_builtins.bool] is_anonymous_access_allowed: (Updatable) Whether an unauthenticated user may access the API. Must be "true" to enable ANONYMOUS route authorization.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] issuers: (Updatable) A list of parties that could have issued the token.
        :param pulumi.Input[_builtins.float] max_clock_skew_in_seconds: (Updatable) The maximum expected time difference between the system clocks of the token issuer and the API Gateway.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] parameters: (Updatable) A map where key is a user defined string and value is a context expressions whose values will be sent to the custom auth function. Values should contain an expression. Example: `{"foo": "request.header[abc]"}`
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationPublicKeysArgs'] public_keys: (Updatable) A set of Public Keys that will be used to verify the JWT signature.
        :param pulumi.Input[_builtins.str] token_auth_scheme: (Updatable) The authentication scheme that is to be used when authenticating the token. This must to be provided if "tokenHeader" is specified.
        :param pulumi.Input[_builtins.str] token_header: (Updatable) The name of the header containing the authentication token.
        :param pulumi.Input[_builtins.str] token_query_param: (Updatable) The name of the query parameter containing the authentication token.
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyArgs'] validation_failure_policy: (Updatable) Policy for defining behaviour on validation failure.
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyArgs'] validation_policy: (Updatable) Authentication Policies for the Token Authentication types.
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationVerifyClaimArgs']]] verify_claims: (Updatable) A list of claims which should be validated to consider the token valid.
        """
        pulumi.set(__self__, "type", type)
        if audiences is not None:
            pulumi.set(__self__, "audiences", audiences)
        if cache_keys is not None:
            pulumi.set(__self__, "cache_keys", cache_keys)
        if function_id is not None:
            pulumi.set(__self__, "function_id", function_id)
        if is_anonymous_access_allowed is not None:
            pulumi.set(__self__, "is_anonymous_access_allowed", is_anonymous_access_allowed)
        if issuers is not None:
            pulumi.set(__self__, "issuers", issuers)
        if max_clock_skew_in_seconds is not None:
            pulumi.set(__self__, "max_clock_skew_in_seconds", max_clock_skew_in_seconds)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if public_keys is not None:
            pulumi.set(__self__, "public_keys", public_keys)
        if token_auth_scheme is not None:
            pulumi.set(__self__, "token_auth_scheme", token_auth_scheme)
        if token_header is not None:
            pulumi.set(__self__, "token_header", token_header)
        if token_query_param is not None:
            pulumi.set(__self__, "token_query_param", token_query_param)
        if validation_failure_policy is not None:
            pulumi.set(__self__, "validation_failure_policy", validation_failure_policy)
        if validation_policy is not None:
            pulumi.set(__self__, "validation_policy", validation_policy)
        if verify_claims is not None:
            pulumi.set(__self__, "verify_claims", verify_claims)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of the authentication policy to use.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The list of intended recipients for the token.
        """
        return pulumi.get(self, "audiences")

    @audiences.setter
    def audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "audiences", value)

    @_builtins.property
    @pulumi.getter(name="cacheKeys")
    def cache_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) A list of keys from "parameters" attribute value whose values will be added to the cache key.
        """
        return pulumi.get(self, "cache_keys")

    @cache_keys.setter
    def cache_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "cache_keys", value)

    @_builtins.property
    @pulumi.getter(name="functionId")
    def function_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Functions function resource.
        """
        return pulumi.get(self, "function_id")

    @function_id.setter
    def function_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "function_id", value)

    @_builtins.property
    @pulumi.getter(name="isAnonymousAccessAllowed")
    def is_anonymous_access_allowed(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Whether an unauthenticated user may access the API. Must be "true" to enable ANONYMOUS route authorization.
        """
        return pulumi.get(self, "is_anonymous_access_allowed")

    @is_anonymous_access_allowed.setter
    def is_anonymous_access_allowed(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_anonymous_access_allowed", value)

    @_builtins.property
    @pulumi.getter
    def issuers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) A list of parties that could have issued the token.
        """
        return pulumi.get(self, "issuers")

    @issuers.setter
    def issuers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "issuers", value)

    @_builtins.property
    @pulumi.getter(name="maxClockSkewInSeconds")
    def max_clock_skew_in_seconds(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Updatable) The maximum expected time difference between the system clocks of the token issuer and the API Gateway.
        """
        return pulumi.get(self, "max_clock_skew_in_seconds")

    @max_clock_skew_in_seconds.setter
    def max_clock_skew_in_seconds(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max_clock_skew_in_seconds", value)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) A map where key is a user defined string and value is a context expressions whose values will be sent to the custom auth function. Values should contain an expression. Example: `{"foo": "request.header[abc]"}`
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "parameters", value)

    @_builtins.property
    @pulumi.getter(name="publicKeys")
    def public_keys(self) -> Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationPublicKeysArgs']]:
        """
        (Updatable) A set of Public Keys that will be used to verify the JWT signature.
        """
        return pulumi.get(self, "public_keys")

    @public_keys.setter
    def public_keys(self, value: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationPublicKeysArgs']]):
        pulumi.set(self, "public_keys", value)

    @_builtins.property
    @pulumi.getter(name="tokenAuthScheme")
    def token_auth_scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The authentication scheme that is to be used when authenticating the token. This must to be provided if "tokenHeader" is specified.
        """
        return pulumi.get(self, "token_auth_scheme")

    @token_auth_scheme.setter
    def token_auth_scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token_auth_scheme", value)

    @_builtins.property
    @pulumi.getter(name="tokenHeader")
    def token_header(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the header containing the authentication token.
        """
        return pulumi.get(self, "token_header")

    @token_header.setter
    def token_header(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token_header", value)

    @_builtins.property
    @pulumi.getter(name="tokenQueryParam")
    def token_query_param(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the query parameter containing the authentication token.
        """
        return pulumi.get(self, "token_query_param")

    @token_query_param.setter
    def token_query_param(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token_query_param", value)

    @_builtins.property
    @pulumi.getter(name="validationFailurePolicy")
    def validation_failure_policy(self) -> Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyArgs']]:
        """
        (Updatable) Policy for defining behaviour on validation failure.
        """
        return pulumi.get(self, "validation_failure_policy")

    @validation_failure_policy.setter
    def validation_failure_policy(self, value: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyArgs']]):
        pulumi.set(self, "validation_failure_policy", value)

    @_builtins.property
    @pulumi.getter(name="validationPolicy")
    def validation_policy(self) -> Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyArgs']]:
        """
        (Updatable) Authentication Policies for the Token Authentication types.
        """
        return pulumi.get(self, "validation_policy")

    @validation_policy.setter
    def validation_policy(self, value: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyArgs']]):
        pulumi.set(self, "validation_policy", value)

    @_builtins.property
    @pulumi.getter(name="verifyClaims")
    def verify_claims(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationVerifyClaimArgs']]]]:
        """
        (Updatable) A list of claims which should be validated to consider the token valid.
        """
        return pulumi.get(self, "verify_claims")

    @verify_claims.setter
    def verify_claims(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationVerifyClaimArgs']]]]):
        pulumi.set(self, "verify_claims", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesAuthenticationPublicKeysArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of the public key set.
        """
        is_ssl_verify_disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Defines whether or not to uphold SSL verification.
        """
        keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationPublicKeysKeyArgsDict']]]]
        """
        (Updatable) The set of static public keys.
        """
        max_cache_duration_in_hours: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The duration for which the JWKS should be cached before it is fetched again.
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The uri from which to retrieve the key. It must be accessible without authentication.
        """
elif False:
    DeploymentSpecificationRequestPoliciesAuthenticationPublicKeysArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesAuthenticationPublicKeysArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 is_ssl_verify_disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 keys: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationPublicKeysKeyArgs']]]] = None,
                 max_cache_duration_in_hours: Optional[pulumi.Input[_builtins.int]] = None,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: (Updatable) Type of the public key set.
        :param pulumi.Input[_builtins.bool] is_ssl_verify_disabled: (Updatable) Defines whether or not to uphold SSL verification.
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationPublicKeysKeyArgs']]] keys: (Updatable) The set of static public keys.
        :param pulumi.Input[_builtins.int] max_cache_duration_in_hours: (Updatable) The duration for which the JWKS should be cached before it is fetched again.
        :param pulumi.Input[_builtins.str] uri: (Updatable) The uri from which to retrieve the key. It must be accessible without authentication.
        """
        pulumi.set(__self__, "type", type)
        if is_ssl_verify_disabled is not None:
            pulumi.set(__self__, "is_ssl_verify_disabled", is_ssl_verify_disabled)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if max_cache_duration_in_hours is not None:
            pulumi.set(__self__, "max_cache_duration_in_hours", max_cache_duration_in_hours)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of the public key set.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="isSslVerifyDisabled")
    def is_ssl_verify_disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Defines whether or not to uphold SSL verification.
        """
        return pulumi.get(self, "is_ssl_verify_disabled")

    @is_ssl_verify_disabled.setter
    def is_ssl_verify_disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_ssl_verify_disabled", value)

    @_builtins.property
    @pulumi.getter
    def keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationPublicKeysKeyArgs']]]]:
        """
        (Updatable) The set of static public keys.
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationPublicKeysKeyArgs']]]]):
        pulumi.set(self, "keys", value)

    @_builtins.property
    @pulumi.getter(name="maxCacheDurationInHours")
    def max_cache_duration_in_hours(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The duration for which the JWKS should be cached before it is fetched again.
        """
        return pulumi.get(self, "max_cache_duration_in_hours")

    @max_cache_duration_in_hours.setter
    def max_cache_duration_in_hours(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_cache_duration_in_hours", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The uri from which to retrieve the key. It must be accessible without authentication.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesAuthenticationPublicKeysKeyArgsDict(TypedDict):
        format: pulumi.Input[_builtins.str]
        """
        (Updatable) The format of the public key.
        """
        alg: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The algorithm intended for use with this key.
        """
        e: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The base64 url encoded exponent of the RSA public key represented by this key.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The content of the PEM-encoded public key.
        """
        key_ops: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The operations for which this key is to be used.
        """
        kid: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A unique key ID. This key will be used to verify the signature of a JWT with matching "kid".
        """
        kty: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The key type.
        """
        n: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The base64 url encoded modulus of the RSA public key represented by this key.
        """
        use: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The intended use of the public key.
        """
elif False:
    DeploymentSpecificationRequestPoliciesAuthenticationPublicKeysKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesAuthenticationPublicKeysKeyArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[_builtins.str],
                 alg: Optional[pulumi.Input[_builtins.str]] = None,
                 e: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 key_ops: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 kid: Optional[pulumi.Input[_builtins.str]] = None,
                 kty: Optional[pulumi.Input[_builtins.str]] = None,
                 n: Optional[pulumi.Input[_builtins.str]] = None,
                 use: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] format: (Updatable) The format of the public key.
        :param pulumi.Input[_builtins.str] alg: (Updatable) The algorithm intended for use with this key.
        :param pulumi.Input[_builtins.str] e: (Updatable) The base64 url encoded exponent of the RSA public key represented by this key.
        :param pulumi.Input[_builtins.str] key: (Updatable) The content of the PEM-encoded public key.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] key_ops: (Updatable) The operations for which this key is to be used.
        :param pulumi.Input[_builtins.str] kid: (Updatable) A unique key ID. This key will be used to verify the signature of a JWT with matching "kid".
        :param pulumi.Input[_builtins.str] kty: (Updatable) The key type.
        :param pulumi.Input[_builtins.str] n: (Updatable) The base64 url encoded modulus of the RSA public key represented by this key.
        :param pulumi.Input[_builtins.str] use: (Updatable) The intended use of the public key.
        """
        pulumi.set(__self__, "format", format)
        if alg is not None:
            pulumi.set(__self__, "alg", alg)
        if e is not None:
            pulumi.set(__self__, "e", e)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if key_ops is not None:
            pulumi.set(__self__, "key_ops", key_ops)
        if kid is not None:
            pulumi.set(__self__, "kid", kid)
        if kty is not None:
            pulumi.set(__self__, "kty", kty)
        if n is not None:
            pulumi.set(__self__, "n", n)
        if use is not None:
            pulumi.set(__self__, "use", use)

    @_builtins.property
    @pulumi.getter
    def format(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The format of the public key.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter
    def alg(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The algorithm intended for use with this key.
        """
        return pulumi.get(self, "alg")

    @alg.setter
    def alg(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alg", value)

    @_builtins.property
    @pulumi.getter
    def e(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The base64 url encoded exponent of the RSA public key represented by this key.
        """
        return pulumi.get(self, "e")

    @e.setter
    def e(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "e", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The content of the PEM-encoded public key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="keyOps")
    def key_ops(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The operations for which this key is to be used.
        """
        return pulumi.get(self, "key_ops")

    @key_ops.setter
    def key_ops(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "key_ops", value)

    @_builtins.property
    @pulumi.getter
    def kid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A unique key ID. This key will be used to verify the signature of a JWT with matching "kid".
        """
        return pulumi.get(self, "kid")

    @kid.setter
    def kid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kid", value)

    @_builtins.property
    @pulumi.getter
    def kty(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The key type.
        """
        return pulumi.get(self, "kty")

    @kty.setter
    def kty(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kty", value)

    @_builtins.property
    @pulumi.getter
    def n(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The base64 url encoded modulus of the RSA public key represented by this key.
        """
        return pulumi.get(self, "n")

    @n.setter
    def n(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "n", value)

    @_builtins.property
    @pulumi.getter
    def use(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The intended use of the public key.
        """
        return pulumi.get(self, "use")

    @use.setter
    def use(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "use", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of the Validation failure Policy.
        """
        client_details: NotRequired[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyClientDetailsArgsDict']]
        """
        (Updatable) Client App Credential details.
        """
        fallback_redirect_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The path to be used as fallback after OAuth2.
        """
        logout_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The path to be used as logout.
        """
        max_expiry_duration_in_hours: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The duration for which the OAuth2 success token should be cached before it is fetched again.
        """
        response_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) HTTP response code, can include context variables.
        """
        response_header_transformations: NotRequired[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsArgsDict']]
        """
        (Updatable) A set of transformations to apply to HTTP headers that pass through the gateway.
        """
        response_message: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) HTTP response message.
        """
        response_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Response Type.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) List of scopes.
        """
        source_uri_details: NotRequired[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicySourceUriDetailsArgsDict']]
        """
        (Updatable) Auth endpoint details.
        """
        use_cookies_for_intermediate_steps: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Defines whether or not to use cookies for OAuth2 intermediate steps.
        """
        use_cookies_for_session: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Defines whether or not to use cookies for session maintenance.
        """
        use_pkce: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Defines whether or not to support PKCE.
        """
elif False:
    DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 client_details: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyClientDetailsArgs']] = None,
                 fallback_redirect_path: Optional[pulumi.Input[_builtins.str]] = None,
                 logout_path: Optional[pulumi.Input[_builtins.str]] = None,
                 max_expiry_duration_in_hours: Optional[pulumi.Input[_builtins.int]] = None,
                 response_code: Optional[pulumi.Input[_builtins.str]] = None,
                 response_header_transformations: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsArgs']] = None,
                 response_message: Optional[pulumi.Input[_builtins.str]] = None,
                 response_type: Optional[pulumi.Input[_builtins.str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 source_uri_details: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicySourceUriDetailsArgs']] = None,
                 use_cookies_for_intermediate_steps: Optional[pulumi.Input[_builtins.bool]] = None,
                 use_cookies_for_session: Optional[pulumi.Input[_builtins.bool]] = None,
                 use_pkce: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] type: (Updatable) Type of the Validation failure Policy.
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyClientDetailsArgs'] client_details: (Updatable) Client App Credential details.
        :param pulumi.Input[_builtins.str] fallback_redirect_path: (Updatable) The path to be used as fallback after OAuth2.
        :param pulumi.Input[_builtins.str] logout_path: (Updatable) The path to be used as logout.
        :param pulumi.Input[_builtins.int] max_expiry_duration_in_hours: (Updatable) The duration for which the OAuth2 success token should be cached before it is fetched again.
        :param pulumi.Input[_builtins.str] response_code: (Updatable) HTTP response code, can include context variables.
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsArgs'] response_header_transformations: (Updatable) A set of transformations to apply to HTTP headers that pass through the gateway.
        :param pulumi.Input[_builtins.str] response_message: (Updatable) HTTP response message.
        :param pulumi.Input[_builtins.str] response_type: (Updatable) Response Type.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: (Updatable) List of scopes.
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicySourceUriDetailsArgs'] source_uri_details: (Updatable) Auth endpoint details.
        :param pulumi.Input[_builtins.bool] use_cookies_for_intermediate_steps: (Updatable) Defines whether or not to use cookies for OAuth2 intermediate steps.
        :param pulumi.Input[_builtins.bool] use_cookies_for_session: (Updatable) Defines whether or not to use cookies for session maintenance.
        :param pulumi.Input[_builtins.bool] use_pkce: (Updatable) Defines whether or not to support PKCE.
        """
        pulumi.set(__self__, "type", type)
        if client_details is not None:
            pulumi.set(__self__, "client_details", client_details)
        if fallback_redirect_path is not None:
            pulumi.set(__self__, "fallback_redirect_path", fallback_redirect_path)
        if logout_path is not None:
            pulumi.set(__self__, "logout_path", logout_path)
        if max_expiry_duration_in_hours is not None:
            pulumi.set(__self__, "max_expiry_duration_in_hours", max_expiry_duration_in_hours)
        if response_code is not None:
            pulumi.set(__self__, "response_code", response_code)
        if response_header_transformations is not None:
            pulumi.set(__self__, "response_header_transformations", response_header_transformations)
        if response_message is not None:
            pulumi.set(__self__, "response_message", response_message)
        if response_type is not None:
            pulumi.set(__self__, "response_type", response_type)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if source_uri_details is not None:
            pulumi.set(__self__, "source_uri_details", source_uri_details)
        if use_cookies_for_intermediate_steps is not None:
            pulumi.set(__self__, "use_cookies_for_intermediate_steps", use_cookies_for_intermediate_steps)
        if use_cookies_for_session is not None:
            pulumi.set(__self__, "use_cookies_for_session", use_cookies_for_session)
        if use_pkce is not None:
            pulumi.set(__self__, "use_pkce", use_pkce)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of the Validation failure Policy.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="clientDetails")
    def client_details(self) -> Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyClientDetailsArgs']]:
        """
        (Updatable) Client App Credential details.
        """
        return pulumi.get(self, "client_details")

    @client_details.setter
    def client_details(self, value: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyClientDetailsArgs']]):
        pulumi.set(self, "client_details", value)

    @_builtins.property
    @pulumi.getter(name="fallbackRedirectPath")
    def fallback_redirect_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The path to be used as fallback after OAuth2.
        """
        return pulumi.get(self, "fallback_redirect_path")

    @fallback_redirect_path.setter
    def fallback_redirect_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_redirect_path", value)

    @_builtins.property
    @pulumi.getter(name="logoutPath")
    def logout_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The path to be used as logout.
        """
        return pulumi.get(self, "logout_path")

    @logout_path.setter
    def logout_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logout_path", value)

    @_builtins.property
    @pulumi.getter(name="maxExpiryDurationInHours")
    def max_expiry_duration_in_hours(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The duration for which the OAuth2 success token should be cached before it is fetched again.
        """
        return pulumi.get(self, "max_expiry_duration_in_hours")

    @max_expiry_duration_in_hours.setter
    def max_expiry_duration_in_hours(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_expiry_duration_in_hours", value)

    @_builtins.property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) HTTP response code, can include context variables.
        """
        return pulumi.get(self, "response_code")

    @response_code.setter
    def response_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_code", value)

    @_builtins.property
    @pulumi.getter(name="responseHeaderTransformations")
    def response_header_transformations(self) -> Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsArgs']]:
        """
        (Updatable) A set of transformations to apply to HTTP headers that pass through the gateway.
        """
        return pulumi.get(self, "response_header_transformations")

    @response_header_transformations.setter
    def response_header_transformations(self, value: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsArgs']]):
        pulumi.set(self, "response_header_transformations", value)

    @_builtins.property
    @pulumi.getter(name="responseMessage")
    def response_message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) HTTP response message.
        """
        return pulumi.get(self, "response_message")

    @response_message.setter
    def response_message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_message", value)

    @_builtins.property
    @pulumi.getter(name="responseType")
    def response_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Response Type.
        """
        return pulumi.get(self, "response_type")

    @response_type.setter
    def response_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_type", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) List of scopes.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter(name="sourceUriDetails")
    def source_uri_details(self) -> Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicySourceUriDetailsArgs']]:
        """
        (Updatable) Auth endpoint details.
        """
        return pulumi.get(self, "source_uri_details")

    @source_uri_details.setter
    def source_uri_details(self, value: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicySourceUriDetailsArgs']]):
        pulumi.set(self, "source_uri_details", value)

    @_builtins.property
    @pulumi.getter(name="useCookiesForIntermediateSteps")
    def use_cookies_for_intermediate_steps(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Defines whether or not to use cookies for OAuth2 intermediate steps.
        """
        return pulumi.get(self, "use_cookies_for_intermediate_steps")

    @use_cookies_for_intermediate_steps.setter
    def use_cookies_for_intermediate_steps(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_cookies_for_intermediate_steps", value)

    @_builtins.property
    @pulumi.getter(name="useCookiesForSession")
    def use_cookies_for_session(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Defines whether or not to use cookies for session maintenance.
        """
        return pulumi.get(self, "use_cookies_for_session")

    @use_cookies_for_session.setter
    def use_cookies_for_session(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_cookies_for_session", value)

    @_builtins.property
    @pulumi.getter(name="usePkce")
    def use_pkce(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Defines whether or not to support PKCE.
        """
        return pulumi.get(self, "use_pkce")

    @use_pkce.setter
    def use_pkce(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_pkce", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyClientDetailsArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) To specify where the Client App details should be taken from.
        """
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Client ID for the OAuth2/OIDC app.
        """
        client_secret_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Vault Service secret resource.
        """
        client_secret_version_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The version number of the client secret to use.
        """
elif False:
    DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyClientDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyClientDetailsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret_version_number: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: (Updatable) To specify where the Client App details should be taken from.
        :param pulumi.Input[_builtins.str] client_id: (Updatable) Client ID for the OAuth2/OIDC app.
        :param pulumi.Input[_builtins.str] client_secret_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Vault Service secret resource.
        :param pulumi.Input[_builtins.str] client_secret_version_number: (Updatable) The version number of the client secret to use.
        """
        pulumi.set(__self__, "type", type)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret_id is not None:
            pulumi.set(__self__, "client_secret_id", client_secret_id)
        if client_secret_version_number is not None:
            pulumi.set(__self__, "client_secret_version_number", client_secret_version_number)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) To specify where the Client App details should be taken from.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Client ID for the OAuth2/OIDC app.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecretId")
    def client_secret_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Vault Service secret resource.
        """
        return pulumi.get(self, "client_secret_id")

    @client_secret_id.setter
    def client_secret_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecretVersionNumber")
    def client_secret_version_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The version number of the client secret to use.
        """
        return pulumi.get(self, "client_secret_version_number")

    @client_secret_version_number.setter
    def client_secret_version_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret_version_number", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsArgsDict(TypedDict):
        filter_headers: NotRequired[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsFilterHeadersArgsDict']]
        """
        (Updatable) Filter HTTP headers as they pass through the gateway.  The gateway applies filters after other transformations, so any headers set or renamed must also be listed here when using an ALLOW type policy.
        """
        rename_headers: NotRequired[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsRenameHeadersArgsDict']]
        """
        (Updatable) Rename HTTP headers as they pass through the gateway.
        """
        set_headers: NotRequired[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsSetHeadersArgsDict']]
        """
        (Updatable) Set HTTP headers as they pass through the gateway.
        """
elif False:
    DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsArgs:
    def __init__(__self__, *,
                 filter_headers: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsFilterHeadersArgs']] = None,
                 rename_headers: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsRenameHeadersArgs']] = None,
                 set_headers: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsSetHeadersArgs']] = None):
        """
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsFilterHeadersArgs'] filter_headers: (Updatable) Filter HTTP headers as they pass through the gateway.  The gateway applies filters after other transformations, so any headers set or renamed must also be listed here when using an ALLOW type policy.
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsRenameHeadersArgs'] rename_headers: (Updatable) Rename HTTP headers as they pass through the gateway.
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsSetHeadersArgs'] set_headers: (Updatable) Set HTTP headers as they pass through the gateway.
        """
        if filter_headers is not None:
            pulumi.set(__self__, "filter_headers", filter_headers)
        if rename_headers is not None:
            pulumi.set(__self__, "rename_headers", rename_headers)
        if set_headers is not None:
            pulumi.set(__self__, "set_headers", set_headers)

    @_builtins.property
    @pulumi.getter(name="filterHeaders")
    def filter_headers(self) -> Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsFilterHeadersArgs']]:
        """
        (Updatable) Filter HTTP headers as they pass through the gateway.  The gateway applies filters after other transformations, so any headers set or renamed must also be listed here when using an ALLOW type policy.
        """
        return pulumi.get(self, "filter_headers")

    @filter_headers.setter
    def filter_headers(self, value: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsFilterHeadersArgs']]):
        pulumi.set(self, "filter_headers", value)

    @_builtins.property
    @pulumi.getter(name="renameHeaders")
    def rename_headers(self) -> Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsRenameHeadersArgs']]:
        """
        (Updatable) Rename HTTP headers as they pass through the gateway.
        """
        return pulumi.get(self, "rename_headers")

    @rename_headers.setter
    def rename_headers(self, value: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsRenameHeadersArgs']]):
        pulumi.set(self, "rename_headers", value)

    @_builtins.property
    @pulumi.getter(name="setHeaders")
    def set_headers(self) -> Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsSetHeadersArgs']]:
        """
        (Updatable) Set HTTP headers as they pass through the gateway.
        """
        return pulumi.get(self, "set_headers")

    @set_headers.setter
    def set_headers(self, value: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsSetHeadersArgs']]):
        pulumi.set(self, "set_headers", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsFilterHeadersArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsFilterHeadersItemArgsDict']]]]
        """
        (Updatable) The list of headers.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) BLOCK drops any headers that are in the list of items, so it acts as an exclusion list.  ALLOW permits only the headers in the list and removes all others, so it acts as an inclusion list.
        """
elif False:
    DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsFilterHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsFilterHeadersArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsFilterHeadersItemArgs']]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsFilterHeadersItemArgs']]] items: (Updatable) The list of headers.
        :param pulumi.Input[_builtins.str] type: (Updatable) BLOCK drops any headers that are in the list of items, so it acts as an exclusion list.  ALLOW permits only the headers in the list and removes all others, so it acts as an inclusion list.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsFilterHeadersItemArgs']]]]:
        """
        (Updatable) The list of headers.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsFilterHeadersItemArgs']]]]):
        pulumi.set(self, "items", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) BLOCK drops any headers that are in the list of items, so it acts as an exclusion list.  ALLOW permits only the headers in the list and removes all others, so it acts as an inclusion list.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsFilterHeadersItemArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
elif False:
    DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsFilterHeadersItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsFilterHeadersItemArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsRenameHeadersArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsRenameHeadersItemArgsDict']]]]
        """
        (Updatable) The list of headers.
        """
elif False:
    DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsRenameHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsRenameHeadersArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsRenameHeadersItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsRenameHeadersItemArgs']]] items: (Updatable) The list of headers.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsRenameHeadersItemArgs']]]]:
        """
        (Updatable) The list of headers.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsRenameHeadersItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsRenameHeadersItemArgsDict(TypedDict):
        from_: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The original case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        to: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The new name of the header.  This name must be unique across transformation policies.
        """
elif False:
    DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsRenameHeadersItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsRenameHeadersItemArgs:
    def __init__(__self__, *,
                 from_: Optional[pulumi.Input[_builtins.str]] = None,
                 to: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] from_: (Updatable) The original case-insensitive name of the header.  This name must be unique across transformation policies.
        :param pulumi.Input[_builtins.str] to: (Updatable) The new name of the header.  This name must be unique across transformation policies.
        """
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The original case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The new name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsSetHeadersArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsSetHeadersItemArgsDict']]]]
        """
        (Updatable) The list of headers.
        """
elif False:
    DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsSetHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsSetHeadersArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsSetHeadersItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsSetHeadersItemArgs']]] items: (Updatable) The list of headers.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsSetHeadersItemArgs']]]]:
        """
        (Updatable) The list of headers.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsSetHeadersItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsSetHeadersItemArgsDict(TypedDict):
        if_exists: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) If a header with the same name already exists in the request, OVERWRITE will overwrite the value, APPEND will append to the existing value, or SKIP will keep the existing value.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) A list of new values.  Each value can be a constant or may include one or more expressions enclosed within ${} delimiters.
        """
elif False:
    DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsSetHeadersItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicyResponseHeaderTransformationsSetHeadersItemArgs:
    def __init__(__self__, *,
                 if_exists: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] if_exists: (Updatable) If a header with the same name already exists in the request, OVERWRITE will overwrite the value, APPEND will append to the existing value, or SKIP will keep the existing value.
        :param pulumi.Input[_builtins.str] name: (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: (Updatable) A list of new values.  Each value can be a constant or may include one or more expressions enclosed within ${} delimiters.
        """
        if if_exists is not None:
            pulumi.set(__self__, "if_exists", if_exists)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="ifExists")
    def if_exists(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) If a header with the same name already exists in the request, OVERWRITE will overwrite the value, APPEND will append to the existing value, or SKIP will keep the existing value.
        """
        return pulumi.get(self, "if_exists")

    @if_exists.setter
    def if_exists(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "if_exists", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) A list of new values.  Each value can be a constant or may include one or more expressions enclosed within ${} delimiters.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicySourceUriDetailsArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of the Uri detail.
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The discovery URI for the auth server.
        """
elif False:
    DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicySourceUriDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesAuthenticationValidationFailurePolicySourceUriDetailsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: (Updatable) Type of the Uri detail.
        :param pulumi.Input[_builtins.str] uri: (Updatable) The discovery URI for the auth server.
        """
        pulumi.set(__self__, "type", type)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of the Uri detail.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The discovery URI for the auth server.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of the token validation policy.
        """
        additional_validation_policy: NotRequired[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyAdditionalValidationPolicyArgsDict']]
        """
        (Updatable) Additional JWT validation checks.
        """
        client_details: NotRequired[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyClientDetailsArgsDict']]
        """
        (Updatable) Client App Credential details.
        """
        is_ssl_verify_disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Defines whether or not to uphold SSL verification.
        """
        keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyKeyArgsDict']]]]
        """
        (Updatable) The set of static public keys.
        """
        max_cache_duration_in_hours: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The duration for which the introspect URL response should be cached before it is fetched again.
        """
        source_uri_details: NotRequired[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicySourceUriDetailsArgsDict']]
        """
        (Updatable) Auth endpoint details.
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The uri from which to retrieve the key. It must be accessible without authentication.
        """
elif False:
    DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 additional_validation_policy: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyAdditionalValidationPolicyArgs']] = None,
                 client_details: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyClientDetailsArgs']] = None,
                 is_ssl_verify_disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 keys: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyKeyArgs']]]] = None,
                 max_cache_duration_in_hours: Optional[pulumi.Input[_builtins.int]] = None,
                 source_uri_details: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicySourceUriDetailsArgs']] = None,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: (Updatable) Type of the token validation policy.
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyAdditionalValidationPolicyArgs'] additional_validation_policy: (Updatable) Additional JWT validation checks.
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyClientDetailsArgs'] client_details: (Updatable) Client App Credential details.
        :param pulumi.Input[_builtins.bool] is_ssl_verify_disabled: (Updatable) Defines whether or not to uphold SSL verification.
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyKeyArgs']]] keys: (Updatable) The set of static public keys.
        :param pulumi.Input[_builtins.int] max_cache_duration_in_hours: (Updatable) The duration for which the introspect URL response should be cached before it is fetched again.
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicySourceUriDetailsArgs'] source_uri_details: (Updatable) Auth endpoint details.
        :param pulumi.Input[_builtins.str] uri: (Updatable) The uri from which to retrieve the key. It must be accessible without authentication.
        """
        pulumi.set(__self__, "type", type)
        if additional_validation_policy is not None:
            pulumi.set(__self__, "additional_validation_policy", additional_validation_policy)
        if client_details is not None:
            pulumi.set(__self__, "client_details", client_details)
        if is_ssl_verify_disabled is not None:
            pulumi.set(__self__, "is_ssl_verify_disabled", is_ssl_verify_disabled)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if max_cache_duration_in_hours is not None:
            pulumi.set(__self__, "max_cache_duration_in_hours", max_cache_duration_in_hours)
        if source_uri_details is not None:
            pulumi.set(__self__, "source_uri_details", source_uri_details)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of the token validation policy.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="additionalValidationPolicy")
    def additional_validation_policy(self) -> Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyAdditionalValidationPolicyArgs']]:
        """
        (Updatable) Additional JWT validation checks.
        """
        return pulumi.get(self, "additional_validation_policy")

    @additional_validation_policy.setter
    def additional_validation_policy(self, value: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyAdditionalValidationPolicyArgs']]):
        pulumi.set(self, "additional_validation_policy", value)

    @_builtins.property
    @pulumi.getter(name="clientDetails")
    def client_details(self) -> Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyClientDetailsArgs']]:
        """
        (Updatable) Client App Credential details.
        """
        return pulumi.get(self, "client_details")

    @client_details.setter
    def client_details(self, value: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyClientDetailsArgs']]):
        pulumi.set(self, "client_details", value)

    @_builtins.property
    @pulumi.getter(name="isSslVerifyDisabled")
    def is_ssl_verify_disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Defines whether or not to uphold SSL verification.
        """
        return pulumi.get(self, "is_ssl_verify_disabled")

    @is_ssl_verify_disabled.setter
    def is_ssl_verify_disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_ssl_verify_disabled", value)

    @_builtins.property
    @pulumi.getter
    def keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyKeyArgs']]]]:
        """
        (Updatable) The set of static public keys.
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyKeyArgs']]]]):
        pulumi.set(self, "keys", value)

    @_builtins.property
    @pulumi.getter(name="maxCacheDurationInHours")
    def max_cache_duration_in_hours(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The duration for which the introspect URL response should be cached before it is fetched again.
        """
        return pulumi.get(self, "max_cache_duration_in_hours")

    @max_cache_duration_in_hours.setter
    def max_cache_duration_in_hours(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_cache_duration_in_hours", value)

    @_builtins.property
    @pulumi.getter(name="sourceUriDetails")
    def source_uri_details(self) -> Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicySourceUriDetailsArgs']]:
        """
        (Updatable) Auth endpoint details.
        """
        return pulumi.get(self, "source_uri_details")

    @source_uri_details.setter
    def source_uri_details(self, value: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicySourceUriDetailsArgs']]):
        pulumi.set(self, "source_uri_details", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The uri from which to retrieve the key. It must be accessible without authentication.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyAdditionalValidationPolicyArgsDict(TypedDict):
        audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The list of intended recipients for the token.
        """
        issuers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) A list of parties that could have issued the token.
        """
        verify_claims: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyAdditionalValidationPolicyVerifyClaimArgsDict']]]]
        """
        (Updatable) A list of claims which should be validated to consider the token valid.
        """
elif False:
    DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyAdditionalValidationPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyAdditionalValidationPolicyArgs:
    def __init__(__self__, *,
                 audiences: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 issuers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 verify_claims: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyAdditionalValidationPolicyVerifyClaimArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] audiences: (Updatable) The list of intended recipients for the token.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] issuers: (Updatable) A list of parties that could have issued the token.
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyAdditionalValidationPolicyVerifyClaimArgs']]] verify_claims: (Updatable) A list of claims which should be validated to consider the token valid.
        """
        if audiences is not None:
            pulumi.set(__self__, "audiences", audiences)
        if issuers is not None:
            pulumi.set(__self__, "issuers", issuers)
        if verify_claims is not None:
            pulumi.set(__self__, "verify_claims", verify_claims)

    @_builtins.property
    @pulumi.getter
    def audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The list of intended recipients for the token.
        """
        return pulumi.get(self, "audiences")

    @audiences.setter
    def audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "audiences", value)

    @_builtins.property
    @pulumi.getter
    def issuers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) A list of parties that could have issued the token.
        """
        return pulumi.get(self, "issuers")

    @issuers.setter
    def issuers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "issuers", value)

    @_builtins.property
    @pulumi.getter(name="verifyClaims")
    def verify_claims(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyAdditionalValidationPolicyVerifyClaimArgs']]]]:
        """
        (Updatable) A list of claims which should be validated to consider the token valid.
        """
        return pulumi.get(self, "verify_claims")

    @verify_claims.setter
    def verify_claims(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyAdditionalValidationPolicyVerifyClaimArgs']]]]):
        pulumi.set(self, "verify_claims", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyAdditionalValidationPolicyVerifyClaimArgsDict(TypedDict):
        is_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Whether the claim is required to be present in the JWT or not. If set to "false", the claim values will be matched only if the claim is present in the JWT.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Name of the claim.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The list of acceptable values for a given claim. If this value is "null" or empty and "isRequired" set to "true", then the presence of this claim in the JWT is validated.
        """
elif False:
    DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyAdditionalValidationPolicyVerifyClaimArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyAdditionalValidationPolicyVerifyClaimArgs:
    def __init__(__self__, *,
                 is_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_required: (Updatable) Whether the claim is required to be present in the JWT or not. If set to "false", the claim values will be matched only if the claim is present in the JWT.
        :param pulumi.Input[_builtins.str] key: (Updatable) Name of the claim.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: (Updatable) The list of acceptable values for a given claim. If this value is "null" or empty and "isRequired" set to "true", then the presence of this claim in the JWT is validated.
        """
        if is_required is not None:
            pulumi.set(__self__, "is_required", is_required)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="isRequired")
    def is_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Whether the claim is required to be present in the JWT or not. If set to "false", the claim values will be matched only if the claim is present in the JWT.
        """
        return pulumi.get(self, "is_required")

    @is_required.setter
    def is_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_required", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Name of the claim.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The list of acceptable values for a given claim. If this value is "null" or empty and "isRequired" set to "true", then the presence of this claim in the JWT is validated.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyClientDetailsArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) To specify where the Client App details should be taken from.
        """
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Client ID for the OAuth2/OIDC app.
        """
        client_secret_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Vault Service secret resource.
        """
        client_secret_version_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The version number of the client secret to use.
        """
elif False:
    DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyClientDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyClientDetailsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret_version_number: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: (Updatable) To specify where the Client App details should be taken from.
        :param pulumi.Input[_builtins.str] client_id: (Updatable) Client ID for the OAuth2/OIDC app.
        :param pulumi.Input[_builtins.str] client_secret_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Vault Service secret resource.
        :param pulumi.Input[_builtins.str] client_secret_version_number: (Updatable) The version number of the client secret to use.
        """
        pulumi.set(__self__, "type", type)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret_id is not None:
            pulumi.set(__self__, "client_secret_id", client_secret_id)
        if client_secret_version_number is not None:
            pulumi.set(__self__, "client_secret_version_number", client_secret_version_number)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) To specify where the Client App details should be taken from.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Client ID for the OAuth2/OIDC app.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecretId")
    def client_secret_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Vault Service secret resource.
        """
        return pulumi.get(self, "client_secret_id")

    @client_secret_id.setter
    def client_secret_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecretVersionNumber")
    def client_secret_version_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The version number of the client secret to use.
        """
        return pulumi.get(self, "client_secret_version_number")

    @client_secret_version_number.setter
    def client_secret_version_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret_version_number", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyKeyArgsDict(TypedDict):
        format: pulumi.Input[_builtins.str]
        """
        (Updatable) The format of the public key.
        """
        alg: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The algorithm intended for use with this key.
        """
        e: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The base64 url encoded exponent of the RSA public key represented by this key.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The content of the PEM-encoded public key.
        """
        key_ops: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The operations for which this key is to be used.
        """
        kid: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A unique key ID. This key will be used to verify the signature of a JWT with matching "kid".
        """
        kty: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The key type.
        """
        n: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The base64 url encoded modulus of the RSA public key represented by this key.
        """
        use: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The intended use of the public key.
        """
elif False:
    DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicyKeyArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[_builtins.str],
                 alg: Optional[pulumi.Input[_builtins.str]] = None,
                 e: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 key_ops: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 kid: Optional[pulumi.Input[_builtins.str]] = None,
                 kty: Optional[pulumi.Input[_builtins.str]] = None,
                 n: Optional[pulumi.Input[_builtins.str]] = None,
                 use: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] format: (Updatable) The format of the public key.
        :param pulumi.Input[_builtins.str] alg: (Updatable) The algorithm intended for use with this key.
        :param pulumi.Input[_builtins.str] e: (Updatable) The base64 url encoded exponent of the RSA public key represented by this key.
        :param pulumi.Input[_builtins.str] key: (Updatable) The content of the PEM-encoded public key.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] key_ops: (Updatable) The operations for which this key is to be used.
        :param pulumi.Input[_builtins.str] kid: (Updatable) A unique key ID. This key will be used to verify the signature of a JWT with matching "kid".
        :param pulumi.Input[_builtins.str] kty: (Updatable) The key type.
        :param pulumi.Input[_builtins.str] n: (Updatable) The base64 url encoded modulus of the RSA public key represented by this key.
        :param pulumi.Input[_builtins.str] use: (Updatable) The intended use of the public key.
        """
        pulumi.set(__self__, "format", format)
        if alg is not None:
            pulumi.set(__self__, "alg", alg)
        if e is not None:
            pulumi.set(__self__, "e", e)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if key_ops is not None:
            pulumi.set(__self__, "key_ops", key_ops)
        if kid is not None:
            pulumi.set(__self__, "kid", kid)
        if kty is not None:
            pulumi.set(__self__, "kty", kty)
        if n is not None:
            pulumi.set(__self__, "n", n)
        if use is not None:
            pulumi.set(__self__, "use", use)

    @_builtins.property
    @pulumi.getter
    def format(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The format of the public key.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter
    def alg(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The algorithm intended for use with this key.
        """
        return pulumi.get(self, "alg")

    @alg.setter
    def alg(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alg", value)

    @_builtins.property
    @pulumi.getter
    def e(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The base64 url encoded exponent of the RSA public key represented by this key.
        """
        return pulumi.get(self, "e")

    @e.setter
    def e(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "e", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The content of the PEM-encoded public key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="keyOps")
    def key_ops(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The operations for which this key is to be used.
        """
        return pulumi.get(self, "key_ops")

    @key_ops.setter
    def key_ops(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "key_ops", value)

    @_builtins.property
    @pulumi.getter
    def kid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A unique key ID. This key will be used to verify the signature of a JWT with matching "kid".
        """
        return pulumi.get(self, "kid")

    @kid.setter
    def kid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kid", value)

    @_builtins.property
    @pulumi.getter
    def kty(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The key type.
        """
        return pulumi.get(self, "kty")

    @kty.setter
    def kty(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kty", value)

    @_builtins.property
    @pulumi.getter
    def n(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The base64 url encoded modulus of the RSA public key represented by this key.
        """
        return pulumi.get(self, "n")

    @n.setter
    def n(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "n", value)

    @_builtins.property
    @pulumi.getter
    def use(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The intended use of the public key.
        """
        return pulumi.get(self, "use")

    @use.setter
    def use(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "use", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicySourceUriDetailsArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of the Uri detail.
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The discovery URI for the auth server.
        """
elif False:
    DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicySourceUriDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesAuthenticationValidationPolicySourceUriDetailsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: (Updatable) Type of the Uri detail.
        :param pulumi.Input[_builtins.str] uri: (Updatable) The discovery URI for the auth server.
        """
        pulumi.set(__self__, "type", type)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of the Uri detail.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The discovery URI for the auth server.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesAuthenticationVerifyClaimArgsDict(TypedDict):
        is_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Whether the claim is required to be present in the JWT or not. If set to "false", the claim values will be matched only if the claim is present in the JWT.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Name of the claim.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The list of acceptable values for a given claim. If this value is "null" or empty and "isRequired" set to "true", then the presence of this claim in the JWT is validated.
        """
elif False:
    DeploymentSpecificationRequestPoliciesAuthenticationVerifyClaimArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesAuthenticationVerifyClaimArgs:
    def __init__(__self__, *,
                 is_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_required: (Updatable) Whether the claim is required to be present in the JWT or not. If set to "false", the claim values will be matched only if the claim is present in the JWT.
        :param pulumi.Input[_builtins.str] key: (Updatable) Name of the claim.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: (Updatable) The list of acceptable values for a given claim. If this value is "null" or empty and "isRequired" set to "true", then the presence of this claim in the JWT is validated.
        """
        if is_required is not None:
            pulumi.set(__self__, "is_required", is_required)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="isRequired")
    def is_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Whether the claim is required to be present in the JWT or not. If set to "false", the claim values will be matched only if the claim is present in the JWT.
        """
        return pulumi.get(self, "is_required")

    @is_required.setter
    def is_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_required", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Name of the claim.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The list of acceptable values for a given claim. If this value is "null" or empty and "isRequired" set to "true", then the presence of this claim in the JWT is validated.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesCorsArgsDict(TypedDict):
        allowed_origins: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        (Updatable) The list of allowed origins that the CORS handler will use to respond to CORS requests. The gateway will send the Access-Control-Allow-Origin header with the best origin match for the circumstances. '*' will match any origins, and 'null' will match queries from 'file:' origins. All other origins must be qualified with the scheme, full hostname, and port if necessary.
        """
        allowed_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The list of headers that will be allowed from the client via the Access-Control-Allow-Headers header. '*' will allow all headers.
        """
        allowed_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The list of allowed HTTP methods that will be returned for the preflight OPTIONS request in the Access-Control-Allow-Methods header. '*' will allow all methods.
        """
        exposed_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The list of headers that the client will be allowed to see from the response as indicated by the Access-Control-Expose-Headers header. '*' will expose all headers.
        """
        is_allow_credentials_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Whether to send the Access-Control-Allow-Credentials header to allow CORS requests with cookies.
        """
        max_age_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The time in seconds for the client to cache preflight responses. This is sent as the Access-Control-Max-Age if greater than 0.
        """
elif False:
    DeploymentSpecificationRequestPoliciesCorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesCorsArgs:
    def __init__(__self__, *,
                 allowed_origins: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allowed_methods: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 exposed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 is_allow_credentials_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 max_age_in_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_origins: (Updatable) The list of allowed origins that the CORS handler will use to respond to CORS requests. The gateway will send the Access-Control-Allow-Origin header with the best origin match for the circumstances. '*' will match any origins, and 'null' will match queries from 'file:' origins. All other origins must be qualified with the scheme, full hostname, and port if necessary.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_headers: (Updatable) The list of headers that will be allowed from the client via the Access-Control-Allow-Headers header. '*' will allow all headers.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_methods: (Updatable) The list of allowed HTTP methods that will be returned for the preflight OPTIONS request in the Access-Control-Allow-Methods header. '*' will allow all methods.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exposed_headers: (Updatable) The list of headers that the client will be allowed to see from the response as indicated by the Access-Control-Expose-Headers header. '*' will expose all headers.
        :param pulumi.Input[_builtins.bool] is_allow_credentials_enabled: (Updatable) Whether to send the Access-Control-Allow-Credentials header to allow CORS requests with cookies.
        :param pulumi.Input[_builtins.int] max_age_in_seconds: (Updatable) The time in seconds for the client to cache preflight responses. This is sent as the Access-Control-Max-Age if greater than 0.
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if allowed_methods is not None:
            pulumi.set(__self__, "allowed_methods", allowed_methods)
        if exposed_headers is not None:
            pulumi.set(__self__, "exposed_headers", exposed_headers)
        if is_allow_credentials_enabled is not None:
            pulumi.set(__self__, "is_allow_credentials_enabled", is_allow_credentials_enabled)
        if max_age_in_seconds is not None:
            pulumi.set(__self__, "max_age_in_seconds", max_age_in_seconds)

    @_builtins.property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        (Updatable) The list of allowed origins that the CORS handler will use to respond to CORS requests. The gateway will send the Access-Control-Allow-Origin header with the best origin match for the circumstances. '*' will match any origins, and 'null' will match queries from 'file:' origins. All other origins must be qualified with the scheme, full hostname, and port if necessary.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "allowed_origins", value)

    @_builtins.property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The list of headers that will be allowed from the client via the Access-Control-Allow-Headers header. '*' will allow all headers.
        """
        return pulumi.get(self, "allowed_headers")

    @allowed_headers.setter
    def allowed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_headers", value)

    @_builtins.property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The list of allowed HTTP methods that will be returned for the preflight OPTIONS request in the Access-Control-Allow-Methods header. '*' will allow all methods.
        """
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_methods", value)

    @_builtins.property
    @pulumi.getter(name="exposedHeaders")
    def exposed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The list of headers that the client will be allowed to see from the response as indicated by the Access-Control-Expose-Headers header. '*' will expose all headers.
        """
        return pulumi.get(self, "exposed_headers")

    @exposed_headers.setter
    def exposed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exposed_headers", value)

    @_builtins.property
    @pulumi.getter(name="isAllowCredentialsEnabled")
    def is_allow_credentials_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Whether to send the Access-Control-Allow-Credentials header to allow CORS requests with cookies.
        """
        return pulumi.get(self, "is_allow_credentials_enabled")

    @is_allow_credentials_enabled.setter
    def is_allow_credentials_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_allow_credentials_enabled", value)

    @_builtins.property
    @pulumi.getter(name="maxAgeInSeconds")
    def max_age_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The time in seconds for the client to cache preflight responses. This is sent as the Access-Control-Max-Age if greater than 0.
        """
        return pulumi.get(self, "max_age_in_seconds")

    @max_age_in_seconds.setter
    def max_age_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_age_in_seconds", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesDynamicAuthenticationArgsDict(TypedDict):
        authentication_servers: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerArgsDict']]]
        """
        (Updatable) List of authentication servers to choose from during dynamic authentication.
        """
        selection_source: pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationSelectionSourceArgsDict']
        """
        (Updatable) The type of selector to use when dynamically routing and dynamically authenticating requests.
        """
elif False:
    DeploymentSpecificationRequestPoliciesDynamicAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesDynamicAuthenticationArgs:
    def __init__(__self__, *,
                 authentication_servers: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerArgs']]],
                 selection_source: pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationSelectionSourceArgs']):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerArgs']]] authentication_servers: (Updatable) List of authentication servers to choose from during dynamic authentication.
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationSelectionSourceArgs'] selection_source: (Updatable) The type of selector to use when dynamically routing and dynamically authenticating requests.
        """
        pulumi.set(__self__, "authentication_servers", authentication_servers)
        pulumi.set(__self__, "selection_source", selection_source)

    @_builtins.property
    @pulumi.getter(name="authenticationServers")
    def authentication_servers(self) -> pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerArgs']]]:
        """
        (Updatable) List of authentication servers to choose from during dynamic authentication.
        """
        return pulumi.get(self, "authentication_servers")

    @authentication_servers.setter
    def authentication_servers(self, value: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerArgs']]]):
        pulumi.set(self, "authentication_servers", value)

    @_builtins.property
    @pulumi.getter(name="selectionSource")
    def selection_source(self) -> pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationSelectionSourceArgs']:
        """
        (Updatable) The type of selector to use when dynamically routing and dynamically authenticating requests.
        """
        return pulumi.get(self, "selection_source")

    @selection_source.setter
    def selection_source(self, value: pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationSelectionSourceArgs']):
        pulumi.set(self, "selection_source", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerArgsDict(TypedDict):
        authentication_server_detail: pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailArgsDict']
        """
        (Updatable) Information on how to authenticate incoming requests.
        """
        key: pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerKeyArgsDict']
        """
        (Updatable) Base policy for defining how to match the context variable in an incoming request with selection keys when dynamically routing and dynamically authenticating requests.
        """
elif False:
    DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerArgs:
    def __init__(__self__, *,
                 authentication_server_detail: pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailArgs'],
                 key: pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerKeyArgs']):
        """
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailArgs'] authentication_server_detail: (Updatable) Information on how to authenticate incoming requests.
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerKeyArgs'] key: (Updatable) Base policy for defining how to match the context variable in an incoming request with selection keys when dynamically routing and dynamically authenticating requests.
        """
        pulumi.set(__self__, "authentication_server_detail", authentication_server_detail)
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter(name="authenticationServerDetail")
    def authentication_server_detail(self) -> pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailArgs']:
        """
        (Updatable) Information on how to authenticate incoming requests.
        """
        return pulumi.get(self, "authentication_server_detail")

    @authentication_server_detail.setter
    def authentication_server_detail(self, value: pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailArgs']):
        pulumi.set(self, "authentication_server_detail", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerKeyArgs']:
        """
        (Updatable) Base policy for defining how to match the context variable in an incoming request with selection keys when dynamically routing and dynamically authenticating requests.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerKeyArgs']):
        pulumi.set(self, "key", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of the authentication policy to use.
        """
        audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The list of intended recipients for the token.
        """
        cache_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of keys from "parameters" attribute value whose values will be added to the cache key.
        """
        function_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Functions function resource.
        """
        is_anonymous_access_allowed: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Whether an unauthenticated user may access the API. Must be "true" to enable ANONYMOUS route authorization.
        """
        issuers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) A list of parties that could have issued the token.
        """
        max_clock_skew_in_seconds: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Updatable) The maximum expected time difference between the system clocks of the token issuer and the API Gateway.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        (Updatable) A map where key is a user defined string and value is a context expressions whose values will be sent to the custom auth function. Values should contain an expression. Example: `{"foo": "request.header[abc]"}`
        """
        public_keys: NotRequired[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailPublicKeysArgsDict']]
        """
        (Updatable) A set of Public Keys that will be used to verify the JWT signature.
        """
        token_auth_scheme: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The authentication scheme that is to be used when authenticating the token. This must to be provided if "tokenHeader" is specified.
        """
        token_header: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the header containing the authentication token.
        """
        token_query_param: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the query parameter containing the authentication token.
        """
        validation_failure_policy: NotRequired[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyArgsDict']]
        """
        (Updatable) Policy for defining behaviour on validation failure.
        """
        validation_policy: NotRequired[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyArgsDict']]
        """
        (Updatable) Authentication Policies for the Token Authentication types.
        """
        verify_claims: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailVerifyClaimArgsDict']]]]
        """
        (Updatable) A list of claims which should be validated to consider the token valid.
        """
elif False:
    DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 audiences: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 cache_keys: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 function_id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_anonymous_access_allowed: Optional[pulumi.Input[_builtins.bool]] = None,
                 issuers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 max_clock_skew_in_seconds: Optional[pulumi.Input[_builtins.float]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 public_keys: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailPublicKeysArgs']] = None,
                 token_auth_scheme: Optional[pulumi.Input[_builtins.str]] = None,
                 token_header: Optional[pulumi.Input[_builtins.str]] = None,
                 token_query_param: Optional[pulumi.Input[_builtins.str]] = None,
                 validation_failure_policy: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyArgs']] = None,
                 validation_policy: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyArgs']] = None,
                 verify_claims: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailVerifyClaimArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] type: (Updatable) Type of the authentication policy to use.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] audiences: (Updatable) The list of intended recipients for the token.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] cache_keys: A list of keys from "parameters" attribute value whose values will be added to the cache key.
        :param pulumi.Input[_builtins.str] function_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Functions function resource.
        :param pulumi.Input[_builtins.bool] is_anonymous_access_allowed: (Updatable) Whether an unauthenticated user may access the API. Must be "true" to enable ANONYMOUS route authorization.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] issuers: (Updatable) A list of parties that could have issued the token.
        :param pulumi.Input[_builtins.float] max_clock_skew_in_seconds: (Updatable) The maximum expected time difference between the system clocks of the token issuer and the API Gateway.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] parameters: (Updatable) A map where key is a user defined string and value is a context expressions whose values will be sent to the custom auth function. Values should contain an expression. Example: `{"foo": "request.header[abc]"}`
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailPublicKeysArgs'] public_keys: (Updatable) A set of Public Keys that will be used to verify the JWT signature.
        :param pulumi.Input[_builtins.str] token_auth_scheme: (Updatable) The authentication scheme that is to be used when authenticating the token. This must to be provided if "tokenHeader" is specified.
        :param pulumi.Input[_builtins.str] token_header: (Updatable) The name of the header containing the authentication token.
        :param pulumi.Input[_builtins.str] token_query_param: (Updatable) The name of the query parameter containing the authentication token.
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyArgs'] validation_failure_policy: (Updatable) Policy for defining behaviour on validation failure.
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyArgs'] validation_policy: (Updatable) Authentication Policies for the Token Authentication types.
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailVerifyClaimArgs']]] verify_claims: (Updatable) A list of claims which should be validated to consider the token valid.
        """
        pulumi.set(__self__, "type", type)
        if audiences is not None:
            pulumi.set(__self__, "audiences", audiences)
        if cache_keys is not None:
            pulumi.set(__self__, "cache_keys", cache_keys)
        if function_id is not None:
            pulumi.set(__self__, "function_id", function_id)
        if is_anonymous_access_allowed is not None:
            pulumi.set(__self__, "is_anonymous_access_allowed", is_anonymous_access_allowed)
        if issuers is not None:
            pulumi.set(__self__, "issuers", issuers)
        if max_clock_skew_in_seconds is not None:
            pulumi.set(__self__, "max_clock_skew_in_seconds", max_clock_skew_in_seconds)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if public_keys is not None:
            pulumi.set(__self__, "public_keys", public_keys)
        if token_auth_scheme is not None:
            pulumi.set(__self__, "token_auth_scheme", token_auth_scheme)
        if token_header is not None:
            pulumi.set(__self__, "token_header", token_header)
        if token_query_param is not None:
            pulumi.set(__self__, "token_query_param", token_query_param)
        if validation_failure_policy is not None:
            pulumi.set(__self__, "validation_failure_policy", validation_failure_policy)
        if validation_policy is not None:
            pulumi.set(__self__, "validation_policy", validation_policy)
        if verify_claims is not None:
            pulumi.set(__self__, "verify_claims", verify_claims)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of the authentication policy to use.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The list of intended recipients for the token.
        """
        return pulumi.get(self, "audiences")

    @audiences.setter
    def audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "audiences", value)

    @_builtins.property
    @pulumi.getter(name="cacheKeys")
    def cache_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of keys from "parameters" attribute value whose values will be added to the cache key.
        """
        return pulumi.get(self, "cache_keys")

    @cache_keys.setter
    def cache_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "cache_keys", value)

    @_builtins.property
    @pulumi.getter(name="functionId")
    def function_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Functions function resource.
        """
        return pulumi.get(self, "function_id")

    @function_id.setter
    def function_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "function_id", value)

    @_builtins.property
    @pulumi.getter(name="isAnonymousAccessAllowed")
    def is_anonymous_access_allowed(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Whether an unauthenticated user may access the API. Must be "true" to enable ANONYMOUS route authorization.
        """
        return pulumi.get(self, "is_anonymous_access_allowed")

    @is_anonymous_access_allowed.setter
    def is_anonymous_access_allowed(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_anonymous_access_allowed", value)

    @_builtins.property
    @pulumi.getter
    def issuers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) A list of parties that could have issued the token.
        """
        return pulumi.get(self, "issuers")

    @issuers.setter
    def issuers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "issuers", value)

    @_builtins.property
    @pulumi.getter(name="maxClockSkewInSeconds")
    def max_clock_skew_in_seconds(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Updatable) The maximum expected time difference between the system clocks of the token issuer and the API Gateway.
        """
        return pulumi.get(self, "max_clock_skew_in_seconds")

    @max_clock_skew_in_seconds.setter
    def max_clock_skew_in_seconds(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max_clock_skew_in_seconds", value)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) A map where key is a user defined string and value is a context expressions whose values will be sent to the custom auth function. Values should contain an expression. Example: `{"foo": "request.header[abc]"}`
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "parameters", value)

    @_builtins.property
    @pulumi.getter(name="publicKeys")
    def public_keys(self) -> Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailPublicKeysArgs']]:
        """
        (Updatable) A set of Public Keys that will be used to verify the JWT signature.
        """
        return pulumi.get(self, "public_keys")

    @public_keys.setter
    def public_keys(self, value: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailPublicKeysArgs']]):
        pulumi.set(self, "public_keys", value)

    @_builtins.property
    @pulumi.getter(name="tokenAuthScheme")
    def token_auth_scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The authentication scheme that is to be used when authenticating the token. This must to be provided if "tokenHeader" is specified.
        """
        return pulumi.get(self, "token_auth_scheme")

    @token_auth_scheme.setter
    def token_auth_scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token_auth_scheme", value)

    @_builtins.property
    @pulumi.getter(name="tokenHeader")
    def token_header(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the header containing the authentication token.
        """
        return pulumi.get(self, "token_header")

    @token_header.setter
    def token_header(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token_header", value)

    @_builtins.property
    @pulumi.getter(name="tokenQueryParam")
    def token_query_param(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the query parameter containing the authentication token.
        """
        return pulumi.get(self, "token_query_param")

    @token_query_param.setter
    def token_query_param(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token_query_param", value)

    @_builtins.property
    @pulumi.getter(name="validationFailurePolicy")
    def validation_failure_policy(self) -> Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyArgs']]:
        """
        (Updatable) Policy for defining behaviour on validation failure.
        """
        return pulumi.get(self, "validation_failure_policy")

    @validation_failure_policy.setter
    def validation_failure_policy(self, value: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyArgs']]):
        pulumi.set(self, "validation_failure_policy", value)

    @_builtins.property
    @pulumi.getter(name="validationPolicy")
    def validation_policy(self) -> Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyArgs']]:
        """
        (Updatable) Authentication Policies for the Token Authentication types.
        """
        return pulumi.get(self, "validation_policy")

    @validation_policy.setter
    def validation_policy(self, value: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyArgs']]):
        pulumi.set(self, "validation_policy", value)

    @_builtins.property
    @pulumi.getter(name="verifyClaims")
    def verify_claims(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailVerifyClaimArgs']]]]:
        """
        (Updatable) A list of claims which should be validated to consider the token valid.
        """
        return pulumi.get(self, "verify_claims")

    @verify_claims.setter
    def verify_claims(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailVerifyClaimArgs']]]]):
        pulumi.set(self, "verify_claims", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailPublicKeysArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of the public key set.
        """
        is_ssl_verify_disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Defines whether or not to uphold SSL verification.
        """
        keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailPublicKeysKeyArgsDict']]]]
        """
        (Updatable) The set of static public keys.
        """
        max_cache_duration_in_hours: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The duration for which the JWKS should be cached before it is fetched again.
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The uri from which to retrieve the key. It must be accessible without authentication.
        """
elif False:
    DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailPublicKeysArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailPublicKeysArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 is_ssl_verify_disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 keys: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailPublicKeysKeyArgs']]]] = None,
                 max_cache_duration_in_hours: Optional[pulumi.Input[_builtins.int]] = None,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: (Updatable) Type of the public key set.
        :param pulumi.Input[_builtins.bool] is_ssl_verify_disabled: (Updatable) Defines whether or not to uphold SSL verification.
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailPublicKeysKeyArgs']]] keys: (Updatable) The set of static public keys.
        :param pulumi.Input[_builtins.int] max_cache_duration_in_hours: (Updatable) The duration for which the JWKS should be cached before it is fetched again.
        :param pulumi.Input[_builtins.str] uri: (Updatable) The uri from which to retrieve the key. It must be accessible without authentication.
        """
        pulumi.set(__self__, "type", type)
        if is_ssl_verify_disabled is not None:
            pulumi.set(__self__, "is_ssl_verify_disabled", is_ssl_verify_disabled)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if max_cache_duration_in_hours is not None:
            pulumi.set(__self__, "max_cache_duration_in_hours", max_cache_duration_in_hours)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of the public key set.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="isSslVerifyDisabled")
    def is_ssl_verify_disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Defines whether or not to uphold SSL verification.
        """
        return pulumi.get(self, "is_ssl_verify_disabled")

    @is_ssl_verify_disabled.setter
    def is_ssl_verify_disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_ssl_verify_disabled", value)

    @_builtins.property
    @pulumi.getter
    def keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailPublicKeysKeyArgs']]]]:
        """
        (Updatable) The set of static public keys.
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailPublicKeysKeyArgs']]]]):
        pulumi.set(self, "keys", value)

    @_builtins.property
    @pulumi.getter(name="maxCacheDurationInHours")
    def max_cache_duration_in_hours(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The duration for which the JWKS should be cached before it is fetched again.
        """
        return pulumi.get(self, "max_cache_duration_in_hours")

    @max_cache_duration_in_hours.setter
    def max_cache_duration_in_hours(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_cache_duration_in_hours", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The uri from which to retrieve the key. It must be accessible without authentication.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailPublicKeysKeyArgsDict(TypedDict):
        format: pulumi.Input[_builtins.str]
        """
        (Updatable) The format of the public key.
        """
        alg: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The algorithm intended for use with this key.
        """
        e: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The base64 url encoded exponent of the RSA public key represented by this key.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The content of the PEM-encoded public key.
        """
        key_ops: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The operations for which this key is to be used.
        """
        kid: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A unique key ID. This key will be used to verify the signature of a JWT with matching "kid".
        """
        kty: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The key type.
        """
        n: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The base64 url encoded modulus of the RSA public key represented by this key.
        """
        use: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The intended use of the public key.
        """
elif False:
    DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailPublicKeysKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailPublicKeysKeyArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[_builtins.str],
                 alg: Optional[pulumi.Input[_builtins.str]] = None,
                 e: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 key_ops: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 kid: Optional[pulumi.Input[_builtins.str]] = None,
                 kty: Optional[pulumi.Input[_builtins.str]] = None,
                 n: Optional[pulumi.Input[_builtins.str]] = None,
                 use: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] format: (Updatable) The format of the public key.
        :param pulumi.Input[_builtins.str] alg: (Updatable) The algorithm intended for use with this key.
        :param pulumi.Input[_builtins.str] e: (Updatable) The base64 url encoded exponent of the RSA public key represented by this key.
        :param pulumi.Input[_builtins.str] key: (Updatable) The content of the PEM-encoded public key.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] key_ops: (Updatable) The operations for which this key is to be used.
        :param pulumi.Input[_builtins.str] kid: (Updatable) A unique key ID. This key will be used to verify the signature of a JWT with matching "kid".
        :param pulumi.Input[_builtins.str] kty: (Updatable) The key type.
        :param pulumi.Input[_builtins.str] n: (Updatable) The base64 url encoded modulus of the RSA public key represented by this key.
        :param pulumi.Input[_builtins.str] use: (Updatable) The intended use of the public key.
        """
        pulumi.set(__self__, "format", format)
        if alg is not None:
            pulumi.set(__self__, "alg", alg)
        if e is not None:
            pulumi.set(__self__, "e", e)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if key_ops is not None:
            pulumi.set(__self__, "key_ops", key_ops)
        if kid is not None:
            pulumi.set(__self__, "kid", kid)
        if kty is not None:
            pulumi.set(__self__, "kty", kty)
        if n is not None:
            pulumi.set(__self__, "n", n)
        if use is not None:
            pulumi.set(__self__, "use", use)

    @_builtins.property
    @pulumi.getter
    def format(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The format of the public key.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter
    def alg(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The algorithm intended for use with this key.
        """
        return pulumi.get(self, "alg")

    @alg.setter
    def alg(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alg", value)

    @_builtins.property
    @pulumi.getter
    def e(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The base64 url encoded exponent of the RSA public key represented by this key.
        """
        return pulumi.get(self, "e")

    @e.setter
    def e(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "e", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The content of the PEM-encoded public key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="keyOps")
    def key_ops(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The operations for which this key is to be used.
        """
        return pulumi.get(self, "key_ops")

    @key_ops.setter
    def key_ops(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "key_ops", value)

    @_builtins.property
    @pulumi.getter
    def kid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A unique key ID. This key will be used to verify the signature of a JWT with matching "kid".
        """
        return pulumi.get(self, "kid")

    @kid.setter
    def kid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kid", value)

    @_builtins.property
    @pulumi.getter
    def kty(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The key type.
        """
        return pulumi.get(self, "kty")

    @kty.setter
    def kty(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kty", value)

    @_builtins.property
    @pulumi.getter
    def n(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The base64 url encoded modulus of the RSA public key represented by this key.
        """
        return pulumi.get(self, "n")

    @n.setter
    def n(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "n", value)

    @_builtins.property
    @pulumi.getter
    def use(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The intended use of the public key.
        """
        return pulumi.get(self, "use")

    @use.setter
    def use(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "use", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of the Validation failure Policy.
        """
        client_details: NotRequired[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyClientDetailsArgsDict']]
        """
        (Updatable) Client App Credential details.
        """
        fallback_redirect_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The path to be used as fallback after OAuth2.
        """
        logout_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The path to be used as logout.
        """
        max_expiry_duration_in_hours: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The duration for which the OAuth2 success token should be cached before it is fetched again.
        """
        response_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) HTTP response code, can include context variables.
        """
        response_header_transformations: NotRequired[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsArgsDict']]
        """
        (Updatable) A set of transformations to apply to HTTP headers that pass through the gateway.
        """
        response_message: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) HTTP response message.
        """
        response_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Response Type.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) List of scopes.
        """
        source_uri_details: NotRequired[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicySourceUriDetailsArgsDict']]
        """
        (Updatable) Auth endpoint details.
        """
        use_cookies_for_intermediate_steps: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Defines whether or not to use cookies for OAuth2 intermediate steps.
        """
        use_cookies_for_session: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Defines whether or not to use cookies for session maintenance.
        """
        use_pkce: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Defines whether or not to support PKCE.
        """
elif False:
    DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 client_details: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyClientDetailsArgs']] = None,
                 fallback_redirect_path: Optional[pulumi.Input[_builtins.str]] = None,
                 logout_path: Optional[pulumi.Input[_builtins.str]] = None,
                 max_expiry_duration_in_hours: Optional[pulumi.Input[_builtins.int]] = None,
                 response_code: Optional[pulumi.Input[_builtins.str]] = None,
                 response_header_transformations: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsArgs']] = None,
                 response_message: Optional[pulumi.Input[_builtins.str]] = None,
                 response_type: Optional[pulumi.Input[_builtins.str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 source_uri_details: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicySourceUriDetailsArgs']] = None,
                 use_cookies_for_intermediate_steps: Optional[pulumi.Input[_builtins.bool]] = None,
                 use_cookies_for_session: Optional[pulumi.Input[_builtins.bool]] = None,
                 use_pkce: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] type: (Updatable) Type of the Validation failure Policy.
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyClientDetailsArgs'] client_details: (Updatable) Client App Credential details.
        :param pulumi.Input[_builtins.str] fallback_redirect_path: (Updatable) The path to be used as fallback after OAuth2.
        :param pulumi.Input[_builtins.str] logout_path: (Updatable) The path to be used as logout.
        :param pulumi.Input[_builtins.int] max_expiry_duration_in_hours: (Updatable) The duration for which the OAuth2 success token should be cached before it is fetched again.
        :param pulumi.Input[_builtins.str] response_code: (Updatable) HTTP response code, can include context variables.
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsArgs'] response_header_transformations: (Updatable) A set of transformations to apply to HTTP headers that pass through the gateway.
        :param pulumi.Input[_builtins.str] response_message: (Updatable) HTTP response message.
        :param pulumi.Input[_builtins.str] response_type: (Updatable) Response Type.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: (Updatable) List of scopes.
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicySourceUriDetailsArgs'] source_uri_details: (Updatable) Auth endpoint details.
        :param pulumi.Input[_builtins.bool] use_cookies_for_intermediate_steps: (Updatable) Defines whether or not to use cookies for OAuth2 intermediate steps.
        :param pulumi.Input[_builtins.bool] use_cookies_for_session: (Updatable) Defines whether or not to use cookies for session maintenance.
        :param pulumi.Input[_builtins.bool] use_pkce: (Updatable) Defines whether or not to support PKCE.
        """
        pulumi.set(__self__, "type", type)
        if client_details is not None:
            pulumi.set(__self__, "client_details", client_details)
        if fallback_redirect_path is not None:
            pulumi.set(__self__, "fallback_redirect_path", fallback_redirect_path)
        if logout_path is not None:
            pulumi.set(__self__, "logout_path", logout_path)
        if max_expiry_duration_in_hours is not None:
            pulumi.set(__self__, "max_expiry_duration_in_hours", max_expiry_duration_in_hours)
        if response_code is not None:
            pulumi.set(__self__, "response_code", response_code)
        if response_header_transformations is not None:
            pulumi.set(__self__, "response_header_transformations", response_header_transformations)
        if response_message is not None:
            pulumi.set(__self__, "response_message", response_message)
        if response_type is not None:
            pulumi.set(__self__, "response_type", response_type)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if source_uri_details is not None:
            pulumi.set(__self__, "source_uri_details", source_uri_details)
        if use_cookies_for_intermediate_steps is not None:
            pulumi.set(__self__, "use_cookies_for_intermediate_steps", use_cookies_for_intermediate_steps)
        if use_cookies_for_session is not None:
            pulumi.set(__self__, "use_cookies_for_session", use_cookies_for_session)
        if use_pkce is not None:
            pulumi.set(__self__, "use_pkce", use_pkce)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of the Validation failure Policy.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="clientDetails")
    def client_details(self) -> Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyClientDetailsArgs']]:
        """
        (Updatable) Client App Credential details.
        """
        return pulumi.get(self, "client_details")

    @client_details.setter
    def client_details(self, value: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyClientDetailsArgs']]):
        pulumi.set(self, "client_details", value)

    @_builtins.property
    @pulumi.getter(name="fallbackRedirectPath")
    def fallback_redirect_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The path to be used as fallback after OAuth2.
        """
        return pulumi.get(self, "fallback_redirect_path")

    @fallback_redirect_path.setter
    def fallback_redirect_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_redirect_path", value)

    @_builtins.property
    @pulumi.getter(name="logoutPath")
    def logout_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The path to be used as logout.
        """
        return pulumi.get(self, "logout_path")

    @logout_path.setter
    def logout_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logout_path", value)

    @_builtins.property
    @pulumi.getter(name="maxExpiryDurationInHours")
    def max_expiry_duration_in_hours(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The duration for which the OAuth2 success token should be cached before it is fetched again.
        """
        return pulumi.get(self, "max_expiry_duration_in_hours")

    @max_expiry_duration_in_hours.setter
    def max_expiry_duration_in_hours(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_expiry_duration_in_hours", value)

    @_builtins.property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) HTTP response code, can include context variables.
        """
        return pulumi.get(self, "response_code")

    @response_code.setter
    def response_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_code", value)

    @_builtins.property
    @pulumi.getter(name="responseHeaderTransformations")
    def response_header_transformations(self) -> Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsArgs']]:
        """
        (Updatable) A set of transformations to apply to HTTP headers that pass through the gateway.
        """
        return pulumi.get(self, "response_header_transformations")

    @response_header_transformations.setter
    def response_header_transformations(self, value: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsArgs']]):
        pulumi.set(self, "response_header_transformations", value)

    @_builtins.property
    @pulumi.getter(name="responseMessage")
    def response_message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) HTTP response message.
        """
        return pulumi.get(self, "response_message")

    @response_message.setter
    def response_message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_message", value)

    @_builtins.property
    @pulumi.getter(name="responseType")
    def response_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Response Type.
        """
        return pulumi.get(self, "response_type")

    @response_type.setter
    def response_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_type", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) List of scopes.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter(name="sourceUriDetails")
    def source_uri_details(self) -> Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicySourceUriDetailsArgs']]:
        """
        (Updatable) Auth endpoint details.
        """
        return pulumi.get(self, "source_uri_details")

    @source_uri_details.setter
    def source_uri_details(self, value: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicySourceUriDetailsArgs']]):
        pulumi.set(self, "source_uri_details", value)

    @_builtins.property
    @pulumi.getter(name="useCookiesForIntermediateSteps")
    def use_cookies_for_intermediate_steps(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Defines whether or not to use cookies for OAuth2 intermediate steps.
        """
        return pulumi.get(self, "use_cookies_for_intermediate_steps")

    @use_cookies_for_intermediate_steps.setter
    def use_cookies_for_intermediate_steps(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_cookies_for_intermediate_steps", value)

    @_builtins.property
    @pulumi.getter(name="useCookiesForSession")
    def use_cookies_for_session(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Defines whether or not to use cookies for session maintenance.
        """
        return pulumi.get(self, "use_cookies_for_session")

    @use_cookies_for_session.setter
    def use_cookies_for_session(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_cookies_for_session", value)

    @_builtins.property
    @pulumi.getter(name="usePkce")
    def use_pkce(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Defines whether or not to support PKCE.
        """
        return pulumi.get(self, "use_pkce")

    @use_pkce.setter
    def use_pkce(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_pkce", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyClientDetailsArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) To specify where the Client App details should be taken from.
        """
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Client ID for the OAuth2/OIDC app.
        """
        client_secret_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Vault Service secret resource.
        """
        client_secret_version_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The version number of the client secret to use.
        """
elif False:
    DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyClientDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyClientDetailsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret_version_number: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: (Updatable) To specify where the Client App details should be taken from.
        :param pulumi.Input[_builtins.str] client_id: (Updatable) Client ID for the OAuth2/OIDC app.
        :param pulumi.Input[_builtins.str] client_secret_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Vault Service secret resource.
        :param pulumi.Input[_builtins.str] client_secret_version_number: (Updatable) The version number of the client secret to use.
        """
        pulumi.set(__self__, "type", type)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret_id is not None:
            pulumi.set(__self__, "client_secret_id", client_secret_id)
        if client_secret_version_number is not None:
            pulumi.set(__self__, "client_secret_version_number", client_secret_version_number)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) To specify where the Client App details should be taken from.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Client ID for the OAuth2/OIDC app.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecretId")
    def client_secret_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Vault Service secret resource.
        """
        return pulumi.get(self, "client_secret_id")

    @client_secret_id.setter
    def client_secret_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecretVersionNumber")
    def client_secret_version_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The version number of the client secret to use.
        """
        return pulumi.get(self, "client_secret_version_number")

    @client_secret_version_number.setter
    def client_secret_version_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret_version_number", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsArgsDict(TypedDict):
        filter_headers: NotRequired[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsFilterHeadersArgsDict']]
        """
        (Updatable) Filter HTTP headers as they pass through the gateway.  The gateway applies filters after other transformations, so any headers set or renamed must also be listed here when using an ALLOW type policy.
        """
        rename_headers: NotRequired[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsRenameHeadersArgsDict']]
        """
        (Updatable) Rename HTTP headers as they pass through the gateway.
        """
        set_headers: NotRequired[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsSetHeadersArgsDict']]
        """
        (Updatable) Set HTTP headers as they pass through the gateway.
        """
elif False:
    DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsArgs:
    def __init__(__self__, *,
                 filter_headers: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsFilterHeadersArgs']] = None,
                 rename_headers: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsRenameHeadersArgs']] = None,
                 set_headers: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsSetHeadersArgs']] = None):
        """
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsFilterHeadersArgs'] filter_headers: (Updatable) Filter HTTP headers as they pass through the gateway.  The gateway applies filters after other transformations, so any headers set or renamed must also be listed here when using an ALLOW type policy.
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsRenameHeadersArgs'] rename_headers: (Updatable) Rename HTTP headers as they pass through the gateway.
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsSetHeadersArgs'] set_headers: (Updatable) Set HTTP headers as they pass through the gateway.
        """
        if filter_headers is not None:
            pulumi.set(__self__, "filter_headers", filter_headers)
        if rename_headers is not None:
            pulumi.set(__self__, "rename_headers", rename_headers)
        if set_headers is not None:
            pulumi.set(__self__, "set_headers", set_headers)

    @_builtins.property
    @pulumi.getter(name="filterHeaders")
    def filter_headers(self) -> Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsFilterHeadersArgs']]:
        """
        (Updatable) Filter HTTP headers as they pass through the gateway.  The gateway applies filters after other transformations, so any headers set or renamed must also be listed here when using an ALLOW type policy.
        """
        return pulumi.get(self, "filter_headers")

    @filter_headers.setter
    def filter_headers(self, value: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsFilterHeadersArgs']]):
        pulumi.set(self, "filter_headers", value)

    @_builtins.property
    @pulumi.getter(name="renameHeaders")
    def rename_headers(self) -> Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsRenameHeadersArgs']]:
        """
        (Updatable) Rename HTTP headers as they pass through the gateway.
        """
        return pulumi.get(self, "rename_headers")

    @rename_headers.setter
    def rename_headers(self, value: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsRenameHeadersArgs']]):
        pulumi.set(self, "rename_headers", value)

    @_builtins.property
    @pulumi.getter(name="setHeaders")
    def set_headers(self) -> Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsSetHeadersArgs']]:
        """
        (Updatable) Set HTTP headers as they pass through the gateway.
        """
        return pulumi.get(self, "set_headers")

    @set_headers.setter
    def set_headers(self, value: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsSetHeadersArgs']]):
        pulumi.set(self, "set_headers", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsFilterHeadersArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsFilterHeadersItemArgsDict']]]]
        """
        (Updatable) The list of headers.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) BLOCK drops any headers that are in the list of items, so it acts as an exclusion list.  ALLOW permits only the headers in the list and removes all others, so it acts as an inclusion list.
        """
elif False:
    DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsFilterHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsFilterHeadersArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsFilterHeadersItemArgs']]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsFilterHeadersItemArgs']]] items: (Updatable) The list of headers.
        :param pulumi.Input[_builtins.str] type: (Updatable) BLOCK drops any headers that are in the list of items, so it acts as an exclusion list.  ALLOW permits only the headers in the list and removes all others, so it acts as an inclusion list.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsFilterHeadersItemArgs']]]]:
        """
        (Updatable) The list of headers.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsFilterHeadersItemArgs']]]]):
        pulumi.set(self, "items", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) BLOCK drops any headers that are in the list of items, so it acts as an exclusion list.  ALLOW permits only the headers in the list and removes all others, so it acts as an inclusion list.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsFilterHeadersItemArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
elif False:
    DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsFilterHeadersItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsFilterHeadersItemArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsRenameHeadersArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsRenameHeadersItemArgsDict']]]]
        """
        (Updatable) The list of headers.
        """
elif False:
    DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsRenameHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsRenameHeadersArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsRenameHeadersItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsRenameHeadersItemArgs']]] items: (Updatable) The list of headers.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsRenameHeadersItemArgs']]]]:
        """
        (Updatable) The list of headers.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsRenameHeadersItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsRenameHeadersItemArgsDict(TypedDict):
        from_: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The original case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        to: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The new name of the header.  This name must be unique across transformation policies.
        """
elif False:
    DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsRenameHeadersItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsRenameHeadersItemArgs:
    def __init__(__self__, *,
                 from_: Optional[pulumi.Input[_builtins.str]] = None,
                 to: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] from_: (Updatable) The original case-insensitive name of the header.  This name must be unique across transformation policies.
        :param pulumi.Input[_builtins.str] to: (Updatable) The new name of the header.  This name must be unique across transformation policies.
        """
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The original case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The new name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsSetHeadersArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsSetHeadersItemArgsDict']]]]
        """
        (Updatable) The list of headers.
        """
elif False:
    DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsSetHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsSetHeadersArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsSetHeadersItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsSetHeadersItemArgs']]] items: (Updatable) The list of headers.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsSetHeadersItemArgs']]]]:
        """
        (Updatable) The list of headers.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsSetHeadersItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsSetHeadersItemArgsDict(TypedDict):
        if_exists: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) If a header with the same name already exists in the request, OVERWRITE will overwrite the value, APPEND will append to the existing value, or SKIP will keep the existing value.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) A list of new values.  Each value can be a constant or may include one or more expressions enclosed within ${} delimiters.
        """
elif False:
    DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsSetHeadersItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicyResponseHeaderTransformationsSetHeadersItemArgs:
    def __init__(__self__, *,
                 if_exists: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] if_exists: (Updatable) If a header with the same name already exists in the request, OVERWRITE will overwrite the value, APPEND will append to the existing value, or SKIP will keep the existing value.
        :param pulumi.Input[_builtins.str] name: (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: (Updatable) A list of new values.  Each value can be a constant or may include one or more expressions enclosed within ${} delimiters.
        """
        if if_exists is not None:
            pulumi.set(__self__, "if_exists", if_exists)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="ifExists")
    def if_exists(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) If a header with the same name already exists in the request, OVERWRITE will overwrite the value, APPEND will append to the existing value, or SKIP will keep the existing value.
        """
        return pulumi.get(self, "if_exists")

    @if_exists.setter
    def if_exists(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "if_exists", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) A list of new values.  Each value can be a constant or may include one or more expressions enclosed within ${} delimiters.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicySourceUriDetailsArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of the Uri detail.
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The discovery URI for the auth server.
        """
elif False:
    DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicySourceUriDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationFailurePolicySourceUriDetailsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: (Updatable) Type of the Uri detail.
        :param pulumi.Input[_builtins.str] uri: (Updatable) The discovery URI for the auth server.
        """
        pulumi.set(__self__, "type", type)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of the Uri detail.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The discovery URI for the auth server.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of the token validation policy.
        """
        additional_validation_policy: NotRequired[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyAdditionalValidationPolicyArgsDict']]
        """
        (Updatable) Additional JWT validation checks.
        """
        client_details: NotRequired[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyClientDetailsArgsDict']]
        """
        (Updatable) Client App Credential details.
        """
        is_ssl_verify_disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Defines whether or not to uphold SSL verification.
        """
        keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyKeyArgsDict']]]]
        """
        (Updatable) The set of static public keys.
        """
        max_cache_duration_in_hours: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The duration for which the introspect URL response should be cached before it is fetched again.
        """
        source_uri_details: NotRequired[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicySourceUriDetailsArgsDict']]
        """
        (Updatable) Auth endpoint details.
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The uri from which to retrieve the key. It must be accessible without authentication.
        """
elif False:
    DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 additional_validation_policy: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyAdditionalValidationPolicyArgs']] = None,
                 client_details: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyClientDetailsArgs']] = None,
                 is_ssl_verify_disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 keys: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyKeyArgs']]]] = None,
                 max_cache_duration_in_hours: Optional[pulumi.Input[_builtins.int]] = None,
                 source_uri_details: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicySourceUriDetailsArgs']] = None,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: (Updatable) Type of the token validation policy.
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyAdditionalValidationPolicyArgs'] additional_validation_policy: (Updatable) Additional JWT validation checks.
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyClientDetailsArgs'] client_details: (Updatable) Client App Credential details.
        :param pulumi.Input[_builtins.bool] is_ssl_verify_disabled: (Updatable) Defines whether or not to uphold SSL verification.
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyKeyArgs']]] keys: (Updatable) The set of static public keys.
        :param pulumi.Input[_builtins.int] max_cache_duration_in_hours: (Updatable) The duration for which the introspect URL response should be cached before it is fetched again.
        :param pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicySourceUriDetailsArgs'] source_uri_details: (Updatable) Auth endpoint details.
        :param pulumi.Input[_builtins.str] uri: (Updatable) The uri from which to retrieve the key. It must be accessible without authentication.
        """
        pulumi.set(__self__, "type", type)
        if additional_validation_policy is not None:
            pulumi.set(__self__, "additional_validation_policy", additional_validation_policy)
        if client_details is not None:
            pulumi.set(__self__, "client_details", client_details)
        if is_ssl_verify_disabled is not None:
            pulumi.set(__self__, "is_ssl_verify_disabled", is_ssl_verify_disabled)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if max_cache_duration_in_hours is not None:
            pulumi.set(__self__, "max_cache_duration_in_hours", max_cache_duration_in_hours)
        if source_uri_details is not None:
            pulumi.set(__self__, "source_uri_details", source_uri_details)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of the token validation policy.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="additionalValidationPolicy")
    def additional_validation_policy(self) -> Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyAdditionalValidationPolicyArgs']]:
        """
        (Updatable) Additional JWT validation checks.
        """
        return pulumi.get(self, "additional_validation_policy")

    @additional_validation_policy.setter
    def additional_validation_policy(self, value: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyAdditionalValidationPolicyArgs']]):
        pulumi.set(self, "additional_validation_policy", value)

    @_builtins.property
    @pulumi.getter(name="clientDetails")
    def client_details(self) -> Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyClientDetailsArgs']]:
        """
        (Updatable) Client App Credential details.
        """
        return pulumi.get(self, "client_details")

    @client_details.setter
    def client_details(self, value: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyClientDetailsArgs']]):
        pulumi.set(self, "client_details", value)

    @_builtins.property
    @pulumi.getter(name="isSslVerifyDisabled")
    def is_ssl_verify_disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Defines whether or not to uphold SSL verification.
        """
        return pulumi.get(self, "is_ssl_verify_disabled")

    @is_ssl_verify_disabled.setter
    def is_ssl_verify_disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_ssl_verify_disabled", value)

    @_builtins.property
    @pulumi.getter
    def keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyKeyArgs']]]]:
        """
        (Updatable) The set of static public keys.
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyKeyArgs']]]]):
        pulumi.set(self, "keys", value)

    @_builtins.property
    @pulumi.getter(name="maxCacheDurationInHours")
    def max_cache_duration_in_hours(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The duration for which the introspect URL response should be cached before it is fetched again.
        """
        return pulumi.get(self, "max_cache_duration_in_hours")

    @max_cache_duration_in_hours.setter
    def max_cache_duration_in_hours(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_cache_duration_in_hours", value)

    @_builtins.property
    @pulumi.getter(name="sourceUriDetails")
    def source_uri_details(self) -> Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicySourceUriDetailsArgs']]:
        """
        (Updatable) Auth endpoint details.
        """
        return pulumi.get(self, "source_uri_details")

    @source_uri_details.setter
    def source_uri_details(self, value: Optional[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicySourceUriDetailsArgs']]):
        pulumi.set(self, "source_uri_details", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The uri from which to retrieve the key. It must be accessible without authentication.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyAdditionalValidationPolicyArgsDict(TypedDict):
        audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The list of intended recipients for the token.
        """
        issuers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) A list of parties that could have issued the token.
        """
        verify_claims: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyAdditionalValidationPolicyVerifyClaimArgsDict']]]]
        """
        (Updatable) A list of claims which should be validated to consider the token valid.
        """
elif False:
    DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyAdditionalValidationPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyAdditionalValidationPolicyArgs:
    def __init__(__self__, *,
                 audiences: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 issuers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 verify_claims: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyAdditionalValidationPolicyVerifyClaimArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] audiences: (Updatable) The list of intended recipients for the token.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] issuers: (Updatable) A list of parties that could have issued the token.
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyAdditionalValidationPolicyVerifyClaimArgs']]] verify_claims: (Updatable) A list of claims which should be validated to consider the token valid.
        """
        if audiences is not None:
            pulumi.set(__self__, "audiences", audiences)
        if issuers is not None:
            pulumi.set(__self__, "issuers", issuers)
        if verify_claims is not None:
            pulumi.set(__self__, "verify_claims", verify_claims)

    @_builtins.property
    @pulumi.getter
    def audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The list of intended recipients for the token.
        """
        return pulumi.get(self, "audiences")

    @audiences.setter
    def audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "audiences", value)

    @_builtins.property
    @pulumi.getter
    def issuers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) A list of parties that could have issued the token.
        """
        return pulumi.get(self, "issuers")

    @issuers.setter
    def issuers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "issuers", value)

    @_builtins.property
    @pulumi.getter(name="verifyClaims")
    def verify_claims(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyAdditionalValidationPolicyVerifyClaimArgs']]]]:
        """
        (Updatable) A list of claims which should be validated to consider the token valid.
        """
        return pulumi.get(self, "verify_claims")

    @verify_claims.setter
    def verify_claims(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyAdditionalValidationPolicyVerifyClaimArgs']]]]):
        pulumi.set(self, "verify_claims", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyAdditionalValidationPolicyVerifyClaimArgsDict(TypedDict):
        is_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Whether the claim is required to be present in the JWT or not. If set to "false", the claim values will be matched only if the claim is present in the JWT.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Name of the claim.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The list of acceptable values for a given claim. If this value is "null" or empty and "isRequired" set to "true", then the presence of this claim in the JWT is validated.
        """
elif False:
    DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyAdditionalValidationPolicyVerifyClaimArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyAdditionalValidationPolicyVerifyClaimArgs:
    def __init__(__self__, *,
                 is_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_required: (Updatable) Whether the claim is required to be present in the JWT or not. If set to "false", the claim values will be matched only if the claim is present in the JWT.
        :param pulumi.Input[_builtins.str] key: (Updatable) Name of the claim.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: (Updatable) The list of acceptable values for a given claim. If this value is "null" or empty and "isRequired" set to "true", then the presence of this claim in the JWT is validated.
        """
        if is_required is not None:
            pulumi.set(__self__, "is_required", is_required)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="isRequired")
    def is_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Whether the claim is required to be present in the JWT or not. If set to "false", the claim values will be matched only if the claim is present in the JWT.
        """
        return pulumi.get(self, "is_required")

    @is_required.setter
    def is_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_required", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Name of the claim.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The list of acceptable values for a given claim. If this value is "null" or empty and "isRequired" set to "true", then the presence of this claim in the JWT is validated.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyClientDetailsArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) To specify where the Client App details should be taken from.
        """
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Client ID for the OAuth2/OIDC app.
        """
        client_secret_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Vault Service secret resource.
        """
        client_secret_version_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The version number of the client secret to use.
        """
elif False:
    DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyClientDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyClientDetailsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret_version_number: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: (Updatable) To specify where the Client App details should be taken from.
        :param pulumi.Input[_builtins.str] client_id: (Updatable) Client ID for the OAuth2/OIDC app.
        :param pulumi.Input[_builtins.str] client_secret_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Vault Service secret resource.
        :param pulumi.Input[_builtins.str] client_secret_version_number: (Updatable) The version number of the client secret to use.
        """
        pulumi.set(__self__, "type", type)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret_id is not None:
            pulumi.set(__self__, "client_secret_id", client_secret_id)
        if client_secret_version_number is not None:
            pulumi.set(__self__, "client_secret_version_number", client_secret_version_number)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) To specify where the Client App details should be taken from.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Client ID for the OAuth2/OIDC app.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecretId")
    def client_secret_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Vault Service secret resource.
        """
        return pulumi.get(self, "client_secret_id")

    @client_secret_id.setter
    def client_secret_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecretVersionNumber")
    def client_secret_version_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The version number of the client secret to use.
        """
        return pulumi.get(self, "client_secret_version_number")

    @client_secret_version_number.setter
    def client_secret_version_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret_version_number", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyKeyArgsDict(TypedDict):
        format: pulumi.Input[_builtins.str]
        """
        (Updatable) The format of the public key.
        """
        alg: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The algorithm intended for use with this key.
        """
        e: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The base64 url encoded exponent of the RSA public key represented by this key.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The content of the PEM-encoded public key.
        """
        key_ops: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The operations for which this key is to be used.
        """
        kid: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A unique key ID. This key will be used to verify the signature of a JWT with matching "kid".
        """
        kty: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The key type.
        """
        n: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The base64 url encoded modulus of the RSA public key represented by this key.
        """
        use: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The intended use of the public key.
        """
elif False:
    DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicyKeyArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[_builtins.str],
                 alg: Optional[pulumi.Input[_builtins.str]] = None,
                 e: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 key_ops: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 kid: Optional[pulumi.Input[_builtins.str]] = None,
                 kty: Optional[pulumi.Input[_builtins.str]] = None,
                 n: Optional[pulumi.Input[_builtins.str]] = None,
                 use: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] format: (Updatable) The format of the public key.
        :param pulumi.Input[_builtins.str] alg: (Updatable) The algorithm intended for use with this key.
        :param pulumi.Input[_builtins.str] e: (Updatable) The base64 url encoded exponent of the RSA public key represented by this key.
        :param pulumi.Input[_builtins.str] key: (Updatable) The content of the PEM-encoded public key.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] key_ops: (Updatable) The operations for which this key is to be used.
        :param pulumi.Input[_builtins.str] kid: (Updatable) A unique key ID. This key will be used to verify the signature of a JWT with matching "kid".
        :param pulumi.Input[_builtins.str] kty: (Updatable) The key type.
        :param pulumi.Input[_builtins.str] n: (Updatable) The base64 url encoded modulus of the RSA public key represented by this key.
        :param pulumi.Input[_builtins.str] use: (Updatable) The intended use of the public key.
        """
        pulumi.set(__self__, "format", format)
        if alg is not None:
            pulumi.set(__self__, "alg", alg)
        if e is not None:
            pulumi.set(__self__, "e", e)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if key_ops is not None:
            pulumi.set(__self__, "key_ops", key_ops)
        if kid is not None:
            pulumi.set(__self__, "kid", kid)
        if kty is not None:
            pulumi.set(__self__, "kty", kty)
        if n is not None:
            pulumi.set(__self__, "n", n)
        if use is not None:
            pulumi.set(__self__, "use", use)

    @_builtins.property
    @pulumi.getter
    def format(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The format of the public key.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter
    def alg(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The algorithm intended for use with this key.
        """
        return pulumi.get(self, "alg")

    @alg.setter
    def alg(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alg", value)

    @_builtins.property
    @pulumi.getter
    def e(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The base64 url encoded exponent of the RSA public key represented by this key.
        """
        return pulumi.get(self, "e")

    @e.setter
    def e(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "e", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The content of the PEM-encoded public key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="keyOps")
    def key_ops(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The operations for which this key is to be used.
        """
        return pulumi.get(self, "key_ops")

    @key_ops.setter
    def key_ops(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "key_ops", value)

    @_builtins.property
    @pulumi.getter
    def kid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A unique key ID. This key will be used to verify the signature of a JWT with matching "kid".
        """
        return pulumi.get(self, "kid")

    @kid.setter
    def kid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kid", value)

    @_builtins.property
    @pulumi.getter
    def kty(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The key type.
        """
        return pulumi.get(self, "kty")

    @kty.setter
    def kty(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kty", value)

    @_builtins.property
    @pulumi.getter
    def n(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The base64 url encoded modulus of the RSA public key represented by this key.
        """
        return pulumi.get(self, "n")

    @n.setter
    def n(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "n", value)

    @_builtins.property
    @pulumi.getter
    def use(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The intended use of the public key.
        """
        return pulumi.get(self, "use")

    @use.setter
    def use(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "use", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicySourceUriDetailsArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of the Uri detail.
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The discovery URI for the auth server.
        """
elif False:
    DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicySourceUriDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailValidationPolicySourceUriDetailsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: (Updatable) Type of the Uri detail.
        :param pulumi.Input[_builtins.str] uri: (Updatable) The discovery URI for the auth server.
        """
        pulumi.set(__self__, "type", type)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of the Uri detail.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The discovery URI for the auth server.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailVerifyClaimArgsDict(TypedDict):
        is_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Whether the claim is required to be present in the JWT or not. If set to "false", the claim values will be matched only if the claim is present in the JWT.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Name of the claim.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The list of acceptable values for a given claim. If this value is "null" or empty and "isRequired" set to "true", then the presence of this claim in the JWT is validated.
        """
elif False:
    DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailVerifyClaimArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerAuthenticationServerDetailVerifyClaimArgs:
    def __init__(__self__, *,
                 is_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_required: (Updatable) Whether the claim is required to be present in the JWT or not. If set to "false", the claim values will be matched only if the claim is present in the JWT.
        :param pulumi.Input[_builtins.str] key: (Updatable) Name of the claim.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: (Updatable) The list of acceptable values for a given claim. If this value is "null" or empty and "isRequired" set to "true", then the presence of this claim in the JWT is validated.
        """
        if is_required is not None:
            pulumi.set(__self__, "is_required", is_required)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="isRequired")
    def is_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Whether the claim is required to be present in the JWT or not. If set to "false", the claim values will be matched only if the claim is present in the JWT.
        """
        return pulumi.get(self, "is_required")

    @is_required.setter
    def is_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_required", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Name of the claim.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The list of acceptable values for a given claim. If this value is "null" or empty and "isRequired" set to "true", then the presence of this claim in the JWT is validated.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerKeyArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        (Updatable) Name assigned to the branch.
        """
        expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A selection key string containing a wildcard to match with the context variable in an incoming request. If the context variable matches the string, the request is sent to the route or authentication server associated with the selection key. Valid wildcards are '*' (zero or more characters) and '+' (one or more characters). The string can only contain one wildcard, and the wildcard must be at the start or the end of the string.
        """
        is_default: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Specifies whether to use the route or authentication server associated with this selection key as the default. The default is used if the value of a context variable in an incoming request does not match any of the other selection key values when dynamically routing and dynamically authenticating requests.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Type of the selection key.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The set of selection keys to match with the context variable in an incoming request. If the context variable exactly matches one of the keys in the set, the request is sent to the route or authentication server associated with the set.
        """
elif False:
    DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesDynamicAuthenticationAuthenticationServerKeyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 expression: Optional[pulumi.Input[_builtins.str]] = None,
                 is_default: Optional[pulumi.Input[_builtins.bool]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) Name assigned to the branch.
        :param pulumi.Input[_builtins.str] expression: (Updatable) A selection key string containing a wildcard to match with the context variable in an incoming request. If the context variable matches the string, the request is sent to the route or authentication server associated with the selection key. Valid wildcards are '*' (zero or more characters) and '+' (one or more characters). The string can only contain one wildcard, and the wildcard must be at the start or the end of the string.
        :param pulumi.Input[_builtins.bool] is_default: (Updatable) Specifies whether to use the route or authentication server associated with this selection key as the default. The default is used if the value of a context variable in an incoming request does not match any of the other selection key values when dynamically routing and dynamically authenticating requests.
        :param pulumi.Input[_builtins.str] type: (Updatable) Type of the selection key.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: (Updatable) The set of selection keys to match with the context variable in an incoming request. If the context variable exactly matches one of the keys in the set, the request is sent to the route or authentication server associated with the set.
        """
        pulumi.set(__self__, "name", name)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Name assigned to the branch.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A selection key string containing a wildcard to match with the context variable in an incoming request. If the context variable matches the string, the request is sent to the route or authentication server associated with the selection key. Valid wildcards are '*' (zero or more characters) and '+' (one or more characters). The string can only contain one wildcard, and the wildcard must be at the start or the end of the string.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Specifies whether to use the route or authentication server associated with this selection key as the default. The default is used if the value of a context variable in an incoming request does not match any of the other selection key values when dynamically routing and dynamically authenticating requests.
        """
        return pulumi.get(self, "is_default")

    @is_default.setter
    def is_default(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_default", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Type of the selection key.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The set of selection keys to match with the context variable in an incoming request. If the context variable exactly matches one of the keys in the set, the request is sent to the route or authentication server associated with the set.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesDynamicAuthenticationSelectionSourceArgsDict(TypedDict):
        selector: pulumi.Input[_builtins.str]
        """
        (Updatable) String describing the context variable used as selector.
        """
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of the Selection source to use.
        """
elif False:
    DeploymentSpecificationRequestPoliciesDynamicAuthenticationSelectionSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesDynamicAuthenticationSelectionSourceArgs:
    def __init__(__self__, *,
                 selector: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] selector: (Updatable) String describing the context variable used as selector.
        :param pulumi.Input[_builtins.str] type: (Updatable) Type of the Selection source to use.
        """
        pulumi.set(__self__, "selector", selector)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def selector(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) String describing the context variable used as selector.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "selector", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of the Selection source to use.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesMutualTlsArgsDict(TypedDict):
        allowed_sans: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) Allowed list of CN or SAN which will be used for verification of certificate.
        """
        is_verified_certificate_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Determines whether to enable client verification when API Consumer makes connection to the gateway.
        """
elif False:
    DeploymentSpecificationRequestPoliciesMutualTlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesMutualTlsArgs:
    def __init__(__self__, *,
                 allowed_sans: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 is_verified_certificate_required: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_sans: (Updatable) Allowed list of CN or SAN which will be used for verification of certificate.
        :param pulumi.Input[_builtins.bool] is_verified_certificate_required: (Updatable) Determines whether to enable client verification when API Consumer makes connection to the gateway.
        """
        if allowed_sans is not None:
            pulumi.set(__self__, "allowed_sans", allowed_sans)
        if is_verified_certificate_required is not None:
            pulumi.set(__self__, "is_verified_certificate_required", is_verified_certificate_required)

    @_builtins.property
    @pulumi.getter(name="allowedSans")
    def allowed_sans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) Allowed list of CN or SAN which will be used for verification of certificate.
        """
        return pulumi.get(self, "allowed_sans")

    @allowed_sans.setter
    def allowed_sans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_sans", value)

    @_builtins.property
    @pulumi.getter(name="isVerifiedCertificateRequired")
    def is_verified_certificate_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Determines whether to enable client verification when API Consumer makes connection to the gateway.
        """
        return pulumi.get(self, "is_verified_certificate_required")

    @is_verified_certificate_required.setter
    def is_verified_certificate_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_verified_certificate_required", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesRateLimitingArgsDict(TypedDict):
        rate_in_requests_per_second: pulumi.Input[_builtins.int]
        """
        (Updatable) The maximum number of requests per second to allow.
        """
        rate_key: pulumi.Input[_builtins.str]
        """
        (Updatable) The key used to group requests together.
        """
elif False:
    DeploymentSpecificationRequestPoliciesRateLimitingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesRateLimitingArgs:
    def __init__(__self__, *,
                 rate_in_requests_per_second: pulumi.Input[_builtins.int],
                 rate_key: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] rate_in_requests_per_second: (Updatable) The maximum number of requests per second to allow.
        :param pulumi.Input[_builtins.str] rate_key: (Updatable) The key used to group requests together.
        """
        pulumi.set(__self__, "rate_in_requests_per_second", rate_in_requests_per_second)
        pulumi.set(__self__, "rate_key", rate_key)

    @_builtins.property
    @pulumi.getter(name="rateInRequestsPerSecond")
    def rate_in_requests_per_second(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) The maximum number of requests per second to allow.
        """
        return pulumi.get(self, "rate_in_requests_per_second")

    @rate_in_requests_per_second.setter
    def rate_in_requests_per_second(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "rate_in_requests_per_second", value)

    @_builtins.property
    @pulumi.getter(name="rateKey")
    def rate_key(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The key used to group requests together.
        """
        return pulumi.get(self, "rate_key")

    @rate_key.setter
    def rate_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "rate_key", value)


if not MYPY:
    class DeploymentSpecificationRequestPoliciesUsagePlansArgsDict(TypedDict):
        token_locations: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        (Updatable) A list of context variables specifying where API tokens may be located in a request. Example locations:
        * "request.headers[token]"
        * "request.query[token]"
        * "request.auth[Token]"
        * "request.path[TOKEN]"
        """
elif False:
    DeploymentSpecificationRequestPoliciesUsagePlansArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRequestPoliciesUsagePlansArgs:
    def __init__(__self__, *,
                 token_locations: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] token_locations: (Updatable) A list of context variables specifying where API tokens may be located in a request. Example locations:
               * "request.headers[token]"
               * "request.query[token]"
               * "request.auth[Token]"
               * "request.path[TOKEN]"
        """
        pulumi.set(__self__, "token_locations", token_locations)

    @_builtins.property
    @pulumi.getter(name="tokenLocations")
    def token_locations(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        (Updatable) A list of context variables specifying where API tokens may be located in a request. Example locations:
        * "request.headers[token]"
        * "request.query[token]"
        * "request.auth[Token]"
        * "request.path[TOKEN]"
        """
        return pulumi.get(self, "token_locations")

    @token_locations.setter
    def token_locations(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "token_locations", value)


if not MYPY:
    class DeploymentSpecificationRouteArgsDict(TypedDict):
        backend: pulumi.Input['DeploymentSpecificationRouteBackendArgsDict']
        """
        (Updatable) The backend to forward requests to.
        """
        path: pulumi.Input[_builtins.str]
        """
        (Updatable) A URL path pattern that must be matched on this route. The path pattern may contain a subset of RFC 6570 identifiers to allow wildcard and parameterized matching.
        """
        logging_policies: NotRequired[pulumi.Input['DeploymentSpecificationRouteLoggingPoliciesArgsDict']]
        """
        (Updatable) Policies controlling the pushing of logs to Oracle Cloud Infrastructure Public Logging.
        """
        methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) A list of allowed methods on this route.
        """
        request_policies: NotRequired[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesArgsDict']]
        """
        (Updatable) Behavior applied to any requests received by the API on this route.
        """
        response_policies: NotRequired[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesArgsDict']]
        """
        (Updatable) Behavior applied to any responses sent by the API for requests on this route.
        """
elif False:
    DeploymentSpecificationRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteArgs:
    def __init__(__self__, *,
                 backend: pulumi.Input['DeploymentSpecificationRouteBackendArgs'],
                 path: pulumi.Input[_builtins.str],
                 logging_policies: Optional[pulumi.Input['DeploymentSpecificationRouteLoggingPoliciesArgs']] = None,
                 methods: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 request_policies: Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesArgs']] = None,
                 response_policies: Optional[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesArgs']] = None):
        """
        :param pulumi.Input['DeploymentSpecificationRouteBackendArgs'] backend: (Updatable) The backend to forward requests to.
        :param pulumi.Input[_builtins.str] path: (Updatable) A URL path pattern that must be matched on this route. The path pattern may contain a subset of RFC 6570 identifiers to allow wildcard and parameterized matching.
        :param pulumi.Input['DeploymentSpecificationRouteLoggingPoliciesArgs'] logging_policies: (Updatable) Policies controlling the pushing of logs to Oracle Cloud Infrastructure Public Logging.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] methods: (Updatable) A list of allowed methods on this route.
        :param pulumi.Input['DeploymentSpecificationRouteRequestPoliciesArgs'] request_policies: (Updatable) Behavior applied to any requests received by the API on this route.
        :param pulumi.Input['DeploymentSpecificationRouteResponsePoliciesArgs'] response_policies: (Updatable) Behavior applied to any responses sent by the API for requests on this route.
        """
        pulumi.set(__self__, "backend", backend)
        pulumi.set(__self__, "path", path)
        if logging_policies is not None:
            pulumi.set(__self__, "logging_policies", logging_policies)
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if request_policies is not None:
            pulumi.set(__self__, "request_policies", request_policies)
        if response_policies is not None:
            pulumi.set(__self__, "response_policies", response_policies)

    @_builtins.property
    @pulumi.getter
    def backend(self) -> pulumi.Input['DeploymentSpecificationRouteBackendArgs']:
        """
        (Updatable) The backend to forward requests to.
        """
        return pulumi.get(self, "backend")

    @backend.setter
    def backend(self, value: pulumi.Input['DeploymentSpecificationRouteBackendArgs']):
        pulumi.set(self, "backend", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) A URL path pattern that must be matched on this route. The path pattern may contain a subset of RFC 6570 identifiers to allow wildcard and parameterized matching.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="loggingPolicies")
    def logging_policies(self) -> Optional[pulumi.Input['DeploymentSpecificationRouteLoggingPoliciesArgs']]:
        """
        (Updatable) Policies controlling the pushing of logs to Oracle Cloud Infrastructure Public Logging.
        """
        return pulumi.get(self, "logging_policies")

    @logging_policies.setter
    def logging_policies(self, value: Optional[pulumi.Input['DeploymentSpecificationRouteLoggingPoliciesArgs']]):
        pulumi.set(self, "logging_policies", value)

    @_builtins.property
    @pulumi.getter
    def methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) A list of allowed methods on this route.
        """
        return pulumi.get(self, "methods")

    @methods.setter
    def methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "methods", value)

    @_builtins.property
    @pulumi.getter(name="requestPolicies")
    def request_policies(self) -> Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesArgs']]:
        """
        (Updatable) Behavior applied to any requests received by the API on this route.
        """
        return pulumi.get(self, "request_policies")

    @request_policies.setter
    def request_policies(self, value: Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesArgs']]):
        pulumi.set(self, "request_policies", value)

    @_builtins.property
    @pulumi.getter(name="responsePolicies")
    def response_policies(self) -> Optional[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesArgs']]:
        """
        (Updatable) Behavior applied to any responses sent by the API for requests on this route.
        """
        return pulumi.get(self, "response_policies")

    @response_policies.setter
    def response_policies(self, value: Optional[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesArgs']]):
        pulumi.set(self, "response_policies", value)


if not MYPY:
    class DeploymentSpecificationRouteBackendArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of the API backend.
        """
        allowed_post_logout_uris: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) A list of allowed post-logout URLs to which a request can be redirected after revoke access
        """
        body: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The body of the stock response from the mock backend.
        """
        connect_timeout_in_seconds: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Updatable) Defines a timeout for establishing a connection with a proxied server.
        """
        function_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Functions function resource.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteBackendHeaderArgsDict']]]]
        """
        (Updatable) The headers of the stock response from the mock backend.
        """
        is_ssl_verify_disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Defines whether or not to uphold SSL verification.
        """
        post_logout_state: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Defines a state that should be shared on redirecting to postLogout URL.
        """
        read_timeout_in_seconds: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Updatable) Defines a timeout for reading a response from the proxied server.
        """
        routing_backends: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteBackendRoutingBackendArgsDict']]]]
        """
        (Updatable) List of backends to chose from for Dynamic Routing.
        """
        selection_source: NotRequired[pulumi.Input['DeploymentSpecificationRouteBackendSelectionSourceArgsDict']]
        """
        (Updatable) Information around selector used for branching among routes/ authentication servers while dynamic routing/ authentication.
        """
        send_timeout_in_seconds: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Updatable) Defines a timeout for transmitting a request to the proxied server.
        """
        status: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The status code of the stock response from the mock backend.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The url of the HTTP Backend
        """
elif False:
    DeploymentSpecificationRouteBackendArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteBackendArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 allowed_post_logout_uris: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 body: Optional[pulumi.Input[_builtins.str]] = None,
                 connect_timeout_in_seconds: Optional[pulumi.Input[_builtins.float]] = None,
                 function_id: Optional[pulumi.Input[_builtins.str]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteBackendHeaderArgs']]]] = None,
                 is_ssl_verify_disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 post_logout_state: Optional[pulumi.Input[_builtins.str]] = None,
                 read_timeout_in_seconds: Optional[pulumi.Input[_builtins.float]] = None,
                 routing_backends: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteBackendRoutingBackendArgs']]]] = None,
                 selection_source: Optional[pulumi.Input['DeploymentSpecificationRouteBackendSelectionSourceArgs']] = None,
                 send_timeout_in_seconds: Optional[pulumi.Input[_builtins.float]] = None,
                 status: Optional[pulumi.Input[_builtins.int]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: (Updatable) Type of the API backend.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_post_logout_uris: (Updatable) A list of allowed post-logout URLs to which a request can be redirected after revoke access
        :param pulumi.Input[_builtins.str] body: (Updatable) The body of the stock response from the mock backend.
        :param pulumi.Input[_builtins.float] connect_timeout_in_seconds: (Updatable) Defines a timeout for establishing a connection with a proxied server.
        :param pulumi.Input[_builtins.str] function_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Functions function resource.
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteBackendHeaderArgs']]] headers: (Updatable) The headers of the stock response from the mock backend.
        :param pulumi.Input[_builtins.bool] is_ssl_verify_disabled: (Updatable) Defines whether or not to uphold SSL verification.
        :param pulumi.Input[_builtins.str] post_logout_state: (Updatable) Defines a state that should be shared on redirecting to postLogout URL.
        :param pulumi.Input[_builtins.float] read_timeout_in_seconds: (Updatable) Defines a timeout for reading a response from the proxied server.
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteBackendRoutingBackendArgs']]] routing_backends: (Updatable) List of backends to chose from for Dynamic Routing.
        :param pulumi.Input['DeploymentSpecificationRouteBackendSelectionSourceArgs'] selection_source: (Updatable) Information around selector used for branching among routes/ authentication servers while dynamic routing/ authentication.
        :param pulumi.Input[_builtins.float] send_timeout_in_seconds: (Updatable) Defines a timeout for transmitting a request to the proxied server.
        :param pulumi.Input[_builtins.int] status: (Updatable) The status code of the stock response from the mock backend.
        :param pulumi.Input[_builtins.str] url: (Updatable) The url of the HTTP Backend
        """
        pulumi.set(__self__, "type", type)
        if allowed_post_logout_uris is not None:
            pulumi.set(__self__, "allowed_post_logout_uris", allowed_post_logout_uris)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if connect_timeout_in_seconds is not None:
            pulumi.set(__self__, "connect_timeout_in_seconds", connect_timeout_in_seconds)
        if function_id is not None:
            pulumi.set(__self__, "function_id", function_id)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if is_ssl_verify_disabled is not None:
            pulumi.set(__self__, "is_ssl_verify_disabled", is_ssl_verify_disabled)
        if post_logout_state is not None:
            pulumi.set(__self__, "post_logout_state", post_logout_state)
        if read_timeout_in_seconds is not None:
            pulumi.set(__self__, "read_timeout_in_seconds", read_timeout_in_seconds)
        if routing_backends is not None:
            pulumi.set(__self__, "routing_backends", routing_backends)
        if selection_source is not None:
            pulumi.set(__self__, "selection_source", selection_source)
        if send_timeout_in_seconds is not None:
            pulumi.set(__self__, "send_timeout_in_seconds", send_timeout_in_seconds)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of the API backend.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="allowedPostLogoutUris")
    def allowed_post_logout_uris(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) A list of allowed post-logout URLs to which a request can be redirected after revoke access
        """
        return pulumi.get(self, "allowed_post_logout_uris")

    @allowed_post_logout_uris.setter
    def allowed_post_logout_uris(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_post_logout_uris", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The body of the stock response from the mock backend.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter(name="connectTimeoutInSeconds")
    def connect_timeout_in_seconds(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Updatable) Defines a timeout for establishing a connection with a proxied server.
        """
        return pulumi.get(self, "connect_timeout_in_seconds")

    @connect_timeout_in_seconds.setter
    def connect_timeout_in_seconds(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "connect_timeout_in_seconds", value)

    @_builtins.property
    @pulumi.getter(name="functionId")
    def function_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Functions function resource.
        """
        return pulumi.get(self, "function_id")

    @function_id.setter
    def function_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "function_id", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteBackendHeaderArgs']]]]:
        """
        (Updatable) The headers of the stock response from the mock backend.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteBackendHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="isSslVerifyDisabled")
    def is_ssl_verify_disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Defines whether or not to uphold SSL verification.
        """
        return pulumi.get(self, "is_ssl_verify_disabled")

    @is_ssl_verify_disabled.setter
    def is_ssl_verify_disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_ssl_verify_disabled", value)

    @_builtins.property
    @pulumi.getter(name="postLogoutState")
    def post_logout_state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Defines a state that should be shared on redirecting to postLogout URL.
        """
        return pulumi.get(self, "post_logout_state")

    @post_logout_state.setter
    def post_logout_state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "post_logout_state", value)

    @_builtins.property
    @pulumi.getter(name="readTimeoutInSeconds")
    def read_timeout_in_seconds(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Updatable) Defines a timeout for reading a response from the proxied server.
        """
        return pulumi.get(self, "read_timeout_in_seconds")

    @read_timeout_in_seconds.setter
    def read_timeout_in_seconds(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "read_timeout_in_seconds", value)

    @_builtins.property
    @pulumi.getter(name="routingBackends")
    def routing_backends(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteBackendRoutingBackendArgs']]]]:
        """
        (Updatable) List of backends to chose from for Dynamic Routing.
        """
        return pulumi.get(self, "routing_backends")

    @routing_backends.setter
    def routing_backends(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteBackendRoutingBackendArgs']]]]):
        pulumi.set(self, "routing_backends", value)

    @_builtins.property
    @pulumi.getter(name="selectionSource")
    def selection_source(self) -> Optional[pulumi.Input['DeploymentSpecificationRouteBackendSelectionSourceArgs']]:
        """
        (Updatable) Information around selector used for branching among routes/ authentication servers while dynamic routing/ authentication.
        """
        return pulumi.get(self, "selection_source")

    @selection_source.setter
    def selection_source(self, value: Optional[pulumi.Input['DeploymentSpecificationRouteBackendSelectionSourceArgs']]):
        pulumi.set(self, "selection_source", value)

    @_builtins.property
    @pulumi.getter(name="sendTimeoutInSeconds")
    def send_timeout_in_seconds(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Updatable) Defines a timeout for transmitting a request to the proxied server.
        """
        return pulumi.get(self, "send_timeout_in_seconds")

    @send_timeout_in_seconds.setter
    def send_timeout_in_seconds(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "send_timeout_in_seconds", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The status code of the stock response from the mock backend.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The url of the HTTP Backend
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class DeploymentSpecificationRouteBackendHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Name of the header.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Value of the header.
        """
elif False:
    DeploymentSpecificationRouteBackendHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteBackendHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) Name of the header.
        :param pulumi.Input[_builtins.str] value: (Updatable) Value of the header.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Name of the header.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Value of the header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DeploymentSpecificationRouteBackendRoutingBackendArgsDict(TypedDict):
        backend: NotRequired[pulumi.Input['DeploymentSpecificationRouteBackendRoutingBackendBackendArgsDict']]
        """
        (Updatable) The backend to forward requests to.
        """
        key: NotRequired[pulumi.Input['DeploymentSpecificationRouteBackendRoutingBackendKeyArgsDict']]
        """
        (Updatable) Information around the values for selector of an authentication/ routing branch.
        """
elif False:
    DeploymentSpecificationRouteBackendRoutingBackendArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteBackendRoutingBackendArgs:
    def __init__(__self__, *,
                 backend: Optional[pulumi.Input['DeploymentSpecificationRouteBackendRoutingBackendBackendArgs']] = None,
                 key: Optional[pulumi.Input['DeploymentSpecificationRouteBackendRoutingBackendKeyArgs']] = None):
        """
        :param pulumi.Input['DeploymentSpecificationRouteBackendRoutingBackendBackendArgs'] backend: (Updatable) The backend to forward requests to.
        :param pulumi.Input['DeploymentSpecificationRouteBackendRoutingBackendKeyArgs'] key: (Updatable) Information around the values for selector of an authentication/ routing branch.
        """
        if backend is not None:
            pulumi.set(__self__, "backend", backend)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def backend(self) -> Optional[pulumi.Input['DeploymentSpecificationRouteBackendRoutingBackendBackendArgs']]:
        """
        (Updatable) The backend to forward requests to.
        """
        return pulumi.get(self, "backend")

    @backend.setter
    def backend(self, value: Optional[pulumi.Input['DeploymentSpecificationRouteBackendRoutingBackendBackendArgs']]):
        pulumi.set(self, "backend", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input['DeploymentSpecificationRouteBackendRoutingBackendKeyArgs']]:
        """
        (Updatable) Information around the values for selector of an authentication/ routing branch.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input['DeploymentSpecificationRouteBackendRoutingBackendKeyArgs']]):
        pulumi.set(self, "key", value)


if not MYPY:
    class DeploymentSpecificationRouteBackendRoutingBackendBackendArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of the Response Cache Store Policy.
        """
        body: NotRequired[pulumi.Input[_builtins.str]]
        """
        The body of the stock response from the mock backend.
        """
        connect_timeout_in_seconds: NotRequired[pulumi.Input[_builtins.float]]
        """
        Defines a timeout for establishing a connection with a proxied server.
        """
        function_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Functions function resource.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteBackendRoutingBackendBackendHeaderArgsDict']]]]
        """
        The List of Headers
        """
        is_ssl_verify_disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Defines whether or not to uphold SSL verification.
        """
        read_timeout_in_seconds: NotRequired[pulumi.Input[_builtins.float]]
        """
        Defines a timeout for reading a response from the proxied server.
        """
        send_timeout_in_seconds: NotRequired[pulumi.Input[_builtins.float]]
        """
        Defines a timeout for transmitting a request to the proxied server.
        """
        status: NotRequired[pulumi.Input[_builtins.int]]
        """
        The status code of the stock response from the mock backend.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The url of the HTTP Backend
        """
elif False:
    DeploymentSpecificationRouteBackendRoutingBackendBackendArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteBackendRoutingBackendBackendArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 body: Optional[pulumi.Input[_builtins.str]] = None,
                 connect_timeout_in_seconds: Optional[pulumi.Input[_builtins.float]] = None,
                 function_id: Optional[pulumi.Input[_builtins.str]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteBackendRoutingBackendBackendHeaderArgs']]]] = None,
                 is_ssl_verify_disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 read_timeout_in_seconds: Optional[pulumi.Input[_builtins.float]] = None,
                 send_timeout_in_seconds: Optional[pulumi.Input[_builtins.float]] = None,
                 status: Optional[pulumi.Input[_builtins.int]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of the Response Cache Store Policy.
        :param pulumi.Input[_builtins.str] body: The body of the stock response from the mock backend.
        :param pulumi.Input[_builtins.float] connect_timeout_in_seconds: Defines a timeout for establishing a connection with a proxied server.
        :param pulumi.Input[_builtins.str] function_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Functions function resource.
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteBackendRoutingBackendBackendHeaderArgs']]] headers: The List of Headers
        :param pulumi.Input[_builtins.bool] is_ssl_verify_disabled: Defines whether or not to uphold SSL verification.
        :param pulumi.Input[_builtins.float] read_timeout_in_seconds: Defines a timeout for reading a response from the proxied server.
        :param pulumi.Input[_builtins.float] send_timeout_in_seconds: Defines a timeout for transmitting a request to the proxied server.
        :param pulumi.Input[_builtins.int] status: The status code of the stock response from the mock backend.
        :param pulumi.Input[_builtins.str] url: The url of the HTTP Backend
        """
        pulumi.set(__self__, "type", type)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if connect_timeout_in_seconds is not None:
            pulumi.set(__self__, "connect_timeout_in_seconds", connect_timeout_in_seconds)
        if function_id is not None:
            pulumi.set(__self__, "function_id", function_id)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if is_ssl_verify_disabled is not None:
            pulumi.set(__self__, "is_ssl_verify_disabled", is_ssl_verify_disabled)
        if read_timeout_in_seconds is not None:
            pulumi.set(__self__, "read_timeout_in_seconds", read_timeout_in_seconds)
        if send_timeout_in_seconds is not None:
            pulumi.set(__self__, "send_timeout_in_seconds", send_timeout_in_seconds)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of the Response Cache Store Policy.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The body of the stock response from the mock backend.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter(name="connectTimeoutInSeconds")
    def connect_timeout_in_seconds(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Defines a timeout for establishing a connection with a proxied server.
        """
        return pulumi.get(self, "connect_timeout_in_seconds")

    @connect_timeout_in_seconds.setter
    def connect_timeout_in_seconds(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "connect_timeout_in_seconds", value)

    @_builtins.property
    @pulumi.getter(name="functionId")
    def function_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Functions function resource.
        """
        return pulumi.get(self, "function_id")

    @function_id.setter
    def function_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "function_id", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteBackendRoutingBackendBackendHeaderArgs']]]]:
        """
        The List of Headers
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteBackendRoutingBackendBackendHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="isSslVerifyDisabled")
    def is_ssl_verify_disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Defines whether or not to uphold SSL verification.
        """
        return pulumi.get(self, "is_ssl_verify_disabled")

    @is_ssl_verify_disabled.setter
    def is_ssl_verify_disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_ssl_verify_disabled", value)

    @_builtins.property
    @pulumi.getter(name="readTimeoutInSeconds")
    def read_timeout_in_seconds(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Defines a timeout for reading a response from the proxied server.
        """
        return pulumi.get(self, "read_timeout_in_seconds")

    @read_timeout_in_seconds.setter
    def read_timeout_in_seconds(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "read_timeout_in_seconds", value)

    @_builtins.property
    @pulumi.getter(name="sendTimeoutInSeconds")
    def send_timeout_in_seconds(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Defines a timeout for transmitting a request to the proxied server.
        """
        return pulumi.get(self, "send_timeout_in_seconds")

    @send_timeout_in_seconds.setter
    def send_timeout_in_seconds(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "send_timeout_in_seconds", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The status code of the stock response from the mock backend.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The url of the HTTP Backend
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class DeploymentSpecificationRouteBackendRoutingBackendBackendHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value of the header.
        """
elif False:
    DeploymentSpecificationRouteBackendRoutingBackendBackendHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteBackendRoutingBackendBackendHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The case-insensitive name of the header.  This name must be unique across transformation policies.
        :param pulumi.Input[_builtins.str] value: Value of the header.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value of the header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DeploymentSpecificationRouteBackendRoutingBackendKeyArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        (Updatable) Name assigned to the branch.
        """
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Information regarding type of the selection key.
        """
        expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) String describing the expression with wildcards.
        """
        is_default: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Information regarding whether this is the default branch.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) Information regarding the set of values of selector for which this branch should be selected.
        """
elif False:
    DeploymentSpecificationRouteBackendRoutingBackendKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteBackendRoutingBackendKeyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 expression: Optional[pulumi.Input[_builtins.str]] = None,
                 is_default: Optional[pulumi.Input[_builtins.bool]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) Name assigned to the branch.
        :param pulumi.Input[_builtins.str] type: (Updatable) Information regarding type of the selection key.
        :param pulumi.Input[_builtins.str] expression: (Updatable) String describing the expression with wildcards.
        :param pulumi.Input[_builtins.bool] is_default: (Updatable) Information regarding whether this is the default branch.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: (Updatable) Information regarding the set of values of selector for which this branch should be selected.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Name assigned to the branch.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Information regarding type of the selection key.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) String describing the expression with wildcards.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Information regarding whether this is the default branch.
        """
        return pulumi.get(self, "is_default")

    @is_default.setter
    def is_default(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_default", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) Information regarding the set of values of selector for which this branch should be selected.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DeploymentSpecificationRouteBackendSelectionSourceArgsDict(TypedDict):
        selector: pulumi.Input[_builtins.str]
        """
        (Updatable) String describing the context variable used as selector.
        """
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of the Selection source to use.
        """
elif False:
    DeploymentSpecificationRouteBackendSelectionSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteBackendSelectionSourceArgs:
    def __init__(__self__, *,
                 selector: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] selector: (Updatable) String describing the context variable used as selector.
        :param pulumi.Input[_builtins.str] type: (Updatable) Type of the Selection source to use.
        """
        pulumi.set(__self__, "selector", selector)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def selector(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) String describing the context variable used as selector.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "selector", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of the Selection source to use.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DeploymentSpecificationRouteLoggingPoliciesArgsDict(TypedDict):
        access_log: NotRequired[pulumi.Input['DeploymentSpecificationRouteLoggingPoliciesAccessLogArgsDict']]
        """
        (Updatable) Configures the logging policies for the access logs of an API Deployment.
        """
        execution_log: NotRequired[pulumi.Input['DeploymentSpecificationRouteLoggingPoliciesExecutionLogArgsDict']]
        """
        (Updatable) Configures the logging policies for the execution logs of an API Deployment.
        """
elif False:
    DeploymentSpecificationRouteLoggingPoliciesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteLoggingPoliciesArgs:
    def __init__(__self__, *,
                 access_log: Optional[pulumi.Input['DeploymentSpecificationRouteLoggingPoliciesAccessLogArgs']] = None,
                 execution_log: Optional[pulumi.Input['DeploymentSpecificationRouteLoggingPoliciesExecutionLogArgs']] = None):
        """
        :param pulumi.Input['DeploymentSpecificationRouteLoggingPoliciesAccessLogArgs'] access_log: (Updatable) Configures the logging policies for the access logs of an API Deployment.
        :param pulumi.Input['DeploymentSpecificationRouteLoggingPoliciesExecutionLogArgs'] execution_log: (Updatable) Configures the logging policies for the execution logs of an API Deployment.
        """
        if access_log is not None:
            pulumi.set(__self__, "access_log", access_log)
        if execution_log is not None:
            pulumi.set(__self__, "execution_log", execution_log)

    @_builtins.property
    @pulumi.getter(name="accessLog")
    def access_log(self) -> Optional[pulumi.Input['DeploymentSpecificationRouteLoggingPoliciesAccessLogArgs']]:
        """
        (Updatable) Configures the logging policies for the access logs of an API Deployment.
        """
        return pulumi.get(self, "access_log")

    @access_log.setter
    def access_log(self, value: Optional[pulumi.Input['DeploymentSpecificationRouteLoggingPoliciesAccessLogArgs']]):
        pulumi.set(self, "access_log", value)

    @_builtins.property
    @pulumi.getter(name="executionLog")
    def execution_log(self) -> Optional[pulumi.Input['DeploymentSpecificationRouteLoggingPoliciesExecutionLogArgs']]:
        """
        (Updatable) Configures the logging policies for the execution logs of an API Deployment.
        """
        return pulumi.get(self, "execution_log")

    @execution_log.setter
    def execution_log(self, value: Optional[pulumi.Input['DeploymentSpecificationRouteLoggingPoliciesExecutionLogArgs']]):
        pulumi.set(self, "execution_log", value)


if not MYPY:
    class DeploymentSpecificationRouteLoggingPoliciesAccessLogArgsDict(TypedDict):
        is_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Enables pushing of access logs to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket.

        Oracle recommends using the Oracle Cloud Infrastructure Logging service to enable, retrieve, and query access logs for an API Deployment. If there is an active log object for the API Deployment and its category is set to 'access' in Oracle Cloud Infrastructure Logging service, the logs will not be uploaded to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket.

        Please note that the functionality to push to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket has been deprecated and will be removed in the future.
        """
elif False:
    DeploymentSpecificationRouteLoggingPoliciesAccessLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteLoggingPoliciesAccessLogArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_enabled: (Updatable) Enables pushing of access logs to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket.
               
               Oracle recommends using the Oracle Cloud Infrastructure Logging service to enable, retrieve, and query access logs for an API Deployment. If there is an active log object for the API Deployment and its category is set to 'access' in Oracle Cloud Infrastructure Logging service, the logs will not be uploaded to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket.
               
               Please note that the functionality to push to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket has been deprecated and will be removed in the future.
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Enables pushing of access logs to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket.

        Oracle recommends using the Oracle Cloud Infrastructure Logging service to enable, retrieve, and query access logs for an API Deployment. If there is an active log object for the API Deployment and its category is set to 'access' in Oracle Cloud Infrastructure Logging service, the logs will not be uploaded to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket.

        Please note that the functionality to push to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket has been deprecated and will be removed in the future.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_enabled", value)


if not MYPY:
    class DeploymentSpecificationRouteLoggingPoliciesExecutionLogArgsDict(TypedDict):
        is_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Enables pushing of execution logs to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket.

        Oracle recommends using the Oracle Cloud Infrastructure Logging service to enable, retrieve, and query execution logs for an API Deployment. If there is an active log object for the API Deployment and its category is set to 'execution' in Oracle Cloud Infrastructure Logging service, the logs will not be uploaded to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket.

        Please note that the functionality to push to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket has been deprecated and will be removed in the future.
        """
        log_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Specifies the log level used to control logging output of execution logs. Enabling logging at a given level also enables logging at all higher levels.
        """
elif False:
    DeploymentSpecificationRouteLoggingPoliciesExecutionLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteLoggingPoliciesExecutionLogArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 log_level: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_enabled: (Updatable) Enables pushing of execution logs to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket.
               
               Oracle recommends using the Oracle Cloud Infrastructure Logging service to enable, retrieve, and query execution logs for an API Deployment. If there is an active log object for the API Deployment and its category is set to 'execution' in Oracle Cloud Infrastructure Logging service, the logs will not be uploaded to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket.
               
               Please note that the functionality to push to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket has been deprecated and will be removed in the future.
        :param pulumi.Input[_builtins.str] log_level: (Updatable) Specifies the log level used to control logging output of execution logs. Enabling logging at a given level also enables logging at all higher levels.
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Enables pushing of execution logs to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket.

        Oracle recommends using the Oracle Cloud Infrastructure Logging service to enable, retrieve, and query execution logs for an API Deployment. If there is an active log object for the API Deployment and its category is set to 'execution' in Oracle Cloud Infrastructure Logging service, the logs will not be uploaded to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket.

        Please note that the functionality to push to the legacy Oracle Cloud Infrastructure Object Storage log archival bucket has been deprecated and will be removed in the future.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_enabled", value)

    @_builtins.property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Specifies the log level used to control logging output of execution logs. Enabling logging at a given level also enables logging at all higher levels.
        """
        return pulumi.get(self, "log_level")

    @log_level.setter
    def log_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_level", value)


if not MYPY:
    class DeploymentSpecificationRouteRequestPoliciesArgsDict(TypedDict):
        authorization: NotRequired[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesAuthorizationArgsDict']]
        """
        (Updatable) If authentication has been performed, validate whether the request scope (if any) applies to this route. If no RouteAuthorizationPolicy is defined for a route, a policy with a type of AUTHENTICATION_ONLY is applied.
        """
        body_validation: NotRequired[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesBodyValidationArgsDict']]
        """
        (Updatable) Validate the payload body of the incoming API requests on a specific route.
        """
        cors: NotRequired[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesCorsArgsDict']]
        """
        (Updatable) Enable CORS (Cross-Origin-Resource-Sharing) request handling.
        """
        header_transformations: NotRequired[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsArgsDict']]
        """
        (Updatable) A set of transformations to apply to HTTP headers that pass through the gateway.
        """
        header_validations: NotRequired[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderValidationsArgsDict']]
        """
        (Updatable) Validate the HTTP headers on the incoming API requests on a specific route.
        """
        query_parameter_transformations: NotRequired[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsArgsDict']]
        """
        (Updatable) A set of transformations to apply to query parameters that pass through the gateway.
        """
        query_parameter_validations: NotRequired[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsArgsDict']]
        """
        (Updatable) Validate the URL query parameters on the incoming API requests on a specific route.
        """
        response_cache_lookup: NotRequired[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesResponseCacheLookupArgsDict']]
        """
        (Updatable) Base policy for Response Cache lookup.
        """
elif False:
    DeploymentSpecificationRouteRequestPoliciesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteRequestPoliciesArgs:
    def __init__(__self__, *,
                 authorization: Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesAuthorizationArgs']] = None,
                 body_validation: Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesBodyValidationArgs']] = None,
                 cors: Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesCorsArgs']] = None,
                 header_transformations: Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsArgs']] = None,
                 header_validations: Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderValidationsArgs']] = None,
                 query_parameter_transformations: Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsArgs']] = None,
                 query_parameter_validations: Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsArgs']] = None,
                 response_cache_lookup: Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesResponseCacheLookupArgs']] = None):
        """
        :param pulumi.Input['DeploymentSpecificationRouteRequestPoliciesAuthorizationArgs'] authorization: (Updatable) If authentication has been performed, validate whether the request scope (if any) applies to this route. If no RouteAuthorizationPolicy is defined for a route, a policy with a type of AUTHENTICATION_ONLY is applied.
        :param pulumi.Input['DeploymentSpecificationRouteRequestPoliciesBodyValidationArgs'] body_validation: (Updatable) Validate the payload body of the incoming API requests on a specific route.
        :param pulumi.Input['DeploymentSpecificationRouteRequestPoliciesCorsArgs'] cors: (Updatable) Enable CORS (Cross-Origin-Resource-Sharing) request handling.
        :param pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsArgs'] header_transformations: (Updatable) A set of transformations to apply to HTTP headers that pass through the gateway.
        :param pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderValidationsArgs'] header_validations: (Updatable) Validate the HTTP headers on the incoming API requests on a specific route.
        :param pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsArgs'] query_parameter_transformations: (Updatable) A set of transformations to apply to query parameters that pass through the gateway.
        :param pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsArgs'] query_parameter_validations: (Updatable) Validate the URL query parameters on the incoming API requests on a specific route.
        :param pulumi.Input['DeploymentSpecificationRouteRequestPoliciesResponseCacheLookupArgs'] response_cache_lookup: (Updatable) Base policy for Response Cache lookup.
        """
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)
        if body_validation is not None:
            pulumi.set(__self__, "body_validation", body_validation)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if header_transformations is not None:
            pulumi.set(__self__, "header_transformations", header_transformations)
        if header_validations is not None:
            pulumi.set(__self__, "header_validations", header_validations)
        if query_parameter_transformations is not None:
            pulumi.set(__self__, "query_parameter_transformations", query_parameter_transformations)
        if query_parameter_validations is not None:
            pulumi.set(__self__, "query_parameter_validations", query_parameter_validations)
        if response_cache_lookup is not None:
            pulumi.set(__self__, "response_cache_lookup", response_cache_lookup)

    @_builtins.property
    @pulumi.getter
    def authorization(self) -> Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesAuthorizationArgs']]:
        """
        (Updatable) If authentication has been performed, validate whether the request scope (if any) applies to this route. If no RouteAuthorizationPolicy is defined for a route, a policy with a type of AUTHENTICATION_ONLY is applied.
        """
        return pulumi.get(self, "authorization")

    @authorization.setter
    def authorization(self, value: Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesAuthorizationArgs']]):
        pulumi.set(self, "authorization", value)

    @_builtins.property
    @pulumi.getter(name="bodyValidation")
    def body_validation(self) -> Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesBodyValidationArgs']]:
        """
        (Updatable) Validate the payload body of the incoming API requests on a specific route.
        """
        return pulumi.get(self, "body_validation")

    @body_validation.setter
    def body_validation(self, value: Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesBodyValidationArgs']]):
        pulumi.set(self, "body_validation", value)

    @_builtins.property
    @pulumi.getter
    def cors(self) -> Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesCorsArgs']]:
        """
        (Updatable) Enable CORS (Cross-Origin-Resource-Sharing) request handling.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesCorsArgs']]):
        pulumi.set(self, "cors", value)

    @_builtins.property
    @pulumi.getter(name="headerTransformations")
    def header_transformations(self) -> Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsArgs']]:
        """
        (Updatable) A set of transformations to apply to HTTP headers that pass through the gateway.
        """
        return pulumi.get(self, "header_transformations")

    @header_transformations.setter
    def header_transformations(self, value: Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsArgs']]):
        pulumi.set(self, "header_transformations", value)

    @_builtins.property
    @pulumi.getter(name="headerValidations")
    def header_validations(self) -> Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderValidationsArgs']]:
        """
        (Updatable) Validate the HTTP headers on the incoming API requests on a specific route.
        """
        return pulumi.get(self, "header_validations")

    @header_validations.setter
    def header_validations(self, value: Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderValidationsArgs']]):
        pulumi.set(self, "header_validations", value)

    @_builtins.property
    @pulumi.getter(name="queryParameterTransformations")
    def query_parameter_transformations(self) -> Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsArgs']]:
        """
        (Updatable) A set of transformations to apply to query parameters that pass through the gateway.
        """
        return pulumi.get(self, "query_parameter_transformations")

    @query_parameter_transformations.setter
    def query_parameter_transformations(self, value: Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsArgs']]):
        pulumi.set(self, "query_parameter_transformations", value)

    @_builtins.property
    @pulumi.getter(name="queryParameterValidations")
    def query_parameter_validations(self) -> Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsArgs']]:
        """
        (Updatable) Validate the URL query parameters on the incoming API requests on a specific route.
        """
        return pulumi.get(self, "query_parameter_validations")

    @query_parameter_validations.setter
    def query_parameter_validations(self, value: Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsArgs']]):
        pulumi.set(self, "query_parameter_validations", value)

    @_builtins.property
    @pulumi.getter(name="responseCacheLookup")
    def response_cache_lookup(self) -> Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesResponseCacheLookupArgs']]:
        """
        (Updatable) Base policy for Response Cache lookup.
        """
        return pulumi.get(self, "response_cache_lookup")

    @response_cache_lookup.setter
    def response_cache_lookup(self, value: Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesResponseCacheLookupArgs']]):
        pulumi.set(self, "response_cache_lookup", value)


if not MYPY:
    class DeploymentSpecificationRouteRequestPoliciesAuthorizationArgsDict(TypedDict):
        allowed_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) A user whose scope includes any of these access ranges is allowed on this route. Access ranges are case-sensitive.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Indicates how authorization should be applied. For a type of ANY_OF, an "allowedScope" property must also be specified. Otherwise, only a type is required. For a type of ANONYMOUS, an authenticated API must have the "isAnonymousAccessAllowed" property set to "true" in the authentication policy.
        """
elif False:
    DeploymentSpecificationRouteRequestPoliciesAuthorizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteRequestPoliciesAuthorizationArgs:
    def __init__(__self__, *,
                 allowed_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_scopes: (Updatable) A user whose scope includes any of these access ranges is allowed on this route. Access ranges are case-sensitive.
        :param pulumi.Input[_builtins.str] type: (Updatable) Indicates how authorization should be applied. For a type of ANY_OF, an "allowedScope" property must also be specified. Otherwise, only a type is required. For a type of ANONYMOUS, an authenticated API must have the "isAnonymousAccessAllowed" property set to "true" in the authentication policy.
        """
        if allowed_scopes is not None:
            pulumi.set(__self__, "allowed_scopes", allowed_scopes)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="allowedScopes")
    def allowed_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) A user whose scope includes any of these access ranges is allowed on this route. Access ranges are case-sensitive.
        """
        return pulumi.get(self, "allowed_scopes")

    @allowed_scopes.setter
    def allowed_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_scopes", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Indicates how authorization should be applied. For a type of ANY_OF, an "allowedScope" property must also be specified. Otherwise, only a type is required. For a type of ANONYMOUS, an authenticated API must have the "isAnonymousAccessAllowed" property set to "true" in the authentication policy.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DeploymentSpecificationRouteRequestPoliciesBodyValidationArgsDict(TypedDict):
        contents: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesBodyValidationContentArgsDict']]]]
        """
        (Updatable) The content of the request body.
        """
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Determines if the request body is required in the request.
        """
        validation_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Validation behavior mode.

        In `ENFORCING` mode, upon a validation failure, the request will be rejected with a 4xx response and not sent to the backend.

        In `PERMISSIVE` mode, the result of the validation will be exposed as metrics while the request will follow the normal path.

        `DISABLED` type turns the validation off.
        """
elif False:
    DeploymentSpecificationRouteRequestPoliciesBodyValidationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteRequestPoliciesBodyValidationArgs:
    def __init__(__self__, *,
                 contents: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesBodyValidationContentArgs']]]] = None,
                 required: Optional[pulumi.Input[_builtins.bool]] = None,
                 validation_mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesBodyValidationContentArgs']]] contents: (Updatable) The content of the request body.
        :param pulumi.Input[_builtins.bool] required: (Updatable) Determines if the request body is required in the request.
        :param pulumi.Input[_builtins.str] validation_mode: (Updatable) Validation behavior mode.
               
               In `ENFORCING` mode, upon a validation failure, the request will be rejected with a 4xx response and not sent to the backend.
               
               In `PERMISSIVE` mode, the result of the validation will be exposed as metrics while the request will follow the normal path.
               
               `DISABLED` type turns the validation off.
        """
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if validation_mode is not None:
            pulumi.set(__self__, "validation_mode", validation_mode)

    @_builtins.property
    @pulumi.getter
    def contents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesBodyValidationContentArgs']]]]:
        """
        (Updatable) The content of the request body.
        """
        return pulumi.get(self, "contents")

    @contents.setter
    def contents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesBodyValidationContentArgs']]]]):
        pulumi.set(self, "contents", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Determines if the request body is required in the request.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)

    @_builtins.property
    @pulumi.getter(name="validationMode")
    def validation_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Validation behavior mode.

        In `ENFORCING` mode, upon a validation failure, the request will be rejected with a 4xx response and not sent to the backend.

        In `PERMISSIVE` mode, the result of the validation will be exposed as metrics while the request will follow the normal path.

        `DISABLED` type turns the validation off.
        """
        return pulumi.get(self, "validation_mode")

    @validation_mode.setter
    def validation_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "validation_mode", value)


if not MYPY:
    class DeploymentSpecificationRouteRequestPoliciesBodyValidationContentArgsDict(TypedDict):
        media_type: pulumi.Input[_builtins.str]
        """
        (Updatable) The media_type is a [media type range](https://tools.ietf.org/html/rfc7231#appendix-D) subset restricted to the following schema

        media_type ::= ( / (  "*" "/" "*" ) / ( type "/" "*" ) / ( type "/" subtype ) )

        For requests that match multiple media types, only the most specific media type is applicable. e.g. `text/plain` overrides `text/*`
        """
        validation_type: pulumi.Input[_builtins.str]
        """
        (Updatable) Validation type defines the content validation method.

        Make the validation to first parse the body as the respective format.
        """
elif False:
    DeploymentSpecificationRouteRequestPoliciesBodyValidationContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteRequestPoliciesBodyValidationContentArgs:
    def __init__(__self__, *,
                 media_type: pulumi.Input[_builtins.str],
                 validation_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] media_type: (Updatable) The media_type is a [media type range](https://tools.ietf.org/html/rfc7231#appendix-D) subset restricted to the following schema
               
               media_type ::= ( / (  "*" "/" "*" ) / ( type "/" "*" ) / ( type "/" subtype ) )
               
               For requests that match multiple media types, only the most specific media type is applicable. e.g. `text/plain` overrides `text/*`
        :param pulumi.Input[_builtins.str] validation_type: (Updatable) Validation type defines the content validation method.
               
               Make the validation to first parse the body as the respective format.
        """
        pulumi.set(__self__, "media_type", media_type)
        pulumi.set(__self__, "validation_type", validation_type)

    @_builtins.property
    @pulumi.getter(name="mediaType")
    def media_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The media_type is a [media type range](https://tools.ietf.org/html/rfc7231#appendix-D) subset restricted to the following schema

        media_type ::= ( / (  "*" "/" "*" ) / ( type "/" "*" ) / ( type "/" subtype ) )

        For requests that match multiple media types, only the most specific media type is applicable. e.g. `text/plain` overrides `text/*`
        """
        return pulumi.get(self, "media_type")

    @media_type.setter
    def media_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "media_type", value)

    @_builtins.property
    @pulumi.getter(name="validationType")
    def validation_type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Validation type defines the content validation method.

        Make the validation to first parse the body as the respective format.
        """
        return pulumi.get(self, "validation_type")

    @validation_type.setter
    def validation_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "validation_type", value)


if not MYPY:
    class DeploymentSpecificationRouteRequestPoliciesCorsArgsDict(TypedDict):
        allowed_origins: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        (Updatable) The list of allowed origins that the CORS handler will use to respond to CORS requests. The gateway will send the Access-Control-Allow-Origin header with the best origin match for the circumstances. '*' will match any origins, and 'null' will match queries from 'file:' origins. All other origins must be qualified with the scheme, full hostname, and port if necessary.
        """
        allowed_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The list of headers that will be allowed from the client via the Access-Control-Allow-Headers header. '*' will allow all headers.
        """
        allowed_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The list of allowed HTTP methods that will be returned for the preflight OPTIONS request in the Access-Control-Allow-Methods header. '*' will allow all methods.
        """
        exposed_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) The list of headers that the client will be allowed to see from the response as indicated by the Access-Control-Expose-Headers header. '*' will expose all headers.
        """
        is_allow_credentials_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Whether to send the Access-Control-Allow-Credentials header to allow CORS requests with cookies.
        """
        max_age_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The time in seconds for the client to cache preflight responses. This is sent as the Access-Control-Max-Age if greater than 0.
        """
elif False:
    DeploymentSpecificationRouteRequestPoliciesCorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteRequestPoliciesCorsArgs:
    def __init__(__self__, *,
                 allowed_origins: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allowed_methods: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 exposed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 is_allow_credentials_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 max_age_in_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_origins: (Updatable) The list of allowed origins that the CORS handler will use to respond to CORS requests. The gateway will send the Access-Control-Allow-Origin header with the best origin match for the circumstances. '*' will match any origins, and 'null' will match queries from 'file:' origins. All other origins must be qualified with the scheme, full hostname, and port if necessary.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_headers: (Updatable) The list of headers that will be allowed from the client via the Access-Control-Allow-Headers header. '*' will allow all headers.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_methods: (Updatable) The list of allowed HTTP methods that will be returned for the preflight OPTIONS request in the Access-Control-Allow-Methods header. '*' will allow all methods.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exposed_headers: (Updatable) The list of headers that the client will be allowed to see from the response as indicated by the Access-Control-Expose-Headers header. '*' will expose all headers.
        :param pulumi.Input[_builtins.bool] is_allow_credentials_enabled: (Updatable) Whether to send the Access-Control-Allow-Credentials header to allow CORS requests with cookies.
        :param pulumi.Input[_builtins.int] max_age_in_seconds: (Updatable) The time in seconds for the client to cache preflight responses. This is sent as the Access-Control-Max-Age if greater than 0.
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if allowed_methods is not None:
            pulumi.set(__self__, "allowed_methods", allowed_methods)
        if exposed_headers is not None:
            pulumi.set(__self__, "exposed_headers", exposed_headers)
        if is_allow_credentials_enabled is not None:
            pulumi.set(__self__, "is_allow_credentials_enabled", is_allow_credentials_enabled)
        if max_age_in_seconds is not None:
            pulumi.set(__self__, "max_age_in_seconds", max_age_in_seconds)

    @_builtins.property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        (Updatable) The list of allowed origins that the CORS handler will use to respond to CORS requests. The gateway will send the Access-Control-Allow-Origin header with the best origin match for the circumstances. '*' will match any origins, and 'null' will match queries from 'file:' origins. All other origins must be qualified with the scheme, full hostname, and port if necessary.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "allowed_origins", value)

    @_builtins.property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The list of headers that will be allowed from the client via the Access-Control-Allow-Headers header. '*' will allow all headers.
        """
        return pulumi.get(self, "allowed_headers")

    @allowed_headers.setter
    def allowed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_headers", value)

    @_builtins.property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The list of allowed HTTP methods that will be returned for the preflight OPTIONS request in the Access-Control-Allow-Methods header. '*' will allow all methods.
        """
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_methods", value)

    @_builtins.property
    @pulumi.getter(name="exposedHeaders")
    def exposed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) The list of headers that the client will be allowed to see from the response as indicated by the Access-Control-Expose-Headers header. '*' will expose all headers.
        """
        return pulumi.get(self, "exposed_headers")

    @exposed_headers.setter
    def exposed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exposed_headers", value)

    @_builtins.property
    @pulumi.getter(name="isAllowCredentialsEnabled")
    def is_allow_credentials_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Whether to send the Access-Control-Allow-Credentials header to allow CORS requests with cookies.
        """
        return pulumi.get(self, "is_allow_credentials_enabled")

    @is_allow_credentials_enabled.setter
    def is_allow_credentials_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_allow_credentials_enabled", value)

    @_builtins.property
    @pulumi.getter(name="maxAgeInSeconds")
    def max_age_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The time in seconds for the client to cache preflight responses. This is sent as the Access-Control-Max-Age if greater than 0.
        """
        return pulumi.get(self, "max_age_in_seconds")

    @max_age_in_seconds.setter
    def max_age_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_age_in_seconds", value)


if not MYPY:
    class DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsArgsDict(TypedDict):
        filter_headers: NotRequired[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersArgsDict']]
        """
        (Updatable) Filter HTTP headers as they pass through the gateway.  The gateway applies filters after other transformations, so any headers set or renamed must also be listed here when using an ALLOW type policy.
        """
        rename_headers: NotRequired[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersArgsDict']]
        """
        (Updatable) Rename HTTP headers as they pass through the gateway.
        """
        set_headers: NotRequired[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersArgsDict']]
        """
        (Updatable) Set HTTP headers as they pass through the gateway.
        """
elif False:
    DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsArgs:
    def __init__(__self__, *,
                 filter_headers: Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersArgs']] = None,
                 rename_headers: Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersArgs']] = None,
                 set_headers: Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersArgs']] = None):
        """
        :param pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersArgs'] filter_headers: (Updatable) Filter HTTP headers as they pass through the gateway.  The gateway applies filters after other transformations, so any headers set or renamed must also be listed here when using an ALLOW type policy.
        :param pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersArgs'] rename_headers: (Updatable) Rename HTTP headers as they pass through the gateway.
        :param pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersArgs'] set_headers: (Updatable) Set HTTP headers as they pass through the gateway.
        """
        if filter_headers is not None:
            pulumi.set(__self__, "filter_headers", filter_headers)
        if rename_headers is not None:
            pulumi.set(__self__, "rename_headers", rename_headers)
        if set_headers is not None:
            pulumi.set(__self__, "set_headers", set_headers)

    @_builtins.property
    @pulumi.getter(name="filterHeaders")
    def filter_headers(self) -> Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersArgs']]:
        """
        (Updatable) Filter HTTP headers as they pass through the gateway.  The gateway applies filters after other transformations, so any headers set or renamed must also be listed here when using an ALLOW type policy.
        """
        return pulumi.get(self, "filter_headers")

    @filter_headers.setter
    def filter_headers(self, value: Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersArgs']]):
        pulumi.set(self, "filter_headers", value)

    @_builtins.property
    @pulumi.getter(name="renameHeaders")
    def rename_headers(self) -> Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersArgs']]:
        """
        (Updatable) Rename HTTP headers as they pass through the gateway.
        """
        return pulumi.get(self, "rename_headers")

    @rename_headers.setter
    def rename_headers(self, value: Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersArgs']]):
        pulumi.set(self, "rename_headers", value)

    @_builtins.property
    @pulumi.getter(name="setHeaders")
    def set_headers(self) -> Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersArgs']]:
        """
        (Updatable) Set HTTP headers as they pass through the gateway.
        """
        return pulumi.get(self, "set_headers")

    @set_headers.setter
    def set_headers(self, value: Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersArgs']]):
        pulumi.set(self, "set_headers", value)


if not MYPY:
    class DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersArgsDict(TypedDict):
        items: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersItemArgsDict']]]
        """
        (Updatable) The list of headers.
        """
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) BLOCK drops any headers that are in the list of items, so it acts as an exclusion list.  ALLOW permits only the headers in the list and removes all others, so it acts as an inclusion list.
        """
elif False:
    DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersItemArgs']]],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersItemArgs']]] items: (Updatable) The list of headers.
        :param pulumi.Input[_builtins.str] type: (Updatable) BLOCK drops any headers that are in the list of items, so it acts as an exclusion list.  ALLOW permits only the headers in the list and removes all others, so it acts as an inclusion list.
        """
        pulumi.set(__self__, "items", items)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersItemArgs']]]:
        """
        (Updatable) The list of headers.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersItemArgs']]]):
        pulumi.set(self, "items", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) BLOCK drops any headers that are in the list of items, so it acts as an exclusion list.  ALLOW permits only the headers in the list and removes all others, so it acts as an inclusion list.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersItemArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
elif False:
    DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersItemArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersArgsDict(TypedDict):
        items: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersItemArgsDict']]]
        """
        (Updatable) The list of headers.
        """
elif False:
    DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersItemArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersItemArgs']]] items: (Updatable) The list of headers.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersItemArgs']]]:
        """
        (Updatable) The list of headers.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersItemArgs']]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersItemArgsDict(TypedDict):
        from_: pulumi.Input[_builtins.str]
        """
        (Updatable) The original case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        to: pulumi.Input[_builtins.str]
        """
        (Updatable) The new name of the header.  This name must be unique across transformation policies.
        """
elif False:
    DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersItemArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input[_builtins.str],
                 to: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] from_: (Updatable) The original case-insensitive name of the header.  This name must be unique across transformation policies.
        :param pulumi.Input[_builtins.str] to: (Updatable) The new name of the header.  This name must be unique across transformation policies.
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The original case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The new name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "to", value)


if not MYPY:
    class DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersArgsDict(TypedDict):
        items: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersItemArgsDict']]]
        """
        (Updatable) The list of headers.
        """
elif False:
    DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersItemArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersItemArgs']]] items: (Updatable) The list of headers.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersItemArgs']]]:
        """
        (Updatable) The list of headers.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersItemArgs']]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersItemArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        (Updatable) A list of new values.  Each value can be a constant or may include one or more expressions enclosed within ${} delimiters.
        """
        if_exists: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) If a header with the same name already exists in the request, OVERWRITE will overwrite the value, APPEND will append to the existing value, or SKIP will keep the existing value.
        """
elif False:
    DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersItemArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 if_exists: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: (Updatable) A list of new values.  Each value can be a constant or may include one or more expressions enclosed within ${} delimiters.
        :param pulumi.Input[_builtins.str] if_exists: (Updatable) If a header with the same name already exists in the request, OVERWRITE will overwrite the value, APPEND will append to the existing value, or SKIP will keep the existing value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if if_exists is not None:
            pulumi.set(__self__, "if_exists", if_exists)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        (Updatable) A list of new values.  Each value can be a constant or may include one or more expressions enclosed within ${} delimiters.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter(name="ifExists")
    def if_exists(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) If a header with the same name already exists in the request, OVERWRITE will overwrite the value, APPEND will append to the existing value, or SKIP will keep the existing value.
        """
        return pulumi.get(self, "if_exists")

    @if_exists.setter
    def if_exists(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "if_exists", value)


if not MYPY:
    class DeploymentSpecificationRouteRequestPoliciesHeaderValidationsArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderValidationsHeaderArgsDict']]]]
        """
        (Updatable) The List of Headers
        """
        validation_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Validation behavior mode.

        In `ENFORCING` mode, upon a validation failure, the request will be rejected with a 4xx response and not sent to the backend.

        In `PERMISSIVE` mode, the result of the validation will be exposed as metrics while the request will follow the normal path.

        `DISABLED` type turns the validation off.
        """
elif False:
    DeploymentSpecificationRouteRequestPoliciesHeaderValidationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteRequestPoliciesHeaderValidationsArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderValidationsHeaderArgs']]]] = None,
                 validation_mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderValidationsHeaderArgs']]] headers: (Updatable) The List of Headers
        :param pulumi.Input[_builtins.str] validation_mode: (Updatable) Validation behavior mode.
               
               In `ENFORCING` mode, upon a validation failure, the request will be rejected with a 4xx response and not sent to the backend.
               
               In `PERMISSIVE` mode, the result of the validation will be exposed as metrics while the request will follow the normal path.
               
               `DISABLED` type turns the validation off.
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if validation_mode is not None:
            pulumi.set(__self__, "validation_mode", validation_mode)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderValidationsHeaderArgs']]]]:
        """
        (Updatable) The List of Headers
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesHeaderValidationsHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="validationMode")
    def validation_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Validation behavior mode.

        In `ENFORCING` mode, upon a validation failure, the request will be rejected with a 4xx response and not sent to the backend.

        In `PERMISSIVE` mode, the result of the validation will be exposed as metrics while the request will follow the normal path.

        `DISABLED` type turns the validation off.
        """
        return pulumi.get(self, "validation_mode")

    @validation_mode.setter
    def validation_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "validation_mode", value)


if not MYPY:
    class DeploymentSpecificationRouteRequestPoliciesHeaderValidationsHeaderArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        (Updatable) Parameter name.
        """
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Determines if the header is required in the request.
        """
elif False:
    DeploymentSpecificationRouteRequestPoliciesHeaderValidationsHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteRequestPoliciesHeaderValidationsHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 required: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) Parameter name.
        :param pulumi.Input[_builtins.bool] required: (Updatable) Determines if the header is required in the request.
        """
        pulumi.set(__self__, "name", name)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Parameter name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Determines if the header is required in the request.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)


if not MYPY:
    class DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsArgsDict(TypedDict):
        filter_query_parameters: NotRequired[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersArgsDict']]
        """
        (Updatable) Filter parameters from the query string as they pass through the gateway.  The gateway applies filters after other transformations, so any parameters set or renamed must also be listed here when using an ALLOW type policy.
        """
        rename_query_parameters: NotRequired[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersArgsDict']]
        """
        (Updatable) Rename parameters on the query string as they pass through the gateway.
        """
        set_query_parameters: NotRequired[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersArgsDict']]
        """
        (Updatable) Set parameters on the query string as they pass through the gateway.
        """
elif False:
    DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsArgs:
    def __init__(__self__, *,
                 filter_query_parameters: Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersArgs']] = None,
                 rename_query_parameters: Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersArgs']] = None,
                 set_query_parameters: Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersArgs']] = None):
        """
        :param pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersArgs'] filter_query_parameters: (Updatable) Filter parameters from the query string as they pass through the gateway.  The gateway applies filters after other transformations, so any parameters set or renamed must also be listed here when using an ALLOW type policy.
        :param pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersArgs'] rename_query_parameters: (Updatable) Rename parameters on the query string as they pass through the gateway.
        :param pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersArgs'] set_query_parameters: (Updatable) Set parameters on the query string as they pass through the gateway.
        """
        if filter_query_parameters is not None:
            pulumi.set(__self__, "filter_query_parameters", filter_query_parameters)
        if rename_query_parameters is not None:
            pulumi.set(__self__, "rename_query_parameters", rename_query_parameters)
        if set_query_parameters is not None:
            pulumi.set(__self__, "set_query_parameters", set_query_parameters)

    @_builtins.property
    @pulumi.getter(name="filterQueryParameters")
    def filter_query_parameters(self) -> Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersArgs']]:
        """
        (Updatable) Filter parameters from the query string as they pass through the gateway.  The gateway applies filters after other transformations, so any parameters set or renamed must also be listed here when using an ALLOW type policy.
        """
        return pulumi.get(self, "filter_query_parameters")

    @filter_query_parameters.setter
    def filter_query_parameters(self, value: Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersArgs']]):
        pulumi.set(self, "filter_query_parameters", value)

    @_builtins.property
    @pulumi.getter(name="renameQueryParameters")
    def rename_query_parameters(self) -> Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersArgs']]:
        """
        (Updatable) Rename parameters on the query string as they pass through the gateway.
        """
        return pulumi.get(self, "rename_query_parameters")

    @rename_query_parameters.setter
    def rename_query_parameters(self, value: Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersArgs']]):
        pulumi.set(self, "rename_query_parameters", value)

    @_builtins.property
    @pulumi.getter(name="setQueryParameters")
    def set_query_parameters(self) -> Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersArgs']]:
        """
        (Updatable) Set parameters on the query string as they pass through the gateway.
        """
        return pulumi.get(self, "set_query_parameters")

    @set_query_parameters.setter
    def set_query_parameters(self, value: Optional[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersArgs']]):
        pulumi.set(self, "set_query_parameters", value)


if not MYPY:
    class DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersArgsDict(TypedDict):
        items: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersItemArgsDict']]]
        """
        (Updatable) The list of query parameters.
        """
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) BLOCK drops any query parameters that are in the list of items, so it acts as an exclusion list.  ALLOW permits only the parameters in the list and removes all others, so it acts as an inclusion list.
        """
elif False:
    DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersItemArgs']]],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersItemArgs']]] items: (Updatable) The list of query parameters.
        :param pulumi.Input[_builtins.str] type: (Updatable) BLOCK drops any query parameters that are in the list of items, so it acts as an exclusion list.  ALLOW permits only the parameters in the list and removes all others, so it acts as an inclusion list.
        """
        pulumi.set(__self__, "items", items)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersItemArgs']]]:
        """
        (Updatable) The list of query parameters.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersItemArgs']]]):
        pulumi.set(self, "items", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) BLOCK drops any query parameters that are in the list of items, so it acts as an exclusion list.  ALLOW permits only the parameters in the list and removes all others, so it acts as an inclusion list.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersItemArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        (Updatable) The case-sensitive name of the query parameter.
        """
elif False:
    DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersItemArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) The case-sensitive name of the query parameter.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The case-sensitive name of the query parameter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersArgsDict(TypedDict):
        items: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersItemArgsDict']]]
        """
        (Updatable) The list of query parameters.
        """
elif False:
    DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersItemArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersItemArgs']]] items: (Updatable) The list of query parameters.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersItemArgs']]]:
        """
        (Updatable) The list of query parameters.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersItemArgs']]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersItemArgsDict(TypedDict):
        from_: pulumi.Input[_builtins.str]
        """
        (Updatable) The original case-sensitive name of the query parameter.  This name must be unique across transformation policies.
        """
        to: pulumi.Input[_builtins.str]
        """
        (Updatable) The new name of the query parameter.  This name must be unique across transformation policies.
        """
elif False:
    DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersItemArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input[_builtins.str],
                 to: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] from_: (Updatable) The original case-sensitive name of the query parameter.  This name must be unique across transformation policies.
        :param pulumi.Input[_builtins.str] to: (Updatable) The new name of the query parameter.  This name must be unique across transformation policies.
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The original case-sensitive name of the query parameter.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The new name of the query parameter.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "to", value)


if not MYPY:
    class DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersArgsDict(TypedDict):
        items: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersItemArgsDict']]]
        """
        (Updatable) The list of query parameters.
        """
elif False:
    DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersItemArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersItemArgs']]] items: (Updatable) The list of query parameters.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersItemArgs']]]:
        """
        (Updatable) The list of query parameters.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersItemArgs']]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersItemArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        (Updatable) The case-sensitive name of the query parameter.  This name must be unique across transformation policies.
        """
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        (Updatable) A list of new values.  Each value can be a constant or may include one or more expressions enclosed within ${} delimiters.
        """
        if_exists: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) If a query parameter with the same name already exists in the request, OVERWRITE will overwrite the value, APPEND will append to the existing value, or SKIP will keep the existing value.
        """
elif False:
    DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersItemArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 if_exists: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) The case-sensitive name of the query parameter.  This name must be unique across transformation policies.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: (Updatable) A list of new values.  Each value can be a constant or may include one or more expressions enclosed within ${} delimiters.
        :param pulumi.Input[_builtins.str] if_exists: (Updatable) If a query parameter with the same name already exists in the request, OVERWRITE will overwrite the value, APPEND will append to the existing value, or SKIP will keep the existing value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if if_exists is not None:
            pulumi.set(__self__, "if_exists", if_exists)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The case-sensitive name of the query parameter.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        (Updatable) A list of new values.  Each value can be a constant or may include one or more expressions enclosed within ${} delimiters.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter(name="ifExists")
    def if_exists(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) If a query parameter with the same name already exists in the request, OVERWRITE will overwrite the value, APPEND will append to the existing value, or SKIP will keep the existing value.
        """
        return pulumi.get(self, "if_exists")

    @if_exists.setter
    def if_exists(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "if_exists", value)


if not MYPY:
    class DeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsArgsDict(TypedDict):
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsParameterArgsDict']]]]
        """
        (Updatable) The List of Query Parameters
        """
        validation_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Validation behavior mode.

        In `ENFORCING` mode, upon a validation failure, the request will be rejected with a 4xx response and not sent to the backend.

        In `PERMISSIVE` mode, the result of the validation will be exposed as metrics while the request will follow the normal path.

        `DISABLED` type turns the validation off.
        """
elif False:
    DeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsArgs:
    def __init__(__self__, *,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsParameterArgs']]]] = None,
                 validation_mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsParameterArgs']]] parameters: (Updatable) The List of Query Parameters
        :param pulumi.Input[_builtins.str] validation_mode: (Updatable) Validation behavior mode.
               
               In `ENFORCING` mode, upon a validation failure, the request will be rejected with a 4xx response and not sent to the backend.
               
               In `PERMISSIVE` mode, the result of the validation will be exposed as metrics while the request will follow the normal path.
               
               `DISABLED` type turns the validation off.
        """
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if validation_mode is not None:
            pulumi.set(__self__, "validation_mode", validation_mode)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsParameterArgs']]]]:
        """
        (Updatable) The List of Query Parameters
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsParameterArgs']]]]):
        pulumi.set(self, "parameters", value)

    @_builtins.property
    @pulumi.getter(name="validationMode")
    def validation_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Validation behavior mode.

        In `ENFORCING` mode, upon a validation failure, the request will be rejected with a 4xx response and not sent to the backend.

        In `PERMISSIVE` mode, the result of the validation will be exposed as metrics while the request will follow the normal path.

        `DISABLED` type turns the validation off.
        """
        return pulumi.get(self, "validation_mode")

    @validation_mode.setter
    def validation_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "validation_mode", value)


if not MYPY:
    class DeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsParameterArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        (Updatable) Parameter name.
        """
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Determines if the parameter is required in the request.
        """
elif False:
    DeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 required: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) Parameter name.
        :param pulumi.Input[_builtins.bool] required: (Updatable) Determines if the parameter is required in the request.
        """
        pulumi.set(__self__, "name", name)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Parameter name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Determines if the parameter is required in the request.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)


if not MYPY:
    class DeploymentSpecificationRouteRequestPoliciesResponseCacheLookupArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of the Response Cache Store Policy.
        """
        cache_key_additions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Updatable) A list of context expressions whose values will be added to the base cache key. Values should contain an expression enclosed within ${} delimiters. Only the request context is available.
        """
        is_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Whether this policy is currently enabled.
        """
        is_private_caching_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Set true to allow caching responses where the request has an Authorization header. Ensure you have configured your  cache key additions to get the level of isolation across authenticated requests that you require.

        When false, any request with an Authorization header will not be stored in the Response Cache.

        If using the CustomAuthenticationPolicy then the tokenHeader/tokenQueryParam are also subject to this check.
        """
elif False:
    DeploymentSpecificationRouteRequestPoliciesResponseCacheLookupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteRequestPoliciesResponseCacheLookupArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 cache_key_additions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 is_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_private_caching_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] type: (Updatable) Type of the Response Cache Store Policy.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] cache_key_additions: (Updatable) A list of context expressions whose values will be added to the base cache key. Values should contain an expression enclosed within ${} delimiters. Only the request context is available.
        :param pulumi.Input[_builtins.bool] is_enabled: (Updatable) Whether this policy is currently enabled.
        :param pulumi.Input[_builtins.bool] is_private_caching_enabled: (Updatable) Set true to allow caching responses where the request has an Authorization header. Ensure you have configured your  cache key additions to get the level of isolation across authenticated requests that you require.
               
               When false, any request with an Authorization header will not be stored in the Response Cache.
               
               If using the CustomAuthenticationPolicy then the tokenHeader/tokenQueryParam are also subject to this check.
        """
        pulumi.set(__self__, "type", type)
        if cache_key_additions is not None:
            pulumi.set(__self__, "cache_key_additions", cache_key_additions)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_private_caching_enabled is not None:
            pulumi.set(__self__, "is_private_caching_enabled", is_private_caching_enabled)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of the Response Cache Store Policy.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="cacheKeyAdditions")
    def cache_key_additions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) A list of context expressions whose values will be added to the base cache key. Values should contain an expression enclosed within ${} delimiters. Only the request context is available.
        """
        return pulumi.get(self, "cache_key_additions")

    @cache_key_additions.setter
    def cache_key_additions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "cache_key_additions", value)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Whether this policy is currently enabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_enabled", value)

    @_builtins.property
    @pulumi.getter(name="isPrivateCachingEnabled")
    def is_private_caching_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Set true to allow caching responses where the request has an Authorization header. Ensure you have configured your  cache key additions to get the level of isolation across authenticated requests that you require.

        When false, any request with an Authorization header will not be stored in the Response Cache.

        If using the CustomAuthenticationPolicy then the tokenHeader/tokenQueryParam are also subject to this check.
        """
        return pulumi.get(self, "is_private_caching_enabled")

    @is_private_caching_enabled.setter
    def is_private_caching_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_private_caching_enabled", value)


if not MYPY:
    class DeploymentSpecificationRouteResponsePoliciesArgsDict(TypedDict):
        header_transformations: NotRequired[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsArgsDict']]
        """
        (Updatable) A set of transformations to apply to HTTP headers that pass through the gateway.
        """
        response_cache_store: NotRequired[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesResponseCacheStoreArgsDict']]
        """
        (Updatable) Base policy for how a response from a backend is cached in the Response Cache.
        """
elif False:
    DeploymentSpecificationRouteResponsePoliciesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteResponsePoliciesArgs:
    def __init__(__self__, *,
                 header_transformations: Optional[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsArgs']] = None,
                 response_cache_store: Optional[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesResponseCacheStoreArgs']] = None):
        """
        :param pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsArgs'] header_transformations: (Updatable) A set of transformations to apply to HTTP headers that pass through the gateway.
        :param pulumi.Input['DeploymentSpecificationRouteResponsePoliciesResponseCacheStoreArgs'] response_cache_store: (Updatable) Base policy for how a response from a backend is cached in the Response Cache.
        """
        if header_transformations is not None:
            pulumi.set(__self__, "header_transformations", header_transformations)
        if response_cache_store is not None:
            pulumi.set(__self__, "response_cache_store", response_cache_store)

    @_builtins.property
    @pulumi.getter(name="headerTransformations")
    def header_transformations(self) -> Optional[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsArgs']]:
        """
        (Updatable) A set of transformations to apply to HTTP headers that pass through the gateway.
        """
        return pulumi.get(self, "header_transformations")

    @header_transformations.setter
    def header_transformations(self, value: Optional[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsArgs']]):
        pulumi.set(self, "header_transformations", value)

    @_builtins.property
    @pulumi.getter(name="responseCacheStore")
    def response_cache_store(self) -> Optional[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesResponseCacheStoreArgs']]:
        """
        (Updatable) Base policy for how a response from a backend is cached in the Response Cache.
        """
        return pulumi.get(self, "response_cache_store")

    @response_cache_store.setter
    def response_cache_store(self, value: Optional[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesResponseCacheStoreArgs']]):
        pulumi.set(self, "response_cache_store", value)


if not MYPY:
    class DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsArgsDict(TypedDict):
        filter_headers: NotRequired[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersArgsDict']]
        """
        (Updatable) Filter HTTP headers as they pass through the gateway.  The gateway applies filters after other transformations, so any headers set or renamed must also be listed here when using an ALLOW type policy.
        """
        rename_headers: NotRequired[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersArgsDict']]
        """
        (Updatable) Rename HTTP headers as they pass through the gateway.
        """
        set_headers: NotRequired[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersArgsDict']]
        """
        (Updatable) Set HTTP headers as they pass through the gateway.
        """
elif False:
    DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsArgs:
    def __init__(__self__, *,
                 filter_headers: Optional[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersArgs']] = None,
                 rename_headers: Optional[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersArgs']] = None,
                 set_headers: Optional[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersArgs']] = None):
        """
        :param pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersArgs'] filter_headers: (Updatable) Filter HTTP headers as they pass through the gateway.  The gateway applies filters after other transformations, so any headers set or renamed must also be listed here when using an ALLOW type policy.
        :param pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersArgs'] rename_headers: (Updatable) Rename HTTP headers as they pass through the gateway.
        :param pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersArgs'] set_headers: (Updatable) Set HTTP headers as they pass through the gateway.
        """
        if filter_headers is not None:
            pulumi.set(__self__, "filter_headers", filter_headers)
        if rename_headers is not None:
            pulumi.set(__self__, "rename_headers", rename_headers)
        if set_headers is not None:
            pulumi.set(__self__, "set_headers", set_headers)

    @_builtins.property
    @pulumi.getter(name="filterHeaders")
    def filter_headers(self) -> Optional[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersArgs']]:
        """
        (Updatable) Filter HTTP headers as they pass through the gateway.  The gateway applies filters after other transformations, so any headers set or renamed must also be listed here when using an ALLOW type policy.
        """
        return pulumi.get(self, "filter_headers")

    @filter_headers.setter
    def filter_headers(self, value: Optional[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersArgs']]):
        pulumi.set(self, "filter_headers", value)

    @_builtins.property
    @pulumi.getter(name="renameHeaders")
    def rename_headers(self) -> Optional[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersArgs']]:
        """
        (Updatable) Rename HTTP headers as they pass through the gateway.
        """
        return pulumi.get(self, "rename_headers")

    @rename_headers.setter
    def rename_headers(self, value: Optional[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersArgs']]):
        pulumi.set(self, "rename_headers", value)

    @_builtins.property
    @pulumi.getter(name="setHeaders")
    def set_headers(self) -> Optional[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersArgs']]:
        """
        (Updatable) Set HTTP headers as they pass through the gateway.
        """
        return pulumi.get(self, "set_headers")

    @set_headers.setter
    def set_headers(self, value: Optional[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersArgs']]):
        pulumi.set(self, "set_headers", value)


if not MYPY:
    class DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersArgsDict(TypedDict):
        items: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersItemArgsDict']]]
        """
        (Updatable) The list of headers.
        """
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) BLOCK drops any headers that are in the list of items, so it acts as an exclusion list.  ALLOW permits only the headers in the list and removes all others, so it acts as an inclusion list.
        """
elif False:
    DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersItemArgs']]],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersItemArgs']]] items: (Updatable) The list of headers.
        :param pulumi.Input[_builtins.str] type: (Updatable) BLOCK drops any headers that are in the list of items, so it acts as an exclusion list.  ALLOW permits only the headers in the list and removes all others, so it acts as an inclusion list.
        """
        pulumi.set(__self__, "items", items)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersItemArgs']]]:
        """
        (Updatable) The list of headers.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersItemArgs']]]):
        pulumi.set(self, "items", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) BLOCK drops any headers that are in the list of items, so it acts as an exclusion list.  ALLOW permits only the headers in the list and removes all others, so it acts as an inclusion list.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersItemArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
elif False:
    DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersItemArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersArgsDict(TypedDict):
        items: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersItemArgsDict']]]
        """
        (Updatable) The list of headers.
        """
elif False:
    DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersItemArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersItemArgs']]] items: (Updatable) The list of headers.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersItemArgs']]]:
        """
        (Updatable) The list of headers.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersItemArgs']]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersItemArgsDict(TypedDict):
        from_: pulumi.Input[_builtins.str]
        """
        (Updatable) The original case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        to: pulumi.Input[_builtins.str]
        """
        (Updatable) The new name of the header.  This name must be unique across transformation policies.
        """
elif False:
    DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersItemArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input[_builtins.str],
                 to: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] from_: (Updatable) The original case-insensitive name of the header.  This name must be unique across transformation policies.
        :param pulumi.Input[_builtins.str] to: (Updatable) The new name of the header.  This name must be unique across transformation policies.
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The original case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The new name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "to", value)


if not MYPY:
    class DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersArgsDict(TypedDict):
        items: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersItemArgsDict']]]
        """
        (Updatable) The list of headers.
        """
elif False:
    DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersItemArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersItemArgs']]] items: (Updatable) The list of headers.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersItemArgs']]]:
        """
        (Updatable) The list of headers.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersItemArgs']]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersItemArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        (Updatable) A list of new values.  Each value can be a constant or may include one or more expressions enclosed within ${} delimiters.
        """
        if_exists: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) If a header with the same name already exists in the request, OVERWRITE will overwrite the value, APPEND will append to the existing value, or SKIP will keep the existing value.
        """
elif False:
    DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersItemArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 if_exists: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: (Updatable) A list of new values.  Each value can be a constant or may include one or more expressions enclosed within ${} delimiters.
        :param pulumi.Input[_builtins.str] if_exists: (Updatable) If a header with the same name already exists in the request, OVERWRITE will overwrite the value, APPEND will append to the existing value, or SKIP will keep the existing value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if if_exists is not None:
            pulumi.set(__self__, "if_exists", if_exists)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        (Updatable) A list of new values.  Each value can be a constant or may include one or more expressions enclosed within ${} delimiters.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter(name="ifExists")
    def if_exists(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) If a header with the same name already exists in the request, OVERWRITE will overwrite the value, APPEND will append to the existing value, or SKIP will keep the existing value.
        """
        return pulumi.get(self, "if_exists")

    @if_exists.setter
    def if_exists(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "if_exists", value)


if not MYPY:
    class DeploymentSpecificationRouteResponsePoliciesResponseCacheStoreArgsDict(TypedDict):
        time_to_live_in_seconds: pulumi.Input[_builtins.int]
        """
        (Updatable) Sets the number of seconds for a response from a backend being stored in the Response Cache before it expires.
        """
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of the Response Cache Store Policy.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    DeploymentSpecificationRouteResponsePoliciesResponseCacheStoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentSpecificationRouteResponsePoliciesResponseCacheStoreArgs:
    def __init__(__self__, *,
                 time_to_live_in_seconds: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] time_to_live_in_seconds: (Updatable) Sets the number of seconds for a response from a backend being stored in the Response Cache before it expires.
        :param pulumi.Input[_builtins.str] type: (Updatable) Type of the Response Cache Store Policy.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "time_to_live_in_seconds", time_to_live_in_seconds)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="timeToLiveInSeconds")
    def time_to_live_in_seconds(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) Sets the number of seconds for a response from a backend being stored in the Response Cache before it expires.
        """
        return pulumi.get(self, "time_to_live_in_seconds")

    @time_to_live_in_seconds.setter
    def time_to_live_in_seconds(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "time_to_live_in_seconds", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of the Response Cache Store Policy.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GatewayCaBundleArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of the CA bundle
        """
        ca_bundle_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the resource.
        """
        certificate_authority_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the resource.
        """
elif False:
    GatewayCaBundleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayCaBundleArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 ca_bundle_id: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_authority_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: (Updatable) Type of the CA bundle
        :param pulumi.Input[_builtins.str] ca_bundle_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the resource.
        :param pulumi.Input[_builtins.str] certificate_authority_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the resource.
        """
        pulumi.set(__self__, "type", type)
        if ca_bundle_id is not None:
            pulumi.set(__self__, "ca_bundle_id", ca_bundle_id)
        if certificate_authority_id is not None:
            pulumi.set(__self__, "certificate_authority_id", certificate_authority_id)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of the CA bundle
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="caBundleId")
    def ca_bundle_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the resource.
        """
        return pulumi.get(self, "ca_bundle_id")

    @ca_bundle_id.setter
    def ca_bundle_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ca_bundle_id", value)

    @_builtins.property
    @pulumi.getter(name="certificateAuthorityId")
    def certificate_authority_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the resource.
        """
        return pulumi.get(self, "certificate_authority_id")

    @certificate_authority_id.setter
    def certificate_authority_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_authority_id", value)


if not MYPY:
    class GatewayIpAddressArgsDict(TypedDict):
        ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        An IP address.
        """
elif False:
    GatewayIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayIpAddressArgs:
    def __init__(__self__, *,
                 ip_address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ip_address: An IP address.
        """
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An IP address.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_address", value)


if not MYPY:
    class GatewayLockArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of the lock.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        """
        related_resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        """
        time_created: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time this resource was created. An RFC3339 formatted datetime string.
        """
elif False:
    GatewayLockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayLockArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 related_resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 time_created: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of the lock.
        :param pulumi.Input[_builtins.str] message: A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        :param pulumi.Input[_builtins.str] related_resource_id: The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        :param pulumi.Input[_builtins.str] time_created: The time this resource was created. An RFC3339 formatted datetime string.
        """
        pulumi.set(__self__, "type", type)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if related_resource_id is not None:
            pulumi.set(__self__, "related_resource_id", related_resource_id)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of the lock.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter(name="relatedResourceId")
    def related_resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        """
        return pulumi.get(self, "related_resource_id")

    @related_resource_id.setter
    def related_resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "related_resource_id", value)

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time this resource was created. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_created", value)


if not MYPY:
    class GatewayResponseCacheDetailsArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        (Updatable) Type of the Response Cache.
        """
        authentication_secret_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Vault Service secret resource.
        """
        authentication_secret_version_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The version number of the authentication secret to use.
        """
        connect_timeout_in_ms: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Defines the timeout for establishing a connection with the Response Cache.
        """
        is_ssl_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Defines if the connection should be over SSL.
        """
        is_ssl_verify_disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Defines whether or not to uphold SSL verification.
        """
        read_timeout_in_ms: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Defines the timeout for reading data from the Response Cache.
        """
        send_timeout_in_ms: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) Defines the timeout for transmitting data to the Response Cache.
        """
        servers: NotRequired[pulumi.Input[Sequence[pulumi.Input['GatewayResponseCacheDetailsServerArgsDict']]]]
        """
        (Updatable) The set of cache store members to connect to. At present only a single server is supported.
        """
elif False:
    GatewayResponseCacheDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayResponseCacheDetailsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 authentication_secret_id: Optional[pulumi.Input[_builtins.str]] = None,
                 authentication_secret_version_number: Optional[pulumi.Input[_builtins.str]] = None,
                 connect_timeout_in_ms: Optional[pulumi.Input[_builtins.int]] = None,
                 is_ssl_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_ssl_verify_disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 read_timeout_in_ms: Optional[pulumi.Input[_builtins.int]] = None,
                 send_timeout_in_ms: Optional[pulumi.Input[_builtins.int]] = None,
                 servers: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayResponseCacheDetailsServerArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] type: (Updatable) Type of the Response Cache.
        :param pulumi.Input[_builtins.str] authentication_secret_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Vault Service secret resource.
        :param pulumi.Input[_builtins.str] authentication_secret_version_number: (Updatable) The version number of the authentication secret to use.
        :param pulumi.Input[_builtins.int] connect_timeout_in_ms: (Updatable) Defines the timeout for establishing a connection with the Response Cache.
        :param pulumi.Input[_builtins.bool] is_ssl_enabled: (Updatable) Defines if the connection should be over SSL.
        :param pulumi.Input[_builtins.bool] is_ssl_verify_disabled: (Updatable) Defines whether or not to uphold SSL verification.
        :param pulumi.Input[_builtins.int] read_timeout_in_ms: (Updatable) Defines the timeout for reading data from the Response Cache.
        :param pulumi.Input[_builtins.int] send_timeout_in_ms: (Updatable) Defines the timeout for transmitting data to the Response Cache.
        :param pulumi.Input[Sequence[pulumi.Input['GatewayResponseCacheDetailsServerArgs']]] servers: (Updatable) The set of cache store members to connect to. At present only a single server is supported.
        """
        pulumi.set(__self__, "type", type)
        if authentication_secret_id is not None:
            pulumi.set(__self__, "authentication_secret_id", authentication_secret_id)
        if authentication_secret_version_number is not None:
            pulumi.set(__self__, "authentication_secret_version_number", authentication_secret_version_number)
        if connect_timeout_in_ms is not None:
            pulumi.set(__self__, "connect_timeout_in_ms", connect_timeout_in_ms)
        if is_ssl_enabled is not None:
            pulumi.set(__self__, "is_ssl_enabled", is_ssl_enabled)
        if is_ssl_verify_disabled is not None:
            pulumi.set(__self__, "is_ssl_verify_disabled", is_ssl_verify_disabled)
        if read_timeout_in_ms is not None:
            pulumi.set(__self__, "read_timeout_in_ms", read_timeout_in_ms)
        if send_timeout_in_ms is not None:
            pulumi.set(__self__, "send_timeout_in_ms", send_timeout_in_ms)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) Type of the Response Cache.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="authenticationSecretId")
    def authentication_secret_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Vault Service secret resource.
        """
        return pulumi.get(self, "authentication_secret_id")

    @authentication_secret_id.setter
    def authentication_secret_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authentication_secret_id", value)

    @_builtins.property
    @pulumi.getter(name="authenticationSecretVersionNumber")
    def authentication_secret_version_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The version number of the authentication secret to use.
        """
        return pulumi.get(self, "authentication_secret_version_number")

    @authentication_secret_version_number.setter
    def authentication_secret_version_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authentication_secret_version_number", value)

    @_builtins.property
    @pulumi.getter(name="connectTimeoutInMs")
    def connect_timeout_in_ms(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Defines the timeout for establishing a connection with the Response Cache.
        """
        return pulumi.get(self, "connect_timeout_in_ms")

    @connect_timeout_in_ms.setter
    def connect_timeout_in_ms(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "connect_timeout_in_ms", value)

    @_builtins.property
    @pulumi.getter(name="isSslEnabled")
    def is_ssl_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Defines if the connection should be over SSL.
        """
        return pulumi.get(self, "is_ssl_enabled")

    @is_ssl_enabled.setter
    def is_ssl_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_ssl_enabled", value)

    @_builtins.property
    @pulumi.getter(name="isSslVerifyDisabled")
    def is_ssl_verify_disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Defines whether or not to uphold SSL verification.
        """
        return pulumi.get(self, "is_ssl_verify_disabled")

    @is_ssl_verify_disabled.setter
    def is_ssl_verify_disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_ssl_verify_disabled", value)

    @_builtins.property
    @pulumi.getter(name="readTimeoutInMs")
    def read_timeout_in_ms(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Defines the timeout for reading data from the Response Cache.
        """
        return pulumi.get(self, "read_timeout_in_ms")

    @read_timeout_in_ms.setter
    def read_timeout_in_ms(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "read_timeout_in_ms", value)

    @_builtins.property
    @pulumi.getter(name="sendTimeoutInMs")
    def send_timeout_in_ms(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) Defines the timeout for transmitting data to the Response Cache.
        """
        return pulumi.get(self, "send_timeout_in_ms")

    @send_timeout_in_ms.setter
    def send_timeout_in_ms(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "send_timeout_in_ms", value)

    @_builtins.property
    @pulumi.getter
    def servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewayResponseCacheDetailsServerArgs']]]]:
        """
        (Updatable) The set of cache store members to connect to. At present only a single server is supported.
        """
        return pulumi.get(self, "servers")

    @servers.setter
    def servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayResponseCacheDetailsServerArgs']]]]):
        pulumi.set(self, "servers", value)


if not MYPY:
    class GatewayResponseCacheDetailsServerArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) Hostname or IP address (IPv4 only) where the cache store is running.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The port the cache store is exposed on.
        """
elif False:
    GatewayResponseCacheDetailsServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayResponseCacheDetailsServerArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] host: (Updatable) Hostname or IP address (IPv4 only) where the cache store is running.
        :param pulumi.Input[_builtins.int] port: (Updatable) The port the cache store is exposed on.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) Hostname or IP address (IPv4 only) where the cache store is running.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The port the cache store is exposed on.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class SubscriberClientArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        (Updatable) The name of the client. Must be unique within a subscriber.
        """
        token: pulumi.Input[_builtins.str]
        """
        (Updatable) The token for the client. Must be unique within a tenancy.
        """
elif False:
    SubscriberClientArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriberClientArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) The name of the client. Must be unique within a subscriber.
        :param pulumi.Input[_builtins.str] token: (Updatable) The token for the client. Must be unique within a tenancy.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The name of the client. Must be unique within a subscriber.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The token for the client. Must be unique within a tenancy.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)


if not MYPY:
    class SubscriberLockArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of the lock.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        """
        related_resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        """
        time_created: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time this resource was created. An RFC3339 formatted datetime string.
        """
elif False:
    SubscriberLockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriberLockArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 related_resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 time_created: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of the lock.
        :param pulumi.Input[_builtins.str] message: A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        :param pulumi.Input[_builtins.str] related_resource_id: The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        :param pulumi.Input[_builtins.str] time_created: The time this resource was created. An RFC3339 formatted datetime string.
        """
        pulumi.set(__self__, "type", type)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if related_resource_id is not None:
            pulumi.set(__self__, "related_resource_id", related_resource_id)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of the lock.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter(name="relatedResourceId")
    def related_resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        """
        return pulumi.get(self, "related_resource_id")

    @related_resource_id.setter
    def related_resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "related_resource_id", value)

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time this resource was created. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_created", value)


if not MYPY:
    class UsagePlanEntitlementArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        (Updatable) An entitlement name, unique within a usage plan.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A user-friendly description. To provide some insight about the resource. Avoid entering confidential information.
        """
        quota: NotRequired[pulumi.Input['UsagePlanEntitlementQuotaArgsDict']]
        """
        (Updatable) Quota policy for a usage plan.
        """
        rate_limit: NotRequired[pulumi.Input['UsagePlanEntitlementRateLimitArgsDict']]
        """
        (Updatable) Rate-limiting policy for a usage plan.
        """
        targets: NotRequired[pulumi.Input[Sequence[pulumi.Input['UsagePlanEntitlementTargetArgsDict']]]]
        """
        (Updatable) A collection of targeted deployments that the entitlement will be applied to.
        """
elif False:
    UsagePlanEntitlementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UsagePlanEntitlementArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 quota: Optional[pulumi.Input['UsagePlanEntitlementQuotaArgs']] = None,
                 rate_limit: Optional[pulumi.Input['UsagePlanEntitlementRateLimitArgs']] = None,
                 targets: Optional[pulumi.Input[Sequence[pulumi.Input['UsagePlanEntitlementTargetArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) An entitlement name, unique within a usage plan.
        :param pulumi.Input[_builtins.str] description: (Updatable) A user-friendly description. To provide some insight about the resource. Avoid entering confidential information.
        :param pulumi.Input['UsagePlanEntitlementQuotaArgs'] quota: (Updatable) Quota policy for a usage plan.
        :param pulumi.Input['UsagePlanEntitlementRateLimitArgs'] rate_limit: (Updatable) Rate-limiting policy for a usage plan.
        :param pulumi.Input[Sequence[pulumi.Input['UsagePlanEntitlementTargetArgs']]] targets: (Updatable) A collection of targeted deployments that the entitlement will be applied to.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if quota is not None:
            pulumi.set(__self__, "quota", quota)
        if rate_limit is not None:
            pulumi.set(__self__, "rate_limit", rate_limit)
        if targets is not None:
            pulumi.set(__self__, "targets", targets)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) An entitlement name, unique within a usage plan.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A user-friendly description. To provide some insight about the resource. Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def quota(self) -> Optional[pulumi.Input['UsagePlanEntitlementQuotaArgs']]:
        """
        (Updatable) Quota policy for a usage plan.
        """
        return pulumi.get(self, "quota")

    @quota.setter
    def quota(self, value: Optional[pulumi.Input['UsagePlanEntitlementQuotaArgs']]):
        pulumi.set(self, "quota", value)

    @_builtins.property
    @pulumi.getter(name="rateLimit")
    def rate_limit(self) -> Optional[pulumi.Input['UsagePlanEntitlementRateLimitArgs']]:
        """
        (Updatable) Rate-limiting policy for a usage plan.
        """
        return pulumi.get(self, "rate_limit")

    @rate_limit.setter
    def rate_limit(self, value: Optional[pulumi.Input['UsagePlanEntitlementRateLimitArgs']]):
        pulumi.set(self, "rate_limit", value)

    @_builtins.property
    @pulumi.getter
    def targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UsagePlanEntitlementTargetArgs']]]]:
        """
        (Updatable) A collection of targeted deployments that the entitlement will be applied to.
        """
        return pulumi.get(self, "targets")

    @targets.setter
    def targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UsagePlanEntitlementTargetArgs']]]]):
        pulumi.set(self, "targets", value)


if not MYPY:
    class UsagePlanEntitlementQuotaArgsDict(TypedDict):
        operation_on_breach: pulumi.Input[_builtins.str]
        """
        (Updatable) What the usage plan will do when a quota is breached: `REJECT` will allow no further requests `ALLOW` will continue to allow further requests
        """
        reset_policy: pulumi.Input[_builtins.str]
        """
        (Updatable) The policy that controls when quotas will reset. Example: `CALENDAR`
        """
        unit: pulumi.Input[_builtins.str]
        """
        (Updatable) The unit of time over which quotas are calculated. Example: `MINUTE` or `MONTH`
        """
        value: pulumi.Input[_builtins.int]
        """
        (Updatable) The number of requests that can be made per time period.
        """
elif False:
    UsagePlanEntitlementQuotaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UsagePlanEntitlementQuotaArgs:
    def __init__(__self__, *,
                 operation_on_breach: pulumi.Input[_builtins.str],
                 reset_policy: pulumi.Input[_builtins.str],
                 unit: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] operation_on_breach: (Updatable) What the usage plan will do when a quota is breached: `REJECT` will allow no further requests `ALLOW` will continue to allow further requests
        :param pulumi.Input[_builtins.str] reset_policy: (Updatable) The policy that controls when quotas will reset. Example: `CALENDAR`
        :param pulumi.Input[_builtins.str] unit: (Updatable) The unit of time over which quotas are calculated. Example: `MINUTE` or `MONTH`
        :param pulumi.Input[_builtins.int] value: (Updatable) The number of requests that can be made per time period.
        """
        pulumi.set(__self__, "operation_on_breach", operation_on_breach)
        pulumi.set(__self__, "reset_policy", reset_policy)
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="operationOnBreach")
    def operation_on_breach(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) What the usage plan will do when a quota is breached: `REJECT` will allow no further requests `ALLOW` will continue to allow further requests
        """
        return pulumi.get(self, "operation_on_breach")

    @operation_on_breach.setter
    def operation_on_breach(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operation_on_breach", value)

    @_builtins.property
    @pulumi.getter(name="resetPolicy")
    def reset_policy(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The policy that controls when quotas will reset. Example: `CALENDAR`
        """
        return pulumi.get(self, "reset_policy")

    @reset_policy.setter
    def reset_policy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "reset_policy", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The unit of time over which quotas are calculated. Example: `MINUTE` or `MONTH`
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "unit", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) The number of requests that can be made per time period.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class UsagePlanEntitlementRateLimitArgsDict(TypedDict):
        unit: pulumi.Input[_builtins.str]
        """
        (Updatable) The unit of time over which rate limits are calculated. Example: `SECOND`
        """
        value: pulumi.Input[_builtins.int]
        """
        (Updatable) The number of requests that can be made per time period.
        """
elif False:
    UsagePlanEntitlementRateLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UsagePlanEntitlementRateLimitArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] unit: (Updatable) The unit of time over which rate limits are calculated. Example: `SECOND`
        :param pulumi.Input[_builtins.int] value: (Updatable) The number of requests that can be made per time period.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The unit of time over which rate limits are calculated. Example: `SECOND`
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "unit", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.int]:
        """
        (Updatable) The number of requests that can be made per time period.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class UsagePlanEntitlementTargetArgsDict(TypedDict):
        deployment_id: pulumi.Input[_builtins.str]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of a deployment resource.
        """
elif False:
    UsagePlanEntitlementTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UsagePlanEntitlementTargetArgs:
    def __init__(__self__, *,
                 deployment_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] deployment_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of a deployment resource.
        """
        pulumi.set(__self__, "deployment_id", deployment_id)

    @_builtins.property
    @pulumi.getter(name="deploymentId")
    def deployment_id(self) -> pulumi.Input[_builtins.str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of a deployment resource.
        """
        return pulumi.get(self, "deployment_id")

    @deployment_id.setter
    def deployment_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "deployment_id", value)


if not MYPY:
    class UsagePlanLockArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of the lock.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        """
        related_resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        """
        time_created: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time this resource was created. An RFC3339 formatted datetime string.
        """
elif False:
    UsagePlanLockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UsagePlanLockArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 related_resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 time_created: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of the lock.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param pulumi.Input[_builtins.str] message: A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        :param pulumi.Input[_builtins.str] related_resource_id: The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        :param pulumi.Input[_builtins.str] time_created: The time this resource was created. An RFC3339 formatted datetime string.
        """
        pulumi.set(__self__, "type", type)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if related_resource_id is not None:
            pulumi.set(__self__, "related_resource_id", related_resource_id)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of the lock.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter(name="relatedResourceId")
    def related_resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The id of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
        """
        return pulumi.get(self, "related_resource_id")

    @related_resource_id.setter
    def related_resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "related_resource_id", value)

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time this resource was created. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_created", value)


if not MYPY:
    class GetApisFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        Name of the validation.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetApisFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApisFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Name of the validation.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the validation.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetCertificatesFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetCertificatesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCertificatesFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDeploymentsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        values: Sequence[_builtins.str]
        """
        A list of new values.  Each value can be a constant or may include one or more expressions enclosed within ${} delimiters.
        """
        regex: NotRequired[_builtins.bool]
elif False:
    GetDeploymentsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDeploymentsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The case-insensitive name of the header.  This name must be unique across transformation policies.
        :param Sequence[_builtins.str] values: A list of new values.  Each value can be a constant or may include one or more expressions enclosed within ${} delimiters.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        A list of new values.  Each value can be a constant or may include one or more expressions enclosed within ${} delimiters.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetGatewaysFilterArgsDict(TypedDict):
        name: _builtins.str
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetGatewaysFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGatewaysFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSubscribersFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The name of the client. Must be unique within a subscriber.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetSubscribersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSubscribersFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name of the client. Must be unique within a subscriber.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the client. Must be unique within a subscriber.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetUsagePlansFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        An entitlement name, unique within a usage plan.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetUsagePlansFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetUsagePlansFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: An entitlement name, unique within a usage plan.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        An entitlement name, unique within a usage plan.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


