# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ConfigConfigArgs',
    'ConfigConfigArgsDict',
    'ConfigConfigConfigMapArgs',
    'ConfigConfigConfigMapArgsDict',
    'ConfigDimensionArgs',
    'ConfigDimensionArgsDict',
    'ConfigInUseByArgs',
    'ConfigInUseByArgsDict',
    'ConfigMetricArgs',
    'ConfigMetricArgsDict',
    'ConfigOverridesArgs',
    'ConfigOverridesArgsDict',
    'ConfigOverridesOverrideListArgs',
    'ConfigOverridesOverrideListArgsDict',
    'ConfigRuleArgs',
    'ConfigRuleArgsDict',
    'GetConfigsFilterArgs',
    'GetConfigsFilterArgsDict',
]

MYPY = False

if not MYPY:
    class ConfigConfigArgsDict(TypedDict):
        config_maps: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConfigConfigConfigMapArgsDict']]]]
        """
        (Updatable) Map of an agent configuration file.
        """
elif False:
    ConfigConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigConfigArgs:
    def __init__(__self__, *,
                 config_maps: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigConfigConfigMapArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ConfigConfigConfigMapArgs']]] config_maps: (Updatable) Map of an agent configuration file.
        """
        if config_maps is not None:
            pulumi.set(__self__, "config_maps", config_maps)

    @_builtins.property
    @pulumi.getter(name="configMaps")
    def config_maps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConfigConfigConfigMapArgs']]]]:
        """
        (Updatable) Map of an agent configuration file.
        """
        return pulumi.get(self, "config_maps")

    @config_maps.setter
    def config_maps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigConfigConfigMapArgs']]]]):
        pulumi.set(self, "config_maps", value)


if not MYPY:
    class ConfigConfigConfigMapArgsDict(TypedDict):
        body: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Base64 encoded agent configuration file.
        """
        content_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The MIME Content-Type that describes the content of the body field, for example, text/yaml or text/yaml; charset=utf-8
        """
        file_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) An agent configuration file name.
        """
elif False:
    ConfigConfigConfigMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigConfigConfigMapArgs:
    def __init__(__self__, *,
                 body: Optional[pulumi.Input[_builtins.str]] = None,
                 content_type: Optional[pulumi.Input[_builtins.str]] = None,
                 file_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] body: The Base64 encoded agent configuration file.
        :param pulumi.Input[_builtins.str] content_type: (Updatable) The MIME Content-Type that describes the content of the body field, for example, text/yaml or text/yaml; charset=utf-8
        :param pulumi.Input[_builtins.str] file_name: (Updatable) An agent configuration file name.
        """
        if body is not None:
            pulumi.set(__self__, "body", body)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Base64 encoded agent configuration file.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The MIME Content-Type that describes the content of the body field, for example, text/yaml or text/yaml; charset=utf-8
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content_type", value)

    @_builtins.property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) An agent configuration file name.
        """
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "file_name", value)


if not MYPY:
    class ConfigDimensionArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the dimension.
        """
        value_source: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The source to populate the dimension. This must not be specified.
        """
elif False:
    ConfigDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigDimensionArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value_source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) The name of the dimension.
        :param pulumi.Input[_builtins.str] value_source: (Updatable) The source to populate the dimension. This must not be specified.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value_source is not None:
            pulumi.set(__self__, "value_source", value_source)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the dimension.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="valueSource")
    def value_source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The source to populate the dimension. This must not be specified.
        """
        return pulumi.get(self, "value_source")

    @value_source.setter
    def value_source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value_source", value)


if not MYPY:
    class ConfigInUseByArgsDict(TypedDict):
        config_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The type of configuration item.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name by which a configuration entity is displayed to the end user.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the configuration item. An OCID is generated when the item is created.
        """
        options_group: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that specifies the group that an OPTIONS item belongs to.
        """
elif False:
    ConfigInUseByArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigInUseByArgs:
    def __init__(__self__, *,
                 config_type: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 options_group: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] config_type: (Updatable) The type of configuration item.
        :param pulumi.Input[_builtins.str] display_name: (Updatable) The name by which a configuration entity is displayed to the end user.
        :param pulumi.Input[_builtins.str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the configuration item. An OCID is generated when the item is created.
        :param pulumi.Input[_builtins.str] options_group: A string that specifies the group that an OPTIONS item belongs to.
        """
        if config_type is not None:
            pulumi.set(__self__, "config_type", config_type)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if options_group is not None:
            pulumi.set(__self__, "options_group", options_group)

    @_builtins.property
    @pulumi.getter(name="configType")
    def config_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The type of configuration item.
        """
        return pulumi.get(self, "config_type")

    @config_type.setter
    def config_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "config_type", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name by which a configuration entity is displayed to the end user.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the configuration item. An OCID is generated when the item is created.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="optionsGroup")
    def options_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that specifies the group that an OPTIONS item belongs to.
        """
        return pulumi.get(self, "options_group")

    @options_group.setter
    def options_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "options_group", value)


if not MYPY:
    class ConfigMetricArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A description of the metric.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the metric. This must be a known metric name.
        """
        unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The unit of the metric.
        """
        value_source: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) This must not be set.
        """
elif False:
    ConfigMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigMetricArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None,
                 value_source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: (Updatable) A description of the metric.
        :param pulumi.Input[_builtins.str] name: (Updatable) The name of the metric. This must be a known metric name.
        :param pulumi.Input[_builtins.str] unit: (Updatable) The unit of the metric.
        :param pulumi.Input[_builtins.str] value_source: (Updatable) This must not be set.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)
        if value_source is not None:
            pulumi.set(__self__, "value_source", value_source)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A description of the metric.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the metric. This must be a known metric name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The unit of the metric.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)

    @_builtins.property
    @pulumi.getter(name="valueSource")
    def value_source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) This must not be set.
        """
        return pulumi.get(self, "value_source")

    @value_source.setter
    def value_source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value_source", value)


if not MYPY:
    class ConfigOverridesArgsDict(TypedDict):
        override_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConfigOverridesOverrideListArgsDict']]]]
        """
        (Updatable)
        """
elif False:
    ConfigOverridesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigOverridesArgs:
    def __init__(__self__, *,
                 override_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigOverridesOverrideListArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ConfigOverridesOverrideListArgs']]] override_lists: (Updatable)
        """
        if override_lists is not None:
            pulumi.set(__self__, "override_lists", override_lists)

    @_builtins.property
    @pulumi.getter(name="overrideLists")
    def override_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConfigOverridesOverrideListArgs']]]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "override_lists")

    @override_lists.setter
    def override_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigOverridesOverrideListArgs']]]]):
        pulumi.set(self, "override_lists", value)


if not MYPY:
    class ConfigOverridesOverrideListArgsDict(TypedDict):
        agent_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The string that defines the Agent Filter expression.
        """
        override_map: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        (Updatable) A map whose key is a substitution variable specified within the configuration's body. For example, if below was specified in the configuration's body {{ isJfrEnabled | default false }} Then a valid map key would be "isJfrEnabled". The value is typically different than the default specified in the configuration's body. Thus, in this example, the map entry could be "isJfrEnabled": true
        """
elif False:
    ConfigOverridesOverrideListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigOverridesOverrideListArgs:
    def __init__(__self__, *,
                 agent_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 override_map: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] agent_filter: (Updatable) The string that defines the Agent Filter expression.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] override_map: (Updatable) A map whose key is a substitution variable specified within the configuration's body. For example, if below was specified in the configuration's body {{ isJfrEnabled | default false }} Then a valid map key would be "isJfrEnabled". The value is typically different than the default specified in the configuration's body. Thus, in this example, the map entry could be "isJfrEnabled": true
        """
        if agent_filter is not None:
            pulumi.set(__self__, "agent_filter", agent_filter)
        if override_map is not None:
            pulumi.set(__self__, "override_map", override_map)

    @_builtins.property
    @pulumi.getter(name="agentFilter")
    def agent_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The string that defines the Agent Filter expression.
        """
        return pulumi.get(self, "agent_filter")

    @agent_filter.setter
    def agent_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "agent_filter", value)

    @_builtins.property
    @pulumi.getter(name="overrideMap")
    def override_map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Updatable) A map whose key is a substitution variable specified within the configuration's body. For example, if below was specified in the configuration's body {{ isJfrEnabled | default false }} Then a valid map key would be "isJfrEnabled". The value is typically different than the default specified in the configuration's body. Thus, in this example, the map entry could be "isJfrEnabled": true
        """
        return pulumi.get(self, "override_map")

    @override_map.setter
    def override_map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "override_map", value)


if not MYPY:
    class ConfigRuleArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name by which a configuration entity is displayed to the end user.
        """
        filter_text: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The string that defines the Span Filter expression.
        """
        is_apply_to_error_spans: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Specifies whether an Apdex score should be computed for error spans. Setting it to "true" means that the Apdex score is computed in the usual way. Setting it to "false" skips the Apdex computation and sets the Apdex score to "frustrating" regardless of the configured thresholds. The default is "false".
        """
        is_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Specifies whether the Apdex score should be computed for spans matching the rule. This can be used to disable Apdex score for spans that do not need or require it. The default is "true".
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The priority controls the order in which multiple rules in a rule set are applied. Lower values indicate higher priorities. Rules with higher priority are applied first, and once a match is found, the rest of the rules are ignored. Rules within the same rule set cannot have the same priority.
        """
        satisfied_response_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The maximum response time in milliseconds that is considered "satisfactory" for the end user.
        """
        tolerating_response_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The maximum response time in milliseconds that is considered "tolerable" for the end user. A response time beyond this threshold is considered "frustrating". This value cannot be lower than "satisfiedResponseTime".
        """
elif False:
    ConfigRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigRuleArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 filter_text: Optional[pulumi.Input[_builtins.str]] = None,
                 is_apply_to_error_spans: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 priority: Optional[pulumi.Input[_builtins.int]] = None,
                 satisfied_response_time: Optional[pulumi.Input[_builtins.int]] = None,
                 tolerating_response_time: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: (Updatable) The name by which a configuration entity is displayed to the end user.
        :param pulumi.Input[_builtins.str] filter_text: (Updatable) The string that defines the Span Filter expression.
        :param pulumi.Input[_builtins.bool] is_apply_to_error_spans: (Updatable) Specifies whether an Apdex score should be computed for error spans. Setting it to "true" means that the Apdex score is computed in the usual way. Setting it to "false" skips the Apdex computation and sets the Apdex score to "frustrating" regardless of the configured thresholds. The default is "false".
        :param pulumi.Input[_builtins.bool] is_enabled: (Updatable) Specifies whether the Apdex score should be computed for spans matching the rule. This can be used to disable Apdex score for spans that do not need or require it. The default is "true".
        :param pulumi.Input[_builtins.int] priority: (Updatable) The priority controls the order in which multiple rules in a rule set are applied. Lower values indicate higher priorities. Rules with higher priority are applied first, and once a match is found, the rest of the rules are ignored. Rules within the same rule set cannot have the same priority.
        :param pulumi.Input[_builtins.int] satisfied_response_time: (Updatable) The maximum response time in milliseconds that is considered "satisfactory" for the end user.
        :param pulumi.Input[_builtins.int] tolerating_response_time: (Updatable) The maximum response time in milliseconds that is considered "tolerable" for the end user. A response time beyond this threshold is considered "frustrating". This value cannot be lower than "satisfiedResponseTime".
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if filter_text is not None:
            pulumi.set(__self__, "filter_text", filter_text)
        if is_apply_to_error_spans is not None:
            pulumi.set(__self__, "is_apply_to_error_spans", is_apply_to_error_spans)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if satisfied_response_time is not None:
            pulumi.set(__self__, "satisfied_response_time", satisfied_response_time)
        if tolerating_response_time is not None:
            pulumi.set(__self__, "tolerating_response_time", tolerating_response_time)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name by which a configuration entity is displayed to the end user.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="filterText")
    def filter_text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The string that defines the Span Filter expression.
        """
        return pulumi.get(self, "filter_text")

    @filter_text.setter
    def filter_text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "filter_text", value)

    @_builtins.property
    @pulumi.getter(name="isApplyToErrorSpans")
    def is_apply_to_error_spans(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Specifies whether an Apdex score should be computed for error spans. Setting it to "true" means that the Apdex score is computed in the usual way. Setting it to "false" skips the Apdex computation and sets the Apdex score to "frustrating" regardless of the configured thresholds. The default is "false".
        """
        return pulumi.get(self, "is_apply_to_error_spans")

    @is_apply_to_error_spans.setter
    def is_apply_to_error_spans(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_apply_to_error_spans", value)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Specifies whether the Apdex score should be computed for spans matching the rule. This can be used to disable Apdex score for spans that do not need or require it. The default is "true".
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_enabled", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The priority controls the order in which multiple rules in a rule set are applied. Lower values indicate higher priorities. Rules with higher priority are applied first, and once a match is found, the rest of the rules are ignored. Rules within the same rule set cannot have the same priority.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter(name="satisfiedResponseTime")
    def satisfied_response_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The maximum response time in milliseconds that is considered "satisfactory" for the end user.
        """
        return pulumi.get(self, "satisfied_response_time")

    @satisfied_response_time.setter
    def satisfied_response_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "satisfied_response_time", value)

    @_builtins.property
    @pulumi.getter(name="toleratingResponseTime")
    def tolerating_response_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The maximum response time in milliseconds that is considered "tolerable" for the end user. A response time beyond this threshold is considered "frustrating". This value cannot be lower than "satisfiedResponseTime".
        """
        return pulumi.get(self, "tolerating_response_time")

    @tolerating_response_time.setter
    def tolerating_response_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "tolerating_response_time", value)


if not MYPY:
    class GetConfigsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The name of the metric. This must be a known metric name.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetConfigsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetConfigsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name of the metric. This must be a known metric name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the metric. This must be a known metric name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


