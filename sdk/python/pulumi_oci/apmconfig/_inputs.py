# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ConfigDimensionArgs',
    'ConfigDimensionArgsDict',
    'ConfigInUseByArgs',
    'ConfigInUseByArgsDict',
    'ConfigMetricArgs',
    'ConfigMetricArgsDict',
    'ConfigRuleArgs',
    'ConfigRuleArgsDict',
    'GetConfigsFilterArgs',
    'GetConfigsFilterArgsDict',
]

MYPY = False

if not MYPY:
    class ConfigDimensionArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the dimension.
        """
        value_source: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The source to populate the dimension. This must not be specified.
        """
elif False:
    ConfigDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigDimensionArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value_source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: (Updatable) The name of the dimension.
        :param pulumi.Input[_builtins.str] value_source: (Updatable) The source to populate the dimension. This must not be specified.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value_source is not None:
            pulumi.set(__self__, "value_source", value_source)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the dimension.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="valueSource")
    def value_source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The source to populate the dimension. This must not be specified.
        """
        return pulumi.get(self, "value_source")

    @value_source.setter
    def value_source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value_source", value)


if not MYPY:
    class ConfigInUseByArgsDict(TypedDict):
        config_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The type of configuration item.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name by which a configuration entity is displayed to the end user.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the configuration item. An OCID is generated when the item is created.
        """
        options_group: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that specifies the group that an OPTIONS item belongs to.
        """
elif False:
    ConfigInUseByArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigInUseByArgs:
    def __init__(__self__, *,
                 config_type: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 options_group: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] config_type: (Updatable) The type of configuration item.
        :param pulumi.Input[_builtins.str] display_name: (Updatable) The name by which a configuration entity is displayed to the end user.
        :param pulumi.Input[_builtins.str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the configuration item. An OCID is generated when the item is created.
        :param pulumi.Input[_builtins.str] options_group: A string that specifies the group that an OPTIONS item belongs to.
        """
        if config_type is not None:
            pulumi.set(__self__, "config_type", config_type)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if options_group is not None:
            pulumi.set(__self__, "options_group", options_group)

    @_builtins.property
    @pulumi.getter(name="configType")
    def config_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The type of configuration item.
        """
        return pulumi.get(self, "config_type")

    @config_type.setter
    def config_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "config_type", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name by which a configuration entity is displayed to the end user.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the configuration item. An OCID is generated when the item is created.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="optionsGroup")
    def options_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that specifies the group that an OPTIONS item belongs to.
        """
        return pulumi.get(self, "options_group")

    @options_group.setter
    def options_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "options_group", value)


if not MYPY:
    class ConfigMetricArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) A description of the metric.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name of the metric. This must be a known metric name.
        """
        unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The unit of the metric.
        """
        value_source: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) This must not be set.
        """
elif False:
    ConfigMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigMetricArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None,
                 value_source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: (Updatable) A description of the metric.
        :param pulumi.Input[_builtins.str] name: (Updatable) The name of the metric. This must be a known metric name.
        :param pulumi.Input[_builtins.str] unit: (Updatable) The unit of the metric.
        :param pulumi.Input[_builtins.str] value_source: (Updatable) This must not be set.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)
        if value_source is not None:
            pulumi.set(__self__, "value_source", value_source)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) A description of the metric.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name of the metric. This must be a known metric name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The unit of the metric.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)

    @_builtins.property
    @pulumi.getter(name="valueSource")
    def value_source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) This must not be set.
        """
        return pulumi.get(self, "value_source")

    @value_source.setter
    def value_source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value_source", value)


if not MYPY:
    class ConfigRuleArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The name by which a configuration entity is displayed to the end user.
        """
        filter_text: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Updatable) The string that defines the Span Filter expression.
        """
        is_apply_to_error_spans: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Specifies whether an Apdex score should be computed for error spans. Setting it to "true" means that the Apdex score is computed in the usual way. Setting it to "false" skips the Apdex computation and sets the Apdex score to "frustrating" regardless of the configured thresholds. The default is "false".
        """
        is_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Updatable) Specifies whether the Apdex score should be computed for spans matching the rule. This can be used to disable Apdex score for spans that do not need or require it. The default is "true".
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The priority controls the order in which multiple rules in a rule set are applied. Lower values indicate higher priorities. Rules with higher priority are applied first, and once a match is found, the rest of the rules are ignored. Rules within the same rule set cannot have the same priority.
        """
        satisfied_response_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The maximum response time in milliseconds that is considered "satisfactory" for the end user.
        """
        tolerating_response_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Updatable) The maximum response time in milliseconds that is considered "tolerable" for the end user. A response time beyond this threshold is considered "frustrating". This value cannot be lower than "satisfiedResponseTime". 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    ConfigRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigRuleArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 filter_text: Optional[pulumi.Input[_builtins.str]] = None,
                 is_apply_to_error_spans: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 priority: Optional[pulumi.Input[_builtins.int]] = None,
                 satisfied_response_time: Optional[pulumi.Input[_builtins.int]] = None,
                 tolerating_response_time: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: (Updatable) The name by which a configuration entity is displayed to the end user.
        :param pulumi.Input[_builtins.str] filter_text: (Updatable) The string that defines the Span Filter expression.
        :param pulumi.Input[_builtins.bool] is_apply_to_error_spans: (Updatable) Specifies whether an Apdex score should be computed for error spans. Setting it to "true" means that the Apdex score is computed in the usual way. Setting it to "false" skips the Apdex computation and sets the Apdex score to "frustrating" regardless of the configured thresholds. The default is "false".
        :param pulumi.Input[_builtins.bool] is_enabled: (Updatable) Specifies whether the Apdex score should be computed for spans matching the rule. This can be used to disable Apdex score for spans that do not need or require it. The default is "true".
        :param pulumi.Input[_builtins.int] priority: (Updatable) The priority controls the order in which multiple rules in a rule set are applied. Lower values indicate higher priorities. Rules with higher priority are applied first, and once a match is found, the rest of the rules are ignored. Rules within the same rule set cannot have the same priority.
        :param pulumi.Input[_builtins.int] satisfied_response_time: (Updatable) The maximum response time in milliseconds that is considered "satisfactory" for the end user.
        :param pulumi.Input[_builtins.int] tolerating_response_time: (Updatable) The maximum response time in milliseconds that is considered "tolerable" for the end user. A response time beyond this threshold is considered "frustrating". This value cannot be lower than "satisfiedResponseTime". 
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if filter_text is not None:
            pulumi.set(__self__, "filter_text", filter_text)
        if is_apply_to_error_spans is not None:
            pulumi.set(__self__, "is_apply_to_error_spans", is_apply_to_error_spans)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if satisfied_response_time is not None:
            pulumi.set(__self__, "satisfied_response_time", satisfied_response_time)
        if tolerating_response_time is not None:
            pulumi.set(__self__, "tolerating_response_time", tolerating_response_time)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The name by which a configuration entity is displayed to the end user.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="filterText")
    def filter_text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Updatable) The string that defines the Span Filter expression.
        """
        return pulumi.get(self, "filter_text")

    @filter_text.setter
    def filter_text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "filter_text", value)

    @_builtins.property
    @pulumi.getter(name="isApplyToErrorSpans")
    def is_apply_to_error_spans(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Specifies whether an Apdex score should be computed for error spans. Setting it to "true" means that the Apdex score is computed in the usual way. Setting it to "false" skips the Apdex computation and sets the Apdex score to "frustrating" regardless of the configured thresholds. The default is "false".
        """
        return pulumi.get(self, "is_apply_to_error_spans")

    @is_apply_to_error_spans.setter
    def is_apply_to_error_spans(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_apply_to_error_spans", value)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Updatable) Specifies whether the Apdex score should be computed for spans matching the rule. This can be used to disable Apdex score for spans that do not need or require it. The default is "true".
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_enabled", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The priority controls the order in which multiple rules in a rule set are applied. Lower values indicate higher priorities. Rules with higher priority are applied first, and once a match is found, the rest of the rules are ignored. Rules within the same rule set cannot have the same priority.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter(name="satisfiedResponseTime")
    def satisfied_response_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The maximum response time in milliseconds that is considered "satisfactory" for the end user.
        """
        return pulumi.get(self, "satisfied_response_time")

    @satisfied_response_time.setter
    def satisfied_response_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "satisfied_response_time", value)

    @_builtins.property
    @pulumi.getter(name="toleratingResponseTime")
    def tolerating_response_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Updatable) The maximum response time in milliseconds that is considered "tolerable" for the end user. A response time beyond this threshold is considered "frustrating". This value cannot be lower than "satisfiedResponseTime". 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "tolerating_response_time")

    @tolerating_response_time.setter
    def tolerating_response_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "tolerating_response_time", value)


if not MYPY:
    class GetConfigsFilterArgsDict(TypedDict):
        name: _builtins.str
        """
        The name of the metric. This must be a known metric name.
        """
        values: Sequence[_builtins.str]
        regex: NotRequired[_builtins.bool]
elif False:
    GetConfigsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetConfigsFilterArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name of the metric. This must be a known metric name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the metric. This must be a known metric name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "regex", value)


