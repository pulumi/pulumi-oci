# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'ConfigDimension',
    'ConfigMetric',
    'ConfigRule',
    'GetConfigDimensionResult',
    'GetConfigMetricResult',
    'GetConfigRuleResult',
    'GetConfigsConfigCollectionResult',
    'GetConfigsConfigCollectionItemResult',
    'GetConfigsConfigCollectionItemDimensionResult',
    'GetConfigsConfigCollectionItemMetricResult',
    'GetConfigsConfigCollectionItemRuleResult',
    'GetConfigsFilterResult',
]

@pulumi.output_type
class ConfigDimension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueSource":
            suggest = "value_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value_source: Optional[str] = None):
        """
        :param str name: (Updatable) The name of the metric
        :param str value_source: (Updatable) Must be NULL at the moment, and "name" must be a known metric.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value_source is not None:
            pulumi.set(__self__, "value_source", value_source)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        (Updatable) The name of the metric
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="valueSource")
    def value_source(self) -> Optional[str]:
        """
        (Updatable) Must be NULL at the moment, and "name" must be a known metric.
        """
        return pulumi.get(self, "value_source")


@pulumi.output_type
class ConfigMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueSource":
            suggest = "value_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 name: Optional[str] = None,
                 unit: Optional[str] = None,
                 value_source: Optional[str] = None):
        """
        :param str description: (Updatable) A description of the metric
        :param str name: (Updatable) The name of the metric
        :param str unit: (Updatable) The unit of the metric
        :param str value_source: (Updatable) Must be NULL at the moment, and "name" must be a known metric.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)
        if value_source is not None:
            pulumi.set(__self__, "value_source", value_source)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        (Updatable) A description of the metric
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        (Updatable) The name of the metric
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        """
        (Updatable) The unit of the metric
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter(name="valueSource")
    def value_source(self) -> Optional[str]:
        """
        (Updatable) Must be NULL at the moment, and "name" must be a known metric.
        """
        return pulumi.get(self, "value_source")


@pulumi.output_type
class ConfigRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "filterText":
            suggest = "filter_text"
        elif key == "isApplyToErrorSpans":
            suggest = "is_apply_to_error_spans"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "satisfiedResponseTime":
            suggest = "satisfied_response_time"
        elif key == "toleratingResponseTime":
            suggest = "tolerating_response_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: Optional[str] = None,
                 filter_text: Optional[str] = None,
                 is_apply_to_error_spans: Optional[bool] = None,
                 is_enabled: Optional[bool] = None,
                 priority: Optional[int] = None,
                 satisfied_response_time: Optional[int] = None,
                 tolerating_response_time: Optional[int] = None):
        """
        :param str display_name: (Updatable) A user-friendly name that provides a short description this rule.
        :param str filter_text: (Updatable) The string that defines the Span Filter expression.
        :param bool is_apply_to_error_spans: (Updatable) If true, the rule will compute the actual Apdex score for spans that have been marked as errors. If false, the rule will always set the Apdex for error spans to frustrating, regardless of the configured thresholds. Default is false.
        :param bool is_enabled: (Updatable) Specifies if the Apdex rule will be computed for spans matching the rule. Can be used to make sure certain spans don't get an Apdex score. The default is "true".
        :param int priority: (Updatable) The priority controls the order in which multiple rules in a rule set are applied. Lower values indicate higher priorities. Rules with higher priority are applied first, and once a match is found, the rest of the rules are ignored. Rules within the same rule set cannot have the same priority.
        :param int satisfied_response_time: (Updatable) The maximum response time in milliseconds that will be considered satisfactory for the end user.
        :param int tolerating_response_time: (Updatable) The maximum response time in milliseconds that will be considered tolerable for the end user. Response times beyond this threshold will be considered frustrating. This value cannot be lower than "satisfiedResponseTime".
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if filter_text is not None:
            pulumi.set(__self__, "filter_text", filter_text)
        if is_apply_to_error_spans is not None:
            pulumi.set(__self__, "is_apply_to_error_spans", is_apply_to_error_spans)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if satisfied_response_time is not None:
            pulumi.set(__self__, "satisfied_response_time", satisfied_response_time)
        if tolerating_response_time is not None:
            pulumi.set(__self__, "tolerating_response_time", tolerating_response_time)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        (Updatable) A user-friendly name that provides a short description this rule.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="filterText")
    def filter_text(self) -> Optional[str]:
        """
        (Updatable) The string that defines the Span Filter expression.
        """
        return pulumi.get(self, "filter_text")

    @property
    @pulumi.getter(name="isApplyToErrorSpans")
    def is_apply_to_error_spans(self) -> Optional[bool]:
        """
        (Updatable) If true, the rule will compute the actual Apdex score for spans that have been marked as errors. If false, the rule will always set the Apdex for error spans to frustrating, regardless of the configured thresholds. Default is false.
        """
        return pulumi.get(self, "is_apply_to_error_spans")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        (Updatable) Specifies if the Apdex rule will be computed for spans matching the rule. Can be used to make sure certain spans don't get an Apdex score. The default is "true".
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        (Updatable) The priority controls the order in which multiple rules in a rule set are applied. Lower values indicate higher priorities. Rules with higher priority are applied first, and once a match is found, the rest of the rules are ignored. Rules within the same rule set cannot have the same priority.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="satisfiedResponseTime")
    def satisfied_response_time(self) -> Optional[int]:
        """
        (Updatable) The maximum response time in milliseconds that will be considered satisfactory for the end user.
        """
        return pulumi.get(self, "satisfied_response_time")

    @property
    @pulumi.getter(name="toleratingResponseTime")
    def tolerating_response_time(self) -> Optional[int]:
        """
        (Updatable) The maximum response time in milliseconds that will be considered tolerable for the end user. Response times beyond this threshold will be considered frustrating. This value cannot be lower than "satisfiedResponseTime".
        """
        return pulumi.get(self, "tolerating_response_time")


@pulumi.output_type
class GetConfigDimensionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value_source: str):
        """
        :param str name: The name of the metric
        :param str value_source: Must be NULL at the moment, and "name" must be a known metric.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value_source", value_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the metric
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="valueSource")
    def value_source(self) -> str:
        """
        Must be NULL at the moment, and "name" must be a known metric.
        """
        return pulumi.get(self, "value_source")


@pulumi.output_type
class GetConfigMetricResult(dict):
    def __init__(__self__, *,
                 description: str,
                 name: str,
                 unit: str,
                 value_source: str):
        """
        :param str description: A description of the metric
        :param str name: The name of the metric
        :param str unit: The unit of the metric
        :param str value_source: Must be NULL at the moment, and "name" must be a known metric.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value_source", value_source)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A description of the metric
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the metric
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        The unit of the metric
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter(name="valueSource")
    def value_source(self) -> str:
        """
        Must be NULL at the moment, and "name" must be a known metric.
        """
        return pulumi.get(self, "value_source")


@pulumi.output_type
class GetConfigRuleResult(dict):
    def __init__(__self__, *,
                 display_name: str,
                 filter_text: str,
                 is_apply_to_error_spans: bool,
                 is_enabled: bool,
                 priority: int,
                 satisfied_response_time: int,
                 tolerating_response_time: int):
        """
        :param str display_name: A user-friendly name that provides a short description this rule.
        :param str filter_text: The string that defines the Span Filter expression.
        :param bool is_apply_to_error_spans: If true, the rule will compute the actual Apdex score for spans that have been marked as errors. If false, the rule will always set the Apdex for error spans to frustrating, regardless of the configured thresholds. Default is false.
        :param bool is_enabled: Specifies if the Apdex rule will be computed for spans matching the rule. Can be used to make sure certain spans don't get an Apdex score. The default is "true".
        :param int priority: The priority controls the order in which multiple rules in a rule set are applied. Lower values indicate higher priorities. Rules with higher priority are applied first, and once a match is found, the rest of the rules are ignored. Rules within the same rule set cannot have the same priority.
        :param int satisfied_response_time: The maximum response time in milliseconds that will be considered satisfactory for the end user.
        :param int tolerating_response_time: The maximum response time in milliseconds that will be considered tolerable for the end user. Response times beyond this threshold will be considered frustrating. This value cannot be lower than "satisfiedResponseTime".
        """
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "filter_text", filter_text)
        pulumi.set(__self__, "is_apply_to_error_spans", is_apply_to_error_spans)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "satisfied_response_time", satisfied_response_time)
        pulumi.set(__self__, "tolerating_response_time", tolerating_response_time)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A user-friendly name that provides a short description this rule.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="filterText")
    def filter_text(self) -> str:
        """
        The string that defines the Span Filter expression.
        """
        return pulumi.get(self, "filter_text")

    @property
    @pulumi.getter(name="isApplyToErrorSpans")
    def is_apply_to_error_spans(self) -> bool:
        """
        If true, the rule will compute the actual Apdex score for spans that have been marked as errors. If false, the rule will always set the Apdex for error spans to frustrating, regardless of the configured thresholds. Default is false.
        """
        return pulumi.get(self, "is_apply_to_error_spans")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Specifies if the Apdex rule will be computed for spans matching the rule. Can be used to make sure certain spans don't get an Apdex score. The default is "true".
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The priority controls the order in which multiple rules in a rule set are applied. Lower values indicate higher priorities. Rules with higher priority are applied first, and once a match is found, the rest of the rules are ignored. Rules within the same rule set cannot have the same priority.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="satisfiedResponseTime")
    def satisfied_response_time(self) -> int:
        """
        The maximum response time in milliseconds that will be considered satisfactory for the end user.
        """
        return pulumi.get(self, "satisfied_response_time")

    @property
    @pulumi.getter(name="toleratingResponseTime")
    def tolerating_response_time(self) -> int:
        """
        The maximum response time in milliseconds that will be considered tolerable for the end user. Response times beyond this threshold will be considered frustrating. This value cannot be lower than "satisfiedResponseTime".
        """
        return pulumi.get(self, "tolerating_response_time")


@pulumi.output_type
class GetConfigsConfigCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetConfigsConfigCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetConfigsConfigCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetConfigsConfigCollectionItemResult(dict):
    def __init__(__self__, *,
                 apm_domain_id: str,
                 config_type: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 dimensions: Sequence['outputs.GetConfigsConfigCollectionItemDimensionResult'],
                 display_name: str,
                 filter_id: str,
                 filter_text: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 metrics: Sequence['outputs.GetConfigsConfigCollectionItemMetricResult'],
                 namespace: str,
                 opc_dry_run: str,
                 rules: Sequence['outputs.GetConfigsConfigCollectionItemRuleResult'],
                 time_created: str,
                 time_updated: str):
        """
        :param str apm_domain_id: The APM Domain Id the request is intended for.
        :param str config_type: A filter to match only configuration items of the given type. Supported values are SPAN_FILTER, METRIC_GROUP, and APDEX.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param str description: A description of the metric
        :param Sequence['GetConfigsConfigCollectionItemDimensionArgs'] dimensions: A list of dimensions for this metric
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param str filter_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of a Span Filter. The filterId is mandatory for the creation of MetricGroups. A filterId will be generated when a Span Filter is created.
        :param str filter_text: The string that defines the Span Filter expression.
        :param Mapping[str, Any] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the configuration item. An OCID will be generated when the item is created.
        :param str namespace: The namespace to write the metrics to
        :param str time_created: The time the resource was created, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-12T22:47:12.613Z`
        :param str time_updated: The time the resource was updated, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-13T22:47:12.613Z`
        """
        pulumi.set(__self__, "apm_domain_id", apm_domain_id)
        pulumi.set(__self__, "config_type", config_type)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "filter_id", filter_id)
        pulumi.set(__self__, "filter_text", filter_text)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "opc_dry_run", opc_dry_run)
        pulumi.set(__self__, "rules", rules)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="apmDomainId")
    def apm_domain_id(self) -> str:
        """
        The APM Domain Id the request is intended for.
        """
        return pulumi.get(self, "apm_domain_id")

    @property
    @pulumi.getter(name="configType")
    def config_type(self) -> str:
        """
        A filter to match only configuration items of the given type. Supported values are SPAN_FILTER, METRIC_GROUP, and APDEX.
        """
        return pulumi.get(self, "config_type")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A description of the metric
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.GetConfigsConfigCollectionItemDimensionResult']:
        """
        A list of dimensions for this metric
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="filterId")
    def filter_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of a Span Filter. The filterId is mandatory for the creation of MetricGroups. A filterId will be generated when a Span Filter is created.
        """
        return pulumi.get(self, "filter_id")

    @property
    @pulumi.getter(name="filterText")
    def filter_text(self) -> str:
        """
        The string that defines the Span Filter expression.
        """
        return pulumi.get(self, "filter_text")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the configuration item. An OCID will be generated when the item is created.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def metrics(self) -> Sequence['outputs.GetConfigsConfigCollectionItemMetricResult']:
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        The namespace to write the metrics to
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="opcDryRun")
    def opc_dry_run(self) -> str:
        return pulumi.get(self, "opc_dry_run")

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetConfigsConfigCollectionItemRuleResult']:
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The time the resource was created, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-12T22:47:12.613Z`
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The time the resource was updated, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. Example: `2020-02-13T22:47:12.613Z`
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetConfigsConfigCollectionItemDimensionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value_source: str):
        """
        :param str name: The name of the metric
        :param str value_source: Must be NULL at the moment, and "name" must be a known metric.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value_source", value_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the metric
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="valueSource")
    def value_source(self) -> str:
        """
        Must be NULL at the moment, and "name" must be a known metric.
        """
        return pulumi.get(self, "value_source")


@pulumi.output_type
class GetConfigsConfigCollectionItemMetricResult(dict):
    def __init__(__self__, *,
                 description: str,
                 name: str,
                 unit: str,
                 value_source: str):
        """
        :param str description: A description of the metric
        :param str name: The name of the metric
        :param str unit: The unit of the metric
        :param str value_source: Must be NULL at the moment, and "name" must be a known metric.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value_source", value_source)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A description of the metric
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the metric
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        The unit of the metric
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter(name="valueSource")
    def value_source(self) -> str:
        """
        Must be NULL at the moment, and "name" must be a known metric.
        """
        return pulumi.get(self, "value_source")


@pulumi.output_type
class GetConfigsConfigCollectionItemRuleResult(dict):
    def __init__(__self__, *,
                 display_name: str,
                 filter_text: str,
                 is_apply_to_error_spans: bool,
                 is_enabled: bool,
                 priority: int,
                 satisfied_response_time: int,
                 tolerating_response_time: int):
        """
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param str filter_text: The string that defines the Span Filter expression.
        :param bool is_apply_to_error_spans: If true, the rule will compute the actual Apdex score for spans that have been marked as errors. If false, the rule will always set the Apdex for error spans to frustrating, regardless of the configured thresholds. Default is false.
        :param bool is_enabled: Specifies if the Apdex rule will be computed for spans matching the rule. Can be used to make sure certain spans don't get an Apdex score. The default is "true".
        :param int priority: The priority controls the order in which multiple rules in a rule set are applied. Lower values indicate higher priorities. Rules with higher priority are applied first, and once a match is found, the rest of the rules are ignored. Rules within the same rule set cannot have the same priority.
        :param int satisfied_response_time: The maximum response time in milliseconds that will be considered satisfactory for the end user.
        :param int tolerating_response_time: The maximum response time in milliseconds that will be considered tolerable for the end user. Response times beyond this threshold will be considered frustrating. This value cannot be lower than "satisfiedResponseTime".
        """
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "filter_text", filter_text)
        pulumi.set(__self__, "is_apply_to_error_spans", is_apply_to_error_spans)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "satisfied_response_time", satisfied_response_time)
        pulumi.set(__self__, "tolerating_response_time", tolerating_response_time)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="filterText")
    def filter_text(self) -> str:
        """
        The string that defines the Span Filter expression.
        """
        return pulumi.get(self, "filter_text")

    @property
    @pulumi.getter(name="isApplyToErrorSpans")
    def is_apply_to_error_spans(self) -> bool:
        """
        If true, the rule will compute the actual Apdex score for spans that have been marked as errors. If false, the rule will always set the Apdex for error spans to frustrating, regardless of the configured thresholds. Default is false.
        """
        return pulumi.get(self, "is_apply_to_error_spans")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Specifies if the Apdex rule will be computed for spans matching the rule. Can be used to make sure certain spans don't get an Apdex score. The default is "true".
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The priority controls the order in which multiple rules in a rule set are applied. Lower values indicate higher priorities. Rules with higher priority are applied first, and once a match is found, the rest of the rules are ignored. Rules within the same rule set cannot have the same priority.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="satisfiedResponseTime")
    def satisfied_response_time(self) -> int:
        """
        The maximum response time in milliseconds that will be considered satisfactory for the end user.
        """
        return pulumi.get(self, "satisfied_response_time")

    @property
    @pulumi.getter(name="toleratingResponseTime")
    def tolerating_response_time(self) -> int:
        """
        The maximum response time in milliseconds that will be considered tolerable for the end user. Response times beyond this threshold will be considered frustrating. This value cannot be lower than "satisfiedResponseTime".
        """
        return pulumi.get(self, "tolerating_response_time")


@pulumi.output_type
class GetConfigsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the metric
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the metric
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


