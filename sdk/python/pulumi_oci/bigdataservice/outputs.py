# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AutoScalingConfigurationPolicy',
    'AutoScalingConfigurationPolicyDetails',
    'AutoScalingConfigurationPolicyDetailsScaleDownConfig',
    'AutoScalingConfigurationPolicyDetailsScaleDownConfigMetric',
    'AutoScalingConfigurationPolicyDetailsScaleDownConfigMetricThreshold',
    'AutoScalingConfigurationPolicyDetailsScaleInConfig',
    'AutoScalingConfigurationPolicyDetailsScaleInConfigMetric',
    'AutoScalingConfigurationPolicyDetailsScaleInConfigMetricThreshold',
    'AutoScalingConfigurationPolicyDetailsScaleOutConfig',
    'AutoScalingConfigurationPolicyDetailsScaleOutConfigMetric',
    'AutoScalingConfigurationPolicyDetailsScaleOutConfigMetricThreshold',
    'AutoScalingConfigurationPolicyDetailsScaleUpConfig',
    'AutoScalingConfigurationPolicyDetailsScaleUpConfigMetric',
    'AutoScalingConfigurationPolicyDetailsScaleUpConfigMetricThreshold',
    'AutoScalingConfigurationPolicyDetailsScheduleDetail',
    'AutoScalingConfigurationPolicyDetailsScheduleDetailTimeAndHorizontalScalingConfig',
    'AutoScalingConfigurationPolicyDetailsScheduleDetailTimeAndVerticalScalingConfig',
    'AutoScalingConfigurationPolicyRule',
    'AutoScalingConfigurationPolicyRuleMetric',
    'AutoScalingConfigurationPolicyRuleMetricThreshold',
    'BdsCapacityReportShapeAvailability',
    'BdsCapacityReportShapeAvailabilityDomainLevelCapacityReport',
    'BdsCapacityReportShapeAvailabilityDomainLevelCapacityReportCapacityAvailability',
    'BdsCapacityReportShapeAvailabilityShapeConfig',
    'BdsInstanceBdsClusterVersionSummary',
    'BdsInstanceCloudSqlDetail',
    'BdsInstanceCloudSqlDetailKerberosDetail',
    'BdsInstanceClusterDetail',
    'BdsInstanceComputeOnlyWorkerNode',
    'BdsInstanceComputeOnlyWorkerNodeShapeConfig',
    'BdsInstanceEdgeNode',
    'BdsInstanceEdgeNodeShapeConfig',
    'BdsInstanceIdentityConfigurationIamUserSyncConfiguration',
    'BdsInstanceIdentityConfigurationIamUserSyncConfigurationDetails',
    'BdsInstanceIdentityConfigurationUpstConfiguration',
    'BdsInstanceIdentityConfigurationUpstConfigurationDetails',
    'BdsInstanceKafkaBrokerNode',
    'BdsInstanceKafkaBrokerNodeShapeConfig',
    'BdsInstanceMasterNode',
    'BdsInstanceMasterNodeShapeConfig',
    'BdsInstanceNetworkConfig',
    'BdsInstanceNode',
    'BdsInstanceNodeAttachedBlockVolume',
    'BdsInstanceNodeBackupConfigurationLevelTypeDetails',
    'BdsInstanceNodeBackupLevelTypeDetails',
    'BdsInstanceNodeReplaceConfigurationLevelTypeDetails',
    'BdsInstanceOperationCertificateManagementsManagementHostCertDetail',
    'BdsInstanceOsPatchActionPatchingConfigs',
    'BdsInstancePatchActionPatchingConfig',
    'BdsInstanceStartClusterShapeConfig',
    'BdsInstanceStartClusterShapeConfigNodeTypeShapeConfig',
    'BdsInstanceUtilNode',
    'BdsInstanceUtilNodeShapeConfig',
    'BdsInstanceWorkerNode',
    'BdsInstanceWorkerNodeShapeConfig',
    'GetAutoScalingConfigurationPolicyResult',
    'GetAutoScalingConfigurationPolicyDetailResult',
    'GetAutoScalingConfigurationPolicyDetailScaleDownConfigResult',
    'GetAutoScalingConfigurationPolicyDetailScaleDownConfigMetricResult',
    'GetAutoScalingConfigurationPolicyDetailScaleDownConfigMetricThresholdResult',
    'GetAutoScalingConfigurationPolicyDetailScaleInConfigResult',
    'GetAutoScalingConfigurationPolicyDetailScaleInConfigMetricResult',
    'GetAutoScalingConfigurationPolicyDetailScaleInConfigMetricThresholdResult',
    'GetAutoScalingConfigurationPolicyDetailScaleOutConfigResult',
    'GetAutoScalingConfigurationPolicyDetailScaleOutConfigMetricResult',
    'GetAutoScalingConfigurationPolicyDetailScaleOutConfigMetricThresholdResult',
    'GetAutoScalingConfigurationPolicyDetailScaleUpConfigResult',
    'GetAutoScalingConfigurationPolicyDetailScaleUpConfigMetricResult',
    'GetAutoScalingConfigurationPolicyDetailScaleUpConfigMetricThresholdResult',
    'GetAutoScalingConfigurationPolicyDetailScheduleDetailResult',
    'GetAutoScalingConfigurationPolicyDetailScheduleDetailTimeAndHorizontalScalingConfigResult',
    'GetAutoScalingConfigurationPolicyDetailScheduleDetailTimeAndVerticalScalingConfigResult',
    'GetAutoScalingConfigurationPolicyRuleResult',
    'GetAutoScalingConfigurationPolicyRuleMetricResult',
    'GetAutoScalingConfigurationPolicyRuleMetricThresholdResult',
    'GetAutoScalingConfigurationsAutoScalingConfigurationResult',
    'GetAutoScalingConfigurationsAutoScalingConfigurationPolicyResult',
    'GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailResult',
    'GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleDownConfigResult',
    'GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleDownConfigMetricResult',
    'GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleDownConfigMetricThresholdResult',
    'GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleInConfigResult',
    'GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleInConfigMetricResult',
    'GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleInConfigMetricThresholdResult',
    'GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleOutConfigResult',
    'GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleOutConfigMetricResult',
    'GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleOutConfigMetricThresholdResult',
    'GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleUpConfigResult',
    'GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleUpConfigMetricResult',
    'GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleUpConfigMetricThresholdResult',
    'GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScheduleDetailResult',
    'GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScheduleDetailTimeAndHorizontalScalingConfigResult',
    'GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScheduleDetailTimeAndVerticalScalingConfigResult',
    'GetAutoScalingConfigurationsAutoScalingConfigurationPolicyRuleResult',
    'GetAutoScalingConfigurationsAutoScalingConfigurationPolicyRuleMetricResult',
    'GetAutoScalingConfigurationsAutoScalingConfigurationPolicyRuleMetricThresholdResult',
    'GetAutoScalingConfigurationsFilterResult',
    'GetBdsClusterVersionsBdsClusterVersionResult',
    'GetBdsClusterVersionsFilterResult',
    'GetBdsInstanceApiKeysBdsApiKeyResult',
    'GetBdsInstanceApiKeysFilterResult',
    'GetBdsInstanceBdsClusterVersionSummaryResult',
    'GetBdsInstanceCloudSqlDetailResult',
    'GetBdsInstanceCloudSqlDetailKerberosDetailResult',
    'GetBdsInstanceClusterDetailResult',
    'GetBdsInstanceComputeOnlyWorkerNodeResult',
    'GetBdsInstanceComputeOnlyWorkerNodeShapeConfigResult',
    'GetBdsInstanceEdgeNodeResult',
    'GetBdsInstanceEdgeNodeShapeConfigResult',
    'GetBdsInstanceGetOsPatchFilterResult',
    'GetBdsInstanceGetOsPatchTargetPackageResult',
    'GetBdsInstanceIdentityConfigurationIamUserSyncConfigurationResult',
    'GetBdsInstanceIdentityConfigurationIamUserSyncConfigurationDetailResult',
    'GetBdsInstanceIdentityConfigurationUpstConfigurationResult',
    'GetBdsInstanceIdentityConfigurationUpstConfigurationDetailResult',
    'GetBdsInstanceIdentityConfigurationsFilterResult',
    'GetBdsInstanceIdentityConfigurationsIdentityConfigurationResult',
    'GetBdsInstanceIdentityConfigurationsIdentityConfigurationIamUserSyncConfigurationResult',
    'GetBdsInstanceIdentityConfigurationsIdentityConfigurationIamUserSyncConfigurationDetailResult',
    'GetBdsInstanceIdentityConfigurationsIdentityConfigurationUpstConfigurationResult',
    'GetBdsInstanceIdentityConfigurationsIdentityConfigurationUpstConfigurationDetailResult',
    'GetBdsInstanceKafkaBrokerNodeResult',
    'GetBdsInstanceKafkaBrokerNodeShapeConfigResult',
    'GetBdsInstanceListOsPatchesFilterResult',
    'GetBdsInstanceListOsPatchesOsPatchResult',
    'GetBdsInstanceMasterNodeResult',
    'GetBdsInstanceMasterNodeShapeConfigResult',
    'GetBdsInstanceMetastoreConfigsBdsMetastoreConfigurationResult',
    'GetBdsInstanceMetastoreConfigsFilterResult',
    'GetBdsInstanceNetworkConfigResult',
    'GetBdsInstanceNodeResult',
    'GetBdsInstanceNodeAttachedBlockVolumeResult',
    'GetBdsInstanceNodeBackupConfigurationLevelTypeDetailResult',
    'GetBdsInstanceNodeBackupConfigurationsFilterResult',
    'GetBdsInstanceNodeBackupConfigurationsNodeBackupConfigurationResult',
    'GetBdsInstanceNodeBackupConfigurationsNodeBackupConfigurationLevelTypeDetailResult',
    'GetBdsInstanceNodeBackupsFilterResult',
    'GetBdsInstanceNodeBackupsNodeBackupResult',
    'GetBdsInstanceNodeReplaceConfigurationLevelTypeDetailResult',
    'GetBdsInstanceNodeReplaceConfigurationsFilterResult',
    'GetBdsInstanceNodeReplaceConfigurationsNodeReplaceConfigurationResult',
    'GetBdsInstanceNodeReplaceConfigurationsNodeReplaceConfigurationLevelTypeDetailResult',
    'GetBdsInstancePatchHistoriesFilterResult',
    'GetBdsInstancePatchHistoriesPatchHistoryResult',
    'GetBdsInstancePatchesFilterResult',
    'GetBdsInstancePatchesPatchResult',
    'GetBdsInstanceResourcePrincipalConfigurationsFilterResult',
    'GetBdsInstanceResourcePrincipalConfigurationsResourcePrincipalConfigurationResult',
    'GetBdsInstanceSoftwareUpdatesFilterResult',
    'GetBdsInstanceSoftwareUpdatesSoftwareUpdateCollectionResult',
    'GetBdsInstanceSoftwareUpdatesSoftwareUpdateCollectionItemResult',
    'GetBdsInstanceStartClusterShapeConfigResult',
    'GetBdsInstanceStartClusterShapeConfigNodeTypeShapeConfigResult',
    'GetBdsInstanceUtilNodeResult',
    'GetBdsInstanceUtilNodeShapeConfigResult',
    'GetBdsInstanceWorkerNodeResult',
    'GetBdsInstanceWorkerNodeShapeConfigResult',
    'GetBdsInstancesBdsInstanceResult',
    'GetBdsInstancesBdsInstanceBdsClusterVersionSummaryResult',
    'GetBdsInstancesBdsInstanceCloudSqlDetailResult',
    'GetBdsInstancesBdsInstanceCloudSqlDetailKerberosDetailResult',
    'GetBdsInstancesBdsInstanceClusterDetailResult',
    'GetBdsInstancesBdsInstanceComputeOnlyWorkerNodeResult',
    'GetBdsInstancesBdsInstanceComputeOnlyWorkerNodeShapeConfigResult',
    'GetBdsInstancesBdsInstanceEdgeNodeResult',
    'GetBdsInstancesBdsInstanceEdgeNodeShapeConfigResult',
    'GetBdsInstancesBdsInstanceKafkaBrokerNodeResult',
    'GetBdsInstancesBdsInstanceKafkaBrokerNodeShapeConfigResult',
    'GetBdsInstancesBdsInstanceMasterNodeResult',
    'GetBdsInstancesBdsInstanceMasterNodeShapeConfigResult',
    'GetBdsInstancesBdsInstanceNetworkConfigResult',
    'GetBdsInstancesBdsInstanceNodeResult',
    'GetBdsInstancesBdsInstanceNodeAttachedBlockVolumeResult',
    'GetBdsInstancesBdsInstanceStartClusterShapeConfigResult',
    'GetBdsInstancesBdsInstanceStartClusterShapeConfigNodeTypeShapeConfigResult',
    'GetBdsInstancesBdsInstanceUtilNodeResult',
    'GetBdsInstancesBdsInstanceUtilNodeShapeConfigResult',
    'GetBdsInstancesBdsInstanceWorkerNodeResult',
    'GetBdsInstancesBdsInstanceWorkerNodeShapeConfigResult',
    'GetBdsInstancesFilterResult',
]

@pulumi.output_type
class AutoScalingConfigurationPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "policyType":
            suggest = "policy_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalingConfigurationPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalingConfigurationPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalingConfigurationPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policy_type: _builtins.str,
                 rules: Sequence['outputs.AutoScalingConfigurationPolicyRule']):
        """
        :param _builtins.str policy_type: (Updatable) Types of autoscale policies. Options are SCHEDULE-BASED or THRESHOLD-BASED. (Only THRESHOLD-BASED is supported in this release.)
        :param Sequence['AutoScalingConfigurationPolicyRuleArgs'] rules: (Updatable) The list of rules for autoscaling. If an action has multiple rules, the last rule in the array will be applied.
        """
        pulumi.set(__self__, "policy_type", policy_type)
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> _builtins.str:
        """
        (Updatable) Types of autoscale policies. Options are SCHEDULE-BASED or THRESHOLD-BASED. (Only THRESHOLD-BASED is supported in this release.)
        """
        return pulumi.get(self, "policy_type")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.AutoScalingConfigurationPolicyRule']:
        """
        (Updatable) The list of rules for autoscaling. If an action has multiple rules, the last rule in the array will be applied.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class AutoScalingConfigurationPolicyDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "policyType":
            suggest = "policy_type"
        elif key == "actionType":
            suggest = "action_type"
        elif key == "scaleDownConfig":
            suggest = "scale_down_config"
        elif key == "scaleInConfig":
            suggest = "scale_in_config"
        elif key == "scaleOutConfig":
            suggest = "scale_out_config"
        elif key == "scaleUpConfig":
            suggest = "scale_up_config"
        elif key == "scheduleDetails":
            suggest = "schedule_details"
        elif key == "triggerType":
            suggest = "trigger_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalingConfigurationPolicyDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalingConfigurationPolicyDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalingConfigurationPolicyDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policy_type: _builtins.str,
                 action_type: Optional[_builtins.str] = None,
                 scale_down_config: Optional['outputs.AutoScalingConfigurationPolicyDetailsScaleDownConfig'] = None,
                 scale_in_config: Optional['outputs.AutoScalingConfigurationPolicyDetailsScaleInConfig'] = None,
                 scale_out_config: Optional['outputs.AutoScalingConfigurationPolicyDetailsScaleOutConfig'] = None,
                 scale_up_config: Optional['outputs.AutoScalingConfigurationPolicyDetailsScaleUpConfig'] = None,
                 schedule_details: Optional[Sequence['outputs.AutoScalingConfigurationPolicyDetailsScheduleDetail']] = None,
                 timezone: Optional[_builtins.str] = None,
                 trigger_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str policy_type: Type of autoscaling policy.
        :param _builtins.str action_type: The type of autoscaling action to take.
        :param 'AutoScalingConfigurationPolicyDetailsScaleDownConfigArgs' scale_down_config: (Updatable) Configration for a metric based vertical scale-down policy.
        :param 'AutoScalingConfigurationPolicyDetailsScaleInConfigArgs' scale_in_config: (Updatable) Configration for a metric based horizontal scale-in policy.
        :param 'AutoScalingConfigurationPolicyDetailsScaleOutConfigArgs' scale_out_config: (Updatable) Configration for a metric based horizontal scale-out policy.
        :param 'AutoScalingConfigurationPolicyDetailsScaleUpConfigArgs' scale_up_config: (Updatable) Configration for a metric based vertical scale-up policy.
        :param Sequence['AutoScalingConfigurationPolicyDetailsScheduleDetailArgs'] schedule_details: (Updatable) Details of a horizontal scaling schedule.
        :param _builtins.str timezone: (Updatable) The time zone of the execution schedule, in IANA time zone database name format
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param _builtins.str trigger_type: The type of autoscaling trigger.
        """
        pulumi.set(__self__, "policy_type", policy_type)
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if scale_down_config is not None:
            pulumi.set(__self__, "scale_down_config", scale_down_config)
        if scale_in_config is not None:
            pulumi.set(__self__, "scale_in_config", scale_in_config)
        if scale_out_config is not None:
            pulumi.set(__self__, "scale_out_config", scale_out_config)
        if scale_up_config is not None:
            pulumi.set(__self__, "scale_up_config", scale_up_config)
        if schedule_details is not None:
            pulumi.set(__self__, "schedule_details", schedule_details)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if trigger_type is not None:
            pulumi.set(__self__, "trigger_type", trigger_type)

    @_builtins.property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> _builtins.str:
        """
        Type of autoscaling policy.
        """
        return pulumi.get(self, "policy_type")

    @_builtins.property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[_builtins.str]:
        """
        The type of autoscaling action to take.
        """
        return pulumi.get(self, "action_type")

    @_builtins.property
    @pulumi.getter(name="scaleDownConfig")
    def scale_down_config(self) -> Optional['outputs.AutoScalingConfigurationPolicyDetailsScaleDownConfig']:
        """
        (Updatable) Configration for a metric based vertical scale-down policy.
        """
        return pulumi.get(self, "scale_down_config")

    @_builtins.property
    @pulumi.getter(name="scaleInConfig")
    def scale_in_config(self) -> Optional['outputs.AutoScalingConfigurationPolicyDetailsScaleInConfig']:
        """
        (Updatable) Configration for a metric based horizontal scale-in policy.
        """
        return pulumi.get(self, "scale_in_config")

    @_builtins.property
    @pulumi.getter(name="scaleOutConfig")
    def scale_out_config(self) -> Optional['outputs.AutoScalingConfigurationPolicyDetailsScaleOutConfig']:
        """
        (Updatable) Configration for a metric based horizontal scale-out policy.
        """
        return pulumi.get(self, "scale_out_config")

    @_builtins.property
    @pulumi.getter(name="scaleUpConfig")
    def scale_up_config(self) -> Optional['outputs.AutoScalingConfigurationPolicyDetailsScaleUpConfig']:
        """
        (Updatable) Configration for a metric based vertical scale-up policy.
        """
        return pulumi.get(self, "scale_up_config")

    @_builtins.property
    @pulumi.getter(name="scheduleDetails")
    def schedule_details(self) -> Optional[Sequence['outputs.AutoScalingConfigurationPolicyDetailsScheduleDetail']]:
        """
        (Updatable) Details of a horizontal scaling schedule.
        """
        return pulumi.get(self, "schedule_details")

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> Optional[_builtins.str]:
        """
        (Updatable) The time zone of the execution schedule, in IANA time zone database name format


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "timezone")

    @_builtins.property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> Optional[_builtins.str]:
        """
        The type of autoscaling trigger.
        """
        return pulumi.get(self, "trigger_type")


@pulumi.output_type
class AutoScalingConfigurationPolicyDetailsScaleDownConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "memoryStepSize":
            suggest = "memory_step_size"
        elif key == "minMemoryPerNode":
            suggest = "min_memory_per_node"
        elif key == "minOcpusPerNode":
            suggest = "min_ocpus_per_node"
        elif key == "ocpuStepSize":
            suggest = "ocpu_step_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalingConfigurationPolicyDetailsScaleDownConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalingConfigurationPolicyDetailsScaleDownConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalingConfigurationPolicyDetailsScaleDownConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 memory_step_size: Optional[_builtins.int] = None,
                 metric: Optional['outputs.AutoScalingConfigurationPolicyDetailsScaleDownConfigMetric'] = None,
                 min_memory_per_node: Optional[_builtins.int] = None,
                 min_ocpus_per_node: Optional[_builtins.int] = None,
                 ocpu_step_size: Optional[_builtins.int] = None):
        """
        :param _builtins.int memory_step_size: (Updatable) For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the size of memory in GBs to remove from each node during a scale-down event. This value is not used for nodes with fixed compute shapes.
        :param 'AutoScalingConfigurationPolicyDetailsScaleDownConfigMetricArgs' metric: (Updatable) Metric and threshold details for triggering an autoscale action.
        :param _builtins.int min_memory_per_node: (Updatable) For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the minimum memory in GBs each node can be scaled-down to. This value is not used for nodes with fixed compute shapes.
        :param _builtins.int min_ocpus_per_node: (Updatable) For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the minimum number of OCPUs each node can be scaled-down to. This value is not used for nodes with fixed compute shapes.
        :param _builtins.int ocpu_step_size: (Updatable) For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the number of OCPUs to remove from each node during a scale-down event. This value is not used for nodes with fixed compute shapes.
        """
        if memory_step_size is not None:
            pulumi.set(__self__, "memory_step_size", memory_step_size)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if min_memory_per_node is not None:
            pulumi.set(__self__, "min_memory_per_node", min_memory_per_node)
        if min_ocpus_per_node is not None:
            pulumi.set(__self__, "min_ocpus_per_node", min_ocpus_per_node)
        if ocpu_step_size is not None:
            pulumi.set(__self__, "ocpu_step_size", ocpu_step_size)

    @_builtins.property
    @pulumi.getter(name="memoryStepSize")
    def memory_step_size(self) -> Optional[_builtins.int]:
        """
        (Updatable) For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the size of memory in GBs to remove from each node during a scale-down event. This value is not used for nodes with fixed compute shapes.
        """
        return pulumi.get(self, "memory_step_size")

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional['outputs.AutoScalingConfigurationPolicyDetailsScaleDownConfigMetric']:
        """
        (Updatable) Metric and threshold details for triggering an autoscale action.
        """
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter(name="minMemoryPerNode")
    def min_memory_per_node(self) -> Optional[_builtins.int]:
        """
        (Updatable) For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the minimum memory in GBs each node can be scaled-down to. This value is not used for nodes with fixed compute shapes.
        """
        return pulumi.get(self, "min_memory_per_node")

    @_builtins.property
    @pulumi.getter(name="minOcpusPerNode")
    def min_ocpus_per_node(self) -> Optional[_builtins.int]:
        """
        (Updatable) For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the minimum number of OCPUs each node can be scaled-down to. This value is not used for nodes with fixed compute shapes.
        """
        return pulumi.get(self, "min_ocpus_per_node")

    @_builtins.property
    @pulumi.getter(name="ocpuStepSize")
    def ocpu_step_size(self) -> Optional[_builtins.int]:
        """
        (Updatable) For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the number of OCPUs to remove from each node during a scale-down event. This value is not used for nodes with fixed compute shapes.
        """
        return pulumi.get(self, "ocpu_step_size")


@pulumi.output_type
class AutoScalingConfigurationPolicyDetailsScaleDownConfigMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricType":
            suggest = "metric_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalingConfigurationPolicyDetailsScaleDownConfigMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalingConfigurationPolicyDetailsScaleDownConfigMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalingConfigurationPolicyDetailsScaleDownConfigMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_type: Optional[_builtins.str] = None,
                 threshold: Optional['outputs.AutoScalingConfigurationPolicyDetailsScaleDownConfigMetricThreshold'] = None):
        """
        :param _builtins.str metric_type: (Updatable) Allowed values are CPU_UTILIZATION and MEMORY_UTILIZATION.
        :param 'AutoScalingConfigurationPolicyDetailsScaleDownConfigMetricThresholdArgs' threshold: (Updatable) An autoscale action is triggered when a performance metric exceeds a threshold.
        """
        if metric_type is not None:
            pulumi.set(__self__, "metric_type", metric_type)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> Optional[_builtins.str]:
        """
        (Updatable) Allowed values are CPU_UTILIZATION and MEMORY_UTILIZATION.
        """
        return pulumi.get(self, "metric_type")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional['outputs.AutoScalingConfigurationPolicyDetailsScaleDownConfigMetricThreshold']:
        """
        (Updatable) An autoscale action is triggered when a performance metric exceeds a threshold.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class AutoScalingConfigurationPolicyDetailsScaleDownConfigMetricThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationInMinutes":
            suggest = "duration_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalingConfigurationPolicyDetailsScaleDownConfigMetricThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalingConfigurationPolicyDetailsScaleDownConfigMetricThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalingConfigurationPolicyDetailsScaleDownConfigMetricThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_in_minutes: Optional[_builtins.int] = None,
                 operator: Optional[_builtins.str] = None,
                 value: Optional[_builtins.int] = None):
        """
        :param _builtins.int duration_in_minutes: (Updatable) This value is the minimum period of time the metric value exceeds the threshold value before the action is triggered. The value is in minutes.
        :param _builtins.str operator: (Updatable) The comparison operator to use. Options are greater than (GT) or less than (LT).
        :param _builtins.int value: (Updatable) Integer non-negative value. 0 < value < 100
        """
        if duration_in_minutes is not None:
            pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> Optional[_builtins.int]:
        """
        (Updatable) This value is the minimum period of time the metric value exceeds the threshold value before the action is triggered. The value is in minutes.
        """
        return pulumi.get(self, "duration_in_minutes")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        (Updatable) The comparison operator to use. Options are greater than (GT) or less than (LT).
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.int]:
        """
        (Updatable) Integer non-negative value. 0 < value < 100
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutoScalingConfigurationPolicyDetailsScaleInConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minNodeCount":
            suggest = "min_node_count"
        elif key == "stepSize":
            suggest = "step_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalingConfigurationPolicyDetailsScaleInConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalingConfigurationPolicyDetailsScaleInConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalingConfigurationPolicyDetailsScaleInConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: Optional['outputs.AutoScalingConfigurationPolicyDetailsScaleInConfigMetric'] = None,
                 min_node_count: Optional[_builtins.int] = None,
                 step_size: Optional[_builtins.int] = None):
        """
        :param 'AutoScalingConfigurationPolicyDetailsScaleInConfigMetricArgs' metric: (Updatable) Metric and threshold details for triggering an autoscale action.
        :param _builtins.int min_node_count: (Updatable) This value is the minimum number of nodes the cluster can be scaled-in to.
        :param _builtins.int step_size: (Updatable) This value is the number of nodes to remove during a scale-in event.
        """
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if min_node_count is not None:
            pulumi.set(__self__, "min_node_count", min_node_count)
        if step_size is not None:
            pulumi.set(__self__, "step_size", step_size)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional['outputs.AutoScalingConfigurationPolicyDetailsScaleInConfigMetric']:
        """
        (Updatable) Metric and threshold details for triggering an autoscale action.
        """
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter(name="minNodeCount")
    def min_node_count(self) -> Optional[_builtins.int]:
        """
        (Updatable) This value is the minimum number of nodes the cluster can be scaled-in to.
        """
        return pulumi.get(self, "min_node_count")

    @_builtins.property
    @pulumi.getter(name="stepSize")
    def step_size(self) -> Optional[_builtins.int]:
        """
        (Updatable) This value is the number of nodes to remove during a scale-in event.
        """
        return pulumi.get(self, "step_size")


@pulumi.output_type
class AutoScalingConfigurationPolicyDetailsScaleInConfigMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricType":
            suggest = "metric_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalingConfigurationPolicyDetailsScaleInConfigMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalingConfigurationPolicyDetailsScaleInConfigMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalingConfigurationPolicyDetailsScaleInConfigMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_type: Optional[_builtins.str] = None,
                 threshold: Optional['outputs.AutoScalingConfigurationPolicyDetailsScaleInConfigMetricThreshold'] = None):
        """
        :param _builtins.str metric_type: (Updatable) Allowed values are CPU_UTILIZATION and MEMORY_UTILIZATION.
        :param 'AutoScalingConfigurationPolicyDetailsScaleInConfigMetricThresholdArgs' threshold: (Updatable) An autoscale action is triggered when a performance metric exceeds a threshold.
        """
        if metric_type is not None:
            pulumi.set(__self__, "metric_type", metric_type)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> Optional[_builtins.str]:
        """
        (Updatable) Allowed values are CPU_UTILIZATION and MEMORY_UTILIZATION.
        """
        return pulumi.get(self, "metric_type")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional['outputs.AutoScalingConfigurationPolicyDetailsScaleInConfigMetricThreshold']:
        """
        (Updatable) An autoscale action is triggered when a performance metric exceeds a threshold.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class AutoScalingConfigurationPolicyDetailsScaleInConfigMetricThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationInMinutes":
            suggest = "duration_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalingConfigurationPolicyDetailsScaleInConfigMetricThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalingConfigurationPolicyDetailsScaleInConfigMetricThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalingConfigurationPolicyDetailsScaleInConfigMetricThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_in_minutes: Optional[_builtins.int] = None,
                 operator: Optional[_builtins.str] = None,
                 value: Optional[_builtins.int] = None):
        """
        :param _builtins.int duration_in_minutes: (Updatable) This value is the minimum period of time the metric value exceeds the threshold value before the action is triggered. The value is in minutes.
        :param _builtins.str operator: (Updatable) The comparison operator to use. Options are greater than (GT) or less than (LT).
        :param _builtins.int value: (Updatable) Integer non-negative value. 0 < value < 100
        """
        if duration_in_minutes is not None:
            pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> Optional[_builtins.int]:
        """
        (Updatable) This value is the minimum period of time the metric value exceeds the threshold value before the action is triggered. The value is in minutes.
        """
        return pulumi.get(self, "duration_in_minutes")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        (Updatable) The comparison operator to use. Options are greater than (GT) or less than (LT).
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.int]:
        """
        (Updatable) Integer non-negative value. 0 < value < 100
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutoScalingConfigurationPolicyDetailsScaleOutConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxNodeCount":
            suggest = "max_node_count"
        elif key == "stepSize":
            suggest = "step_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalingConfigurationPolicyDetailsScaleOutConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalingConfigurationPolicyDetailsScaleOutConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalingConfigurationPolicyDetailsScaleOutConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_node_count: Optional[_builtins.int] = None,
                 metric: Optional['outputs.AutoScalingConfigurationPolicyDetailsScaleOutConfigMetric'] = None,
                 step_size: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_node_count: (Updatable) This value is the maximum number of nodes the cluster can be scaled-out to.
        :param 'AutoScalingConfigurationPolicyDetailsScaleOutConfigMetricArgs' metric: (Updatable) Metric and threshold details for triggering an autoscale action.
        :param _builtins.int step_size: (Updatable) This value is the number of nodes to add during a scale-out event.
        """
        if max_node_count is not None:
            pulumi.set(__self__, "max_node_count", max_node_count)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if step_size is not None:
            pulumi.set(__self__, "step_size", step_size)

    @_builtins.property
    @pulumi.getter(name="maxNodeCount")
    def max_node_count(self) -> Optional[_builtins.int]:
        """
        (Updatable) This value is the maximum number of nodes the cluster can be scaled-out to.
        """
        return pulumi.get(self, "max_node_count")

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional['outputs.AutoScalingConfigurationPolicyDetailsScaleOutConfigMetric']:
        """
        (Updatable) Metric and threshold details for triggering an autoscale action.
        """
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter(name="stepSize")
    def step_size(self) -> Optional[_builtins.int]:
        """
        (Updatable) This value is the number of nodes to add during a scale-out event.
        """
        return pulumi.get(self, "step_size")


@pulumi.output_type
class AutoScalingConfigurationPolicyDetailsScaleOutConfigMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricType":
            suggest = "metric_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalingConfigurationPolicyDetailsScaleOutConfigMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalingConfigurationPolicyDetailsScaleOutConfigMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalingConfigurationPolicyDetailsScaleOutConfigMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_type: Optional[_builtins.str] = None,
                 threshold: Optional['outputs.AutoScalingConfigurationPolicyDetailsScaleOutConfigMetricThreshold'] = None):
        """
        :param _builtins.str metric_type: (Updatable) Allowed values are CPU_UTILIZATION and MEMORY_UTILIZATION.
        :param 'AutoScalingConfigurationPolicyDetailsScaleOutConfigMetricThresholdArgs' threshold: (Updatable) An autoscale action is triggered when a performance metric exceeds a threshold.
        """
        if metric_type is not None:
            pulumi.set(__self__, "metric_type", metric_type)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> Optional[_builtins.str]:
        """
        (Updatable) Allowed values are CPU_UTILIZATION and MEMORY_UTILIZATION.
        """
        return pulumi.get(self, "metric_type")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional['outputs.AutoScalingConfigurationPolicyDetailsScaleOutConfigMetricThreshold']:
        """
        (Updatable) An autoscale action is triggered when a performance metric exceeds a threshold.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class AutoScalingConfigurationPolicyDetailsScaleOutConfigMetricThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationInMinutes":
            suggest = "duration_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalingConfigurationPolicyDetailsScaleOutConfigMetricThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalingConfigurationPolicyDetailsScaleOutConfigMetricThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalingConfigurationPolicyDetailsScaleOutConfigMetricThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_in_minutes: Optional[_builtins.int] = None,
                 operator: Optional[_builtins.str] = None,
                 value: Optional[_builtins.int] = None):
        """
        :param _builtins.int duration_in_minutes: (Updatable) This value is the minimum period of time the metric value exceeds the threshold value before the action is triggered. The value is in minutes.
        :param _builtins.str operator: (Updatable) The comparison operator to use. Options are greater than (GT) or less than (LT).
        :param _builtins.int value: (Updatable) Integer non-negative value. 0 < value < 100
        """
        if duration_in_minutes is not None:
            pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> Optional[_builtins.int]:
        """
        (Updatable) This value is the minimum period of time the metric value exceeds the threshold value before the action is triggered. The value is in minutes.
        """
        return pulumi.get(self, "duration_in_minutes")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        (Updatable) The comparison operator to use. Options are greater than (GT) or less than (LT).
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.int]:
        """
        (Updatable) Integer non-negative value. 0 < value < 100
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutoScalingConfigurationPolicyDetailsScaleUpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxMemoryPerNode":
            suggest = "max_memory_per_node"
        elif key == "maxOcpusPerNode":
            suggest = "max_ocpus_per_node"
        elif key == "memoryStepSize":
            suggest = "memory_step_size"
        elif key == "ocpuStepSize":
            suggest = "ocpu_step_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalingConfigurationPolicyDetailsScaleUpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalingConfigurationPolicyDetailsScaleUpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalingConfigurationPolicyDetailsScaleUpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_memory_per_node: Optional[_builtins.int] = None,
                 max_ocpus_per_node: Optional[_builtins.int] = None,
                 memory_step_size: Optional[_builtins.int] = None,
                 metric: Optional['outputs.AutoScalingConfigurationPolicyDetailsScaleUpConfigMetric'] = None,
                 ocpu_step_size: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_memory_per_node: (Updatable) For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the maximum memory in GBs each node can be scaled-up to. This value is not used for nodes with fixed compute shapes.
        :param _builtins.int max_ocpus_per_node: (Updatable) For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the maximum number of OCPUs each node can be scaled-up to. This value is not used for nodes with fixed compute shapes.
        :param _builtins.int memory_step_size: (Updatable) For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the size of memory in GBs to add to each node during a scale-up event. This value is not used for nodes with fixed compute shapes.
        :param 'AutoScalingConfigurationPolicyDetailsScaleUpConfigMetricArgs' metric: (Updatable) Metric and threshold details for triggering an autoscale action.
        :param _builtins.int ocpu_step_size: (Updatable) For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the number of OCPUs to add to each node during a scale-up event. This value is not used for nodes with fixed compute shapes.
        """
        if max_memory_per_node is not None:
            pulumi.set(__self__, "max_memory_per_node", max_memory_per_node)
        if max_ocpus_per_node is not None:
            pulumi.set(__self__, "max_ocpus_per_node", max_ocpus_per_node)
        if memory_step_size is not None:
            pulumi.set(__self__, "memory_step_size", memory_step_size)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if ocpu_step_size is not None:
            pulumi.set(__self__, "ocpu_step_size", ocpu_step_size)

    @_builtins.property
    @pulumi.getter(name="maxMemoryPerNode")
    def max_memory_per_node(self) -> Optional[_builtins.int]:
        """
        (Updatable) For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the maximum memory in GBs each node can be scaled-up to. This value is not used for nodes with fixed compute shapes.
        """
        return pulumi.get(self, "max_memory_per_node")

    @_builtins.property
    @pulumi.getter(name="maxOcpusPerNode")
    def max_ocpus_per_node(self) -> Optional[_builtins.int]:
        """
        (Updatable) For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the maximum number of OCPUs each node can be scaled-up to. This value is not used for nodes with fixed compute shapes.
        """
        return pulumi.get(self, "max_ocpus_per_node")

    @_builtins.property
    @pulumi.getter(name="memoryStepSize")
    def memory_step_size(self) -> Optional[_builtins.int]:
        """
        (Updatable) For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the size of memory in GBs to add to each node during a scale-up event. This value is not used for nodes with fixed compute shapes.
        """
        return pulumi.get(self, "memory_step_size")

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional['outputs.AutoScalingConfigurationPolicyDetailsScaleUpConfigMetric']:
        """
        (Updatable) Metric and threshold details for triggering an autoscale action.
        """
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter(name="ocpuStepSize")
    def ocpu_step_size(self) -> Optional[_builtins.int]:
        """
        (Updatable) For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the number of OCPUs to add to each node during a scale-up event. This value is not used for nodes with fixed compute shapes.
        """
        return pulumi.get(self, "ocpu_step_size")


@pulumi.output_type
class AutoScalingConfigurationPolicyDetailsScaleUpConfigMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricType":
            suggest = "metric_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalingConfigurationPolicyDetailsScaleUpConfigMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalingConfigurationPolicyDetailsScaleUpConfigMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalingConfigurationPolicyDetailsScaleUpConfigMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_type: Optional[_builtins.str] = None,
                 threshold: Optional['outputs.AutoScalingConfigurationPolicyDetailsScaleUpConfigMetricThreshold'] = None):
        """
        :param _builtins.str metric_type: (Updatable) Allowed values are CPU_UTILIZATION and MEMORY_UTILIZATION.
        :param 'AutoScalingConfigurationPolicyDetailsScaleUpConfigMetricThresholdArgs' threshold: (Updatable) An autoscale action is triggered when a performance metric exceeds a threshold.
        """
        if metric_type is not None:
            pulumi.set(__self__, "metric_type", metric_type)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> Optional[_builtins.str]:
        """
        (Updatable) Allowed values are CPU_UTILIZATION and MEMORY_UTILIZATION.
        """
        return pulumi.get(self, "metric_type")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional['outputs.AutoScalingConfigurationPolicyDetailsScaleUpConfigMetricThreshold']:
        """
        (Updatable) An autoscale action is triggered when a performance metric exceeds a threshold.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class AutoScalingConfigurationPolicyDetailsScaleUpConfigMetricThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationInMinutes":
            suggest = "duration_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalingConfigurationPolicyDetailsScaleUpConfigMetricThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalingConfigurationPolicyDetailsScaleUpConfigMetricThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalingConfigurationPolicyDetailsScaleUpConfigMetricThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_in_minutes: Optional[_builtins.int] = None,
                 operator: Optional[_builtins.str] = None,
                 value: Optional[_builtins.int] = None):
        """
        :param _builtins.int duration_in_minutes: (Updatable) This value is the minimum period of time the metric value exceeds the threshold value before the action is triggered. The value is in minutes.
        :param _builtins.str operator: (Updatable) The comparison operator to use. Options are greater than (GT) or less than (LT).
        :param _builtins.int value: (Updatable) Integer non-negative value. 0 < value < 100
        """
        if duration_in_minutes is not None:
            pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> Optional[_builtins.int]:
        """
        (Updatable) This value is the minimum period of time the metric value exceeds the threshold value before the action is triggered. The value is in minutes.
        """
        return pulumi.get(self, "duration_in_minutes")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        (Updatable) The comparison operator to use. Options are greater than (GT) or less than (LT).
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.int]:
        """
        (Updatable) Integer non-negative value. 0 < value < 100
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutoScalingConfigurationPolicyDetailsScheduleDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scheduleType":
            suggest = "schedule_type"
        elif key == "timeAndHorizontalScalingConfigs":
            suggest = "time_and_horizontal_scaling_configs"
        elif key == "timeAndVerticalScalingConfigs":
            suggest = "time_and_vertical_scaling_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalingConfigurationPolicyDetailsScheduleDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalingConfigurationPolicyDetailsScheduleDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalingConfigurationPolicyDetailsScheduleDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schedule_type: Optional[_builtins.str] = None,
                 time_and_horizontal_scaling_configs: Optional[Sequence['outputs.AutoScalingConfigurationPolicyDetailsScheduleDetailTimeAndHorizontalScalingConfig']] = None,
                 time_and_vertical_scaling_configs: Optional[Sequence['outputs.AutoScalingConfigurationPolicyDetailsScheduleDetailTimeAndVerticalScalingConfig']] = None):
        """
        :param _builtins.str schedule_type: (Updatable) The type of schedule.
        :param Sequence['AutoScalingConfigurationPolicyDetailsScheduleDetailTimeAndHorizontalScalingConfigArgs'] time_and_horizontal_scaling_configs: (Updatable) Time of day and horizontal scaling configuration.
        :param Sequence['AutoScalingConfigurationPolicyDetailsScheduleDetailTimeAndVerticalScalingConfigArgs'] time_and_vertical_scaling_configs: (Updatable) Time of day and vertical scaling configuration
        """
        if schedule_type is not None:
            pulumi.set(__self__, "schedule_type", schedule_type)
        if time_and_horizontal_scaling_configs is not None:
            pulumi.set(__self__, "time_and_horizontal_scaling_configs", time_and_horizontal_scaling_configs)
        if time_and_vertical_scaling_configs is not None:
            pulumi.set(__self__, "time_and_vertical_scaling_configs", time_and_vertical_scaling_configs)

    @_builtins.property
    @pulumi.getter(name="scheduleType")
    def schedule_type(self) -> Optional[_builtins.str]:
        """
        (Updatable) The type of schedule.
        """
        return pulumi.get(self, "schedule_type")

    @_builtins.property
    @pulumi.getter(name="timeAndHorizontalScalingConfigs")
    def time_and_horizontal_scaling_configs(self) -> Optional[Sequence['outputs.AutoScalingConfigurationPolicyDetailsScheduleDetailTimeAndHorizontalScalingConfig']]:
        """
        (Updatable) Time of day and horizontal scaling configuration.
        """
        return pulumi.get(self, "time_and_horizontal_scaling_configs")

    @_builtins.property
    @pulumi.getter(name="timeAndVerticalScalingConfigs")
    def time_and_vertical_scaling_configs(self) -> Optional[Sequence['outputs.AutoScalingConfigurationPolicyDetailsScheduleDetailTimeAndVerticalScalingConfig']]:
        """
        (Updatable) Time of day and vertical scaling configuration
        """
        return pulumi.get(self, "time_and_vertical_scaling_configs")


@pulumi.output_type
class AutoScalingConfigurationPolicyDetailsScheduleDetailTimeAndHorizontalScalingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetNodeCount":
            suggest = "target_node_count"
        elif key == "timeRecurrence":
            suggest = "time_recurrence"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalingConfigurationPolicyDetailsScheduleDetailTimeAndHorizontalScalingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalingConfigurationPolicyDetailsScheduleDetailTimeAndHorizontalScalingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalingConfigurationPolicyDetailsScheduleDetailTimeAndHorizontalScalingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_node_count: Optional[_builtins.int] = None,
                 time_recurrence: Optional[_builtins.str] = None):
        """
        :param _builtins.int target_node_count: (Updatable) This value is the desired number of nodes in the cluster.
        :param _builtins.str time_recurrence: (Updatable) Day/time recurrence (specified following RFC 5545) at which to trigger autoscaling action. Currently only WEEKLY frequency is supported. Days of the week are specified using BYDAY field. Time of the day is specified using BYHOUR and BYMINUTE fields. Other fields are not supported.
        """
        if target_node_count is not None:
            pulumi.set(__self__, "target_node_count", target_node_count)
        if time_recurrence is not None:
            pulumi.set(__self__, "time_recurrence", time_recurrence)

    @_builtins.property
    @pulumi.getter(name="targetNodeCount")
    def target_node_count(self) -> Optional[_builtins.int]:
        """
        (Updatable) This value is the desired number of nodes in the cluster.
        """
        return pulumi.get(self, "target_node_count")

    @_builtins.property
    @pulumi.getter(name="timeRecurrence")
    def time_recurrence(self) -> Optional[_builtins.str]:
        """
        (Updatable) Day/time recurrence (specified following RFC 5545) at which to trigger autoscaling action. Currently only WEEKLY frequency is supported. Days of the week are specified using BYDAY field. Time of the day is specified using BYHOUR and BYMINUTE fields. Other fields are not supported.
        """
        return pulumi.get(self, "time_recurrence")


@pulumi.output_type
class AutoScalingConfigurationPolicyDetailsScheduleDetailTimeAndVerticalScalingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetMemoryPerNode":
            suggest = "target_memory_per_node"
        elif key == "targetOcpusPerNode":
            suggest = "target_ocpus_per_node"
        elif key == "targetShape":
            suggest = "target_shape"
        elif key == "timeRecurrence":
            suggest = "time_recurrence"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalingConfigurationPolicyDetailsScheduleDetailTimeAndVerticalScalingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalingConfigurationPolicyDetailsScheduleDetailTimeAndVerticalScalingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalingConfigurationPolicyDetailsScheduleDetailTimeAndVerticalScalingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_memory_per_node: Optional[_builtins.int] = None,
                 target_ocpus_per_node: Optional[_builtins.int] = None,
                 target_shape: Optional[_builtins.str] = None,
                 time_recurrence: Optional[_builtins.str] = None):
        """
        :param _builtins.int target_memory_per_node: (Updatable) For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the desired memory in GBs on each node. This value is not used for nodes with fixed compute shapes.
        :param _builtins.int target_ocpus_per_node: (Updatable) For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the desired OCPUs count on each node. This value is not used for nodes with fixed compute shapes.
        :param _builtins.str target_shape: (Updatable) For nodes with [fixed compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the desired shape of each node. This value is not used for nodes with flexible compute shapes.
        :param _builtins.str time_recurrence: (Updatable) Day/time recurrence (specified following RFC 5545) at which to trigger autoscaling action. Currently only WEEKLY frequency is supported. Days of the week are specified using BYDAY field. Time of the day is specified using BYHOUR and BYMINUTE fields. Other fields are not supported.
        """
        if target_memory_per_node is not None:
            pulumi.set(__self__, "target_memory_per_node", target_memory_per_node)
        if target_ocpus_per_node is not None:
            pulumi.set(__self__, "target_ocpus_per_node", target_ocpus_per_node)
        if target_shape is not None:
            pulumi.set(__self__, "target_shape", target_shape)
        if time_recurrence is not None:
            pulumi.set(__self__, "time_recurrence", time_recurrence)

    @_builtins.property
    @pulumi.getter(name="targetMemoryPerNode")
    def target_memory_per_node(self) -> Optional[_builtins.int]:
        """
        (Updatable) For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the desired memory in GBs on each node. This value is not used for nodes with fixed compute shapes.
        """
        return pulumi.get(self, "target_memory_per_node")

    @_builtins.property
    @pulumi.getter(name="targetOcpusPerNode")
    def target_ocpus_per_node(self) -> Optional[_builtins.int]:
        """
        (Updatable) For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the desired OCPUs count on each node. This value is not used for nodes with fixed compute shapes.
        """
        return pulumi.get(self, "target_ocpus_per_node")

    @_builtins.property
    @pulumi.getter(name="targetShape")
    def target_shape(self) -> Optional[_builtins.str]:
        """
        (Updatable) For nodes with [fixed compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the desired shape of each node. This value is not used for nodes with flexible compute shapes.
        """
        return pulumi.get(self, "target_shape")

    @_builtins.property
    @pulumi.getter(name="timeRecurrence")
    def time_recurrence(self) -> Optional[_builtins.str]:
        """
        (Updatable) Day/time recurrence (specified following RFC 5545) at which to trigger autoscaling action. Currently only WEEKLY frequency is supported. Days of the week are specified using BYDAY field. Time of the day is specified using BYHOUR and BYMINUTE fields. Other fields are not supported.
        """
        return pulumi.get(self, "time_recurrence")


@pulumi.output_type
class AutoScalingConfigurationPolicyRule(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 metric: 'outputs.AutoScalingConfigurationPolicyRuleMetric'):
        """
        :param _builtins.str action: (Updatable) The valid value are CHANGE_SHAPE_SCALE_UP or CHANGE_SHAPE_SCALE_DOWN.
        :param 'AutoScalingConfigurationPolicyRuleMetricArgs' metric: (Updatable) Metric and threshold details for triggering an autoscale action.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "metric", metric)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        (Updatable) The valid value are CHANGE_SHAPE_SCALE_UP or CHANGE_SHAPE_SCALE_DOWN.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def metric(self) -> 'outputs.AutoScalingConfigurationPolicyRuleMetric':
        """
        (Updatable) Metric and threshold details for triggering an autoscale action.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class AutoScalingConfigurationPolicyRuleMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricType":
            suggest = "metric_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalingConfigurationPolicyRuleMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalingConfigurationPolicyRuleMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalingConfigurationPolicyRuleMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_type: _builtins.str,
                 threshold: 'outputs.AutoScalingConfigurationPolicyRuleMetricThreshold'):
        """
        :param _builtins.str metric_type: (Updatable) Allowed values are CPU_UTILIZATION and MEMORY_UTILIZATION.
        :param 'AutoScalingConfigurationPolicyRuleMetricThresholdArgs' threshold: (Updatable) An autoscale action is triggered when a performance metric exceeds a threshold.
        """
        pulumi.set(__self__, "metric_type", metric_type)
        pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> _builtins.str:
        """
        (Updatable) Allowed values are CPU_UTILIZATION and MEMORY_UTILIZATION.
        """
        return pulumi.get(self, "metric_type")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> 'outputs.AutoScalingConfigurationPolicyRuleMetricThreshold':
        """
        (Updatable) An autoscale action is triggered when a performance metric exceeds a threshold.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class AutoScalingConfigurationPolicyRuleMetricThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationInMinutes":
            suggest = "duration_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalingConfigurationPolicyRuleMetricThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalingConfigurationPolicyRuleMetricThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalingConfigurationPolicyRuleMetricThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_in_minutes: _builtins.int,
                 operator: _builtins.str,
                 value: _builtins.int):
        """
        :param _builtins.int duration_in_minutes: (Updatable) This value is the minimum period of time the metric value exceeds the threshold value before the action is triggered. The value is in minutes.
        :param _builtins.str operator: (Updatable) The comparison operator to use. Options are greater than (GT) or less than (LT).
        :param _builtins.int value: (Updatable) Integer non-negative value. 0 < value < 100
        """
        pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> _builtins.int:
        """
        (Updatable) This value is the minimum period of time the metric value exceeds the threshold value before the action is triggered. The value is in minutes.
        """
        return pulumi.get(self, "duration_in_minutes")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        (Updatable) The comparison operator to use. Options are greater than (GT) or less than (LT).
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        """
        (Updatable) Integer non-negative value. 0 < value < 100
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BdsCapacityReportShapeAvailability(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainLevelCapacityReports":
            suggest = "domain_level_capacity_reports"
        elif key == "shapeConfig":
            suggest = "shape_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsCapacityReportShapeAvailability. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsCapacityReportShapeAvailability.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsCapacityReportShapeAvailability.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 shape: _builtins.str,
                 domain_level_capacity_reports: Optional[Sequence['outputs.BdsCapacityReportShapeAvailabilityDomainLevelCapacityReport']] = None,
                 shape_config: Optional['outputs.BdsCapacityReportShapeAvailabilityShapeConfig'] = None):
        """
        :param _builtins.str shape: The shape that you want to request a capacity report for.
        :param Sequence['BdsCapacityReportShapeAvailabilityDomainLevelCapacityReportArgs'] domain_level_capacity_reports: Information about the capacity in each domain.
        :param 'BdsCapacityReportShapeAvailabilityShapeConfigArgs' shape_config: The shape configuration requested for the node.
        """
        pulumi.set(__self__, "shape", shape)
        if domain_level_capacity_reports is not None:
            pulumi.set(__self__, "domain_level_capacity_reports", domain_level_capacity_reports)
        if shape_config is not None:
            pulumi.set(__self__, "shape_config", shape_config)

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        The shape that you want to request a capacity report for.
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter(name="domainLevelCapacityReports")
    def domain_level_capacity_reports(self) -> Optional[Sequence['outputs.BdsCapacityReportShapeAvailabilityDomainLevelCapacityReport']]:
        """
        Information about the capacity in each domain.
        """
        return pulumi.get(self, "domain_level_capacity_reports")

    @_builtins.property
    @pulumi.getter(name="shapeConfig")
    def shape_config(self) -> Optional['outputs.BdsCapacityReportShapeAvailabilityShapeConfig']:
        """
        The shape configuration requested for the node.
        """
        return pulumi.get(self, "shape_config")


@pulumi.output_type
class BdsCapacityReportShapeAvailabilityDomainLevelCapacityReport(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityDomain":
            suggest = "availability_domain"
        elif key == "capacityAvailabilities":
            suggest = "capacity_availabilities"
        elif key == "domainType":
            suggest = "domain_type"
        elif key == "faultDomain":
            suggest = "fault_domain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsCapacityReportShapeAvailabilityDomainLevelCapacityReport. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsCapacityReportShapeAvailabilityDomainLevelCapacityReport.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsCapacityReportShapeAvailabilityDomainLevelCapacityReport.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_domain: Optional[_builtins.str] = None,
                 capacity_availabilities: Optional[Sequence['outputs.BdsCapacityReportShapeAvailabilityDomainLevelCapacityReportCapacityAvailability']] = None,
                 domain_type: Optional[_builtins.str] = None,
                 fault_domain: Optional[_builtins.str] = None):
        """
        :param _builtins.str availability_domain: The availability domain for the capacity report.
        :param Sequence['BdsCapacityReportShapeAvailabilityDomainLevelCapacityReportCapacityAvailabilityArgs'] capacity_availabilities: Information about the available capacity for a shape.
        :param _builtins.str domain_type: Type of domain level for the capacity report.
        :param _builtins.str fault_domain: The fault domain for the capacity report.
        """
        if availability_domain is not None:
            pulumi.set(__self__, "availability_domain", availability_domain)
        if capacity_availabilities is not None:
            pulumi.set(__self__, "capacity_availabilities", capacity_availabilities)
        if domain_type is not None:
            pulumi.set(__self__, "domain_type", domain_type)
        if fault_domain is not None:
            pulumi.set(__self__, "fault_domain", fault_domain)

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[_builtins.str]:
        """
        The availability domain for the capacity report.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="capacityAvailabilities")
    def capacity_availabilities(self) -> Optional[Sequence['outputs.BdsCapacityReportShapeAvailabilityDomainLevelCapacityReportCapacityAvailability']]:
        """
        Information about the available capacity for a shape.
        """
        return pulumi.get(self, "capacity_availabilities")

    @_builtins.property
    @pulumi.getter(name="domainType")
    def domain_type(self) -> Optional[_builtins.str]:
        """
        Type of domain level for the capacity report.
        """
        return pulumi.get(self, "domain_type")

    @_builtins.property
    @pulumi.getter(name="faultDomain")
    def fault_domain(self) -> Optional[_builtins.str]:
        """
        The fault domain for the capacity report.
        """
        return pulumi.get(self, "fault_domain")


@pulumi.output_type
class BdsCapacityReportShapeAvailabilityDomainLevelCapacityReportCapacityAvailability(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityStatus":
            suggest = "availability_status"
        elif key == "availableCount":
            suggest = "available_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsCapacityReportShapeAvailabilityDomainLevelCapacityReportCapacityAvailability. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsCapacityReportShapeAvailabilityDomainLevelCapacityReportCapacityAvailability.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsCapacityReportShapeAvailabilityDomainLevelCapacityReportCapacityAvailability.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_status: Optional[_builtins.str] = None,
                 available_count: Optional[_builtins.str] = None):
        """
        :param _builtins.str availability_status: A flag denoting whether capacity is available.
        :param _builtins.str available_count: The total number of new cluster nodes that can be created with the specified shape configuration.
        """
        if availability_status is not None:
            pulumi.set(__self__, "availability_status", availability_status)
        if available_count is not None:
            pulumi.set(__self__, "available_count", available_count)

    @_builtins.property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional[_builtins.str]:
        """
        A flag denoting whether capacity is available.
        """
        return pulumi.get(self, "availability_status")

    @_builtins.property
    @pulumi.getter(name="availableCount")
    def available_count(self) -> Optional[_builtins.str]:
        """
        The total number of new cluster nodes that can be created with the specified shape configuration.
        """
        return pulumi.get(self, "available_count")


@pulumi.output_type
class BdsCapacityReportShapeAvailabilityShapeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "memoryInGbs":
            suggest = "memory_in_gbs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsCapacityReportShapeAvailabilityShapeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsCapacityReportShapeAvailabilityShapeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsCapacityReportShapeAvailabilityShapeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 memory_in_gbs: Optional[_builtins.int] = None,
                 nvmes: Optional[_builtins.int] = None,
                 ocpus: Optional[_builtins.int] = None):
        """
        :param _builtins.int memory_in_gbs: The total amount of memory available to the node, in gigabytes.
        :param _builtins.int nvmes: The number of NVMe drives to be used for storage. A single drive has 6.8 TB available. This parameter is used only for dense shapes.
        :param _builtins.int ocpus: The total number of OCPUs available to the node.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if nvmes is not None:
            pulumi.set(__self__, "nvmes", nvmes)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[_builtins.int]:
        """
        The total amount of memory available to the node, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @_builtins.property
    @pulumi.getter
    def nvmes(self) -> Optional[_builtins.int]:
        """
        The number of NVMe drives to be used for storage. A single drive has 6.8 TB available. This parameter is used only for dense shapes.
        """
        return pulumi.get(self, "nvmes")

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> Optional[_builtins.int]:
        """
        The total number of OCPUs available to the node.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "ocpus")


@pulumi.output_type
class BdsInstanceBdsClusterVersionSummary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bdsVersion":
            suggest = "bds_version"
        elif key == "odhVersion":
            suggest = "odh_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsInstanceBdsClusterVersionSummary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsInstanceBdsClusterVersionSummary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsInstanceBdsClusterVersionSummary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bds_version: _builtins.str,
                 odh_version: Optional[_builtins.str] = None):
        """
        :param _builtins.str bds_version: BDS version to be used for cluster creation
        :param _builtins.str odh_version: ODH version to be used for cluster creation
        """
        pulumi.set(__self__, "bds_version", bds_version)
        if odh_version is not None:
            pulumi.set(__self__, "odh_version", odh_version)

    @_builtins.property
    @pulumi.getter(name="bdsVersion")
    def bds_version(self) -> _builtins.str:
        """
        BDS version to be used for cluster creation
        """
        return pulumi.get(self, "bds_version")

    @_builtins.property
    @pulumi.getter(name="odhVersion")
    def odh_version(self) -> Optional[_builtins.str]:
        """
        ODH version to be used for cluster creation
        """
        return pulumi.get(self, "odh_version")


@pulumi.output_type
class BdsInstanceCloudSqlDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockVolumeSizeInGbs":
            suggest = "block_volume_size_in_gbs"
        elif key == "ipAddress":
            suggest = "ip_address"
        elif key == "isKerberosMappedToDatabaseUsers":
            suggest = "is_kerberos_mapped_to_database_users"
        elif key == "kerberosDetails":
            suggest = "kerberos_details"
        elif key == "memoryInGbs":
            suggest = "memory_in_gbs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsInstanceCloudSqlDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsInstanceCloudSqlDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsInstanceCloudSqlDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 shape: _builtins.str,
                 block_volume_size_in_gbs: Optional[_builtins.str] = None,
                 ip_address: Optional[_builtins.str] = None,
                 is_kerberos_mapped_to_database_users: Optional[_builtins.bool] = None,
                 kerberos_details: Optional[Sequence['outputs.BdsInstanceCloudSqlDetailKerberosDetail']] = None,
                 memory_in_gbs: Optional[_builtins.int] = None,
                 nvmes: Optional[_builtins.int] = None,
                 ocpus: Optional[_builtins.int] = None):
        """
        :param _builtins.str shape: Shape of the node
        :param _builtins.str block_volume_size_in_gbs: The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        :param _builtins.str ip_address: IP address of the node
        :param _builtins.bool is_kerberos_mapped_to_database_users: Boolean flag specifying whether or not are Kerberos principals mapped to database users.
        :param Sequence['BdsInstanceCloudSqlDetailKerberosDetailArgs'] kerberos_details: Details about Kerberos principals
        :param _builtins.int memory_in_gbs: The total amount of memory available to the node, in gigabytes.
        :param _builtins.int nvmes: The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        :param _builtins.int ocpus: The total number of OCPUs available to the node.
        """
        pulumi.set(__self__, "shape", shape)
        if block_volume_size_in_gbs is not None:
            pulumi.set(__self__, "block_volume_size_in_gbs", block_volume_size_in_gbs)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if is_kerberos_mapped_to_database_users is not None:
            pulumi.set(__self__, "is_kerberos_mapped_to_database_users", is_kerberos_mapped_to_database_users)
        if kerberos_details is not None:
            pulumi.set(__self__, "kerberos_details", kerberos_details)
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if nvmes is not None:
            pulumi.set(__self__, "nvmes", nvmes)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        Shape of the node
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter(name="blockVolumeSizeInGbs")
    def block_volume_size_in_gbs(self) -> Optional[_builtins.str]:
        """
        The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        """
        return pulumi.get(self, "block_volume_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[_builtins.str]:
        """
        IP address of the node
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter(name="isKerberosMappedToDatabaseUsers")
    def is_kerberos_mapped_to_database_users(self) -> Optional[_builtins.bool]:
        """
        Boolean flag specifying whether or not are Kerberos principals mapped to database users.
        """
        return pulumi.get(self, "is_kerberos_mapped_to_database_users")

    @_builtins.property
    @pulumi.getter(name="kerberosDetails")
    def kerberos_details(self) -> Optional[Sequence['outputs.BdsInstanceCloudSqlDetailKerberosDetail']]:
        """
        Details about Kerberos principals
        """
        return pulumi.get(self, "kerberos_details")

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[_builtins.int]:
        """
        The total amount of memory available to the node, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @_builtins.property
    @pulumi.getter
    def nvmes(self) -> Optional[_builtins.int]:
        """
        The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        """
        return pulumi.get(self, "nvmes")

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> Optional[_builtins.int]:
        """
        The total number of OCPUs available to the node.
        """
        return pulumi.get(self, "ocpus")


@pulumi.output_type
class BdsInstanceCloudSqlDetailKerberosDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keytabFile":
            suggest = "keytab_file"
        elif key == "principalName":
            suggest = "principal_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsInstanceCloudSqlDetailKerberosDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsInstanceCloudSqlDetailKerberosDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsInstanceCloudSqlDetailKerberosDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 keytab_file: Optional[_builtins.str] = None,
                 principal_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str keytab_file: Location of the keytab file
        :param _builtins.str principal_name: Name of the Kerberos principal
        """
        if keytab_file is not None:
            pulumi.set(__self__, "keytab_file", keytab_file)
        if principal_name is not None:
            pulumi.set(__self__, "principal_name", principal_name)

    @_builtins.property
    @pulumi.getter(name="keytabFile")
    def keytab_file(self) -> Optional[_builtins.str]:
        """
        Location of the keytab file
        """
        return pulumi.get(self, "keytab_file")

    @_builtins.property
    @pulumi.getter(name="principalName")
    def principal_name(self) -> Optional[_builtins.str]:
        """
        Name of the Kerberos principal
        """
        return pulumi.get(self, "principal_name")


@pulumi.output_type
class BdsInstanceClusterDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ambariUrl":
            suggest = "ambari_url"
        elif key == "bdCellVersion":
            suggest = "bd_cell_version"
        elif key == "bdaVersion":
            suggest = "bda_version"
        elif key == "bdmVersion":
            suggest = "bdm_version"
        elif key == "bdsVersion":
            suggest = "bds_version"
        elif key == "bigDataManagerUrl":
            suggest = "big_data_manager_url"
        elif key == "clouderaManagerUrl":
            suggest = "cloudera_manager_url"
        elif key == "csqlCellVersion":
            suggest = "csql_cell_version"
        elif key == "dbVersion":
            suggest = "db_version"
        elif key == "hueServerUrl":
            suggest = "hue_server_url"
        elif key == "jupyterHubUrl":
            suggest = "jupyter_hub_url"
        elif key == "odhVersion":
            suggest = "odh_version"
        elif key == "osVersion":
            suggest = "os_version"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeRefreshed":
            suggest = "time_refreshed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsInstanceClusterDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsInstanceClusterDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsInstanceClusterDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ambari_url: Optional[_builtins.str] = None,
                 bd_cell_version: Optional[_builtins.str] = None,
                 bda_version: Optional[_builtins.str] = None,
                 bdm_version: Optional[_builtins.str] = None,
                 bds_version: Optional[_builtins.str] = None,
                 big_data_manager_url: Optional[_builtins.str] = None,
                 cloudera_manager_url: Optional[_builtins.str] = None,
                 csql_cell_version: Optional[_builtins.str] = None,
                 db_version: Optional[_builtins.str] = None,
                 hue_server_url: Optional[_builtins.str] = None,
                 jupyter_hub_url: Optional[_builtins.str] = None,
                 odh_version: Optional[_builtins.str] = None,
                 os_version: Optional[_builtins.str] = None,
                 time_created: Optional[_builtins.str] = None,
                 time_refreshed: Optional[_builtins.str] = None):
        """
        :param _builtins.str ambari_url: The URL of Ambari
        :param _builtins.str bd_cell_version: Cloud SQL cell version.
        :param _builtins.str bda_version: BDA version installed in the cluster
        :param _builtins.str bdm_version: Big Data Manager version installed in the cluster.
        :param _builtins.str bds_version: Big Data Service version installed in the cluster.
        :param _builtins.str big_data_manager_url: The URL of Big Data Manager.
        :param _builtins.str cloudera_manager_url: The URL of Cloudera Manager
        :param _builtins.str csql_cell_version: Big Data SQL version.
        :param _builtins.str db_version: Cloud SQL query server database version.
        :param _builtins.str hue_server_url: The URL of the Hue server.
        :param _builtins.str jupyter_hub_url: The URL of the Jupyterhub.
        :param _builtins.str odh_version: Version of the ODH (Oracle Distribution including Apache Hadoop) for the node.
        :param _builtins.str os_version: BDS-assigned Operating System version for the node.
        :param _builtins.str time_created: The time the BDS instance was created. An RFC3339 formatted datetime string
        :param _builtins.str time_refreshed: The time the cluster was automatically or manually refreshed, shown as an RFC 3339 formatted datetime string.
        """
        if ambari_url is not None:
            pulumi.set(__self__, "ambari_url", ambari_url)
        if bd_cell_version is not None:
            pulumi.set(__self__, "bd_cell_version", bd_cell_version)
        if bda_version is not None:
            pulumi.set(__self__, "bda_version", bda_version)
        if bdm_version is not None:
            pulumi.set(__self__, "bdm_version", bdm_version)
        if bds_version is not None:
            pulumi.set(__self__, "bds_version", bds_version)
        if big_data_manager_url is not None:
            pulumi.set(__self__, "big_data_manager_url", big_data_manager_url)
        if cloudera_manager_url is not None:
            pulumi.set(__self__, "cloudera_manager_url", cloudera_manager_url)
        if csql_cell_version is not None:
            pulumi.set(__self__, "csql_cell_version", csql_cell_version)
        if db_version is not None:
            pulumi.set(__self__, "db_version", db_version)
        if hue_server_url is not None:
            pulumi.set(__self__, "hue_server_url", hue_server_url)
        if jupyter_hub_url is not None:
            pulumi.set(__self__, "jupyter_hub_url", jupyter_hub_url)
        if odh_version is not None:
            pulumi.set(__self__, "odh_version", odh_version)
        if os_version is not None:
            pulumi.set(__self__, "os_version", os_version)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_refreshed is not None:
            pulumi.set(__self__, "time_refreshed", time_refreshed)

    @_builtins.property
    @pulumi.getter(name="ambariUrl")
    def ambari_url(self) -> Optional[_builtins.str]:
        """
        The URL of Ambari
        """
        return pulumi.get(self, "ambari_url")

    @_builtins.property
    @pulumi.getter(name="bdCellVersion")
    def bd_cell_version(self) -> Optional[_builtins.str]:
        """
        Cloud SQL cell version.
        """
        return pulumi.get(self, "bd_cell_version")

    @_builtins.property
    @pulumi.getter(name="bdaVersion")
    def bda_version(self) -> Optional[_builtins.str]:
        """
        BDA version installed in the cluster
        """
        return pulumi.get(self, "bda_version")

    @_builtins.property
    @pulumi.getter(name="bdmVersion")
    def bdm_version(self) -> Optional[_builtins.str]:
        """
        Big Data Manager version installed in the cluster.
        """
        return pulumi.get(self, "bdm_version")

    @_builtins.property
    @pulumi.getter(name="bdsVersion")
    def bds_version(self) -> Optional[_builtins.str]:
        """
        Big Data Service version installed in the cluster.
        """
        return pulumi.get(self, "bds_version")

    @_builtins.property
    @pulumi.getter(name="bigDataManagerUrl")
    def big_data_manager_url(self) -> Optional[_builtins.str]:
        """
        The URL of Big Data Manager.
        """
        return pulumi.get(self, "big_data_manager_url")

    @_builtins.property
    @pulumi.getter(name="clouderaManagerUrl")
    def cloudera_manager_url(self) -> Optional[_builtins.str]:
        """
        The URL of Cloudera Manager
        """
        return pulumi.get(self, "cloudera_manager_url")

    @_builtins.property
    @pulumi.getter(name="csqlCellVersion")
    def csql_cell_version(self) -> Optional[_builtins.str]:
        """
        Big Data SQL version.
        """
        return pulumi.get(self, "csql_cell_version")

    @_builtins.property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> Optional[_builtins.str]:
        """
        Cloud SQL query server database version.
        """
        return pulumi.get(self, "db_version")

    @_builtins.property
    @pulumi.getter(name="hueServerUrl")
    def hue_server_url(self) -> Optional[_builtins.str]:
        """
        The URL of the Hue server.
        """
        return pulumi.get(self, "hue_server_url")

    @_builtins.property
    @pulumi.getter(name="jupyterHubUrl")
    def jupyter_hub_url(self) -> Optional[_builtins.str]:
        """
        The URL of the Jupyterhub.
        """
        return pulumi.get(self, "jupyter_hub_url")

    @_builtins.property
    @pulumi.getter(name="odhVersion")
    def odh_version(self) -> Optional[_builtins.str]:
        """
        Version of the ODH (Oracle Distribution including Apache Hadoop) for the node.
        """
        return pulumi.get(self, "odh_version")

    @_builtins.property
    @pulumi.getter(name="osVersion")
    def os_version(self) -> Optional[_builtins.str]:
        """
        BDS-assigned Operating System version for the node.
        """
        return pulumi.get(self, "os_version")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[_builtins.str]:
        """
        The time the BDS instance was created. An RFC3339 formatted datetime string
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeRefreshed")
    def time_refreshed(self) -> Optional[_builtins.str]:
        """
        The time the cluster was automatically or manually refreshed, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_refreshed")


@pulumi.output_type
class BdsInstanceComputeOnlyWorkerNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numberOfNodes":
            suggest = "number_of_nodes"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "blockVolumeSizeInGbs":
            suggest = "block_volume_size_in_gbs"
        elif key == "shapeConfig":
            suggest = "shape_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsInstanceComputeOnlyWorkerNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsInstanceComputeOnlyWorkerNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsInstanceComputeOnlyWorkerNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 number_of_nodes: _builtins.int,
                 shape: _builtins.str,
                 subnet_id: _builtins.str,
                 block_volume_size_in_gbs: Optional[_builtins.str] = None,
                 shape_config: Optional['outputs.BdsInstanceComputeOnlyWorkerNodeShapeConfig'] = None):
        """
        :param _builtins.int number_of_nodes: Number of nodes that forming the cluster
        :param _builtins.str shape: Shape of the node
        :param _builtins.str subnet_id: The OCID of the subnet in which the node should be created
        :param _builtins.str block_volume_size_in_gbs: The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        """
        pulumi.set(__self__, "number_of_nodes", number_of_nodes)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if block_volume_size_in_gbs is not None:
            pulumi.set(__self__, "block_volume_size_in_gbs", block_volume_size_in_gbs)
        if shape_config is not None:
            pulumi.set(__self__, "shape_config", shape_config)

    @_builtins.property
    @pulumi.getter(name="numberOfNodes")
    def number_of_nodes(self) -> _builtins.int:
        """
        Number of nodes that forming the cluster
        """
        return pulumi.get(self, "number_of_nodes")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        Shape of the node
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The OCID of the subnet in which the node should be created
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="blockVolumeSizeInGbs")
    def block_volume_size_in_gbs(self) -> Optional[_builtins.str]:
        """
        The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        """
        return pulumi.get(self, "block_volume_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="shapeConfig")
    def shape_config(self) -> Optional['outputs.BdsInstanceComputeOnlyWorkerNodeShapeConfig']:
        return pulumi.get(self, "shape_config")


@pulumi.output_type
class BdsInstanceComputeOnlyWorkerNodeShapeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "memoryInGbs":
            suggest = "memory_in_gbs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsInstanceComputeOnlyWorkerNodeShapeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsInstanceComputeOnlyWorkerNodeShapeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsInstanceComputeOnlyWorkerNodeShapeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 memory_in_gbs: Optional[_builtins.int] = None,
                 nvmes: Optional[_builtins.int] = None,
                 ocpus: Optional[_builtins.int] = None):
        """
        :param _builtins.int memory_in_gbs: The total amount of memory available to the node, in gigabytes.
        :param _builtins.int nvmes: The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        :param _builtins.int ocpus: The total number of OCPUs available to the node.
        """
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if nvmes is not None:
            pulumi.set(__self__, "nvmes", nvmes)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[_builtins.int]:
        """
        The total amount of memory available to the node, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @_builtins.property
    @pulumi.getter
    def nvmes(self) -> Optional[_builtins.int]:
        """
        The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        """
        return pulumi.get(self, "nvmes")

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> Optional[_builtins.int]:
        """
        The total number of OCPUs available to the node.
        """
        return pulumi.get(self, "ocpus")


@pulumi.output_type
class BdsInstanceEdgeNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numberOfNodes":
            suggest = "number_of_nodes"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "blockVolumeSizeInGbs":
            suggest = "block_volume_size_in_gbs"
        elif key == "shapeConfig":
            suggest = "shape_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsInstanceEdgeNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsInstanceEdgeNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsInstanceEdgeNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 number_of_nodes: _builtins.int,
                 shape: _builtins.str,
                 subnet_id: _builtins.str,
                 block_volume_size_in_gbs: Optional[_builtins.str] = None,
                 shape_config: Optional['outputs.BdsInstanceEdgeNodeShapeConfig'] = None):
        """
        :param _builtins.int number_of_nodes: Number of nodes that forming the cluster
        :param _builtins.str shape: Shape of the node
        :param _builtins.str subnet_id: The OCID of the subnet in which the node should be created
        :param _builtins.str block_volume_size_in_gbs: The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        """
        pulumi.set(__self__, "number_of_nodes", number_of_nodes)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if block_volume_size_in_gbs is not None:
            pulumi.set(__self__, "block_volume_size_in_gbs", block_volume_size_in_gbs)
        if shape_config is not None:
            pulumi.set(__self__, "shape_config", shape_config)

    @_builtins.property
    @pulumi.getter(name="numberOfNodes")
    def number_of_nodes(self) -> _builtins.int:
        """
        Number of nodes that forming the cluster
        """
        return pulumi.get(self, "number_of_nodes")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        Shape of the node
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The OCID of the subnet in which the node should be created
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="blockVolumeSizeInGbs")
    def block_volume_size_in_gbs(self) -> Optional[_builtins.str]:
        """
        The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        """
        return pulumi.get(self, "block_volume_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="shapeConfig")
    def shape_config(self) -> Optional['outputs.BdsInstanceEdgeNodeShapeConfig']:
        return pulumi.get(self, "shape_config")


@pulumi.output_type
class BdsInstanceEdgeNodeShapeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "memoryInGbs":
            suggest = "memory_in_gbs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsInstanceEdgeNodeShapeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsInstanceEdgeNodeShapeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsInstanceEdgeNodeShapeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 memory_in_gbs: Optional[_builtins.int] = None,
                 nvmes: Optional[_builtins.int] = None,
                 ocpus: Optional[_builtins.int] = None):
        """
        :param _builtins.int memory_in_gbs: The total amount of memory available to the node, in gigabytes.
        :param _builtins.int nvmes: The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        :param _builtins.int ocpus: The total number of OCPUs available to the node.
        """
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if nvmes is not None:
            pulumi.set(__self__, "nvmes", nvmes)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[_builtins.int]:
        """
        The total amount of memory available to the node, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @_builtins.property
    @pulumi.getter
    def nvmes(self) -> Optional[_builtins.int]:
        """
        The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        """
        return pulumi.get(self, "nvmes")

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> Optional[_builtins.int]:
        """
        The total number of OCPUs available to the node.
        """
        return pulumi.get(self, "ocpus")


@pulumi.output_type
class BdsInstanceIdentityConfigurationIamUserSyncConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isPosixAttributesAdditionRequired":
            suggest = "is_posix_attributes_addition_required"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeUpdated":
            suggest = "time_updated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsInstanceIdentityConfigurationIamUserSyncConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsInstanceIdentityConfigurationIamUserSyncConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsInstanceIdentityConfigurationIamUserSyncConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_posix_attributes_addition_required: Optional[_builtins.bool] = None,
                 state: Optional[_builtins.str] = None,
                 time_created: Optional[_builtins.str] = None,
                 time_updated: Optional[_builtins.str] = None):
        """
        :param _builtins.bool is_posix_attributes_addition_required: whether to append POSIX attributes to IAM users
        :param _builtins.str state: Lifecycle state of the UPST config
        :param _builtins.str time_created: Time when this UPST config was created, shown as an RFC 3339 formatted datetime string.
        :param _builtins.str time_updated: Time when this UPST config was updated, shown as an RFC 3339 formatted datetime string.
        """
        if is_posix_attributes_addition_required is not None:
            pulumi.set(__self__, "is_posix_attributes_addition_required", is_posix_attributes_addition_required)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)

    @_builtins.property
    @pulumi.getter(name="isPosixAttributesAdditionRequired")
    def is_posix_attributes_addition_required(self) -> Optional[_builtins.bool]:
        """
        whether to append POSIX attributes to IAM users
        """
        return pulumi.get(self, "is_posix_attributes_addition_required")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Lifecycle state of the UPST config
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[_builtins.str]:
        """
        Time when this UPST config was created, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[_builtins.str]:
        """
        Time when this UPST config was updated, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class BdsInstanceIdentityConfigurationIamUserSyncConfigurationDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isPosixAttributesAdditionRequired":
            suggest = "is_posix_attributes_addition_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsInstanceIdentityConfigurationIamUserSyncConfigurationDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsInstanceIdentityConfigurationIamUserSyncConfigurationDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsInstanceIdentityConfigurationIamUserSyncConfigurationDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_posix_attributes_addition_required: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool is_posix_attributes_addition_required: (Updatable) whether posix attribute needs to be appended to users, required for updating IAM user sync configuration
        """
        if is_posix_attributes_addition_required is not None:
            pulumi.set(__self__, "is_posix_attributes_addition_required", is_posix_attributes_addition_required)

    @_builtins.property
    @pulumi.getter(name="isPosixAttributesAdditionRequired")
    def is_posix_attributes_addition_required(self) -> Optional[_builtins.bool]:
        """
        (Updatable) whether posix attribute needs to be appended to users, required for updating IAM user sync configuration
        """
        return pulumi.get(self, "is_posix_attributes_addition_required")


@pulumi.output_type
class BdsInstanceIdentityConfigurationUpstConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keytabContent":
            suggest = "keytab_content"
        elif key == "masterEncryptionKeyId":
            suggest = "master_encryption_key_id"
        elif key == "secretId":
            suggest = "secret_id"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeTokenExchangeKeytabLastRefreshed":
            suggest = "time_token_exchange_keytab_last_refreshed"
        elif key == "timeUpdated":
            suggest = "time_updated"
        elif key == "tokenExchangePrincipalName":
            suggest = "token_exchange_principal_name"
        elif key == "vaultId":
            suggest = "vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsInstanceIdentityConfigurationUpstConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsInstanceIdentityConfigurationUpstConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsInstanceIdentityConfigurationUpstConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 keytab_content: Optional[_builtins.str] = None,
                 master_encryption_key_id: Optional[_builtins.str] = None,
                 secret_id: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None,
                 time_created: Optional[_builtins.str] = None,
                 time_token_exchange_keytab_last_refreshed: Optional[_builtins.str] = None,
                 time_updated: Optional[_builtins.str] = None,
                 token_exchange_principal_name: Optional[_builtins.str] = None,
                 vault_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str keytab_content: The kerberos keytab content used for creating identity propagation trust config, in base64 format
        :param _builtins.str master_encryption_key_id: Master Encryption key used for encrypting token exchange keytab.
        :param _builtins.str secret_id: Secret ID for token exchange keytab
        :param _builtins.str state: Lifecycle state of the UPST config
        :param _builtins.str time_created: Time when this UPST config was created, shown as an RFC 3339 formatted datetime string.
        :param _builtins.str time_token_exchange_keytab_last_refreshed: Time when the keytab for token exchange principal is last refreshed, shown as an RFC 3339 formatted datetime string.
        :param _builtins.str time_updated: Time when this UPST config was updated, shown as an RFC 3339 formatted datetime string.
        :param _builtins.str token_exchange_principal_name: Token exchange kerberos Principal name in cluster
        :param _builtins.str vault_id: The instance OCID of the node, which is the resource from which the node backup was acquired.
        """
        if keytab_content is not None:
            pulumi.set(__self__, "keytab_content", keytab_content)
        if master_encryption_key_id is not None:
            pulumi.set(__self__, "master_encryption_key_id", master_encryption_key_id)
        if secret_id is not None:
            pulumi.set(__self__, "secret_id", secret_id)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_token_exchange_keytab_last_refreshed is not None:
            pulumi.set(__self__, "time_token_exchange_keytab_last_refreshed", time_token_exchange_keytab_last_refreshed)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)
        if token_exchange_principal_name is not None:
            pulumi.set(__self__, "token_exchange_principal_name", token_exchange_principal_name)
        if vault_id is not None:
            pulumi.set(__self__, "vault_id", vault_id)

    @_builtins.property
    @pulumi.getter(name="keytabContent")
    def keytab_content(self) -> Optional[_builtins.str]:
        """
        The kerberos keytab content used for creating identity propagation trust config, in base64 format
        """
        return pulumi.get(self, "keytab_content")

    @_builtins.property
    @pulumi.getter(name="masterEncryptionKeyId")
    def master_encryption_key_id(self) -> Optional[_builtins.str]:
        """
        Master Encryption key used for encrypting token exchange keytab.
        """
        return pulumi.get(self, "master_encryption_key_id")

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> Optional[_builtins.str]:
        """
        Secret ID for token exchange keytab
        """
        return pulumi.get(self, "secret_id")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Lifecycle state of the UPST config
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[_builtins.str]:
        """
        Time when this UPST config was created, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeTokenExchangeKeytabLastRefreshed")
    def time_token_exchange_keytab_last_refreshed(self) -> Optional[_builtins.str]:
        """
        Time when the keytab for token exchange principal is last refreshed, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_token_exchange_keytab_last_refreshed")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[_builtins.str]:
        """
        Time when this UPST config was updated, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_updated")

    @_builtins.property
    @pulumi.getter(name="tokenExchangePrincipalName")
    def token_exchange_principal_name(self) -> Optional[_builtins.str]:
        """
        Token exchange kerberos Principal name in cluster
        """
        return pulumi.get(self, "token_exchange_principal_name")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[_builtins.str]:
        """
        The instance OCID of the node, which is the resource from which the node backup was acquired.
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class BdsInstanceIdentityConfigurationUpstConfigurationDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "masterEncryptionKeyId":
            suggest = "master_encryption_key_id"
        elif key == "vaultId":
            suggest = "vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsInstanceIdentityConfigurationUpstConfigurationDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsInstanceIdentityConfigurationUpstConfigurationDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsInstanceIdentityConfigurationUpstConfigurationDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 master_encryption_key_id: Optional[_builtins.str] = None,
                 vault_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str master_encryption_key_id: (Updatable) OCID of the master encryption key in vault for encrypting token exchange service principal keytab, required for activating UPST config
        :param _builtins.str vault_id: (Updatable) OCID of the vault to store token exchange service principal keyta, required for activating UPST config
        """
        if master_encryption_key_id is not None:
            pulumi.set(__self__, "master_encryption_key_id", master_encryption_key_id)
        if vault_id is not None:
            pulumi.set(__self__, "vault_id", vault_id)

    @_builtins.property
    @pulumi.getter(name="masterEncryptionKeyId")
    def master_encryption_key_id(self) -> Optional[_builtins.str]:
        """
        (Updatable) OCID of the master encryption key in vault for encrypting token exchange service principal keytab, required for activating UPST config
        """
        return pulumi.get(self, "master_encryption_key_id")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[_builtins.str]:
        """
        (Updatable) OCID of the vault to store token exchange service principal keyta, required for activating UPST config
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class BdsInstanceKafkaBrokerNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numberOfKafkaNodes":
            suggest = "number_of_kafka_nodes"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "blockVolumeSizeInGbs":
            suggest = "block_volume_size_in_gbs"
        elif key == "shapeConfig":
            suggest = "shape_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsInstanceKafkaBrokerNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsInstanceKafkaBrokerNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsInstanceKafkaBrokerNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 number_of_kafka_nodes: _builtins.int,
                 shape: _builtins.str,
                 subnet_id: _builtins.str,
                 block_volume_size_in_gbs: Optional[_builtins.str] = None,
                 shape_config: Optional['outputs.BdsInstanceKafkaBrokerNodeShapeConfig'] = None):
        """
        :param _builtins.str shape: Shape of the node
        :param _builtins.str subnet_id: The OCID of the subnet in which the node should be created
        :param _builtins.str block_volume_size_in_gbs: The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        :param 'BdsInstanceKafkaBrokerNodeShapeConfigArgs' shape_config: The shape configuration requested for the node.
        """
        pulumi.set(__self__, "number_of_kafka_nodes", number_of_kafka_nodes)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if block_volume_size_in_gbs is not None:
            pulumi.set(__self__, "block_volume_size_in_gbs", block_volume_size_in_gbs)
        if shape_config is not None:
            pulumi.set(__self__, "shape_config", shape_config)

    @_builtins.property
    @pulumi.getter(name="numberOfKafkaNodes")
    def number_of_kafka_nodes(self) -> _builtins.int:
        return pulumi.get(self, "number_of_kafka_nodes")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        Shape of the node
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The OCID of the subnet in which the node should be created
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="blockVolumeSizeInGbs")
    def block_volume_size_in_gbs(self) -> Optional[_builtins.str]:
        """
        The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        """
        return pulumi.get(self, "block_volume_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="shapeConfig")
    def shape_config(self) -> Optional['outputs.BdsInstanceKafkaBrokerNodeShapeConfig']:
        """
        The shape configuration requested for the node.
        """
        return pulumi.get(self, "shape_config")


@pulumi.output_type
class BdsInstanceKafkaBrokerNodeShapeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "memoryInGbs":
            suggest = "memory_in_gbs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsInstanceKafkaBrokerNodeShapeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsInstanceKafkaBrokerNodeShapeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsInstanceKafkaBrokerNodeShapeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 memory_in_gbs: Optional[_builtins.int] = None,
                 nvmes: Optional[_builtins.int] = None,
                 ocpus: Optional[_builtins.int] = None):
        """
        :param _builtins.int memory_in_gbs: The total amount of memory available to the node, in gigabytes
        :param _builtins.int nvmes: The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        :param _builtins.int ocpus: The total number of OCPUs available to the node.
        """
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if nvmes is not None:
            pulumi.set(__self__, "nvmes", nvmes)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[_builtins.int]:
        """
        The total amount of memory available to the node, in gigabytes
        """
        return pulumi.get(self, "memory_in_gbs")

    @_builtins.property
    @pulumi.getter
    def nvmes(self) -> Optional[_builtins.int]:
        """
        The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        """
        return pulumi.get(self, "nvmes")

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> Optional[_builtins.int]:
        """
        The total number of OCPUs available to the node.
        """
        return pulumi.get(self, "ocpus")


@pulumi.output_type
class BdsInstanceMasterNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numberOfNodes":
            suggest = "number_of_nodes"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "blockVolumeSizeInGbs":
            suggest = "block_volume_size_in_gbs"
        elif key == "shapeConfig":
            suggest = "shape_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsInstanceMasterNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsInstanceMasterNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsInstanceMasterNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 number_of_nodes: _builtins.int,
                 shape: _builtins.str,
                 subnet_id: _builtins.str,
                 block_volume_size_in_gbs: Optional[_builtins.str] = None,
                 shape_config: Optional['outputs.BdsInstanceMasterNodeShapeConfig'] = None):
        """
        :param _builtins.int number_of_nodes: The amount of master nodes should be created.
        :param _builtins.str shape: Shape of the node
        :param _builtins.str subnet_id: The OCID of the subnet in which the node should be created
        :param _builtins.str block_volume_size_in_gbs: The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        :param 'BdsInstanceMasterNodeShapeConfigArgs' shape_config: The shape configuration requested for the node.
        """
        pulumi.set(__self__, "number_of_nodes", number_of_nodes)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if block_volume_size_in_gbs is not None:
            pulumi.set(__self__, "block_volume_size_in_gbs", block_volume_size_in_gbs)
        if shape_config is not None:
            pulumi.set(__self__, "shape_config", shape_config)

    @_builtins.property
    @pulumi.getter(name="numberOfNodes")
    def number_of_nodes(self) -> _builtins.int:
        """
        The amount of master nodes should be created.
        """
        return pulumi.get(self, "number_of_nodes")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        Shape of the node
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The OCID of the subnet in which the node should be created
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="blockVolumeSizeInGbs")
    def block_volume_size_in_gbs(self) -> Optional[_builtins.str]:
        """
        The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        """
        return pulumi.get(self, "block_volume_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="shapeConfig")
    def shape_config(self) -> Optional['outputs.BdsInstanceMasterNodeShapeConfig']:
        """
        The shape configuration requested for the node.
        """
        return pulumi.get(self, "shape_config")


@pulumi.output_type
class BdsInstanceMasterNodeShapeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "memoryInGbs":
            suggest = "memory_in_gbs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsInstanceMasterNodeShapeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsInstanceMasterNodeShapeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsInstanceMasterNodeShapeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 memory_in_gbs: Optional[_builtins.int] = None,
                 nvmes: Optional[_builtins.int] = None,
                 ocpus: Optional[_builtins.int] = None):
        """
        :param _builtins.int memory_in_gbs: The total amount of memory available to the node, in gigabytes
        :param _builtins.int nvmes: The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        :param _builtins.int ocpus: The total number of OCPUs available to the node.
        """
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if nvmes is not None:
            pulumi.set(__self__, "nvmes", nvmes)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[_builtins.int]:
        """
        The total amount of memory available to the node, in gigabytes
        """
        return pulumi.get(self, "memory_in_gbs")

    @_builtins.property
    @pulumi.getter
    def nvmes(self) -> Optional[_builtins.int]:
        """
        The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        """
        return pulumi.get(self, "nvmes")

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> Optional[_builtins.int]:
        """
        The total number of OCPUs available to the node.
        """
        return pulumi.get(self, "ocpus")


@pulumi.output_type
class BdsInstanceNetworkConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cidrBlock":
            suggest = "cidr_block"
        elif key == "isNatGatewayRequired":
            suggest = "is_nat_gateway_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsInstanceNetworkConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsInstanceNetworkConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsInstanceNetworkConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr_block: Optional[_builtins.str] = None,
                 is_nat_gateway_required: Optional[_builtins.bool] = None):
        """
        :param _builtins.str cidr_block: (Updatable) The CIDR IP address block of the VCN.
        :param _builtins.bool is_nat_gateway_required: (Updatable) A boolean flag whether to configure a NAT gateway.
        """
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if is_nat_gateway_required is not None:
            pulumi.set(__self__, "is_nat_gateway_required", is_nat_gateway_required)

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[_builtins.str]:
        """
        (Updatable) The CIDR IP address block of the VCN.
        """
        return pulumi.get(self, "cidr_block")

    @_builtins.property
    @pulumi.getter(name="isNatGatewayRequired")
    def is_nat_gateway_required(self) -> Optional[_builtins.bool]:
        """
        (Updatable) A boolean flag whether to configure a NAT gateway.
        """
        return pulumi.get(self, "is_nat_gateway_required")


@pulumi.output_type
class BdsInstanceNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attachedBlockVolumes":
            suggest = "attached_block_volumes"
        elif key == "availabilityDomain":
            suggest = "availability_domain"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "faultDomain":
            suggest = "fault_domain"
        elif key == "imageId":
            suggest = "image_id"
        elif key == "instanceId":
            suggest = "instance_id"
        elif key == "ipAddress":
            suggest = "ip_address"
        elif key == "isRebootRequired":
            suggest = "is_reboot_required"
        elif key == "localDisksTotalSizeInGbs":
            suggest = "local_disks_total_size_in_gbs"
        elif key == "memoryInGbs":
            suggest = "memory_in_gbs"
        elif key == "nodeType":
            suggest = "node_type"
        elif key == "odhVersion":
            suggest = "odh_version"
        elif key == "osVersion":
            suggest = "os_version"
        elif key == "sshFingerprint":
            suggest = "ssh_fingerprint"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeMaintenanceRebootDue":
            suggest = "time_maintenance_reboot_due"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsInstanceNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsInstanceNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsInstanceNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attached_block_volumes: Optional[Sequence['outputs.BdsInstanceNodeAttachedBlockVolume']] = None,
                 availability_domain: Optional[_builtins.str] = None,
                 display_name: Optional[_builtins.str] = None,
                 fault_domain: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 image_id: Optional[_builtins.str] = None,
                 instance_id: Optional[_builtins.str] = None,
                 ip_address: Optional[_builtins.str] = None,
                 is_reboot_required: Optional[_builtins.bool] = None,
                 local_disks_total_size_in_gbs: Optional[_builtins.float] = None,
                 memory_in_gbs: Optional[_builtins.int] = None,
                 node_type: Optional[_builtins.str] = None,
                 nvmes: Optional[_builtins.int] = None,
                 ocpus: Optional[_builtins.int] = None,
                 odh_version: Optional[_builtins.str] = None,
                 os_version: Optional[_builtins.str] = None,
                 shape: Optional[_builtins.str] = None,
                 ssh_fingerprint: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None,
                 subnet_id: Optional[_builtins.str] = None,
                 time_created: Optional[_builtins.str] = None,
                 time_maintenance_reboot_due: Optional[_builtins.str] = None):
        """
        :param Sequence['BdsInstanceNodeAttachedBlockVolumeArgs'] attached_block_volumes: The list of block volumes attached to a given node.
        :param _builtins.str availability_domain: The name of the availability domain the node is running in
        :param _builtins.str display_name: (Updatable) Name of the BDS instance
        :param _builtins.str fault_domain: The name of the fault domain the node is running in
        :param _builtins.str hostname: The fully-qualified hostname (FQDN) of the node
        :param _builtins.str image_id: The OCID of the image from which the node was created
        :param _builtins.str instance_id: The OCID of the underlying compute instance
        :param _builtins.str ip_address: IP address of the node
        :param _builtins.bool is_reboot_required: Indicates if the node requires a reboot to either reflect the latest os kernel or take actions for maintenance reboot.
        :param _builtins.float local_disks_total_size_in_gbs: The aggregate size of all local disks, in gigabytes. If the instance does not have any local disks, this field is null.
        :param _builtins.int memory_in_gbs: The total amount of memory available to the node, in gigabytes.
        :param _builtins.str node_type: The Big Data Service cluster node type.
        :param _builtins.int nvmes: The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        :param _builtins.int ocpus: The total number of OCPUs available to the node.
        :param _builtins.str odh_version: Version of the ODH (Oracle Distribution including Apache Hadoop) for the node.
        :param _builtins.str os_version: BDS-assigned Operating System version for the node.
        :param _builtins.str shape: (Updatable) Shape of the node.
        :param _builtins.str ssh_fingerprint: The fingerprint of the SSH key used for node access
        :param _builtins.str state: (Updatable) The target state for the Bds Instance. Could be set to `ACTIVE` or `INACTIVE` to start/stop the bds instance.
        :param _builtins.str subnet_id: The OCID of the subnet in which the node will be created.
        :param _builtins.str time_created: The time the BDS instance was created. An RFC3339 formatted datetime string
        :param _builtins.str time_maintenance_reboot_due: The date and time the instance is expected to be stopped / started, in the format defined by RFC3339.
        """
        if attached_block_volumes is not None:
            pulumi.set(__self__, "attached_block_volumes", attached_block_volumes)
        if availability_domain is not None:
            pulumi.set(__self__, "availability_domain", availability_domain)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if fault_domain is not None:
            pulumi.set(__self__, "fault_domain", fault_domain)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if is_reboot_required is not None:
            pulumi.set(__self__, "is_reboot_required", is_reboot_required)
        if local_disks_total_size_in_gbs is not None:
            pulumi.set(__self__, "local_disks_total_size_in_gbs", local_disks_total_size_in_gbs)
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if node_type is not None:
            pulumi.set(__self__, "node_type", node_type)
        if nvmes is not None:
            pulumi.set(__self__, "nvmes", nvmes)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)
        if odh_version is not None:
            pulumi.set(__self__, "odh_version", odh_version)
        if os_version is not None:
            pulumi.set(__self__, "os_version", os_version)
        if shape is not None:
            pulumi.set(__self__, "shape", shape)
        if ssh_fingerprint is not None:
            pulumi.set(__self__, "ssh_fingerprint", ssh_fingerprint)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_maintenance_reboot_due is not None:
            pulumi.set(__self__, "time_maintenance_reboot_due", time_maintenance_reboot_due)

    @_builtins.property
    @pulumi.getter(name="attachedBlockVolumes")
    def attached_block_volumes(self) -> Optional[Sequence['outputs.BdsInstanceNodeAttachedBlockVolume']]:
        """
        The list of block volumes attached to a given node.
        """
        return pulumi.get(self, "attached_block_volumes")

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[_builtins.str]:
        """
        The name of the availability domain the node is running in
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        (Updatable) Name of the BDS instance
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="faultDomain")
    def fault_domain(self) -> Optional[_builtins.str]:
        """
        The name of the fault domain the node is running in
        """
        return pulumi.get(self, "fault_domain")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The fully-qualified hostname (FQDN) of the node
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[_builtins.str]:
        """
        The OCID of the image from which the node was created
        """
        return pulumi.get(self, "image_id")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[_builtins.str]:
        """
        The OCID of the underlying compute instance
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[_builtins.str]:
        """
        IP address of the node
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter(name="isRebootRequired")
    def is_reboot_required(self) -> Optional[_builtins.bool]:
        """
        Indicates if the node requires a reboot to either reflect the latest os kernel or take actions for maintenance reboot.
        """
        return pulumi.get(self, "is_reboot_required")

    @_builtins.property
    @pulumi.getter(name="localDisksTotalSizeInGbs")
    def local_disks_total_size_in_gbs(self) -> Optional[_builtins.float]:
        """
        The aggregate size of all local disks, in gigabytes. If the instance does not have any local disks, this field is null.
        """
        return pulumi.get(self, "local_disks_total_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[_builtins.int]:
        """
        The total amount of memory available to the node, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @_builtins.property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> Optional[_builtins.str]:
        """
        The Big Data Service cluster node type.
        """
        return pulumi.get(self, "node_type")

    @_builtins.property
    @pulumi.getter
    def nvmes(self) -> Optional[_builtins.int]:
        """
        The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        """
        return pulumi.get(self, "nvmes")

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> Optional[_builtins.int]:
        """
        The total number of OCPUs available to the node.
        """
        return pulumi.get(self, "ocpus")

    @_builtins.property
    @pulumi.getter(name="odhVersion")
    def odh_version(self) -> Optional[_builtins.str]:
        """
        Version of the ODH (Oracle Distribution including Apache Hadoop) for the node.
        """
        return pulumi.get(self, "odh_version")

    @_builtins.property
    @pulumi.getter(name="osVersion")
    def os_version(self) -> Optional[_builtins.str]:
        """
        BDS-assigned Operating System version for the node.
        """
        return pulumi.get(self, "os_version")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> Optional[_builtins.str]:
        """
        (Updatable) Shape of the node.
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter(name="sshFingerprint")
    def ssh_fingerprint(self) -> Optional[_builtins.str]:
        """
        The fingerprint of the SSH key used for node access
        """
        return pulumi.get(self, "ssh_fingerprint")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        (Updatable) The target state for the Bds Instance. Could be set to `ACTIVE` or `INACTIVE` to start/stop the bds instance.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        The OCID of the subnet in which the node will be created.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[_builtins.str]:
        """
        The time the BDS instance was created. An RFC3339 formatted datetime string
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeMaintenanceRebootDue")
    def time_maintenance_reboot_due(self) -> Optional[_builtins.str]:
        """
        The date and time the instance is expected to be stopped / started, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_maintenance_reboot_due")


@pulumi.output_type
class BdsInstanceNodeAttachedBlockVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeAttachmentId":
            suggest = "volume_attachment_id"
        elif key == "volumeSizeInGbs":
            suggest = "volume_size_in_gbs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsInstanceNodeAttachedBlockVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsInstanceNodeAttachedBlockVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsInstanceNodeAttachedBlockVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 volume_attachment_id: Optional[_builtins.str] = None,
                 volume_size_in_gbs: Optional[_builtins.str] = None):
        """
        :param _builtins.str volume_attachment_id: The OCID of the volume attachment.
        :param _builtins.str volume_size_in_gbs: The size of the volume in GBs.
        """
        if volume_attachment_id is not None:
            pulumi.set(__self__, "volume_attachment_id", volume_attachment_id)
        if volume_size_in_gbs is not None:
            pulumi.set(__self__, "volume_size_in_gbs", volume_size_in_gbs)

    @_builtins.property
    @pulumi.getter(name="volumeAttachmentId")
    def volume_attachment_id(self) -> Optional[_builtins.str]:
        """
        The OCID of the volume attachment.
        """
        return pulumi.get(self, "volume_attachment_id")

    @_builtins.property
    @pulumi.getter(name="volumeSizeInGbs")
    def volume_size_in_gbs(self) -> Optional[_builtins.str]:
        """
        The size of the volume in GBs.
        """
        return pulumi.get(self, "volume_size_in_gbs")


@pulumi.output_type
class BdsInstanceNodeBackupConfigurationLevelTypeDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "levelType":
            suggest = "level_type"
        elif key == "nodeHostName":
            suggest = "node_host_name"
        elif key == "nodeType":
            suggest = "node_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsInstanceNodeBackupConfigurationLevelTypeDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsInstanceNodeBackupConfigurationLevelTypeDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsInstanceNodeBackupConfigurationLevelTypeDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 level_type: _builtins.str,
                 node_host_name: Optional[_builtins.str] = None,
                 node_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str level_type: (Updatable) Type of level used to trigger the creation of a new node backup configuration or node replacement configuration.
        :param _builtins.str node_host_name: (Updatable) Host name of the node to create backup configuration.
        :param _builtins.str node_type: (Updatable) Type of the node or nodes of the node backup configuration or node replacement configuration which are going to be created. Accepted values are MASTER and UTILITY.
        """
        pulumi.set(__self__, "level_type", level_type)
        if node_host_name is not None:
            pulumi.set(__self__, "node_host_name", node_host_name)
        if node_type is not None:
            pulumi.set(__self__, "node_type", node_type)

    @_builtins.property
    @pulumi.getter(name="levelType")
    def level_type(self) -> _builtins.str:
        """
        (Updatable) Type of level used to trigger the creation of a new node backup configuration or node replacement configuration.
        """
        return pulumi.get(self, "level_type")

    @_builtins.property
    @pulumi.getter(name="nodeHostName")
    def node_host_name(self) -> Optional[_builtins.str]:
        """
        (Updatable) Host name of the node to create backup configuration.
        """
        return pulumi.get(self, "node_host_name")

    @_builtins.property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> Optional[_builtins.str]:
        """
        (Updatable) Type of the node or nodes of the node backup configuration or node replacement configuration which are going to be created. Accepted values are MASTER and UTILITY.
        """
        return pulumi.get(self, "node_type")


@pulumi.output_type
class BdsInstanceNodeBackupLevelTypeDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "levelType":
            suggest = "level_type"
        elif key == "nodeHostName":
            suggest = "node_host_name"
        elif key == "nodeType":
            suggest = "node_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsInstanceNodeBackupLevelTypeDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsInstanceNodeBackupLevelTypeDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsInstanceNodeBackupLevelTypeDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 level_type: _builtins.str,
                 node_host_name: Optional[_builtins.str] = None,
                 node_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str level_type: Type of level used to trigger the creation of a new node backup.
        :param _builtins.str node_host_name: (Updatable) Host name of the node to create backup.
        :param _builtins.str node_type: (Updatable) Type of the node or nodes of the node backup which are going to be created.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "level_type", level_type)
        if node_host_name is not None:
            pulumi.set(__self__, "node_host_name", node_host_name)
        if node_type is not None:
            pulumi.set(__self__, "node_type", node_type)

    @_builtins.property
    @pulumi.getter(name="levelType")
    def level_type(self) -> _builtins.str:
        """
        Type of level used to trigger the creation of a new node backup.
        """
        return pulumi.get(self, "level_type")

    @_builtins.property
    @pulumi.getter(name="nodeHostName")
    def node_host_name(self) -> Optional[_builtins.str]:
        """
        (Updatable) Host name of the node to create backup.
        """
        return pulumi.get(self, "node_host_name")

    @_builtins.property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> Optional[_builtins.str]:
        """
        (Updatable) Type of the node or nodes of the node backup which are going to be created.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "node_type")


@pulumi.output_type
class BdsInstanceNodeReplaceConfigurationLevelTypeDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "levelType":
            suggest = "level_type"
        elif key == "nodeHostName":
            suggest = "node_host_name"
        elif key == "nodeType":
            suggest = "node_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsInstanceNodeReplaceConfigurationLevelTypeDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsInstanceNodeReplaceConfigurationLevelTypeDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsInstanceNodeReplaceConfigurationLevelTypeDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 level_type: _builtins.str,
                 node_host_name: Optional[_builtins.str] = None,
                 node_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str level_type: (Updatable) Type of level used to trigger the creation of a new node backup configuration or node replacement configuration. Accepted values are NODE_LEVEL and NODE_TYPE_LEVEL.
        :param _builtins.str node_host_name: (Updatable) Host name of the node to create backup configuration.
        :param _builtins.str node_type: (Updatable) Type of the node or nodes of the node backup configuration or node replacement configuration which are going to be created.
        """
        pulumi.set(__self__, "level_type", level_type)
        if node_host_name is not None:
            pulumi.set(__self__, "node_host_name", node_host_name)
        if node_type is not None:
            pulumi.set(__self__, "node_type", node_type)

    @_builtins.property
    @pulumi.getter(name="levelType")
    def level_type(self) -> _builtins.str:
        """
        (Updatable) Type of level used to trigger the creation of a new node backup configuration or node replacement configuration. Accepted values are NODE_LEVEL and NODE_TYPE_LEVEL.
        """
        return pulumi.get(self, "level_type")

    @_builtins.property
    @pulumi.getter(name="nodeHostName")
    def node_host_name(self) -> Optional[_builtins.str]:
        """
        (Updatable) Host name of the node to create backup configuration.
        """
        return pulumi.get(self, "node_host_name")

    @_builtins.property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> Optional[_builtins.str]:
        """
        (Updatable) Type of the node or nodes of the node backup configuration or node replacement configuration which are going to be created.
        """
        return pulumi.get(self, "node_type")


@pulumi.output_type
class BdsInstanceOperationCertificateManagementsManagementHostCertDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostName":
            suggest = "host_name"
        elif key == "privateKey":
            suggest = "private_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsInstanceOperationCertificateManagementsManagementHostCertDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsInstanceOperationCertificateManagementsManagementHostCertDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsInstanceOperationCertificateManagementsManagementHostCertDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate: Optional[_builtins.str] = None,
                 host_name: Optional[_builtins.str] = None,
                 private_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str certificate: Certificate value in string format
        :param _builtins.str host_name: Fully qualified domain name (FQDN) of the host
        :param _builtins.str private_key: Private key of the provided certificate
        """
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[_builtins.str]:
        """
        Certificate value in string format
        """
        return pulumi.get(self, "certificate")

    @_builtins.property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[_builtins.str]:
        """
        Fully qualified domain name (FQDN) of the host
        """
        return pulumi.get(self, "host_name")

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[_builtins.str]:
        """
        Private key of the provided certificate
        """
        return pulumi.get(self, "private_key")


@pulumi.output_type
class BdsInstanceOsPatchActionPatchingConfigs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "patchingConfigStrategy":
            suggest = "patching_config_strategy"
        elif key == "batchSize":
            suggest = "batch_size"
        elif key == "toleranceThresholdPerBatch":
            suggest = "tolerance_threshold_per_batch"
        elif key == "toleranceThresholdPerDomain":
            suggest = "tolerance_threshold_per_domain"
        elif key == "waitTimeBetweenBatchInSeconds":
            suggest = "wait_time_between_batch_in_seconds"
        elif key == "waitTimeBetweenDomainInSeconds":
            suggest = "wait_time_between_domain_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsInstanceOsPatchActionPatchingConfigs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsInstanceOsPatchActionPatchingConfigs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsInstanceOsPatchActionPatchingConfigs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 patching_config_strategy: _builtins.str,
                 batch_size: Optional[_builtins.int] = None,
                 tolerance_threshold_per_batch: Optional[_builtins.int] = None,
                 tolerance_threshold_per_domain: Optional[_builtins.int] = None,
                 wait_time_between_batch_in_seconds: Optional[_builtins.int] = None,
                 wait_time_between_domain_in_seconds: Optional[_builtins.int] = None):
        """
        :param _builtins.str patching_config_strategy: Type of strategy used for detailed patching configuration
        :param _builtins.int batch_size: How many nodes to be patched in each iteration.
        :param _builtins.int tolerance_threshold_per_batch: Acceptable number of failed-to-be-patched nodes in each batch. The maximum number of failed-to-patch nodes cannot exceed 20% of the number of nodes.
        :param _builtins.int tolerance_threshold_per_domain: Acceptable number of failed-to-be-patched nodes in each domain. The maximum number of failed-to-patch nodes cannot exceed 20% of the number of nodes.
        :param _builtins.int wait_time_between_batch_in_seconds: The wait time between batches in seconds.
        :param _builtins.int wait_time_between_domain_in_seconds: The wait time between AD/FD in seconds.
        """
        pulumi.set(__self__, "patching_config_strategy", patching_config_strategy)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if tolerance_threshold_per_batch is not None:
            pulumi.set(__self__, "tolerance_threshold_per_batch", tolerance_threshold_per_batch)
        if tolerance_threshold_per_domain is not None:
            pulumi.set(__self__, "tolerance_threshold_per_domain", tolerance_threshold_per_domain)
        if wait_time_between_batch_in_seconds is not None:
            pulumi.set(__self__, "wait_time_between_batch_in_seconds", wait_time_between_batch_in_seconds)
        if wait_time_between_domain_in_seconds is not None:
            pulumi.set(__self__, "wait_time_between_domain_in_seconds", wait_time_between_domain_in_seconds)

    @_builtins.property
    @pulumi.getter(name="patchingConfigStrategy")
    def patching_config_strategy(self) -> _builtins.str:
        """
        Type of strategy used for detailed patching configuration
        """
        return pulumi.get(self, "patching_config_strategy")

    @_builtins.property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[_builtins.int]:
        """
        How many nodes to be patched in each iteration.
        """
        return pulumi.get(self, "batch_size")

    @_builtins.property
    @pulumi.getter(name="toleranceThresholdPerBatch")
    def tolerance_threshold_per_batch(self) -> Optional[_builtins.int]:
        """
        Acceptable number of failed-to-be-patched nodes in each batch. The maximum number of failed-to-patch nodes cannot exceed 20% of the number of nodes.
        """
        return pulumi.get(self, "tolerance_threshold_per_batch")

    @_builtins.property
    @pulumi.getter(name="toleranceThresholdPerDomain")
    def tolerance_threshold_per_domain(self) -> Optional[_builtins.int]:
        """
        Acceptable number of failed-to-be-patched nodes in each domain. The maximum number of failed-to-patch nodes cannot exceed 20% of the number of nodes.
        """
        return pulumi.get(self, "tolerance_threshold_per_domain")

    @_builtins.property
    @pulumi.getter(name="waitTimeBetweenBatchInSeconds")
    def wait_time_between_batch_in_seconds(self) -> Optional[_builtins.int]:
        """
        The wait time between batches in seconds.
        """
        return pulumi.get(self, "wait_time_between_batch_in_seconds")

    @_builtins.property
    @pulumi.getter(name="waitTimeBetweenDomainInSeconds")
    def wait_time_between_domain_in_seconds(self) -> Optional[_builtins.int]:
        """
        The wait time between AD/FD in seconds.
        """
        return pulumi.get(self, "wait_time_between_domain_in_seconds")


@pulumi.output_type
class BdsInstancePatchActionPatchingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "patchingConfigStrategy":
            suggest = "patching_config_strategy"
        elif key == "batchSize":
            suggest = "batch_size"
        elif key == "toleranceThresholdPerBatch":
            suggest = "tolerance_threshold_per_batch"
        elif key == "toleranceThresholdPerDomain":
            suggest = "tolerance_threshold_per_domain"
        elif key == "waitTimeBetweenBatchInSeconds":
            suggest = "wait_time_between_batch_in_seconds"
        elif key == "waitTimeBetweenDomainInSeconds":
            suggest = "wait_time_between_domain_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsInstancePatchActionPatchingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsInstancePatchActionPatchingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsInstancePatchActionPatchingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 patching_config_strategy: _builtins.str,
                 batch_size: Optional[_builtins.int] = None,
                 tolerance_threshold_per_batch: Optional[_builtins.int] = None,
                 tolerance_threshold_per_domain: Optional[_builtins.int] = None,
                 wait_time_between_batch_in_seconds: Optional[_builtins.int] = None,
                 wait_time_between_domain_in_seconds: Optional[_builtins.int] = None):
        """
        :param _builtins.str patching_config_strategy: Type of strategy used for detailed patching configuration
        :param _builtins.int batch_size: How many nodes to be patched in each iteration.
        :param _builtins.int tolerance_threshold_per_batch: Acceptable number of failed-to-be-patched nodes in each batch. The maximum number of failed-to-patch nodes cannot exceed 20% of the number of non-utility and non-master nodes.
        :param _builtins.int tolerance_threshold_per_domain: Acceptable number of failed-to-be-patched nodes in each domain. The maximum number of failed-to-patch nodes cannot exceed 20% of the number of non-utility and non-master nodes.
        :param _builtins.int wait_time_between_batch_in_seconds: The wait time between batches in seconds.
        :param _builtins.int wait_time_between_domain_in_seconds: The wait time between AD/FD in seconds.
        """
        pulumi.set(__self__, "patching_config_strategy", patching_config_strategy)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if tolerance_threshold_per_batch is not None:
            pulumi.set(__self__, "tolerance_threshold_per_batch", tolerance_threshold_per_batch)
        if tolerance_threshold_per_domain is not None:
            pulumi.set(__self__, "tolerance_threshold_per_domain", tolerance_threshold_per_domain)
        if wait_time_between_batch_in_seconds is not None:
            pulumi.set(__self__, "wait_time_between_batch_in_seconds", wait_time_between_batch_in_seconds)
        if wait_time_between_domain_in_seconds is not None:
            pulumi.set(__self__, "wait_time_between_domain_in_seconds", wait_time_between_domain_in_seconds)

    @_builtins.property
    @pulumi.getter(name="patchingConfigStrategy")
    def patching_config_strategy(self) -> _builtins.str:
        """
        Type of strategy used for detailed patching configuration
        """
        return pulumi.get(self, "patching_config_strategy")

    @_builtins.property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[_builtins.int]:
        """
        How many nodes to be patched in each iteration.
        """
        return pulumi.get(self, "batch_size")

    @_builtins.property
    @pulumi.getter(name="toleranceThresholdPerBatch")
    def tolerance_threshold_per_batch(self) -> Optional[_builtins.int]:
        """
        Acceptable number of failed-to-be-patched nodes in each batch. The maximum number of failed-to-patch nodes cannot exceed 20% of the number of non-utility and non-master nodes.
        """
        return pulumi.get(self, "tolerance_threshold_per_batch")

    @_builtins.property
    @pulumi.getter(name="toleranceThresholdPerDomain")
    def tolerance_threshold_per_domain(self) -> Optional[_builtins.int]:
        """
        Acceptable number of failed-to-be-patched nodes in each domain. The maximum number of failed-to-patch nodes cannot exceed 20% of the number of non-utility and non-master nodes.
        """
        return pulumi.get(self, "tolerance_threshold_per_domain")

    @_builtins.property
    @pulumi.getter(name="waitTimeBetweenBatchInSeconds")
    def wait_time_between_batch_in_seconds(self) -> Optional[_builtins.int]:
        """
        The wait time between batches in seconds.
        """
        return pulumi.get(self, "wait_time_between_batch_in_seconds")

    @_builtins.property
    @pulumi.getter(name="waitTimeBetweenDomainInSeconds")
    def wait_time_between_domain_in_seconds(self) -> Optional[_builtins.int]:
        """
        The wait time between AD/FD in seconds.
        """
        return pulumi.get(self, "wait_time_between_domain_in_seconds")


@pulumi.output_type
class BdsInstanceStartClusterShapeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeTypeShapeConfigs":
            suggest = "node_type_shape_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsInstanceStartClusterShapeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsInstanceStartClusterShapeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsInstanceStartClusterShapeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_type_shape_configs: Optional[Sequence['outputs.BdsInstanceStartClusterShapeConfigNodeTypeShapeConfig']] = None):
        if node_type_shape_configs is not None:
            pulumi.set(__self__, "node_type_shape_configs", node_type_shape_configs)

    @_builtins.property
    @pulumi.getter(name="nodeTypeShapeConfigs")
    def node_type_shape_configs(self) -> Optional[Sequence['outputs.BdsInstanceStartClusterShapeConfigNodeTypeShapeConfig']]:
        return pulumi.get(self, "node_type_shape_configs")


@pulumi.output_type
class BdsInstanceStartClusterShapeConfigNodeTypeShapeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeType":
            suggest = "node_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsInstanceStartClusterShapeConfigNodeTypeShapeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsInstanceStartClusterShapeConfigNodeTypeShapeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsInstanceStartClusterShapeConfigNodeTypeShapeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_type: Optional[_builtins.str] = None,
                 shape: Optional[_builtins.str] = None):
        """
        :param _builtins.str node_type: BDS instance node type
        :param _builtins.str shape: Shape of the node
        """
        if node_type is not None:
            pulumi.set(__self__, "node_type", node_type)
        if shape is not None:
            pulumi.set(__self__, "shape", shape)

    @_builtins.property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> Optional[_builtins.str]:
        """
        BDS instance node type
        """
        return pulumi.get(self, "node_type")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> Optional[_builtins.str]:
        """
        Shape of the node
        """
        return pulumi.get(self, "shape")


@pulumi.output_type
class BdsInstanceUtilNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numberOfNodes":
            suggest = "number_of_nodes"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "blockVolumeSizeInGbs":
            suggest = "block_volume_size_in_gbs"
        elif key == "shapeConfig":
            suggest = "shape_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsInstanceUtilNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsInstanceUtilNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsInstanceUtilNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 number_of_nodes: _builtins.int,
                 shape: _builtins.str,
                 subnet_id: _builtins.str,
                 block_volume_size_in_gbs: Optional[_builtins.str] = None,
                 shape_config: Optional['outputs.BdsInstanceUtilNodeShapeConfig'] = None):
        """
        :param _builtins.int number_of_nodes: The amount of utility nodes should be created.
        :param _builtins.str shape: Shape of the node
        :param _builtins.str subnet_id: The OCID of the subnet in which the node should be created
        :param _builtins.str block_volume_size_in_gbs: The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        :param 'BdsInstanceUtilNodeShapeConfigArgs' shape_config: The shape configuration requested for the node.
        """
        pulumi.set(__self__, "number_of_nodes", number_of_nodes)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if block_volume_size_in_gbs is not None:
            pulumi.set(__self__, "block_volume_size_in_gbs", block_volume_size_in_gbs)
        if shape_config is not None:
            pulumi.set(__self__, "shape_config", shape_config)

    @_builtins.property
    @pulumi.getter(name="numberOfNodes")
    def number_of_nodes(self) -> _builtins.int:
        """
        The amount of utility nodes should be created.
        """
        return pulumi.get(self, "number_of_nodes")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        Shape of the node
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The OCID of the subnet in which the node should be created
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="blockVolumeSizeInGbs")
    def block_volume_size_in_gbs(self) -> Optional[_builtins.str]:
        """
        The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        """
        return pulumi.get(self, "block_volume_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="shapeConfig")
    def shape_config(self) -> Optional['outputs.BdsInstanceUtilNodeShapeConfig']:
        """
        The shape configuration requested for the node.
        """
        return pulumi.get(self, "shape_config")


@pulumi.output_type
class BdsInstanceUtilNodeShapeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "memoryInGbs":
            suggest = "memory_in_gbs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsInstanceUtilNodeShapeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsInstanceUtilNodeShapeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsInstanceUtilNodeShapeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 memory_in_gbs: Optional[_builtins.int] = None,
                 nvmes: Optional[_builtins.int] = None,
                 ocpus: Optional[_builtins.int] = None):
        """
        :param _builtins.int memory_in_gbs: The total amount of memory available to the node, in gigabytes
        :param _builtins.int nvmes: The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        :param _builtins.int ocpus: The total number of OCPUs available to the node.
        """
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if nvmes is not None:
            pulumi.set(__self__, "nvmes", nvmes)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[_builtins.int]:
        """
        The total amount of memory available to the node, in gigabytes
        """
        return pulumi.get(self, "memory_in_gbs")

    @_builtins.property
    @pulumi.getter
    def nvmes(self) -> Optional[_builtins.int]:
        """
        The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        """
        return pulumi.get(self, "nvmes")

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> Optional[_builtins.int]:
        """
        The total number of OCPUs available to the node.
        """
        return pulumi.get(self, "ocpus")


@pulumi.output_type
class BdsInstanceWorkerNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numberOfNodes":
            suggest = "number_of_nodes"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "blockVolumeSizeInGbs":
            suggest = "block_volume_size_in_gbs"
        elif key == "shapeConfig":
            suggest = "shape_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsInstanceWorkerNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsInstanceWorkerNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsInstanceWorkerNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 number_of_nodes: _builtins.int,
                 shape: _builtins.str,
                 subnet_id: _builtins.str,
                 block_volume_size_in_gbs: Optional[_builtins.str] = None,
                 shape_config: Optional['outputs.BdsInstanceWorkerNodeShapeConfig'] = None):
        """
        :param _builtins.int number_of_nodes: Number of nodes that forming the cluster
        :param _builtins.str shape: Shape of the node
        :param _builtins.str subnet_id: The OCID of the subnet in which the node should be created
        :param _builtins.str block_volume_size_in_gbs: The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        """
        pulumi.set(__self__, "number_of_nodes", number_of_nodes)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if block_volume_size_in_gbs is not None:
            pulumi.set(__self__, "block_volume_size_in_gbs", block_volume_size_in_gbs)
        if shape_config is not None:
            pulumi.set(__self__, "shape_config", shape_config)

    @_builtins.property
    @pulumi.getter(name="numberOfNodes")
    def number_of_nodes(self) -> _builtins.int:
        """
        Number of nodes that forming the cluster
        """
        return pulumi.get(self, "number_of_nodes")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        Shape of the node
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The OCID of the subnet in which the node should be created
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="blockVolumeSizeInGbs")
    def block_volume_size_in_gbs(self) -> Optional[_builtins.str]:
        """
        The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        """
        return pulumi.get(self, "block_volume_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="shapeConfig")
    def shape_config(self) -> Optional['outputs.BdsInstanceWorkerNodeShapeConfig']:
        return pulumi.get(self, "shape_config")


@pulumi.output_type
class BdsInstanceWorkerNodeShapeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "memoryInGbs":
            suggest = "memory_in_gbs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BdsInstanceWorkerNodeShapeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BdsInstanceWorkerNodeShapeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BdsInstanceWorkerNodeShapeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 memory_in_gbs: Optional[_builtins.int] = None,
                 nvmes: Optional[_builtins.int] = None,
                 ocpus: Optional[_builtins.int] = None):
        """
        :param _builtins.int memory_in_gbs: The total amount of memory available to the node, in gigabytes.
        :param _builtins.int nvmes: The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        :param _builtins.int ocpus: The total number of OCPUs available to the node.
        """
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if nvmes is not None:
            pulumi.set(__self__, "nvmes", nvmes)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[_builtins.int]:
        """
        The total amount of memory available to the node, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @_builtins.property
    @pulumi.getter
    def nvmes(self) -> Optional[_builtins.int]:
        """
        The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        """
        return pulumi.get(self, "nvmes")

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> Optional[_builtins.int]:
        """
        The total number of OCPUs available to the node.
        """
        return pulumi.get(self, "ocpus")


@pulumi.output_type
class GetAutoScalingConfigurationPolicyResult(dict):
    def __init__(__self__, *,
                 policy_type: _builtins.str,
                 rules: Sequence['outputs.GetAutoScalingConfigurationPolicyRuleResult']):
        """
        :param _builtins.str policy_type: Type of autoscaling policy.
        :param Sequence['GetAutoScalingConfigurationPolicyRuleArgs'] rules: The list of rules for autoscaling. If an action has multiple rules, the last rule in the array will be applied.
        """
        pulumi.set(__self__, "policy_type", policy_type)
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> _builtins.str:
        """
        Type of autoscaling policy.
        """
        return pulumi.get(self, "policy_type")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetAutoScalingConfigurationPolicyRuleResult']:
        """
        The list of rules for autoscaling. If an action has multiple rules, the last rule in the array will be applied.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class GetAutoScalingConfigurationPolicyDetailResult(dict):
    def __init__(__self__, *,
                 action_type: _builtins.str,
                 policy_type: _builtins.str,
                 scale_down_configs: Sequence['outputs.GetAutoScalingConfigurationPolicyDetailScaleDownConfigResult'],
                 scale_in_configs: Sequence['outputs.GetAutoScalingConfigurationPolicyDetailScaleInConfigResult'],
                 scale_out_configs: Sequence['outputs.GetAutoScalingConfigurationPolicyDetailScaleOutConfigResult'],
                 scale_up_configs: Sequence['outputs.GetAutoScalingConfigurationPolicyDetailScaleUpConfigResult'],
                 schedule_details: Sequence['outputs.GetAutoScalingConfigurationPolicyDetailScheduleDetailResult'],
                 timezone: _builtins.str,
                 trigger_type: _builtins.str):
        """
        :param _builtins.str action_type: The type of autoscaling action to take.
        :param _builtins.str policy_type: Type of autoscaling policy.
        :param Sequence['GetAutoScalingConfigurationPolicyDetailScaleDownConfigArgs'] scale_down_configs: Configration for a metric based vertical scale-down policy.
        :param Sequence['GetAutoScalingConfigurationPolicyDetailScaleInConfigArgs'] scale_in_configs: Configration for a metric based horizontal scale-in policy.
        :param Sequence['GetAutoScalingConfigurationPolicyDetailScaleOutConfigArgs'] scale_out_configs: Configration for a metric based horizontal scale-out policy.
        :param Sequence['GetAutoScalingConfigurationPolicyDetailScaleUpConfigArgs'] scale_up_configs: Configration for a metric based vertical scale-up policy.
        :param Sequence['GetAutoScalingConfigurationPolicyDetailScheduleDetailArgs'] schedule_details: Details of a horizontal scaling schedule.
        :param _builtins.str timezone: The time zone of the execution schedule, in IANA time zone database name format
        :param _builtins.str trigger_type: The type of autoscaling trigger.
        """
        pulumi.set(__self__, "action_type", action_type)
        pulumi.set(__self__, "policy_type", policy_type)
        pulumi.set(__self__, "scale_down_configs", scale_down_configs)
        pulumi.set(__self__, "scale_in_configs", scale_in_configs)
        pulumi.set(__self__, "scale_out_configs", scale_out_configs)
        pulumi.set(__self__, "scale_up_configs", scale_up_configs)
        pulumi.set(__self__, "schedule_details", schedule_details)
        pulumi.set(__self__, "timezone", timezone)
        pulumi.set(__self__, "trigger_type", trigger_type)

    @_builtins.property
    @pulumi.getter(name="actionType")
    def action_type(self) -> _builtins.str:
        """
        The type of autoscaling action to take.
        """
        return pulumi.get(self, "action_type")

    @_builtins.property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> _builtins.str:
        """
        Type of autoscaling policy.
        """
        return pulumi.get(self, "policy_type")

    @_builtins.property
    @pulumi.getter(name="scaleDownConfigs")
    def scale_down_configs(self) -> Sequence['outputs.GetAutoScalingConfigurationPolicyDetailScaleDownConfigResult']:
        """
        Configration for a metric based vertical scale-down policy.
        """
        return pulumi.get(self, "scale_down_configs")

    @_builtins.property
    @pulumi.getter(name="scaleInConfigs")
    def scale_in_configs(self) -> Sequence['outputs.GetAutoScalingConfigurationPolicyDetailScaleInConfigResult']:
        """
        Configration for a metric based horizontal scale-in policy.
        """
        return pulumi.get(self, "scale_in_configs")

    @_builtins.property
    @pulumi.getter(name="scaleOutConfigs")
    def scale_out_configs(self) -> Sequence['outputs.GetAutoScalingConfigurationPolicyDetailScaleOutConfigResult']:
        """
        Configration for a metric based horizontal scale-out policy.
        """
        return pulumi.get(self, "scale_out_configs")

    @_builtins.property
    @pulumi.getter(name="scaleUpConfigs")
    def scale_up_configs(self) -> Sequence['outputs.GetAutoScalingConfigurationPolicyDetailScaleUpConfigResult']:
        """
        Configration for a metric based vertical scale-up policy.
        """
        return pulumi.get(self, "scale_up_configs")

    @_builtins.property
    @pulumi.getter(name="scheduleDetails")
    def schedule_details(self) -> Sequence['outputs.GetAutoScalingConfigurationPolicyDetailScheduleDetailResult']:
        """
        Details of a horizontal scaling schedule.
        """
        return pulumi.get(self, "schedule_details")

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> _builtins.str:
        """
        The time zone of the execution schedule, in IANA time zone database name format
        """
        return pulumi.get(self, "timezone")

    @_builtins.property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> _builtins.str:
        """
        The type of autoscaling trigger.
        """
        return pulumi.get(self, "trigger_type")


@pulumi.output_type
class GetAutoScalingConfigurationPolicyDetailScaleDownConfigResult(dict):
    def __init__(__self__, *,
                 memory_step_size: _builtins.int,
                 metrics: Sequence['outputs.GetAutoScalingConfigurationPolicyDetailScaleDownConfigMetricResult'],
                 min_memory_per_node: _builtins.int,
                 min_ocpus_per_node: _builtins.int,
                 ocpu_step_size: _builtins.int):
        """
        :param _builtins.int memory_step_size: For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the size of memory in GBs to add to each node during a scale-up event. This value is not used for nodes with fixed compute shapes.
        :param Sequence['GetAutoScalingConfigurationPolicyDetailScaleDownConfigMetricArgs'] metrics: Metric and threshold details for triggering an autoscale action.
        :param _builtins.int min_memory_per_node: For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the minimum memory in GBs each node can be scaled-down to. This value is not used for nodes with fixed compute shapes.
        :param _builtins.int min_ocpus_per_node: For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the minimum number of OCPUs each node can be scaled-down to. This value is not used for nodes with fixed compute shapes.
        :param _builtins.int ocpu_step_size: For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the number of OCPUs to add to each node during a scale-up event. This value is not used for nodes with fixed compute shapes.
        """
        pulumi.set(__self__, "memory_step_size", memory_step_size)
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "min_memory_per_node", min_memory_per_node)
        pulumi.set(__self__, "min_ocpus_per_node", min_ocpus_per_node)
        pulumi.set(__self__, "ocpu_step_size", ocpu_step_size)

    @_builtins.property
    @pulumi.getter(name="memoryStepSize")
    def memory_step_size(self) -> _builtins.int:
        """
        For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the size of memory in GBs to add to each node during a scale-up event. This value is not used for nodes with fixed compute shapes.
        """
        return pulumi.get(self, "memory_step_size")

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Sequence['outputs.GetAutoScalingConfigurationPolicyDetailScaleDownConfigMetricResult']:
        """
        Metric and threshold details for triggering an autoscale action.
        """
        return pulumi.get(self, "metrics")

    @_builtins.property
    @pulumi.getter(name="minMemoryPerNode")
    def min_memory_per_node(self) -> _builtins.int:
        """
        For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the minimum memory in GBs each node can be scaled-down to. This value is not used for nodes with fixed compute shapes.
        """
        return pulumi.get(self, "min_memory_per_node")

    @_builtins.property
    @pulumi.getter(name="minOcpusPerNode")
    def min_ocpus_per_node(self) -> _builtins.int:
        """
        For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the minimum number of OCPUs each node can be scaled-down to. This value is not used for nodes with fixed compute shapes.
        """
        return pulumi.get(self, "min_ocpus_per_node")

    @_builtins.property
    @pulumi.getter(name="ocpuStepSize")
    def ocpu_step_size(self) -> _builtins.int:
        """
        For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the number of OCPUs to add to each node during a scale-up event. This value is not used for nodes with fixed compute shapes.
        """
        return pulumi.get(self, "ocpu_step_size")


@pulumi.output_type
class GetAutoScalingConfigurationPolicyDetailScaleDownConfigMetricResult(dict):
    def __init__(__self__, *,
                 metric_type: _builtins.str,
                 thresholds: Sequence['outputs.GetAutoScalingConfigurationPolicyDetailScaleDownConfigMetricThresholdResult']):
        """
        :param _builtins.str metric_type: Allowed values are CPU_UTILIZATION and MEMORY_UTILIZATION.
        :param Sequence['GetAutoScalingConfigurationPolicyDetailScaleDownConfigMetricThresholdArgs'] thresholds: An autoscale action is triggered when a performance metric exceeds a threshold.
        """
        pulumi.set(__self__, "metric_type", metric_type)
        pulumi.set(__self__, "thresholds", thresholds)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> _builtins.str:
        """
        Allowed values are CPU_UTILIZATION and MEMORY_UTILIZATION.
        """
        return pulumi.get(self, "metric_type")

    @_builtins.property
    @pulumi.getter
    def thresholds(self) -> Sequence['outputs.GetAutoScalingConfigurationPolicyDetailScaleDownConfigMetricThresholdResult']:
        """
        An autoscale action is triggered when a performance metric exceeds a threshold.
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class GetAutoScalingConfigurationPolicyDetailScaleDownConfigMetricThresholdResult(dict):
    def __init__(__self__, *,
                 duration_in_minutes: _builtins.int,
                 operator: _builtins.str,
                 value: _builtins.int):
        """
        :param _builtins.int duration_in_minutes: This value is the minimum period of time the metric value exceeds the threshold value before the action is triggered. The value is in minutes.
        :param _builtins.str operator: The comparison operator to use. Options are greater than (GT) or less than (LT).
        :param _builtins.int value: Integer non-negative value. 0 < value < 100
        """
        pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> _builtins.int:
        """
        This value is the minimum period of time the metric value exceeds the threshold value before the action is triggered. The value is in minutes.
        """
        return pulumi.get(self, "duration_in_minutes")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The comparison operator to use. Options are greater than (GT) or less than (LT).
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        """
        Integer non-negative value. 0 < value < 100
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAutoScalingConfigurationPolicyDetailScaleInConfigResult(dict):
    def __init__(__self__, *,
                 metrics: Sequence['outputs.GetAutoScalingConfigurationPolicyDetailScaleInConfigMetricResult'],
                 min_node_count: _builtins.int,
                 step_size: _builtins.int):
        """
        :param Sequence['GetAutoScalingConfigurationPolicyDetailScaleInConfigMetricArgs'] metrics: Metric and threshold details for triggering an autoscale action.
        :param _builtins.int min_node_count: This value is the minimum number of nodes the cluster can be scaled-in to.
        :param _builtins.int step_size: This value is the number of nodes to add during a scale-out event.
        """
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "min_node_count", min_node_count)
        pulumi.set(__self__, "step_size", step_size)

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Sequence['outputs.GetAutoScalingConfigurationPolicyDetailScaleInConfigMetricResult']:
        """
        Metric and threshold details for triggering an autoscale action.
        """
        return pulumi.get(self, "metrics")

    @_builtins.property
    @pulumi.getter(name="minNodeCount")
    def min_node_count(self) -> _builtins.int:
        """
        This value is the minimum number of nodes the cluster can be scaled-in to.
        """
        return pulumi.get(self, "min_node_count")

    @_builtins.property
    @pulumi.getter(name="stepSize")
    def step_size(self) -> _builtins.int:
        """
        This value is the number of nodes to add during a scale-out event.
        """
        return pulumi.get(self, "step_size")


@pulumi.output_type
class GetAutoScalingConfigurationPolicyDetailScaleInConfigMetricResult(dict):
    def __init__(__self__, *,
                 metric_type: _builtins.str,
                 thresholds: Sequence['outputs.GetAutoScalingConfigurationPolicyDetailScaleInConfigMetricThresholdResult']):
        """
        :param _builtins.str metric_type: Allowed values are CPU_UTILIZATION and MEMORY_UTILIZATION.
        :param Sequence['GetAutoScalingConfigurationPolicyDetailScaleInConfigMetricThresholdArgs'] thresholds: An autoscale action is triggered when a performance metric exceeds a threshold.
        """
        pulumi.set(__self__, "metric_type", metric_type)
        pulumi.set(__self__, "thresholds", thresholds)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> _builtins.str:
        """
        Allowed values are CPU_UTILIZATION and MEMORY_UTILIZATION.
        """
        return pulumi.get(self, "metric_type")

    @_builtins.property
    @pulumi.getter
    def thresholds(self) -> Sequence['outputs.GetAutoScalingConfigurationPolicyDetailScaleInConfigMetricThresholdResult']:
        """
        An autoscale action is triggered when a performance metric exceeds a threshold.
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class GetAutoScalingConfigurationPolicyDetailScaleInConfigMetricThresholdResult(dict):
    def __init__(__self__, *,
                 duration_in_minutes: _builtins.int,
                 operator: _builtins.str,
                 value: _builtins.int):
        """
        :param _builtins.int duration_in_minutes: This value is the minimum period of time the metric value exceeds the threshold value before the action is triggered. The value is in minutes.
        :param _builtins.str operator: The comparison operator to use. Options are greater than (GT) or less than (LT).
        :param _builtins.int value: Integer non-negative value. 0 < value < 100
        """
        pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> _builtins.int:
        """
        This value is the minimum period of time the metric value exceeds the threshold value before the action is triggered. The value is in minutes.
        """
        return pulumi.get(self, "duration_in_minutes")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The comparison operator to use. Options are greater than (GT) or less than (LT).
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        """
        Integer non-negative value. 0 < value < 100
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAutoScalingConfigurationPolicyDetailScaleOutConfigResult(dict):
    def __init__(__self__, *,
                 max_node_count: _builtins.int,
                 metrics: Sequence['outputs.GetAutoScalingConfigurationPolicyDetailScaleOutConfigMetricResult'],
                 step_size: _builtins.int):
        """
        :param _builtins.int max_node_count: This value is the maximum number of nodes the cluster can be scaled-out to.
        :param Sequence['GetAutoScalingConfigurationPolicyDetailScaleOutConfigMetricArgs'] metrics: Metric and threshold details for triggering an autoscale action.
        :param _builtins.int step_size: This value is the number of nodes to add during a scale-out event.
        """
        pulumi.set(__self__, "max_node_count", max_node_count)
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "step_size", step_size)

    @_builtins.property
    @pulumi.getter(name="maxNodeCount")
    def max_node_count(self) -> _builtins.int:
        """
        This value is the maximum number of nodes the cluster can be scaled-out to.
        """
        return pulumi.get(self, "max_node_count")

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Sequence['outputs.GetAutoScalingConfigurationPolicyDetailScaleOutConfigMetricResult']:
        """
        Metric and threshold details for triggering an autoscale action.
        """
        return pulumi.get(self, "metrics")

    @_builtins.property
    @pulumi.getter(name="stepSize")
    def step_size(self) -> _builtins.int:
        """
        This value is the number of nodes to add during a scale-out event.
        """
        return pulumi.get(self, "step_size")


@pulumi.output_type
class GetAutoScalingConfigurationPolicyDetailScaleOutConfigMetricResult(dict):
    def __init__(__self__, *,
                 metric_type: _builtins.str,
                 thresholds: Sequence['outputs.GetAutoScalingConfigurationPolicyDetailScaleOutConfigMetricThresholdResult']):
        """
        :param _builtins.str metric_type: Allowed values are CPU_UTILIZATION and MEMORY_UTILIZATION.
        :param Sequence['GetAutoScalingConfigurationPolicyDetailScaleOutConfigMetricThresholdArgs'] thresholds: An autoscale action is triggered when a performance metric exceeds a threshold.
        """
        pulumi.set(__self__, "metric_type", metric_type)
        pulumi.set(__self__, "thresholds", thresholds)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> _builtins.str:
        """
        Allowed values are CPU_UTILIZATION and MEMORY_UTILIZATION.
        """
        return pulumi.get(self, "metric_type")

    @_builtins.property
    @pulumi.getter
    def thresholds(self) -> Sequence['outputs.GetAutoScalingConfigurationPolicyDetailScaleOutConfigMetricThresholdResult']:
        """
        An autoscale action is triggered when a performance metric exceeds a threshold.
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class GetAutoScalingConfigurationPolicyDetailScaleOutConfigMetricThresholdResult(dict):
    def __init__(__self__, *,
                 duration_in_minutes: _builtins.int,
                 operator: _builtins.str,
                 value: _builtins.int):
        """
        :param _builtins.int duration_in_minutes: This value is the minimum period of time the metric value exceeds the threshold value before the action is triggered. The value is in minutes.
        :param _builtins.str operator: The comparison operator to use. Options are greater than (GT) or less than (LT).
        :param _builtins.int value: Integer non-negative value. 0 < value < 100
        """
        pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> _builtins.int:
        """
        This value is the minimum period of time the metric value exceeds the threshold value before the action is triggered. The value is in minutes.
        """
        return pulumi.get(self, "duration_in_minutes")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The comparison operator to use. Options are greater than (GT) or less than (LT).
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        """
        Integer non-negative value. 0 < value < 100
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAutoScalingConfigurationPolicyDetailScaleUpConfigResult(dict):
    def __init__(__self__, *,
                 max_memory_per_node: _builtins.int,
                 max_ocpus_per_node: _builtins.int,
                 memory_step_size: _builtins.int,
                 metrics: Sequence['outputs.GetAutoScalingConfigurationPolicyDetailScaleUpConfigMetricResult'],
                 ocpu_step_size: _builtins.int):
        """
        :param _builtins.int max_memory_per_node: For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the maximum memory in GBs each node can be scaled-up to. This value is not used for nodes with fixed compute shapes.
        :param _builtins.int max_ocpus_per_node: For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the maximum number of OCPUs each node can be scaled-up to. This value is not used for nodes with fixed compute shapes.
        :param _builtins.int memory_step_size: For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the size of memory in GBs to add to each node during a scale-up event. This value is not used for nodes with fixed compute shapes.
        :param Sequence['GetAutoScalingConfigurationPolicyDetailScaleUpConfigMetricArgs'] metrics: Metric and threshold details for triggering an autoscale action.
        :param _builtins.int ocpu_step_size: For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the number of OCPUs to add to each node during a scale-up event. This value is not used for nodes with fixed compute shapes.
        """
        pulumi.set(__self__, "max_memory_per_node", max_memory_per_node)
        pulumi.set(__self__, "max_ocpus_per_node", max_ocpus_per_node)
        pulumi.set(__self__, "memory_step_size", memory_step_size)
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "ocpu_step_size", ocpu_step_size)

    @_builtins.property
    @pulumi.getter(name="maxMemoryPerNode")
    def max_memory_per_node(self) -> _builtins.int:
        """
        For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the maximum memory in GBs each node can be scaled-up to. This value is not used for nodes with fixed compute shapes.
        """
        return pulumi.get(self, "max_memory_per_node")

    @_builtins.property
    @pulumi.getter(name="maxOcpusPerNode")
    def max_ocpus_per_node(self) -> _builtins.int:
        """
        For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the maximum number of OCPUs each node can be scaled-up to. This value is not used for nodes with fixed compute shapes.
        """
        return pulumi.get(self, "max_ocpus_per_node")

    @_builtins.property
    @pulumi.getter(name="memoryStepSize")
    def memory_step_size(self) -> _builtins.int:
        """
        For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the size of memory in GBs to add to each node during a scale-up event. This value is not used for nodes with fixed compute shapes.
        """
        return pulumi.get(self, "memory_step_size")

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Sequence['outputs.GetAutoScalingConfigurationPolicyDetailScaleUpConfigMetricResult']:
        """
        Metric and threshold details for triggering an autoscale action.
        """
        return pulumi.get(self, "metrics")

    @_builtins.property
    @pulumi.getter(name="ocpuStepSize")
    def ocpu_step_size(self) -> _builtins.int:
        """
        For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the number of OCPUs to add to each node during a scale-up event. This value is not used for nodes with fixed compute shapes.
        """
        return pulumi.get(self, "ocpu_step_size")


@pulumi.output_type
class GetAutoScalingConfigurationPolicyDetailScaleUpConfigMetricResult(dict):
    def __init__(__self__, *,
                 metric_type: _builtins.str,
                 thresholds: Sequence['outputs.GetAutoScalingConfigurationPolicyDetailScaleUpConfigMetricThresholdResult']):
        """
        :param _builtins.str metric_type: Allowed values are CPU_UTILIZATION and MEMORY_UTILIZATION.
        :param Sequence['GetAutoScalingConfigurationPolicyDetailScaleUpConfigMetricThresholdArgs'] thresholds: An autoscale action is triggered when a performance metric exceeds a threshold.
        """
        pulumi.set(__self__, "metric_type", metric_type)
        pulumi.set(__self__, "thresholds", thresholds)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> _builtins.str:
        """
        Allowed values are CPU_UTILIZATION and MEMORY_UTILIZATION.
        """
        return pulumi.get(self, "metric_type")

    @_builtins.property
    @pulumi.getter
    def thresholds(self) -> Sequence['outputs.GetAutoScalingConfigurationPolicyDetailScaleUpConfigMetricThresholdResult']:
        """
        An autoscale action is triggered when a performance metric exceeds a threshold.
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class GetAutoScalingConfigurationPolicyDetailScaleUpConfigMetricThresholdResult(dict):
    def __init__(__self__, *,
                 duration_in_minutes: _builtins.int,
                 operator: _builtins.str,
                 value: _builtins.int):
        """
        :param _builtins.int duration_in_minutes: This value is the minimum period of time the metric value exceeds the threshold value before the action is triggered. The value is in minutes.
        :param _builtins.str operator: The comparison operator to use. Options are greater than (GT) or less than (LT).
        :param _builtins.int value: Integer non-negative value. 0 < value < 100
        """
        pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> _builtins.int:
        """
        This value is the minimum period of time the metric value exceeds the threshold value before the action is triggered. The value is in minutes.
        """
        return pulumi.get(self, "duration_in_minutes")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The comparison operator to use. Options are greater than (GT) or less than (LT).
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        """
        Integer non-negative value. 0 < value < 100
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAutoScalingConfigurationPolicyDetailScheduleDetailResult(dict):
    def __init__(__self__, *,
                 schedule_type: _builtins.str,
                 time_and_horizontal_scaling_configs: Sequence['outputs.GetAutoScalingConfigurationPolicyDetailScheduleDetailTimeAndHorizontalScalingConfigResult'],
                 time_and_vertical_scaling_configs: Sequence['outputs.GetAutoScalingConfigurationPolicyDetailScheduleDetailTimeAndVerticalScalingConfigResult']):
        """
        :param _builtins.str schedule_type: The type of schedule.
        :param Sequence['GetAutoScalingConfigurationPolicyDetailScheduleDetailTimeAndHorizontalScalingConfigArgs'] time_and_horizontal_scaling_configs: Time of day and horizontal scaling configuration.
        :param Sequence['GetAutoScalingConfigurationPolicyDetailScheduleDetailTimeAndVerticalScalingConfigArgs'] time_and_vertical_scaling_configs: Time of day and vertical scaling configuration
        """
        pulumi.set(__self__, "schedule_type", schedule_type)
        pulumi.set(__self__, "time_and_horizontal_scaling_configs", time_and_horizontal_scaling_configs)
        pulumi.set(__self__, "time_and_vertical_scaling_configs", time_and_vertical_scaling_configs)

    @_builtins.property
    @pulumi.getter(name="scheduleType")
    def schedule_type(self) -> _builtins.str:
        """
        The type of schedule.
        """
        return pulumi.get(self, "schedule_type")

    @_builtins.property
    @pulumi.getter(name="timeAndHorizontalScalingConfigs")
    def time_and_horizontal_scaling_configs(self) -> Sequence['outputs.GetAutoScalingConfigurationPolicyDetailScheduleDetailTimeAndHorizontalScalingConfigResult']:
        """
        Time of day and horizontal scaling configuration.
        """
        return pulumi.get(self, "time_and_horizontal_scaling_configs")

    @_builtins.property
    @pulumi.getter(name="timeAndVerticalScalingConfigs")
    def time_and_vertical_scaling_configs(self) -> Sequence['outputs.GetAutoScalingConfigurationPolicyDetailScheduleDetailTimeAndVerticalScalingConfigResult']:
        """
        Time of day and vertical scaling configuration
        """
        return pulumi.get(self, "time_and_vertical_scaling_configs")


@pulumi.output_type
class GetAutoScalingConfigurationPolicyDetailScheduleDetailTimeAndHorizontalScalingConfigResult(dict):
    def __init__(__self__, *,
                 target_node_count: _builtins.int,
                 time_recurrence: _builtins.str):
        """
        :param _builtins.int target_node_count: This value is the desired number of nodes in the cluster.
        :param _builtins.str time_recurrence: Day/time recurrence (specified following RFC 5545) at which to trigger autoscaling action. Currently only WEEKLY frequency is supported. Days of the week are specified using BYDAY field. Time of the day is specified using BYHOUR and BYMINUTE fields. Other fields are not supported.
        """
        pulumi.set(__self__, "target_node_count", target_node_count)
        pulumi.set(__self__, "time_recurrence", time_recurrence)

    @_builtins.property
    @pulumi.getter(name="targetNodeCount")
    def target_node_count(self) -> _builtins.int:
        """
        This value is the desired number of nodes in the cluster.
        """
        return pulumi.get(self, "target_node_count")

    @_builtins.property
    @pulumi.getter(name="timeRecurrence")
    def time_recurrence(self) -> _builtins.str:
        """
        Day/time recurrence (specified following RFC 5545) at which to trigger autoscaling action. Currently only WEEKLY frequency is supported. Days of the week are specified using BYDAY field. Time of the day is specified using BYHOUR and BYMINUTE fields. Other fields are not supported.
        """
        return pulumi.get(self, "time_recurrence")


@pulumi.output_type
class GetAutoScalingConfigurationPolicyDetailScheduleDetailTimeAndVerticalScalingConfigResult(dict):
    def __init__(__self__, *,
                 target_memory_per_node: _builtins.int,
                 target_ocpus_per_node: _builtins.int,
                 target_shape: _builtins.str,
                 time_recurrence: _builtins.str):
        """
        :param _builtins.int target_memory_per_node: For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the desired memory in GBs on each node. This value is not used for nodes with fixed compute shapes.
        :param _builtins.int target_ocpus_per_node: For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the desired OCPUs count on each node. This value is not used for nodes with fixed compute shapes.
        :param _builtins.str target_shape: For nodes with [fixed compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the desired shape of each node. This value is not used for nodes with flexible compute shapes.
        :param _builtins.str time_recurrence: Day/time recurrence (specified following RFC 5545) at which to trigger autoscaling action. Currently only WEEKLY frequency is supported. Days of the week are specified using BYDAY field. Time of the day is specified using BYHOUR and BYMINUTE fields. Other fields are not supported.
        """
        pulumi.set(__self__, "target_memory_per_node", target_memory_per_node)
        pulumi.set(__self__, "target_ocpus_per_node", target_ocpus_per_node)
        pulumi.set(__self__, "target_shape", target_shape)
        pulumi.set(__self__, "time_recurrence", time_recurrence)

    @_builtins.property
    @pulumi.getter(name="targetMemoryPerNode")
    def target_memory_per_node(self) -> _builtins.int:
        """
        For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the desired memory in GBs on each node. This value is not used for nodes with fixed compute shapes.
        """
        return pulumi.get(self, "target_memory_per_node")

    @_builtins.property
    @pulumi.getter(name="targetOcpusPerNode")
    def target_ocpus_per_node(self) -> _builtins.int:
        """
        For nodes with [flexible compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the desired OCPUs count on each node. This value is not used for nodes with fixed compute shapes.
        """
        return pulumi.get(self, "target_ocpus_per_node")

    @_builtins.property
    @pulumi.getter(name="targetShape")
    def target_shape(self) -> _builtins.str:
        """
        For nodes with [fixed compute shapes](https://docs.cloud.oracle.com/iaas/Content/bigdata/create-cluster.htm#cluster-plan-shape), this value is the desired shape of each node. This value is not used for nodes with flexible compute shapes.
        """
        return pulumi.get(self, "target_shape")

    @_builtins.property
    @pulumi.getter(name="timeRecurrence")
    def time_recurrence(self) -> _builtins.str:
        """
        Day/time recurrence (specified following RFC 5545) at which to trigger autoscaling action. Currently only WEEKLY frequency is supported. Days of the week are specified using BYDAY field. Time of the day is specified using BYHOUR and BYMINUTE fields. Other fields are not supported.
        """
        return pulumi.get(self, "time_recurrence")


@pulumi.output_type
class GetAutoScalingConfigurationPolicyRuleResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 metrics: Sequence['outputs.GetAutoScalingConfigurationPolicyRuleMetricResult']):
        """
        :param _builtins.str action: The valid value are CHANGE_SHAPE_SCALE_UP or CHANGE_SHAPE_SCALE_DOWN.
        :param Sequence['GetAutoScalingConfigurationPolicyRuleMetricArgs'] metrics: Metric and threshold details for triggering an autoscale action.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "metrics", metrics)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        The valid value are CHANGE_SHAPE_SCALE_UP or CHANGE_SHAPE_SCALE_DOWN.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Sequence['outputs.GetAutoScalingConfigurationPolicyRuleMetricResult']:
        """
        Metric and threshold details for triggering an autoscale action.
        """
        return pulumi.get(self, "metrics")


@pulumi.output_type
class GetAutoScalingConfigurationPolicyRuleMetricResult(dict):
    def __init__(__self__, *,
                 metric_type: _builtins.str,
                 thresholds: Sequence['outputs.GetAutoScalingConfigurationPolicyRuleMetricThresholdResult']):
        """
        :param _builtins.str metric_type: Allowed values are CPU_UTILIZATION and MEMORY_UTILIZATION.
        :param Sequence['GetAutoScalingConfigurationPolicyRuleMetricThresholdArgs'] thresholds: An autoscale action is triggered when a performance metric exceeds a threshold.
        """
        pulumi.set(__self__, "metric_type", metric_type)
        pulumi.set(__self__, "thresholds", thresholds)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> _builtins.str:
        """
        Allowed values are CPU_UTILIZATION and MEMORY_UTILIZATION.
        """
        return pulumi.get(self, "metric_type")

    @_builtins.property
    @pulumi.getter
    def thresholds(self) -> Sequence['outputs.GetAutoScalingConfigurationPolicyRuleMetricThresholdResult']:
        """
        An autoscale action is triggered when a performance metric exceeds a threshold.
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class GetAutoScalingConfigurationPolicyRuleMetricThresholdResult(dict):
    def __init__(__self__, *,
                 duration_in_minutes: _builtins.int,
                 operator: _builtins.str,
                 value: _builtins.int):
        """
        :param _builtins.int duration_in_minutes: This value is the minimum period of time the metric value exceeds the threshold value before the action is triggered. The value is in minutes.
        :param _builtins.str operator: The comparison operator to use. Options are greater than (GT) or less than (LT).
        :param _builtins.int value: Integer non-negative value. 0 < value < 100
        """
        pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> _builtins.int:
        """
        This value is the minimum period of time the metric value exceeds the threshold value before the action is triggered. The value is in minutes.
        """
        return pulumi.get(self, "duration_in_minutes")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The comparison operator to use. Options are greater than (GT) or less than (LT).
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        """
        Integer non-negative value. 0 < value < 100
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAutoScalingConfigurationsAutoScalingConfigurationResult(dict):
    def __init__(__self__, *,
                 bds_instance_id: _builtins.str,
                 cluster_admin_password: _builtins.str,
                 display_name: _builtins.str,
                 id: _builtins.str,
                 is_enabled: _builtins.bool,
                 node_type: _builtins.str,
                 policies: Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyResult'],
                 policy_details: Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailResult'],
                 state: _builtins.str,
                 time_created: _builtins.str,
                 time_updated: _builtins.str):
        pulumi.set(__self__, "bds_instance_id", bds_instance_id)
        pulumi.set(__self__, "cluster_admin_password", cluster_admin_password)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "node_type", node_type)
        pulumi.set(__self__, "policies", policies)
        pulumi.set(__self__, "policy_details", policy_details)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @_builtins.property
    @pulumi.getter(name="bdsInstanceId")
    def bds_instance_id(self) -> _builtins.str:
        return pulumi.get(self, "bds_instance_id")

    @_builtins.property
    @pulumi.getter(name="clusterAdminPassword")
    def cluster_admin_password(self) -> _builtins.str:
        return pulumi.get(self, "cluster_admin_password")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "is_enabled")

    @_builtins.property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> _builtins.str:
        return pulumi.get(self, "node_type")

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyResult']:
        return pulumi.get(self, "policies")

    @_builtins.property
    @pulumi.getter(name="policyDetails")
    def policy_details(self) -> Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailResult']:
        return pulumi.get(self, "policy_details")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetAutoScalingConfigurationsAutoScalingConfigurationPolicyResult(dict):
    def __init__(__self__, *,
                 policy_type: _builtins.str,
                 rules: Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyRuleResult']):
        pulumi.set(__self__, "policy_type", policy_type)
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> _builtins.str:
        return pulumi.get(self, "policy_type")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyRuleResult']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailResult(dict):
    def __init__(__self__, *,
                 action_type: _builtins.str,
                 policy_type: _builtins.str,
                 scale_down_configs: Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleDownConfigResult'],
                 scale_in_configs: Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleInConfigResult'],
                 scale_out_configs: Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleOutConfigResult'],
                 scale_up_configs: Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleUpConfigResult'],
                 schedule_details: Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScheduleDetailResult'],
                 timezone: _builtins.str,
                 trigger_type: _builtins.str):
        pulumi.set(__self__, "action_type", action_type)
        pulumi.set(__self__, "policy_type", policy_type)
        pulumi.set(__self__, "scale_down_configs", scale_down_configs)
        pulumi.set(__self__, "scale_in_configs", scale_in_configs)
        pulumi.set(__self__, "scale_out_configs", scale_out_configs)
        pulumi.set(__self__, "scale_up_configs", scale_up_configs)
        pulumi.set(__self__, "schedule_details", schedule_details)
        pulumi.set(__self__, "timezone", timezone)
        pulumi.set(__self__, "trigger_type", trigger_type)

    @_builtins.property
    @pulumi.getter(name="actionType")
    def action_type(self) -> _builtins.str:
        return pulumi.get(self, "action_type")

    @_builtins.property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> _builtins.str:
        return pulumi.get(self, "policy_type")

    @_builtins.property
    @pulumi.getter(name="scaleDownConfigs")
    def scale_down_configs(self) -> Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleDownConfigResult']:
        return pulumi.get(self, "scale_down_configs")

    @_builtins.property
    @pulumi.getter(name="scaleInConfigs")
    def scale_in_configs(self) -> Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleInConfigResult']:
        return pulumi.get(self, "scale_in_configs")

    @_builtins.property
    @pulumi.getter(name="scaleOutConfigs")
    def scale_out_configs(self) -> Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleOutConfigResult']:
        return pulumi.get(self, "scale_out_configs")

    @_builtins.property
    @pulumi.getter(name="scaleUpConfigs")
    def scale_up_configs(self) -> Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleUpConfigResult']:
        return pulumi.get(self, "scale_up_configs")

    @_builtins.property
    @pulumi.getter(name="scheduleDetails")
    def schedule_details(self) -> Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScheduleDetailResult']:
        return pulumi.get(self, "schedule_details")

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> _builtins.str:
        return pulumi.get(self, "timezone")

    @_builtins.property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> _builtins.str:
        return pulumi.get(self, "trigger_type")


@pulumi.output_type
class GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleDownConfigResult(dict):
    def __init__(__self__, *,
                 memory_step_size: _builtins.int,
                 metrics: Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleDownConfigMetricResult'],
                 min_memory_per_node: _builtins.int,
                 min_ocpus_per_node: _builtins.int,
                 ocpu_step_size: _builtins.int):
        pulumi.set(__self__, "memory_step_size", memory_step_size)
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "min_memory_per_node", min_memory_per_node)
        pulumi.set(__self__, "min_ocpus_per_node", min_ocpus_per_node)
        pulumi.set(__self__, "ocpu_step_size", ocpu_step_size)

    @_builtins.property
    @pulumi.getter(name="memoryStepSize")
    def memory_step_size(self) -> _builtins.int:
        return pulumi.get(self, "memory_step_size")

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleDownConfigMetricResult']:
        return pulumi.get(self, "metrics")

    @_builtins.property
    @pulumi.getter(name="minMemoryPerNode")
    def min_memory_per_node(self) -> _builtins.int:
        return pulumi.get(self, "min_memory_per_node")

    @_builtins.property
    @pulumi.getter(name="minOcpusPerNode")
    def min_ocpus_per_node(self) -> _builtins.int:
        return pulumi.get(self, "min_ocpus_per_node")

    @_builtins.property
    @pulumi.getter(name="ocpuStepSize")
    def ocpu_step_size(self) -> _builtins.int:
        return pulumi.get(self, "ocpu_step_size")


@pulumi.output_type
class GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleDownConfigMetricResult(dict):
    def __init__(__self__, *,
                 metric_type: _builtins.str,
                 thresholds: Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleDownConfigMetricThresholdResult']):
        pulumi.set(__self__, "metric_type", metric_type)
        pulumi.set(__self__, "thresholds", thresholds)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> _builtins.str:
        return pulumi.get(self, "metric_type")

    @_builtins.property
    @pulumi.getter
    def thresholds(self) -> Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleDownConfigMetricThresholdResult']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleDownConfigMetricThresholdResult(dict):
    def __init__(__self__, *,
                 duration_in_minutes: _builtins.int,
                 operator: _builtins.str,
                 value: _builtins.int):
        pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> _builtins.int:
        return pulumi.get(self, "duration_in_minutes")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleInConfigResult(dict):
    def __init__(__self__, *,
                 metrics: Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleInConfigMetricResult'],
                 min_node_count: _builtins.int,
                 step_size: _builtins.int):
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "min_node_count", min_node_count)
        pulumi.set(__self__, "step_size", step_size)

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleInConfigMetricResult']:
        return pulumi.get(self, "metrics")

    @_builtins.property
    @pulumi.getter(name="minNodeCount")
    def min_node_count(self) -> _builtins.int:
        return pulumi.get(self, "min_node_count")

    @_builtins.property
    @pulumi.getter(name="stepSize")
    def step_size(self) -> _builtins.int:
        return pulumi.get(self, "step_size")


@pulumi.output_type
class GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleInConfigMetricResult(dict):
    def __init__(__self__, *,
                 metric_type: _builtins.str,
                 thresholds: Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleInConfigMetricThresholdResult']):
        pulumi.set(__self__, "metric_type", metric_type)
        pulumi.set(__self__, "thresholds", thresholds)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> _builtins.str:
        return pulumi.get(self, "metric_type")

    @_builtins.property
    @pulumi.getter
    def thresholds(self) -> Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleInConfigMetricThresholdResult']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleInConfigMetricThresholdResult(dict):
    def __init__(__self__, *,
                 duration_in_minutes: _builtins.int,
                 operator: _builtins.str,
                 value: _builtins.int):
        pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> _builtins.int:
        return pulumi.get(self, "duration_in_minutes")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleOutConfigResult(dict):
    def __init__(__self__, *,
                 max_node_count: _builtins.int,
                 metrics: Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleOutConfigMetricResult'],
                 step_size: _builtins.int):
        pulumi.set(__self__, "max_node_count", max_node_count)
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "step_size", step_size)

    @_builtins.property
    @pulumi.getter(name="maxNodeCount")
    def max_node_count(self) -> _builtins.int:
        return pulumi.get(self, "max_node_count")

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleOutConfigMetricResult']:
        return pulumi.get(self, "metrics")

    @_builtins.property
    @pulumi.getter(name="stepSize")
    def step_size(self) -> _builtins.int:
        return pulumi.get(self, "step_size")


@pulumi.output_type
class GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleOutConfigMetricResult(dict):
    def __init__(__self__, *,
                 metric_type: _builtins.str,
                 thresholds: Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleOutConfigMetricThresholdResult']):
        pulumi.set(__self__, "metric_type", metric_type)
        pulumi.set(__self__, "thresholds", thresholds)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> _builtins.str:
        return pulumi.get(self, "metric_type")

    @_builtins.property
    @pulumi.getter
    def thresholds(self) -> Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleOutConfigMetricThresholdResult']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleOutConfigMetricThresholdResult(dict):
    def __init__(__self__, *,
                 duration_in_minutes: _builtins.int,
                 operator: _builtins.str,
                 value: _builtins.int):
        pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> _builtins.int:
        return pulumi.get(self, "duration_in_minutes")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleUpConfigResult(dict):
    def __init__(__self__, *,
                 max_memory_per_node: _builtins.int,
                 max_ocpus_per_node: _builtins.int,
                 memory_step_size: _builtins.int,
                 metrics: Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleUpConfigMetricResult'],
                 ocpu_step_size: _builtins.int):
        pulumi.set(__self__, "max_memory_per_node", max_memory_per_node)
        pulumi.set(__self__, "max_ocpus_per_node", max_ocpus_per_node)
        pulumi.set(__self__, "memory_step_size", memory_step_size)
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "ocpu_step_size", ocpu_step_size)

    @_builtins.property
    @pulumi.getter(name="maxMemoryPerNode")
    def max_memory_per_node(self) -> _builtins.int:
        return pulumi.get(self, "max_memory_per_node")

    @_builtins.property
    @pulumi.getter(name="maxOcpusPerNode")
    def max_ocpus_per_node(self) -> _builtins.int:
        return pulumi.get(self, "max_ocpus_per_node")

    @_builtins.property
    @pulumi.getter(name="memoryStepSize")
    def memory_step_size(self) -> _builtins.int:
        return pulumi.get(self, "memory_step_size")

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleUpConfigMetricResult']:
        return pulumi.get(self, "metrics")

    @_builtins.property
    @pulumi.getter(name="ocpuStepSize")
    def ocpu_step_size(self) -> _builtins.int:
        return pulumi.get(self, "ocpu_step_size")


@pulumi.output_type
class GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleUpConfigMetricResult(dict):
    def __init__(__self__, *,
                 metric_type: _builtins.str,
                 thresholds: Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleUpConfigMetricThresholdResult']):
        pulumi.set(__self__, "metric_type", metric_type)
        pulumi.set(__self__, "thresholds", thresholds)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> _builtins.str:
        return pulumi.get(self, "metric_type")

    @_builtins.property
    @pulumi.getter
    def thresholds(self) -> Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleUpConfigMetricThresholdResult']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScaleUpConfigMetricThresholdResult(dict):
    def __init__(__self__, *,
                 duration_in_minutes: _builtins.int,
                 operator: _builtins.str,
                 value: _builtins.int):
        pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> _builtins.int:
        return pulumi.get(self, "duration_in_minutes")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScheduleDetailResult(dict):
    def __init__(__self__, *,
                 schedule_type: _builtins.str,
                 time_and_horizontal_scaling_configs: Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScheduleDetailTimeAndHorizontalScalingConfigResult'],
                 time_and_vertical_scaling_configs: Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScheduleDetailTimeAndVerticalScalingConfigResult']):
        pulumi.set(__self__, "schedule_type", schedule_type)
        pulumi.set(__self__, "time_and_horizontal_scaling_configs", time_and_horizontal_scaling_configs)
        pulumi.set(__self__, "time_and_vertical_scaling_configs", time_and_vertical_scaling_configs)

    @_builtins.property
    @pulumi.getter(name="scheduleType")
    def schedule_type(self) -> _builtins.str:
        return pulumi.get(self, "schedule_type")

    @_builtins.property
    @pulumi.getter(name="timeAndHorizontalScalingConfigs")
    def time_and_horizontal_scaling_configs(self) -> Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScheduleDetailTimeAndHorizontalScalingConfigResult']:
        return pulumi.get(self, "time_and_horizontal_scaling_configs")

    @_builtins.property
    @pulumi.getter(name="timeAndVerticalScalingConfigs")
    def time_and_vertical_scaling_configs(self) -> Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScheduleDetailTimeAndVerticalScalingConfigResult']:
        return pulumi.get(self, "time_and_vertical_scaling_configs")


@pulumi.output_type
class GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScheduleDetailTimeAndHorizontalScalingConfigResult(dict):
    def __init__(__self__, *,
                 target_node_count: _builtins.int,
                 time_recurrence: _builtins.str):
        pulumi.set(__self__, "target_node_count", target_node_count)
        pulumi.set(__self__, "time_recurrence", time_recurrence)

    @_builtins.property
    @pulumi.getter(name="targetNodeCount")
    def target_node_count(self) -> _builtins.int:
        return pulumi.get(self, "target_node_count")

    @_builtins.property
    @pulumi.getter(name="timeRecurrence")
    def time_recurrence(self) -> _builtins.str:
        return pulumi.get(self, "time_recurrence")


@pulumi.output_type
class GetAutoScalingConfigurationsAutoScalingConfigurationPolicyDetailScheduleDetailTimeAndVerticalScalingConfigResult(dict):
    def __init__(__self__, *,
                 target_memory_per_node: _builtins.int,
                 target_ocpus_per_node: _builtins.int,
                 target_shape: _builtins.str,
                 time_recurrence: _builtins.str):
        pulumi.set(__self__, "target_memory_per_node", target_memory_per_node)
        pulumi.set(__self__, "target_ocpus_per_node", target_ocpus_per_node)
        pulumi.set(__self__, "target_shape", target_shape)
        pulumi.set(__self__, "time_recurrence", time_recurrence)

    @_builtins.property
    @pulumi.getter(name="targetMemoryPerNode")
    def target_memory_per_node(self) -> _builtins.int:
        return pulumi.get(self, "target_memory_per_node")

    @_builtins.property
    @pulumi.getter(name="targetOcpusPerNode")
    def target_ocpus_per_node(self) -> _builtins.int:
        return pulumi.get(self, "target_ocpus_per_node")

    @_builtins.property
    @pulumi.getter(name="targetShape")
    def target_shape(self) -> _builtins.str:
        return pulumi.get(self, "target_shape")

    @_builtins.property
    @pulumi.getter(name="timeRecurrence")
    def time_recurrence(self) -> _builtins.str:
        return pulumi.get(self, "time_recurrence")


@pulumi.output_type
class GetAutoScalingConfigurationsAutoScalingConfigurationPolicyRuleResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 metrics: Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyRuleMetricResult']):
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "metrics", metrics)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyRuleMetricResult']:
        return pulumi.get(self, "metrics")


@pulumi.output_type
class GetAutoScalingConfigurationsAutoScalingConfigurationPolicyRuleMetricResult(dict):
    def __init__(__self__, *,
                 metric_type: _builtins.str,
                 thresholds: Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyRuleMetricThresholdResult']):
        pulumi.set(__self__, "metric_type", metric_type)
        pulumi.set(__self__, "thresholds", thresholds)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> _builtins.str:
        return pulumi.get(self, "metric_type")

    @_builtins.property
    @pulumi.getter
    def thresholds(self) -> Sequence['outputs.GetAutoScalingConfigurationsAutoScalingConfigurationPolicyRuleMetricThresholdResult']:
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class GetAutoScalingConfigurationsAutoScalingConfigurationPolicyRuleMetricThresholdResult(dict):
    def __init__(__self__, *,
                 duration_in_minutes: _builtins.int,
                 operator: _builtins.str,
                 value: _builtins.int):
        pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> _builtins.int:
        return pulumi.get(self, "duration_in_minutes")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAutoScalingConfigurationsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetBdsClusterVersionsBdsClusterVersionResult(dict):
    def __init__(__self__, *,
                 bds_version: _builtins.str,
                 odh_version: _builtins.str):
        """
        :param _builtins.str bds_version: BDS version to be used for cluster creation
        :param _builtins.str odh_version: ODH version to be used for cluster creation
        """
        pulumi.set(__self__, "bds_version", bds_version)
        pulumi.set(__self__, "odh_version", odh_version)

    @_builtins.property
    @pulumi.getter(name="bdsVersion")
    def bds_version(self) -> _builtins.str:
        """
        BDS version to be used for cluster creation
        """
        return pulumi.get(self, "bds_version")

    @_builtins.property
    @pulumi.getter(name="odhVersion")
    def odh_version(self) -> _builtins.str:
        """
        ODH version to be used for cluster creation
        """
        return pulumi.get(self, "odh_version")


@pulumi.output_type
class GetBdsClusterVersionsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetBdsInstanceApiKeysBdsApiKeyResult(dict):
    def __init__(__self__, *,
                 bds_instance_id: _builtins.str,
                 default_region: _builtins.str,
                 domain_ocid: _builtins.str,
                 fingerprint: _builtins.str,
                 id: _builtins.str,
                 key_alias: _builtins.str,
                 passphrase: _builtins.str,
                 pemfilepath: _builtins.str,
                 state: _builtins.str,
                 tenant_id: _builtins.str,
                 time_created: _builtins.str,
                 user_id: _builtins.str):
        """
        :param _builtins.str bds_instance_id: The OCID of the cluster.
        :param _builtins.str default_region: The name of the region to establish the Object Storage endpoint which was set as part of key creation operation. If no region was provided this will be set to be the same region where the cluster lives. Example us-phoenix-1 .
        :param _builtins.str domain_ocid: Identity domain OCID ,where user is present. For default domain ,this field will be optional.
        :param _builtins.str fingerprint: The fingerprint that corresponds to the public API key requested.
        :param _builtins.str id: Identifier of the user's API key.
        :param _builtins.str key_alias: User friendly identifier used to uniquely differentiate between different API keys. Only ASCII alphanumeric characters with no spaces allowed.
        :param _builtins.str pemfilepath: The full path and file name of the private key used for authentication. This location will be automatically selected on the BDS local file system.
        :param _builtins.str state: The current status of the API key.
        :param _builtins.str tenant_id: The OCID of your tenancy.
        :param _builtins.str time_created: The time the API key was created, shown as an RFC 3339 formatted datetime string.
        :param _builtins.str user_id: The user OCID for which this API key was created.
        """
        pulumi.set(__self__, "bds_instance_id", bds_instance_id)
        pulumi.set(__self__, "default_region", default_region)
        pulumi.set(__self__, "domain_ocid", domain_ocid)
        pulumi.set(__self__, "fingerprint", fingerprint)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key_alias", key_alias)
        pulumi.set(__self__, "passphrase", passphrase)
        pulumi.set(__self__, "pemfilepath", pemfilepath)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="bdsInstanceId")
    def bds_instance_id(self) -> _builtins.str:
        """
        The OCID of the cluster.
        """
        return pulumi.get(self, "bds_instance_id")

    @_builtins.property
    @pulumi.getter(name="defaultRegion")
    def default_region(self) -> _builtins.str:
        """
        The name of the region to establish the Object Storage endpoint which was set as part of key creation operation. If no region was provided this will be set to be the same region where the cluster lives. Example us-phoenix-1 .
        """
        return pulumi.get(self, "default_region")

    @_builtins.property
    @pulumi.getter(name="domainOcid")
    def domain_ocid(self) -> _builtins.str:
        """
        Identity domain OCID ,where user is present. For default domain ,this field will be optional.
        """
        return pulumi.get(self, "domain_ocid")

    @_builtins.property
    @pulumi.getter
    def fingerprint(self) -> _builtins.str:
        """
        The fingerprint that corresponds to the public API key requested.
        """
        return pulumi.get(self, "fingerprint")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Identifier of the user's API key.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="keyAlias")
    def key_alias(self) -> _builtins.str:
        """
        User friendly identifier used to uniquely differentiate between different API keys. Only ASCII alphanumeric characters with no spaces allowed.
        """
        return pulumi.get(self, "key_alias")

    @_builtins.property
    @pulumi.getter
    def passphrase(self) -> _builtins.str:
        return pulumi.get(self, "passphrase")

    @_builtins.property
    @pulumi.getter
    def pemfilepath(self) -> _builtins.str:
        """
        The full path and file name of the private key used for authentication. This location will be automatically selected on the BDS local file system.
        """
        return pulumi.get(self, "pemfilepath")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The current status of the API key.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        The OCID of your tenancy.
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The time the API key was created, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> _builtins.str:
        """
        The user OCID for which this API key was created.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetBdsInstanceApiKeysFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetBdsInstanceBdsClusterVersionSummaryResult(dict):
    def __init__(__self__, *,
                 bds_version: _builtins.str,
                 odh_version: _builtins.str):
        """
        :param _builtins.str bds_version: Big Data Service version installed in the cluster.
        :param _builtins.str odh_version: Version of the ODH (Oracle Distribution including Apache Hadoop) for the node.
        """
        pulumi.set(__self__, "bds_version", bds_version)
        pulumi.set(__self__, "odh_version", odh_version)

    @_builtins.property
    @pulumi.getter(name="bdsVersion")
    def bds_version(self) -> _builtins.str:
        """
        Big Data Service version installed in the cluster.
        """
        return pulumi.get(self, "bds_version")

    @_builtins.property
    @pulumi.getter(name="odhVersion")
    def odh_version(self) -> _builtins.str:
        """
        Version of the ODH (Oracle Distribution including Apache Hadoop) for the node.
        """
        return pulumi.get(self, "odh_version")


@pulumi.output_type
class GetBdsInstanceCloudSqlDetailResult(dict):
    def __init__(__self__, *,
                 block_volume_size_in_gbs: _builtins.str,
                 ip_address: _builtins.str,
                 is_kerberos_mapped_to_database_users: _builtins.bool,
                 kerberos_details: Sequence['outputs.GetBdsInstanceCloudSqlDetailKerberosDetailResult'],
                 memory_in_gbs: _builtins.int,
                 nvmes: _builtins.int,
                 ocpus: _builtins.int,
                 shape: _builtins.str):
        """
        :param _builtins.str block_volume_size_in_gbs: The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        :param _builtins.str ip_address: IP address of the node.
        :param _builtins.bool is_kerberos_mapped_to_database_users: Boolean flag specifying whether or not Kerberos principals are mapped to database users.
        :param Sequence['GetBdsInstanceCloudSqlDetailKerberosDetailArgs'] kerberos_details: Details about the Kerberos principals.
        :param _builtins.int memory_in_gbs: The total amount of memory available to the node, in gigabytes.
        :param _builtins.int nvmes: The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        :param _builtins.int ocpus: The total number of OCPUs available to the node.
        :param _builtins.str shape: Shape of the node.
        """
        pulumi.set(__self__, "block_volume_size_in_gbs", block_volume_size_in_gbs)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "is_kerberos_mapped_to_database_users", is_kerberos_mapped_to_database_users)
        pulumi.set(__self__, "kerberos_details", kerberos_details)
        pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        pulumi.set(__self__, "nvmes", nvmes)
        pulumi.set(__self__, "ocpus", ocpus)
        pulumi.set(__self__, "shape", shape)

    @_builtins.property
    @pulumi.getter(name="blockVolumeSizeInGbs")
    def block_volume_size_in_gbs(self) -> _builtins.str:
        """
        The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        """
        return pulumi.get(self, "block_volume_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> _builtins.str:
        """
        IP address of the node.
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter(name="isKerberosMappedToDatabaseUsers")
    def is_kerberos_mapped_to_database_users(self) -> _builtins.bool:
        """
        Boolean flag specifying whether or not Kerberos principals are mapped to database users.
        """
        return pulumi.get(self, "is_kerberos_mapped_to_database_users")

    @_builtins.property
    @pulumi.getter(name="kerberosDetails")
    def kerberos_details(self) -> Sequence['outputs.GetBdsInstanceCloudSqlDetailKerberosDetailResult']:
        """
        Details about the Kerberos principals.
        """
        return pulumi.get(self, "kerberos_details")

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> _builtins.int:
        """
        The total amount of memory available to the node, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @_builtins.property
    @pulumi.getter
    def nvmes(self) -> _builtins.int:
        """
        The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        """
        return pulumi.get(self, "nvmes")

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> _builtins.int:
        """
        The total number of OCPUs available to the node.
        """
        return pulumi.get(self, "ocpus")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        Shape of the node.
        """
        return pulumi.get(self, "shape")


@pulumi.output_type
class GetBdsInstanceCloudSqlDetailKerberosDetailResult(dict):
    def __init__(__self__, *,
                 keytab_file: _builtins.str,
                 principal_name: _builtins.str):
        """
        :param _builtins.str keytab_file: Location of the keytab file
        :param _builtins.str principal_name: Name of the Kerberos principal.
        """
        pulumi.set(__self__, "keytab_file", keytab_file)
        pulumi.set(__self__, "principal_name", principal_name)

    @_builtins.property
    @pulumi.getter(name="keytabFile")
    def keytab_file(self) -> _builtins.str:
        """
        Location of the keytab file
        """
        return pulumi.get(self, "keytab_file")

    @_builtins.property
    @pulumi.getter(name="principalName")
    def principal_name(self) -> _builtins.str:
        """
        Name of the Kerberos principal.
        """
        return pulumi.get(self, "principal_name")


@pulumi.output_type
class GetBdsInstanceClusterDetailResult(dict):
    def __init__(__self__, *,
                 ambari_url: _builtins.str,
                 bd_cell_version: _builtins.str,
                 bda_version: _builtins.str,
                 bdm_version: _builtins.str,
                 bds_version: _builtins.str,
                 big_data_manager_url: _builtins.str,
                 cloudera_manager_url: _builtins.str,
                 csql_cell_version: _builtins.str,
                 db_version: _builtins.str,
                 hue_server_url: _builtins.str,
                 jupyter_hub_url: _builtins.str,
                 odh_version: _builtins.str,
                 os_version: _builtins.str,
                 time_created: _builtins.str,
                 time_refreshed: _builtins.str):
        """
        :param _builtins.str ambari_url: The URL of Ambari
        :param _builtins.str bd_cell_version: Cloud SQL cell version.
        :param _builtins.str bda_version: BDA version installed in the cluster
        :param _builtins.str bdm_version: Big Data Manager version installed in the cluster.
        :param _builtins.str bds_version: Big Data Service version installed in the cluster.
        :param _builtins.str big_data_manager_url: The URL of Big Data Manager.
        :param _builtins.str cloudera_manager_url: The URL of Cloudera Manager
        :param _builtins.str csql_cell_version: Big Data SQL version.
        :param _builtins.str db_version: Cloud SQL query server database version.
        :param _builtins.str hue_server_url: The URL of the Hue server.
        :param _builtins.str jupyter_hub_url: The URL of the Jupyterhub.
        :param _builtins.str odh_version: Version of the ODH (Oracle Distribution including Apache Hadoop) for the node.
        :param _builtins.str os_version: BDS-assigned Operating System version for the node.
        :param _builtins.str time_created: The time the cluster was created, shown as an RFC 3339 formatted datetime string.
        :param _builtins.str time_refreshed: The time the cluster was automatically or manually refreshed, shown as an RFC 3339 formatted datetime string.
        """
        pulumi.set(__self__, "ambari_url", ambari_url)
        pulumi.set(__self__, "bd_cell_version", bd_cell_version)
        pulumi.set(__self__, "bda_version", bda_version)
        pulumi.set(__self__, "bdm_version", bdm_version)
        pulumi.set(__self__, "bds_version", bds_version)
        pulumi.set(__self__, "big_data_manager_url", big_data_manager_url)
        pulumi.set(__self__, "cloudera_manager_url", cloudera_manager_url)
        pulumi.set(__self__, "csql_cell_version", csql_cell_version)
        pulumi.set(__self__, "db_version", db_version)
        pulumi.set(__self__, "hue_server_url", hue_server_url)
        pulumi.set(__self__, "jupyter_hub_url", jupyter_hub_url)
        pulumi.set(__self__, "odh_version", odh_version)
        pulumi.set(__self__, "os_version", os_version)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_refreshed", time_refreshed)

    @_builtins.property
    @pulumi.getter(name="ambariUrl")
    def ambari_url(self) -> _builtins.str:
        """
        The URL of Ambari
        """
        return pulumi.get(self, "ambari_url")

    @_builtins.property
    @pulumi.getter(name="bdCellVersion")
    def bd_cell_version(self) -> _builtins.str:
        """
        Cloud SQL cell version.
        """
        return pulumi.get(self, "bd_cell_version")

    @_builtins.property
    @pulumi.getter(name="bdaVersion")
    def bda_version(self) -> _builtins.str:
        """
        BDA version installed in the cluster
        """
        return pulumi.get(self, "bda_version")

    @_builtins.property
    @pulumi.getter(name="bdmVersion")
    def bdm_version(self) -> _builtins.str:
        """
        Big Data Manager version installed in the cluster.
        """
        return pulumi.get(self, "bdm_version")

    @_builtins.property
    @pulumi.getter(name="bdsVersion")
    def bds_version(self) -> _builtins.str:
        """
        Big Data Service version installed in the cluster.
        """
        return pulumi.get(self, "bds_version")

    @_builtins.property
    @pulumi.getter(name="bigDataManagerUrl")
    def big_data_manager_url(self) -> _builtins.str:
        """
        The URL of Big Data Manager.
        """
        return pulumi.get(self, "big_data_manager_url")

    @_builtins.property
    @pulumi.getter(name="clouderaManagerUrl")
    def cloudera_manager_url(self) -> _builtins.str:
        """
        The URL of Cloudera Manager
        """
        return pulumi.get(self, "cloudera_manager_url")

    @_builtins.property
    @pulumi.getter(name="csqlCellVersion")
    def csql_cell_version(self) -> _builtins.str:
        """
        Big Data SQL version.
        """
        return pulumi.get(self, "csql_cell_version")

    @_builtins.property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> _builtins.str:
        """
        Cloud SQL query server database version.
        """
        return pulumi.get(self, "db_version")

    @_builtins.property
    @pulumi.getter(name="hueServerUrl")
    def hue_server_url(self) -> _builtins.str:
        """
        The URL of the Hue server.
        """
        return pulumi.get(self, "hue_server_url")

    @_builtins.property
    @pulumi.getter(name="jupyterHubUrl")
    def jupyter_hub_url(self) -> _builtins.str:
        """
        The URL of the Jupyterhub.
        """
        return pulumi.get(self, "jupyter_hub_url")

    @_builtins.property
    @pulumi.getter(name="odhVersion")
    def odh_version(self) -> _builtins.str:
        """
        Version of the ODH (Oracle Distribution including Apache Hadoop) for the node.
        """
        return pulumi.get(self, "odh_version")

    @_builtins.property
    @pulumi.getter(name="osVersion")
    def os_version(self) -> _builtins.str:
        """
        BDS-assigned Operating System version for the node.
        """
        return pulumi.get(self, "os_version")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The time the cluster was created, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeRefreshed")
    def time_refreshed(self) -> _builtins.str:
        """
        The time the cluster was automatically or manually refreshed, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_refreshed")


@pulumi.output_type
class GetBdsInstanceComputeOnlyWorkerNodeResult(dict):
    def __init__(__self__, *,
                 block_volume_size_in_gbs: _builtins.str,
                 number_of_nodes: _builtins.int,
                 shape: _builtins.str,
                 shape_configs: Sequence['outputs.GetBdsInstanceComputeOnlyWorkerNodeShapeConfigResult'],
                 subnet_id: _builtins.str):
        """
        :param _builtins.str block_volume_size_in_gbs: The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        :param _builtins.int number_of_nodes: The number of nodes that form the cluster.
        :param _builtins.str shape: Shape of the node.
        :param _builtins.str subnet_id: The OCID of the subnet in which the node is to be created.
        """
        pulumi.set(__self__, "block_volume_size_in_gbs", block_volume_size_in_gbs)
        pulumi.set(__self__, "number_of_nodes", number_of_nodes)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "shape_configs", shape_configs)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="blockVolumeSizeInGbs")
    def block_volume_size_in_gbs(self) -> _builtins.str:
        """
        The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        """
        return pulumi.get(self, "block_volume_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="numberOfNodes")
    def number_of_nodes(self) -> _builtins.int:
        """
        The number of nodes that form the cluster.
        """
        return pulumi.get(self, "number_of_nodes")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        Shape of the node.
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter(name="shapeConfigs")
    def shape_configs(self) -> Sequence['outputs.GetBdsInstanceComputeOnlyWorkerNodeShapeConfigResult']:
        return pulumi.get(self, "shape_configs")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The OCID of the subnet in which the node is to be created.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetBdsInstanceComputeOnlyWorkerNodeShapeConfigResult(dict):
    def __init__(__self__, *,
                 memory_in_gbs: _builtins.int,
                 nvmes: _builtins.int,
                 ocpus: _builtins.int):
        """
        :param _builtins.int memory_in_gbs: The total amount of memory available to the node, in gigabytes.
        :param _builtins.int nvmes: The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        :param _builtins.int ocpus: The total number of OCPUs available to the node.
        """
        pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        pulumi.set(__self__, "nvmes", nvmes)
        pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> _builtins.int:
        """
        The total amount of memory available to the node, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @_builtins.property
    @pulumi.getter
    def nvmes(self) -> _builtins.int:
        """
        The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        """
        return pulumi.get(self, "nvmes")

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> _builtins.int:
        """
        The total number of OCPUs available to the node.
        """
        return pulumi.get(self, "ocpus")


@pulumi.output_type
class GetBdsInstanceEdgeNodeResult(dict):
    def __init__(__self__, *,
                 block_volume_size_in_gbs: _builtins.str,
                 number_of_nodes: _builtins.int,
                 shape: _builtins.str,
                 shape_configs: Sequence['outputs.GetBdsInstanceEdgeNodeShapeConfigResult'],
                 subnet_id: _builtins.str):
        """
        :param _builtins.str block_volume_size_in_gbs: The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        :param _builtins.int number_of_nodes: The number of nodes that form the cluster.
        :param _builtins.str shape: Shape of the node.
        :param _builtins.str subnet_id: The OCID of the subnet in which the node is to be created.
        """
        pulumi.set(__self__, "block_volume_size_in_gbs", block_volume_size_in_gbs)
        pulumi.set(__self__, "number_of_nodes", number_of_nodes)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "shape_configs", shape_configs)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="blockVolumeSizeInGbs")
    def block_volume_size_in_gbs(self) -> _builtins.str:
        """
        The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        """
        return pulumi.get(self, "block_volume_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="numberOfNodes")
    def number_of_nodes(self) -> _builtins.int:
        """
        The number of nodes that form the cluster.
        """
        return pulumi.get(self, "number_of_nodes")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        Shape of the node.
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter(name="shapeConfigs")
    def shape_configs(self) -> Sequence['outputs.GetBdsInstanceEdgeNodeShapeConfigResult']:
        return pulumi.get(self, "shape_configs")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The OCID of the subnet in which the node is to be created.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetBdsInstanceEdgeNodeShapeConfigResult(dict):
    def __init__(__self__, *,
                 memory_in_gbs: _builtins.int,
                 nvmes: _builtins.int,
                 ocpus: _builtins.int):
        """
        :param _builtins.int memory_in_gbs: The total amount of memory available to the node, in gigabytes.
        :param _builtins.int nvmes: The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        :param _builtins.int ocpus: The total number of OCPUs available to the node.
        """
        pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        pulumi.set(__self__, "nvmes", nvmes)
        pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> _builtins.int:
        """
        The total amount of memory available to the node, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @_builtins.property
    @pulumi.getter
    def nvmes(self) -> _builtins.int:
        """
        The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        """
        return pulumi.get(self, "nvmes")

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> _builtins.int:
        """
        The total number of OCPUs available to the node.
        """
        return pulumi.get(self, "ocpus")


@pulumi.output_type
class GetBdsInstanceGetOsPatchFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetBdsInstanceGetOsPatchTargetPackageResult(dict):
    def __init__(__self__, *,
                 package_name: _builtins.str,
                 package_type: _builtins.str,
                 related_cv_es: Sequence[_builtins.str],
                 target_version: _builtins.str,
                 update_type: _builtins.str):
        """
        :param _builtins.str package_name: The package's name.
        :param _builtins.str package_type: Package type based on package installation manager.
        :param Sequence[_builtins.str] related_cv_es: Related CVEs of the package update.
        :param _builtins.str target_version: The target version of the package.
        :param _builtins.str update_type: The action that current package will be executed on the cluster.
        """
        pulumi.set(__self__, "package_name", package_name)
        pulumi.set(__self__, "package_type", package_type)
        pulumi.set(__self__, "related_cv_es", related_cv_es)
        pulumi.set(__self__, "target_version", target_version)
        pulumi.set(__self__, "update_type", update_type)

    @_builtins.property
    @pulumi.getter(name="packageName")
    def package_name(self) -> _builtins.str:
        """
        The package's name.
        """
        return pulumi.get(self, "package_name")

    @_builtins.property
    @pulumi.getter(name="packageType")
    def package_type(self) -> _builtins.str:
        """
        Package type based on package installation manager.
        """
        return pulumi.get(self, "package_type")

    @_builtins.property
    @pulumi.getter(name="relatedCvEs")
    def related_cv_es(self) -> Sequence[_builtins.str]:
        """
        Related CVEs of the package update.
        """
        return pulumi.get(self, "related_cv_es")

    @_builtins.property
    @pulumi.getter(name="targetVersion")
    def target_version(self) -> _builtins.str:
        """
        The target version of the package.
        """
        return pulumi.get(self, "target_version")

    @_builtins.property
    @pulumi.getter(name="updateType")
    def update_type(self) -> _builtins.str:
        """
        The action that current package will be executed on the cluster.
        """
        return pulumi.get(self, "update_type")


@pulumi.output_type
class GetBdsInstanceIdentityConfigurationIamUserSyncConfigurationResult(dict):
    def __init__(__self__, *,
                 is_posix_attributes_addition_required: _builtins.bool,
                 state: _builtins.str,
                 time_created: _builtins.str,
                 time_updated: _builtins.str):
        """
        :param _builtins.bool is_posix_attributes_addition_required: whether to append POSIX attributes to IAM users
        :param _builtins.str state: Lifecycle state of the UPST config
        :param _builtins.str time_created: Time when this UPST config was created, shown as an RFC 3339 formatted datetime string.
        :param _builtins.str time_updated: Time when this UPST config was updated, shown as an RFC 3339 formatted datetime string.
        """
        pulumi.set(__self__, "is_posix_attributes_addition_required", is_posix_attributes_addition_required)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @_builtins.property
    @pulumi.getter(name="isPosixAttributesAdditionRequired")
    def is_posix_attributes_addition_required(self) -> _builtins.bool:
        """
        whether to append POSIX attributes to IAM users
        """
        return pulumi.get(self, "is_posix_attributes_addition_required")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        Lifecycle state of the UPST config
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        Time when this UPST config was created, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        Time when this UPST config was updated, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetBdsInstanceIdentityConfigurationIamUserSyncConfigurationDetailResult(dict):
    def __init__(__self__, *,
                 is_posix_attributes_addition_required: _builtins.bool):
        """
        :param _builtins.bool is_posix_attributes_addition_required: whether to append POSIX attributes to IAM users
        """
        pulumi.set(__self__, "is_posix_attributes_addition_required", is_posix_attributes_addition_required)

    @_builtins.property
    @pulumi.getter(name="isPosixAttributesAdditionRequired")
    def is_posix_attributes_addition_required(self) -> _builtins.bool:
        """
        whether to append POSIX attributes to IAM users
        """
        return pulumi.get(self, "is_posix_attributes_addition_required")


@pulumi.output_type
class GetBdsInstanceIdentityConfigurationUpstConfigurationResult(dict):
    def __init__(__self__, *,
                 keytab_content: _builtins.str,
                 master_encryption_key_id: _builtins.str,
                 secret_id: _builtins.str,
                 state: _builtins.str,
                 time_created: _builtins.str,
                 time_token_exchange_keytab_last_refreshed: _builtins.str,
                 time_updated: _builtins.str,
                 token_exchange_principal_name: _builtins.str,
                 vault_id: _builtins.str):
        """
        :param _builtins.str keytab_content: The kerberos keytab content used for creating identity propagation trust config, in base64 format
        :param _builtins.str master_encryption_key_id: Master Encryption key used for encrypting token exchange keytab.
        :param _builtins.str secret_id: Secret ID for token exchange keytab
        :param _builtins.str state: Lifecycle state of the UPST config
        :param _builtins.str time_created: Time when this UPST config was created, shown as an RFC 3339 formatted datetime string.
        :param _builtins.str time_token_exchange_keytab_last_refreshed: Time when the keytab for token exchange principal is last refreshed, shown as an RFC 3339 formatted datetime string.
        :param _builtins.str time_updated: Time when this UPST config was updated, shown as an RFC 3339 formatted datetime string.
        :param _builtins.str token_exchange_principal_name: Token exchange kerberos Principal name in cluster
        :param _builtins.str vault_id: The instance OCID of the node, which is the resource from which the node backup was acquired.
        """
        pulumi.set(__self__, "keytab_content", keytab_content)
        pulumi.set(__self__, "master_encryption_key_id", master_encryption_key_id)
        pulumi.set(__self__, "secret_id", secret_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_token_exchange_keytab_last_refreshed", time_token_exchange_keytab_last_refreshed)
        pulumi.set(__self__, "time_updated", time_updated)
        pulumi.set(__self__, "token_exchange_principal_name", token_exchange_principal_name)
        pulumi.set(__self__, "vault_id", vault_id)

    @_builtins.property
    @pulumi.getter(name="keytabContent")
    def keytab_content(self) -> _builtins.str:
        """
        The kerberos keytab content used for creating identity propagation trust config, in base64 format
        """
        return pulumi.get(self, "keytab_content")

    @_builtins.property
    @pulumi.getter(name="masterEncryptionKeyId")
    def master_encryption_key_id(self) -> _builtins.str:
        """
        Master Encryption key used for encrypting token exchange keytab.
        """
        return pulumi.get(self, "master_encryption_key_id")

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> _builtins.str:
        """
        Secret ID for token exchange keytab
        """
        return pulumi.get(self, "secret_id")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        Lifecycle state of the UPST config
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        Time when this UPST config was created, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeTokenExchangeKeytabLastRefreshed")
    def time_token_exchange_keytab_last_refreshed(self) -> _builtins.str:
        """
        Time when the keytab for token exchange principal is last refreshed, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_token_exchange_keytab_last_refreshed")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        Time when this UPST config was updated, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_updated")

    @_builtins.property
    @pulumi.getter(name="tokenExchangePrincipalName")
    def token_exchange_principal_name(self) -> _builtins.str:
        """
        Token exchange kerberos Principal name in cluster
        """
        return pulumi.get(self, "token_exchange_principal_name")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> _builtins.str:
        """
        The instance OCID of the node, which is the resource from which the node backup was acquired.
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class GetBdsInstanceIdentityConfigurationUpstConfigurationDetailResult(dict):
    def __init__(__self__, *,
                 master_encryption_key_id: _builtins.str,
                 vault_id: _builtins.str):
        """
        :param _builtins.str master_encryption_key_id: Master Encryption key used for encrypting token exchange keytab.
        :param _builtins.str vault_id: The instance OCID of the node, which is the resource from which the node backup was acquired.
        """
        pulumi.set(__self__, "master_encryption_key_id", master_encryption_key_id)
        pulumi.set(__self__, "vault_id", vault_id)

    @_builtins.property
    @pulumi.getter(name="masterEncryptionKeyId")
    def master_encryption_key_id(self) -> _builtins.str:
        """
        Master Encryption key used for encrypting token exchange keytab.
        """
        return pulumi.get(self, "master_encryption_key_id")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> _builtins.str:
        """
        The instance OCID of the node, which is the resource from which the node backup was acquired.
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class GetBdsInstanceIdentityConfigurationsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetBdsInstanceIdentityConfigurationsIdentityConfigurationResult(dict):
    def __init__(__self__, *,
                 activate_iam_user_sync_configuration_trigger: _builtins.str,
                 activate_upst_configuration_trigger: _builtins.str,
                 bds_instance_id: _builtins.str,
                 cluster_admin_password: _builtins.str,
                 confidential_application_id: _builtins.str,
                 display_name: _builtins.str,
                 iam_user_sync_configuration_details: Sequence['outputs.GetBdsInstanceIdentityConfigurationsIdentityConfigurationIamUserSyncConfigurationDetailResult'],
                 iam_user_sync_configurations: Sequence['outputs.GetBdsInstanceIdentityConfigurationsIdentityConfigurationIamUserSyncConfigurationResult'],
                 id: _builtins.str,
                 identity_domain_id: _builtins.str,
                 refresh_confidential_application_trigger: _builtins.str,
                 refresh_upst_token_exchange_keytab_trigger: _builtins.str,
                 state: _builtins.str,
                 time_created: _builtins.str,
                 time_updated: _builtins.str,
                 upst_configuration_details: Sequence['outputs.GetBdsInstanceIdentityConfigurationsIdentityConfigurationUpstConfigurationDetailResult'],
                 upst_configurations: Sequence['outputs.GetBdsInstanceIdentityConfigurationsIdentityConfigurationUpstConfigurationResult']):
        """
        :param _builtins.str bds_instance_id: The OCID of the cluster.
        :param _builtins.str confidential_application_id: identity domain confidential application ID for the identity config
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given.
        :param Sequence['GetBdsInstanceIdentityConfigurationsIdentityConfigurationIamUserSyncConfigurationArgs'] iam_user_sync_configurations: Information about the IAM user sync configuration.
        :param _builtins.str id: The id of the identity config
        :param _builtins.str identity_domain_id: Identity domain to use for identity config
        :param _builtins.str state: The state of the identity config
        :param _builtins.str time_created: Time when this UPST config was created, shown as an RFC 3339 formatted datetime string.
        :param _builtins.str time_updated: Time when this UPST config was updated, shown as an RFC 3339 formatted datetime string.
        :param Sequence['GetBdsInstanceIdentityConfigurationsIdentityConfigurationUpstConfigurationArgs'] upst_configurations: Information about the UPST configuration.
        """
        pulumi.set(__self__, "activate_iam_user_sync_configuration_trigger", activate_iam_user_sync_configuration_trigger)
        pulumi.set(__self__, "activate_upst_configuration_trigger", activate_upst_configuration_trigger)
        pulumi.set(__self__, "bds_instance_id", bds_instance_id)
        pulumi.set(__self__, "cluster_admin_password", cluster_admin_password)
        pulumi.set(__self__, "confidential_application_id", confidential_application_id)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "iam_user_sync_configuration_details", iam_user_sync_configuration_details)
        pulumi.set(__self__, "iam_user_sync_configurations", iam_user_sync_configurations)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_domain_id", identity_domain_id)
        pulumi.set(__self__, "refresh_confidential_application_trigger", refresh_confidential_application_trigger)
        pulumi.set(__self__, "refresh_upst_token_exchange_keytab_trigger", refresh_upst_token_exchange_keytab_trigger)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)
        pulumi.set(__self__, "upst_configuration_details", upst_configuration_details)
        pulumi.set(__self__, "upst_configurations", upst_configurations)

    @_builtins.property
    @pulumi.getter(name="activateIamUserSyncConfigurationTrigger")
    def activate_iam_user_sync_configuration_trigger(self) -> _builtins.str:
        return pulumi.get(self, "activate_iam_user_sync_configuration_trigger")

    @_builtins.property
    @pulumi.getter(name="activateUpstConfigurationTrigger")
    def activate_upst_configuration_trigger(self) -> _builtins.str:
        return pulumi.get(self, "activate_upst_configuration_trigger")

    @_builtins.property
    @pulumi.getter(name="bdsInstanceId")
    def bds_instance_id(self) -> _builtins.str:
        """
        The OCID of the cluster.
        """
        return pulumi.get(self, "bds_instance_id")

    @_builtins.property
    @pulumi.getter(name="clusterAdminPassword")
    def cluster_admin_password(self) -> _builtins.str:
        return pulumi.get(self, "cluster_admin_password")

    @_builtins.property
    @pulumi.getter(name="confidentialApplicationId")
    def confidential_application_id(self) -> _builtins.str:
        """
        identity domain confidential application ID for the identity config
        """
        return pulumi.get(self, "confidential_application_id")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="iamUserSyncConfigurationDetails")
    def iam_user_sync_configuration_details(self) -> Sequence['outputs.GetBdsInstanceIdentityConfigurationsIdentityConfigurationIamUserSyncConfigurationDetailResult']:
        return pulumi.get(self, "iam_user_sync_configuration_details")

    @_builtins.property
    @pulumi.getter(name="iamUserSyncConfigurations")
    def iam_user_sync_configurations(self) -> Sequence['outputs.GetBdsInstanceIdentityConfigurationsIdentityConfigurationIamUserSyncConfigurationResult']:
        """
        Information about the IAM user sync configuration.
        """
        return pulumi.get(self, "iam_user_sync_configurations")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The id of the identity config
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="identityDomainId")
    def identity_domain_id(self) -> _builtins.str:
        """
        Identity domain to use for identity config
        """
        return pulumi.get(self, "identity_domain_id")

    @_builtins.property
    @pulumi.getter(name="refreshConfidentialApplicationTrigger")
    def refresh_confidential_application_trigger(self) -> _builtins.str:
        return pulumi.get(self, "refresh_confidential_application_trigger")

    @_builtins.property
    @pulumi.getter(name="refreshUpstTokenExchangeKeytabTrigger")
    def refresh_upst_token_exchange_keytab_trigger(self) -> _builtins.str:
        return pulumi.get(self, "refresh_upst_token_exchange_keytab_trigger")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The state of the identity config
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        Time when this UPST config was created, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        Time when this UPST config was updated, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_updated")

    @_builtins.property
    @pulumi.getter(name="upstConfigurationDetails")
    def upst_configuration_details(self) -> Sequence['outputs.GetBdsInstanceIdentityConfigurationsIdentityConfigurationUpstConfigurationDetailResult']:
        return pulumi.get(self, "upst_configuration_details")

    @_builtins.property
    @pulumi.getter(name="upstConfigurations")
    def upst_configurations(self) -> Sequence['outputs.GetBdsInstanceIdentityConfigurationsIdentityConfigurationUpstConfigurationResult']:
        """
        Information about the UPST configuration.
        """
        return pulumi.get(self, "upst_configurations")


@pulumi.output_type
class GetBdsInstanceIdentityConfigurationsIdentityConfigurationIamUserSyncConfigurationResult(dict):
    def __init__(__self__, *,
                 is_posix_attributes_addition_required: _builtins.bool,
                 state: _builtins.str,
                 time_created: _builtins.str,
                 time_updated: _builtins.str):
        """
        :param _builtins.bool is_posix_attributes_addition_required: whether to append POSIX attributes to IAM users
        :param _builtins.str state: The state of the identity config
        :param _builtins.str time_created: Time when this UPST config was created, shown as an RFC 3339 formatted datetime string.
        :param _builtins.str time_updated: Time when this UPST config was updated, shown as an RFC 3339 formatted datetime string.
        """
        pulumi.set(__self__, "is_posix_attributes_addition_required", is_posix_attributes_addition_required)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @_builtins.property
    @pulumi.getter(name="isPosixAttributesAdditionRequired")
    def is_posix_attributes_addition_required(self) -> _builtins.bool:
        """
        whether to append POSIX attributes to IAM users
        """
        return pulumi.get(self, "is_posix_attributes_addition_required")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The state of the identity config
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        Time when this UPST config was created, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        Time when this UPST config was updated, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetBdsInstanceIdentityConfigurationsIdentityConfigurationIamUserSyncConfigurationDetailResult(dict):
    def __init__(__self__, *,
                 is_posix_attributes_addition_required: _builtins.bool):
        """
        :param _builtins.bool is_posix_attributes_addition_required: whether to append POSIX attributes to IAM users
        """
        pulumi.set(__self__, "is_posix_attributes_addition_required", is_posix_attributes_addition_required)

    @_builtins.property
    @pulumi.getter(name="isPosixAttributesAdditionRequired")
    def is_posix_attributes_addition_required(self) -> _builtins.bool:
        """
        whether to append POSIX attributes to IAM users
        """
        return pulumi.get(self, "is_posix_attributes_addition_required")


@pulumi.output_type
class GetBdsInstanceIdentityConfigurationsIdentityConfigurationUpstConfigurationResult(dict):
    def __init__(__self__, *,
                 keytab_content: _builtins.str,
                 master_encryption_key_id: _builtins.str,
                 secret_id: _builtins.str,
                 state: _builtins.str,
                 time_created: _builtins.str,
                 time_token_exchange_keytab_last_refreshed: _builtins.str,
                 time_updated: _builtins.str,
                 token_exchange_principal_name: _builtins.str,
                 vault_id: _builtins.str):
        """
        :param _builtins.str keytab_content: The kerberos keytab content used for creating identity propagation trust config, in base64 format
        :param _builtins.str master_encryption_key_id: Master Encryption key used for encrypting token exchange keytab.
        :param _builtins.str secret_id: Secret ID for token exchange keytab
        :param _builtins.str state: The state of the identity config
        :param _builtins.str time_created: Time when this UPST config was created, shown as an RFC 3339 formatted datetime string.
        :param _builtins.str time_token_exchange_keytab_last_refreshed: Time when the keytab for token exchange principal is last refreshed, shown as an RFC 3339 formatted datetime string.
        :param _builtins.str time_updated: Time when this UPST config was updated, shown as an RFC 3339 formatted datetime string.
        :param _builtins.str token_exchange_principal_name: Token exchange kerberos Principal name in cluster
        :param _builtins.str vault_id: The instance OCID of the node, which is the resource from which the node backup was acquired.
        """
        pulumi.set(__self__, "keytab_content", keytab_content)
        pulumi.set(__self__, "master_encryption_key_id", master_encryption_key_id)
        pulumi.set(__self__, "secret_id", secret_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_token_exchange_keytab_last_refreshed", time_token_exchange_keytab_last_refreshed)
        pulumi.set(__self__, "time_updated", time_updated)
        pulumi.set(__self__, "token_exchange_principal_name", token_exchange_principal_name)
        pulumi.set(__self__, "vault_id", vault_id)

    @_builtins.property
    @pulumi.getter(name="keytabContent")
    def keytab_content(self) -> _builtins.str:
        """
        The kerberos keytab content used for creating identity propagation trust config, in base64 format
        """
        return pulumi.get(self, "keytab_content")

    @_builtins.property
    @pulumi.getter(name="masterEncryptionKeyId")
    def master_encryption_key_id(self) -> _builtins.str:
        """
        Master Encryption key used for encrypting token exchange keytab.
        """
        return pulumi.get(self, "master_encryption_key_id")

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> _builtins.str:
        """
        Secret ID for token exchange keytab
        """
        return pulumi.get(self, "secret_id")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The state of the identity config
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        Time when this UPST config was created, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeTokenExchangeKeytabLastRefreshed")
    def time_token_exchange_keytab_last_refreshed(self) -> _builtins.str:
        """
        Time when the keytab for token exchange principal is last refreshed, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_token_exchange_keytab_last_refreshed")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        Time when this UPST config was updated, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_updated")

    @_builtins.property
    @pulumi.getter(name="tokenExchangePrincipalName")
    def token_exchange_principal_name(self) -> _builtins.str:
        """
        Token exchange kerberos Principal name in cluster
        """
        return pulumi.get(self, "token_exchange_principal_name")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> _builtins.str:
        """
        The instance OCID of the node, which is the resource from which the node backup was acquired.
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class GetBdsInstanceIdentityConfigurationsIdentityConfigurationUpstConfigurationDetailResult(dict):
    def __init__(__self__, *,
                 master_encryption_key_id: _builtins.str,
                 vault_id: _builtins.str):
        """
        :param _builtins.str master_encryption_key_id: Master Encryption key used for encrypting token exchange keytab.
        :param _builtins.str vault_id: The instance OCID of the node, which is the resource from which the node backup was acquired.
        """
        pulumi.set(__self__, "master_encryption_key_id", master_encryption_key_id)
        pulumi.set(__self__, "vault_id", vault_id)

    @_builtins.property
    @pulumi.getter(name="masterEncryptionKeyId")
    def master_encryption_key_id(self) -> _builtins.str:
        """
        Master Encryption key used for encrypting token exchange keytab.
        """
        return pulumi.get(self, "master_encryption_key_id")

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> _builtins.str:
        """
        The instance OCID of the node, which is the resource from which the node backup was acquired.
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class GetBdsInstanceKafkaBrokerNodeResult(dict):
    def __init__(__self__, *,
                 block_volume_size_in_gbs: _builtins.str,
                 number_of_kafka_nodes: _builtins.int,
                 shape: _builtins.str,
                 shape_configs: Sequence['outputs.GetBdsInstanceKafkaBrokerNodeShapeConfigResult'],
                 subnet_id: _builtins.str):
        """
        :param _builtins.str block_volume_size_in_gbs: The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        :param _builtins.str shape: Shape of the node.
        :param _builtins.str subnet_id: The OCID of the subnet in which the node is to be created.
        """
        pulumi.set(__self__, "block_volume_size_in_gbs", block_volume_size_in_gbs)
        pulumi.set(__self__, "number_of_kafka_nodes", number_of_kafka_nodes)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "shape_configs", shape_configs)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="blockVolumeSizeInGbs")
    def block_volume_size_in_gbs(self) -> _builtins.str:
        """
        The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        """
        return pulumi.get(self, "block_volume_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="numberOfKafkaNodes")
    def number_of_kafka_nodes(self) -> _builtins.int:
        return pulumi.get(self, "number_of_kafka_nodes")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        Shape of the node.
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter(name="shapeConfigs")
    def shape_configs(self) -> Sequence['outputs.GetBdsInstanceKafkaBrokerNodeShapeConfigResult']:
        return pulumi.get(self, "shape_configs")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The OCID of the subnet in which the node is to be created.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetBdsInstanceKafkaBrokerNodeShapeConfigResult(dict):
    def __init__(__self__, *,
                 memory_in_gbs: _builtins.int,
                 nvmes: _builtins.int,
                 ocpus: _builtins.int):
        """
        :param _builtins.int memory_in_gbs: The total amount of memory available to the node, in gigabytes.
        :param _builtins.int nvmes: The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        :param _builtins.int ocpus: The total number of OCPUs available to the node.
        """
        pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        pulumi.set(__self__, "nvmes", nvmes)
        pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> _builtins.int:
        """
        The total amount of memory available to the node, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @_builtins.property
    @pulumi.getter
    def nvmes(self) -> _builtins.int:
        """
        The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        """
        return pulumi.get(self, "nvmes")

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> _builtins.int:
        """
        The total number of OCPUs available to the node.
        """
        return pulumi.get(self, "ocpus")


@pulumi.output_type
class GetBdsInstanceListOsPatchesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetBdsInstanceListOsPatchesOsPatchResult(dict):
    def __init__(__self__, *,
                 bds_instance_id: _builtins.str,
                 os_patch_version: _builtins.str,
                 release_date: _builtins.str):
        """
        :param _builtins.str bds_instance_id: The OCID of the cluster.
        :param _builtins.str os_patch_version: Patch version of the os patch.
        :param _builtins.str release_date: The time when the OS patch was released.
        """
        pulumi.set(__self__, "bds_instance_id", bds_instance_id)
        pulumi.set(__self__, "os_patch_version", os_patch_version)
        pulumi.set(__self__, "release_date", release_date)

    @_builtins.property
    @pulumi.getter(name="bdsInstanceId")
    def bds_instance_id(self) -> _builtins.str:
        """
        The OCID of the cluster.
        """
        return pulumi.get(self, "bds_instance_id")

    @_builtins.property
    @pulumi.getter(name="osPatchVersion")
    def os_patch_version(self) -> _builtins.str:
        """
        Patch version of the os patch.
        """
        return pulumi.get(self, "os_patch_version")

    @_builtins.property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> _builtins.str:
        """
        The time when the OS patch was released.
        """
        return pulumi.get(self, "release_date")


@pulumi.output_type
class GetBdsInstanceMasterNodeResult(dict):
    def __init__(__self__, *,
                 block_volume_size_in_gbs: _builtins.str,
                 number_of_nodes: _builtins.int,
                 shape: _builtins.str,
                 shape_configs: Sequence['outputs.GetBdsInstanceMasterNodeShapeConfigResult'],
                 subnet_id: _builtins.str):
        """
        :param _builtins.str block_volume_size_in_gbs: The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        :param _builtins.int number_of_nodes: The number of nodes that form the cluster.
        :param _builtins.str shape: Shape of the node.
        :param _builtins.str subnet_id: The OCID of the subnet in which the node is to be created.
        """
        pulumi.set(__self__, "block_volume_size_in_gbs", block_volume_size_in_gbs)
        pulumi.set(__self__, "number_of_nodes", number_of_nodes)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "shape_configs", shape_configs)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="blockVolumeSizeInGbs")
    def block_volume_size_in_gbs(self) -> _builtins.str:
        """
        The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        """
        return pulumi.get(self, "block_volume_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="numberOfNodes")
    def number_of_nodes(self) -> _builtins.int:
        """
        The number of nodes that form the cluster.
        """
        return pulumi.get(self, "number_of_nodes")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        Shape of the node.
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter(name="shapeConfigs")
    def shape_configs(self) -> Sequence['outputs.GetBdsInstanceMasterNodeShapeConfigResult']:
        return pulumi.get(self, "shape_configs")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The OCID of the subnet in which the node is to be created.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetBdsInstanceMasterNodeShapeConfigResult(dict):
    def __init__(__self__, *,
                 memory_in_gbs: _builtins.int,
                 nvmes: _builtins.int,
                 ocpus: _builtins.int):
        """
        :param _builtins.int memory_in_gbs: The total amount of memory available to the node, in gigabytes.
        :param _builtins.int nvmes: The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        :param _builtins.int ocpus: The total number of OCPUs available to the node.
        """
        pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        pulumi.set(__self__, "nvmes", nvmes)
        pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> _builtins.int:
        """
        The total amount of memory available to the node, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @_builtins.property
    @pulumi.getter
    def nvmes(self) -> _builtins.int:
        """
        The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        """
        return pulumi.get(self, "nvmes")

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> _builtins.int:
        """
        The total number of OCPUs available to the node.
        """
        return pulumi.get(self, "ocpus")


@pulumi.output_type
class GetBdsInstanceMetastoreConfigsBdsMetastoreConfigurationResult(dict):
    def __init__(__self__, *,
                 activate_trigger: _builtins.int,
                 bds_api_key_id: _builtins.str,
                 bds_api_key_passphrase: _builtins.str,
                 bds_instance_id: _builtins.str,
                 cluster_admin_password: _builtins.str,
                 display_name: _builtins.str,
                 id: _builtins.str,
                 metastore_id: _builtins.str,
                 metastore_type: _builtins.str,
                 state: _builtins.str,
                 time_created: _builtins.str,
                 time_updated: _builtins.str):
        """
        :param _builtins.str bds_api_key_id: The ID of the API key that is associated with the external metastore in the metastore configuration
        :param _builtins.str bds_instance_id: The OCID of the cluster.
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given.
        :param _builtins.str id: The ID of the metastore configuration
        :param _builtins.str metastore_id: The OCID of the Data Catalog metastore in the metastore configuration
        :param _builtins.str metastore_type: The type of the metastore in the metastore configuration
        :param _builtins.str state: The lifecycle state of the metastore in the metastore configuration
        :param _builtins.str time_created: The time when the configuration was created, shown as an RFC 3339 formatted datetime string.
        :param _builtins.str time_updated: The time when the configuration was updated, shown as an RFC 3339 formatted datetime string.
        """
        pulumi.set(__self__, "activate_trigger", activate_trigger)
        pulumi.set(__self__, "bds_api_key_id", bds_api_key_id)
        pulumi.set(__self__, "bds_api_key_passphrase", bds_api_key_passphrase)
        pulumi.set(__self__, "bds_instance_id", bds_instance_id)
        pulumi.set(__self__, "cluster_admin_password", cluster_admin_password)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "metastore_id", metastore_id)
        pulumi.set(__self__, "metastore_type", metastore_type)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @_builtins.property
    @pulumi.getter(name="activateTrigger")
    def activate_trigger(self) -> _builtins.int:
        return pulumi.get(self, "activate_trigger")

    @_builtins.property
    @pulumi.getter(name="bdsApiKeyId")
    def bds_api_key_id(self) -> _builtins.str:
        """
        The ID of the API key that is associated with the external metastore in the metastore configuration
        """
        return pulumi.get(self, "bds_api_key_id")

    @_builtins.property
    @pulumi.getter(name="bdsApiKeyPassphrase")
    def bds_api_key_passphrase(self) -> _builtins.str:
        return pulumi.get(self, "bds_api_key_passphrase")

    @_builtins.property
    @pulumi.getter(name="bdsInstanceId")
    def bds_instance_id(self) -> _builtins.str:
        """
        The OCID of the cluster.
        """
        return pulumi.get(self, "bds_instance_id")

    @_builtins.property
    @pulumi.getter(name="clusterAdminPassword")
    def cluster_admin_password(self) -> _builtins.str:
        return pulumi.get(self, "cluster_admin_password")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the metastore configuration
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="metastoreId")
    def metastore_id(self) -> _builtins.str:
        """
        The OCID of the Data Catalog metastore in the metastore configuration
        """
        return pulumi.get(self, "metastore_id")

    @_builtins.property
    @pulumi.getter(name="metastoreType")
    def metastore_type(self) -> _builtins.str:
        """
        The type of the metastore in the metastore configuration
        """
        return pulumi.get(self, "metastore_type")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The lifecycle state of the metastore in the metastore configuration
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The time when the configuration was created, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The time when the configuration was updated, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetBdsInstanceMetastoreConfigsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetBdsInstanceNetworkConfigResult(dict):
    def __init__(__self__, *,
                 cidr_block: _builtins.str,
                 is_nat_gateway_required: _builtins.bool):
        """
        :param _builtins.str cidr_block: The CIDR IP address block of the VCN.
        :param _builtins.bool is_nat_gateway_required: A boolean flag whether to configure a NAT gateway.
        """
        pulumi.set(__self__, "cidr_block", cidr_block)
        pulumi.set(__self__, "is_nat_gateway_required", is_nat_gateway_required)

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> _builtins.str:
        """
        The CIDR IP address block of the VCN.
        """
        return pulumi.get(self, "cidr_block")

    @_builtins.property
    @pulumi.getter(name="isNatGatewayRequired")
    def is_nat_gateway_required(self) -> _builtins.bool:
        """
        A boolean flag whether to configure a NAT gateway.
        """
        return pulumi.get(self, "is_nat_gateway_required")


@pulumi.output_type
class GetBdsInstanceNodeResult(dict):
    def __init__(__self__, *,
                 attached_block_volumes: Sequence['outputs.GetBdsInstanceNodeAttachedBlockVolumeResult'],
                 availability_domain: _builtins.str,
                 display_name: _builtins.str,
                 fault_domain: _builtins.str,
                 hostname: _builtins.str,
                 image_id: _builtins.str,
                 instance_id: _builtins.str,
                 ip_address: _builtins.str,
                 is_reboot_required: _builtins.bool,
                 local_disks_total_size_in_gbs: _builtins.float,
                 memory_in_gbs: _builtins.int,
                 node_type: _builtins.str,
                 nvmes: _builtins.int,
                 ocpus: _builtins.int,
                 odh_version: _builtins.str,
                 os_version: _builtins.str,
                 shape: _builtins.str,
                 ssh_fingerprint: _builtins.str,
                 state: _builtins.str,
                 subnet_id: _builtins.str,
                 time_created: _builtins.str,
                 time_maintenance_reboot_due: _builtins.str):
        """
        :param Sequence['GetBdsInstanceNodeAttachedBlockVolumeArgs'] attached_block_volumes: The list of block volumes attached to a given node.
        :param _builtins.str availability_domain: The name of the availability domain in which the node is running.
        :param _builtins.str display_name: The name of the node.
        :param _builtins.str fault_domain: The name of the fault domain in which the node is running.
        :param _builtins.str hostname: The fully-qualified hostname (FQDN) of the node.
        :param _builtins.str image_id: The OCID of the image from which the node was created.
        :param _builtins.str instance_id: The OCID of the underlying Oracle Cloud Infrastructure Compute instance.
        :param _builtins.str ip_address: IP address of the node.
        :param _builtins.bool is_reboot_required: Indicates if the node requires a reboot to either reflect the latest os kernel or take actions for maintenance reboot.
        :param _builtins.float local_disks_total_size_in_gbs: The aggregate size of all local disks, in gigabytes. If the instance does not have any local disks, this field is null.
        :param _builtins.int memory_in_gbs: The total amount of memory available to the node, in gigabytes.
        :param _builtins.str node_type: Cluster node type.
        :param _builtins.int nvmes: The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        :param _builtins.int ocpus: The total number of OCPUs available to the node.
        :param _builtins.str odh_version: Version of the ODH (Oracle Distribution including Apache Hadoop) for the node.
        :param _builtins.str os_version: BDS-assigned Operating System version for the node.
        :param _builtins.str shape: Shape of the node.
        :param _builtins.str ssh_fingerprint: The fingerprint of the SSH key used for node access.
        :param _builtins.str state: The state of the cluster.
        :param _builtins.str subnet_id: The OCID of the subnet in which the node is to be created.
        :param _builtins.str time_created: The time the cluster was created, shown as an RFC 3339 formatted datetime string.
        :param _builtins.str time_maintenance_reboot_due: The date and time the instance is expected to be stopped / started, in the format defined by RFC3339.
        """
        pulumi.set(__self__, "attached_block_volumes", attached_block_volumes)
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "fault_domain", fault_domain)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "image_id", image_id)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "is_reboot_required", is_reboot_required)
        pulumi.set(__self__, "local_disks_total_size_in_gbs", local_disks_total_size_in_gbs)
        pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        pulumi.set(__self__, "node_type", node_type)
        pulumi.set(__self__, "nvmes", nvmes)
        pulumi.set(__self__, "ocpus", ocpus)
        pulumi.set(__self__, "odh_version", odh_version)
        pulumi.set(__self__, "os_version", os_version)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "ssh_fingerprint", ssh_fingerprint)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_maintenance_reboot_due", time_maintenance_reboot_due)

    @_builtins.property
    @pulumi.getter(name="attachedBlockVolumes")
    def attached_block_volumes(self) -> Sequence['outputs.GetBdsInstanceNodeAttachedBlockVolumeResult']:
        """
        The list of block volumes attached to a given node.
        """
        return pulumi.get(self, "attached_block_volumes")

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> _builtins.str:
        """
        The name of the availability domain in which the node is running.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The name of the node.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="faultDomain")
    def fault_domain(self) -> _builtins.str:
        """
        The name of the fault domain in which the node is running.
        """
        return pulumi.get(self, "fault_domain")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The fully-qualified hostname (FQDN) of the node.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter(name="imageId")
    def image_id(self) -> _builtins.str:
        """
        The OCID of the image from which the node was created.
        """
        return pulumi.get(self, "image_id")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        """
        The OCID of the underlying Oracle Cloud Infrastructure Compute instance.
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> _builtins.str:
        """
        IP address of the node.
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter(name="isRebootRequired")
    def is_reboot_required(self) -> _builtins.bool:
        """
        Indicates if the node requires a reboot to either reflect the latest os kernel or take actions for maintenance reboot.
        """
        return pulumi.get(self, "is_reboot_required")

    @_builtins.property
    @pulumi.getter(name="localDisksTotalSizeInGbs")
    def local_disks_total_size_in_gbs(self) -> _builtins.float:
        """
        The aggregate size of all local disks, in gigabytes. If the instance does not have any local disks, this field is null.
        """
        return pulumi.get(self, "local_disks_total_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> _builtins.int:
        """
        The total amount of memory available to the node, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @_builtins.property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> _builtins.str:
        """
        Cluster node type.
        """
        return pulumi.get(self, "node_type")

    @_builtins.property
    @pulumi.getter
    def nvmes(self) -> _builtins.int:
        """
        The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        """
        return pulumi.get(self, "nvmes")

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> _builtins.int:
        """
        The total number of OCPUs available to the node.
        """
        return pulumi.get(self, "ocpus")

    @_builtins.property
    @pulumi.getter(name="odhVersion")
    def odh_version(self) -> _builtins.str:
        """
        Version of the ODH (Oracle Distribution including Apache Hadoop) for the node.
        """
        return pulumi.get(self, "odh_version")

    @_builtins.property
    @pulumi.getter(name="osVersion")
    def os_version(self) -> _builtins.str:
        """
        BDS-assigned Operating System version for the node.
        """
        return pulumi.get(self, "os_version")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        Shape of the node.
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter(name="sshFingerprint")
    def ssh_fingerprint(self) -> _builtins.str:
        """
        The fingerprint of the SSH key used for node access.
        """
        return pulumi.get(self, "ssh_fingerprint")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The state of the cluster.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The OCID of the subnet in which the node is to be created.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The time the cluster was created, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeMaintenanceRebootDue")
    def time_maintenance_reboot_due(self) -> _builtins.str:
        """
        The date and time the instance is expected to be stopped / started, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_maintenance_reboot_due")


@pulumi.output_type
class GetBdsInstanceNodeAttachedBlockVolumeResult(dict):
    def __init__(__self__, *,
                 volume_attachment_id: _builtins.str,
                 volume_size_in_gbs: _builtins.str):
        """
        :param _builtins.str volume_attachment_id: The OCID of the volume attachment.
        :param _builtins.str volume_size_in_gbs: The size of the volume in GBs.
        """
        pulumi.set(__self__, "volume_attachment_id", volume_attachment_id)
        pulumi.set(__self__, "volume_size_in_gbs", volume_size_in_gbs)

    @_builtins.property
    @pulumi.getter(name="volumeAttachmentId")
    def volume_attachment_id(self) -> _builtins.str:
        """
        The OCID of the volume attachment.
        """
        return pulumi.get(self, "volume_attachment_id")

    @_builtins.property
    @pulumi.getter(name="volumeSizeInGbs")
    def volume_size_in_gbs(self) -> _builtins.str:
        """
        The size of the volume in GBs.
        """
        return pulumi.get(self, "volume_size_in_gbs")


@pulumi.output_type
class GetBdsInstanceNodeBackupConfigurationLevelTypeDetailResult(dict):
    def __init__(__self__, *,
                 level_type: _builtins.str,
                 node_host_name: _builtins.str,
                 node_type: _builtins.str):
        """
        :param _builtins.str level_type: Type of level used to trigger the creation of a new node backup configuration or node replacement configuration.
        :param _builtins.str node_host_name: Host name of the node to create backup configuration.
        :param _builtins.str node_type: Type of the node or nodes of the node backup configuration or node replacement configuration which are going to be created.
        """
        pulumi.set(__self__, "level_type", level_type)
        pulumi.set(__self__, "node_host_name", node_host_name)
        pulumi.set(__self__, "node_type", node_type)

    @_builtins.property
    @pulumi.getter(name="levelType")
    def level_type(self) -> _builtins.str:
        """
        Type of level used to trigger the creation of a new node backup configuration or node replacement configuration.
        """
        return pulumi.get(self, "level_type")

    @_builtins.property
    @pulumi.getter(name="nodeHostName")
    def node_host_name(self) -> _builtins.str:
        """
        Host name of the node to create backup configuration.
        """
        return pulumi.get(self, "node_host_name")

    @_builtins.property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> _builtins.str:
        """
        Type of the node or nodes of the node backup configuration or node replacement configuration which are going to be created.
        """
        return pulumi.get(self, "node_type")


@pulumi.output_type
class GetBdsInstanceNodeBackupConfigurationsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetBdsInstanceNodeBackupConfigurationsNodeBackupConfigurationResult(dict):
    def __init__(__self__, *,
                 backup_type: _builtins.str,
                 bds_instance_id: _builtins.str,
                 display_name: _builtins.str,
                 id: _builtins.str,
                 level_type_details: Sequence['outputs.GetBdsInstanceNodeBackupConfigurationsNodeBackupConfigurationLevelTypeDetailResult'],
                 number_of_backups_to_retain: _builtins.int,
                 schedule: _builtins.str,
                 state: _builtins.str,
                 time_created: _builtins.str,
                 time_updated: _builtins.str,
                 timezone: _builtins.str):
        """
        :param _builtins.str backup_type: Incremental backup type includes only the changes since the last backup. Full backup type includes all changes since the volume was created.
        :param _builtins.str bds_instance_id: The OCID of the cluster.
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given.
        :param _builtins.str id: The unique identifier for the NodeBackupConfiguration.
        :param Sequence['GetBdsInstanceNodeBackupConfigurationsNodeBackupConfigurationLevelTypeDetailArgs'] level_type_details: Details of the type of level used to trigger the creation of a new node backup configuration or node replacement configuration.
        :param _builtins.int number_of_backups_to_retain: Number of backup copies to retain.
        :param _builtins.str schedule: Day/time recurrence (specified following RFC 5545) at which to trigger the backup process. Currently only DAILY, WEEKLY and MONTHLY frequency is supported. Days of the week are specified using BYDAY field. Time of the day is specified using BYHOUR. Other fields are not supported.
        :param _builtins.str state: The state of the NodeBackupConfiguration configuration.
        :param _builtins.str time_created: The time the NodeBackupConfiguration was created, shown as an RFC 3339 formatted datetime string.
        :param _builtins.str time_updated: The time the NodeBackupConfiguration was updated, shown as an RFC 3339 formatted datetime string.
        :param _builtins.str timezone: The time zone of the execution schedule, in IANA time zone database name format
        """
        pulumi.set(__self__, "backup_type", backup_type)
        pulumi.set(__self__, "bds_instance_id", bds_instance_id)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "level_type_details", level_type_details)
        pulumi.set(__self__, "number_of_backups_to_retain", number_of_backups_to_retain)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)
        pulumi.set(__self__, "timezone", timezone)

    @_builtins.property
    @pulumi.getter(name="backupType")
    def backup_type(self) -> _builtins.str:
        """
        Incremental backup type includes only the changes since the last backup. Full backup type includes all changes since the volume was created.
        """
        return pulumi.get(self, "backup_type")

    @_builtins.property
    @pulumi.getter(name="bdsInstanceId")
    def bds_instance_id(self) -> _builtins.str:
        """
        The OCID of the cluster.
        """
        return pulumi.get(self, "bds_instance_id")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The unique identifier for the NodeBackupConfiguration.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="levelTypeDetails")
    def level_type_details(self) -> Sequence['outputs.GetBdsInstanceNodeBackupConfigurationsNodeBackupConfigurationLevelTypeDetailResult']:
        """
        Details of the type of level used to trigger the creation of a new node backup configuration or node replacement configuration.
        """
        return pulumi.get(self, "level_type_details")

    @_builtins.property
    @pulumi.getter(name="numberOfBackupsToRetain")
    def number_of_backups_to_retain(self) -> _builtins.int:
        """
        Number of backup copies to retain.
        """
        return pulumi.get(self, "number_of_backups_to_retain")

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> _builtins.str:
        """
        Day/time recurrence (specified following RFC 5545) at which to trigger the backup process. Currently only DAILY, WEEKLY and MONTHLY frequency is supported. Days of the week are specified using BYDAY field. Time of the day is specified using BYHOUR. Other fields are not supported.
        """
        return pulumi.get(self, "schedule")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The state of the NodeBackupConfiguration configuration.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The time the NodeBackupConfiguration was created, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The time the NodeBackupConfiguration was updated, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_updated")

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> _builtins.str:
        """
        The time zone of the execution schedule, in IANA time zone database name format
        """
        return pulumi.get(self, "timezone")


@pulumi.output_type
class GetBdsInstanceNodeBackupConfigurationsNodeBackupConfigurationLevelTypeDetailResult(dict):
    def __init__(__self__, *,
                 level_type: _builtins.str,
                 node_host_name: _builtins.str,
                 node_type: _builtins.str):
        """
        :param _builtins.str level_type: Type of level used to trigger the creation of a new node backup configuration or node replacement configuration.
        :param _builtins.str node_host_name: Host name of the node to create backup configuration.
        :param _builtins.str node_type: Type of the node or nodes of the node backup configuration or node replacement configuration which are going to be created.
        """
        pulumi.set(__self__, "level_type", level_type)
        pulumi.set(__self__, "node_host_name", node_host_name)
        pulumi.set(__self__, "node_type", node_type)

    @_builtins.property
    @pulumi.getter(name="levelType")
    def level_type(self) -> _builtins.str:
        """
        Type of level used to trigger the creation of a new node backup configuration or node replacement configuration.
        """
        return pulumi.get(self, "level_type")

    @_builtins.property
    @pulumi.getter(name="nodeHostName")
    def node_host_name(self) -> _builtins.str:
        """
        Host name of the node to create backup configuration.
        """
        return pulumi.get(self, "node_host_name")

    @_builtins.property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> _builtins.str:
        """
        Type of the node or nodes of the node backup configuration or node replacement configuration which are going to be created.
        """
        return pulumi.get(self, "node_type")


@pulumi.output_type
class GetBdsInstanceNodeBackupsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetBdsInstanceNodeBackupsNodeBackupResult(dict):
    def __init__(__self__, *,
                 backup_trigger_type: _builtins.str,
                 backup_type: _builtins.str,
                 display_name: _builtins.str,
                 id: _builtins.str,
                 node_backup_config_id: _builtins.str,
                 node_host_name: _builtins.str,
                 node_instance_id: _builtins.str,
                 state: _builtins.str,
                 time_created: _builtins.str):
        """
        :param _builtins.str backup_trigger_type: type based on how backup action was initiated.
        :param _builtins.str backup_type: Incremental backup type includes only the changes since the last backup. Full backup type includes all changes since the volume was created.
        :param _builtins.str display_name: The display name belonged to the node backup.
        :param _builtins.str id: The id of the node backup.
        :param _builtins.str node_backup_config_id: The ID of the nodeBackupConfiguration if the NodeBackup is automatically created by applying the configuration.
        :param _builtins.str node_host_name: The node host name belonged to a node that has a node backup.
        :param _builtins.str node_instance_id: The instance OCID of the node, which is the resource from which the node backup was acquired.
        :param _builtins.str state: The state of the Node's Backup.
        :param _builtins.str time_created: The time the cluster was created, shown as an RFC 3339 formatted datetime string.
        """
        pulumi.set(__self__, "backup_trigger_type", backup_trigger_type)
        pulumi.set(__self__, "backup_type", backup_type)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "node_backup_config_id", node_backup_config_id)
        pulumi.set(__self__, "node_host_name", node_host_name)
        pulumi.set(__self__, "node_instance_id", node_instance_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)

    @_builtins.property
    @pulumi.getter(name="backupTriggerType")
    def backup_trigger_type(self) -> _builtins.str:
        """
        type based on how backup action was initiated.
        """
        return pulumi.get(self, "backup_trigger_type")

    @_builtins.property
    @pulumi.getter(name="backupType")
    def backup_type(self) -> _builtins.str:
        """
        Incremental backup type includes only the changes since the last backup. Full backup type includes all changes since the volume was created.
        """
        return pulumi.get(self, "backup_type")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The display name belonged to the node backup.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The id of the node backup.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="nodeBackupConfigId")
    def node_backup_config_id(self) -> _builtins.str:
        """
        The ID of the nodeBackupConfiguration if the NodeBackup is automatically created by applying the configuration.
        """
        return pulumi.get(self, "node_backup_config_id")

    @_builtins.property
    @pulumi.getter(name="nodeHostName")
    def node_host_name(self) -> _builtins.str:
        """
        The node host name belonged to a node that has a node backup.
        """
        return pulumi.get(self, "node_host_name")

    @_builtins.property
    @pulumi.getter(name="nodeInstanceId")
    def node_instance_id(self) -> _builtins.str:
        """
        The instance OCID of the node, which is the resource from which the node backup was acquired.
        """
        return pulumi.get(self, "node_instance_id")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The state of the Node's Backup.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The time the cluster was created, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")


@pulumi.output_type
class GetBdsInstanceNodeReplaceConfigurationLevelTypeDetailResult(dict):
    def __init__(__self__, *,
                 level_type: _builtins.str,
                 node_host_name: _builtins.str,
                 node_type: _builtins.str):
        """
        :param _builtins.str level_type: Type of level used to trigger the creation of a new node backup configuration or node replacement configuration.
        :param _builtins.str node_host_name: Host name of the node to create backup configuration.
        :param _builtins.str node_type: Type of the node or nodes of the node backup configuration or node replacement configuration which are going to be created.
        """
        pulumi.set(__self__, "level_type", level_type)
        pulumi.set(__self__, "node_host_name", node_host_name)
        pulumi.set(__self__, "node_type", node_type)

    @_builtins.property
    @pulumi.getter(name="levelType")
    def level_type(self) -> _builtins.str:
        """
        Type of level used to trigger the creation of a new node backup configuration or node replacement configuration.
        """
        return pulumi.get(self, "level_type")

    @_builtins.property
    @pulumi.getter(name="nodeHostName")
    def node_host_name(self) -> _builtins.str:
        """
        Host name of the node to create backup configuration.
        """
        return pulumi.get(self, "node_host_name")

    @_builtins.property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> _builtins.str:
        """
        Type of the node or nodes of the node backup configuration or node replacement configuration which are going to be created.
        """
        return pulumi.get(self, "node_type")


@pulumi.output_type
class GetBdsInstanceNodeReplaceConfigurationsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetBdsInstanceNodeReplaceConfigurationsNodeReplaceConfigurationResult(dict):
    def __init__(__self__, *,
                 bds_instance_id: _builtins.str,
                 cluster_admin_password: _builtins.str,
                 display_name: _builtins.str,
                 duration_in_minutes: _builtins.int,
                 id: _builtins.str,
                 level_type_details: Sequence['outputs.GetBdsInstanceNodeReplaceConfigurationsNodeReplaceConfigurationLevelTypeDetailResult'],
                 metric_type: _builtins.str,
                 state: _builtins.str,
                 time_created: _builtins.str,
                 time_updated: _builtins.str):
        """
        :param _builtins.str bds_instance_id: The OCID of the cluster.
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given.
        :param _builtins.int duration_in_minutes: This value is the minimum period of time to wait for metric emission before triggering node replacement. The value is in minutes.
        :param _builtins.str id: The unique identifier for the NodeReplaceConfiguration.
        :param Sequence['GetBdsInstanceNodeReplaceConfigurationsNodeReplaceConfigurationLevelTypeDetailArgs'] level_type_details: Details of the type of level used to trigger the creation of a new node backup configuration or node replacement configuration.
        :param _builtins.str metric_type: Type of compute instance health metric to use for node replacement
        :param _builtins.str state: The state of the NodeReplaceConfiguration.
        :param _builtins.str time_created: The time the NodeReplaceConfiguration was created, shown as an RFC 3339 formatted datetime string.
        :param _builtins.str time_updated: The time the NodeReplaceConfiguration was updated, shown as an RFC 3339 formatted datetime string.
        """
        pulumi.set(__self__, "bds_instance_id", bds_instance_id)
        pulumi.set(__self__, "cluster_admin_password", cluster_admin_password)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "level_type_details", level_type_details)
        pulumi.set(__self__, "metric_type", metric_type)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)

    @_builtins.property
    @pulumi.getter(name="bdsInstanceId")
    def bds_instance_id(self) -> _builtins.str:
        """
        The OCID of the cluster.
        """
        return pulumi.get(self, "bds_instance_id")

    @_builtins.property
    @pulumi.getter(name="clusterAdminPassword")
    def cluster_admin_password(self) -> _builtins.str:
        return pulumi.get(self, "cluster_admin_password")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> _builtins.int:
        """
        This value is the minimum period of time to wait for metric emission before triggering node replacement. The value is in minutes.
        """
        return pulumi.get(self, "duration_in_minutes")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The unique identifier for the NodeReplaceConfiguration.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="levelTypeDetails")
    def level_type_details(self) -> Sequence['outputs.GetBdsInstanceNodeReplaceConfigurationsNodeReplaceConfigurationLevelTypeDetailResult']:
        """
        Details of the type of level used to trigger the creation of a new node backup configuration or node replacement configuration.
        """
        return pulumi.get(self, "level_type_details")

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> _builtins.str:
        """
        Type of compute instance health metric to use for node replacement
        """
        return pulumi.get(self, "metric_type")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The state of the NodeReplaceConfiguration.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The time the NodeReplaceConfiguration was created, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The time the NodeReplaceConfiguration was updated, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetBdsInstanceNodeReplaceConfigurationsNodeReplaceConfigurationLevelTypeDetailResult(dict):
    def __init__(__self__, *,
                 level_type: _builtins.str,
                 node_host_name: _builtins.str,
                 node_type: _builtins.str):
        """
        :param _builtins.str level_type: Type of level used to trigger the creation of a new node backup configuration or node replacement configuration.
        :param _builtins.str node_host_name: Host name of the node to create backup configuration.
        :param _builtins.str node_type: Type of the node or nodes of the node backup configuration or node replacement configuration which are going to be created.
        """
        pulumi.set(__self__, "level_type", level_type)
        pulumi.set(__self__, "node_host_name", node_host_name)
        pulumi.set(__self__, "node_type", node_type)

    @_builtins.property
    @pulumi.getter(name="levelType")
    def level_type(self) -> _builtins.str:
        """
        Type of level used to trigger the creation of a new node backup configuration or node replacement configuration.
        """
        return pulumi.get(self, "level_type")

    @_builtins.property
    @pulumi.getter(name="nodeHostName")
    def node_host_name(self) -> _builtins.str:
        """
        Host name of the node to create backup configuration.
        """
        return pulumi.get(self, "node_host_name")

    @_builtins.property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> _builtins.str:
        """
        Type of the node or nodes of the node backup configuration or node replacement configuration which are going to be created.
        """
        return pulumi.get(self, "node_type")


@pulumi.output_type
class GetBdsInstancePatchHistoriesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetBdsInstancePatchHistoriesPatchHistoryResult(dict):
    def __init__(__self__, *,
                 patch_type: _builtins.str,
                 state: _builtins.str,
                 time_updated: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str patch_type: The type of a BDS patch history entity.
        :param _builtins.str state: The status of the patch.
        :param _builtins.str time_updated: The time when the patch history was last updated.
        :param _builtins.str version: The version of the patch.
        """
        pulumi.set(__self__, "patch_type", patch_type)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_updated", time_updated)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="patchType")
    def patch_type(self) -> _builtins.str:
        """
        The type of a BDS patch history entity.
        """
        return pulumi.get(self, "patch_type")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The status of the patch.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The time when the patch history was last updated.
        """
        return pulumi.get(self, "time_updated")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The version of the patch.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetBdsInstancePatchesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetBdsInstancePatchesPatchResult(dict):
    def __init__(__self__, *,
                 time_released: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str time_released: The time when the patch was released.
        :param _builtins.str version: The version of the patch.
        """
        pulumi.set(__self__, "time_released", time_released)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="timeReleased")
    def time_released(self) -> _builtins.str:
        """
        The time when the patch was released.
        """
        return pulumi.get(self, "time_released")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The version of the patch.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetBdsInstanceResourcePrincipalConfigurationsFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetBdsInstanceResourcePrincipalConfigurationsResourcePrincipalConfigurationResult(dict):
    def __init__(__self__, *,
                 bds_instance_id: _builtins.str,
                 cluster_admin_password: _builtins.str,
                 display_name: _builtins.str,
                 force_refresh_resource_principal_trigger: _builtins.int,
                 id: _builtins.str,
                 session_token_life_span_duration_in_hours: _builtins.int,
                 state: _builtins.str,
                 time_created: _builtins.str,
                 time_token_expiry: _builtins.str,
                 time_token_refreshed: _builtins.str,
                 time_updated: _builtins.str):
        """
        :param _builtins.str bds_instance_id: The OCID of the cluster.
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given.
        :param _builtins.str id: The id of the ResourcePrincipalConfiguration.
        :param _builtins.int session_token_life_span_duration_in_hours: Life span in hours of each resource principal session token.
        :param _builtins.str state: The state of the ResourcePrincipalConfiguration.
        :param _builtins.str time_created: The time the ResourcePrincipalConfiguration was created, shown as an RFC 3339 formatted datetime string.
        :param _builtins.str time_token_expiry: the time the resource principal session token will expired, shown as an rfc 3339 formatted datetime string.
        :param _builtins.str time_token_refreshed: the time the resource principal session token was refreshed, shown as an rfc 3339 formatted datetime string.
        :param _builtins.str time_updated: The time the ResourcePrincipalConfiguration was updated, shown as an RFC 3339 formatted datetime string.
        """
        pulumi.set(__self__, "bds_instance_id", bds_instance_id)
        pulumi.set(__self__, "cluster_admin_password", cluster_admin_password)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "force_refresh_resource_principal_trigger", force_refresh_resource_principal_trigger)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "session_token_life_span_duration_in_hours", session_token_life_span_duration_in_hours)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_token_expiry", time_token_expiry)
        pulumi.set(__self__, "time_token_refreshed", time_token_refreshed)
        pulumi.set(__self__, "time_updated", time_updated)

    @_builtins.property
    @pulumi.getter(name="bdsInstanceId")
    def bds_instance_id(self) -> _builtins.str:
        """
        The OCID of the cluster.
        """
        return pulumi.get(self, "bds_instance_id")

    @_builtins.property
    @pulumi.getter(name="clusterAdminPassword")
    def cluster_admin_password(self) -> _builtins.str:
        return pulumi.get(self, "cluster_admin_password")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="forceRefreshResourcePrincipalTrigger")
    def force_refresh_resource_principal_trigger(self) -> _builtins.int:
        return pulumi.get(self, "force_refresh_resource_principal_trigger")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The id of the ResourcePrincipalConfiguration.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="sessionTokenLifeSpanDurationInHours")
    def session_token_life_span_duration_in_hours(self) -> _builtins.int:
        """
        Life span in hours of each resource principal session token.
        """
        return pulumi.get(self, "session_token_life_span_duration_in_hours")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The state of the ResourcePrincipalConfiguration.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The time the ResourcePrincipalConfiguration was created, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeTokenExpiry")
    def time_token_expiry(self) -> _builtins.str:
        """
        the time the resource principal session token will expired, shown as an rfc 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_token_expiry")

    @_builtins.property
    @pulumi.getter(name="timeTokenRefreshed")
    def time_token_refreshed(self) -> _builtins.str:
        """
        the time the resource principal session token was refreshed, shown as an rfc 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_token_refreshed")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The time the ResourcePrincipalConfiguration was updated, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetBdsInstanceSoftwareUpdatesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetBdsInstanceSoftwareUpdatesSoftwareUpdateCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetBdsInstanceSoftwareUpdatesSoftwareUpdateCollectionItemResult']):
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetBdsInstanceSoftwareUpdatesSoftwareUpdateCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetBdsInstanceSoftwareUpdatesSoftwareUpdateCollectionItemResult(dict):
    def __init__(__self__, *,
                 software_update_key: _builtins.str,
                 software_update_type: _builtins.str,
                 software_update_version: _builtins.str,
                 state: _builtins.str,
                 time_due: _builtins.str,
                 time_released: _builtins.str):
        """
        :param _builtins.str software_update_key: Unique identifier of a given software update
        :param _builtins.str software_update_type: type of current software update.
               * Big Data Service's micro service. BDS version will be changed after upgrade.
        :param _builtins.str software_update_version: The version of the software update.
        :param _builtins.str state: The lifecycle state of the software update.
        :param _builtins.str time_due: The due date for the software update. Big Data Service will be updated automatically after this date.
        :param _builtins.str time_released: The time when the software update was released.
        """
        pulumi.set(__self__, "software_update_key", software_update_key)
        pulumi.set(__self__, "software_update_type", software_update_type)
        pulumi.set(__self__, "software_update_version", software_update_version)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_due", time_due)
        pulumi.set(__self__, "time_released", time_released)

    @_builtins.property
    @pulumi.getter(name="softwareUpdateKey")
    def software_update_key(self) -> _builtins.str:
        """
        Unique identifier of a given software update
        """
        return pulumi.get(self, "software_update_key")

    @_builtins.property
    @pulumi.getter(name="softwareUpdateType")
    def software_update_type(self) -> _builtins.str:
        """
        type of current software update.
        * Big Data Service's micro service. BDS version will be changed after upgrade.
        """
        return pulumi.get(self, "software_update_type")

    @_builtins.property
    @pulumi.getter(name="softwareUpdateVersion")
    def software_update_version(self) -> _builtins.str:
        """
        The version of the software update.
        """
        return pulumi.get(self, "software_update_version")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The lifecycle state of the software update.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeDue")
    def time_due(self) -> _builtins.str:
        """
        The due date for the software update. Big Data Service will be updated automatically after this date.
        """
        return pulumi.get(self, "time_due")

    @_builtins.property
    @pulumi.getter(name="timeReleased")
    def time_released(self) -> _builtins.str:
        """
        The time when the software update was released.
        """
        return pulumi.get(self, "time_released")


@pulumi.output_type
class GetBdsInstanceStartClusterShapeConfigResult(dict):
    def __init__(__self__, *,
                 node_type_shape_configs: Sequence['outputs.GetBdsInstanceStartClusterShapeConfigNodeTypeShapeConfigResult']):
        pulumi.set(__self__, "node_type_shape_configs", node_type_shape_configs)

    @_builtins.property
    @pulumi.getter(name="nodeTypeShapeConfigs")
    def node_type_shape_configs(self) -> Sequence['outputs.GetBdsInstanceStartClusterShapeConfigNodeTypeShapeConfigResult']:
        return pulumi.get(self, "node_type_shape_configs")


@pulumi.output_type
class GetBdsInstanceStartClusterShapeConfigNodeTypeShapeConfigResult(dict):
    def __init__(__self__, *,
                 node_type: _builtins.str,
                 shape: _builtins.str):
        """
        :param _builtins.str node_type: Cluster node type.
        :param _builtins.str shape: Shape of the node.
        """
        pulumi.set(__self__, "node_type", node_type)
        pulumi.set(__self__, "shape", shape)

    @_builtins.property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> _builtins.str:
        """
        Cluster node type.
        """
        return pulumi.get(self, "node_type")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        Shape of the node.
        """
        return pulumi.get(self, "shape")


@pulumi.output_type
class GetBdsInstanceUtilNodeResult(dict):
    def __init__(__self__, *,
                 block_volume_size_in_gbs: _builtins.str,
                 number_of_nodes: _builtins.int,
                 shape: _builtins.str,
                 shape_configs: Sequence['outputs.GetBdsInstanceUtilNodeShapeConfigResult'],
                 subnet_id: _builtins.str):
        """
        :param _builtins.str block_volume_size_in_gbs: The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        :param _builtins.int number_of_nodes: The number of nodes that form the cluster.
        :param _builtins.str shape: Shape of the node.
        :param _builtins.str subnet_id: The OCID of the subnet in which the node is to be created.
        """
        pulumi.set(__self__, "block_volume_size_in_gbs", block_volume_size_in_gbs)
        pulumi.set(__self__, "number_of_nodes", number_of_nodes)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "shape_configs", shape_configs)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="blockVolumeSizeInGbs")
    def block_volume_size_in_gbs(self) -> _builtins.str:
        """
        The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        """
        return pulumi.get(self, "block_volume_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="numberOfNodes")
    def number_of_nodes(self) -> _builtins.int:
        """
        The number of nodes that form the cluster.
        """
        return pulumi.get(self, "number_of_nodes")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        Shape of the node.
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter(name="shapeConfigs")
    def shape_configs(self) -> Sequence['outputs.GetBdsInstanceUtilNodeShapeConfigResult']:
        return pulumi.get(self, "shape_configs")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The OCID of the subnet in which the node is to be created.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetBdsInstanceUtilNodeShapeConfigResult(dict):
    def __init__(__self__, *,
                 memory_in_gbs: _builtins.int,
                 nvmes: _builtins.int,
                 ocpus: _builtins.int):
        """
        :param _builtins.int memory_in_gbs: The total amount of memory available to the node, in gigabytes.
        :param _builtins.int nvmes: The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        :param _builtins.int ocpus: The total number of OCPUs available to the node.
        """
        pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        pulumi.set(__self__, "nvmes", nvmes)
        pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> _builtins.int:
        """
        The total amount of memory available to the node, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @_builtins.property
    @pulumi.getter
    def nvmes(self) -> _builtins.int:
        """
        The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        """
        return pulumi.get(self, "nvmes")

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> _builtins.int:
        """
        The total number of OCPUs available to the node.
        """
        return pulumi.get(self, "ocpus")


@pulumi.output_type
class GetBdsInstanceWorkerNodeResult(dict):
    def __init__(__self__, *,
                 block_volume_size_in_gbs: _builtins.str,
                 number_of_nodes: _builtins.int,
                 shape: _builtins.str,
                 shape_configs: Sequence['outputs.GetBdsInstanceWorkerNodeShapeConfigResult'],
                 subnet_id: _builtins.str):
        """
        :param _builtins.str block_volume_size_in_gbs: The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        :param _builtins.int number_of_nodes: The number of nodes that form the cluster.
        :param _builtins.str shape: Shape of the node.
        :param _builtins.str subnet_id: The OCID of the subnet in which the node is to be created.
        """
        pulumi.set(__self__, "block_volume_size_in_gbs", block_volume_size_in_gbs)
        pulumi.set(__self__, "number_of_nodes", number_of_nodes)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "shape_configs", shape_configs)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="blockVolumeSizeInGbs")
    def block_volume_size_in_gbs(self) -> _builtins.str:
        """
        The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        """
        return pulumi.get(self, "block_volume_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="numberOfNodes")
    def number_of_nodes(self) -> _builtins.int:
        """
        The number of nodes that form the cluster.
        """
        return pulumi.get(self, "number_of_nodes")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        Shape of the node.
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter(name="shapeConfigs")
    def shape_configs(self) -> Sequence['outputs.GetBdsInstanceWorkerNodeShapeConfigResult']:
        return pulumi.get(self, "shape_configs")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The OCID of the subnet in which the node is to be created.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetBdsInstanceWorkerNodeShapeConfigResult(dict):
    def __init__(__self__, *,
                 memory_in_gbs: _builtins.int,
                 nvmes: _builtins.int,
                 ocpus: _builtins.int):
        """
        :param _builtins.int memory_in_gbs: The total amount of memory available to the node, in gigabytes.
        :param _builtins.int nvmes: The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        :param _builtins.int ocpus: The total number of OCPUs available to the node.
        """
        pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        pulumi.set(__self__, "nvmes", nvmes)
        pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> _builtins.int:
        """
        The total amount of memory available to the node, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @_builtins.property
    @pulumi.getter
    def nvmes(self) -> _builtins.int:
        """
        The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        """
        return pulumi.get(self, "nvmes")

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> _builtins.int:
        """
        The total number of OCPUs available to the node.
        """
        return pulumi.get(self, "ocpus")


@pulumi.output_type
class GetBdsInstancesBdsInstanceResult(dict):
    def __init__(__self__, *,
                 bds_cluster_version_summaries: Sequence['outputs.GetBdsInstancesBdsInstanceBdsClusterVersionSummaryResult'],
                 bootstrap_script_url: _builtins.str,
                 cloud_sql_details: Sequence['outputs.GetBdsInstancesBdsInstanceCloudSqlDetailResult'],
                 cluster_admin_password: _builtins.str,
                 cluster_details: Sequence['outputs.GetBdsInstancesBdsInstanceClusterDetailResult'],
                 cluster_profile: _builtins.str,
                 cluster_public_key: _builtins.str,
                 cluster_version: _builtins.str,
                 compartment_id: _builtins.str,
                 compute_only_worker_nodes: Sequence['outputs.GetBdsInstancesBdsInstanceComputeOnlyWorkerNodeResult'],
                 created_by: _builtins.str,
                 defined_tags: Mapping[str, _builtins.str],
                 display_name: _builtins.str,
                 edge_nodes: Sequence['outputs.GetBdsInstancesBdsInstanceEdgeNodeResult'],
                 freeform_tags: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 ignore_existing_nodes_shapes: Sequence[_builtins.str],
                 is_cloud_sql_configured: _builtins.bool,
                 is_force_remove_enabled: _builtins.bool,
                 is_force_stop_jobs: _builtins.bool,
                 is_high_availability: _builtins.bool,
                 is_kafka_configured: _builtins.bool,
                 is_secure: _builtins.bool,
                 kafka_broker_nodes: Sequence['outputs.GetBdsInstancesBdsInstanceKafkaBrokerNodeResult'],
                 kerberos_realm_name: _builtins.str,
                 kms_key_id: _builtins.str,
                 master_nodes: Sequence['outputs.GetBdsInstancesBdsInstanceMasterNodeResult'],
                 network_configs: Sequence['outputs.GetBdsInstancesBdsInstanceNetworkConfigResult'],
                 nodes: Sequence['outputs.GetBdsInstancesBdsInstanceNodeResult'],
                 number_of_nodes: _builtins.int,
                 number_of_nodes_requiring_maintenance_reboot: _builtins.int,
                 os_patch_version: _builtins.str,
                 remove_node: _builtins.str,
                 start_cluster_shape_configs: Sequence['outputs.GetBdsInstancesBdsInstanceStartClusterShapeConfigResult'],
                 state: _builtins.str,
                 time_created: _builtins.str,
                 time_updated: _builtins.str,
                 util_nodes: Sequence['outputs.GetBdsInstancesBdsInstanceUtilNodeResult'],
                 worker_nodes: Sequence['outputs.GetBdsInstancesBdsInstanceWorkerNodeResult']):
        """
        :param Sequence['GetBdsInstancesBdsInstanceBdsClusterVersionSummaryArgs'] bds_cluster_version_summaries: Cluster version details including bds and odh version information.
        :param _builtins.str bootstrap_script_url: pre-authenticated URL of the bootstrap script in Object Store that can be downloaded and executed.
        :param Sequence['GetBdsInstancesBdsInstanceCloudSqlDetailArgs'] cloud_sql_details: The information about added Cloud SQL capability
        :param Sequence['GetBdsInstancesBdsInstanceClusterDetailArgs'] cluster_details: Specific info about a Hadoop cluster
        :param _builtins.str cluster_profile: Profile of the Big Data Service cluster.
        :param _builtins.str cluster_version: Version of the Hadoop distribution.
        :param _builtins.str compartment_id: The OCID of the compartment.
        :param _builtins.str created_by: The user who created the cluster.
        :param Mapping[str, _builtins.str] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For example, `{"foo-namespace": {"bar-key": "value"}}`
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given.
        :param Mapping[str, _builtins.str] freeform_tags: Simple key-value pair that is applied without any predefined name, type, or scope. Exists for cross-compatibility only. For example, `{"bar-key": "value"}`
        :param _builtins.str id: The OCID of the Big Data Service resource.
        :param _builtins.bool is_cloud_sql_configured: Boolean flag specifying whether or not Cloud SQL should be configured.
        :param _builtins.bool is_high_availability: Boolean flag specifying whether or not the cluster is highly available (HA)
        :param _builtins.bool is_kafka_configured: Boolean flag specifying whether or not Kafka should be configured.
        :param _builtins.bool is_secure: Boolean flag specifying whether or not the cluster should be set up as secure.
        :param _builtins.str kms_key_id: The OCID of the Key Management master encryption key.
        :param Sequence['GetBdsInstancesBdsInstanceNetworkConfigArgs'] network_configs: Additional configuration of the user's network.
        :param Sequence['GetBdsInstancesBdsInstanceNodeArgs'] nodes: The list of nodes in the cluster.
        :param _builtins.int number_of_nodes: The number of nodes that form the cluster.
        :param _builtins.int number_of_nodes_requiring_maintenance_reboot: Number of nodes that require a maintenance reboot
        :param _builtins.str state: The state of the cluster.
        :param _builtins.str time_created: The time the cluster was created, shown as an RFC 3339 formatted datetime string.
        :param _builtins.str time_updated: The time the cluster was updated, shown as an RFC 3339 formatted datetime string.
        """
        pulumi.set(__self__, "bds_cluster_version_summaries", bds_cluster_version_summaries)
        pulumi.set(__self__, "bootstrap_script_url", bootstrap_script_url)
        pulumi.set(__self__, "cloud_sql_details", cloud_sql_details)
        pulumi.set(__self__, "cluster_admin_password", cluster_admin_password)
        pulumi.set(__self__, "cluster_details", cluster_details)
        pulumi.set(__self__, "cluster_profile", cluster_profile)
        pulumi.set(__self__, "cluster_public_key", cluster_public_key)
        pulumi.set(__self__, "cluster_version", cluster_version)
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "compute_only_worker_nodes", compute_only_worker_nodes)
        pulumi.set(__self__, "created_by", created_by)
        pulumi.set(__self__, "defined_tags", defined_tags)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "edge_nodes", edge_nodes)
        pulumi.set(__self__, "freeform_tags", freeform_tags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ignore_existing_nodes_shapes", ignore_existing_nodes_shapes)
        pulumi.set(__self__, "is_cloud_sql_configured", is_cloud_sql_configured)
        pulumi.set(__self__, "is_force_remove_enabled", is_force_remove_enabled)
        pulumi.set(__self__, "is_force_stop_jobs", is_force_stop_jobs)
        pulumi.set(__self__, "is_high_availability", is_high_availability)
        pulumi.set(__self__, "is_kafka_configured", is_kafka_configured)
        pulumi.set(__self__, "is_secure", is_secure)
        pulumi.set(__self__, "kafka_broker_nodes", kafka_broker_nodes)
        pulumi.set(__self__, "kerberos_realm_name", kerberos_realm_name)
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        pulumi.set(__self__, "master_nodes", master_nodes)
        pulumi.set(__self__, "network_configs", network_configs)
        pulumi.set(__self__, "nodes", nodes)
        pulumi.set(__self__, "number_of_nodes", number_of_nodes)
        pulumi.set(__self__, "number_of_nodes_requiring_maintenance_reboot", number_of_nodes_requiring_maintenance_reboot)
        pulumi.set(__self__, "os_patch_version", os_patch_version)
        pulumi.set(__self__, "remove_node", remove_node)
        pulumi.set(__self__, "start_cluster_shape_configs", start_cluster_shape_configs)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_updated", time_updated)
        pulumi.set(__self__, "util_nodes", util_nodes)
        pulumi.set(__self__, "worker_nodes", worker_nodes)

    @_builtins.property
    @pulumi.getter(name="bdsClusterVersionSummaries")
    def bds_cluster_version_summaries(self) -> Sequence['outputs.GetBdsInstancesBdsInstanceBdsClusterVersionSummaryResult']:
        """
        Cluster version details including bds and odh version information.
        """
        return pulumi.get(self, "bds_cluster_version_summaries")

    @_builtins.property
    @pulumi.getter(name="bootstrapScriptUrl")
    def bootstrap_script_url(self) -> _builtins.str:
        """
        pre-authenticated URL of the bootstrap script in Object Store that can be downloaded and executed.
        """
        return pulumi.get(self, "bootstrap_script_url")

    @_builtins.property
    @pulumi.getter(name="cloudSqlDetails")
    def cloud_sql_details(self) -> Sequence['outputs.GetBdsInstancesBdsInstanceCloudSqlDetailResult']:
        """
        The information about added Cloud SQL capability
        """
        return pulumi.get(self, "cloud_sql_details")

    @_builtins.property
    @pulumi.getter(name="clusterAdminPassword")
    def cluster_admin_password(self) -> _builtins.str:
        return pulumi.get(self, "cluster_admin_password")

    @_builtins.property
    @pulumi.getter(name="clusterDetails")
    def cluster_details(self) -> Sequence['outputs.GetBdsInstancesBdsInstanceClusterDetailResult']:
        """
        Specific info about a Hadoop cluster
        """
        return pulumi.get(self, "cluster_details")

    @_builtins.property
    @pulumi.getter(name="clusterProfile")
    def cluster_profile(self) -> _builtins.str:
        """
        Profile of the Big Data Service cluster.
        """
        return pulumi.get(self, "cluster_profile")

    @_builtins.property
    @pulumi.getter(name="clusterPublicKey")
    def cluster_public_key(self) -> _builtins.str:
        return pulumi.get(self, "cluster_public_key")

    @_builtins.property
    @pulumi.getter(name="clusterVersion")
    def cluster_version(self) -> _builtins.str:
        """
        Version of the Hadoop distribution.
        """
        return pulumi.get(self, "cluster_version")

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The OCID of the compartment.
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="computeOnlyWorkerNodes")
    def compute_only_worker_nodes(self) -> Sequence['outputs.GetBdsInstancesBdsInstanceComputeOnlyWorkerNodeResult']:
        return pulumi.get(self, "compute_only_worker_nodes")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> _builtins.str:
        """
        The user who created the cluster.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, _builtins.str]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For example, `{"foo-namespace": {"bar-key": "value"}}`
        """
        return pulumi.get(self, "defined_tags")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="edgeNodes")
    def edge_nodes(self) -> Sequence['outputs.GetBdsInstancesBdsInstanceEdgeNodeResult']:
        return pulumi.get(self, "edge_nodes")

    @_builtins.property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, _builtins.str]:
        """
        Simple key-value pair that is applied without any predefined name, type, or scope. Exists for cross-compatibility only. For example, `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The OCID of the Big Data Service resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="ignoreExistingNodesShapes")
    def ignore_existing_nodes_shapes(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ignore_existing_nodes_shapes")

    @_builtins.property
    @pulumi.getter(name="isCloudSqlConfigured")
    def is_cloud_sql_configured(self) -> _builtins.bool:
        """
        Boolean flag specifying whether or not Cloud SQL should be configured.
        """
        return pulumi.get(self, "is_cloud_sql_configured")

    @_builtins.property
    @pulumi.getter(name="isForceRemoveEnabled")
    def is_force_remove_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "is_force_remove_enabled")

    @_builtins.property
    @pulumi.getter(name="isForceStopJobs")
    def is_force_stop_jobs(self) -> _builtins.bool:
        return pulumi.get(self, "is_force_stop_jobs")

    @_builtins.property
    @pulumi.getter(name="isHighAvailability")
    def is_high_availability(self) -> _builtins.bool:
        """
        Boolean flag specifying whether or not the cluster is highly available (HA)
        """
        return pulumi.get(self, "is_high_availability")

    @_builtins.property
    @pulumi.getter(name="isKafkaConfigured")
    def is_kafka_configured(self) -> _builtins.bool:
        """
        Boolean flag specifying whether or not Kafka should be configured.
        """
        return pulumi.get(self, "is_kafka_configured")

    @_builtins.property
    @pulumi.getter(name="isSecure")
    def is_secure(self) -> _builtins.bool:
        """
        Boolean flag specifying whether or not the cluster should be set up as secure.
        """
        return pulumi.get(self, "is_secure")

    @_builtins.property
    @pulumi.getter(name="kafkaBrokerNodes")
    def kafka_broker_nodes(self) -> Sequence['outputs.GetBdsInstancesBdsInstanceKafkaBrokerNodeResult']:
        return pulumi.get(self, "kafka_broker_nodes")

    @_builtins.property
    @pulumi.getter(name="kerberosRealmName")
    def kerberos_realm_name(self) -> _builtins.str:
        return pulumi.get(self, "kerberos_realm_name")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> _builtins.str:
        """
        The OCID of the Key Management master encryption key.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="masterNodes")
    def master_nodes(self) -> Sequence['outputs.GetBdsInstancesBdsInstanceMasterNodeResult']:
        return pulumi.get(self, "master_nodes")

    @_builtins.property
    @pulumi.getter(name="networkConfigs")
    def network_configs(self) -> Sequence['outputs.GetBdsInstancesBdsInstanceNetworkConfigResult']:
        """
        Additional configuration of the user's network.
        """
        return pulumi.get(self, "network_configs")

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> Sequence['outputs.GetBdsInstancesBdsInstanceNodeResult']:
        """
        The list of nodes in the cluster.
        """
        return pulumi.get(self, "nodes")

    @_builtins.property
    @pulumi.getter(name="numberOfNodes")
    def number_of_nodes(self) -> _builtins.int:
        """
        The number of nodes that form the cluster.
        """
        return pulumi.get(self, "number_of_nodes")

    @_builtins.property
    @pulumi.getter(name="numberOfNodesRequiringMaintenanceReboot")
    def number_of_nodes_requiring_maintenance_reboot(self) -> _builtins.int:
        """
        Number of nodes that require a maintenance reboot
        """
        return pulumi.get(self, "number_of_nodes_requiring_maintenance_reboot")

    @_builtins.property
    @pulumi.getter(name="osPatchVersion")
    def os_patch_version(self) -> _builtins.str:
        return pulumi.get(self, "os_patch_version")

    @_builtins.property
    @pulumi.getter(name="removeNode")
    def remove_node(self) -> _builtins.str:
        return pulumi.get(self, "remove_node")

    @_builtins.property
    @pulumi.getter(name="startClusterShapeConfigs")
    def start_cluster_shape_configs(self) -> Sequence['outputs.GetBdsInstancesBdsInstanceStartClusterShapeConfigResult']:
        return pulumi.get(self, "start_cluster_shape_configs")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The state of the cluster.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The time the cluster was created, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> _builtins.str:
        """
        The time the cluster was updated, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_updated")

    @_builtins.property
    @pulumi.getter(name="utilNodes")
    def util_nodes(self) -> Sequence['outputs.GetBdsInstancesBdsInstanceUtilNodeResult']:
        return pulumi.get(self, "util_nodes")

    @_builtins.property
    @pulumi.getter(name="workerNodes")
    def worker_nodes(self) -> Sequence['outputs.GetBdsInstancesBdsInstanceWorkerNodeResult']:
        return pulumi.get(self, "worker_nodes")


@pulumi.output_type
class GetBdsInstancesBdsInstanceBdsClusterVersionSummaryResult(dict):
    def __init__(__self__, *,
                 bds_version: _builtins.str,
                 odh_version: _builtins.str):
        """
        :param _builtins.str bds_version: Big Data Service version installed in the cluster.
        :param _builtins.str odh_version: Version of the ODH (Oracle Distribution including Apache Hadoop) for the node.
        """
        pulumi.set(__self__, "bds_version", bds_version)
        pulumi.set(__self__, "odh_version", odh_version)

    @_builtins.property
    @pulumi.getter(name="bdsVersion")
    def bds_version(self) -> _builtins.str:
        """
        Big Data Service version installed in the cluster.
        """
        return pulumi.get(self, "bds_version")

    @_builtins.property
    @pulumi.getter(name="odhVersion")
    def odh_version(self) -> _builtins.str:
        """
        Version of the ODH (Oracle Distribution including Apache Hadoop) for the node.
        """
        return pulumi.get(self, "odh_version")


@pulumi.output_type
class GetBdsInstancesBdsInstanceCloudSqlDetailResult(dict):
    def __init__(__self__, *,
                 block_volume_size_in_gbs: _builtins.str,
                 ip_address: _builtins.str,
                 is_kerberos_mapped_to_database_users: _builtins.bool,
                 kerberos_details: Sequence['outputs.GetBdsInstancesBdsInstanceCloudSqlDetailKerberosDetailResult'],
                 memory_in_gbs: _builtins.int,
                 nvmes: _builtins.int,
                 ocpus: _builtins.int,
                 shape: _builtins.str):
        """
        :param _builtins.str block_volume_size_in_gbs: The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        :param _builtins.str ip_address: IP address of the node.
        :param _builtins.bool is_kerberos_mapped_to_database_users: Boolean flag specifying whether or not Kerberos principals are mapped to database users.
        :param Sequence['GetBdsInstancesBdsInstanceCloudSqlDetailKerberosDetailArgs'] kerberos_details: Details about the Kerberos principals.
        :param _builtins.int memory_in_gbs: The total amount of memory available to the node, in gigabytes.
        :param _builtins.int nvmes: The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        :param _builtins.int ocpus: The total number of OCPUs available to the node.
        :param _builtins.str shape: Shape of the node.
        """
        pulumi.set(__self__, "block_volume_size_in_gbs", block_volume_size_in_gbs)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "is_kerberos_mapped_to_database_users", is_kerberos_mapped_to_database_users)
        pulumi.set(__self__, "kerberos_details", kerberos_details)
        pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        pulumi.set(__self__, "nvmes", nvmes)
        pulumi.set(__self__, "ocpus", ocpus)
        pulumi.set(__self__, "shape", shape)

    @_builtins.property
    @pulumi.getter(name="blockVolumeSizeInGbs")
    def block_volume_size_in_gbs(self) -> _builtins.str:
        """
        The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        """
        return pulumi.get(self, "block_volume_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> _builtins.str:
        """
        IP address of the node.
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter(name="isKerberosMappedToDatabaseUsers")
    def is_kerberos_mapped_to_database_users(self) -> _builtins.bool:
        """
        Boolean flag specifying whether or not Kerberos principals are mapped to database users.
        """
        return pulumi.get(self, "is_kerberos_mapped_to_database_users")

    @_builtins.property
    @pulumi.getter(name="kerberosDetails")
    def kerberos_details(self) -> Sequence['outputs.GetBdsInstancesBdsInstanceCloudSqlDetailKerberosDetailResult']:
        """
        Details about the Kerberos principals.
        """
        return pulumi.get(self, "kerberos_details")

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> _builtins.int:
        """
        The total amount of memory available to the node, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @_builtins.property
    @pulumi.getter
    def nvmes(self) -> _builtins.int:
        """
        The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        """
        return pulumi.get(self, "nvmes")

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> _builtins.int:
        """
        The total number of OCPUs available to the node.
        """
        return pulumi.get(self, "ocpus")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        Shape of the node.
        """
        return pulumi.get(self, "shape")


@pulumi.output_type
class GetBdsInstancesBdsInstanceCloudSqlDetailKerberosDetailResult(dict):
    def __init__(__self__, *,
                 keytab_file: _builtins.str,
                 principal_name: _builtins.str):
        """
        :param _builtins.str keytab_file: Location of the keytab file
        :param _builtins.str principal_name: Name of the Kerberos principal.
        """
        pulumi.set(__self__, "keytab_file", keytab_file)
        pulumi.set(__self__, "principal_name", principal_name)

    @_builtins.property
    @pulumi.getter(name="keytabFile")
    def keytab_file(self) -> _builtins.str:
        """
        Location of the keytab file
        """
        return pulumi.get(self, "keytab_file")

    @_builtins.property
    @pulumi.getter(name="principalName")
    def principal_name(self) -> _builtins.str:
        """
        Name of the Kerberos principal.
        """
        return pulumi.get(self, "principal_name")


@pulumi.output_type
class GetBdsInstancesBdsInstanceClusterDetailResult(dict):
    def __init__(__self__, *,
                 ambari_url: _builtins.str,
                 bd_cell_version: _builtins.str,
                 bda_version: _builtins.str,
                 bdm_version: _builtins.str,
                 bds_version: _builtins.str,
                 big_data_manager_url: _builtins.str,
                 cloudera_manager_url: _builtins.str,
                 csql_cell_version: _builtins.str,
                 db_version: _builtins.str,
                 hue_server_url: _builtins.str,
                 jupyter_hub_url: _builtins.str,
                 odh_version: _builtins.str,
                 os_version: _builtins.str,
                 time_created: _builtins.str,
                 time_refreshed: _builtins.str):
        """
        :param _builtins.str ambari_url: The URL of Ambari
        :param _builtins.str bd_cell_version: Cloud SQL cell version.
        :param _builtins.str bda_version: BDA version installed in the cluster
        :param _builtins.str bdm_version: Big Data Manager version installed in the cluster.
        :param _builtins.str bds_version: Big Data Service version installed in the cluster.
        :param _builtins.str big_data_manager_url: The URL of Big Data Manager.
        :param _builtins.str cloudera_manager_url: The URL of Cloudera Manager
        :param _builtins.str csql_cell_version: Big Data SQL version.
        :param _builtins.str db_version: Cloud SQL query server database version.
        :param _builtins.str hue_server_url: The URL of the Hue server.
        :param _builtins.str jupyter_hub_url: The URL of the Jupyterhub.
        :param _builtins.str odh_version: Version of the ODH (Oracle Distribution including Apache Hadoop) for the node.
        :param _builtins.str os_version: BDS-assigned Operating System version for the node.
        :param _builtins.str time_created: The time the cluster was created, shown as an RFC 3339 formatted datetime string.
        :param _builtins.str time_refreshed: The time the cluster was automatically or manually refreshed, shown as an RFC 3339 formatted datetime string.
        """
        pulumi.set(__self__, "ambari_url", ambari_url)
        pulumi.set(__self__, "bd_cell_version", bd_cell_version)
        pulumi.set(__self__, "bda_version", bda_version)
        pulumi.set(__self__, "bdm_version", bdm_version)
        pulumi.set(__self__, "bds_version", bds_version)
        pulumi.set(__self__, "big_data_manager_url", big_data_manager_url)
        pulumi.set(__self__, "cloudera_manager_url", cloudera_manager_url)
        pulumi.set(__self__, "csql_cell_version", csql_cell_version)
        pulumi.set(__self__, "db_version", db_version)
        pulumi.set(__self__, "hue_server_url", hue_server_url)
        pulumi.set(__self__, "jupyter_hub_url", jupyter_hub_url)
        pulumi.set(__self__, "odh_version", odh_version)
        pulumi.set(__self__, "os_version", os_version)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_refreshed", time_refreshed)

    @_builtins.property
    @pulumi.getter(name="ambariUrl")
    def ambari_url(self) -> _builtins.str:
        """
        The URL of Ambari
        """
        return pulumi.get(self, "ambari_url")

    @_builtins.property
    @pulumi.getter(name="bdCellVersion")
    def bd_cell_version(self) -> _builtins.str:
        """
        Cloud SQL cell version.
        """
        return pulumi.get(self, "bd_cell_version")

    @_builtins.property
    @pulumi.getter(name="bdaVersion")
    def bda_version(self) -> _builtins.str:
        """
        BDA version installed in the cluster
        """
        return pulumi.get(self, "bda_version")

    @_builtins.property
    @pulumi.getter(name="bdmVersion")
    def bdm_version(self) -> _builtins.str:
        """
        Big Data Manager version installed in the cluster.
        """
        return pulumi.get(self, "bdm_version")

    @_builtins.property
    @pulumi.getter(name="bdsVersion")
    def bds_version(self) -> _builtins.str:
        """
        Big Data Service version installed in the cluster.
        """
        return pulumi.get(self, "bds_version")

    @_builtins.property
    @pulumi.getter(name="bigDataManagerUrl")
    def big_data_manager_url(self) -> _builtins.str:
        """
        The URL of Big Data Manager.
        """
        return pulumi.get(self, "big_data_manager_url")

    @_builtins.property
    @pulumi.getter(name="clouderaManagerUrl")
    def cloudera_manager_url(self) -> _builtins.str:
        """
        The URL of Cloudera Manager
        """
        return pulumi.get(self, "cloudera_manager_url")

    @_builtins.property
    @pulumi.getter(name="csqlCellVersion")
    def csql_cell_version(self) -> _builtins.str:
        """
        Big Data SQL version.
        """
        return pulumi.get(self, "csql_cell_version")

    @_builtins.property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> _builtins.str:
        """
        Cloud SQL query server database version.
        """
        return pulumi.get(self, "db_version")

    @_builtins.property
    @pulumi.getter(name="hueServerUrl")
    def hue_server_url(self) -> _builtins.str:
        """
        The URL of the Hue server.
        """
        return pulumi.get(self, "hue_server_url")

    @_builtins.property
    @pulumi.getter(name="jupyterHubUrl")
    def jupyter_hub_url(self) -> _builtins.str:
        """
        The URL of the Jupyterhub.
        """
        return pulumi.get(self, "jupyter_hub_url")

    @_builtins.property
    @pulumi.getter(name="odhVersion")
    def odh_version(self) -> _builtins.str:
        """
        Version of the ODH (Oracle Distribution including Apache Hadoop) for the node.
        """
        return pulumi.get(self, "odh_version")

    @_builtins.property
    @pulumi.getter(name="osVersion")
    def os_version(self) -> _builtins.str:
        """
        BDS-assigned Operating System version for the node.
        """
        return pulumi.get(self, "os_version")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The time the cluster was created, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeRefreshed")
    def time_refreshed(self) -> _builtins.str:
        """
        The time the cluster was automatically or manually refreshed, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_refreshed")


@pulumi.output_type
class GetBdsInstancesBdsInstanceComputeOnlyWorkerNodeResult(dict):
    def __init__(__self__, *,
                 block_volume_size_in_gbs: _builtins.str,
                 number_of_nodes: _builtins.int,
                 shape: _builtins.str,
                 shape_configs: Sequence['outputs.GetBdsInstancesBdsInstanceComputeOnlyWorkerNodeShapeConfigResult'],
                 subnet_id: _builtins.str):
        """
        :param _builtins.str block_volume_size_in_gbs: The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        :param _builtins.int number_of_nodes: The number of nodes that form the cluster.
        :param _builtins.str shape: Shape of the node.
        :param _builtins.str subnet_id: The OCID of the subnet in which the node is to be created.
        """
        pulumi.set(__self__, "block_volume_size_in_gbs", block_volume_size_in_gbs)
        pulumi.set(__self__, "number_of_nodes", number_of_nodes)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "shape_configs", shape_configs)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="blockVolumeSizeInGbs")
    def block_volume_size_in_gbs(self) -> _builtins.str:
        """
        The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        """
        return pulumi.get(self, "block_volume_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="numberOfNodes")
    def number_of_nodes(self) -> _builtins.int:
        """
        The number of nodes that form the cluster.
        """
        return pulumi.get(self, "number_of_nodes")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        Shape of the node.
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter(name="shapeConfigs")
    def shape_configs(self) -> Sequence['outputs.GetBdsInstancesBdsInstanceComputeOnlyWorkerNodeShapeConfigResult']:
        return pulumi.get(self, "shape_configs")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The OCID of the subnet in which the node is to be created.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetBdsInstancesBdsInstanceComputeOnlyWorkerNodeShapeConfigResult(dict):
    def __init__(__self__, *,
                 memory_in_gbs: _builtins.int,
                 nvmes: _builtins.int,
                 ocpus: _builtins.int):
        """
        :param _builtins.int memory_in_gbs: The total amount of memory available to the node, in gigabytes.
        :param _builtins.int nvmes: The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        :param _builtins.int ocpus: The total number of OCPUs available to the node.
        """
        pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        pulumi.set(__self__, "nvmes", nvmes)
        pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> _builtins.int:
        """
        The total amount of memory available to the node, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @_builtins.property
    @pulumi.getter
    def nvmes(self) -> _builtins.int:
        """
        The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        """
        return pulumi.get(self, "nvmes")

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> _builtins.int:
        """
        The total number of OCPUs available to the node.
        """
        return pulumi.get(self, "ocpus")


@pulumi.output_type
class GetBdsInstancesBdsInstanceEdgeNodeResult(dict):
    def __init__(__self__, *,
                 block_volume_size_in_gbs: _builtins.str,
                 number_of_nodes: _builtins.int,
                 shape: _builtins.str,
                 shape_configs: Sequence['outputs.GetBdsInstancesBdsInstanceEdgeNodeShapeConfigResult'],
                 subnet_id: _builtins.str):
        """
        :param _builtins.str block_volume_size_in_gbs: The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        :param _builtins.int number_of_nodes: The number of nodes that form the cluster.
        :param _builtins.str shape: Shape of the node.
        :param _builtins.str subnet_id: The OCID of the subnet in which the node is to be created.
        """
        pulumi.set(__self__, "block_volume_size_in_gbs", block_volume_size_in_gbs)
        pulumi.set(__self__, "number_of_nodes", number_of_nodes)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "shape_configs", shape_configs)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="blockVolumeSizeInGbs")
    def block_volume_size_in_gbs(self) -> _builtins.str:
        """
        The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        """
        return pulumi.get(self, "block_volume_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="numberOfNodes")
    def number_of_nodes(self) -> _builtins.int:
        """
        The number of nodes that form the cluster.
        """
        return pulumi.get(self, "number_of_nodes")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        Shape of the node.
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter(name="shapeConfigs")
    def shape_configs(self) -> Sequence['outputs.GetBdsInstancesBdsInstanceEdgeNodeShapeConfigResult']:
        return pulumi.get(self, "shape_configs")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The OCID of the subnet in which the node is to be created.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetBdsInstancesBdsInstanceEdgeNodeShapeConfigResult(dict):
    def __init__(__self__, *,
                 memory_in_gbs: _builtins.int,
                 nvmes: _builtins.int,
                 ocpus: _builtins.int):
        """
        :param _builtins.int memory_in_gbs: The total amount of memory available to the node, in gigabytes.
        :param _builtins.int nvmes: The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        :param _builtins.int ocpus: The total number of OCPUs available to the node.
        """
        pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        pulumi.set(__self__, "nvmes", nvmes)
        pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> _builtins.int:
        """
        The total amount of memory available to the node, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @_builtins.property
    @pulumi.getter
    def nvmes(self) -> _builtins.int:
        """
        The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        """
        return pulumi.get(self, "nvmes")

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> _builtins.int:
        """
        The total number of OCPUs available to the node.
        """
        return pulumi.get(self, "ocpus")


@pulumi.output_type
class GetBdsInstancesBdsInstanceKafkaBrokerNodeResult(dict):
    def __init__(__self__, *,
                 block_volume_size_in_gbs: _builtins.str,
                 number_of_kafka_nodes: _builtins.int,
                 shape: _builtins.str,
                 shape_configs: Sequence['outputs.GetBdsInstancesBdsInstanceKafkaBrokerNodeShapeConfigResult'],
                 subnet_id: _builtins.str):
        """
        :param _builtins.str block_volume_size_in_gbs: The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        :param _builtins.str shape: Shape of the node.
        :param _builtins.str subnet_id: The OCID of the subnet in which the node is to be created.
        """
        pulumi.set(__self__, "block_volume_size_in_gbs", block_volume_size_in_gbs)
        pulumi.set(__self__, "number_of_kafka_nodes", number_of_kafka_nodes)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "shape_configs", shape_configs)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="blockVolumeSizeInGbs")
    def block_volume_size_in_gbs(self) -> _builtins.str:
        """
        The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        """
        return pulumi.get(self, "block_volume_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="numberOfKafkaNodes")
    def number_of_kafka_nodes(self) -> _builtins.int:
        return pulumi.get(self, "number_of_kafka_nodes")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        Shape of the node.
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter(name="shapeConfigs")
    def shape_configs(self) -> Sequence['outputs.GetBdsInstancesBdsInstanceKafkaBrokerNodeShapeConfigResult']:
        return pulumi.get(self, "shape_configs")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The OCID of the subnet in which the node is to be created.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetBdsInstancesBdsInstanceKafkaBrokerNodeShapeConfigResult(dict):
    def __init__(__self__, *,
                 memory_in_gbs: _builtins.int,
                 nvmes: _builtins.int,
                 ocpus: _builtins.int):
        """
        :param _builtins.int memory_in_gbs: The total amount of memory available to the node, in gigabytes.
        :param _builtins.int nvmes: The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        :param _builtins.int ocpus: The total number of OCPUs available to the node.
        """
        pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        pulumi.set(__self__, "nvmes", nvmes)
        pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> _builtins.int:
        """
        The total amount of memory available to the node, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @_builtins.property
    @pulumi.getter
    def nvmes(self) -> _builtins.int:
        """
        The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        """
        return pulumi.get(self, "nvmes")

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> _builtins.int:
        """
        The total number of OCPUs available to the node.
        """
        return pulumi.get(self, "ocpus")


@pulumi.output_type
class GetBdsInstancesBdsInstanceMasterNodeResult(dict):
    def __init__(__self__, *,
                 block_volume_size_in_gbs: _builtins.str,
                 number_of_nodes: _builtins.int,
                 shape: _builtins.str,
                 shape_configs: Sequence['outputs.GetBdsInstancesBdsInstanceMasterNodeShapeConfigResult'],
                 subnet_id: _builtins.str):
        """
        :param _builtins.str block_volume_size_in_gbs: The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        :param _builtins.int number_of_nodes: The number of nodes that form the cluster.
        :param _builtins.str shape: Shape of the node.
        :param _builtins.str subnet_id: The OCID of the subnet in which the node is to be created.
        """
        pulumi.set(__self__, "block_volume_size_in_gbs", block_volume_size_in_gbs)
        pulumi.set(__self__, "number_of_nodes", number_of_nodes)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "shape_configs", shape_configs)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="blockVolumeSizeInGbs")
    def block_volume_size_in_gbs(self) -> _builtins.str:
        """
        The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        """
        return pulumi.get(self, "block_volume_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="numberOfNodes")
    def number_of_nodes(self) -> _builtins.int:
        """
        The number of nodes that form the cluster.
        """
        return pulumi.get(self, "number_of_nodes")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        Shape of the node.
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter(name="shapeConfigs")
    def shape_configs(self) -> Sequence['outputs.GetBdsInstancesBdsInstanceMasterNodeShapeConfigResult']:
        return pulumi.get(self, "shape_configs")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The OCID of the subnet in which the node is to be created.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetBdsInstancesBdsInstanceMasterNodeShapeConfigResult(dict):
    def __init__(__self__, *,
                 memory_in_gbs: _builtins.int,
                 nvmes: _builtins.int,
                 ocpus: _builtins.int):
        """
        :param _builtins.int memory_in_gbs: The total amount of memory available to the node, in gigabytes.
        :param _builtins.int nvmes: The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        :param _builtins.int ocpus: The total number of OCPUs available to the node.
        """
        pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        pulumi.set(__self__, "nvmes", nvmes)
        pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> _builtins.int:
        """
        The total amount of memory available to the node, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @_builtins.property
    @pulumi.getter
    def nvmes(self) -> _builtins.int:
        """
        The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        """
        return pulumi.get(self, "nvmes")

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> _builtins.int:
        """
        The total number of OCPUs available to the node.
        """
        return pulumi.get(self, "ocpus")


@pulumi.output_type
class GetBdsInstancesBdsInstanceNetworkConfigResult(dict):
    def __init__(__self__, *,
                 cidr_block: _builtins.str,
                 is_nat_gateway_required: _builtins.bool):
        """
        :param _builtins.str cidr_block: The CIDR IP address block of the VCN.
        :param _builtins.bool is_nat_gateway_required: A boolean flag whether to configure a NAT gateway.
        """
        pulumi.set(__self__, "cidr_block", cidr_block)
        pulumi.set(__self__, "is_nat_gateway_required", is_nat_gateway_required)

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> _builtins.str:
        """
        The CIDR IP address block of the VCN.
        """
        return pulumi.get(self, "cidr_block")

    @_builtins.property
    @pulumi.getter(name="isNatGatewayRequired")
    def is_nat_gateway_required(self) -> _builtins.bool:
        """
        A boolean flag whether to configure a NAT gateway.
        """
        return pulumi.get(self, "is_nat_gateway_required")


@pulumi.output_type
class GetBdsInstancesBdsInstanceNodeResult(dict):
    def __init__(__self__, *,
                 attached_block_volumes: Sequence['outputs.GetBdsInstancesBdsInstanceNodeAttachedBlockVolumeResult'],
                 availability_domain: _builtins.str,
                 display_name: _builtins.str,
                 fault_domain: _builtins.str,
                 hostname: _builtins.str,
                 image_id: _builtins.str,
                 instance_id: _builtins.str,
                 ip_address: _builtins.str,
                 is_reboot_required: _builtins.bool,
                 local_disks_total_size_in_gbs: _builtins.float,
                 memory_in_gbs: _builtins.int,
                 node_type: _builtins.str,
                 nvmes: _builtins.int,
                 ocpus: _builtins.int,
                 odh_version: _builtins.str,
                 os_version: _builtins.str,
                 shape: _builtins.str,
                 ssh_fingerprint: _builtins.str,
                 state: _builtins.str,
                 subnet_id: _builtins.str,
                 time_created: _builtins.str,
                 time_maintenance_reboot_due: _builtins.str):
        """
        :param Sequence['GetBdsInstancesBdsInstanceNodeAttachedBlockVolumeArgs'] attached_block_volumes: The list of block volumes attached to a given node.
        :param _builtins.str availability_domain: The name of the availability domain in which the node is running.
        :param _builtins.str display_name: A filter to return only resources that match the entire display name given.
        :param _builtins.str fault_domain: The name of the fault domain in which the node is running.
        :param _builtins.str hostname: The fully-qualified hostname (FQDN) of the node.
        :param _builtins.str image_id: The OCID of the image from which the node was created.
        :param _builtins.str instance_id: The OCID of the underlying Oracle Cloud Infrastructure Compute instance.
        :param _builtins.str ip_address: IP address of the node.
        :param _builtins.bool is_reboot_required: Indicates if the node requires a reboot to either reflect the latest os kernel or take actions for maintenance reboot.
        :param _builtins.float local_disks_total_size_in_gbs: The aggregate size of all local disks, in gigabytes. If the instance does not have any local disks, this field is null.
        :param _builtins.int memory_in_gbs: The total amount of memory available to the node, in gigabytes.
        :param _builtins.str node_type: Cluster node type.
        :param _builtins.int nvmes: The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        :param _builtins.int ocpus: The total number of OCPUs available to the node.
        :param _builtins.str odh_version: Version of the ODH (Oracle Distribution including Apache Hadoop) for the node.
        :param _builtins.str os_version: BDS-assigned Operating System version for the node.
        :param _builtins.str shape: Shape of the node.
        :param _builtins.str ssh_fingerprint: The fingerprint of the SSH key used for node access.
        :param _builtins.str state: The state of the cluster.
        :param _builtins.str subnet_id: The OCID of the subnet in which the node is to be created.
        :param _builtins.str time_created: The time the cluster was created, shown as an RFC 3339 formatted datetime string.
        :param _builtins.str time_maintenance_reboot_due: The date and time the instance is expected to be stopped / started, in the format defined by RFC3339.
        """
        pulumi.set(__self__, "attached_block_volumes", attached_block_volumes)
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "fault_domain", fault_domain)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "image_id", image_id)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "is_reboot_required", is_reboot_required)
        pulumi.set(__self__, "local_disks_total_size_in_gbs", local_disks_total_size_in_gbs)
        pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        pulumi.set(__self__, "node_type", node_type)
        pulumi.set(__self__, "nvmes", nvmes)
        pulumi.set(__self__, "ocpus", ocpus)
        pulumi.set(__self__, "odh_version", odh_version)
        pulumi.set(__self__, "os_version", os_version)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "ssh_fingerprint", ssh_fingerprint)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "time_created", time_created)
        pulumi.set(__self__, "time_maintenance_reboot_due", time_maintenance_reboot_due)

    @_builtins.property
    @pulumi.getter(name="attachedBlockVolumes")
    def attached_block_volumes(self) -> Sequence['outputs.GetBdsInstancesBdsInstanceNodeAttachedBlockVolumeResult']:
        """
        The list of block volumes attached to a given node.
        """
        return pulumi.get(self, "attached_block_volumes")

    @_builtins.property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> _builtins.str:
        """
        The name of the availability domain in which the node is running.
        """
        return pulumi.get(self, "availability_domain")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="faultDomain")
    def fault_domain(self) -> _builtins.str:
        """
        The name of the fault domain in which the node is running.
        """
        return pulumi.get(self, "fault_domain")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The fully-qualified hostname (FQDN) of the node.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter(name="imageId")
    def image_id(self) -> _builtins.str:
        """
        The OCID of the image from which the node was created.
        """
        return pulumi.get(self, "image_id")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        """
        The OCID of the underlying Oracle Cloud Infrastructure Compute instance.
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> _builtins.str:
        """
        IP address of the node.
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter(name="isRebootRequired")
    def is_reboot_required(self) -> _builtins.bool:
        """
        Indicates if the node requires a reboot to either reflect the latest os kernel or take actions for maintenance reboot.
        """
        return pulumi.get(self, "is_reboot_required")

    @_builtins.property
    @pulumi.getter(name="localDisksTotalSizeInGbs")
    def local_disks_total_size_in_gbs(self) -> _builtins.float:
        """
        The aggregate size of all local disks, in gigabytes. If the instance does not have any local disks, this field is null.
        """
        return pulumi.get(self, "local_disks_total_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> _builtins.int:
        """
        The total amount of memory available to the node, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @_builtins.property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> _builtins.str:
        """
        Cluster node type.
        """
        return pulumi.get(self, "node_type")

    @_builtins.property
    @pulumi.getter
    def nvmes(self) -> _builtins.int:
        """
        The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        """
        return pulumi.get(self, "nvmes")

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> _builtins.int:
        """
        The total number of OCPUs available to the node.
        """
        return pulumi.get(self, "ocpus")

    @_builtins.property
    @pulumi.getter(name="odhVersion")
    def odh_version(self) -> _builtins.str:
        """
        Version of the ODH (Oracle Distribution including Apache Hadoop) for the node.
        """
        return pulumi.get(self, "odh_version")

    @_builtins.property
    @pulumi.getter(name="osVersion")
    def os_version(self) -> _builtins.str:
        """
        BDS-assigned Operating System version for the node.
        """
        return pulumi.get(self, "os_version")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        Shape of the node.
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter(name="sshFingerprint")
    def ssh_fingerprint(self) -> _builtins.str:
        """
        The fingerprint of the SSH key used for node access.
        """
        return pulumi.get(self, "ssh_fingerprint")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The state of the cluster.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The OCID of the subnet in which the node is to be created.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> _builtins.str:
        """
        The time the cluster was created, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @_builtins.property
    @pulumi.getter(name="timeMaintenanceRebootDue")
    def time_maintenance_reboot_due(self) -> _builtins.str:
        """
        The date and time the instance is expected to be stopped / started, in the format defined by RFC3339.
        """
        return pulumi.get(self, "time_maintenance_reboot_due")


@pulumi.output_type
class GetBdsInstancesBdsInstanceNodeAttachedBlockVolumeResult(dict):
    def __init__(__self__, *,
                 volume_attachment_id: _builtins.str,
                 volume_size_in_gbs: _builtins.str):
        """
        :param _builtins.str volume_attachment_id: The OCID of the volume attachment.
        :param _builtins.str volume_size_in_gbs: The size of the volume in GBs.
        """
        pulumi.set(__self__, "volume_attachment_id", volume_attachment_id)
        pulumi.set(__self__, "volume_size_in_gbs", volume_size_in_gbs)

    @_builtins.property
    @pulumi.getter(name="volumeAttachmentId")
    def volume_attachment_id(self) -> _builtins.str:
        """
        The OCID of the volume attachment.
        """
        return pulumi.get(self, "volume_attachment_id")

    @_builtins.property
    @pulumi.getter(name="volumeSizeInGbs")
    def volume_size_in_gbs(self) -> _builtins.str:
        """
        The size of the volume in GBs.
        """
        return pulumi.get(self, "volume_size_in_gbs")


@pulumi.output_type
class GetBdsInstancesBdsInstanceStartClusterShapeConfigResult(dict):
    def __init__(__self__, *,
                 node_type_shape_configs: Sequence['outputs.GetBdsInstancesBdsInstanceStartClusterShapeConfigNodeTypeShapeConfigResult']):
        pulumi.set(__self__, "node_type_shape_configs", node_type_shape_configs)

    @_builtins.property
    @pulumi.getter(name="nodeTypeShapeConfigs")
    def node_type_shape_configs(self) -> Sequence['outputs.GetBdsInstancesBdsInstanceStartClusterShapeConfigNodeTypeShapeConfigResult']:
        return pulumi.get(self, "node_type_shape_configs")


@pulumi.output_type
class GetBdsInstancesBdsInstanceStartClusterShapeConfigNodeTypeShapeConfigResult(dict):
    def __init__(__self__, *,
                 node_type: _builtins.str,
                 shape: _builtins.str):
        """
        :param _builtins.str node_type: Cluster node type.
        :param _builtins.str shape: Shape of the node.
        """
        pulumi.set(__self__, "node_type", node_type)
        pulumi.set(__self__, "shape", shape)

    @_builtins.property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> _builtins.str:
        """
        Cluster node type.
        """
        return pulumi.get(self, "node_type")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        Shape of the node.
        """
        return pulumi.get(self, "shape")


@pulumi.output_type
class GetBdsInstancesBdsInstanceUtilNodeResult(dict):
    def __init__(__self__, *,
                 block_volume_size_in_gbs: _builtins.str,
                 number_of_nodes: _builtins.int,
                 shape: _builtins.str,
                 shape_configs: Sequence['outputs.GetBdsInstancesBdsInstanceUtilNodeShapeConfigResult'],
                 subnet_id: _builtins.str):
        """
        :param _builtins.str block_volume_size_in_gbs: The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        :param _builtins.int number_of_nodes: The number of nodes that form the cluster.
        :param _builtins.str shape: Shape of the node.
        :param _builtins.str subnet_id: The OCID of the subnet in which the node is to be created.
        """
        pulumi.set(__self__, "block_volume_size_in_gbs", block_volume_size_in_gbs)
        pulumi.set(__self__, "number_of_nodes", number_of_nodes)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "shape_configs", shape_configs)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="blockVolumeSizeInGbs")
    def block_volume_size_in_gbs(self) -> _builtins.str:
        """
        The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        """
        return pulumi.get(self, "block_volume_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="numberOfNodes")
    def number_of_nodes(self) -> _builtins.int:
        """
        The number of nodes that form the cluster.
        """
        return pulumi.get(self, "number_of_nodes")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        Shape of the node.
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter(name="shapeConfigs")
    def shape_configs(self) -> Sequence['outputs.GetBdsInstancesBdsInstanceUtilNodeShapeConfigResult']:
        return pulumi.get(self, "shape_configs")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The OCID of the subnet in which the node is to be created.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetBdsInstancesBdsInstanceUtilNodeShapeConfigResult(dict):
    def __init__(__self__, *,
                 memory_in_gbs: _builtins.int,
                 nvmes: _builtins.int,
                 ocpus: _builtins.int):
        """
        :param _builtins.int memory_in_gbs: The total amount of memory available to the node, in gigabytes.
        :param _builtins.int nvmes: The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        :param _builtins.int ocpus: The total number of OCPUs available to the node.
        """
        pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        pulumi.set(__self__, "nvmes", nvmes)
        pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> _builtins.int:
        """
        The total amount of memory available to the node, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @_builtins.property
    @pulumi.getter
    def nvmes(self) -> _builtins.int:
        """
        The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        """
        return pulumi.get(self, "nvmes")

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> _builtins.int:
        """
        The total number of OCPUs available to the node.
        """
        return pulumi.get(self, "ocpus")


@pulumi.output_type
class GetBdsInstancesBdsInstanceWorkerNodeResult(dict):
    def __init__(__self__, *,
                 block_volume_size_in_gbs: _builtins.str,
                 number_of_nodes: _builtins.int,
                 shape: _builtins.str,
                 shape_configs: Sequence['outputs.GetBdsInstancesBdsInstanceWorkerNodeShapeConfigResult'],
                 subnet_id: _builtins.str):
        """
        :param _builtins.str block_volume_size_in_gbs: The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        :param _builtins.int number_of_nodes: The number of nodes that form the cluster.
        :param _builtins.str shape: Shape of the node.
        :param _builtins.str subnet_id: The OCID of the subnet in which the node is to be created.
        """
        pulumi.set(__self__, "block_volume_size_in_gbs", block_volume_size_in_gbs)
        pulumi.set(__self__, "number_of_nodes", number_of_nodes)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "shape_configs", shape_configs)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="blockVolumeSizeInGbs")
    def block_volume_size_in_gbs(self) -> _builtins.str:
        """
        The size of block volume in GB that needs to be attached to a given node. All the necessary details needed for attachment are managed by service itself.
        """
        return pulumi.get(self, "block_volume_size_in_gbs")

    @_builtins.property
    @pulumi.getter(name="numberOfNodes")
    def number_of_nodes(self) -> _builtins.int:
        """
        The number of nodes that form the cluster.
        """
        return pulumi.get(self, "number_of_nodes")

    @_builtins.property
    @pulumi.getter
    def shape(self) -> _builtins.str:
        """
        Shape of the node.
        """
        return pulumi.get(self, "shape")

    @_builtins.property
    @pulumi.getter(name="shapeConfigs")
    def shape_configs(self) -> Sequence['outputs.GetBdsInstancesBdsInstanceWorkerNodeShapeConfigResult']:
        return pulumi.get(self, "shape_configs")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The OCID of the subnet in which the node is to be created.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetBdsInstancesBdsInstanceWorkerNodeShapeConfigResult(dict):
    def __init__(__self__, *,
                 memory_in_gbs: _builtins.int,
                 nvmes: _builtins.int,
                 ocpus: _builtins.int):
        """
        :param _builtins.int memory_in_gbs: The total amount of memory available to the node, in gigabytes.
        :param _builtins.int nvmes: The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        :param _builtins.int ocpus: The total number of OCPUs available to the node.
        """
        pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        pulumi.set(__self__, "nvmes", nvmes)
        pulumi.set(__self__, "ocpus", ocpus)

    @_builtins.property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> _builtins.int:
        """
        The total amount of memory available to the node, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @_builtins.property
    @pulumi.getter
    def nvmes(self) -> _builtins.int:
        """
        The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        """
        return pulumi.get(self, "nvmes")

    @_builtins.property
    @pulumi.getter
    def ocpus(self) -> _builtins.int:
        """
        The total number of OCPUs available to the node.
        """
        return pulumi.get(self, "ocpus")


@pulumi.output_type
class GetBdsInstancesFilterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str],
                 regex: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "regex")


