# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AdhocQueryAdhocQueryDetailsArgs',
    'AdhocQueryAdhocQueryDetailsArgsDict',
    'AdhocQueryAdhocQueryDetailsAdhocQueryResourceArgs',
    'AdhocQueryAdhocQueryDetailsAdhocQueryResourceArgsDict',
    'AdhocQueryAdhocQueryRegionalDetailArgs',
    'AdhocQueryAdhocQueryRegionalDetailArgsDict',
    'CloudGuardDataSourceDataSourceDetailsArgs',
    'CloudGuardDataSourceDataSourceDetailsArgsDict',
    'CloudGuardDataSourceDataSourceDetailsLoggingQueryDetailsArgs',
    'CloudGuardDataSourceDataSourceDetailsLoggingQueryDetailsArgsDict',
    'CloudGuardDataSourceDataSourceDetailsQueryStartTimeArgs',
    'CloudGuardDataSourceDataSourceDetailsQueryStartTimeArgsDict',
    'CloudGuardDataSourceDataSourceDetailsScheduledQueryScopeDetailArgs',
    'CloudGuardDataSourceDataSourceDetailsScheduledQueryScopeDetailArgsDict',
    'CloudGuardDataSourceDataSourceDetectorMappingInfoArgs',
    'CloudGuardDataSourceDataSourceDetectorMappingInfoArgsDict',
    'CloudGuardDataSourceRegionStatusDetailArgs',
    'CloudGuardDataSourceRegionStatusDetailArgsDict',
    'DataMaskRuleTargetSelectedArgs',
    'DataMaskRuleTargetSelectedArgsDict',
    'DetectorRecipeDetectorRuleArgs',
    'DetectorRecipeDetectorRuleArgsDict',
    'DetectorRecipeDetectorRuleCandidateResponderRuleArgs',
    'DetectorRecipeDetectorRuleCandidateResponderRuleArgsDict',
    'DetectorRecipeDetectorRuleDetailsArgs',
    'DetectorRecipeDetectorRuleDetailsArgsDict',
    'DetectorRecipeDetectorRuleDetailsConfigurationArgs',
    'DetectorRecipeDetectorRuleDetailsConfigurationArgsDict',
    'DetectorRecipeDetectorRuleDetailsConfigurationValueArgs',
    'DetectorRecipeDetectorRuleDetailsConfigurationValueArgsDict',
    'DetectorRecipeDetectorRuleDetailsEntitiesMappingArgs',
    'DetectorRecipeDetectorRuleDetailsEntitiesMappingArgsDict',
    'DetectorRecipeDetectorRuleEntitiesMappingArgs',
    'DetectorRecipeDetectorRuleEntitiesMappingArgsDict',
    'DetectorRecipeEffectiveDetectorRuleArgs',
    'DetectorRecipeEffectiveDetectorRuleArgsDict',
    'DetectorRecipeEffectiveDetectorRuleCandidateResponderRuleArgs',
    'DetectorRecipeEffectiveDetectorRuleCandidateResponderRuleArgsDict',
    'DetectorRecipeEffectiveDetectorRuleDetailArgs',
    'DetectorRecipeEffectiveDetectorRuleDetailArgsDict',
    'DetectorRecipeEffectiveDetectorRuleDetailConfigurationArgs',
    'DetectorRecipeEffectiveDetectorRuleDetailConfigurationArgsDict',
    'DetectorRecipeEffectiveDetectorRuleDetailConfigurationValueArgs',
    'DetectorRecipeEffectiveDetectorRuleDetailConfigurationValueArgsDict',
    'DetectorRecipeEffectiveDetectorRuleDetailEntitiesMappingArgs',
    'DetectorRecipeEffectiveDetectorRuleDetailEntitiesMappingArgsDict',
    'DetectorRecipeEffectiveDetectorRuleEntitiesMappingArgs',
    'DetectorRecipeEffectiveDetectorRuleEntitiesMappingArgsDict',
    'ResponderRecipeEffectiveResponderRuleArgs',
    'ResponderRecipeEffectiveResponderRuleArgsDict',
    'ResponderRecipeEffectiveResponderRuleDetailArgs',
    'ResponderRecipeEffectiveResponderRuleDetailArgsDict',
    'ResponderRecipeEffectiveResponderRuleDetailConfigurationArgs',
    'ResponderRecipeEffectiveResponderRuleDetailConfigurationArgsDict',
    'ResponderRecipeResponderRuleArgs',
    'ResponderRecipeResponderRuleArgsDict',
    'ResponderRecipeResponderRuleDetailsArgs',
    'ResponderRecipeResponderRuleDetailsArgsDict',
    'ResponderRecipeResponderRuleDetailsConfigurationArgs',
    'ResponderRecipeResponderRuleDetailsConfigurationArgsDict',
    'TargetTargetDetailArgs',
    'TargetTargetDetailArgsDict',
    'TargetTargetDetailTargetSecurityZoneRecipeArgs',
    'TargetTargetDetailTargetSecurityZoneRecipeArgsDict',
    'TargetTargetDetectorRecipeArgs',
    'TargetTargetDetectorRecipeArgsDict',
    'TargetTargetDetectorRecipeDetectorRuleArgs',
    'TargetTargetDetectorRecipeDetectorRuleArgsDict',
    'TargetTargetDetectorRecipeDetectorRuleDetailsArgs',
    'TargetTargetDetectorRecipeDetectorRuleDetailsArgsDict',
    'TargetTargetDetectorRecipeDetectorRuleDetailsConditionGroupArgs',
    'TargetTargetDetectorRecipeDetectorRuleDetailsConditionGroupArgsDict',
    'TargetTargetDetectorRecipeDetectorRuleDetailsConfigurationArgs',
    'TargetTargetDetectorRecipeDetectorRuleDetailsConfigurationArgsDict',
    'TargetTargetDetectorRecipeDetectorRuleDetailsConfigurationValueArgs',
    'TargetTargetDetectorRecipeDetectorRuleDetailsConfigurationValueArgsDict',
    'TargetTargetDetectorRecipeDetectorRuleEntitiesMappingArgs',
    'TargetTargetDetectorRecipeDetectorRuleEntitiesMappingArgsDict',
    'TargetTargetDetectorRecipeEffectiveDetectorRuleArgs',
    'TargetTargetDetectorRecipeEffectiveDetectorRuleArgsDict',
    'TargetTargetDetectorRecipeEffectiveDetectorRuleDetailArgs',
    'TargetTargetDetectorRecipeEffectiveDetectorRuleDetailArgsDict',
    'TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroupArgs',
    'TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroupArgsDict',
    'TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationArgs',
    'TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationArgsDict',
    'TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueArgs',
    'TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueArgsDict',
    'TargetTargetDetectorRecipeEffectiveDetectorRuleEntitiesMappingArgs',
    'TargetTargetDetectorRecipeEffectiveDetectorRuleEntitiesMappingArgsDict',
    'TargetTargetResponderRecipeArgs',
    'TargetTargetResponderRecipeArgsDict',
    'TargetTargetResponderRecipeEffectiveResponderRuleArgs',
    'TargetTargetResponderRecipeEffectiveResponderRuleArgsDict',
    'TargetTargetResponderRecipeEffectiveResponderRuleDetailArgs',
    'TargetTargetResponderRecipeEffectiveResponderRuleDetailArgsDict',
    'TargetTargetResponderRecipeEffectiveResponderRuleDetailConfigurationArgs',
    'TargetTargetResponderRecipeEffectiveResponderRuleDetailConfigurationArgsDict',
    'TargetTargetResponderRecipeResponderRuleArgs',
    'TargetTargetResponderRecipeResponderRuleArgsDict',
    'TargetTargetResponderRecipeResponderRuleDetailsArgs',
    'TargetTargetResponderRecipeResponderRuleDetailsArgsDict',
    'TargetTargetResponderRecipeResponderRuleDetailsConfigurationArgs',
    'TargetTargetResponderRecipeResponderRuleDetailsConfigurationArgsDict',
    'GetAdhocQueriesFilterArgs',
    'GetAdhocQueriesFilterArgsDict',
    'GetDataMaskRulesFilterArgs',
    'GetDataMaskRulesFilterArgsDict',
    'GetDataSourceEventsFilterArgs',
    'GetDataSourceEventsFilterArgsDict',
    'GetDataSourcesFilterArgs',
    'GetDataSourcesFilterArgsDict',
    'GetDetectorRecipesFilterArgs',
    'GetDetectorRecipesFilterArgsDict',
    'GetGuardTargetsFilterArgs',
    'GetGuardTargetsFilterArgsDict',
    'GetManagedListsFilterArgs',
    'GetManagedListsFilterArgsDict',
    'GetProblemEntitiesFilterArgs',
    'GetProblemEntitiesFilterArgsDict',
    'GetResponderRecipesFilterArgs',
    'GetResponderRecipesFilterArgsDict',
    'GetSavedQueriesFilterArgs',
    'GetSavedQueriesFilterArgsDict',
    'GetSecurityPoliciesFilterArgs',
    'GetSecurityPoliciesFilterArgsDict',
    'GetSecurityRecipesFilterArgs',
    'GetSecurityRecipesFilterArgsDict',
    'GetSecurityZonesFilterArgs',
    'GetSecurityZonesFilterArgsDict',
    'GetWlpAgentsFilterArgs',
    'GetWlpAgentsFilterArgsDict',
]

MYPY = False

if not MYPY:
    class AdhocQueryAdhocQueryDetailsArgsDict(TypedDict):
        adhoc_query_resources: pulumi.Input[Sequence[pulumi.Input['AdhocQueryAdhocQueryDetailsAdhocQueryResourceArgsDict']]]
        """
        Target information in which adhoc query will be run
        """
        query: pulumi.Input[str]
        """
        The adhoc query expression that is run
        """
elif False:
    AdhocQueryAdhocQueryDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdhocQueryAdhocQueryDetailsArgs:
    def __init__(__self__, *,
                 adhoc_query_resources: pulumi.Input[Sequence[pulumi.Input['AdhocQueryAdhocQueryDetailsAdhocQueryResourceArgs']]],
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AdhocQueryAdhocQueryDetailsAdhocQueryResourceArgs']]] adhoc_query_resources: Target information in which adhoc query will be run
        :param pulumi.Input[str] query: The adhoc query expression that is run
        """
        pulumi.set(__self__, "adhoc_query_resources", adhoc_query_resources)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter(name="adhocQueryResources")
    def adhoc_query_resources(self) -> pulumi.Input[Sequence[pulumi.Input['AdhocQueryAdhocQueryDetailsAdhocQueryResourceArgs']]]:
        """
        Target information in which adhoc query will be run
        """
        return pulumi.get(self, "adhoc_query_resources")

    @adhoc_query_resources.setter
    def adhoc_query_resources(self, value: pulumi.Input[Sequence[pulumi.Input['AdhocQueryAdhocQueryDetailsAdhocQueryResourceArgs']]]):
        pulumi.set(self, "adhoc_query_resources", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The adhoc query expression that is run
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


if not MYPY:
    class AdhocQueryAdhocQueryDetailsAdhocQueryResourceArgsDict(TypedDict):
        region: NotRequired[pulumi.Input[str]]
        """
        Region in which adhoc query needs to be run
        """
        resource_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of OCIDs on which query needs to be run
        """
        resource_type: NotRequired[pulumi.Input[str]]
        """
        Type of resource
        """
elif False:
    AdhocQueryAdhocQueryDetailsAdhocQueryResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdhocQueryAdhocQueryDetailsAdhocQueryResourceArgs:
    def __init__(__self__, *,
                 region: Optional[pulumi.Input[str]] = None,
                 resource_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 resource_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] region: Region in which adhoc query needs to be run
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_ids: List of OCIDs on which query needs to be run
        :param pulumi.Input[str] resource_type: Type of resource
        """
        if region is not None:
            pulumi.set(__self__, "region", region)
        if resource_ids is not None:
            pulumi.set(__self__, "resource_ids", resource_ids)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Region in which adhoc query needs to be run
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="resourceIds")
    def resource_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of OCIDs on which query needs to be run
        """
        return pulumi.get(self, "resource_ids")

    @resource_ids.setter
    def resource_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_ids", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of resource
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_type", value)


if not MYPY:
    class AdhocQueryAdhocQueryRegionalDetailArgsDict(TypedDict):
        expected_count: NotRequired[pulumi.Input[str]]
        """
        Expected number of instances on which query should run
        """
        expired_count: NotRequired[pulumi.Input[str]]
        """
        Number of instances on which query expired
        """
        failed_count: NotRequired[pulumi.Input[str]]
        """
        Number of instances on which query failed
        """
        region: NotRequired[pulumi.Input[str]]
        """
        Region name
        """
        regional_error: NotRequired[pulumi.Input[str]]
        """
        error message to show if adhoc query fails in a region
        """
        regional_status: NotRequired[pulumi.Input[str]]
        """
        adhoc query status of the region
        """
        succeeded_count: NotRequired[pulumi.Input[str]]
        """
        Number of instances on which query succeeded
        """
elif False:
    AdhocQueryAdhocQueryRegionalDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdhocQueryAdhocQueryRegionalDetailArgs:
    def __init__(__self__, *,
                 expected_count: Optional[pulumi.Input[str]] = None,
                 expired_count: Optional[pulumi.Input[str]] = None,
                 failed_count: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 regional_error: Optional[pulumi.Input[str]] = None,
                 regional_status: Optional[pulumi.Input[str]] = None,
                 succeeded_count: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] expected_count: Expected number of instances on which query should run
        :param pulumi.Input[str] expired_count: Number of instances on which query expired
        :param pulumi.Input[str] failed_count: Number of instances on which query failed
        :param pulumi.Input[str] region: Region name
        :param pulumi.Input[str] regional_error: error message to show if adhoc query fails in a region
        :param pulumi.Input[str] regional_status: adhoc query status of the region
        :param pulumi.Input[str] succeeded_count: Number of instances on which query succeeded
        """
        if expected_count is not None:
            pulumi.set(__self__, "expected_count", expected_count)
        if expired_count is not None:
            pulumi.set(__self__, "expired_count", expired_count)
        if failed_count is not None:
            pulumi.set(__self__, "failed_count", failed_count)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if regional_error is not None:
            pulumi.set(__self__, "regional_error", regional_error)
        if regional_status is not None:
            pulumi.set(__self__, "regional_status", regional_status)
        if succeeded_count is not None:
            pulumi.set(__self__, "succeeded_count", succeeded_count)

    @property
    @pulumi.getter(name="expectedCount")
    def expected_count(self) -> Optional[pulumi.Input[str]]:
        """
        Expected number of instances on which query should run
        """
        return pulumi.get(self, "expected_count")

    @expected_count.setter
    def expected_count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expected_count", value)

    @property
    @pulumi.getter(name="expiredCount")
    def expired_count(self) -> Optional[pulumi.Input[str]]:
        """
        Number of instances on which query expired
        """
        return pulumi.get(self, "expired_count")

    @expired_count.setter
    def expired_count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expired_count", value)

    @property
    @pulumi.getter(name="failedCount")
    def failed_count(self) -> Optional[pulumi.Input[str]]:
        """
        Number of instances on which query failed
        """
        return pulumi.get(self, "failed_count")

    @failed_count.setter
    def failed_count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "failed_count", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Region name
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="regionalError")
    def regional_error(self) -> Optional[pulumi.Input[str]]:
        """
        error message to show if adhoc query fails in a region
        """
        return pulumi.get(self, "regional_error")

    @regional_error.setter
    def regional_error(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regional_error", value)

    @property
    @pulumi.getter(name="regionalStatus")
    def regional_status(self) -> Optional[pulumi.Input[str]]:
        """
        adhoc query status of the region
        """
        return pulumi.get(self, "regional_status")

    @regional_status.setter
    def regional_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regional_status", value)

    @property
    @pulumi.getter(name="succeededCount")
    def succeeded_count(self) -> Optional[pulumi.Input[str]]:
        """
        Number of instances on which query succeeded
        """
        return pulumi.get(self, "succeeded_count")

    @succeeded_count.setter
    def succeeded_count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "succeeded_count", value)


if not MYPY:
    class CloudGuardDataSourceDataSourceDetailsArgsDict(TypedDict):
        data_source_feed_provider: pulumi.Input[str]
        """
        (Updatable) Type of data source feed provider (LoggingQuery)
        """
        additional_entities_count: NotRequired[pulumi.Input[int]]
        """
        (Updatable) The additional entities count used for data source query
        """
        description: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Description text for the query
        """
        interval_in_minutes: NotRequired[pulumi.Input[int]]
        """
        (Updatable) Interval in minutes that query is run periodically.
        """
        interval_in_seconds: NotRequired[pulumi.Input[int]]
        """
        (Updatable) Interval in minutes which query is run periodically.
        """
        logging_query_details: NotRequired[pulumi.Input['CloudGuardDataSourceDataSourceDetailsLoggingQueryDetailsArgsDict']]
        """
        (Updatable) Details for a logging query for a data source.
        """
        logging_query_type: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Type of logging query for data source (Sighting/Insight)
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Operator used in data source
        """
        query: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The continuous query expression that is run periodically.
        """
        query_start_time: NotRequired[pulumi.Input['CloudGuardDataSourceDataSourceDetailsQueryStartTimeArgsDict']]
        """
        (Updatable) Start policy for continuous query
        """
        regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (Updatable) List of logging query regions
        """
        scheduled_query_scope_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['CloudGuardDataSourceDataSourceDetailsScheduledQueryScopeDetailArgsDict']]]]
        """
        (Updatable) Target information in which scheduled query will be run
        """
        threshold: NotRequired[pulumi.Input[int]]
        """
        (Updatable) The integer value that must be exceeded, fall below or equal to (depending on the operator), for the query result to trigger an event
        """
elif False:
    CloudGuardDataSourceDataSourceDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudGuardDataSourceDataSourceDetailsArgs:
    def __init__(__self__, *,
                 data_source_feed_provider: pulumi.Input[str],
                 additional_entities_count: Optional[pulumi.Input[int]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 interval_in_minutes: Optional[pulumi.Input[int]] = None,
                 interval_in_seconds: Optional[pulumi.Input[int]] = None,
                 logging_query_details: Optional[pulumi.Input['CloudGuardDataSourceDataSourceDetailsLoggingQueryDetailsArgs']] = None,
                 logging_query_type: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 query: Optional[pulumi.Input[str]] = None,
                 query_start_time: Optional[pulumi.Input['CloudGuardDataSourceDataSourceDetailsQueryStartTimeArgs']] = None,
                 regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 scheduled_query_scope_details: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardDataSourceDataSourceDetailsScheduledQueryScopeDetailArgs']]]] = None,
                 threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] data_source_feed_provider: (Updatable) Type of data source feed provider (LoggingQuery)
        :param pulumi.Input[int] additional_entities_count: (Updatable) The additional entities count used for data source query
        :param pulumi.Input[str] description: (Updatable) Description text for the query
        :param pulumi.Input[int] interval_in_minutes: (Updatable) Interval in minutes that query is run periodically.
        :param pulumi.Input[int] interval_in_seconds: (Updatable) Interval in minutes which query is run periodically.
        :param pulumi.Input['CloudGuardDataSourceDataSourceDetailsLoggingQueryDetailsArgs'] logging_query_details: (Updatable) Details for a logging query for a data source.
        :param pulumi.Input[str] logging_query_type: (Updatable) Type of logging query for data source (Sighting/Insight)
        :param pulumi.Input[str] operator: (Updatable) Operator used in data source
        :param pulumi.Input[str] query: (Updatable) The continuous query expression that is run periodically.
        :param pulumi.Input['CloudGuardDataSourceDataSourceDetailsQueryStartTimeArgs'] query_start_time: (Updatable) Start policy for continuous query
        :param pulumi.Input[Sequence[pulumi.Input[str]]] regions: (Updatable) List of logging query regions
        :param pulumi.Input[Sequence[pulumi.Input['CloudGuardDataSourceDataSourceDetailsScheduledQueryScopeDetailArgs']]] scheduled_query_scope_details: (Updatable) Target information in which scheduled query will be run
        :param pulumi.Input[int] threshold: (Updatable) The integer value that must be exceeded, fall below or equal to (depending on the operator), for the query result to trigger an event
        """
        pulumi.set(__self__, "data_source_feed_provider", data_source_feed_provider)
        if additional_entities_count is not None:
            pulumi.set(__self__, "additional_entities_count", additional_entities_count)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if interval_in_minutes is not None:
            pulumi.set(__self__, "interval_in_minutes", interval_in_minutes)
        if interval_in_seconds is not None:
            pulumi.set(__self__, "interval_in_seconds", interval_in_seconds)
        if logging_query_details is not None:
            pulumi.set(__self__, "logging_query_details", logging_query_details)
        if logging_query_type is not None:
            pulumi.set(__self__, "logging_query_type", logging_query_type)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if query_start_time is not None:
            pulumi.set(__self__, "query_start_time", query_start_time)
        if regions is not None:
            pulumi.set(__self__, "regions", regions)
        if scheduled_query_scope_details is not None:
            pulumi.set(__self__, "scheduled_query_scope_details", scheduled_query_scope_details)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="dataSourceFeedProvider")
    def data_source_feed_provider(self) -> pulumi.Input[str]:
        """
        (Updatable) Type of data source feed provider (LoggingQuery)
        """
        return pulumi.get(self, "data_source_feed_provider")

    @data_source_feed_provider.setter
    def data_source_feed_provider(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source_feed_provider", value)

    @property
    @pulumi.getter(name="additionalEntitiesCount")
    def additional_entities_count(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The additional entities count used for data source query
        """
        return pulumi.get(self, "additional_entities_count")

    @additional_entities_count.setter
    def additional_entities_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "additional_entities_count", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Description text for the query
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="intervalInMinutes")
    def interval_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Interval in minutes that query is run periodically.
        """
        return pulumi.get(self, "interval_in_minutes")

    @interval_in_minutes.setter
    def interval_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval_in_minutes", value)

    @property
    @pulumi.getter(name="intervalInSeconds")
    def interval_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Interval in minutes which query is run periodically.
        """
        return pulumi.get(self, "interval_in_seconds")

    @interval_in_seconds.setter
    def interval_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval_in_seconds", value)

    @property
    @pulumi.getter(name="loggingQueryDetails")
    def logging_query_details(self) -> Optional[pulumi.Input['CloudGuardDataSourceDataSourceDetailsLoggingQueryDetailsArgs']]:
        """
        (Updatable) Details for a logging query for a data source.
        """
        return pulumi.get(self, "logging_query_details")

    @logging_query_details.setter
    def logging_query_details(self, value: Optional[pulumi.Input['CloudGuardDataSourceDataSourceDetailsLoggingQueryDetailsArgs']]):
        pulumi.set(self, "logging_query_details", value)

    @property
    @pulumi.getter(name="loggingQueryType")
    def logging_query_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Type of logging query for data source (Sighting/Insight)
        """
        return pulumi.get(self, "logging_query_type")

    @logging_query_type.setter
    def logging_query_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logging_query_type", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Operator used in data source
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The continuous query expression that is run periodically.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="queryStartTime")
    def query_start_time(self) -> Optional[pulumi.Input['CloudGuardDataSourceDataSourceDetailsQueryStartTimeArgs']]:
        """
        (Updatable) Start policy for continuous query
        """
        return pulumi.get(self, "query_start_time")

    @query_start_time.setter
    def query_start_time(self, value: Optional[pulumi.Input['CloudGuardDataSourceDataSourceDetailsQueryStartTimeArgs']]):
        pulumi.set(self, "query_start_time", value)

    @property
    @pulumi.getter
    def regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) List of logging query regions
        """
        return pulumi.get(self, "regions")

    @regions.setter
    def regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "regions", value)

    @property
    @pulumi.getter(name="scheduledQueryScopeDetails")
    def scheduled_query_scope_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardDataSourceDataSourceDetailsScheduledQueryScopeDetailArgs']]]]:
        """
        (Updatable) Target information in which scheduled query will be run
        """
        return pulumi.get(self, "scheduled_query_scope_details")

    @scheduled_query_scope_details.setter
    def scheduled_query_scope_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardDataSourceDataSourceDetailsScheduledQueryScopeDetailArgs']]]]):
        pulumi.set(self, "scheduled_query_scope_details", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The integer value that must be exceeded, fall below or equal to (depending on the operator), for the query result to trigger an event
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class CloudGuardDataSourceDataSourceDetailsLoggingQueryDetailsArgsDict(TypedDict):
        logging_query_type: pulumi.Input[str]
        """
        (Updatable) Logging query type for data source
        """
        key_entities_count: NotRequired[pulumi.Input[int]]
        """
        (Updatable) The key entities count used for data source query
        """
elif False:
    CloudGuardDataSourceDataSourceDetailsLoggingQueryDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudGuardDataSourceDataSourceDetailsLoggingQueryDetailsArgs:
    def __init__(__self__, *,
                 logging_query_type: pulumi.Input[str],
                 key_entities_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] logging_query_type: (Updatable) Logging query type for data source
        :param pulumi.Input[int] key_entities_count: (Updatable) The key entities count used for data source query
        """
        pulumi.set(__self__, "logging_query_type", logging_query_type)
        if key_entities_count is not None:
            pulumi.set(__self__, "key_entities_count", key_entities_count)

    @property
    @pulumi.getter(name="loggingQueryType")
    def logging_query_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Logging query type for data source
        """
        return pulumi.get(self, "logging_query_type")

    @logging_query_type.setter
    def logging_query_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "logging_query_type", value)

    @property
    @pulumi.getter(name="keyEntitiesCount")
    def key_entities_count(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The key entities count used for data source query
        """
        return pulumi.get(self, "key_entities_count")

    @key_entities_count.setter
    def key_entities_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "key_entities_count", value)


if not MYPY:
    class CloudGuardDataSourceDataSourceDetailsQueryStartTimeArgsDict(TypedDict):
        start_policy_type: pulumi.Input[str]
        """
        (Updatable) Start policy delay timing
        """
        query_start_time: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Time when the query can start. If not specified it can start immediately
        """
elif False:
    CloudGuardDataSourceDataSourceDetailsQueryStartTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudGuardDataSourceDataSourceDetailsQueryStartTimeArgs:
    def __init__(__self__, *,
                 start_policy_type: pulumi.Input[str],
                 query_start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] start_policy_type: (Updatable) Start policy delay timing
        :param pulumi.Input[str] query_start_time: (Updatable) Time when the query can start. If not specified it can start immediately
        """
        pulumi.set(__self__, "start_policy_type", start_policy_type)
        if query_start_time is not None:
            pulumi.set(__self__, "query_start_time", query_start_time)

    @property
    @pulumi.getter(name="startPolicyType")
    def start_policy_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Start policy delay timing
        """
        return pulumi.get(self, "start_policy_type")

    @start_policy_type.setter
    def start_policy_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_policy_type", value)

    @property
    @pulumi.getter(name="queryStartTime")
    def query_start_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Time when the query can start. If not specified it can start immediately
        """
        return pulumi.get(self, "query_start_time")

    @query_start_time.setter
    def query_start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_start_time", value)


if not MYPY:
    class CloudGuardDataSourceDataSourceDetailsScheduledQueryScopeDetailArgsDict(TypedDict):
        region: NotRequired[pulumi.Input[str]]
        """
        (Updatable) region on which scheduled query needs to be run
        """
        resource_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (Updatable) List of OCIDs on scheduled query needs to run
        """
        resource_type: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Type of resource
        """
elif False:
    CloudGuardDataSourceDataSourceDetailsScheduledQueryScopeDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudGuardDataSourceDataSourceDetailsScheduledQueryScopeDetailArgs:
    def __init__(__self__, *,
                 region: Optional[pulumi.Input[str]] = None,
                 resource_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 resource_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] region: (Updatable) region on which scheduled query needs to be run
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_ids: (Updatable) List of OCIDs on scheduled query needs to run
        :param pulumi.Input[str] resource_type: (Updatable) Type of resource
        """
        if region is not None:
            pulumi.set(__self__, "region", region)
        if resource_ids is not None:
            pulumi.set(__self__, "resource_ids", resource_ids)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) region on which scheduled query needs to be run
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="resourceIds")
    def resource_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) List of OCIDs on scheduled query needs to run
        """
        return pulumi.get(self, "resource_ids")

    @resource_ids.setter
    def resource_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_ids", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Type of resource
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_type", value)


if not MYPY:
    class CloudGuardDataSourceDataSourceDetectorMappingInfoArgsDict(TypedDict):
        detector_recipe_id: NotRequired[pulumi.Input[str]]
        """
        ID of the detector recipe attached to the data source
        """
        detector_rule_id: NotRequired[pulumi.Input[str]]
        """
        ID of the detector rule attached to the data source
        """
elif False:
    CloudGuardDataSourceDataSourceDetectorMappingInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudGuardDataSourceDataSourceDetectorMappingInfoArgs:
    def __init__(__self__, *,
                 detector_recipe_id: Optional[pulumi.Input[str]] = None,
                 detector_rule_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] detector_recipe_id: ID of the detector recipe attached to the data source
        :param pulumi.Input[str] detector_rule_id: ID of the detector rule attached to the data source
        """
        if detector_recipe_id is not None:
            pulumi.set(__self__, "detector_recipe_id", detector_recipe_id)
        if detector_rule_id is not None:
            pulumi.set(__self__, "detector_rule_id", detector_rule_id)

    @property
    @pulumi.getter(name="detectorRecipeId")
    def detector_recipe_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the detector recipe attached to the data source
        """
        return pulumi.get(self, "detector_recipe_id")

    @detector_recipe_id.setter
    def detector_recipe_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detector_recipe_id", value)

    @property
    @pulumi.getter(name="detectorRuleId")
    def detector_rule_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the detector rule attached to the data source
        """
        return pulumi.get(self, "detector_rule_id")

    @detector_rule_id.setter
    def detector_rule_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detector_rule_id", value)


if not MYPY:
    class CloudGuardDataSourceRegionStatusDetailArgsDict(TypedDict):
        region: NotRequired[pulumi.Input[str]]
        """
        Data source replication region
        """
        status: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Enablement status of data source.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    CloudGuardDataSourceRegionStatusDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudGuardDataSourceRegionStatusDetailArgs:
    def __init__(__self__, *,
                 region: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] region: Data source replication region
        :param pulumi.Input[str] status: (Updatable) Enablement status of data source.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if region is not None:
            pulumi.set(__self__, "region", region)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Data source replication region
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Enablement status of data source.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class DataMaskRuleTargetSelectedArgsDict(TypedDict):
        kind: pulumi.Input[str]
        """
        (Updatable) Kind of target selection to be used
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (Updatable) Types of targets


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    DataMaskRuleTargetSelectedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataMaskRuleTargetSelectedArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] kind: (Updatable) Kind of target selection to be used
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: (Updatable) Types of targets
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "kind", kind)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        (Updatable) Kind of target selection to be used
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) Types of targets


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DetectorRecipeDetectorRuleArgsDict(TypedDict):
        details: pulumi.Input['DetectorRecipeDetectorRuleDetailsArgsDict']
        """
        (Updatable) Parameters to be updated for a detector rule within a detector recipe.
        """
        detector_rule_id: pulumi.Input[str]
        """
        (Updatable) Detector recipe rule ID
        """
        candidate_responder_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeDetectorRuleCandidateResponderRuleArgsDict']]]]
        """
        List of responder rules that can be used to remediate this detector rule
        """
        data_source_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the attached data source
        """
        description: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Detector recipe description.

        Avoid entering confidential information.
        """
        detector: NotRequired[pulumi.Input[str]]
        """
        Detector for the rule
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Detector recipe display name.

        Avoid entering confidential information.
        """
        entities_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeDetectorRuleEntitiesMappingArgsDict']]]]
        """
        Data source entities mapping for the detector rule
        """
        lifecycle_details: NotRequired[pulumi.Input[str]]
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        managed_list_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of managed list types related to this rule
        """
        recommendation: NotRequired[pulumi.Input[str]]
        """
        Recommendation for DetectorRecipeDetectorRule resource
        """
        resource_type: NotRequired[pulumi.Input[str]]
        """
        Resource type of the configuration to which the rule is applied
        """
        service_type: NotRequired[pulumi.Input[str]]
        """
        Service type of the configuration to which the rule is applied
        """
        state: NotRequired[pulumi.Input[str]]
        """
        The current lifecycle state of the resource
        """
        time_created: NotRequired[pulumi.Input[str]]
        """
        The date and time the detector recipe was created Format defined by RFC3339.
        """
        time_updated: NotRequired[pulumi.Input[str]]
        """
        The date and time the detector recipe was last updated Format defined by RFC3339.
        """
elif False:
    DetectorRecipeDetectorRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DetectorRecipeDetectorRuleArgs:
    def __init__(__self__, *,
                 details: pulumi.Input['DetectorRecipeDetectorRuleDetailsArgs'],
                 detector_rule_id: pulumi.Input[str],
                 candidate_responder_rules: Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeDetectorRuleCandidateResponderRuleArgs']]]] = None,
                 data_source_id: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 detector: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 entities_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeDetectorRuleEntitiesMappingArgs']]]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 managed_list_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 recommendation: Optional[pulumi.Input[str]] = None,
                 resource_type: Optional[pulumi.Input[str]] = None,
                 service_type: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_updated: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DetectorRecipeDetectorRuleDetailsArgs'] details: (Updatable) Parameters to be updated for a detector rule within a detector recipe.
        :param pulumi.Input[str] detector_rule_id: (Updatable) Detector recipe rule ID
        :param pulumi.Input[Sequence[pulumi.Input['DetectorRecipeDetectorRuleCandidateResponderRuleArgs']]] candidate_responder_rules: List of responder rules that can be used to remediate this detector rule
        :param pulumi.Input[str] data_source_id: The ID of the attached data source
        :param pulumi.Input[str] description: (Updatable) Detector recipe description.
               
               Avoid entering confidential information.
        :param pulumi.Input[str] detector: Detector for the rule
        :param pulumi.Input[str] display_name: (Updatable) Detector recipe display name.
               
               Avoid entering confidential information.
        :param pulumi.Input[Sequence[pulumi.Input['DetectorRecipeDetectorRuleEntitiesMappingArgs']]] entities_mappings: Data source entities mapping for the detector rule
        :param pulumi.Input[str] lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] managed_list_types: List of managed list types related to this rule
        :param pulumi.Input[str] recommendation: Recommendation for DetectorRecipeDetectorRule resource
        :param pulumi.Input[str] resource_type: Resource type of the configuration to which the rule is applied
        :param pulumi.Input[str] service_type: Service type of the configuration to which the rule is applied
        :param pulumi.Input[str] state: The current lifecycle state of the resource
        :param pulumi.Input[str] time_created: The date and time the detector recipe was created Format defined by RFC3339.
        :param pulumi.Input[str] time_updated: The date and time the detector recipe was last updated Format defined by RFC3339.
        """
        pulumi.set(__self__, "details", details)
        pulumi.set(__self__, "detector_rule_id", detector_rule_id)
        if candidate_responder_rules is not None:
            pulumi.set(__self__, "candidate_responder_rules", candidate_responder_rules)
        if data_source_id is not None:
            pulumi.set(__self__, "data_source_id", data_source_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if detector is not None:
            pulumi.set(__self__, "detector", detector)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if entities_mappings is not None:
            pulumi.set(__self__, "entities_mappings", entities_mappings)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if managed_list_types is not None:
            pulumi.set(__self__, "managed_list_types", managed_list_types)
        if recommendation is not None:
            pulumi.set(__self__, "recommendation", recommendation)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if service_type is not None:
            pulumi.set(__self__, "service_type", service_type)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter
    def details(self) -> pulumi.Input['DetectorRecipeDetectorRuleDetailsArgs']:
        """
        (Updatable) Parameters to be updated for a detector rule within a detector recipe.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: pulumi.Input['DetectorRecipeDetectorRuleDetailsArgs']):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter(name="detectorRuleId")
    def detector_rule_id(self) -> pulumi.Input[str]:
        """
        (Updatable) Detector recipe rule ID
        """
        return pulumi.get(self, "detector_rule_id")

    @detector_rule_id.setter
    def detector_rule_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "detector_rule_id", value)

    @property
    @pulumi.getter(name="candidateResponderRules")
    def candidate_responder_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeDetectorRuleCandidateResponderRuleArgs']]]]:
        """
        List of responder rules that can be used to remediate this detector rule
        """
        return pulumi.get(self, "candidate_responder_rules")

    @candidate_responder_rules.setter
    def candidate_responder_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeDetectorRuleCandidateResponderRuleArgs']]]]):
        pulumi.set(self, "candidate_responder_rules", value)

    @property
    @pulumi.getter(name="dataSourceId")
    def data_source_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the attached data source
        """
        return pulumi.get(self, "data_source_id")

    @data_source_id.setter
    def data_source_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_source_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Detector recipe description.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def detector(self) -> Optional[pulumi.Input[str]]:
        """
        Detector for the rule
        """
        return pulumi.get(self, "detector")

    @detector.setter
    def detector(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detector", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Detector recipe display name.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="entitiesMappings")
    def entities_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeDetectorRuleEntitiesMappingArgs']]]]:
        """
        Data source entities mapping for the detector rule
        """
        return pulumi.get(self, "entities_mappings")

    @entities_mappings.setter
    def entities_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeDetectorRuleEntitiesMappingArgs']]]]):
        pulumi.set(self, "entities_mappings", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter(name="managedListTypes")
    def managed_list_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of managed list types related to this rule
        """
        return pulumi.get(self, "managed_list_types")

    @managed_list_types.setter
    def managed_list_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "managed_list_types", value)

    @property
    @pulumi.getter
    def recommendation(self) -> Optional[pulumi.Input[str]]:
        """
        Recommendation for DetectorRecipeDetectorRule resource
        """
        return pulumi.get(self, "recommendation")

    @recommendation.setter
    def recommendation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recommendation", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[str]]:
        """
        Resource type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_type", value)

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> Optional[pulumi.Input[str]]:
        """
        Service type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "service_type")

    @service_type.setter
    def service_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_type", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current lifecycle state of the resource
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the detector recipe was created Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the detector recipe was last updated Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_updated", value)


if not MYPY:
    class DetectorRecipeDetectorRuleCandidateResponderRuleArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Detector recipe display name.

        Avoid entering confidential information.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        OCID for detector recipe
        """
        is_preferred: NotRequired[pulumi.Input[bool]]
        """
        Is this the preferred state?
        """
elif False:
    DetectorRecipeDetectorRuleCandidateResponderRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DetectorRecipeDetectorRuleCandidateResponderRuleArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 is_preferred: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] display_name: (Updatable) Detector recipe display name.
               
               Avoid entering confidential information.
        :param pulumi.Input[str] id: OCID for detector recipe
        :param pulumi.Input[bool] is_preferred: Is this the preferred state?
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_preferred is not None:
            pulumi.set(__self__, "is_preferred", is_preferred)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Detector recipe display name.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        OCID for detector recipe
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="isPreferred")
    def is_preferred(self) -> Optional[pulumi.Input[bool]]:
        """
        Is this the preferred state?
        """
        return pulumi.get(self, "is_preferred")

    @is_preferred.setter
    def is_preferred(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_preferred", value)


if not MYPY:
    class DetectorRecipeDetectorRuleDetailsArgsDict(TypedDict):
        is_enabled: pulumi.Input[bool]
        """
        (Updatable) Enablement status of the detector rule
        """
        risk_level: pulumi.Input[str]
        """
        (Updatable) The risk level of the detector rule
        """
        condition: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The base condition resource.
        """
        configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeDetectorRuleDetailsConfigurationArgsDict']]]]
        """
        (Updatable) List of detector rule configurations
        """
        data_source_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The unique identifier of the attached data source
        """
        description: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Description for the detector rule
        """
        entities_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeDetectorRuleDetailsEntitiesMappingArgsDict']]]]
        """
        (Updatable) Data source entities mapping for a detector rule
        """
        is_configuration_allowed: NotRequired[pulumi.Input[bool]]
        """
        Can the rule be configured?
        """
        labels: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (Updatable) User-defined labels for a detector rule
        """
        recommendation: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Recommendation for the detector rule
        """
elif False:
    DetectorRecipeDetectorRuleDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DetectorRecipeDetectorRuleDetailsArgs:
    def __init__(__self__, *,
                 is_enabled: pulumi.Input[bool],
                 risk_level: pulumi.Input[str],
                 condition: Optional[pulumi.Input[str]] = None,
                 configurations: Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeDetectorRuleDetailsConfigurationArgs']]]] = None,
                 data_source_id: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 entities_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeDetectorRuleDetailsEntitiesMappingArgs']]]] = None,
                 is_configuration_allowed: Optional[pulumi.Input[bool]] = None,
                 labels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 recommendation: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_enabled: (Updatable) Enablement status of the detector rule
        :param pulumi.Input[str] risk_level: (Updatable) The risk level of the detector rule
        :param pulumi.Input[str] condition: (Updatable) The base condition resource.
        :param pulumi.Input[Sequence[pulumi.Input['DetectorRecipeDetectorRuleDetailsConfigurationArgs']]] configurations: (Updatable) List of detector rule configurations
        :param pulumi.Input[str] data_source_id: (Updatable) The unique identifier of the attached data source
        :param pulumi.Input[str] description: (Updatable) Description for the detector rule
        :param pulumi.Input[Sequence[pulumi.Input['DetectorRecipeDetectorRuleDetailsEntitiesMappingArgs']]] entities_mappings: (Updatable) Data source entities mapping for a detector rule
        :param pulumi.Input[bool] is_configuration_allowed: Can the rule be configured?
        :param pulumi.Input[Sequence[pulumi.Input[str]]] labels: (Updatable) User-defined labels for a detector rule
        :param pulumi.Input[str] recommendation: (Updatable) Recommendation for the detector rule
        """
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "risk_level", risk_level)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if data_source_id is not None:
            pulumi.set(__self__, "data_source_id", data_source_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if entities_mappings is not None:
            pulumi.set(__self__, "entities_mappings", entities_mappings)
        if is_configuration_allowed is not None:
            pulumi.set(__self__, "is_configuration_allowed", is_configuration_allowed)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if recommendation is not None:
            pulumi.set(__self__, "recommendation", recommendation)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        """
        (Updatable) Enablement status of the detector rule
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> pulumi.Input[str]:
        """
        (Updatable) The risk level of the detector rule
        """
        return pulumi.get(self, "risk_level")

    @risk_level.setter
    def risk_level(self, value: pulumi.Input[str]):
        pulumi.set(self, "risk_level", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The base condition resource.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeDetectorRuleDetailsConfigurationArgs']]]]:
        """
        (Updatable) List of detector rule configurations
        """
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeDetectorRuleDetailsConfigurationArgs']]]]):
        pulumi.set(self, "configurations", value)

    @property
    @pulumi.getter(name="dataSourceId")
    def data_source_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The unique identifier of the attached data source
        """
        return pulumi.get(self, "data_source_id")

    @data_source_id.setter
    def data_source_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_source_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Description for the detector rule
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="entitiesMappings")
    def entities_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeDetectorRuleDetailsEntitiesMappingArgs']]]]:
        """
        (Updatable) Data source entities mapping for a detector rule
        """
        return pulumi.get(self, "entities_mappings")

    @entities_mappings.setter
    def entities_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeDetectorRuleDetailsEntitiesMappingArgs']]]]):
        pulumi.set(self, "entities_mappings", value)

    @property
    @pulumi.getter(name="isConfigurationAllowed")
    def is_configuration_allowed(self) -> Optional[pulumi.Input[bool]]:
        """
        Can the rule be configured?
        """
        return pulumi.get(self, "is_configuration_allowed")

    @is_configuration_allowed.setter
    def is_configuration_allowed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_configuration_allowed", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) User-defined labels for a detector rule
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def recommendation(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Recommendation for the detector rule
        """
        return pulumi.get(self, "recommendation")

    @recommendation.setter
    def recommendation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recommendation", value)


if not MYPY:
    class DetectorRecipeDetectorRuleDetailsConfigurationArgsDict(TypedDict):
        config_key: pulumi.Input[str]
        """
        (Updatable) Unique identifier of the configuration
        """
        name: pulumi.Input[str]
        """
        (Updatable) Configuration name
        """
        data_type: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Configuration data type
        """
        value: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Configuration value
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeDetectorRuleDetailsConfigurationValueArgsDict']]]]
        """
        (Updatable) List of configuration values
        """
elif False:
    DetectorRecipeDetectorRuleDetailsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DetectorRecipeDetectorRuleDetailsConfigurationArgs:
    def __init__(__self__, *,
                 config_key: pulumi.Input[str],
                 name: pulumi.Input[str],
                 data_type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeDetectorRuleDetailsConfigurationValueArgs']]]] = None):
        """
        :param pulumi.Input[str] config_key: (Updatable) Unique identifier of the configuration
        :param pulumi.Input[str] name: (Updatable) Configuration name
        :param pulumi.Input[str] data_type: (Updatable) Configuration data type
        :param pulumi.Input[str] value: (Updatable) Configuration value
        :param pulumi.Input[Sequence[pulumi.Input['DetectorRecipeDetectorRuleDetailsConfigurationValueArgs']]] values: (Updatable) List of configuration values
        """
        pulumi.set(__self__, "config_key", config_key)
        pulumi.set(__self__, "name", name)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> pulumi.Input[str]:
        """
        (Updatable) Unique identifier of the configuration
        """
        return pulumi.get(self, "config_key")

    @config_key.setter
    def config_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "config_key", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Configuration name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Configuration data type
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Configuration value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeDetectorRuleDetailsConfigurationValueArgs']]]]:
        """
        (Updatable) List of configuration values
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeDetectorRuleDetailsConfigurationValueArgs']]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DetectorRecipeDetectorRuleDetailsConfigurationValueArgsDict(TypedDict):
        list_type: pulumi.Input[str]
        """
        (Updatable) Configuration list item type (CUSTOM or MANAGED)
        """
        managed_list_type: pulumi.Input[str]
        """
        (Updatable) Type of content in the managed list
        """
        value: pulumi.Input[str]
        """
        (Updatable) Configuration value
        """
elif False:
    DetectorRecipeDetectorRuleDetailsConfigurationValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DetectorRecipeDetectorRuleDetailsConfigurationValueArgs:
    def __init__(__self__, *,
                 list_type: pulumi.Input[str],
                 managed_list_type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] list_type: (Updatable) Configuration list item type (CUSTOM or MANAGED)
        :param pulumi.Input[str] managed_list_type: (Updatable) Type of content in the managed list
        :param pulumi.Input[str] value: (Updatable) Configuration value
        """
        pulumi.set(__self__, "list_type", list_type)
        pulumi.set(__self__, "managed_list_type", managed_list_type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="listType")
    def list_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Configuration list item type (CUSTOM or MANAGED)
        """
        return pulumi.get(self, "list_type")

    @list_type.setter
    def list_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "list_type", value)

    @property
    @pulumi.getter(name="managedListType")
    def managed_list_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Type of content in the managed list
        """
        return pulumi.get(self, "managed_list_type")

    @managed_list_type.setter
    def managed_list_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "managed_list_type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        (Updatable) Configuration value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DetectorRecipeDetectorRuleDetailsEntitiesMappingArgsDict(TypedDict):
        query_field: pulumi.Input[str]
        """
        (Updatable) The entity value mapped to a data source query
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Display name of the entity
        """
        entity_type: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Type of entity
        """
elif False:
    DetectorRecipeDetectorRuleDetailsEntitiesMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DetectorRecipeDetectorRuleDetailsEntitiesMappingArgs:
    def __init__(__self__, *,
                 query_field: pulumi.Input[str],
                 display_name: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] query_field: (Updatable) The entity value mapped to a data source query
        :param pulumi.Input[str] display_name: (Updatable) Display name of the entity
        :param pulumi.Input[str] entity_type: (Updatable) Type of entity
        """
        pulumi.set(__self__, "query_field", query_field)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)

    @property
    @pulumi.getter(name="queryField")
    def query_field(self) -> pulumi.Input[str]:
        """
        (Updatable) The entity value mapped to a data source query
        """
        return pulumi.get(self, "query_field")

    @query_field.setter
    def query_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "query_field", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Display name of the entity
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Type of entity
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)


if not MYPY:
    class DetectorRecipeDetectorRuleEntitiesMappingArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Detector recipe display name.

        Avoid entering confidential information.
        """
        entity_type: NotRequired[pulumi.Input[str]]
        """
        Type of entity
        """
        query_field: NotRequired[pulumi.Input[str]]
        """
        The entity value mapped to a data source query
        """
elif False:
    DetectorRecipeDetectorRuleEntitiesMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DetectorRecipeDetectorRuleEntitiesMappingArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 query_field: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] display_name: (Updatable) Detector recipe display name.
               
               Avoid entering confidential information.
        :param pulumi.Input[str] entity_type: Type of entity
        :param pulumi.Input[str] query_field: The entity value mapped to a data source query
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if query_field is not None:
            pulumi.set(__self__, "query_field", query_field)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Detector recipe display name.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of entity
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="queryField")
    def query_field(self) -> Optional[pulumi.Input[str]]:
        """
        The entity value mapped to a data source query
        """
        return pulumi.get(self, "query_field")

    @query_field.setter
    def query_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_field", value)


if not MYPY:
    class DetectorRecipeEffectiveDetectorRuleArgsDict(TypedDict):
        candidate_responder_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeEffectiveDetectorRuleCandidateResponderRuleArgsDict']]]]
        """
        List of responder rules that can be used to remediate this detector rule
        """
        data_source_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the attached data source
        """
        description: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Detector recipe description.

        Avoid entering confidential information.
        """
        details: NotRequired[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeEffectiveDetectorRuleDetailArgsDict']]]]
        """
        Detailed information for a detector.
        """
        detector: NotRequired[pulumi.Input[str]]
        """
        Detector for the rule
        """
        detector_rule_id: NotRequired[pulumi.Input[str]]
        """
        The unique identifier of the detector rule.
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Detector recipe display name.

        Avoid entering confidential information.
        """
        entities_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeEffectiveDetectorRuleEntitiesMappingArgsDict']]]]
        """
        Data source entities mapping for the detector rule
        """
        lifecycle_details: NotRequired[pulumi.Input[str]]
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        managed_list_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of managed list types related to this rule
        """
        recommendation: NotRequired[pulumi.Input[str]]
        """
        Recommendation for DetectorRecipeDetectorRule resource
        """
        resource_type: NotRequired[pulumi.Input[str]]
        """
        Resource type of the configuration to which the rule is applied
        """
        service_type: NotRequired[pulumi.Input[str]]
        """
        Service type of the configuration to which the rule is applied
        """
        state: NotRequired[pulumi.Input[str]]
        """
        The current lifecycle state of the resource
        """
        time_created: NotRequired[pulumi.Input[str]]
        """
        The date and time the detector recipe was created Format defined by RFC3339.
        """
        time_updated: NotRequired[pulumi.Input[str]]
        """
        The date and time the detector recipe was last updated Format defined by RFC3339.
        """
elif False:
    DetectorRecipeEffectiveDetectorRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DetectorRecipeEffectiveDetectorRuleArgs:
    def __init__(__self__, *,
                 candidate_responder_rules: Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeEffectiveDetectorRuleCandidateResponderRuleArgs']]]] = None,
                 data_source_id: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 details: Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeEffectiveDetectorRuleDetailArgs']]]] = None,
                 detector: Optional[pulumi.Input[str]] = None,
                 detector_rule_id: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 entities_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeEffectiveDetectorRuleEntitiesMappingArgs']]]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 managed_list_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 recommendation: Optional[pulumi.Input[str]] = None,
                 resource_type: Optional[pulumi.Input[str]] = None,
                 service_type: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_updated: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DetectorRecipeEffectiveDetectorRuleCandidateResponderRuleArgs']]] candidate_responder_rules: List of responder rules that can be used to remediate this detector rule
        :param pulumi.Input[str] data_source_id: The ID of the attached data source
        :param pulumi.Input[str] description: (Updatable) Detector recipe description.
               
               Avoid entering confidential information.
        :param pulumi.Input[Sequence[pulumi.Input['DetectorRecipeEffectiveDetectorRuleDetailArgs']]] details: Detailed information for a detector.
        :param pulumi.Input[str] detector: Detector for the rule
        :param pulumi.Input[str] detector_rule_id: The unique identifier of the detector rule.
        :param pulumi.Input[str] display_name: (Updatable) Detector recipe display name.
               
               Avoid entering confidential information.
        :param pulumi.Input[Sequence[pulumi.Input['DetectorRecipeEffectiveDetectorRuleEntitiesMappingArgs']]] entities_mappings: Data source entities mapping for the detector rule
        :param pulumi.Input[str] lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] managed_list_types: List of managed list types related to this rule
        :param pulumi.Input[str] recommendation: Recommendation for DetectorRecipeDetectorRule resource
        :param pulumi.Input[str] resource_type: Resource type of the configuration to which the rule is applied
        :param pulumi.Input[str] service_type: Service type of the configuration to which the rule is applied
        :param pulumi.Input[str] state: The current lifecycle state of the resource
        :param pulumi.Input[str] time_created: The date and time the detector recipe was created Format defined by RFC3339.
        :param pulumi.Input[str] time_updated: The date and time the detector recipe was last updated Format defined by RFC3339.
        """
        if candidate_responder_rules is not None:
            pulumi.set(__self__, "candidate_responder_rules", candidate_responder_rules)
        if data_source_id is not None:
            pulumi.set(__self__, "data_source_id", data_source_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if detector is not None:
            pulumi.set(__self__, "detector", detector)
        if detector_rule_id is not None:
            pulumi.set(__self__, "detector_rule_id", detector_rule_id)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if entities_mappings is not None:
            pulumi.set(__self__, "entities_mappings", entities_mappings)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if managed_list_types is not None:
            pulumi.set(__self__, "managed_list_types", managed_list_types)
        if recommendation is not None:
            pulumi.set(__self__, "recommendation", recommendation)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if service_type is not None:
            pulumi.set(__self__, "service_type", service_type)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="candidateResponderRules")
    def candidate_responder_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeEffectiveDetectorRuleCandidateResponderRuleArgs']]]]:
        """
        List of responder rules that can be used to remediate this detector rule
        """
        return pulumi.get(self, "candidate_responder_rules")

    @candidate_responder_rules.setter
    def candidate_responder_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeEffectiveDetectorRuleCandidateResponderRuleArgs']]]]):
        pulumi.set(self, "candidate_responder_rules", value)

    @property
    @pulumi.getter(name="dataSourceId")
    def data_source_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the attached data source
        """
        return pulumi.get(self, "data_source_id")

    @data_source_id.setter
    def data_source_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_source_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Detector recipe description.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeEffectiveDetectorRuleDetailArgs']]]]:
        """
        Detailed information for a detector.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeEffectiveDetectorRuleDetailArgs']]]]):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter
    def detector(self) -> Optional[pulumi.Input[str]]:
        """
        Detector for the rule
        """
        return pulumi.get(self, "detector")

    @detector.setter
    def detector(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detector", value)

    @property
    @pulumi.getter(name="detectorRuleId")
    def detector_rule_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique identifier of the detector rule.
        """
        return pulumi.get(self, "detector_rule_id")

    @detector_rule_id.setter
    def detector_rule_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detector_rule_id", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Detector recipe display name.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="entitiesMappings")
    def entities_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeEffectiveDetectorRuleEntitiesMappingArgs']]]]:
        """
        Data source entities mapping for the detector rule
        """
        return pulumi.get(self, "entities_mappings")

    @entities_mappings.setter
    def entities_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeEffectiveDetectorRuleEntitiesMappingArgs']]]]):
        pulumi.set(self, "entities_mappings", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter(name="managedListTypes")
    def managed_list_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of managed list types related to this rule
        """
        return pulumi.get(self, "managed_list_types")

    @managed_list_types.setter
    def managed_list_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "managed_list_types", value)

    @property
    @pulumi.getter
    def recommendation(self) -> Optional[pulumi.Input[str]]:
        """
        Recommendation for DetectorRecipeDetectorRule resource
        """
        return pulumi.get(self, "recommendation")

    @recommendation.setter
    def recommendation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recommendation", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[str]]:
        """
        Resource type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_type", value)

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> Optional[pulumi.Input[str]]:
        """
        Service type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "service_type")

    @service_type.setter
    def service_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_type", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current lifecycle state of the resource
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the detector recipe was created Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the detector recipe was last updated Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_updated", value)


if not MYPY:
    class DetectorRecipeEffectiveDetectorRuleCandidateResponderRuleArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Detector recipe display name.

        Avoid entering confidential information.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        OCID for detector recipe
        """
        is_preferred: NotRequired[pulumi.Input[bool]]
        """
        Is this the preferred state?
        """
elif False:
    DetectorRecipeEffectiveDetectorRuleCandidateResponderRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DetectorRecipeEffectiveDetectorRuleCandidateResponderRuleArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 is_preferred: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] display_name: (Updatable) Detector recipe display name.
               
               Avoid entering confidential information.
        :param pulumi.Input[str] id: OCID for detector recipe
        :param pulumi.Input[bool] is_preferred: Is this the preferred state?
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_preferred is not None:
            pulumi.set(__self__, "is_preferred", is_preferred)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Detector recipe display name.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        OCID for detector recipe
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="isPreferred")
    def is_preferred(self) -> Optional[pulumi.Input[bool]]:
        """
        Is this the preferred state?
        """
        return pulumi.get(self, "is_preferred")

    @is_preferred.setter
    def is_preferred(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_preferred", value)


if not MYPY:
    class DetectorRecipeEffectiveDetectorRuleDetailArgsDict(TypedDict):
        condition: NotRequired[pulumi.Input[str]]
        """
        The base condition resource.
        """
        configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeEffectiveDetectorRuleDetailConfigurationArgsDict']]]]
        """
        List of detector rule configurations
        """
        data_source_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the attached data source
        """
        description: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Detector recipe description.

        Avoid entering confidential information.
        """
        entities_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeEffectiveDetectorRuleDetailEntitiesMappingArgsDict']]]]
        """
        Data source entities mapping for the detector rule
        """
        is_configuration_allowed: NotRequired[pulumi.Input[bool]]
        """
        Can the rule be configured?
        """
        is_enabled: NotRequired[pulumi.Input[bool]]
        """
        Enablement status for the rule
        """
        labels: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        User-defined labels for a detector rule
        """
        recommendation: NotRequired[pulumi.Input[str]]
        """
        Recommendation for DetectorRecipeDetectorRule resource
        """
        risk_level: NotRequired[pulumi.Input[str]]
        """
        The risk level for the rule
        """
elif False:
    DetectorRecipeEffectiveDetectorRuleDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DetectorRecipeEffectiveDetectorRuleDetailArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input[str]] = None,
                 configurations: Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeEffectiveDetectorRuleDetailConfigurationArgs']]]] = None,
                 data_source_id: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 entities_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeEffectiveDetectorRuleDetailEntitiesMappingArgs']]]] = None,
                 is_configuration_allowed: Optional[pulumi.Input[bool]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 labels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 recommendation: Optional[pulumi.Input[str]] = None,
                 risk_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] condition: The base condition resource.
        :param pulumi.Input[Sequence[pulumi.Input['DetectorRecipeEffectiveDetectorRuleDetailConfigurationArgs']]] configurations: List of detector rule configurations
        :param pulumi.Input[str] data_source_id: The ID of the attached data source
        :param pulumi.Input[str] description: (Updatable) Detector recipe description.
               
               Avoid entering confidential information.
        :param pulumi.Input[Sequence[pulumi.Input['DetectorRecipeEffectiveDetectorRuleDetailEntitiesMappingArgs']]] entities_mappings: Data source entities mapping for the detector rule
        :param pulumi.Input[bool] is_configuration_allowed: Can the rule be configured?
        :param pulumi.Input[bool] is_enabled: Enablement status for the rule
        :param pulumi.Input[Sequence[pulumi.Input[str]]] labels: User-defined labels for a detector rule
        :param pulumi.Input[str] recommendation: Recommendation for DetectorRecipeDetectorRule resource
        :param pulumi.Input[str] risk_level: The risk level for the rule
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if data_source_id is not None:
            pulumi.set(__self__, "data_source_id", data_source_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if entities_mappings is not None:
            pulumi.set(__self__, "entities_mappings", entities_mappings)
        if is_configuration_allowed is not None:
            pulumi.set(__self__, "is_configuration_allowed", is_configuration_allowed)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if recommendation is not None:
            pulumi.set(__self__, "recommendation", recommendation)
        if risk_level is not None:
            pulumi.set(__self__, "risk_level", risk_level)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        The base condition resource.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeEffectiveDetectorRuleDetailConfigurationArgs']]]]:
        """
        List of detector rule configurations
        """
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeEffectiveDetectorRuleDetailConfigurationArgs']]]]):
        pulumi.set(self, "configurations", value)

    @property
    @pulumi.getter(name="dataSourceId")
    def data_source_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the attached data source
        """
        return pulumi.get(self, "data_source_id")

    @data_source_id.setter
    def data_source_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_source_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Detector recipe description.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="entitiesMappings")
    def entities_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeEffectiveDetectorRuleDetailEntitiesMappingArgs']]]]:
        """
        Data source entities mapping for the detector rule
        """
        return pulumi.get(self, "entities_mappings")

    @entities_mappings.setter
    def entities_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeEffectiveDetectorRuleDetailEntitiesMappingArgs']]]]):
        pulumi.set(self, "entities_mappings", value)

    @property
    @pulumi.getter(name="isConfigurationAllowed")
    def is_configuration_allowed(self) -> Optional[pulumi.Input[bool]]:
        """
        Can the rule be configured?
        """
        return pulumi.get(self, "is_configuration_allowed")

    @is_configuration_allowed.setter
    def is_configuration_allowed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_configuration_allowed", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enablement status for the rule
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        User-defined labels for a detector rule
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def recommendation(self) -> Optional[pulumi.Input[str]]:
        """
        Recommendation for DetectorRecipeDetectorRule resource
        """
        return pulumi.get(self, "recommendation")

    @recommendation.setter
    def recommendation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recommendation", value)

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> Optional[pulumi.Input[str]]:
        """
        The risk level for the rule
        """
        return pulumi.get(self, "risk_level")

    @risk_level.setter
    def risk_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "risk_level", value)


if not MYPY:
    class DetectorRecipeEffectiveDetectorRuleDetailConfigurationArgsDict(TypedDict):
        config_key: NotRequired[pulumi.Input[str]]
        """
        Unique identifier of the configuration
        """
        data_type: NotRequired[pulumi.Input[str]]
        """
        Configuration data type
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Configuration name
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Configuration value
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeEffectiveDetectorRuleDetailConfigurationValueArgsDict']]]]
        """
        List of configuration values
        """
elif False:
    DetectorRecipeEffectiveDetectorRuleDetailConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DetectorRecipeEffectiveDetectorRuleDetailConfigurationArgs:
    def __init__(__self__, *,
                 config_key: Optional[pulumi.Input[str]] = None,
                 data_type: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeEffectiveDetectorRuleDetailConfigurationValueArgs']]]] = None):
        """
        :param pulumi.Input[str] config_key: Unique identifier of the configuration
        :param pulumi.Input[str] data_type: Configuration data type
        :param pulumi.Input[str] name: Configuration name
        :param pulumi.Input[str] value: Configuration value
        :param pulumi.Input[Sequence[pulumi.Input['DetectorRecipeEffectiveDetectorRuleDetailConfigurationValueArgs']]] values: List of configuration values
        """
        if config_key is not None:
            pulumi.set(__self__, "config_key", config_key)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of the configuration
        """
        return pulumi.get(self, "config_key")

    @config_key.setter
    def config_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_key", value)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[pulumi.Input[str]]:
        """
        Configuration data type
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Configuration name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Configuration value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeEffectiveDetectorRuleDetailConfigurationValueArgs']]]]:
        """
        List of configuration values
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRecipeEffectiveDetectorRuleDetailConfigurationValueArgs']]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DetectorRecipeEffectiveDetectorRuleDetailConfigurationValueArgsDict(TypedDict):
        list_type: NotRequired[pulumi.Input[str]]
        """
        Configuration list item type (CUSTOM or MANAGED)
        """
        managed_list_type: NotRequired[pulumi.Input[str]]
        """
        Type of content in the managed list
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Configuration value
        """
elif False:
    DetectorRecipeEffectiveDetectorRuleDetailConfigurationValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DetectorRecipeEffectiveDetectorRuleDetailConfigurationValueArgs:
    def __init__(__self__, *,
                 list_type: Optional[pulumi.Input[str]] = None,
                 managed_list_type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] list_type: Configuration list item type (CUSTOM or MANAGED)
        :param pulumi.Input[str] managed_list_type: Type of content in the managed list
        :param pulumi.Input[str] value: Configuration value
        """
        if list_type is not None:
            pulumi.set(__self__, "list_type", list_type)
        if managed_list_type is not None:
            pulumi.set(__self__, "managed_list_type", managed_list_type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="listType")
    def list_type(self) -> Optional[pulumi.Input[str]]:
        """
        Configuration list item type (CUSTOM or MANAGED)
        """
        return pulumi.get(self, "list_type")

    @list_type.setter
    def list_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "list_type", value)

    @property
    @pulumi.getter(name="managedListType")
    def managed_list_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of content in the managed list
        """
        return pulumi.get(self, "managed_list_type")

    @managed_list_type.setter
    def managed_list_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "managed_list_type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Configuration value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DetectorRecipeEffectiveDetectorRuleDetailEntitiesMappingArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Detector recipe display name.

        Avoid entering confidential information.
        """
        entity_type: NotRequired[pulumi.Input[str]]
        """
        Type of entity
        """
        query_field: NotRequired[pulumi.Input[str]]
        """
        The entity value mapped to a data source query
        """
elif False:
    DetectorRecipeEffectiveDetectorRuleDetailEntitiesMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DetectorRecipeEffectiveDetectorRuleDetailEntitiesMappingArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 query_field: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] display_name: (Updatable) Detector recipe display name.
               
               Avoid entering confidential information.
        :param pulumi.Input[str] entity_type: Type of entity
        :param pulumi.Input[str] query_field: The entity value mapped to a data source query
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if query_field is not None:
            pulumi.set(__self__, "query_field", query_field)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Detector recipe display name.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of entity
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="queryField")
    def query_field(self) -> Optional[pulumi.Input[str]]:
        """
        The entity value mapped to a data source query
        """
        return pulumi.get(self, "query_field")

    @query_field.setter
    def query_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_field", value)


if not MYPY:
    class DetectorRecipeEffectiveDetectorRuleEntitiesMappingArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Detector recipe display name.

        Avoid entering confidential information.
        """
        entity_type: NotRequired[pulumi.Input[str]]
        """
        Type of entity
        """
        query_field: NotRequired[pulumi.Input[str]]
        """
        The entity value mapped to a data source query
        """
elif False:
    DetectorRecipeEffectiveDetectorRuleEntitiesMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DetectorRecipeEffectiveDetectorRuleEntitiesMappingArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 query_field: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] display_name: (Updatable) Detector recipe display name.
               
               Avoid entering confidential information.
        :param pulumi.Input[str] entity_type: Type of entity
        :param pulumi.Input[str] query_field: The entity value mapped to a data source query
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if query_field is not None:
            pulumi.set(__self__, "query_field", query_field)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Detector recipe display name.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of entity
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="queryField")
    def query_field(self) -> Optional[pulumi.Input[str]]:
        """
        The entity value mapped to a data source query
        """
        return pulumi.get(self, "query_field")

    @query_field.setter
    def query_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_field", value)


if not MYPY:
    class ResponderRecipeEffectiveResponderRuleArgsDict(TypedDict):
        compartment_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Compartment OCID
        """
        description: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Responder recipe description.

        Avoid entering confidential information.
        """
        details: NotRequired[pulumi.Input[Sequence[pulumi.Input['ResponderRecipeEffectiveResponderRuleDetailArgsDict']]]]
        """
        Detailed information for a responder rule
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Responder recipe display name.

        Avoid entering confidential information.
        """
        lifecycle_details: NotRequired[pulumi.Input[str]]
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of policies
        """
        responder_rule_id: NotRequired[pulumi.Input[str]]
        """
        Unique identifier for the responder rule
        """
        state: NotRequired[pulumi.Input[str]]
        """
        The current lifecycle state of the example
        """
        supported_modes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Supported execution modes for the responder rule
        """
        time_created: NotRequired[pulumi.Input[str]]
        """
        The date and time the responder recipe was created. Format defined by RFC3339.
        """
        time_updated: NotRequired[pulumi.Input[str]]
        """
        The date and time the responder recipe was last updated. Format defined by RFC3339.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of responder
        """
elif False:
    ResponderRecipeEffectiveResponderRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResponderRecipeEffectiveResponderRuleArgs:
    def __init__(__self__, *,
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 details: Optional[pulumi.Input[Sequence[pulumi.Input['ResponderRecipeEffectiveResponderRuleDetailArgs']]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 responder_rule_id: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 supported_modes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_updated: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compartment_id: (Updatable) Compartment OCID
        :param pulumi.Input[str] description: (Updatable) Responder recipe description.
               
               Avoid entering confidential information.
        :param pulumi.Input[Sequence[pulumi.Input['ResponderRecipeEffectiveResponderRuleDetailArgs']]] details: Detailed information for a responder rule
        :param pulumi.Input[str] display_name: (Updatable) Responder recipe display name.
               
               Avoid entering confidential information.
        :param pulumi.Input[str] lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] policies: List of policies
        :param pulumi.Input[str] responder_rule_id: Unique identifier for the responder rule
        :param pulumi.Input[str] state: The current lifecycle state of the example
        :param pulumi.Input[Sequence[pulumi.Input[str]]] supported_modes: Supported execution modes for the responder rule
        :param pulumi.Input[str] time_created: The date and time the responder recipe was created. Format defined by RFC3339.
        :param pulumi.Input[str] time_updated: The date and time the responder recipe was last updated. Format defined by RFC3339.
        :param pulumi.Input[str] type: Type of responder
        """
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if responder_rule_id is not None:
            pulumi.set(__self__, "responder_rule_id", responder_rule_id)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if supported_modes is not None:
            pulumi.set(__self__, "supported_modes", supported_modes)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Compartment OCID
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Responder recipe description.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ResponderRecipeEffectiveResponderRuleDetailArgs']]]]:
        """
        Detailed information for a responder rule
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ResponderRecipeEffectiveResponderRuleDetailArgs']]]]):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Responder recipe display name.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of policies
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "policies", value)

    @property
    @pulumi.getter(name="responderRuleId")
    def responder_rule_id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier for the responder rule
        """
        return pulumi.get(self, "responder_rule_id")

    @responder_rule_id.setter
    def responder_rule_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "responder_rule_id", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current lifecycle state of the example
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="supportedModes")
    def supported_modes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Supported execution modes for the responder rule
        """
        return pulumi.get(self, "supported_modes")

    @supported_modes.setter
    def supported_modes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "supported_modes", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the responder recipe was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the responder recipe was last updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_updated", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of responder
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ResponderRecipeEffectiveResponderRuleDetailArgsDict(TypedDict):
        condition: NotRequired[pulumi.Input[str]]
        """
        The base condition resource.
        """
        configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ResponderRecipeEffectiveResponderRuleDetailConfigurationArgsDict']]]]
        """
        List of responder rule configurations
        """
        is_enabled: NotRequired[pulumi.Input[bool]]
        """
        Enabled state for the responder rule
        """
        mode: NotRequired[pulumi.Input[str]]
        """
        Execution mode for the responder rule
        """
elif False:
    ResponderRecipeEffectiveResponderRuleDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResponderRecipeEffectiveResponderRuleDetailArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input[str]] = None,
                 configurations: Optional[pulumi.Input[Sequence[pulumi.Input['ResponderRecipeEffectiveResponderRuleDetailConfigurationArgs']]]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] condition: The base condition resource.
        :param pulumi.Input[Sequence[pulumi.Input['ResponderRecipeEffectiveResponderRuleDetailConfigurationArgs']]] configurations: List of responder rule configurations
        :param pulumi.Input[bool] is_enabled: Enabled state for the responder rule
        :param pulumi.Input[str] mode: Execution mode for the responder rule
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        The base condition resource.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ResponderRecipeEffectiveResponderRuleDetailConfigurationArgs']]]]:
        """
        List of responder rule configurations
        """
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ResponderRecipeEffectiveResponderRuleDetailConfigurationArgs']]]]):
        pulumi.set(self, "configurations", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enabled state for the responder rule
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Execution mode for the responder rule
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class ResponderRecipeEffectiveResponderRuleDetailConfigurationArgsDict(TypedDict):
        config_key: NotRequired[pulumi.Input[str]]
        """
        Unique identifier of the configuration
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Configuration name
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Configuration value
        """
elif False:
    ResponderRecipeEffectiveResponderRuleDetailConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResponderRecipeEffectiveResponderRuleDetailConfigurationArgs:
    def __init__(__self__, *,
                 config_key: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] config_key: Unique identifier of the configuration
        :param pulumi.Input[str] name: Configuration name
        :param pulumi.Input[str] value: Configuration value
        """
        if config_key is not None:
            pulumi.set(__self__, "config_key", config_key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of the configuration
        """
        return pulumi.get(self, "config_key")

    @config_key.setter
    def config_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_key", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Configuration name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Configuration value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ResponderRecipeResponderRuleArgsDict(TypedDict):
        details: pulumi.Input['ResponderRecipeResponderRuleDetailsArgsDict']
        """
        (Updatable) Parameters to be updated for a responder rule within a responder recipe.
        """
        responder_rule_id: pulumi.Input[str]
        """
        (Updatable) Unique identifier for the responder rule
        """
        compartment_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Compartment OCID
        """
        description: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Responder recipe description.

        Avoid entering confidential information.
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Responder recipe display name.

        Avoid entering confidential information.
        """
        lifecycle_details: NotRequired[pulumi.Input[str]]
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of policies
        """
        state: NotRequired[pulumi.Input[str]]
        """
        The current lifecycle state of the example
        """
        supported_modes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Supported execution modes for the responder rule
        """
        time_created: NotRequired[pulumi.Input[str]]
        """
        The date and time the responder recipe was created. Format defined by RFC3339.
        """
        time_updated: NotRequired[pulumi.Input[str]]
        """
        The date and time the responder recipe was last updated. Format defined by RFC3339.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of responder
        """
elif False:
    ResponderRecipeResponderRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResponderRecipeResponderRuleArgs:
    def __init__(__self__, *,
                 details: pulumi.Input['ResponderRecipeResponderRuleDetailsArgs'],
                 responder_rule_id: pulumi.Input[str],
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 supported_modes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_updated: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ResponderRecipeResponderRuleDetailsArgs'] details: (Updatable) Parameters to be updated for a responder rule within a responder recipe.
        :param pulumi.Input[str] responder_rule_id: (Updatable) Unique identifier for the responder rule
        :param pulumi.Input[str] compartment_id: (Updatable) Compartment OCID
        :param pulumi.Input[str] description: (Updatable) Responder recipe description.
               
               Avoid entering confidential information.
        :param pulumi.Input[str] display_name: (Updatable) Responder recipe display name.
               
               Avoid entering confidential information.
        :param pulumi.Input[str] lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] policies: List of policies
        :param pulumi.Input[str] state: The current lifecycle state of the example
        :param pulumi.Input[Sequence[pulumi.Input[str]]] supported_modes: Supported execution modes for the responder rule
        :param pulumi.Input[str] time_created: The date and time the responder recipe was created. Format defined by RFC3339.
        :param pulumi.Input[str] time_updated: The date and time the responder recipe was last updated. Format defined by RFC3339.
        :param pulumi.Input[str] type: Type of responder
        """
        pulumi.set(__self__, "details", details)
        pulumi.set(__self__, "responder_rule_id", responder_rule_id)
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if supported_modes is not None:
            pulumi.set(__self__, "supported_modes", supported_modes)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def details(self) -> pulumi.Input['ResponderRecipeResponderRuleDetailsArgs']:
        """
        (Updatable) Parameters to be updated for a responder rule within a responder recipe.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: pulumi.Input['ResponderRecipeResponderRuleDetailsArgs']):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter(name="responderRuleId")
    def responder_rule_id(self) -> pulumi.Input[str]:
        """
        (Updatable) Unique identifier for the responder rule
        """
        return pulumi.get(self, "responder_rule_id")

    @responder_rule_id.setter
    def responder_rule_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "responder_rule_id", value)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Compartment OCID
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Responder recipe description.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Responder recipe display name.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of policies
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "policies", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current lifecycle state of the example
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="supportedModes")
    def supported_modes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Supported execution modes for the responder rule
        """
        return pulumi.get(self, "supported_modes")

    @supported_modes.setter
    def supported_modes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "supported_modes", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the responder recipe was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the responder recipe was last updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_updated", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of responder
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ResponderRecipeResponderRuleDetailsArgsDict(TypedDict):
        is_enabled: pulumi.Input[bool]
        """
        (Updatable) Enablement state for the responder rule
        """
        condition: NotRequired[pulumi.Input[str]]
        """
        The base condition resource.
        """
        configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ResponderRecipeResponderRuleDetailsConfigurationArgsDict']]]]
        """
        List of responder rule configurations
        """
        mode: NotRequired[pulumi.Input[str]]
        """
        Execution mode for the responder rule
        """
elif False:
    ResponderRecipeResponderRuleDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResponderRecipeResponderRuleDetailsArgs:
    def __init__(__self__, *,
                 is_enabled: pulumi.Input[bool],
                 condition: Optional[pulumi.Input[str]] = None,
                 configurations: Optional[pulumi.Input[Sequence[pulumi.Input['ResponderRecipeResponderRuleDetailsConfigurationArgs']]]] = None,
                 mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_enabled: (Updatable) Enablement state for the responder rule
        :param pulumi.Input[str] condition: The base condition resource.
        :param pulumi.Input[Sequence[pulumi.Input['ResponderRecipeResponderRuleDetailsConfigurationArgs']]] configurations: List of responder rule configurations
        :param pulumi.Input[str] mode: Execution mode for the responder rule
        """
        pulumi.set(__self__, "is_enabled", is_enabled)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        """
        (Updatable) Enablement state for the responder rule
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        The base condition resource.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ResponderRecipeResponderRuleDetailsConfigurationArgs']]]]:
        """
        List of responder rule configurations
        """
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ResponderRecipeResponderRuleDetailsConfigurationArgs']]]]):
        pulumi.set(self, "configurations", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Execution mode for the responder rule
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class ResponderRecipeResponderRuleDetailsConfigurationArgsDict(TypedDict):
        config_key: NotRequired[pulumi.Input[str]]
        """
        Unique identifier of the configuration
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Configuration name
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Configuration value
        """
elif False:
    ResponderRecipeResponderRuleDetailsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResponderRecipeResponderRuleDetailsConfigurationArgs:
    def __init__(__self__, *,
                 config_key: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] config_key: Unique identifier of the configuration
        :param pulumi.Input[str] name: Configuration name
        :param pulumi.Input[str] value: Configuration value
        """
        if config_key is not None:
            pulumi.set(__self__, "config_key", config_key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of the configuration
        """
        return pulumi.get(self, "config_key")

    @config_key.setter
    def config_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_key", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Configuration name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Configuration value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TargetTargetDetailArgsDict(TypedDict):
        security_zone_display_name: NotRequired[pulumi.Input[str]]
        """
        The name of the security zone to associate with this compartment.
        """
        security_zone_id: NotRequired[pulumi.Input[str]]
        """
        The OCID of the security zone to associate with this compartment
        """
        target_resource_type: NotRequired[pulumi.Input[str]]
        """
        Type of resource that target support (COMPARTMENT/FACLOUD)
        """
        target_security_zone_recipes: NotRequired[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetailTargetSecurityZoneRecipeArgsDict']]]]
        """
        The list of security zone recipes to associate with this compartment
        """
elif False:
    TargetTargetDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetTargetDetailArgs:
    def __init__(__self__, *,
                 security_zone_display_name: Optional[pulumi.Input[str]] = None,
                 security_zone_id: Optional[pulumi.Input[str]] = None,
                 target_resource_type: Optional[pulumi.Input[str]] = None,
                 target_security_zone_recipes: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetailTargetSecurityZoneRecipeArgs']]]] = None):
        """
        :param pulumi.Input[str] security_zone_display_name: The name of the security zone to associate with this compartment.
        :param pulumi.Input[str] security_zone_id: The OCID of the security zone to associate with this compartment
        :param pulumi.Input[str] target_resource_type: Type of resource that target support (COMPARTMENT/FACLOUD)
        :param pulumi.Input[Sequence[pulumi.Input['TargetTargetDetailTargetSecurityZoneRecipeArgs']]] target_security_zone_recipes: The list of security zone recipes to associate with this compartment
        """
        if security_zone_display_name is not None:
            pulumi.set(__self__, "security_zone_display_name", security_zone_display_name)
        if security_zone_id is not None:
            pulumi.set(__self__, "security_zone_id", security_zone_id)
        if target_resource_type is not None:
            pulumi.set(__self__, "target_resource_type", target_resource_type)
        if target_security_zone_recipes is not None:
            pulumi.set(__self__, "target_security_zone_recipes", target_security_zone_recipes)

    @property
    @pulumi.getter(name="securityZoneDisplayName")
    def security_zone_display_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the security zone to associate with this compartment.
        """
        return pulumi.get(self, "security_zone_display_name")

    @security_zone_display_name.setter
    def security_zone_display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_zone_display_name", value)

    @property
    @pulumi.getter(name="securityZoneId")
    def security_zone_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the security zone to associate with this compartment
        """
        return pulumi.get(self, "security_zone_id")

    @security_zone_id.setter
    def security_zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_zone_id", value)

    @property
    @pulumi.getter(name="targetResourceType")
    def target_resource_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of resource that target support (COMPARTMENT/FACLOUD)
        """
        return pulumi.get(self, "target_resource_type")

    @target_resource_type.setter
    def target_resource_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_resource_type", value)

    @property
    @pulumi.getter(name="targetSecurityZoneRecipes")
    def target_security_zone_recipes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetailTargetSecurityZoneRecipeArgs']]]]:
        """
        The list of security zone recipes to associate with this compartment
        """
        return pulumi.get(self, "target_security_zone_recipes")

    @target_security_zone_recipes.setter
    def target_security_zone_recipes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetailTargetSecurityZoneRecipeArgs']]]]):
        pulumi.set(self, "target_security_zone_recipes", value)


if not MYPY:
    class TargetTargetDetailTargetSecurityZoneRecipeArgsDict(TypedDict):
        compartment_id: NotRequired[pulumi.Input[str]]
        """
        Compartment OCID where the resource is created
        """
        defined_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The target description.

        Avoid entering confidential information.
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Display name for the target.

        Avoid entering confidential information.
        """
        freeform_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`

        Avoid entering confidential information.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Unique identifier of target responder recipe that can't be changed after creation
        """
        lifecycle_details: NotRequired[pulumi.Input[str]]
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        owner: NotRequired[pulumi.Input[str]]
        """
        Owner of target responder recipe
        """
        security_policies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of security policy IDs that are included in the recipe
        """
        state: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The enablement state of the detector rule
        """
        system_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). System tags can be viewed by users, but can only be created by the system.  Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        time_created: NotRequired[pulumi.Input[str]]
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        time_updated: NotRequired[pulumi.Input[str]]
        """
        The date and time the target was last updated. Format defined by RFC3339.
        """
elif False:
    TargetTargetDetailTargetSecurityZoneRecipeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetTargetDetailTargetSecurityZoneRecipeArgs:
    def __init__(__self__, *,
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 owner: Optional[pulumi.Input[str]] = None,
                 security_policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 system_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_updated: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compartment_id: Compartment OCID where the resource is created
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param pulumi.Input[str] description: The target description.
               
               Avoid entering confidential information.
        :param pulumi.Input[str] display_name: (Updatable) Display name for the target.
               
               Avoid entering confidential information.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] freeform_tags: (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
               
               Avoid entering confidential information.
        :param pulumi.Input[str] id: Unique identifier of target responder recipe that can't be changed after creation
        :param pulumi.Input[str] lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param pulumi.Input[str] owner: Owner of target responder recipe
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_policies: The list of security policy IDs that are included in the recipe
        :param pulumi.Input[str] state: (Updatable) The enablement state of the detector rule
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). System tags can be viewed by users, but can only be created by the system.  Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param pulumi.Input[str] time_created: The date and time the target was created. Format defined by RFC3339.
        :param pulumi.Input[str] time_updated: The date and time the target was last updated. Format defined by RFC3339.
        """
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if security_policies is not None:
            pulumi.set(__self__, "security_policies", security_policies)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if system_tags is not None:
            pulumi.set(__self__, "system_tags", system_tags)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        Compartment OCID where the resource is created
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The target description.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Display name for the target.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`

        Avoid entering confidential information.
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of target responder recipe that can't be changed after creation
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[pulumi.Input[str]]:
        """
        Owner of target responder recipe
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter(name="securityPolicies")
    def security_policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of security policy IDs that are included in the recipe
        """
        return pulumi.get(self, "security_policies")

    @security_policies.setter
    def security_policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_policies", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The enablement state of the detector rule
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). System tags can be viewed by users, but can only be created by the system.  Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @system_tags.setter
    def system_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "system_tags", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the target was last updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_updated", value)


if not MYPY:
    class TargetTargetDetectorRecipeArgsDict(TypedDict):
        detector_recipe_id: pulumi.Input[str]
        """
        Unique identifier for the target detector recipe
        """
        compartment_id: NotRequired[pulumi.Input[str]]
        """
        Compartment OCID where the resource is created
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The target description.

        Avoid entering confidential information.
        """
        detector: NotRequired[pulumi.Input[str]]
        """
        Detector type for the rule
        """
        detector_recipe_type: NotRequired[pulumi.Input[str]]
        """
        Recipe type ( STANDARD, ENTERPRISE )
        """
        detector_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeDetectorRuleArgsDict']]]]
        """
        (Updatable) List of overrides to be applied to detector rules associated with the target
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Display name for the target.

        Avoid entering confidential information.
        """
        effective_detector_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeEffectiveDetectorRuleArgsDict']]]]
        """
        List of currently enabled detector rules for the detector type for recipe after applying defaults
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Unique identifier of target responder recipe that can't be changed after creation
        """
        owner: NotRequired[pulumi.Input[str]]
        """
        Owner of target responder recipe
        """
        state: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The enablement state of the detector rule
        """
        time_created: NotRequired[pulumi.Input[str]]
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        time_updated: NotRequired[pulumi.Input[str]]
        """
        The date and time the target was last updated. Format defined by RFC3339.
        """
elif False:
    TargetTargetDetectorRecipeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetTargetDetectorRecipeArgs:
    def __init__(__self__, *,
                 detector_recipe_id: pulumi.Input[str],
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 detector: Optional[pulumi.Input[str]] = None,
                 detector_recipe_type: Optional[pulumi.Input[str]] = None,
                 detector_rules: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeDetectorRuleArgs']]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 effective_detector_rules: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeEffectiveDetectorRuleArgs']]]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 owner: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_updated: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] detector_recipe_id: Unique identifier for the target detector recipe
        :param pulumi.Input[str] compartment_id: Compartment OCID where the resource is created
        :param pulumi.Input[str] description: The target description.
               
               Avoid entering confidential information.
        :param pulumi.Input[str] detector: Detector type for the rule
        :param pulumi.Input[str] detector_recipe_type: Recipe type ( STANDARD, ENTERPRISE )
        :param pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeDetectorRuleArgs']]] detector_rules: (Updatable) List of overrides to be applied to detector rules associated with the target
        :param pulumi.Input[str] display_name: (Updatable) Display name for the target.
               
               Avoid entering confidential information.
        :param pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeEffectiveDetectorRuleArgs']]] effective_detector_rules: List of currently enabled detector rules for the detector type for recipe after applying defaults
        :param pulumi.Input[str] id: Unique identifier of target responder recipe that can't be changed after creation
        :param pulumi.Input[str] owner: Owner of target responder recipe
        :param pulumi.Input[str] state: (Updatable) The enablement state of the detector rule
        :param pulumi.Input[str] time_created: The date and time the target was created. Format defined by RFC3339.
        :param pulumi.Input[str] time_updated: The date and time the target was last updated. Format defined by RFC3339.
        """
        pulumi.set(__self__, "detector_recipe_id", detector_recipe_id)
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if detector is not None:
            pulumi.set(__self__, "detector", detector)
        if detector_recipe_type is not None:
            pulumi.set(__self__, "detector_recipe_type", detector_recipe_type)
        if detector_rules is not None:
            pulumi.set(__self__, "detector_rules", detector_rules)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if effective_detector_rules is not None:
            pulumi.set(__self__, "effective_detector_rules", effective_detector_rules)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="detectorRecipeId")
    def detector_recipe_id(self) -> pulumi.Input[str]:
        """
        Unique identifier for the target detector recipe
        """
        return pulumi.get(self, "detector_recipe_id")

    @detector_recipe_id.setter
    def detector_recipe_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "detector_recipe_id", value)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        Compartment OCID where the resource is created
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The target description.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def detector(self) -> Optional[pulumi.Input[str]]:
        """
        Detector type for the rule
        """
        return pulumi.get(self, "detector")

    @detector.setter
    def detector(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detector", value)

    @property
    @pulumi.getter(name="detectorRecipeType")
    def detector_recipe_type(self) -> Optional[pulumi.Input[str]]:
        """
        Recipe type ( STANDARD, ENTERPRISE )
        """
        return pulumi.get(self, "detector_recipe_type")

    @detector_recipe_type.setter
    def detector_recipe_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detector_recipe_type", value)

    @property
    @pulumi.getter(name="detectorRules")
    def detector_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeDetectorRuleArgs']]]]:
        """
        (Updatable) List of overrides to be applied to detector rules associated with the target
        """
        return pulumi.get(self, "detector_rules")

    @detector_rules.setter
    def detector_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeDetectorRuleArgs']]]]):
        pulumi.set(self, "detector_rules", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Display name for the target.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="effectiveDetectorRules")
    def effective_detector_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeEffectiveDetectorRuleArgs']]]]:
        """
        List of currently enabled detector rules for the detector type for recipe after applying defaults
        """
        return pulumi.get(self, "effective_detector_rules")

    @effective_detector_rules.setter
    def effective_detector_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeEffectiveDetectorRuleArgs']]]]):
        pulumi.set(self, "effective_detector_rules", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of target responder recipe that can't be changed after creation
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[pulumi.Input[str]]:
        """
        Owner of target responder recipe
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The enablement state of the detector rule
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the target was last updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_updated", value)


if not MYPY:
    class TargetTargetDetectorRecipeDetectorRuleArgsDict(TypedDict):
        details: pulumi.Input['TargetTargetDetectorRecipeDetectorRuleDetailsArgsDict']
        """
        (Updatable) Parameters to update detector rule configuration details in a detector recipe attached to a target.
        """
        detector_rule_id: pulumi.Input[str]
        """
        (Updatable) Unique identifier for the detector rule
        """
        data_source_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the attached data source
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The target description.

        Avoid entering confidential information.
        """
        detector: NotRequired[pulumi.Input[str]]
        """
        Detector type for the rule
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Display name for the target.

        Avoid entering confidential information.
        """
        entities_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeDetectorRuleEntitiesMappingArgsDict']]]]
        """
        Data source entities mapping for a detector rule
        """
        lifecycle_details: NotRequired[pulumi.Input[str]]
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        managed_list_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of managed list types related to this rule
        """
        recommendation: NotRequired[pulumi.Input[str]]
        """
        Recommendation for TargetDetectorRecipeDetectorRule resource
        """
        resource_type: NotRequired[pulumi.Input[str]]
        """
        The type of resource which is monitored by the detector rule. For example, Instance, Database, VCN, Policy. To find the resource type for a particular rule, see [Detector Recipe Reference] (/iaas/cloud-guard/using/detect-recipes.htm#detect-recipes-reference).
        """
        service_type: NotRequired[pulumi.Input[str]]
        """
        Service type of the configuration to which the rule is applied
        """
        state: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The enablement state of the detector rule
        """
        time_created: NotRequired[pulumi.Input[str]]
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        time_updated: NotRequired[pulumi.Input[str]]
        """
        The date and time the target was last updated. Format defined by RFC3339.
        """
elif False:
    TargetTargetDetectorRecipeDetectorRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetTargetDetectorRecipeDetectorRuleArgs:
    def __init__(__self__, *,
                 details: pulumi.Input['TargetTargetDetectorRecipeDetectorRuleDetailsArgs'],
                 detector_rule_id: pulumi.Input[str],
                 data_source_id: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 detector: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 entities_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeDetectorRuleEntitiesMappingArgs']]]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 managed_list_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 recommendation: Optional[pulumi.Input[str]] = None,
                 resource_type: Optional[pulumi.Input[str]] = None,
                 service_type: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_updated: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['TargetTargetDetectorRecipeDetectorRuleDetailsArgs'] details: (Updatable) Parameters to update detector rule configuration details in a detector recipe attached to a target.
        :param pulumi.Input[str] detector_rule_id: (Updatable) Unique identifier for the detector rule
        :param pulumi.Input[str] data_source_id: The ID of the attached data source
        :param pulumi.Input[str] description: The target description.
               
               Avoid entering confidential information.
        :param pulumi.Input[str] detector: Detector type for the rule
        :param pulumi.Input[str] display_name: (Updatable) Display name for the target.
               
               Avoid entering confidential information.
        :param pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeDetectorRuleEntitiesMappingArgs']]] entities_mappings: Data source entities mapping for a detector rule
        :param pulumi.Input[str] lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] managed_list_types: List of managed list types related to this rule
        :param pulumi.Input[str] recommendation: Recommendation for TargetDetectorRecipeDetectorRule resource
        :param pulumi.Input[str] resource_type: The type of resource which is monitored by the detector rule. For example, Instance, Database, VCN, Policy. To find the resource type for a particular rule, see [Detector Recipe Reference] (/iaas/cloud-guard/using/detect-recipes.htm#detect-recipes-reference).
        :param pulumi.Input[str] service_type: Service type of the configuration to which the rule is applied
        :param pulumi.Input[str] state: (Updatable) The enablement state of the detector rule
        :param pulumi.Input[str] time_created: The date and time the target was created. Format defined by RFC3339.
        :param pulumi.Input[str] time_updated: The date and time the target was last updated. Format defined by RFC3339.
        """
        pulumi.set(__self__, "details", details)
        pulumi.set(__self__, "detector_rule_id", detector_rule_id)
        if data_source_id is not None:
            pulumi.set(__self__, "data_source_id", data_source_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if detector is not None:
            pulumi.set(__self__, "detector", detector)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if entities_mappings is not None:
            pulumi.set(__self__, "entities_mappings", entities_mappings)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if managed_list_types is not None:
            pulumi.set(__self__, "managed_list_types", managed_list_types)
        if recommendation is not None:
            pulumi.set(__self__, "recommendation", recommendation)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if service_type is not None:
            pulumi.set(__self__, "service_type", service_type)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter
    def details(self) -> pulumi.Input['TargetTargetDetectorRecipeDetectorRuleDetailsArgs']:
        """
        (Updatable) Parameters to update detector rule configuration details in a detector recipe attached to a target.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: pulumi.Input['TargetTargetDetectorRecipeDetectorRuleDetailsArgs']):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter(name="detectorRuleId")
    def detector_rule_id(self) -> pulumi.Input[str]:
        """
        (Updatable) Unique identifier for the detector rule
        """
        return pulumi.get(self, "detector_rule_id")

    @detector_rule_id.setter
    def detector_rule_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "detector_rule_id", value)

    @property
    @pulumi.getter(name="dataSourceId")
    def data_source_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the attached data source
        """
        return pulumi.get(self, "data_source_id")

    @data_source_id.setter
    def data_source_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_source_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The target description.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def detector(self) -> Optional[pulumi.Input[str]]:
        """
        Detector type for the rule
        """
        return pulumi.get(self, "detector")

    @detector.setter
    def detector(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detector", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Display name for the target.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="entitiesMappings")
    def entities_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeDetectorRuleEntitiesMappingArgs']]]]:
        """
        Data source entities mapping for a detector rule
        """
        return pulumi.get(self, "entities_mappings")

    @entities_mappings.setter
    def entities_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeDetectorRuleEntitiesMappingArgs']]]]):
        pulumi.set(self, "entities_mappings", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter(name="managedListTypes")
    def managed_list_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of managed list types related to this rule
        """
        return pulumi.get(self, "managed_list_types")

    @managed_list_types.setter
    def managed_list_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "managed_list_types", value)

    @property
    @pulumi.getter
    def recommendation(self) -> Optional[pulumi.Input[str]]:
        """
        Recommendation for TargetDetectorRecipeDetectorRule resource
        """
        return pulumi.get(self, "recommendation")

    @recommendation.setter
    def recommendation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recommendation", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of resource which is monitored by the detector rule. For example, Instance, Database, VCN, Policy. To find the resource type for a particular rule, see [Detector Recipe Reference] (/iaas/cloud-guard/using/detect-recipes.htm#detect-recipes-reference).
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_type", value)

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> Optional[pulumi.Input[str]]:
        """
        Service type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "service_type")

    @service_type.setter
    def service_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_type", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The enablement state of the detector rule
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the target was last updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_updated", value)


if not MYPY:
    class TargetTargetDetectorRecipeDetectorRuleDetailsArgsDict(TypedDict):
        condition_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeDetectorRuleDetailsConditionGroupArgsDict']]]]
        """
        (Updatable) Condition group corresponding to each compartment
        """
        configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeDetectorRuleDetailsConfigurationArgsDict']]]]
        """
        List of responder rule configurations
        """
        is_configuration_allowed: NotRequired[pulumi.Input[bool]]
        """
        Configuration allowed or not
        """
        is_enabled: NotRequired[pulumi.Input[bool]]
        """
        Enabled state for the responder rule
        """
        labels: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        User-defined labels for a detector rule
        """
        risk_level: NotRequired[pulumi.Input[str]]
        """
        The risk level of the detector rule
        """
elif False:
    TargetTargetDetectorRecipeDetectorRuleDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetTargetDetectorRecipeDetectorRuleDetailsArgs:
    def __init__(__self__, *,
                 condition_groups: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeDetectorRuleDetailsConditionGroupArgs']]]] = None,
                 configurations: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeDetectorRuleDetailsConfigurationArgs']]]] = None,
                 is_configuration_allowed: Optional[pulumi.Input[bool]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 labels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 risk_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeDetectorRuleDetailsConditionGroupArgs']]] condition_groups: (Updatable) Condition group corresponding to each compartment
        :param pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeDetectorRuleDetailsConfigurationArgs']]] configurations: List of responder rule configurations
        :param pulumi.Input[bool] is_configuration_allowed: Configuration allowed or not
        :param pulumi.Input[bool] is_enabled: Enabled state for the responder rule
        :param pulumi.Input[Sequence[pulumi.Input[str]]] labels: User-defined labels for a detector rule
        :param pulumi.Input[str] risk_level: The risk level of the detector rule
        """
        if condition_groups is not None:
            pulumi.set(__self__, "condition_groups", condition_groups)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if is_configuration_allowed is not None:
            pulumi.set(__self__, "is_configuration_allowed", is_configuration_allowed)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if risk_level is not None:
            pulumi.set(__self__, "risk_level", risk_level)

    @property
    @pulumi.getter(name="conditionGroups")
    def condition_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeDetectorRuleDetailsConditionGroupArgs']]]]:
        """
        (Updatable) Condition group corresponding to each compartment
        """
        return pulumi.get(self, "condition_groups")

    @condition_groups.setter
    def condition_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeDetectorRuleDetailsConditionGroupArgs']]]]):
        pulumi.set(self, "condition_groups", value)

    @property
    @pulumi.getter
    def configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeDetectorRuleDetailsConfigurationArgs']]]]:
        """
        List of responder rule configurations
        """
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeDetectorRuleDetailsConfigurationArgs']]]]):
        pulumi.set(self, "configurations", value)

    @property
    @pulumi.getter(name="isConfigurationAllowed")
    def is_configuration_allowed(self) -> Optional[pulumi.Input[bool]]:
        """
        Configuration allowed or not
        """
        return pulumi.get(self, "is_configuration_allowed")

    @is_configuration_allowed.setter
    def is_configuration_allowed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_configuration_allowed", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enabled state for the responder rule
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        User-defined labels for a detector rule
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> Optional[pulumi.Input[str]]:
        """
        The risk level of the detector rule
        """
        return pulumi.get(self, "risk_level")

    @risk_level.setter
    def risk_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "risk_level", value)


if not MYPY:
    class TargetTargetDetectorRecipeDetectorRuleDetailsConditionGroupArgsDict(TypedDict):
        compartment_id: pulumi.Input[str]
        """
        (Updatable) Compartment OCID associated with condition
        """
        condition: pulumi.Input[str]
        """
        (Updatable) The base condition resource.
        """
elif False:
    TargetTargetDetectorRecipeDetectorRuleDetailsConditionGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetTargetDetectorRecipeDetectorRuleDetailsConditionGroupArgs:
    def __init__(__self__, *,
                 compartment_id: pulumi.Input[str],
                 condition: pulumi.Input[str]):
        """
        :param pulumi.Input[str] compartment_id: (Updatable) Compartment OCID associated with condition
        :param pulumi.Input[str] condition: (Updatable) The base condition resource.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "condition", condition)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> pulumi.Input[str]:
        """
        (Updatable) Compartment OCID associated with condition
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        (Updatable) The base condition resource.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)


if not MYPY:
    class TargetTargetDetectorRecipeDetectorRuleDetailsConfigurationArgsDict(TypedDict):
        config_key: NotRequired[pulumi.Input[str]]
        """
        Unique identifier of the configuration
        """
        data_type: NotRequired[pulumi.Input[str]]
        """
        Configuration data type
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Configuration name
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Configuration value
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeDetectorRuleDetailsConfigurationValueArgsDict']]]]
        """
        List of configuration values
        """
elif False:
    TargetTargetDetectorRecipeDetectorRuleDetailsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetTargetDetectorRecipeDetectorRuleDetailsConfigurationArgs:
    def __init__(__self__, *,
                 config_key: Optional[pulumi.Input[str]] = None,
                 data_type: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeDetectorRuleDetailsConfigurationValueArgs']]]] = None):
        """
        :param pulumi.Input[str] config_key: Unique identifier of the configuration
        :param pulumi.Input[str] data_type: Configuration data type
        :param pulumi.Input[str] name: Configuration name
        :param pulumi.Input[str] value: Configuration value
        :param pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeDetectorRuleDetailsConfigurationValueArgs']]] values: List of configuration values
        """
        if config_key is not None:
            pulumi.set(__self__, "config_key", config_key)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of the configuration
        """
        return pulumi.get(self, "config_key")

    @config_key.setter
    def config_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_key", value)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[pulumi.Input[str]]:
        """
        Configuration data type
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Configuration name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Configuration value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeDetectorRuleDetailsConfigurationValueArgs']]]]:
        """
        List of configuration values
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeDetectorRuleDetailsConfigurationValueArgs']]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class TargetTargetDetectorRecipeDetectorRuleDetailsConfigurationValueArgsDict(TypedDict):
        list_type: NotRequired[pulumi.Input[str]]
        """
        Configuration list item type (CUSTOM or MANAGED)
        """
        managed_list_type: NotRequired[pulumi.Input[str]]
        """
        Type of content in the managed list
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Configuration value
        """
elif False:
    TargetTargetDetectorRecipeDetectorRuleDetailsConfigurationValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetTargetDetectorRecipeDetectorRuleDetailsConfigurationValueArgs:
    def __init__(__self__, *,
                 list_type: Optional[pulumi.Input[str]] = None,
                 managed_list_type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] list_type: Configuration list item type (CUSTOM or MANAGED)
        :param pulumi.Input[str] managed_list_type: Type of content in the managed list
        :param pulumi.Input[str] value: Configuration value
        """
        if list_type is not None:
            pulumi.set(__self__, "list_type", list_type)
        if managed_list_type is not None:
            pulumi.set(__self__, "managed_list_type", managed_list_type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="listType")
    def list_type(self) -> Optional[pulumi.Input[str]]:
        """
        Configuration list item type (CUSTOM or MANAGED)
        """
        return pulumi.get(self, "list_type")

    @list_type.setter
    def list_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "list_type", value)

    @property
    @pulumi.getter(name="managedListType")
    def managed_list_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of content in the managed list
        """
        return pulumi.get(self, "managed_list_type")

    @managed_list_type.setter
    def managed_list_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "managed_list_type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Configuration value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TargetTargetDetectorRecipeDetectorRuleEntitiesMappingArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Display name for the target.

        Avoid entering confidential information.
        """
        entity_type: NotRequired[pulumi.Input[str]]
        """
        Type of entity
        """
        query_field: NotRequired[pulumi.Input[str]]
        """
        The entity value mapped to a data source query
        """
elif False:
    TargetTargetDetectorRecipeDetectorRuleEntitiesMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetTargetDetectorRecipeDetectorRuleEntitiesMappingArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 query_field: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] display_name: (Updatable) Display name for the target.
               
               Avoid entering confidential information.
        :param pulumi.Input[str] entity_type: Type of entity
        :param pulumi.Input[str] query_field: The entity value mapped to a data source query
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if query_field is not None:
            pulumi.set(__self__, "query_field", query_field)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Display name for the target.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of entity
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="queryField")
    def query_field(self) -> Optional[pulumi.Input[str]]:
        """
        The entity value mapped to a data source query
        """
        return pulumi.get(self, "query_field")

    @query_field.setter
    def query_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_field", value)


if not MYPY:
    class TargetTargetDetectorRecipeEffectiveDetectorRuleArgsDict(TypedDict):
        data_source_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the attached data source
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The target description.

        Avoid entering confidential information.
        """
        details: NotRequired[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeEffectiveDetectorRuleDetailArgsDict']]]]
        """
        Detailed information for a responder rule
        """
        detector: NotRequired[pulumi.Input[str]]
        """
        Detector type for the rule
        """
        detector_rule_id: NotRequired[pulumi.Input[str]]
        """
        The unique identifier of the detector rule
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Display name for the target.

        Avoid entering confidential information.
        """
        entities_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeEffectiveDetectorRuleEntitiesMappingArgsDict']]]]
        """
        Data source entities mapping for a detector rule
        """
        lifecycle_details: NotRequired[pulumi.Input[str]]
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        managed_list_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of managed list types related to this rule
        """
        recommendation: NotRequired[pulumi.Input[str]]
        """
        Recommendation for TargetDetectorRecipeDetectorRule resource
        """
        resource_type: NotRequired[pulumi.Input[str]]
        """
        The type of resource which is monitored by the detector rule. For example, Instance, Database, VCN, Policy. To find the resource type for a particular rule, see [Detector Recipe Reference] (/iaas/cloud-guard/using/detect-recipes.htm#detect-recipes-reference).
        """
        service_type: NotRequired[pulumi.Input[str]]
        """
        Service type of the configuration to which the rule is applied
        """
        state: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The enablement state of the detector rule
        """
        time_created: NotRequired[pulumi.Input[str]]
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        time_updated: NotRequired[pulumi.Input[str]]
        """
        The date and time the target was last updated. Format defined by RFC3339.
        """
elif False:
    TargetTargetDetectorRecipeEffectiveDetectorRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetTargetDetectorRecipeEffectiveDetectorRuleArgs:
    def __init__(__self__, *,
                 data_source_id: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 details: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeEffectiveDetectorRuleDetailArgs']]]] = None,
                 detector: Optional[pulumi.Input[str]] = None,
                 detector_rule_id: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 entities_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeEffectiveDetectorRuleEntitiesMappingArgs']]]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 managed_list_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 recommendation: Optional[pulumi.Input[str]] = None,
                 resource_type: Optional[pulumi.Input[str]] = None,
                 service_type: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_updated: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source_id: The ID of the attached data source
        :param pulumi.Input[str] description: The target description.
               
               Avoid entering confidential information.
        :param pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeEffectiveDetectorRuleDetailArgs']]] details: Detailed information for a responder rule
        :param pulumi.Input[str] detector: Detector type for the rule
        :param pulumi.Input[str] detector_rule_id: The unique identifier of the detector rule
        :param pulumi.Input[str] display_name: (Updatable) Display name for the target.
               
               Avoid entering confidential information.
        :param pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeEffectiveDetectorRuleEntitiesMappingArgs']]] entities_mappings: Data source entities mapping for a detector rule
        :param pulumi.Input[str] lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] managed_list_types: List of managed list types related to this rule
        :param pulumi.Input[str] recommendation: Recommendation for TargetDetectorRecipeDetectorRule resource
        :param pulumi.Input[str] resource_type: The type of resource which is monitored by the detector rule. For example, Instance, Database, VCN, Policy. To find the resource type for a particular rule, see [Detector Recipe Reference] (/iaas/cloud-guard/using/detect-recipes.htm#detect-recipes-reference).
        :param pulumi.Input[str] service_type: Service type of the configuration to which the rule is applied
        :param pulumi.Input[str] state: (Updatable) The enablement state of the detector rule
        :param pulumi.Input[str] time_created: The date and time the target was created. Format defined by RFC3339.
        :param pulumi.Input[str] time_updated: The date and time the target was last updated. Format defined by RFC3339.
        """
        if data_source_id is not None:
            pulumi.set(__self__, "data_source_id", data_source_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if detector is not None:
            pulumi.set(__self__, "detector", detector)
        if detector_rule_id is not None:
            pulumi.set(__self__, "detector_rule_id", detector_rule_id)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if entities_mappings is not None:
            pulumi.set(__self__, "entities_mappings", entities_mappings)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if managed_list_types is not None:
            pulumi.set(__self__, "managed_list_types", managed_list_types)
        if recommendation is not None:
            pulumi.set(__self__, "recommendation", recommendation)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if service_type is not None:
            pulumi.set(__self__, "service_type", service_type)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="dataSourceId")
    def data_source_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the attached data source
        """
        return pulumi.get(self, "data_source_id")

    @data_source_id.setter
    def data_source_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_source_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The target description.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeEffectiveDetectorRuleDetailArgs']]]]:
        """
        Detailed information for a responder rule
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeEffectiveDetectorRuleDetailArgs']]]]):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter
    def detector(self) -> Optional[pulumi.Input[str]]:
        """
        Detector type for the rule
        """
        return pulumi.get(self, "detector")

    @detector.setter
    def detector(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detector", value)

    @property
    @pulumi.getter(name="detectorRuleId")
    def detector_rule_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique identifier of the detector rule
        """
        return pulumi.get(self, "detector_rule_id")

    @detector_rule_id.setter
    def detector_rule_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detector_rule_id", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Display name for the target.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="entitiesMappings")
    def entities_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeEffectiveDetectorRuleEntitiesMappingArgs']]]]:
        """
        Data source entities mapping for a detector rule
        """
        return pulumi.get(self, "entities_mappings")

    @entities_mappings.setter
    def entities_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeEffectiveDetectorRuleEntitiesMappingArgs']]]]):
        pulumi.set(self, "entities_mappings", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter(name="managedListTypes")
    def managed_list_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of managed list types related to this rule
        """
        return pulumi.get(self, "managed_list_types")

    @managed_list_types.setter
    def managed_list_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "managed_list_types", value)

    @property
    @pulumi.getter
    def recommendation(self) -> Optional[pulumi.Input[str]]:
        """
        Recommendation for TargetDetectorRecipeDetectorRule resource
        """
        return pulumi.get(self, "recommendation")

    @recommendation.setter
    def recommendation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recommendation", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of resource which is monitored by the detector rule. For example, Instance, Database, VCN, Policy. To find the resource type for a particular rule, see [Detector Recipe Reference] (/iaas/cloud-guard/using/detect-recipes.htm#detect-recipes-reference).
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_type", value)

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> Optional[pulumi.Input[str]]:
        """
        Service type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "service_type")

    @service_type.setter
    def service_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_type", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The enablement state of the detector rule
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the target was last updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_updated", value)


if not MYPY:
    class TargetTargetDetectorRecipeEffectiveDetectorRuleDetailArgsDict(TypedDict):
        condition_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroupArgsDict']]]]
        """
        Condition group corresponding to each compartment
        """
        configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationArgsDict']]]]
        """
        List of responder rule configurations
        """
        is_configuration_allowed: NotRequired[pulumi.Input[bool]]
        """
        Configuration allowed or not
        """
        is_enabled: NotRequired[pulumi.Input[bool]]
        """
        Enabled state for the responder rule
        """
        labels: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        User-defined labels for a detector rule
        """
        risk_level: NotRequired[pulumi.Input[str]]
        """
        The risk level of the detector rule
        """
elif False:
    TargetTargetDetectorRecipeEffectiveDetectorRuleDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetTargetDetectorRecipeEffectiveDetectorRuleDetailArgs:
    def __init__(__self__, *,
                 condition_groups: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroupArgs']]]] = None,
                 configurations: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationArgs']]]] = None,
                 is_configuration_allowed: Optional[pulumi.Input[bool]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 labels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 risk_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroupArgs']]] condition_groups: Condition group corresponding to each compartment
        :param pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationArgs']]] configurations: List of responder rule configurations
        :param pulumi.Input[bool] is_configuration_allowed: Configuration allowed or not
        :param pulumi.Input[bool] is_enabled: Enabled state for the responder rule
        :param pulumi.Input[Sequence[pulumi.Input[str]]] labels: User-defined labels for a detector rule
        :param pulumi.Input[str] risk_level: The risk level of the detector rule
        """
        if condition_groups is not None:
            pulumi.set(__self__, "condition_groups", condition_groups)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if is_configuration_allowed is not None:
            pulumi.set(__self__, "is_configuration_allowed", is_configuration_allowed)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if risk_level is not None:
            pulumi.set(__self__, "risk_level", risk_level)

    @property
    @pulumi.getter(name="conditionGroups")
    def condition_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroupArgs']]]]:
        """
        Condition group corresponding to each compartment
        """
        return pulumi.get(self, "condition_groups")

    @condition_groups.setter
    def condition_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroupArgs']]]]):
        pulumi.set(self, "condition_groups", value)

    @property
    @pulumi.getter
    def configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationArgs']]]]:
        """
        List of responder rule configurations
        """
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationArgs']]]]):
        pulumi.set(self, "configurations", value)

    @property
    @pulumi.getter(name="isConfigurationAllowed")
    def is_configuration_allowed(self) -> Optional[pulumi.Input[bool]]:
        """
        Configuration allowed or not
        """
        return pulumi.get(self, "is_configuration_allowed")

    @is_configuration_allowed.setter
    def is_configuration_allowed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_configuration_allowed", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enabled state for the responder rule
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        User-defined labels for a detector rule
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> Optional[pulumi.Input[str]]:
        """
        The risk level of the detector rule
        """
        return pulumi.get(self, "risk_level")

    @risk_level.setter
    def risk_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "risk_level", value)


if not MYPY:
    class TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroupArgsDict(TypedDict):
        compartment_id: NotRequired[pulumi.Input[str]]
        """
        Compartment OCID where the resource is created
        """
        condition: NotRequired[pulumi.Input[str]]
        """
        The base condition resource.
        """
elif False:
    TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroupArgs:
    def __init__(__self__, *,
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 condition: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compartment_id: Compartment OCID where the resource is created
        :param pulumi.Input[str] condition: The base condition resource.
        """
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        Compartment OCID where the resource is created
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        The base condition resource.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)


if not MYPY:
    class TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationArgsDict(TypedDict):
        config_key: NotRequired[pulumi.Input[str]]
        """
        Unique identifier of the configuration
        """
        data_type: NotRequired[pulumi.Input[str]]
        """
        Configuration data type
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Configuration name
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Configuration value
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueArgsDict']]]]
        """
        List of configuration values
        """
elif False:
    TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationArgs:
    def __init__(__self__, *,
                 config_key: Optional[pulumi.Input[str]] = None,
                 data_type: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueArgs']]]] = None):
        """
        :param pulumi.Input[str] config_key: Unique identifier of the configuration
        :param pulumi.Input[str] data_type: Configuration data type
        :param pulumi.Input[str] name: Configuration name
        :param pulumi.Input[str] value: Configuration value
        :param pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueArgs']]] values: List of configuration values
        """
        if config_key is not None:
            pulumi.set(__self__, "config_key", config_key)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of the configuration
        """
        return pulumi.get(self, "config_key")

    @config_key.setter
    def config_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_key", value)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[pulumi.Input[str]]:
        """
        Configuration data type
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Configuration name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Configuration value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueArgs']]]]:
        """
        List of configuration values
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueArgs']]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueArgsDict(TypedDict):
        list_type: NotRequired[pulumi.Input[str]]
        """
        Configuration list item type (CUSTOM or MANAGED)
        """
        managed_list_type: NotRequired[pulumi.Input[str]]
        """
        Type of content in the managed list
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Configuration value
        """
elif False:
    TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueArgs:
    def __init__(__self__, *,
                 list_type: Optional[pulumi.Input[str]] = None,
                 managed_list_type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] list_type: Configuration list item type (CUSTOM or MANAGED)
        :param pulumi.Input[str] managed_list_type: Type of content in the managed list
        :param pulumi.Input[str] value: Configuration value
        """
        if list_type is not None:
            pulumi.set(__self__, "list_type", list_type)
        if managed_list_type is not None:
            pulumi.set(__self__, "managed_list_type", managed_list_type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="listType")
    def list_type(self) -> Optional[pulumi.Input[str]]:
        """
        Configuration list item type (CUSTOM or MANAGED)
        """
        return pulumi.get(self, "list_type")

    @list_type.setter
    def list_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "list_type", value)

    @property
    @pulumi.getter(name="managedListType")
    def managed_list_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of content in the managed list
        """
        return pulumi.get(self, "managed_list_type")

    @managed_list_type.setter
    def managed_list_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "managed_list_type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Configuration value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TargetTargetDetectorRecipeEffectiveDetectorRuleEntitiesMappingArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Display name for the target.

        Avoid entering confidential information.
        """
        entity_type: NotRequired[pulumi.Input[str]]
        """
        Type of entity
        """
        query_field: NotRequired[pulumi.Input[str]]
        """
        The entity value mapped to a data source query
        """
elif False:
    TargetTargetDetectorRecipeEffectiveDetectorRuleEntitiesMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetTargetDetectorRecipeEffectiveDetectorRuleEntitiesMappingArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 query_field: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] display_name: (Updatable) Display name for the target.
               
               Avoid entering confidential information.
        :param pulumi.Input[str] entity_type: Type of entity
        :param pulumi.Input[str] query_field: The entity value mapped to a data source query
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if query_field is not None:
            pulumi.set(__self__, "query_field", query_field)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Display name for the target.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of entity
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="queryField")
    def query_field(self) -> Optional[pulumi.Input[str]]:
        """
        The entity value mapped to a data source query
        """
        return pulumi.get(self, "query_field")

    @query_field.setter
    def query_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_field", value)


if not MYPY:
    class TargetTargetResponderRecipeArgsDict(TypedDict):
        responder_recipe_id: pulumi.Input[str]
        """
        Unique identifier for responder recipe
        """
        compartment_id: NotRequired[pulumi.Input[str]]
        """
        Compartment OCID where the resource is created
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The target description.

        Avoid entering confidential information.
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Display name for the target.

        Avoid entering confidential information.
        """
        effective_responder_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['TargetTargetResponderRecipeEffectiveResponderRuleArgsDict']]]]
        """
        List of currently enabled responder rules for the responder type for recipe after applying defaults
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Unique identifier of target responder recipe that can't be changed after creation
        """
        owner: NotRequired[pulumi.Input[str]]
        """
        Owner of target responder recipe
        """
        responder_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['TargetTargetResponderRecipeResponderRuleArgsDict']]]]
        """
        (Updatable) List of overrides to be applied to responder rules associated with the target
        """
        time_created: NotRequired[pulumi.Input[str]]
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        time_updated: NotRequired[pulumi.Input[str]]
        """
        The date and time the target was last updated. Format defined by RFC3339.
        """
elif False:
    TargetTargetResponderRecipeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetTargetResponderRecipeArgs:
    def __init__(__self__, *,
                 responder_recipe_id: pulumi.Input[str],
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 effective_responder_rules: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetResponderRecipeEffectiveResponderRuleArgs']]]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 owner: Optional[pulumi.Input[str]] = None,
                 responder_rules: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetResponderRecipeResponderRuleArgs']]]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_updated: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] responder_recipe_id: Unique identifier for responder recipe
        :param pulumi.Input[str] compartment_id: Compartment OCID where the resource is created
        :param pulumi.Input[str] description: The target description.
               
               Avoid entering confidential information.
        :param pulumi.Input[str] display_name: (Updatable) Display name for the target.
               
               Avoid entering confidential information.
        :param pulumi.Input[Sequence[pulumi.Input['TargetTargetResponderRecipeEffectiveResponderRuleArgs']]] effective_responder_rules: List of currently enabled responder rules for the responder type for recipe after applying defaults
        :param pulumi.Input[str] id: Unique identifier of target responder recipe that can't be changed after creation
        :param pulumi.Input[str] owner: Owner of target responder recipe
        :param pulumi.Input[Sequence[pulumi.Input['TargetTargetResponderRecipeResponderRuleArgs']]] responder_rules: (Updatable) List of overrides to be applied to responder rules associated with the target
        :param pulumi.Input[str] time_created: The date and time the target was created. Format defined by RFC3339.
        :param pulumi.Input[str] time_updated: The date and time the target was last updated. Format defined by RFC3339.
        """
        pulumi.set(__self__, "responder_recipe_id", responder_recipe_id)
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if effective_responder_rules is not None:
            pulumi.set(__self__, "effective_responder_rules", effective_responder_rules)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if responder_rules is not None:
            pulumi.set(__self__, "responder_rules", responder_rules)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="responderRecipeId")
    def responder_recipe_id(self) -> pulumi.Input[str]:
        """
        Unique identifier for responder recipe
        """
        return pulumi.get(self, "responder_recipe_id")

    @responder_recipe_id.setter
    def responder_recipe_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "responder_recipe_id", value)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        Compartment OCID where the resource is created
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The target description.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Display name for the target.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="effectiveResponderRules")
    def effective_responder_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetResponderRecipeEffectiveResponderRuleArgs']]]]:
        """
        List of currently enabled responder rules for the responder type for recipe after applying defaults
        """
        return pulumi.get(self, "effective_responder_rules")

    @effective_responder_rules.setter
    def effective_responder_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetResponderRecipeEffectiveResponderRuleArgs']]]]):
        pulumi.set(self, "effective_responder_rules", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of target responder recipe that can't be changed after creation
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[pulumi.Input[str]]:
        """
        Owner of target responder recipe
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter(name="responderRules")
    def responder_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetResponderRecipeResponderRuleArgs']]]]:
        """
        (Updatable) List of overrides to be applied to responder rules associated with the target
        """
        return pulumi.get(self, "responder_rules")

    @responder_rules.setter
    def responder_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetResponderRecipeResponderRuleArgs']]]]):
        pulumi.set(self, "responder_rules", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the target was last updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_updated", value)


if not MYPY:
    class TargetTargetResponderRecipeEffectiveResponderRuleArgsDict(TypedDict):
        compartment_id: NotRequired[pulumi.Input[str]]
        """
        Compartment OCID where the resource is created
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The target description.

        Avoid entering confidential information.
        """
        details: NotRequired[pulumi.Input[Sequence[pulumi.Input['TargetTargetResponderRecipeEffectiveResponderRuleDetailArgsDict']]]]
        """
        Detailed information for a responder rule
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Display name for the target.

        Avoid entering confidential information.
        """
        lifecycle_details: NotRequired[pulumi.Input[str]]
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of policies
        """
        responder_rule_id: NotRequired[pulumi.Input[str]]
        """
        Unique identifier for the responder rule
        """
        state: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The enablement state of the detector rule
        """
        supported_modes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Supported execution modes for the responder rule
        """
        time_created: NotRequired[pulumi.Input[str]]
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        time_updated: NotRequired[pulumi.Input[str]]
        """
        The date and time the target was last updated. Format defined by RFC3339.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of responder
        """
elif False:
    TargetTargetResponderRecipeEffectiveResponderRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetTargetResponderRecipeEffectiveResponderRuleArgs:
    def __init__(__self__, *,
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 details: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetResponderRecipeEffectiveResponderRuleDetailArgs']]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 responder_rule_id: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 supported_modes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_updated: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compartment_id: Compartment OCID where the resource is created
        :param pulumi.Input[str] description: The target description.
               
               Avoid entering confidential information.
        :param pulumi.Input[Sequence[pulumi.Input['TargetTargetResponderRecipeEffectiveResponderRuleDetailArgs']]] details: Detailed information for a responder rule
        :param pulumi.Input[str] display_name: (Updatable) Display name for the target.
               
               Avoid entering confidential information.
        :param pulumi.Input[str] lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] policies: List of policies
        :param pulumi.Input[str] responder_rule_id: Unique identifier for the responder rule
        :param pulumi.Input[str] state: (Updatable) The enablement state of the detector rule
        :param pulumi.Input[Sequence[pulumi.Input[str]]] supported_modes: Supported execution modes for the responder rule
        :param pulumi.Input[str] time_created: The date and time the target was created. Format defined by RFC3339.
        :param pulumi.Input[str] time_updated: The date and time the target was last updated. Format defined by RFC3339.
        :param pulumi.Input[str] type: Type of responder
        """
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if responder_rule_id is not None:
            pulumi.set(__self__, "responder_rule_id", responder_rule_id)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if supported_modes is not None:
            pulumi.set(__self__, "supported_modes", supported_modes)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        Compartment OCID where the resource is created
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The target description.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetResponderRecipeEffectiveResponderRuleDetailArgs']]]]:
        """
        Detailed information for a responder rule
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetResponderRecipeEffectiveResponderRuleDetailArgs']]]]):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Display name for the target.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of policies
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "policies", value)

    @property
    @pulumi.getter(name="responderRuleId")
    def responder_rule_id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier for the responder rule
        """
        return pulumi.get(self, "responder_rule_id")

    @responder_rule_id.setter
    def responder_rule_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "responder_rule_id", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The enablement state of the detector rule
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="supportedModes")
    def supported_modes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Supported execution modes for the responder rule
        """
        return pulumi.get(self, "supported_modes")

    @supported_modes.setter
    def supported_modes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "supported_modes", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the target was last updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_updated", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of responder
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class TargetTargetResponderRecipeEffectiveResponderRuleDetailArgsDict(TypedDict):
        condition: NotRequired[pulumi.Input[str]]
        """
        The base condition resource.
        """
        configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['TargetTargetResponderRecipeEffectiveResponderRuleDetailConfigurationArgsDict']]]]
        """
        List of responder rule configurations
        """
        is_enabled: NotRequired[pulumi.Input[bool]]
        """
        Enabled state for the responder rule
        """
        mode: NotRequired[pulumi.Input[str]]
        """
        Execution mode for the responder rule
        """
elif False:
    TargetTargetResponderRecipeEffectiveResponderRuleDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetTargetResponderRecipeEffectiveResponderRuleDetailArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input[str]] = None,
                 configurations: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetResponderRecipeEffectiveResponderRuleDetailConfigurationArgs']]]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] condition: The base condition resource.
        :param pulumi.Input[Sequence[pulumi.Input['TargetTargetResponderRecipeEffectiveResponderRuleDetailConfigurationArgs']]] configurations: List of responder rule configurations
        :param pulumi.Input[bool] is_enabled: Enabled state for the responder rule
        :param pulumi.Input[str] mode: Execution mode for the responder rule
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        The base condition resource.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetResponderRecipeEffectiveResponderRuleDetailConfigurationArgs']]]]:
        """
        List of responder rule configurations
        """
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetResponderRecipeEffectiveResponderRuleDetailConfigurationArgs']]]]):
        pulumi.set(self, "configurations", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enabled state for the responder rule
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Execution mode for the responder rule
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class TargetTargetResponderRecipeEffectiveResponderRuleDetailConfigurationArgsDict(TypedDict):
        config_key: NotRequired[pulumi.Input[str]]
        """
        Unique identifier of the configuration
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Configuration name
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Configuration value
        """
elif False:
    TargetTargetResponderRecipeEffectiveResponderRuleDetailConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetTargetResponderRecipeEffectiveResponderRuleDetailConfigurationArgs:
    def __init__(__self__, *,
                 config_key: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] config_key: Unique identifier of the configuration
        :param pulumi.Input[str] name: Configuration name
        :param pulumi.Input[str] value: Configuration value
        """
        if config_key is not None:
            pulumi.set(__self__, "config_key", config_key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of the configuration
        """
        return pulumi.get(self, "config_key")

    @config_key.setter
    def config_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_key", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Configuration name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Configuration value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TargetTargetResponderRecipeResponderRuleArgsDict(TypedDict):
        details: pulumi.Input['TargetTargetResponderRecipeResponderRuleDetailsArgsDict']
        """
        (Updatable) Parameters to update details for a responder rule for a target responder recipe. TargetResponderRuleDetails contains all configurations associated with the ResponderRule, whereas UpdateTargetResponderRecipeResponderRuleDetails refers to the details that are to be updated for ResponderRule.
        """
        responder_rule_id: pulumi.Input[str]
        """
        (Updatable) Unique identifier for target detector recipe


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        compartment_id: NotRequired[pulumi.Input[str]]
        """
        Compartment OCID where the resource is created
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The target description.

        Avoid entering confidential information.
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Display name for the target.

        Avoid entering confidential information.
        """
        lifecycle_details: NotRequired[pulumi.Input[str]]
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of policies
        """
        state: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The enablement state of the detector rule
        """
        supported_modes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Supported execution modes for the responder rule
        """
        time_created: NotRequired[pulumi.Input[str]]
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        time_updated: NotRequired[pulumi.Input[str]]
        """
        The date and time the target was last updated. Format defined by RFC3339.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of responder
        """
elif False:
    TargetTargetResponderRecipeResponderRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetTargetResponderRecipeResponderRuleArgs:
    def __init__(__self__, *,
                 details: pulumi.Input['TargetTargetResponderRecipeResponderRuleDetailsArgs'],
                 responder_rule_id: pulumi.Input[str],
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 supported_modes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_updated: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['TargetTargetResponderRecipeResponderRuleDetailsArgs'] details: (Updatable) Parameters to update details for a responder rule for a target responder recipe. TargetResponderRuleDetails contains all configurations associated with the ResponderRule, whereas UpdateTargetResponderRecipeResponderRuleDetails refers to the details that are to be updated for ResponderRule.
        :param pulumi.Input[str] responder_rule_id: (Updatable) Unique identifier for target detector recipe
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param pulumi.Input[str] compartment_id: Compartment OCID where the resource is created
        :param pulumi.Input[str] description: The target description.
               
               Avoid entering confidential information.
        :param pulumi.Input[str] display_name: (Updatable) Display name for the target.
               
               Avoid entering confidential information.
        :param pulumi.Input[str] lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] policies: List of policies
        :param pulumi.Input[str] state: (Updatable) The enablement state of the detector rule
        :param pulumi.Input[Sequence[pulumi.Input[str]]] supported_modes: Supported execution modes for the responder rule
        :param pulumi.Input[str] time_created: The date and time the target was created. Format defined by RFC3339.
        :param pulumi.Input[str] time_updated: The date and time the target was last updated. Format defined by RFC3339.
        :param pulumi.Input[str] type: Type of responder
        """
        pulumi.set(__self__, "details", details)
        pulumi.set(__self__, "responder_rule_id", responder_rule_id)
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if supported_modes is not None:
            pulumi.set(__self__, "supported_modes", supported_modes)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def details(self) -> pulumi.Input['TargetTargetResponderRecipeResponderRuleDetailsArgs']:
        """
        (Updatable) Parameters to update details for a responder rule for a target responder recipe. TargetResponderRuleDetails contains all configurations associated with the ResponderRule, whereas UpdateTargetResponderRecipeResponderRuleDetails refers to the details that are to be updated for ResponderRule.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: pulumi.Input['TargetTargetResponderRecipeResponderRuleDetailsArgs']):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter(name="responderRuleId")
    def responder_rule_id(self) -> pulumi.Input[str]:
        """
        (Updatable) Unique identifier for target detector recipe


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "responder_rule_id")

    @responder_rule_id.setter
    def responder_rule_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "responder_rule_id", value)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        Compartment OCID where the resource is created
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The target description.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Display name for the target.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of policies
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "policies", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The enablement state of the detector rule
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="supportedModes")
    def supported_modes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Supported execution modes for the responder rule
        """
        return pulumi.get(self, "supported_modes")

    @supported_modes.setter
    def supported_modes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "supported_modes", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the target was last updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_updated", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of responder
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class TargetTargetResponderRecipeResponderRuleDetailsArgsDict(TypedDict):
        condition: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The base condition resource.
        """
        configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['TargetTargetResponderRecipeResponderRuleDetailsConfigurationArgsDict']]]]
        """
        (Updatable) List of responder rule configurations
        """
        is_enabled: NotRequired[pulumi.Input[bool]]
        """
        Enabled state for the responder rule
        """
        mode: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Execution mode for the responder rule
        """
elif False:
    TargetTargetResponderRecipeResponderRuleDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetTargetResponderRecipeResponderRuleDetailsArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input[str]] = None,
                 configurations: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetResponderRecipeResponderRuleDetailsConfigurationArgs']]]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] condition: (Updatable) The base condition resource.
        :param pulumi.Input[Sequence[pulumi.Input['TargetTargetResponderRecipeResponderRuleDetailsConfigurationArgs']]] configurations: (Updatable) List of responder rule configurations
        :param pulumi.Input[bool] is_enabled: Enabled state for the responder rule
        :param pulumi.Input[str] mode: (Updatable) Execution mode for the responder rule
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The base condition resource.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetResponderRecipeResponderRuleDetailsConfigurationArgs']]]]:
        """
        (Updatable) List of responder rule configurations
        """
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TargetTargetResponderRecipeResponderRuleDetailsConfigurationArgs']]]]):
        pulumi.set(self, "configurations", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enabled state for the responder rule
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Execution mode for the responder rule
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class TargetTargetResponderRecipeResponderRuleDetailsConfigurationArgsDict(TypedDict):
        config_key: pulumi.Input[str]
        """
        (Updatable) Unique identifier of the configuration
        """
        name: pulumi.Input[str]
        """
        (Updatable) Configuration name
        """
        value: pulumi.Input[str]
        """
        (Updatable) Configuration value
        """
elif False:
    TargetTargetResponderRecipeResponderRuleDetailsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetTargetResponderRecipeResponderRuleDetailsConfigurationArgs:
    def __init__(__self__, *,
                 config_key: pulumi.Input[str],
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] config_key: (Updatable) Unique identifier of the configuration
        :param pulumi.Input[str] name: (Updatable) Configuration name
        :param pulumi.Input[str] value: (Updatable) Configuration value
        """
        pulumi.set(__self__, "config_key", config_key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> pulumi.Input[str]:
        """
        (Updatable) Unique identifier of the configuration
        """
        return pulumi.get(self, "config_key")

    @config_key.setter
    def config_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "config_key", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Configuration name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        (Updatable) Configuration value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetAdhocQueriesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetAdhocQueriesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAdhocQueriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDataMaskRulesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        """
        Types of targets
        """
        regex: NotRequired[bool]
elif False:
    GetDataMaskRulesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDataMaskRulesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param Sequence[str] values: Types of targets
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Types of targets
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDataSourceEventsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDataSourceEventsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDataSourceEventsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDataSourcesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDataSourcesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDataSourcesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDetectorRecipesFilterArgsDict(TypedDict):
        name: str
        """
        Configuration name
        """
        values: Sequence[str]
        """
        List of configuration values
        """
        regex: NotRequired[bool]
elif False:
    GetDetectorRecipesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDetectorRecipesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Configuration name
        :param Sequence[str] values: List of configuration values
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Configuration name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        List of configuration values
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetGuardTargetsFilterArgsDict(TypedDict):
        name: str
        """
        Configuration name
        """
        values: Sequence[str]
        """
        List of configuration values
        """
        regex: NotRequired[bool]
elif False:
    GetGuardTargetsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGuardTargetsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Configuration name
        :param Sequence[str] values: List of configuration values
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Configuration name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        List of configuration values
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagedListsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetManagedListsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedListsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetProblemEntitiesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetProblemEntitiesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProblemEntitiesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetResponderRecipesFilterArgsDict(TypedDict):
        name: str
        """
        Configuration name
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetResponderRecipesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetResponderRecipesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Configuration name
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Configuration name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSavedQueriesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetSavedQueriesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSavedQueriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSecurityPoliciesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetSecurityPoliciesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecurityPoliciesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSecurityRecipesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetSecurityRecipesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecurityRecipesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSecurityZonesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetSecurityZonesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecurityZonesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetWlpAgentsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetWlpAgentsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWlpAgentsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


