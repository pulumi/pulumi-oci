# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'CloudGuardDataSourceDataSourceDetails',
    'CloudGuardDataSourceDataSourceDetailsLoggingQueryDetails',
    'CloudGuardDataSourceDataSourceDetailsQueryStartTime',
    'CloudGuardDataSourceDataSourceDetectorMappingInfo',
    'CloudGuardDataSourceRegionStatusDetail',
    'DataMaskRuleTargetSelected',
    'DetectorRecipeDetectorRule',
    'DetectorRecipeDetectorRuleCandidateResponderRule',
    'DetectorRecipeDetectorRuleDetails',
    'DetectorRecipeDetectorRuleDetailsConfiguration',
    'DetectorRecipeDetectorRuleDetailsConfigurationValue',
    'DetectorRecipeDetectorRuleDetailsEntitiesMapping',
    'DetectorRecipeDetectorRuleEntitiesMapping',
    'DetectorRecipeEffectiveDetectorRule',
    'DetectorRecipeEffectiveDetectorRuleCandidateResponderRule',
    'DetectorRecipeEffectiveDetectorRuleDetail',
    'DetectorRecipeEffectiveDetectorRuleDetailConfiguration',
    'DetectorRecipeEffectiveDetectorRuleDetailConfigurationValue',
    'DetectorRecipeEffectiveDetectorRuleEntitiesMapping',
    'ResponderRecipeEffectiveResponderRule',
    'ResponderRecipeEffectiveResponderRuleDetail',
    'ResponderRecipeEffectiveResponderRuleDetailConfiguration',
    'ResponderRecipeResponderRule',
    'ResponderRecipeResponderRuleDetails',
    'ResponderRecipeResponderRuleDetailsConfiguration',
    'TargetTargetDetail',
    'TargetTargetDetailTargetSecurityZoneRecipe',
    'TargetTargetDetectorRecipe',
    'TargetTargetDetectorRecipeDetectorRule',
    'TargetTargetDetectorRecipeDetectorRuleDetails',
    'TargetTargetDetectorRecipeDetectorRuleDetailsConditionGroup',
    'TargetTargetDetectorRecipeDetectorRuleDetailsConfiguration',
    'TargetTargetDetectorRecipeDetectorRuleDetailsConfigurationValue',
    'TargetTargetDetectorRecipeDetectorRuleEntitiesMapping',
    'TargetTargetDetectorRecipeEffectiveDetectorRule',
    'TargetTargetDetectorRecipeEffectiveDetectorRuleDetail',
    'TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroup',
    'TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfiguration',
    'TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValue',
    'TargetTargetDetectorRecipeEffectiveDetectorRuleEntitiesMapping',
    'TargetTargetResponderRecipe',
    'TargetTargetResponderRecipeEffectiveResponderRule',
    'TargetTargetResponderRecipeEffectiveResponderRuleDetail',
    'TargetTargetResponderRecipeEffectiveResponderRuleDetailConfiguration',
    'TargetTargetResponderRecipeResponderRule',
    'TargetTargetResponderRecipeResponderRuleDetails',
    'TargetTargetResponderRecipeResponderRuleDetailsConfiguration',
    'GetDataMaskRuleTargetSelectedResult',
    'GetDataMaskRulesDataMaskRuleCollectionResult',
    'GetDataMaskRulesDataMaskRuleCollectionItemResult',
    'GetDataMaskRulesDataMaskRuleCollectionItemTargetSelectedResult',
    'GetDataMaskRulesFilterResult',
    'GetDataSourceDataSourceDetailResult',
    'GetDataSourceDataSourceDetailLoggingQueryDetailResult',
    'GetDataSourceDataSourceDetailQueryStartTimeResult',
    'GetDataSourceDataSourceDetectorMappingInfoResult',
    'GetDataSourceEventItemResult',
    'GetDataSourceEventItemEventInfoResult',
    'GetDataSourceEventsDataSourceEventCollectionResult',
    'GetDataSourceEventsDataSourceEventCollectionItemResult',
    'GetDataSourceEventsDataSourceEventCollectionItemEventInfoResult',
    'GetDataSourceEventsFilterResult',
    'GetDataSourceRegionStatusDetailResult',
    'GetDataSourcesDataSourceCollectionResult',
    'GetDataSourcesDataSourceCollectionItemResult',
    'GetDataSourcesDataSourceCollectionItemDataSourceDetailResult',
    'GetDataSourcesDataSourceCollectionItemDataSourceDetailLoggingQueryDetailResult',
    'GetDataSourcesDataSourceCollectionItemDataSourceDetailQueryStartTimeResult',
    'GetDataSourcesDataSourceCollectionItemDataSourceDetectorMappingInfoResult',
    'GetDataSourcesDataSourceCollectionItemRegionStatusDetailResult',
    'GetDataSourcesFilterResult',
    'GetDetectorRecipeDetectorRuleResult',
    'GetDetectorRecipeDetectorRuleCandidateResponderRuleResult',
    'GetDetectorRecipeDetectorRuleDetailResult',
    'GetDetectorRecipeDetectorRuleDetailConfigurationResult',
    'GetDetectorRecipeDetectorRuleDetailConfigurationValueResult',
    'GetDetectorRecipeDetectorRuleDetailEntitiesMappingResult',
    'GetDetectorRecipeDetectorRuleEntitiesMappingResult',
    'GetDetectorRecipeEffectiveDetectorRuleResult',
    'GetDetectorRecipeEffectiveDetectorRuleCandidateResponderRuleResult',
    'GetDetectorRecipeEffectiveDetectorRuleDetailResult',
    'GetDetectorRecipeEffectiveDetectorRuleDetailConfigurationResult',
    'GetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueResult',
    'GetDetectorRecipeEffectiveDetectorRuleEntitiesMappingResult',
    'GetDetectorRecipesDetectorRecipeCollectionResult',
    'GetDetectorRecipesDetectorRecipeCollectionItemResult',
    'GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleResult',
    'GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleCandidateResponderRuleResult',
    'GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleDetailResult',
    'GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleDetailConfigurationResult',
    'GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleDetailConfigurationValueResult',
    'GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleDetailEntitiesMappingResult',
    'GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleEntitiesMappingResult',
    'GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleResult',
    'GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleCandidateResponderRuleResult',
    'GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleDetailResult',
    'GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleDetailConfigurationResult',
    'GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleDetailConfigurationValueResult',
    'GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleEntitiesMappingResult',
    'GetDetectorRecipesFilterResult',
    'GetGuardTargetTargetDetailResult',
    'GetGuardTargetTargetDetailTargetSecurityZoneRecipeResult',
    'GetGuardTargetTargetDetectorRecipeResult',
    'GetGuardTargetTargetDetectorRecipeDetectorRuleResult',
    'GetGuardTargetTargetDetectorRecipeDetectorRuleDetailResult',
    'GetGuardTargetTargetDetectorRecipeDetectorRuleDetailConditionGroupResult',
    'GetGuardTargetTargetDetectorRecipeDetectorRuleDetailConfigurationResult',
    'GetGuardTargetTargetDetectorRecipeDetectorRuleDetailConfigurationValueResult',
    'GetGuardTargetTargetDetectorRecipeDetectorRuleEntitiesMappingResult',
    'GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleResult',
    'GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailResult',
    'GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroupResult',
    'GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationResult',
    'GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueResult',
    'GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleEntitiesMappingResult',
    'GetGuardTargetTargetResponderRecipeResult',
    'GetGuardTargetTargetResponderRecipeEffectiveResponderRuleResult',
    'GetGuardTargetTargetResponderRecipeEffectiveResponderRuleDetailResult',
    'GetGuardTargetTargetResponderRecipeEffectiveResponderRuleDetailConfigurationResult',
    'GetGuardTargetTargetResponderRecipeResponderRuleResult',
    'GetGuardTargetTargetResponderRecipeResponderRuleDetailResult',
    'GetGuardTargetTargetResponderRecipeResponderRuleDetailConfigurationResult',
    'GetGuardTargetsFilterResult',
    'GetGuardTargetsTargetCollectionResult',
    'GetGuardTargetsTargetCollectionItemResult',
    'GetGuardTargetsTargetCollectionItemTargetDetailResult',
    'GetGuardTargetsTargetCollectionItemTargetDetailTargetSecurityZoneRecipeResult',
    'GetGuardTargetsTargetCollectionItemTargetDetectorRecipeResult',
    'GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleResult',
    'GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleDetailResult',
    'GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleDetailConditionGroupResult',
    'GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleDetailConfigurationResult',
    'GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleDetailConfigurationValueResult',
    'GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleEntitiesMappingResult',
    'GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleResult',
    'GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleDetailResult',
    'GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroupResult',
    'GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationResult',
    'GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueResult',
    'GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleEntitiesMappingResult',
    'GetGuardTargetsTargetCollectionItemTargetResponderRecipeResult',
    'GetGuardTargetsTargetCollectionItemTargetResponderRecipeEffectiveResponderRuleResult',
    'GetGuardTargetsTargetCollectionItemTargetResponderRecipeEffectiveResponderRuleDetailResult',
    'GetGuardTargetsTargetCollectionItemTargetResponderRecipeEffectiveResponderRuleDetailConfigurationResult',
    'GetGuardTargetsTargetCollectionItemTargetResponderRecipeResponderRuleResult',
    'GetGuardTargetsTargetCollectionItemTargetResponderRecipeResponderRuleDetailResult',
    'GetGuardTargetsTargetCollectionItemTargetResponderRecipeResponderRuleDetailConfigurationResult',
    'GetManagedListsFilterResult',
    'GetManagedListsManagedListCollectionResult',
    'GetManagedListsManagedListCollectionItemResult',
    'GetProblemEntitiesFilterResult',
    'GetProblemEntitiesProblemEntityCollectionResult',
    'GetProblemEntitiesProblemEntityCollectionItemResult',
    'GetProblemEntitiesProblemEntityCollectionItemEntityDetailResult',
    'GetProblemEntityItemResult',
    'GetProblemEntityItemEntityDetailResult',
    'GetResponderRecipeEffectiveResponderRuleResult',
    'GetResponderRecipeEffectiveResponderRuleDetailResult',
    'GetResponderRecipeEffectiveResponderRuleDetailConfigurationResult',
    'GetResponderRecipeResponderRuleResult',
    'GetResponderRecipeResponderRuleDetailResult',
    'GetResponderRecipeResponderRuleDetailConfigurationResult',
    'GetResponderRecipesFilterResult',
    'GetResponderRecipesResponderRecipeCollectionResult',
    'GetResponderRecipesResponderRecipeCollectionItemResult',
    'GetResponderRecipesResponderRecipeCollectionItemEffectiveResponderRuleResult',
    'GetResponderRecipesResponderRecipeCollectionItemEffectiveResponderRuleDetailResult',
    'GetResponderRecipesResponderRecipeCollectionItemEffectiveResponderRuleDetailConfigurationResult',
    'GetResponderRecipesResponderRecipeCollectionItemResponderRuleResult',
    'GetResponderRecipesResponderRecipeCollectionItemResponderRuleDetailResult',
    'GetResponderRecipesResponderRecipeCollectionItemResponderRuleDetailConfigurationResult',
    'GetSecurityPoliciesFilterResult',
    'GetSecurityPoliciesSecurityPolicyCollectionResult',
    'GetSecurityPoliciesSecurityPolicyCollectionItemResult',
    'GetSecurityRecipesFilterResult',
    'GetSecurityRecipesSecurityRecipeCollectionResult',
    'GetSecurityRecipesSecurityRecipeCollectionItemResult',
    'GetSecurityZonesFilterResult',
    'GetSecurityZonesSecurityZoneCollectionResult',
    'GetSecurityZonesSecurityZoneCollectionItemResult',
]

@pulumi.output_type
class CloudGuardDataSourceDataSourceDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSourceFeedProvider":
            suggest = "data_source_feed_provider"
        elif key == "additionalEntitiesCount":
            suggest = "additional_entities_count"
        elif key == "intervalInMinutes":
            suggest = "interval_in_minutes"
        elif key == "loggingQueryDetails":
            suggest = "logging_query_details"
        elif key == "loggingQueryType":
            suggest = "logging_query_type"
        elif key == "queryStartTime":
            suggest = "query_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudGuardDataSourceDataSourceDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudGuardDataSourceDataSourceDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudGuardDataSourceDataSourceDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source_feed_provider: str,
                 additional_entities_count: Optional[int] = None,
                 interval_in_minutes: Optional[int] = None,
                 logging_query_details: Optional['outputs.CloudGuardDataSourceDataSourceDetailsLoggingQueryDetails'] = None,
                 logging_query_type: Optional[str] = None,
                 operator: Optional[str] = None,
                 query: Optional[str] = None,
                 query_start_time: Optional['outputs.CloudGuardDataSourceDataSourceDetailsQueryStartTime'] = None,
                 regions: Optional[Sequence[str]] = None,
                 threshold: Optional[int] = None):
        """
        :param str data_source_feed_provider: Possible type of dataSourceFeed Provider(LoggingQuery)
        :param int additional_entities_count: (Updatable) The additional entities count used for data source query.
        :param int interval_in_minutes: (Updatable) Interval in minutes that query is run periodically.
        :param 'CloudGuardDataSourceDataSourceDetailsLoggingQueryDetailsArgs' logging_query_details: (Updatable) Additional details specific to the data source type (Sighting/Insight).
        :param str logging_query_type: (Updatable) Logging query type for data source (Sighting/Insight)
        :param str operator: (Updatable) Operator used in Data Soruce
        :param str query: (Updatable) The continuous query expression that is run periodically.
        :param 'CloudGuardDataSourceDataSourceDetailsQueryStartTimeArgs' query_start_time: (Updatable) Time when the query can start, if not specified it can start immediately.
        :param Sequence[str] regions: (Updatable) Logging Query regions
        :param int threshold: (Updatable) The integer value that must be exceeded, fall below or equal to (depending on the operator), the query result to trigger an event.
        """
        CloudGuardDataSourceDataSourceDetails._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source_feed_provider=data_source_feed_provider,
            additional_entities_count=additional_entities_count,
            interval_in_minutes=interval_in_minutes,
            logging_query_details=logging_query_details,
            logging_query_type=logging_query_type,
            operator=operator,
            query=query,
            query_start_time=query_start_time,
            regions=regions,
            threshold=threshold,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source_feed_provider: str,
             additional_entities_count: Optional[int] = None,
             interval_in_minutes: Optional[int] = None,
             logging_query_details: Optional['outputs.CloudGuardDataSourceDataSourceDetailsLoggingQueryDetails'] = None,
             logging_query_type: Optional[str] = None,
             operator: Optional[str] = None,
             query: Optional[str] = None,
             query_start_time: Optional['outputs.CloudGuardDataSourceDataSourceDetailsQueryStartTime'] = None,
             regions: Optional[Sequence[str]] = None,
             threshold: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'dataSourceFeedProvider' in kwargs:
            data_source_feed_provider = kwargs['dataSourceFeedProvider']
        if 'additionalEntitiesCount' in kwargs:
            additional_entities_count = kwargs['additionalEntitiesCount']
        if 'intervalInMinutes' in kwargs:
            interval_in_minutes = kwargs['intervalInMinutes']
        if 'loggingQueryDetails' in kwargs:
            logging_query_details = kwargs['loggingQueryDetails']
        if 'loggingQueryType' in kwargs:
            logging_query_type = kwargs['loggingQueryType']
        if 'queryStartTime' in kwargs:
            query_start_time = kwargs['queryStartTime']

        _setter("data_source_feed_provider", data_source_feed_provider)
        if additional_entities_count is not None:
            _setter("additional_entities_count", additional_entities_count)
        if interval_in_minutes is not None:
            _setter("interval_in_minutes", interval_in_minutes)
        if logging_query_details is not None:
            _setter("logging_query_details", logging_query_details)
        if logging_query_type is not None:
            _setter("logging_query_type", logging_query_type)
        if operator is not None:
            _setter("operator", operator)
        if query is not None:
            _setter("query", query)
        if query_start_time is not None:
            _setter("query_start_time", query_start_time)
        if regions is not None:
            _setter("regions", regions)
        if threshold is not None:
            _setter("threshold", threshold)

    @property
    @pulumi.getter(name="dataSourceFeedProvider")
    def data_source_feed_provider(self) -> str:
        """
        Possible type of dataSourceFeed Provider(LoggingQuery)
        """
        return pulumi.get(self, "data_source_feed_provider")

    @property
    @pulumi.getter(name="additionalEntitiesCount")
    def additional_entities_count(self) -> Optional[int]:
        """
        (Updatable) The additional entities count used for data source query.
        """
        return pulumi.get(self, "additional_entities_count")

    @property
    @pulumi.getter(name="intervalInMinutes")
    def interval_in_minutes(self) -> Optional[int]:
        """
        (Updatable) Interval in minutes that query is run periodically.
        """
        return pulumi.get(self, "interval_in_minutes")

    @property
    @pulumi.getter(name="loggingQueryDetails")
    def logging_query_details(self) -> Optional['outputs.CloudGuardDataSourceDataSourceDetailsLoggingQueryDetails']:
        """
        (Updatable) Additional details specific to the data source type (Sighting/Insight).
        """
        return pulumi.get(self, "logging_query_details")

    @property
    @pulumi.getter(name="loggingQueryType")
    def logging_query_type(self) -> Optional[str]:
        """
        (Updatable) Logging query type for data source (Sighting/Insight)
        """
        return pulumi.get(self, "logging_query_type")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        (Updatable) Operator used in Data Soruce
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        (Updatable) The continuous query expression that is run periodically.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="queryStartTime")
    def query_start_time(self) -> Optional['outputs.CloudGuardDataSourceDataSourceDetailsQueryStartTime']:
        """
        (Updatable) Time when the query can start, if not specified it can start immediately.
        """
        return pulumi.get(self, "query_start_time")

    @property
    @pulumi.getter
    def regions(self) -> Optional[Sequence[str]]:
        """
        (Updatable) Logging Query regions
        """
        return pulumi.get(self, "regions")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[int]:
        """
        (Updatable) The integer value that must be exceeded, fall below or equal to (depending on the operator), the query result to trigger an event.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class CloudGuardDataSourceDataSourceDetailsLoggingQueryDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loggingQueryType":
            suggest = "logging_query_type"
        elif key == "keyEntitiesCount":
            suggest = "key_entities_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudGuardDataSourceDataSourceDetailsLoggingQueryDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudGuardDataSourceDataSourceDetailsLoggingQueryDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudGuardDataSourceDataSourceDetailsLoggingQueryDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 logging_query_type: str,
                 key_entities_count: Optional[int] = None):
        """
        :param str logging_query_type: (Updatable) Logging query type for data source (Sighting/Insight)
        :param int key_entities_count: (Updatable) The key entities count used for data source query
        """
        CloudGuardDataSourceDataSourceDetailsLoggingQueryDetails._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            logging_query_type=logging_query_type,
            key_entities_count=key_entities_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             logging_query_type: str,
             key_entities_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'loggingQueryType' in kwargs:
            logging_query_type = kwargs['loggingQueryType']
        if 'keyEntitiesCount' in kwargs:
            key_entities_count = kwargs['keyEntitiesCount']

        _setter("logging_query_type", logging_query_type)
        if key_entities_count is not None:
            _setter("key_entities_count", key_entities_count)

    @property
    @pulumi.getter(name="loggingQueryType")
    def logging_query_type(self) -> str:
        """
        (Updatable) Logging query type for data source (Sighting/Insight)
        """
        return pulumi.get(self, "logging_query_type")

    @property
    @pulumi.getter(name="keyEntitiesCount")
    def key_entities_count(self) -> Optional[int]:
        """
        (Updatable) The key entities count used for data source query
        """
        return pulumi.get(self, "key_entities_count")


@pulumi.output_type
class CloudGuardDataSourceDataSourceDetailsQueryStartTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startPolicyType":
            suggest = "start_policy_type"
        elif key == "queryStartTime":
            suggest = "query_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudGuardDataSourceDataSourceDetailsQueryStartTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudGuardDataSourceDataSourceDetailsQueryStartTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudGuardDataSourceDataSourceDetailsQueryStartTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 start_policy_type: str,
                 query_start_time: Optional[str] = None):
        """
        :param str start_policy_type: (Updatable) policy used for deciding the query start time
        :param str query_start_time: (Updatable) Time when the query can start, if not specified it can start immediately.
        """
        CloudGuardDataSourceDataSourceDetailsQueryStartTime._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            start_policy_type=start_policy_type,
            query_start_time=query_start_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             start_policy_type: str,
             query_start_time: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'startPolicyType' in kwargs:
            start_policy_type = kwargs['startPolicyType']
        if 'queryStartTime' in kwargs:
            query_start_time = kwargs['queryStartTime']

        _setter("start_policy_type", start_policy_type)
        if query_start_time is not None:
            _setter("query_start_time", query_start_time)

    @property
    @pulumi.getter(name="startPolicyType")
    def start_policy_type(self) -> str:
        """
        (Updatable) policy used for deciding the query start time
        """
        return pulumi.get(self, "start_policy_type")

    @property
    @pulumi.getter(name="queryStartTime")
    def query_start_time(self) -> Optional[str]:
        """
        (Updatable) Time when the query can start, if not specified it can start immediately.
        """
        return pulumi.get(self, "query_start_time")


@pulumi.output_type
class CloudGuardDataSourceDataSourceDetectorMappingInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "detectorRecipeId":
            suggest = "detector_recipe_id"
        elif key == "detectorRuleId":
            suggest = "detector_rule_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudGuardDataSourceDataSourceDetectorMappingInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudGuardDataSourceDataSourceDetectorMappingInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudGuardDataSourceDataSourceDetectorMappingInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 detector_recipe_id: Optional[str] = None,
                 detector_rule_id: Optional[str] = None):
        """
        :param str detector_recipe_id: Id of the attached detectorRecipeId to the Data Source.
        :param str detector_rule_id: Id of the attached detectorRuleId to the Data Source.
        """
        CloudGuardDataSourceDataSourceDetectorMappingInfo._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            detector_recipe_id=detector_recipe_id,
            detector_rule_id=detector_rule_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             detector_recipe_id: Optional[str] = None,
             detector_rule_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'detectorRecipeId' in kwargs:
            detector_recipe_id = kwargs['detectorRecipeId']
        if 'detectorRuleId' in kwargs:
            detector_rule_id = kwargs['detectorRuleId']

        if detector_recipe_id is not None:
            _setter("detector_recipe_id", detector_recipe_id)
        if detector_rule_id is not None:
            _setter("detector_rule_id", detector_rule_id)

    @property
    @pulumi.getter(name="detectorRecipeId")
    def detector_recipe_id(self) -> Optional[str]:
        """
        Id of the attached detectorRecipeId to the Data Source.
        """
        return pulumi.get(self, "detector_recipe_id")

    @property
    @pulumi.getter(name="detectorRuleId")
    def detector_rule_id(self) -> Optional[str]:
        """
        Id of the attached detectorRuleId to the Data Source.
        """
        return pulumi.get(self, "detector_rule_id")


@pulumi.output_type
class CloudGuardDataSourceRegionStatusDetail(dict):
    def __init__(__self__, *,
                 region: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str region: Data Source replication region.
        :param str status: Status of data Source
        """
        CloudGuardDataSourceRegionStatusDetail._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            region=region,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             region: Optional[str] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if region is not None:
            _setter("region", region)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Data Source replication region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of data Source
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class DataMaskRuleTargetSelected(dict):
    def __init__(__self__, *,
                 kind: str,
                 values: Optional[Sequence[str]] = None):
        """
        :param str kind: (Updatable) Target selection.
        :param Sequence[str] values: (Updatable) Types of Targets
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        DataMaskRuleTargetSelected._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            kind=kind,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             kind: str,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("kind", kind)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        (Updatable) Target selection.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        (Updatable) Types of Targets


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class DetectorRecipeDetectorRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "detectorRuleId":
            suggest = "detector_rule_id"
        elif key == "candidateResponderRules":
            suggest = "candidate_responder_rules"
        elif key == "dataSourceId":
            suggest = "data_source_id"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "entitiesMappings":
            suggest = "entities_mappings"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"
        elif key == "managedListTypes":
            suggest = "managed_list_types"
        elif key == "resourceType":
            suggest = "resource_type"
        elif key == "serviceType":
            suggest = "service_type"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeUpdated":
            suggest = "time_updated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DetectorRecipeDetectorRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DetectorRecipeDetectorRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DetectorRecipeDetectorRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 details: 'outputs.DetectorRecipeDetectorRuleDetails',
                 detector_rule_id: str,
                 candidate_responder_rules: Optional[Sequence['outputs.DetectorRecipeDetectorRuleCandidateResponderRule']] = None,
                 data_source_id: Optional[str] = None,
                 description: Optional[str] = None,
                 detector: Optional[str] = None,
                 display_name: Optional[str] = None,
                 entities_mappings: Optional[Sequence['outputs.DetectorRecipeDetectorRuleEntitiesMapping']] = None,
                 lifecycle_details: Optional[str] = None,
                 managed_list_types: Optional[Sequence[str]] = None,
                 recommendation: Optional[str] = None,
                 resource_type: Optional[str] = None,
                 service_type: Optional[str] = None,
                 state: Optional[str] = None,
                 time_created: Optional[str] = None,
                 time_updated: Optional[str] = None):
        """
        :param 'DetectorRecipeDetectorRuleDetailsArgs' details: (Updatable) Details of a Detector Rule to be overriden in Detector Recipe
        :param str detector_rule_id: (Updatable) DetectorRecipeRule Identifier
        :param Sequence['DetectorRecipeDetectorRuleCandidateResponderRuleArgs'] candidate_responder_rules: List of CandidateResponderRule related to this rule
        :param str data_source_id: (Updatable) The id of the attached DataSource.
        :param str description: (Updatable) Description for DetectorRecipeDetectorRule.
        :param str detector: detector for the rule
        :param str display_name: (Updatable) Detector recipe display name.
               
               Avoid entering confidential information.
        :param Sequence['DetectorRecipeDetectorRuleEntitiesMappingArgs'] entities_mappings: (Updatable) Data Source entities mapping for a Detector Rule
        :param str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param Sequence[str] managed_list_types: List of cloudguard managed list types related to this rule
        :param str recommendation: (Updatable) Recommendation for DetectorRecipeDetectorRule
        :param str resource_type: resource type of the configuration to which the rule is applied
        :param str service_type: service type of the configuration to which the rule is applied
        :param str state: The current state of the resource.
        :param str time_created: The date and time the detector recipe was created. Format defined by RFC3339.
        :param str time_updated: The date and time the detector recipe was updated. Format defined by RFC3339.
        """
        DetectorRecipeDetectorRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            details=details,
            detector_rule_id=detector_rule_id,
            candidate_responder_rules=candidate_responder_rules,
            data_source_id=data_source_id,
            description=description,
            detector=detector,
            display_name=display_name,
            entities_mappings=entities_mappings,
            lifecycle_details=lifecycle_details,
            managed_list_types=managed_list_types,
            recommendation=recommendation,
            resource_type=resource_type,
            service_type=service_type,
            state=state,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             details: 'outputs.DetectorRecipeDetectorRuleDetails',
             detector_rule_id: str,
             candidate_responder_rules: Optional[Sequence['outputs.DetectorRecipeDetectorRuleCandidateResponderRule']] = None,
             data_source_id: Optional[str] = None,
             description: Optional[str] = None,
             detector: Optional[str] = None,
             display_name: Optional[str] = None,
             entities_mappings: Optional[Sequence['outputs.DetectorRecipeDetectorRuleEntitiesMapping']] = None,
             lifecycle_details: Optional[str] = None,
             managed_list_types: Optional[Sequence[str]] = None,
             recommendation: Optional[str] = None,
             resource_type: Optional[str] = None,
             service_type: Optional[str] = None,
             state: Optional[str] = None,
             time_created: Optional[str] = None,
             time_updated: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'detectorRuleId' in kwargs:
            detector_rule_id = kwargs['detectorRuleId']
        if 'candidateResponderRules' in kwargs:
            candidate_responder_rules = kwargs['candidateResponderRules']
        if 'dataSourceId' in kwargs:
            data_source_id = kwargs['dataSourceId']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'entitiesMappings' in kwargs:
            entities_mappings = kwargs['entitiesMappings']
        if 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if 'managedListTypes' in kwargs:
            managed_list_types = kwargs['managedListTypes']
        if 'resourceType' in kwargs:
            resource_type = kwargs['resourceType']
        if 'serviceType' in kwargs:
            service_type = kwargs['serviceType']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("details", details)
        _setter("detector_rule_id", detector_rule_id)
        if candidate_responder_rules is not None:
            _setter("candidate_responder_rules", candidate_responder_rules)
        if data_source_id is not None:
            _setter("data_source_id", data_source_id)
        if description is not None:
            _setter("description", description)
        if detector is not None:
            _setter("detector", detector)
        if display_name is not None:
            _setter("display_name", display_name)
        if entities_mappings is not None:
            _setter("entities_mappings", entities_mappings)
        if lifecycle_details is not None:
            _setter("lifecycle_details", lifecycle_details)
        if managed_list_types is not None:
            _setter("managed_list_types", managed_list_types)
        if recommendation is not None:
            _setter("recommendation", recommendation)
        if resource_type is not None:
            _setter("resource_type", resource_type)
        if service_type is not None:
            _setter("service_type", service_type)
        if state is not None:
            _setter("state", state)
        if time_created is not None:
            _setter("time_created", time_created)
        if time_updated is not None:
            _setter("time_updated", time_updated)

    @property
    @pulumi.getter
    def details(self) -> 'outputs.DetectorRecipeDetectorRuleDetails':
        """
        (Updatable) Details of a Detector Rule to be overriden in Detector Recipe
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter(name="detectorRuleId")
    def detector_rule_id(self) -> str:
        """
        (Updatable) DetectorRecipeRule Identifier
        """
        return pulumi.get(self, "detector_rule_id")

    @property
    @pulumi.getter(name="candidateResponderRules")
    def candidate_responder_rules(self) -> Optional[Sequence['outputs.DetectorRecipeDetectorRuleCandidateResponderRule']]:
        """
        List of CandidateResponderRule related to this rule
        """
        return pulumi.get(self, "candidate_responder_rules")

    @property
    @pulumi.getter(name="dataSourceId")
    def data_source_id(self) -> Optional[str]:
        """
        (Updatable) The id of the attached DataSource.
        """
        return pulumi.get(self, "data_source_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        (Updatable) Description for DetectorRecipeDetectorRule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def detector(self) -> Optional[str]:
        """
        detector for the rule
        """
        return pulumi.get(self, "detector")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        (Updatable) Detector recipe display name.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="entitiesMappings")
    def entities_mappings(self) -> Optional[Sequence['outputs.DetectorRecipeDetectorRuleEntitiesMapping']]:
        """
        (Updatable) Data Source entities mapping for a Detector Rule
        """
        return pulumi.get(self, "entities_mappings")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[str]:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="managedListTypes")
    def managed_list_types(self) -> Optional[Sequence[str]]:
        """
        List of cloudguard managed list types related to this rule
        """
        return pulumi.get(self, "managed_list_types")

    @property
    @pulumi.getter
    def recommendation(self) -> Optional[str]:
        """
        (Updatable) Recommendation for DetectorRecipeDetectorRule
        """
        return pulumi.get(self, "recommendation")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[str]:
        """
        resource type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> Optional[str]:
        """
        service type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "service_type")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        The current state of the resource.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[str]:
        """
        The date and time the detector recipe was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[str]:
        """
        The date and time the detector recipe was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class DetectorRecipeDetectorRuleCandidateResponderRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "isPreferred":
            suggest = "is_preferred"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DetectorRecipeDetectorRuleCandidateResponderRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DetectorRecipeDetectorRuleCandidateResponderRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DetectorRecipeDetectorRuleCandidateResponderRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: Optional[str] = None,
                 id: Optional[str] = None,
                 is_preferred: Optional[bool] = None):
        """
        :param str display_name: (Updatable) Detector recipe display name.
               
               Avoid entering confidential information.
        :param str id: Ocid for detector recipe
        :param bool is_preferred: Preferred state
        """
        DetectorRecipeDetectorRuleCandidateResponderRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            id=id,
            is_preferred=is_preferred,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: Optional[str] = None,
             id: Optional[str] = None,
             is_preferred: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'isPreferred' in kwargs:
            is_preferred = kwargs['isPreferred']

        if display_name is not None:
            _setter("display_name", display_name)
        if id is not None:
            _setter("id", id)
        if is_preferred is not None:
            _setter("is_preferred", is_preferred)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        (Updatable) Detector recipe display name.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Ocid for detector recipe
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isPreferred")
    def is_preferred(self) -> Optional[bool]:
        """
        Preferred state
        """
        return pulumi.get(self, "is_preferred")


@pulumi.output_type
class DetectorRecipeDetectorRuleDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "riskLevel":
            suggest = "risk_level"
        elif key == "dataSourceId":
            suggest = "data_source_id"
        elif key == "entitiesMappings":
            suggest = "entities_mappings"
        elif key == "isConfigurationAllowed":
            suggest = "is_configuration_allowed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DetectorRecipeDetectorRuleDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DetectorRecipeDetectorRuleDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DetectorRecipeDetectorRuleDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_enabled: bool,
                 risk_level: str,
                 condition: Optional[str] = None,
                 configurations: Optional[Sequence['outputs.DetectorRecipeDetectorRuleDetailsConfiguration']] = None,
                 data_source_id: Optional[str] = None,
                 description: Optional[str] = None,
                 entities_mappings: Optional[Sequence['outputs.DetectorRecipeDetectorRuleDetailsEntitiesMapping']] = None,
                 is_configuration_allowed: Optional[bool] = None,
                 labels: Optional[Sequence[str]] = None,
                 recommendation: Optional[str] = None):
        """
        :param bool is_enabled: (Updatable) Enables the control
        :param str risk_level: (Updatable) The Risk Level
        :param str condition: (Updatable) Base condition object
        :param Sequence['DetectorRecipeDetectorRuleDetailsConfigurationArgs'] configurations: (Updatable) Configuration details
        :param str data_source_id: (Updatable) The id of the attached DataSource.
        :param str description: (Updatable) Description for DetectorRecipeDetectorRule.
        :param Sequence['DetectorRecipeDetectorRuleDetailsEntitiesMappingArgs'] entities_mappings: (Updatable) Data Source entities mapping for a Detector Rule
        :param bool is_configuration_allowed: configuration allowed or not
        :param Sequence[str] labels: (Updatable) user defined labels for a detector rule
        :param str recommendation: (Updatable) Recommendation for DetectorRecipeDetectorRule
        """
        DetectorRecipeDetectorRuleDetails._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_enabled=is_enabled,
            risk_level=risk_level,
            condition=condition,
            configurations=configurations,
            data_source_id=data_source_id,
            description=description,
            entities_mappings=entities_mappings,
            is_configuration_allowed=is_configuration_allowed,
            labels=labels,
            recommendation=recommendation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_enabled: bool,
             risk_level: str,
             condition: Optional[str] = None,
             configurations: Optional[Sequence['outputs.DetectorRecipeDetectorRuleDetailsConfiguration']] = None,
             data_source_id: Optional[str] = None,
             description: Optional[str] = None,
             entities_mappings: Optional[Sequence['outputs.DetectorRecipeDetectorRuleDetailsEntitiesMapping']] = None,
             is_configuration_allowed: Optional[bool] = None,
             labels: Optional[Sequence[str]] = None,
             recommendation: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']
        if 'riskLevel' in kwargs:
            risk_level = kwargs['riskLevel']
        if 'dataSourceId' in kwargs:
            data_source_id = kwargs['dataSourceId']
        if 'entitiesMappings' in kwargs:
            entities_mappings = kwargs['entitiesMappings']
        if 'isConfigurationAllowed' in kwargs:
            is_configuration_allowed = kwargs['isConfigurationAllowed']

        _setter("is_enabled", is_enabled)
        _setter("risk_level", risk_level)
        if condition is not None:
            _setter("condition", condition)
        if configurations is not None:
            _setter("configurations", configurations)
        if data_source_id is not None:
            _setter("data_source_id", data_source_id)
        if description is not None:
            _setter("description", description)
        if entities_mappings is not None:
            _setter("entities_mappings", entities_mappings)
        if is_configuration_allowed is not None:
            _setter("is_configuration_allowed", is_configuration_allowed)
        if labels is not None:
            _setter("labels", labels)
        if recommendation is not None:
            _setter("recommendation", recommendation)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        (Updatable) Enables the control
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> str:
        """
        (Updatable) The Risk Level
        """
        return pulumi.get(self, "risk_level")

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        """
        (Updatable) Base condition object
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def configurations(self) -> Optional[Sequence['outputs.DetectorRecipeDetectorRuleDetailsConfiguration']]:
        """
        (Updatable) Configuration details
        """
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter(name="dataSourceId")
    def data_source_id(self) -> Optional[str]:
        """
        (Updatable) The id of the attached DataSource.
        """
        return pulumi.get(self, "data_source_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        (Updatable) Description for DetectorRecipeDetectorRule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="entitiesMappings")
    def entities_mappings(self) -> Optional[Sequence['outputs.DetectorRecipeDetectorRuleDetailsEntitiesMapping']]:
        """
        (Updatable) Data Source entities mapping for a Detector Rule
        """
        return pulumi.get(self, "entities_mappings")

    @property
    @pulumi.getter(name="isConfigurationAllowed")
    def is_configuration_allowed(self) -> Optional[bool]:
        """
        configuration allowed or not
        """
        return pulumi.get(self, "is_configuration_allowed")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Sequence[str]]:
        """
        (Updatable) user defined labels for a detector rule
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def recommendation(self) -> Optional[str]:
        """
        (Updatable) Recommendation for DetectorRecipeDetectorRule
        """
        return pulumi.get(self, "recommendation")


@pulumi.output_type
class DetectorRecipeDetectorRuleDetailsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configKey":
            suggest = "config_key"
        elif key == "dataType":
            suggest = "data_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DetectorRecipeDetectorRuleDetailsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DetectorRecipeDetectorRuleDetailsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DetectorRecipeDetectorRuleDetailsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_key: str,
                 name: str,
                 data_type: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence['outputs.DetectorRecipeDetectorRuleDetailsConfigurationValue']] = None):
        """
        :param str config_key: (Updatable) Unique name of the configuration
        :param str name: (Updatable) configuration name
        :param str data_type: (Updatable) configuration data type
        :param str value: (Updatable) configuration value
        :param Sequence['DetectorRecipeDetectorRuleDetailsConfigurationValueArgs'] values: (Updatable) List of configuration values
        """
        DetectorRecipeDetectorRuleDetailsConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_key=config_key,
            name=name,
            data_type=data_type,
            value=value,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_key: str,
             name: str,
             data_type: Optional[str] = None,
             value: Optional[str] = None,
             values: Optional[Sequence['outputs.DetectorRecipeDetectorRuleDetailsConfigurationValue']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'configKey' in kwargs:
            config_key = kwargs['configKey']
        if 'dataType' in kwargs:
            data_type = kwargs['dataType']

        _setter("config_key", config_key)
        _setter("name", name)
        if data_type is not None:
            _setter("data_type", data_type)
        if value is not None:
            _setter("value", value)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> str:
        """
        (Updatable) Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        (Updatable) configuration name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[str]:
        """
        (Updatable) configuration data type
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        (Updatable) configuration value
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.DetectorRecipeDetectorRuleDetailsConfigurationValue']]:
        """
        (Updatable) List of configuration values
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class DetectorRecipeDetectorRuleDetailsConfigurationValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "listType":
            suggest = "list_type"
        elif key == "managedListType":
            suggest = "managed_list_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DetectorRecipeDetectorRuleDetailsConfigurationValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DetectorRecipeDetectorRuleDetailsConfigurationValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DetectorRecipeDetectorRuleDetailsConfigurationValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 list_type: str,
                 managed_list_type: str,
                 value: str):
        """
        :param str list_type: (Updatable) configuration list item type, either CUSTOM or MANAGED
        :param str managed_list_type: (Updatable) type of the managed list
        :param str value: (Updatable) configuration value
        """
        DetectorRecipeDetectorRuleDetailsConfigurationValue._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            list_type=list_type,
            managed_list_type=managed_list_type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             list_type: str,
             managed_list_type: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'listType' in kwargs:
            list_type = kwargs['listType']
        if 'managedListType' in kwargs:
            managed_list_type = kwargs['managedListType']

        _setter("list_type", list_type)
        _setter("managed_list_type", managed_list_type)
        _setter("value", value)

    @property
    @pulumi.getter(name="listType")
    def list_type(self) -> str:
        """
        (Updatable) configuration list item type, either CUSTOM or MANAGED
        """
        return pulumi.get(self, "list_type")

    @property
    @pulumi.getter(name="managedListType")
    def managed_list_type(self) -> str:
        """
        (Updatable) type of the managed list
        """
        return pulumi.get(self, "managed_list_type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        (Updatable) configuration value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DetectorRecipeDetectorRuleDetailsEntitiesMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryField":
            suggest = "query_field"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "entityType":
            suggest = "entity_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DetectorRecipeDetectorRuleDetailsEntitiesMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DetectorRecipeDetectorRuleDetailsEntitiesMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DetectorRecipeDetectorRuleDetailsEntitiesMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_field: str,
                 display_name: Optional[str] = None,
                 entity_type: Optional[str] = None):
        """
        :param str query_field: (Updatable) The entity value mapped to a data source query
        :param str display_name: (Updatable) Detector recipe display name.
               
               Avoid entering confidential information.
        :param str entity_type: (Updatable) Possible type of entity
        """
        DetectorRecipeDetectorRuleDetailsEntitiesMapping._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query_field=query_field,
            display_name=display_name,
            entity_type=entity_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query_field: str,
             display_name: Optional[str] = None,
             entity_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'queryField' in kwargs:
            query_field = kwargs['queryField']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'entityType' in kwargs:
            entity_type = kwargs['entityType']

        _setter("query_field", query_field)
        if display_name is not None:
            _setter("display_name", display_name)
        if entity_type is not None:
            _setter("entity_type", entity_type)

    @property
    @pulumi.getter(name="queryField")
    def query_field(self) -> str:
        """
        (Updatable) The entity value mapped to a data source query
        """
        return pulumi.get(self, "query_field")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        (Updatable) Detector recipe display name.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[str]:
        """
        (Updatable) Possible type of entity
        """
        return pulumi.get(self, "entity_type")


@pulumi.output_type
class DetectorRecipeDetectorRuleEntitiesMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "entityType":
            suggest = "entity_type"
        elif key == "queryField":
            suggest = "query_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DetectorRecipeDetectorRuleEntitiesMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DetectorRecipeDetectorRuleEntitiesMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DetectorRecipeDetectorRuleEntitiesMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: Optional[str] = None,
                 entity_type: Optional[str] = None,
                 query_field: Optional[str] = None):
        """
        :param str display_name: (Updatable) Detector recipe display name.
               
               Avoid entering confidential information.
        :param str entity_type: (Updatable) Possible type of entity
        :param str query_field: (Updatable) The entity value mapped to a data source query
        """
        DetectorRecipeDetectorRuleEntitiesMapping._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            entity_type=entity_type,
            query_field=query_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: Optional[str] = None,
             entity_type: Optional[str] = None,
             query_field: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'entityType' in kwargs:
            entity_type = kwargs['entityType']
        if 'queryField' in kwargs:
            query_field = kwargs['queryField']

        if display_name is not None:
            _setter("display_name", display_name)
        if entity_type is not None:
            _setter("entity_type", entity_type)
        if query_field is not None:
            _setter("query_field", query_field)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        (Updatable) Detector recipe display name.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[str]:
        """
        (Updatable) Possible type of entity
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="queryField")
    def query_field(self) -> Optional[str]:
        """
        (Updatable) The entity value mapped to a data source query
        """
        return pulumi.get(self, "query_field")


@pulumi.output_type
class DetectorRecipeEffectiveDetectorRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "candidateResponderRules":
            suggest = "candidate_responder_rules"
        elif key == "dataSourceId":
            suggest = "data_source_id"
        elif key == "detectorRuleId":
            suggest = "detector_rule_id"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "entitiesMappings":
            suggest = "entities_mappings"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"
        elif key == "managedListTypes":
            suggest = "managed_list_types"
        elif key == "resourceType":
            suggest = "resource_type"
        elif key == "serviceType":
            suggest = "service_type"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeUpdated":
            suggest = "time_updated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DetectorRecipeEffectiveDetectorRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DetectorRecipeEffectiveDetectorRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DetectorRecipeEffectiveDetectorRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 candidate_responder_rules: Optional[Sequence['outputs.DetectorRecipeEffectiveDetectorRuleCandidateResponderRule']] = None,
                 data_source_id: Optional[str] = None,
                 description: Optional[str] = None,
                 details: Optional[Sequence['outputs.DetectorRecipeEffectiveDetectorRuleDetail']] = None,
                 detector: Optional[str] = None,
                 detector_rule_id: Optional[str] = None,
                 display_name: Optional[str] = None,
                 entities_mappings: Optional[Sequence['outputs.DetectorRecipeEffectiveDetectorRuleEntitiesMapping']] = None,
                 lifecycle_details: Optional[str] = None,
                 managed_list_types: Optional[Sequence[str]] = None,
                 recommendation: Optional[str] = None,
                 resource_type: Optional[str] = None,
                 service_type: Optional[str] = None,
                 state: Optional[str] = None,
                 time_created: Optional[str] = None,
                 time_updated: Optional[str] = None):
        """
        :param Sequence['DetectorRecipeEffectiveDetectorRuleCandidateResponderRuleArgs'] candidate_responder_rules: List of CandidateResponderRule related to this rule
        :param str data_source_id: (Updatable) The id of the attached DataSource.
        :param str description: (Updatable) Description for DetectorRecipeDetectorRule.
        :param Sequence['DetectorRecipeEffectiveDetectorRuleDetailArgs'] details: (Updatable) Details of a Detector Rule to be overriden in Detector Recipe
        :param str detector: detector for the rule
        :param str detector_rule_id: (Updatable) DetectorRecipeRule Identifier
        :param str display_name: (Updatable) Detector recipe display name.
               
               Avoid entering confidential information.
        :param Sequence['DetectorRecipeEffectiveDetectorRuleEntitiesMappingArgs'] entities_mappings: (Updatable) Data Source entities mapping for a Detector Rule
        :param str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param Sequence[str] managed_list_types: List of cloudguard managed list types related to this rule
        :param str recommendation: (Updatable) Recommendation for DetectorRecipeDetectorRule
        :param str resource_type: resource type of the configuration to which the rule is applied
        :param str service_type: service type of the configuration to which the rule is applied
        :param str state: The current state of the resource.
        :param str time_created: The date and time the detector recipe was created. Format defined by RFC3339.
        :param str time_updated: The date and time the detector recipe was updated. Format defined by RFC3339.
        """
        DetectorRecipeEffectiveDetectorRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            candidate_responder_rules=candidate_responder_rules,
            data_source_id=data_source_id,
            description=description,
            details=details,
            detector=detector,
            detector_rule_id=detector_rule_id,
            display_name=display_name,
            entities_mappings=entities_mappings,
            lifecycle_details=lifecycle_details,
            managed_list_types=managed_list_types,
            recommendation=recommendation,
            resource_type=resource_type,
            service_type=service_type,
            state=state,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             candidate_responder_rules: Optional[Sequence['outputs.DetectorRecipeEffectiveDetectorRuleCandidateResponderRule']] = None,
             data_source_id: Optional[str] = None,
             description: Optional[str] = None,
             details: Optional[Sequence['outputs.DetectorRecipeEffectiveDetectorRuleDetail']] = None,
             detector: Optional[str] = None,
             detector_rule_id: Optional[str] = None,
             display_name: Optional[str] = None,
             entities_mappings: Optional[Sequence['outputs.DetectorRecipeEffectiveDetectorRuleEntitiesMapping']] = None,
             lifecycle_details: Optional[str] = None,
             managed_list_types: Optional[Sequence[str]] = None,
             recommendation: Optional[str] = None,
             resource_type: Optional[str] = None,
             service_type: Optional[str] = None,
             state: Optional[str] = None,
             time_created: Optional[str] = None,
             time_updated: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'candidateResponderRules' in kwargs:
            candidate_responder_rules = kwargs['candidateResponderRules']
        if 'dataSourceId' in kwargs:
            data_source_id = kwargs['dataSourceId']
        if 'detectorRuleId' in kwargs:
            detector_rule_id = kwargs['detectorRuleId']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'entitiesMappings' in kwargs:
            entities_mappings = kwargs['entitiesMappings']
        if 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if 'managedListTypes' in kwargs:
            managed_list_types = kwargs['managedListTypes']
        if 'resourceType' in kwargs:
            resource_type = kwargs['resourceType']
        if 'serviceType' in kwargs:
            service_type = kwargs['serviceType']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        if candidate_responder_rules is not None:
            _setter("candidate_responder_rules", candidate_responder_rules)
        if data_source_id is not None:
            _setter("data_source_id", data_source_id)
        if description is not None:
            _setter("description", description)
        if details is not None:
            _setter("details", details)
        if detector is not None:
            _setter("detector", detector)
        if detector_rule_id is not None:
            _setter("detector_rule_id", detector_rule_id)
        if display_name is not None:
            _setter("display_name", display_name)
        if entities_mappings is not None:
            _setter("entities_mappings", entities_mappings)
        if lifecycle_details is not None:
            _setter("lifecycle_details", lifecycle_details)
        if managed_list_types is not None:
            _setter("managed_list_types", managed_list_types)
        if recommendation is not None:
            _setter("recommendation", recommendation)
        if resource_type is not None:
            _setter("resource_type", resource_type)
        if service_type is not None:
            _setter("service_type", service_type)
        if state is not None:
            _setter("state", state)
        if time_created is not None:
            _setter("time_created", time_created)
        if time_updated is not None:
            _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="candidateResponderRules")
    def candidate_responder_rules(self) -> Optional[Sequence['outputs.DetectorRecipeEffectiveDetectorRuleCandidateResponderRule']]:
        """
        List of CandidateResponderRule related to this rule
        """
        return pulumi.get(self, "candidate_responder_rules")

    @property
    @pulumi.getter(name="dataSourceId")
    def data_source_id(self) -> Optional[str]:
        """
        (Updatable) The id of the attached DataSource.
        """
        return pulumi.get(self, "data_source_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        (Updatable) Description for DetectorRecipeDetectorRule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def details(self) -> Optional[Sequence['outputs.DetectorRecipeEffectiveDetectorRuleDetail']]:
        """
        (Updatable) Details of a Detector Rule to be overriden in Detector Recipe
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def detector(self) -> Optional[str]:
        """
        detector for the rule
        """
        return pulumi.get(self, "detector")

    @property
    @pulumi.getter(name="detectorRuleId")
    def detector_rule_id(self) -> Optional[str]:
        """
        (Updatable) DetectorRecipeRule Identifier
        """
        return pulumi.get(self, "detector_rule_id")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        (Updatable) Detector recipe display name.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="entitiesMappings")
    def entities_mappings(self) -> Optional[Sequence['outputs.DetectorRecipeEffectiveDetectorRuleEntitiesMapping']]:
        """
        (Updatable) Data Source entities mapping for a Detector Rule
        """
        return pulumi.get(self, "entities_mappings")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[str]:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="managedListTypes")
    def managed_list_types(self) -> Optional[Sequence[str]]:
        """
        List of cloudguard managed list types related to this rule
        """
        return pulumi.get(self, "managed_list_types")

    @property
    @pulumi.getter
    def recommendation(self) -> Optional[str]:
        """
        (Updatable) Recommendation for DetectorRecipeDetectorRule
        """
        return pulumi.get(self, "recommendation")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[str]:
        """
        resource type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> Optional[str]:
        """
        service type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "service_type")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        The current state of the resource.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[str]:
        """
        The date and time the detector recipe was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[str]:
        """
        The date and time the detector recipe was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class DetectorRecipeEffectiveDetectorRuleCandidateResponderRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "isPreferred":
            suggest = "is_preferred"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DetectorRecipeEffectiveDetectorRuleCandidateResponderRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DetectorRecipeEffectiveDetectorRuleCandidateResponderRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DetectorRecipeEffectiveDetectorRuleCandidateResponderRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: Optional[str] = None,
                 id: Optional[str] = None,
                 is_preferred: Optional[bool] = None):
        """
        :param str display_name: (Updatable) Detector recipe display name.
               
               Avoid entering confidential information.
        :param str id: Ocid for detector recipe
        :param bool is_preferred: Preferred state
        """
        DetectorRecipeEffectiveDetectorRuleCandidateResponderRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            id=id,
            is_preferred=is_preferred,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: Optional[str] = None,
             id: Optional[str] = None,
             is_preferred: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'isPreferred' in kwargs:
            is_preferred = kwargs['isPreferred']

        if display_name is not None:
            _setter("display_name", display_name)
        if id is not None:
            _setter("id", id)
        if is_preferred is not None:
            _setter("is_preferred", is_preferred)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        (Updatable) Detector recipe display name.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Ocid for detector recipe
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isPreferred")
    def is_preferred(self) -> Optional[bool]:
        """
        Preferred state
        """
        return pulumi.get(self, "is_preferred")


@pulumi.output_type
class DetectorRecipeEffectiveDetectorRuleDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isConfigurationAllowed":
            suggest = "is_configuration_allowed"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "riskLevel":
            suggest = "risk_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DetectorRecipeEffectiveDetectorRuleDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DetectorRecipeEffectiveDetectorRuleDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DetectorRecipeEffectiveDetectorRuleDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: Optional[str] = None,
                 configurations: Optional[Sequence['outputs.DetectorRecipeEffectiveDetectorRuleDetailConfiguration']] = None,
                 is_configuration_allowed: Optional[bool] = None,
                 is_enabled: Optional[bool] = None,
                 labels: Optional[Sequence[str]] = None,
                 risk_level: Optional[str] = None):
        """
        :param str condition: (Updatable) Base condition object
        :param Sequence['DetectorRecipeEffectiveDetectorRuleDetailConfigurationArgs'] configurations: (Updatable) Configuration details
        :param bool is_configuration_allowed: configuration allowed or not
        :param bool is_enabled: (Updatable) Enables the control
        :param Sequence[str] labels: (Updatable) user defined labels for a detector rule
        :param str risk_level: (Updatable) The Risk Level
        """
        DetectorRecipeEffectiveDetectorRuleDetail._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition=condition,
            configurations=configurations,
            is_configuration_allowed=is_configuration_allowed,
            is_enabled=is_enabled,
            labels=labels,
            risk_level=risk_level,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition: Optional[str] = None,
             configurations: Optional[Sequence['outputs.DetectorRecipeEffectiveDetectorRuleDetailConfiguration']] = None,
             is_configuration_allowed: Optional[bool] = None,
             is_enabled: Optional[bool] = None,
             labels: Optional[Sequence[str]] = None,
             risk_level: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'isConfigurationAllowed' in kwargs:
            is_configuration_allowed = kwargs['isConfigurationAllowed']
        if 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']
        if 'riskLevel' in kwargs:
            risk_level = kwargs['riskLevel']

        if condition is not None:
            _setter("condition", condition)
        if configurations is not None:
            _setter("configurations", configurations)
        if is_configuration_allowed is not None:
            _setter("is_configuration_allowed", is_configuration_allowed)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if labels is not None:
            _setter("labels", labels)
        if risk_level is not None:
            _setter("risk_level", risk_level)

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        """
        (Updatable) Base condition object
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def configurations(self) -> Optional[Sequence['outputs.DetectorRecipeEffectiveDetectorRuleDetailConfiguration']]:
        """
        (Updatable) Configuration details
        """
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter(name="isConfigurationAllowed")
    def is_configuration_allowed(self) -> Optional[bool]:
        """
        configuration allowed or not
        """
        return pulumi.get(self, "is_configuration_allowed")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        (Updatable) Enables the control
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Sequence[str]]:
        """
        (Updatable) user defined labels for a detector rule
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> Optional[str]:
        """
        (Updatable) The Risk Level
        """
        return pulumi.get(self, "risk_level")


@pulumi.output_type
class DetectorRecipeEffectiveDetectorRuleDetailConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configKey":
            suggest = "config_key"
        elif key == "dataType":
            suggest = "data_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DetectorRecipeEffectiveDetectorRuleDetailConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DetectorRecipeEffectiveDetectorRuleDetailConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DetectorRecipeEffectiveDetectorRuleDetailConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_key: Optional[str] = None,
                 data_type: Optional[str] = None,
                 name: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence['outputs.DetectorRecipeEffectiveDetectorRuleDetailConfigurationValue']] = None):
        """
        :param str config_key: (Updatable) Unique name of the configuration
        :param str data_type: (Updatable) configuration data type
        :param str name: (Updatable) configuration name
        :param str value: (Updatable) configuration value
        :param Sequence['DetectorRecipeEffectiveDetectorRuleDetailConfigurationValueArgs'] values: (Updatable) List of configuration values
        """
        DetectorRecipeEffectiveDetectorRuleDetailConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_key=config_key,
            data_type=data_type,
            name=name,
            value=value,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_key: Optional[str] = None,
             data_type: Optional[str] = None,
             name: Optional[str] = None,
             value: Optional[str] = None,
             values: Optional[Sequence['outputs.DetectorRecipeEffectiveDetectorRuleDetailConfigurationValue']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'configKey' in kwargs:
            config_key = kwargs['configKey']
        if 'dataType' in kwargs:
            data_type = kwargs['dataType']

        if config_key is not None:
            _setter("config_key", config_key)
        if data_type is not None:
            _setter("data_type", data_type)
        if name is not None:
            _setter("name", name)
        if value is not None:
            _setter("value", value)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> Optional[str]:
        """
        (Updatable) Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[str]:
        """
        (Updatable) configuration data type
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        (Updatable) configuration name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        (Updatable) configuration value
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.DetectorRecipeEffectiveDetectorRuleDetailConfigurationValue']]:
        """
        (Updatable) List of configuration values
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class DetectorRecipeEffectiveDetectorRuleDetailConfigurationValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "listType":
            suggest = "list_type"
        elif key == "managedListType":
            suggest = "managed_list_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DetectorRecipeEffectiveDetectorRuleDetailConfigurationValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DetectorRecipeEffectiveDetectorRuleDetailConfigurationValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DetectorRecipeEffectiveDetectorRuleDetailConfigurationValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 list_type: Optional[str] = None,
                 managed_list_type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str list_type: (Updatable) configuration list item type, either CUSTOM or MANAGED
        :param str managed_list_type: (Updatable) type of the managed list
        :param str value: (Updatable) configuration value
        """
        DetectorRecipeEffectiveDetectorRuleDetailConfigurationValue._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            list_type=list_type,
            managed_list_type=managed_list_type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             list_type: Optional[str] = None,
             managed_list_type: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'listType' in kwargs:
            list_type = kwargs['listType']
        if 'managedListType' in kwargs:
            managed_list_type = kwargs['managedListType']

        if list_type is not None:
            _setter("list_type", list_type)
        if managed_list_type is not None:
            _setter("managed_list_type", managed_list_type)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="listType")
    def list_type(self) -> Optional[str]:
        """
        (Updatable) configuration list item type, either CUSTOM or MANAGED
        """
        return pulumi.get(self, "list_type")

    @property
    @pulumi.getter(name="managedListType")
    def managed_list_type(self) -> Optional[str]:
        """
        (Updatable) type of the managed list
        """
        return pulumi.get(self, "managed_list_type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        (Updatable) configuration value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DetectorRecipeEffectiveDetectorRuleEntitiesMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "entityType":
            suggest = "entity_type"
        elif key == "queryField":
            suggest = "query_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DetectorRecipeEffectiveDetectorRuleEntitiesMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DetectorRecipeEffectiveDetectorRuleEntitiesMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DetectorRecipeEffectiveDetectorRuleEntitiesMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: Optional[str] = None,
                 entity_type: Optional[str] = None,
                 query_field: Optional[str] = None):
        """
        :param str display_name: (Updatable) Detector recipe display name.
               
               Avoid entering confidential information.
        :param str entity_type: (Updatable) Possible type of entity
        :param str query_field: (Updatable) The entity value mapped to a data source query
        """
        DetectorRecipeEffectiveDetectorRuleEntitiesMapping._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            entity_type=entity_type,
            query_field=query_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: Optional[str] = None,
             entity_type: Optional[str] = None,
             query_field: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'entityType' in kwargs:
            entity_type = kwargs['entityType']
        if 'queryField' in kwargs:
            query_field = kwargs['queryField']

        if display_name is not None:
            _setter("display_name", display_name)
        if entity_type is not None:
            _setter("entity_type", entity_type)
        if query_field is not None:
            _setter("query_field", query_field)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        (Updatable) Detector recipe display name.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[str]:
        """
        (Updatable) Possible type of entity
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="queryField")
    def query_field(self) -> Optional[str]:
        """
        (Updatable) The entity value mapped to a data source query
        """
        return pulumi.get(self, "query_field")


@pulumi.output_type
class ResponderRecipeEffectiveResponderRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compartmentId":
            suggest = "compartment_id"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"
        elif key == "responderRuleId":
            suggest = "responder_rule_id"
        elif key == "supportedModes":
            suggest = "supported_modes"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeUpdated":
            suggest = "time_updated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResponderRecipeEffectiveResponderRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResponderRecipeEffectiveResponderRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResponderRecipeEffectiveResponderRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compartment_id: Optional[str] = None,
                 description: Optional[str] = None,
                 details: Optional[Sequence['outputs.ResponderRecipeEffectiveResponderRuleDetail']] = None,
                 display_name: Optional[str] = None,
                 lifecycle_details: Optional[str] = None,
                 policies: Optional[Sequence[str]] = None,
                 responder_rule_id: Optional[str] = None,
                 state: Optional[str] = None,
                 supported_modes: Optional[Sequence[str]] = None,
                 time_created: Optional[str] = None,
                 time_updated: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str compartment_id: (Updatable) Compartment Identifier
        :param str description: (Updatable) Responder recipe description.
               
               Avoid entering confidential information.
        :param Sequence['ResponderRecipeEffectiveResponderRuleDetailArgs'] details: (Updatable) Details of UpdateResponderRuleDetails.
        :param str display_name: (Updatable) Responder recipe display name.
               
               Avoid entering confidential information.
        :param str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param Sequence[str] policies: List of Policy
        :param str responder_rule_id: (Updatable) ResponderRecipeRule Identifier
        :param str state: The current state of the Example.
        :param Sequence[str] supported_modes: Supported Execution Modes
        :param str time_created: The date and time the responder recipe was created. Format defined by RFC3339.
        :param str time_updated: The date and time the responder recipe was updated. Format defined by RFC3339.
        :param str type: Type of Responder
        """
        ResponderRecipeEffectiveResponderRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            description=description,
            details=details,
            display_name=display_name,
            lifecycle_details=lifecycle_details,
            policies=policies,
            responder_rule_id=responder_rule_id,
            state=state,
            supported_modes=supported_modes,
            time_created=time_created,
            time_updated=time_updated,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: Optional[str] = None,
             description: Optional[str] = None,
             details: Optional[Sequence['outputs.ResponderRecipeEffectiveResponderRuleDetail']] = None,
             display_name: Optional[str] = None,
             lifecycle_details: Optional[str] = None,
             policies: Optional[Sequence[str]] = None,
             responder_rule_id: Optional[str] = None,
             state: Optional[str] = None,
             supported_modes: Optional[Sequence[str]] = None,
             time_created: Optional[str] = None,
             time_updated: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if 'responderRuleId' in kwargs:
            responder_rule_id = kwargs['responderRuleId']
        if 'supportedModes' in kwargs:
            supported_modes = kwargs['supportedModes']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        if compartment_id is not None:
            _setter("compartment_id", compartment_id)
        if description is not None:
            _setter("description", description)
        if details is not None:
            _setter("details", details)
        if display_name is not None:
            _setter("display_name", display_name)
        if lifecycle_details is not None:
            _setter("lifecycle_details", lifecycle_details)
        if policies is not None:
            _setter("policies", policies)
        if responder_rule_id is not None:
            _setter("responder_rule_id", responder_rule_id)
        if state is not None:
            _setter("state", state)
        if supported_modes is not None:
            _setter("supported_modes", supported_modes)
        if time_created is not None:
            _setter("time_created", time_created)
        if time_updated is not None:
            _setter("time_updated", time_updated)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[str]:
        """
        (Updatable) Compartment Identifier
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        (Updatable) Responder recipe description.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def details(self) -> Optional[Sequence['outputs.ResponderRecipeEffectiveResponderRuleDetail']]:
        """
        (Updatable) Details of UpdateResponderRuleDetails.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        (Updatable) Responder recipe display name.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[str]:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[str]]:
        """
        List of Policy
        """
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="responderRuleId")
    def responder_rule_id(self) -> Optional[str]:
        """
        (Updatable) ResponderRecipeRule Identifier
        """
        return pulumi.get(self, "responder_rule_id")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        The current state of the Example.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="supportedModes")
    def supported_modes(self) -> Optional[Sequence[str]]:
        """
        Supported Execution Modes
        """
        return pulumi.get(self, "supported_modes")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[str]:
        """
        The date and time the responder recipe was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[str]:
        """
        The date and time the responder recipe was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of Responder
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ResponderRecipeEffectiveResponderRuleDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResponderRecipeEffectiveResponderRuleDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResponderRecipeEffectiveResponderRuleDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResponderRecipeEffectiveResponderRuleDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: Optional[str] = None,
                 configurations: Optional[Sequence['outputs.ResponderRecipeEffectiveResponderRuleDetailConfiguration']] = None,
                 is_enabled: Optional[bool] = None,
                 mode: Optional[str] = None):
        """
        :param str condition: Base condition object
        :param Sequence['ResponderRecipeEffectiveResponderRuleDetailConfigurationArgs'] configurations: ResponderRule configurations
        :param bool is_enabled: (Updatable) Identifies state for ResponderRule
        :param str mode: Execution Mode for ResponderRule
        """
        ResponderRecipeEffectiveResponderRuleDetail._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition=condition,
            configurations=configurations,
            is_enabled=is_enabled,
            mode=mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition: Optional[str] = None,
             configurations: Optional[Sequence['outputs.ResponderRecipeEffectiveResponderRuleDetailConfiguration']] = None,
             is_enabled: Optional[bool] = None,
             mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']

        if condition is not None:
            _setter("condition", condition)
        if configurations is not None:
            _setter("configurations", configurations)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if mode is not None:
            _setter("mode", mode)

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        """
        Base condition object
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def configurations(self) -> Optional[Sequence['outputs.ResponderRecipeEffectiveResponderRuleDetailConfiguration']]:
        """
        ResponderRule configurations
        """
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        (Updatable) Identifies state for ResponderRule
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Execution Mode for ResponderRule
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class ResponderRecipeEffectiveResponderRuleDetailConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configKey":
            suggest = "config_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResponderRecipeEffectiveResponderRuleDetailConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResponderRecipeEffectiveResponderRuleDetailConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResponderRecipeEffectiveResponderRuleDetailConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_key: Optional[str] = None,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str config_key: Unique name of the configuration
        :param str name: configuration name
        :param str value: configuration value
        """
        ResponderRecipeEffectiveResponderRuleDetailConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_key=config_key,
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_key: Optional[str] = None,
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'configKey' in kwargs:
            config_key = kwargs['configKey']

        if config_key is not None:
            _setter("config_key", config_key)
        if name is not None:
            _setter("name", name)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> Optional[str]:
        """
        Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        configuration name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        configuration value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ResponderRecipeResponderRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "responderRuleId":
            suggest = "responder_rule_id"
        elif key == "compartmentId":
            suggest = "compartment_id"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"
        elif key == "supportedModes":
            suggest = "supported_modes"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeUpdated":
            suggest = "time_updated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResponderRecipeResponderRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResponderRecipeResponderRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResponderRecipeResponderRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 details: 'outputs.ResponderRecipeResponderRuleDetails',
                 responder_rule_id: str,
                 compartment_id: Optional[str] = None,
                 description: Optional[str] = None,
                 display_name: Optional[str] = None,
                 lifecycle_details: Optional[str] = None,
                 policies: Optional[Sequence[str]] = None,
                 state: Optional[str] = None,
                 supported_modes: Optional[Sequence[str]] = None,
                 time_created: Optional[str] = None,
                 time_updated: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param 'ResponderRecipeResponderRuleDetailsArgs' details: (Updatable) Details of UpdateResponderRuleDetails.
        :param str responder_rule_id: (Updatable) ResponderRecipeRule Identifier
        :param str compartment_id: (Updatable) Compartment Identifier
        :param str description: (Updatable) Responder recipe description.
               
               Avoid entering confidential information.
        :param str display_name: (Updatable) Responder recipe display name.
               
               Avoid entering confidential information.
        :param str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param Sequence[str] policies: List of Policy
        :param str state: The current state of the Example.
        :param Sequence[str] supported_modes: Supported Execution Modes
        :param str time_created: The date and time the responder recipe was created. Format defined by RFC3339.
        :param str time_updated: The date and time the responder recipe was updated. Format defined by RFC3339.
        :param str type: Type of Responder
        """
        ResponderRecipeResponderRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            details=details,
            responder_rule_id=responder_rule_id,
            compartment_id=compartment_id,
            description=description,
            display_name=display_name,
            lifecycle_details=lifecycle_details,
            policies=policies,
            state=state,
            supported_modes=supported_modes,
            time_created=time_created,
            time_updated=time_updated,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             details: 'outputs.ResponderRecipeResponderRuleDetails',
             responder_rule_id: str,
             compartment_id: Optional[str] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             lifecycle_details: Optional[str] = None,
             policies: Optional[Sequence[str]] = None,
             state: Optional[str] = None,
             supported_modes: Optional[Sequence[str]] = None,
             time_created: Optional[str] = None,
             time_updated: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'responderRuleId' in kwargs:
            responder_rule_id = kwargs['responderRuleId']
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if 'supportedModes' in kwargs:
            supported_modes = kwargs['supportedModes']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("details", details)
        _setter("responder_rule_id", responder_rule_id)
        if compartment_id is not None:
            _setter("compartment_id", compartment_id)
        if description is not None:
            _setter("description", description)
        if display_name is not None:
            _setter("display_name", display_name)
        if lifecycle_details is not None:
            _setter("lifecycle_details", lifecycle_details)
        if policies is not None:
            _setter("policies", policies)
        if state is not None:
            _setter("state", state)
        if supported_modes is not None:
            _setter("supported_modes", supported_modes)
        if time_created is not None:
            _setter("time_created", time_created)
        if time_updated is not None:
            _setter("time_updated", time_updated)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def details(self) -> 'outputs.ResponderRecipeResponderRuleDetails':
        """
        (Updatable) Details of UpdateResponderRuleDetails.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter(name="responderRuleId")
    def responder_rule_id(self) -> str:
        """
        (Updatable) ResponderRecipeRule Identifier
        """
        return pulumi.get(self, "responder_rule_id")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[str]:
        """
        (Updatable) Compartment Identifier
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        (Updatable) Responder recipe description.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        (Updatable) Responder recipe display name.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[str]:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[str]]:
        """
        List of Policy
        """
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        The current state of the Example.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="supportedModes")
    def supported_modes(self) -> Optional[Sequence[str]]:
        """
        Supported Execution Modes
        """
        return pulumi.get(self, "supported_modes")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[str]:
        """
        The date and time the responder recipe was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[str]:
        """
        The date and time the responder recipe was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of Responder
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ResponderRecipeResponderRuleDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResponderRecipeResponderRuleDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResponderRecipeResponderRuleDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResponderRecipeResponderRuleDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_enabled: bool,
                 condition: Optional[str] = None,
                 configurations: Optional[Sequence['outputs.ResponderRecipeResponderRuleDetailsConfiguration']] = None,
                 mode: Optional[str] = None):
        """
        :param bool is_enabled: (Updatable) Identifies state for ResponderRule
        :param str condition: Base condition object
        :param Sequence['ResponderRecipeResponderRuleDetailsConfigurationArgs'] configurations: ResponderRule configurations
        :param str mode: Execution Mode for ResponderRule
        """
        ResponderRecipeResponderRuleDetails._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_enabled=is_enabled,
            condition=condition,
            configurations=configurations,
            mode=mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_enabled: bool,
             condition: Optional[str] = None,
             configurations: Optional[Sequence['outputs.ResponderRecipeResponderRuleDetailsConfiguration']] = None,
             mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']

        _setter("is_enabled", is_enabled)
        if condition is not None:
            _setter("condition", condition)
        if configurations is not None:
            _setter("configurations", configurations)
        if mode is not None:
            _setter("mode", mode)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        (Updatable) Identifies state for ResponderRule
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        """
        Base condition object
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def configurations(self) -> Optional[Sequence['outputs.ResponderRecipeResponderRuleDetailsConfiguration']]:
        """
        ResponderRule configurations
        """
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Execution Mode for ResponderRule
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class ResponderRecipeResponderRuleDetailsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configKey":
            suggest = "config_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResponderRecipeResponderRuleDetailsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResponderRecipeResponderRuleDetailsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResponderRecipeResponderRuleDetailsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_key: Optional[str] = None,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str config_key: Unique name of the configuration
        :param str name: configuration name
        :param str value: configuration value
        """
        ResponderRecipeResponderRuleDetailsConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_key=config_key,
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_key: Optional[str] = None,
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'configKey' in kwargs:
            config_key = kwargs['configKey']

        if config_key is not None:
            _setter("config_key", config_key)
        if name is not None:
            _setter("name", name)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> Optional[str]:
        """
        Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        configuration name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        configuration value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TargetTargetDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityZoneDisplayName":
            suggest = "security_zone_display_name"
        elif key == "securityZoneId":
            suggest = "security_zone_id"
        elif key == "targetResourceType":
            suggest = "target_resource_type"
        elif key == "targetSecurityZoneRecipes":
            suggest = "target_security_zone_recipes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetTargetDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetTargetDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetTargetDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 security_zone_display_name: Optional[str] = None,
                 security_zone_id: Optional[str] = None,
                 target_resource_type: Optional[str] = None,
                 target_security_zone_recipes: Optional[Sequence['outputs.TargetTargetDetailTargetSecurityZoneRecipe']] = None):
        """
        :param str security_zone_display_name: The name of the security zone to associate this compartment with.
        :param str security_zone_id: The OCID of the security zone to associate this compartment with.
        :param str target_resource_type: possible type of targets(COMPARTMENT/FACLOUD)
        :param Sequence['TargetTargetDetailTargetSecurityZoneRecipeArgs'] target_security_zone_recipes: The list of security zone recipes to associate this compartment with.
        """
        TargetTargetDetail._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            security_zone_display_name=security_zone_display_name,
            security_zone_id=security_zone_id,
            target_resource_type=target_resource_type,
            target_security_zone_recipes=target_security_zone_recipes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             security_zone_display_name: Optional[str] = None,
             security_zone_id: Optional[str] = None,
             target_resource_type: Optional[str] = None,
             target_security_zone_recipes: Optional[Sequence['outputs.TargetTargetDetailTargetSecurityZoneRecipe']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'securityZoneDisplayName' in kwargs:
            security_zone_display_name = kwargs['securityZoneDisplayName']
        if 'securityZoneId' in kwargs:
            security_zone_id = kwargs['securityZoneId']
        if 'targetResourceType' in kwargs:
            target_resource_type = kwargs['targetResourceType']
        if 'targetSecurityZoneRecipes' in kwargs:
            target_security_zone_recipes = kwargs['targetSecurityZoneRecipes']

        if security_zone_display_name is not None:
            _setter("security_zone_display_name", security_zone_display_name)
        if security_zone_id is not None:
            _setter("security_zone_id", security_zone_id)
        if target_resource_type is not None:
            _setter("target_resource_type", target_resource_type)
        if target_security_zone_recipes is not None:
            _setter("target_security_zone_recipes", target_security_zone_recipes)

    @property
    @pulumi.getter(name="securityZoneDisplayName")
    def security_zone_display_name(self) -> Optional[str]:
        """
        The name of the security zone to associate this compartment with.
        """
        return pulumi.get(self, "security_zone_display_name")

    @property
    @pulumi.getter(name="securityZoneId")
    def security_zone_id(self) -> Optional[str]:
        """
        The OCID of the security zone to associate this compartment with.
        """
        return pulumi.get(self, "security_zone_id")

    @property
    @pulumi.getter(name="targetResourceType")
    def target_resource_type(self) -> Optional[str]:
        """
        possible type of targets(COMPARTMENT/FACLOUD)
        """
        return pulumi.get(self, "target_resource_type")

    @property
    @pulumi.getter(name="targetSecurityZoneRecipes")
    def target_security_zone_recipes(self) -> Optional[Sequence['outputs.TargetTargetDetailTargetSecurityZoneRecipe']]:
        """
        The list of security zone recipes to associate this compartment with.
        """
        return pulumi.get(self, "target_security_zone_recipes")


@pulumi.output_type
class TargetTargetDetailTargetSecurityZoneRecipe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compartmentId":
            suggest = "compartment_id"
        elif key == "definedTags":
            suggest = "defined_tags"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "freeformTags":
            suggest = "freeform_tags"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"
        elif key == "securityPolicies":
            suggest = "security_policies"
        elif key == "systemTags":
            suggest = "system_tags"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeUpdated":
            suggest = "time_updated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetTargetDetailTargetSecurityZoneRecipe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetTargetDetailTargetSecurityZoneRecipe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetTargetDetailTargetSecurityZoneRecipe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compartment_id: Optional[str] = None,
                 defined_tags: Optional[Mapping[str, Any]] = None,
                 description: Optional[str] = None,
                 display_name: Optional[str] = None,
                 freeform_tags: Optional[Mapping[str, Any]] = None,
                 id: Optional[str] = None,
                 lifecycle_details: Optional[str] = None,
                 owner: Optional[str] = None,
                 security_policies: Optional[Sequence[str]] = None,
                 state: Optional[str] = None,
                 system_tags: Optional[Mapping[str, Any]] = None,
                 time_created: Optional[str] = None,
                 time_updated: Optional[str] = None):
        """
        :param str compartment_id: (Updatable) compartment associated with condition
        :param Mapping[str, Any] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param str description: The target description.
               
               Avoid entering confidential information.
        :param str display_name: (Updatable) DetectorTemplate identifier.
               
               Avoid entering confidential information.
        :param Mapping[str, Any] freeform_tags: (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
               
               Avoid entering confidential information.
        :param str id: Unique identifier of TargetResponderRecipe that can't be changed after creation.
        :param str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param str owner: Owner of ResponderRecipe
        :param Sequence[str] security_policies: The list of `SecurityPolicy` ids that are included in the recipe
        :param str state: (Updatable) The current state of the DetectorRule.
        :param Mapping[str, Any] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). System tags can be viewed by users, but can only be created by the system.  Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param str time_created: The date and time the target was created. Format defined by RFC3339.
        :param str time_updated: The date and time the target was updated. Format defined by RFC3339.
        """
        TargetTargetDetailTargetSecurityZoneRecipe._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            lifecycle_details=lifecycle_details,
            owner=owner,
            security_policies=security_policies,
            state=state,
            system_tags=system_tags,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             lifecycle_details: Optional[str] = None,
             owner: Optional[str] = None,
             security_policies: Optional[Sequence[str]] = None,
             state: Optional[str] = None,
             system_tags: Optional[Mapping[str, Any]] = None,
             time_created: Optional[str] = None,
             time_updated: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if 'securityPolicies' in kwargs:
            security_policies = kwargs['securityPolicies']
        if 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        if compartment_id is not None:
            _setter("compartment_id", compartment_id)
        if defined_tags is not None:
            _setter("defined_tags", defined_tags)
        if description is not None:
            _setter("description", description)
        if display_name is not None:
            _setter("display_name", display_name)
        if freeform_tags is not None:
            _setter("freeform_tags", freeform_tags)
        if id is not None:
            _setter("id", id)
        if lifecycle_details is not None:
            _setter("lifecycle_details", lifecycle_details)
        if owner is not None:
            _setter("owner", owner)
        if security_policies is not None:
            _setter("security_policies", security_policies)
        if state is not None:
            _setter("state", state)
        if system_tags is not None:
            _setter("system_tags", system_tags)
        if time_created is not None:
            _setter("time_created", time_created)
        if time_updated is not None:
            _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[str]:
        """
        (Updatable) compartment associated with condition
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[Mapping[str, Any]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The target description.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        (Updatable) DetectorTemplate identifier.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[Mapping[str, Any]]:
        """
        (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`

        Avoid entering confidential information.
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of TargetResponderRecipe that can't be changed after creation.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[str]:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def owner(self) -> Optional[str]:
        """
        Owner of ResponderRecipe
        """
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter(name="securityPolicies")
    def security_policies(self) -> Optional[Sequence[str]]:
        """
        The list of `SecurityPolicy` ids that are included in the recipe
        """
        return pulumi.get(self, "security_policies")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        (Updatable) The current state of the DetectorRule.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Optional[Mapping[str, Any]]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). System tags can be viewed by users, but can only be created by the system.  Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[str]:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[str]:
        """
        The date and time the target was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class TargetTargetDetectorRecipe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "detectorRecipeId":
            suggest = "detector_recipe_id"
        elif key == "compartmentId":
            suggest = "compartment_id"
        elif key == "detectorRules":
            suggest = "detector_rules"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "effectiveDetectorRules":
            suggest = "effective_detector_rules"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeUpdated":
            suggest = "time_updated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetTargetDetectorRecipe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetTargetDetectorRecipe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetTargetDetectorRecipe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 detector_recipe_id: str,
                 compartment_id: Optional[str] = None,
                 description: Optional[str] = None,
                 detector: Optional[str] = None,
                 detector_rules: Optional[Sequence['outputs.TargetTargetDetectorRecipeDetectorRule']] = None,
                 display_name: Optional[str] = None,
                 effective_detector_rules: Optional[Sequence['outputs.TargetTargetDetectorRecipeEffectiveDetectorRule']] = None,
                 id: Optional[str] = None,
                 owner: Optional[str] = None,
                 state: Optional[str] = None,
                 time_created: Optional[str] = None,
                 time_updated: Optional[str] = None):
        """
        :param str detector_recipe_id: Identifier for DetectorRecipe.
        :param str compartment_id: (Updatable) compartment associated with condition
        :param str description: The target description.
               
               Avoid entering confidential information.
        :param str detector: detector for the rule
        :param Sequence['TargetTargetDetectorRecipeDetectorRuleArgs'] detector_rules: (Updatable) Overrides to be applied to Detector Rule associated with the target
        :param str display_name: (Updatable) DetectorTemplate identifier.
               
               Avoid entering confidential information.
        :param Sequence['TargetTargetDetectorRecipeEffectiveDetectorRuleArgs'] effective_detector_rules: List of effective detector rules for the detector type for recipe after applying defaults
        :param str id: Unique identifier of TargetResponderRecipe that can't be changed after creation.
        :param str owner: Owner of ResponderRecipe
        :param str state: (Updatable) The current state of the DetectorRule.
        :param str time_created: The date and time the target was created. Format defined by RFC3339.
        :param str time_updated: The date and time the target was updated. Format defined by RFC3339.
        """
        TargetTargetDetectorRecipe._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            detector_recipe_id=detector_recipe_id,
            compartment_id=compartment_id,
            description=description,
            detector=detector,
            detector_rules=detector_rules,
            display_name=display_name,
            effective_detector_rules=effective_detector_rules,
            id=id,
            owner=owner,
            state=state,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             detector_recipe_id: str,
             compartment_id: Optional[str] = None,
             description: Optional[str] = None,
             detector: Optional[str] = None,
             detector_rules: Optional[Sequence['outputs.TargetTargetDetectorRecipeDetectorRule']] = None,
             display_name: Optional[str] = None,
             effective_detector_rules: Optional[Sequence['outputs.TargetTargetDetectorRecipeEffectiveDetectorRule']] = None,
             id: Optional[str] = None,
             owner: Optional[str] = None,
             state: Optional[str] = None,
             time_created: Optional[str] = None,
             time_updated: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'detectorRecipeId' in kwargs:
            detector_recipe_id = kwargs['detectorRecipeId']
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if 'detectorRules' in kwargs:
            detector_rules = kwargs['detectorRules']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'effectiveDetectorRules' in kwargs:
            effective_detector_rules = kwargs['effectiveDetectorRules']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("detector_recipe_id", detector_recipe_id)
        if compartment_id is not None:
            _setter("compartment_id", compartment_id)
        if description is not None:
            _setter("description", description)
        if detector is not None:
            _setter("detector", detector)
        if detector_rules is not None:
            _setter("detector_rules", detector_rules)
        if display_name is not None:
            _setter("display_name", display_name)
        if effective_detector_rules is not None:
            _setter("effective_detector_rules", effective_detector_rules)
        if id is not None:
            _setter("id", id)
        if owner is not None:
            _setter("owner", owner)
        if state is not None:
            _setter("state", state)
        if time_created is not None:
            _setter("time_created", time_created)
        if time_updated is not None:
            _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="detectorRecipeId")
    def detector_recipe_id(self) -> str:
        """
        Identifier for DetectorRecipe.
        """
        return pulumi.get(self, "detector_recipe_id")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[str]:
        """
        (Updatable) compartment associated with condition
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The target description.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def detector(self) -> Optional[str]:
        """
        detector for the rule
        """
        return pulumi.get(self, "detector")

    @property
    @pulumi.getter(name="detectorRules")
    def detector_rules(self) -> Optional[Sequence['outputs.TargetTargetDetectorRecipeDetectorRule']]:
        """
        (Updatable) Overrides to be applied to Detector Rule associated with the target
        """
        return pulumi.get(self, "detector_rules")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        (Updatable) DetectorTemplate identifier.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="effectiveDetectorRules")
    def effective_detector_rules(self) -> Optional[Sequence['outputs.TargetTargetDetectorRecipeEffectiveDetectorRule']]:
        """
        List of effective detector rules for the detector type for recipe after applying defaults
        """
        return pulumi.get(self, "effective_detector_rules")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of TargetResponderRecipe that can't be changed after creation.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def owner(self) -> Optional[str]:
        """
        Owner of ResponderRecipe
        """
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        (Updatable) The current state of the DetectorRule.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[str]:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[str]:
        """
        The date and time the target was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class TargetTargetDetectorRecipeDetectorRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "detectorRuleId":
            suggest = "detector_rule_id"
        elif key == "dataSourceId":
            suggest = "data_source_id"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "entitiesMappings":
            suggest = "entities_mappings"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"
        elif key == "managedListTypes":
            suggest = "managed_list_types"
        elif key == "resourceType":
            suggest = "resource_type"
        elif key == "serviceType":
            suggest = "service_type"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeUpdated":
            suggest = "time_updated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetTargetDetectorRecipeDetectorRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetTargetDetectorRecipeDetectorRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetTargetDetectorRecipeDetectorRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 details: 'outputs.TargetTargetDetectorRecipeDetectorRuleDetails',
                 detector_rule_id: str,
                 data_source_id: Optional[str] = None,
                 description: Optional[str] = None,
                 detector: Optional[str] = None,
                 display_name: Optional[str] = None,
                 entities_mappings: Optional[Sequence['outputs.TargetTargetDetectorRecipeDetectorRuleEntitiesMapping']] = None,
                 lifecycle_details: Optional[str] = None,
                 managed_list_types: Optional[Sequence[str]] = None,
                 recommendation: Optional[str] = None,
                 resource_type: Optional[str] = None,
                 service_type: Optional[str] = None,
                 state: Optional[str] = None,
                 time_created: Optional[str] = None,
                 time_updated: Optional[str] = None):
        """
        :param 'TargetTargetDetectorRecipeDetectorRuleDetailsArgs' details: (Updatable) Details of ResponderRule.
        :param str detector_rule_id: (Updatable) Identifier for DetectorRule.
        :param str data_source_id: The id of the attached DataSource.
        :param str description: The target description.
               
               Avoid entering confidential information.
        :param str detector: detector for the rule
        :param str display_name: (Updatable) DetectorTemplate identifier.
               
               Avoid entering confidential information.
        :param Sequence['TargetTargetDetectorRecipeDetectorRuleEntitiesMappingArgs'] entities_mappings: Data Source entities mapping for a Detector Rule
        :param str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param Sequence[str] managed_list_types: List of cloudguard managed list types related to this rule
        :param str recommendation: Recommendation for TargetDetectorRecipeDetectorRule
        :param str resource_type: resource type of the configuration to which the rule is applied
        :param str service_type: service type of the configuration to which the rule is applied
        :param str state: (Updatable) The current state of the DetectorRule.
        :param str time_created: The date and time the target was created. Format defined by RFC3339.
        :param str time_updated: The date and time the target was updated. Format defined by RFC3339.
        """
        TargetTargetDetectorRecipeDetectorRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            details=details,
            detector_rule_id=detector_rule_id,
            data_source_id=data_source_id,
            description=description,
            detector=detector,
            display_name=display_name,
            entities_mappings=entities_mappings,
            lifecycle_details=lifecycle_details,
            managed_list_types=managed_list_types,
            recommendation=recommendation,
            resource_type=resource_type,
            service_type=service_type,
            state=state,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             details: 'outputs.TargetTargetDetectorRecipeDetectorRuleDetails',
             detector_rule_id: str,
             data_source_id: Optional[str] = None,
             description: Optional[str] = None,
             detector: Optional[str] = None,
             display_name: Optional[str] = None,
             entities_mappings: Optional[Sequence['outputs.TargetTargetDetectorRecipeDetectorRuleEntitiesMapping']] = None,
             lifecycle_details: Optional[str] = None,
             managed_list_types: Optional[Sequence[str]] = None,
             recommendation: Optional[str] = None,
             resource_type: Optional[str] = None,
             service_type: Optional[str] = None,
             state: Optional[str] = None,
             time_created: Optional[str] = None,
             time_updated: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'detectorRuleId' in kwargs:
            detector_rule_id = kwargs['detectorRuleId']
        if 'dataSourceId' in kwargs:
            data_source_id = kwargs['dataSourceId']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'entitiesMappings' in kwargs:
            entities_mappings = kwargs['entitiesMappings']
        if 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if 'managedListTypes' in kwargs:
            managed_list_types = kwargs['managedListTypes']
        if 'resourceType' in kwargs:
            resource_type = kwargs['resourceType']
        if 'serviceType' in kwargs:
            service_type = kwargs['serviceType']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("details", details)
        _setter("detector_rule_id", detector_rule_id)
        if data_source_id is not None:
            _setter("data_source_id", data_source_id)
        if description is not None:
            _setter("description", description)
        if detector is not None:
            _setter("detector", detector)
        if display_name is not None:
            _setter("display_name", display_name)
        if entities_mappings is not None:
            _setter("entities_mappings", entities_mappings)
        if lifecycle_details is not None:
            _setter("lifecycle_details", lifecycle_details)
        if managed_list_types is not None:
            _setter("managed_list_types", managed_list_types)
        if recommendation is not None:
            _setter("recommendation", recommendation)
        if resource_type is not None:
            _setter("resource_type", resource_type)
        if service_type is not None:
            _setter("service_type", service_type)
        if state is not None:
            _setter("state", state)
        if time_created is not None:
            _setter("time_created", time_created)
        if time_updated is not None:
            _setter("time_updated", time_updated)

    @property
    @pulumi.getter
    def details(self) -> 'outputs.TargetTargetDetectorRecipeDetectorRuleDetails':
        """
        (Updatable) Details of ResponderRule.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter(name="detectorRuleId")
    def detector_rule_id(self) -> str:
        """
        (Updatable) Identifier for DetectorRule.
        """
        return pulumi.get(self, "detector_rule_id")

    @property
    @pulumi.getter(name="dataSourceId")
    def data_source_id(self) -> Optional[str]:
        """
        The id of the attached DataSource.
        """
        return pulumi.get(self, "data_source_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The target description.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def detector(self) -> Optional[str]:
        """
        detector for the rule
        """
        return pulumi.get(self, "detector")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        (Updatable) DetectorTemplate identifier.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="entitiesMappings")
    def entities_mappings(self) -> Optional[Sequence['outputs.TargetTargetDetectorRecipeDetectorRuleEntitiesMapping']]:
        """
        Data Source entities mapping for a Detector Rule
        """
        return pulumi.get(self, "entities_mappings")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[str]:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="managedListTypes")
    def managed_list_types(self) -> Optional[Sequence[str]]:
        """
        List of cloudguard managed list types related to this rule
        """
        return pulumi.get(self, "managed_list_types")

    @property
    @pulumi.getter
    def recommendation(self) -> Optional[str]:
        """
        Recommendation for TargetDetectorRecipeDetectorRule
        """
        return pulumi.get(self, "recommendation")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[str]:
        """
        resource type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> Optional[str]:
        """
        service type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "service_type")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        (Updatable) The current state of the DetectorRule.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[str]:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[str]:
        """
        The date and time the target was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class TargetTargetDetectorRecipeDetectorRuleDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionGroups":
            suggest = "condition_groups"
        elif key == "isConfigurationAllowed":
            suggest = "is_configuration_allowed"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "riskLevel":
            suggest = "risk_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetTargetDetectorRecipeDetectorRuleDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetTargetDetectorRecipeDetectorRuleDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetTargetDetectorRecipeDetectorRuleDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition_groups: Optional[Sequence['outputs.TargetTargetDetectorRecipeDetectorRuleDetailsConditionGroup']] = None,
                 configurations: Optional[Sequence['outputs.TargetTargetDetectorRecipeDetectorRuleDetailsConfiguration']] = None,
                 is_configuration_allowed: Optional[bool] = None,
                 is_enabled: Optional[bool] = None,
                 labels: Optional[Sequence[str]] = None,
                 risk_level: Optional[str] = None):
        """
        :param Sequence['TargetTargetDetectorRecipeDetectorRuleDetailsConditionGroupArgs'] condition_groups: (Updatable) Condition group corresponding to each compartment
        :param Sequence['TargetTargetDetectorRecipeDetectorRuleDetailsConfigurationArgs'] configurations: (Updatable) Configurations associated with the ResponderRule
        :param bool is_configuration_allowed: configuration allowed or not
        :param bool is_enabled: Identifies state for ResponderRule
        :param Sequence[str] labels: user defined labels for a detector rule
        :param str risk_level: The Risk Level
        """
        TargetTargetDetectorRecipeDetectorRuleDetails._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition_groups=condition_groups,
            configurations=configurations,
            is_configuration_allowed=is_configuration_allowed,
            is_enabled=is_enabled,
            labels=labels,
            risk_level=risk_level,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition_groups: Optional[Sequence['outputs.TargetTargetDetectorRecipeDetectorRuleDetailsConditionGroup']] = None,
             configurations: Optional[Sequence['outputs.TargetTargetDetectorRecipeDetectorRuleDetailsConfiguration']] = None,
             is_configuration_allowed: Optional[bool] = None,
             is_enabled: Optional[bool] = None,
             labels: Optional[Sequence[str]] = None,
             risk_level: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'conditionGroups' in kwargs:
            condition_groups = kwargs['conditionGroups']
        if 'isConfigurationAllowed' in kwargs:
            is_configuration_allowed = kwargs['isConfigurationAllowed']
        if 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']
        if 'riskLevel' in kwargs:
            risk_level = kwargs['riskLevel']

        if condition_groups is not None:
            _setter("condition_groups", condition_groups)
        if configurations is not None:
            _setter("configurations", configurations)
        if is_configuration_allowed is not None:
            _setter("is_configuration_allowed", is_configuration_allowed)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if labels is not None:
            _setter("labels", labels)
        if risk_level is not None:
            _setter("risk_level", risk_level)

    @property
    @pulumi.getter(name="conditionGroups")
    def condition_groups(self) -> Optional[Sequence['outputs.TargetTargetDetectorRecipeDetectorRuleDetailsConditionGroup']]:
        """
        (Updatable) Condition group corresponding to each compartment
        """
        return pulumi.get(self, "condition_groups")

    @property
    @pulumi.getter
    def configurations(self) -> Optional[Sequence['outputs.TargetTargetDetectorRecipeDetectorRuleDetailsConfiguration']]:
        """
        (Updatable) Configurations associated with the ResponderRule
        """
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter(name="isConfigurationAllowed")
    def is_configuration_allowed(self) -> Optional[bool]:
        """
        configuration allowed or not
        """
        return pulumi.get(self, "is_configuration_allowed")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Identifies state for ResponderRule
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Sequence[str]]:
        """
        user defined labels for a detector rule
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> Optional[str]:
        """
        The Risk Level
        """
        return pulumi.get(self, "risk_level")


@pulumi.output_type
class TargetTargetDetectorRecipeDetectorRuleDetailsConditionGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compartmentId":
            suggest = "compartment_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetTargetDetectorRecipeDetectorRuleDetailsConditionGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetTargetDetectorRecipeDetectorRuleDetailsConditionGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetTargetDetectorRecipeDetectorRuleDetailsConditionGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compartment_id: str,
                 condition: str):
        """
        :param str compartment_id: (Updatable) compartment associated with condition
        :param str condition: (Updatable) Base condition object
        """
        TargetTargetDetectorRecipeDetectorRuleDetailsConditionGroup._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            condition=condition,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             condition: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']

        _setter("compartment_id", compartment_id)
        _setter("condition", condition)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        (Updatable) compartment associated with condition
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        (Updatable) Base condition object
        """
        return pulumi.get(self, "condition")


@pulumi.output_type
class TargetTargetDetectorRecipeDetectorRuleDetailsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configKey":
            suggest = "config_key"
        elif key == "dataType":
            suggest = "data_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetTargetDetectorRecipeDetectorRuleDetailsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetTargetDetectorRecipeDetectorRuleDetailsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetTargetDetectorRecipeDetectorRuleDetailsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_key: Optional[str] = None,
                 data_type: Optional[str] = None,
                 name: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence['outputs.TargetTargetDetectorRecipeDetectorRuleDetailsConfigurationValue']] = None):
        """
        :param str config_key: (Updatable) Unique name of the configuration
        :param str data_type: configuration data type
        :param str name: (Updatable) configuration name
        :param str value: (Updatable) configuration value
        :param Sequence['TargetTargetDetectorRecipeDetectorRuleDetailsConfigurationValueArgs'] values: List of configuration values
        """
        TargetTargetDetectorRecipeDetectorRuleDetailsConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_key=config_key,
            data_type=data_type,
            name=name,
            value=value,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_key: Optional[str] = None,
             data_type: Optional[str] = None,
             name: Optional[str] = None,
             value: Optional[str] = None,
             values: Optional[Sequence['outputs.TargetTargetDetectorRecipeDetectorRuleDetailsConfigurationValue']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'configKey' in kwargs:
            config_key = kwargs['configKey']
        if 'dataType' in kwargs:
            data_type = kwargs['dataType']

        if config_key is not None:
            _setter("config_key", config_key)
        if data_type is not None:
            _setter("data_type", data_type)
        if name is not None:
            _setter("name", name)
        if value is not None:
            _setter("value", value)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> Optional[str]:
        """
        (Updatable) Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[str]:
        """
        configuration data type
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        (Updatable) configuration name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        (Updatable) configuration value
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.TargetTargetDetectorRecipeDetectorRuleDetailsConfigurationValue']]:
        """
        List of configuration values
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class TargetTargetDetectorRecipeDetectorRuleDetailsConfigurationValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "listType":
            suggest = "list_type"
        elif key == "managedListType":
            suggest = "managed_list_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetTargetDetectorRecipeDetectorRuleDetailsConfigurationValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetTargetDetectorRecipeDetectorRuleDetailsConfigurationValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetTargetDetectorRecipeDetectorRuleDetailsConfigurationValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 list_type: Optional[str] = None,
                 managed_list_type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str list_type: configuration list item type, either CUSTOM or MANAGED
        :param str managed_list_type: type of the managed list
        :param str value: (Updatable) configuration value
        """
        TargetTargetDetectorRecipeDetectorRuleDetailsConfigurationValue._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            list_type=list_type,
            managed_list_type=managed_list_type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             list_type: Optional[str] = None,
             managed_list_type: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'listType' in kwargs:
            list_type = kwargs['listType']
        if 'managedListType' in kwargs:
            managed_list_type = kwargs['managedListType']

        if list_type is not None:
            _setter("list_type", list_type)
        if managed_list_type is not None:
            _setter("managed_list_type", managed_list_type)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="listType")
    def list_type(self) -> Optional[str]:
        """
        configuration list item type, either CUSTOM or MANAGED
        """
        return pulumi.get(self, "list_type")

    @property
    @pulumi.getter(name="managedListType")
    def managed_list_type(self) -> Optional[str]:
        """
        type of the managed list
        """
        return pulumi.get(self, "managed_list_type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        (Updatable) configuration value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TargetTargetDetectorRecipeDetectorRuleEntitiesMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "entityType":
            suggest = "entity_type"
        elif key == "queryField":
            suggest = "query_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetTargetDetectorRecipeDetectorRuleEntitiesMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetTargetDetectorRecipeDetectorRuleEntitiesMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetTargetDetectorRecipeDetectorRuleEntitiesMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: Optional[str] = None,
                 entity_type: Optional[str] = None,
                 query_field: Optional[str] = None):
        """
        :param str display_name: (Updatable) DetectorTemplate identifier.
               
               Avoid entering confidential information.
        :param str entity_type: Possible type of entity
        :param str query_field: The entity value mapped to a data source query
        """
        TargetTargetDetectorRecipeDetectorRuleEntitiesMapping._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            entity_type=entity_type,
            query_field=query_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: Optional[str] = None,
             entity_type: Optional[str] = None,
             query_field: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'entityType' in kwargs:
            entity_type = kwargs['entityType']
        if 'queryField' in kwargs:
            query_field = kwargs['queryField']

        if display_name is not None:
            _setter("display_name", display_name)
        if entity_type is not None:
            _setter("entity_type", entity_type)
        if query_field is not None:
            _setter("query_field", query_field)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        (Updatable) DetectorTemplate identifier.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[str]:
        """
        Possible type of entity
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="queryField")
    def query_field(self) -> Optional[str]:
        """
        The entity value mapped to a data source query
        """
        return pulumi.get(self, "query_field")


@pulumi.output_type
class TargetTargetDetectorRecipeEffectiveDetectorRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSourceId":
            suggest = "data_source_id"
        elif key == "detectorRuleId":
            suggest = "detector_rule_id"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "entitiesMappings":
            suggest = "entities_mappings"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"
        elif key == "managedListTypes":
            suggest = "managed_list_types"
        elif key == "resourceType":
            suggest = "resource_type"
        elif key == "serviceType":
            suggest = "service_type"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeUpdated":
            suggest = "time_updated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetTargetDetectorRecipeEffectiveDetectorRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetTargetDetectorRecipeEffectiveDetectorRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetTargetDetectorRecipeEffectiveDetectorRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source_id: Optional[str] = None,
                 description: Optional[str] = None,
                 details: Optional[Sequence['outputs.TargetTargetDetectorRecipeEffectiveDetectorRuleDetail']] = None,
                 detector: Optional[str] = None,
                 detector_rule_id: Optional[str] = None,
                 display_name: Optional[str] = None,
                 entities_mappings: Optional[Sequence['outputs.TargetTargetDetectorRecipeEffectiveDetectorRuleEntitiesMapping']] = None,
                 lifecycle_details: Optional[str] = None,
                 managed_list_types: Optional[Sequence[str]] = None,
                 recommendation: Optional[str] = None,
                 resource_type: Optional[str] = None,
                 service_type: Optional[str] = None,
                 state: Optional[str] = None,
                 time_created: Optional[str] = None,
                 time_updated: Optional[str] = None):
        """
        :param str data_source_id: The id of the attached DataSource.
        :param str description: The target description.
               
               Avoid entering confidential information.
        :param Sequence['TargetTargetDetectorRecipeEffectiveDetectorRuleDetailArgs'] details: (Updatable) Details of ResponderRule.
        :param str detector: detector for the rule
        :param str detector_rule_id: (Updatable) Identifier for DetectorRule.
        :param str display_name: (Updatable) DetectorTemplate identifier.
               
               Avoid entering confidential information.
        :param Sequence['TargetTargetDetectorRecipeEffectiveDetectorRuleEntitiesMappingArgs'] entities_mappings: Data Source entities mapping for a Detector Rule
        :param str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param Sequence[str] managed_list_types: List of cloudguard managed list types related to this rule
        :param str recommendation: Recommendation for TargetDetectorRecipeDetectorRule
        :param str resource_type: resource type of the configuration to which the rule is applied
        :param str service_type: service type of the configuration to which the rule is applied
        :param str state: (Updatable) The current state of the DetectorRule.
        :param str time_created: The date and time the target was created. Format defined by RFC3339.
        :param str time_updated: The date and time the target was updated. Format defined by RFC3339.
        """
        TargetTargetDetectorRecipeEffectiveDetectorRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source_id=data_source_id,
            description=description,
            details=details,
            detector=detector,
            detector_rule_id=detector_rule_id,
            display_name=display_name,
            entities_mappings=entities_mappings,
            lifecycle_details=lifecycle_details,
            managed_list_types=managed_list_types,
            recommendation=recommendation,
            resource_type=resource_type,
            service_type=service_type,
            state=state,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source_id: Optional[str] = None,
             description: Optional[str] = None,
             details: Optional[Sequence['outputs.TargetTargetDetectorRecipeEffectiveDetectorRuleDetail']] = None,
             detector: Optional[str] = None,
             detector_rule_id: Optional[str] = None,
             display_name: Optional[str] = None,
             entities_mappings: Optional[Sequence['outputs.TargetTargetDetectorRecipeEffectiveDetectorRuleEntitiesMapping']] = None,
             lifecycle_details: Optional[str] = None,
             managed_list_types: Optional[Sequence[str]] = None,
             recommendation: Optional[str] = None,
             resource_type: Optional[str] = None,
             service_type: Optional[str] = None,
             state: Optional[str] = None,
             time_created: Optional[str] = None,
             time_updated: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'dataSourceId' in kwargs:
            data_source_id = kwargs['dataSourceId']
        if 'detectorRuleId' in kwargs:
            detector_rule_id = kwargs['detectorRuleId']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'entitiesMappings' in kwargs:
            entities_mappings = kwargs['entitiesMappings']
        if 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if 'managedListTypes' in kwargs:
            managed_list_types = kwargs['managedListTypes']
        if 'resourceType' in kwargs:
            resource_type = kwargs['resourceType']
        if 'serviceType' in kwargs:
            service_type = kwargs['serviceType']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        if data_source_id is not None:
            _setter("data_source_id", data_source_id)
        if description is not None:
            _setter("description", description)
        if details is not None:
            _setter("details", details)
        if detector is not None:
            _setter("detector", detector)
        if detector_rule_id is not None:
            _setter("detector_rule_id", detector_rule_id)
        if display_name is not None:
            _setter("display_name", display_name)
        if entities_mappings is not None:
            _setter("entities_mappings", entities_mappings)
        if lifecycle_details is not None:
            _setter("lifecycle_details", lifecycle_details)
        if managed_list_types is not None:
            _setter("managed_list_types", managed_list_types)
        if recommendation is not None:
            _setter("recommendation", recommendation)
        if resource_type is not None:
            _setter("resource_type", resource_type)
        if service_type is not None:
            _setter("service_type", service_type)
        if state is not None:
            _setter("state", state)
        if time_created is not None:
            _setter("time_created", time_created)
        if time_updated is not None:
            _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="dataSourceId")
    def data_source_id(self) -> Optional[str]:
        """
        The id of the attached DataSource.
        """
        return pulumi.get(self, "data_source_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The target description.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def details(self) -> Optional[Sequence['outputs.TargetTargetDetectorRecipeEffectiveDetectorRuleDetail']]:
        """
        (Updatable) Details of ResponderRule.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def detector(self) -> Optional[str]:
        """
        detector for the rule
        """
        return pulumi.get(self, "detector")

    @property
    @pulumi.getter(name="detectorRuleId")
    def detector_rule_id(self) -> Optional[str]:
        """
        (Updatable) Identifier for DetectorRule.
        """
        return pulumi.get(self, "detector_rule_id")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        (Updatable) DetectorTemplate identifier.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="entitiesMappings")
    def entities_mappings(self) -> Optional[Sequence['outputs.TargetTargetDetectorRecipeEffectiveDetectorRuleEntitiesMapping']]:
        """
        Data Source entities mapping for a Detector Rule
        """
        return pulumi.get(self, "entities_mappings")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[str]:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="managedListTypes")
    def managed_list_types(self) -> Optional[Sequence[str]]:
        """
        List of cloudguard managed list types related to this rule
        """
        return pulumi.get(self, "managed_list_types")

    @property
    @pulumi.getter
    def recommendation(self) -> Optional[str]:
        """
        Recommendation for TargetDetectorRecipeDetectorRule
        """
        return pulumi.get(self, "recommendation")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[str]:
        """
        resource type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> Optional[str]:
        """
        service type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "service_type")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        (Updatable) The current state of the DetectorRule.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[str]:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[str]:
        """
        The date and time the target was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class TargetTargetDetectorRecipeEffectiveDetectorRuleDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionGroups":
            suggest = "condition_groups"
        elif key == "isConfigurationAllowed":
            suggest = "is_configuration_allowed"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "riskLevel":
            suggest = "risk_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetTargetDetectorRecipeEffectiveDetectorRuleDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetTargetDetectorRecipeEffectiveDetectorRuleDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetTargetDetectorRecipeEffectiveDetectorRuleDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition_groups: Optional[Sequence['outputs.TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroup']] = None,
                 configurations: Optional[Sequence['outputs.TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfiguration']] = None,
                 is_configuration_allowed: Optional[bool] = None,
                 is_enabled: Optional[bool] = None,
                 labels: Optional[Sequence[str]] = None,
                 risk_level: Optional[str] = None):
        """
        :param Sequence['TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroupArgs'] condition_groups: (Updatable) Condition group corresponding to each compartment
        :param Sequence['TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationArgs'] configurations: (Updatable) Configurations associated with the ResponderRule
        :param bool is_configuration_allowed: configuration allowed or not
        :param bool is_enabled: Identifies state for ResponderRule
        :param Sequence[str] labels: user defined labels for a detector rule
        :param str risk_level: The Risk Level
        """
        TargetTargetDetectorRecipeEffectiveDetectorRuleDetail._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition_groups=condition_groups,
            configurations=configurations,
            is_configuration_allowed=is_configuration_allowed,
            is_enabled=is_enabled,
            labels=labels,
            risk_level=risk_level,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition_groups: Optional[Sequence['outputs.TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroup']] = None,
             configurations: Optional[Sequence['outputs.TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfiguration']] = None,
             is_configuration_allowed: Optional[bool] = None,
             is_enabled: Optional[bool] = None,
             labels: Optional[Sequence[str]] = None,
             risk_level: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'conditionGroups' in kwargs:
            condition_groups = kwargs['conditionGroups']
        if 'isConfigurationAllowed' in kwargs:
            is_configuration_allowed = kwargs['isConfigurationAllowed']
        if 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']
        if 'riskLevel' in kwargs:
            risk_level = kwargs['riskLevel']

        if condition_groups is not None:
            _setter("condition_groups", condition_groups)
        if configurations is not None:
            _setter("configurations", configurations)
        if is_configuration_allowed is not None:
            _setter("is_configuration_allowed", is_configuration_allowed)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if labels is not None:
            _setter("labels", labels)
        if risk_level is not None:
            _setter("risk_level", risk_level)

    @property
    @pulumi.getter(name="conditionGroups")
    def condition_groups(self) -> Optional[Sequence['outputs.TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroup']]:
        """
        (Updatable) Condition group corresponding to each compartment
        """
        return pulumi.get(self, "condition_groups")

    @property
    @pulumi.getter
    def configurations(self) -> Optional[Sequence['outputs.TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfiguration']]:
        """
        (Updatable) Configurations associated with the ResponderRule
        """
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter(name="isConfigurationAllowed")
    def is_configuration_allowed(self) -> Optional[bool]:
        """
        configuration allowed or not
        """
        return pulumi.get(self, "is_configuration_allowed")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Identifies state for ResponderRule
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Sequence[str]]:
        """
        user defined labels for a detector rule
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> Optional[str]:
        """
        The Risk Level
        """
        return pulumi.get(self, "risk_level")


@pulumi.output_type
class TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compartmentId":
            suggest = "compartment_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compartment_id: Optional[str] = None,
                 condition: Optional[str] = None):
        """
        :param str compartment_id: (Updatable) compartment associated with condition
        :param str condition: (Updatable) Base condition object
        """
        TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroup._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            condition=condition,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: Optional[str] = None,
             condition: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']

        if compartment_id is not None:
            _setter("compartment_id", compartment_id)
        if condition is not None:
            _setter("condition", condition)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[str]:
        """
        (Updatable) compartment associated with condition
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        """
        (Updatable) Base condition object
        """
        return pulumi.get(self, "condition")


@pulumi.output_type
class TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configKey":
            suggest = "config_key"
        elif key == "dataType":
            suggest = "data_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_key: Optional[str] = None,
                 data_type: Optional[str] = None,
                 name: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence['outputs.TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValue']] = None):
        """
        :param str config_key: (Updatable) Unique name of the configuration
        :param str data_type: configuration data type
        :param str name: (Updatable) configuration name
        :param str value: (Updatable) configuration value
        :param Sequence['TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueArgs'] values: List of configuration values
        """
        TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_key=config_key,
            data_type=data_type,
            name=name,
            value=value,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_key: Optional[str] = None,
             data_type: Optional[str] = None,
             name: Optional[str] = None,
             value: Optional[str] = None,
             values: Optional[Sequence['outputs.TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValue']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'configKey' in kwargs:
            config_key = kwargs['configKey']
        if 'dataType' in kwargs:
            data_type = kwargs['dataType']

        if config_key is not None:
            _setter("config_key", config_key)
        if data_type is not None:
            _setter("data_type", data_type)
        if name is not None:
            _setter("name", name)
        if value is not None:
            _setter("value", value)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> Optional[str]:
        """
        (Updatable) Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[str]:
        """
        configuration data type
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        (Updatable) configuration name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        (Updatable) configuration value
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValue']]:
        """
        List of configuration values
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "listType":
            suggest = "list_type"
        elif key == "managedListType":
            suggest = "managed_list_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 list_type: Optional[str] = None,
                 managed_list_type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str list_type: configuration list item type, either CUSTOM or MANAGED
        :param str managed_list_type: type of the managed list
        :param str value: (Updatable) configuration value
        """
        TargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValue._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            list_type=list_type,
            managed_list_type=managed_list_type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             list_type: Optional[str] = None,
             managed_list_type: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'listType' in kwargs:
            list_type = kwargs['listType']
        if 'managedListType' in kwargs:
            managed_list_type = kwargs['managedListType']

        if list_type is not None:
            _setter("list_type", list_type)
        if managed_list_type is not None:
            _setter("managed_list_type", managed_list_type)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="listType")
    def list_type(self) -> Optional[str]:
        """
        configuration list item type, either CUSTOM or MANAGED
        """
        return pulumi.get(self, "list_type")

    @property
    @pulumi.getter(name="managedListType")
    def managed_list_type(self) -> Optional[str]:
        """
        type of the managed list
        """
        return pulumi.get(self, "managed_list_type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        (Updatable) configuration value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TargetTargetDetectorRecipeEffectiveDetectorRuleEntitiesMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "entityType":
            suggest = "entity_type"
        elif key == "queryField":
            suggest = "query_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetTargetDetectorRecipeEffectiveDetectorRuleEntitiesMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetTargetDetectorRecipeEffectiveDetectorRuleEntitiesMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetTargetDetectorRecipeEffectiveDetectorRuleEntitiesMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: Optional[str] = None,
                 entity_type: Optional[str] = None,
                 query_field: Optional[str] = None):
        """
        :param str display_name: (Updatable) DetectorTemplate identifier.
               
               Avoid entering confidential information.
        :param str entity_type: Possible type of entity
        :param str query_field: The entity value mapped to a data source query
        """
        TargetTargetDetectorRecipeEffectiveDetectorRuleEntitiesMapping._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            entity_type=entity_type,
            query_field=query_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: Optional[str] = None,
             entity_type: Optional[str] = None,
             query_field: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'entityType' in kwargs:
            entity_type = kwargs['entityType']
        if 'queryField' in kwargs:
            query_field = kwargs['queryField']

        if display_name is not None:
            _setter("display_name", display_name)
        if entity_type is not None:
            _setter("entity_type", entity_type)
        if query_field is not None:
            _setter("query_field", query_field)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        (Updatable) DetectorTemplate identifier.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[str]:
        """
        Possible type of entity
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="queryField")
    def query_field(self) -> Optional[str]:
        """
        The entity value mapped to a data source query
        """
        return pulumi.get(self, "query_field")


@pulumi.output_type
class TargetTargetResponderRecipe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "responderRecipeId":
            suggest = "responder_recipe_id"
        elif key == "compartmentId":
            suggest = "compartment_id"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "effectiveResponderRules":
            suggest = "effective_responder_rules"
        elif key == "responderRules":
            suggest = "responder_rules"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeUpdated":
            suggest = "time_updated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetTargetResponderRecipe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetTargetResponderRecipe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetTargetResponderRecipe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 responder_recipe_id: str,
                 compartment_id: Optional[str] = None,
                 description: Optional[str] = None,
                 display_name: Optional[str] = None,
                 effective_responder_rules: Optional[Sequence['outputs.TargetTargetResponderRecipeEffectiveResponderRule']] = None,
                 id: Optional[str] = None,
                 owner: Optional[str] = None,
                 responder_rules: Optional[Sequence['outputs.TargetTargetResponderRecipeResponderRule']] = None,
                 time_created: Optional[str] = None,
                 time_updated: Optional[str] = None):
        """
        :param str responder_recipe_id: Identifier for ResponderRecipe.
        :param str compartment_id: (Updatable) compartment associated with condition
        :param str description: The target description.
               
               Avoid entering confidential information.
        :param str display_name: (Updatable) DetectorTemplate identifier.
               
               Avoid entering confidential information.
        :param Sequence['TargetTargetResponderRecipeEffectiveResponderRuleArgs'] effective_responder_rules: List of responder rules associated with the recipe after applying all defaults
        :param str id: Unique identifier of TargetResponderRecipe that can't be changed after creation.
        :param str owner: Owner of ResponderRecipe
        :param Sequence['TargetTargetResponderRecipeResponderRuleArgs'] responder_rules: (Updatable) Override responder rules associated with reponder recipe in a target.
        :param str time_created: The date and time the target was created. Format defined by RFC3339.
        :param str time_updated: The date and time the target was updated. Format defined by RFC3339.
        """
        TargetTargetResponderRecipe._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            responder_recipe_id=responder_recipe_id,
            compartment_id=compartment_id,
            description=description,
            display_name=display_name,
            effective_responder_rules=effective_responder_rules,
            id=id,
            owner=owner,
            responder_rules=responder_rules,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             responder_recipe_id: str,
             compartment_id: Optional[str] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             effective_responder_rules: Optional[Sequence['outputs.TargetTargetResponderRecipeEffectiveResponderRule']] = None,
             id: Optional[str] = None,
             owner: Optional[str] = None,
             responder_rules: Optional[Sequence['outputs.TargetTargetResponderRecipeResponderRule']] = None,
             time_created: Optional[str] = None,
             time_updated: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'responderRecipeId' in kwargs:
            responder_recipe_id = kwargs['responderRecipeId']
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'effectiveResponderRules' in kwargs:
            effective_responder_rules = kwargs['effectiveResponderRules']
        if 'responderRules' in kwargs:
            responder_rules = kwargs['responderRules']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("responder_recipe_id", responder_recipe_id)
        if compartment_id is not None:
            _setter("compartment_id", compartment_id)
        if description is not None:
            _setter("description", description)
        if display_name is not None:
            _setter("display_name", display_name)
        if effective_responder_rules is not None:
            _setter("effective_responder_rules", effective_responder_rules)
        if id is not None:
            _setter("id", id)
        if owner is not None:
            _setter("owner", owner)
        if responder_rules is not None:
            _setter("responder_rules", responder_rules)
        if time_created is not None:
            _setter("time_created", time_created)
        if time_updated is not None:
            _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="responderRecipeId")
    def responder_recipe_id(self) -> str:
        """
        Identifier for ResponderRecipe.
        """
        return pulumi.get(self, "responder_recipe_id")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[str]:
        """
        (Updatable) compartment associated with condition
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The target description.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        (Updatable) DetectorTemplate identifier.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="effectiveResponderRules")
    def effective_responder_rules(self) -> Optional[Sequence['outputs.TargetTargetResponderRecipeEffectiveResponderRule']]:
        """
        List of responder rules associated with the recipe after applying all defaults
        """
        return pulumi.get(self, "effective_responder_rules")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of TargetResponderRecipe that can't be changed after creation.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def owner(self) -> Optional[str]:
        """
        Owner of ResponderRecipe
        """
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter(name="responderRules")
    def responder_rules(self) -> Optional[Sequence['outputs.TargetTargetResponderRecipeResponderRule']]:
        """
        (Updatable) Override responder rules associated with reponder recipe in a target.
        """
        return pulumi.get(self, "responder_rules")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[str]:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[str]:
        """
        The date and time the target was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class TargetTargetResponderRecipeEffectiveResponderRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compartmentId":
            suggest = "compartment_id"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"
        elif key == "responderRuleId":
            suggest = "responder_rule_id"
        elif key == "supportedModes":
            suggest = "supported_modes"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeUpdated":
            suggest = "time_updated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetTargetResponderRecipeEffectiveResponderRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetTargetResponderRecipeEffectiveResponderRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetTargetResponderRecipeEffectiveResponderRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compartment_id: Optional[str] = None,
                 description: Optional[str] = None,
                 details: Optional[Sequence['outputs.TargetTargetResponderRecipeEffectiveResponderRuleDetail']] = None,
                 display_name: Optional[str] = None,
                 lifecycle_details: Optional[str] = None,
                 policies: Optional[Sequence[str]] = None,
                 responder_rule_id: Optional[str] = None,
                 state: Optional[str] = None,
                 supported_modes: Optional[Sequence[str]] = None,
                 time_created: Optional[str] = None,
                 time_updated: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str compartment_id: (Updatable) compartment associated with condition
        :param str description: The target description.
               
               Avoid entering confidential information.
        :param Sequence['TargetTargetResponderRecipeEffectiveResponderRuleDetailArgs'] details: (Updatable) Details of ResponderRule.
        :param str display_name: (Updatable) DetectorTemplate identifier.
               
               Avoid entering confidential information.
        :param str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param Sequence[str] policies: List of Policy
        :param str responder_rule_id: (Updatable) Identifier for ResponderRule.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param str state: (Updatable) The current state of the DetectorRule.
        :param Sequence[str] supported_modes: Supported Execution Modes
        :param str time_created: The date and time the target was created. Format defined by RFC3339.
        :param str time_updated: The date and time the target was updated. Format defined by RFC3339.
        :param str type: Type of Responder
        """
        TargetTargetResponderRecipeEffectiveResponderRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            description=description,
            details=details,
            display_name=display_name,
            lifecycle_details=lifecycle_details,
            policies=policies,
            responder_rule_id=responder_rule_id,
            state=state,
            supported_modes=supported_modes,
            time_created=time_created,
            time_updated=time_updated,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: Optional[str] = None,
             description: Optional[str] = None,
             details: Optional[Sequence['outputs.TargetTargetResponderRecipeEffectiveResponderRuleDetail']] = None,
             display_name: Optional[str] = None,
             lifecycle_details: Optional[str] = None,
             policies: Optional[Sequence[str]] = None,
             responder_rule_id: Optional[str] = None,
             state: Optional[str] = None,
             supported_modes: Optional[Sequence[str]] = None,
             time_created: Optional[str] = None,
             time_updated: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if 'responderRuleId' in kwargs:
            responder_rule_id = kwargs['responderRuleId']
        if 'supportedModes' in kwargs:
            supported_modes = kwargs['supportedModes']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        if compartment_id is not None:
            _setter("compartment_id", compartment_id)
        if description is not None:
            _setter("description", description)
        if details is not None:
            _setter("details", details)
        if display_name is not None:
            _setter("display_name", display_name)
        if lifecycle_details is not None:
            _setter("lifecycle_details", lifecycle_details)
        if policies is not None:
            _setter("policies", policies)
        if responder_rule_id is not None:
            _setter("responder_rule_id", responder_rule_id)
        if state is not None:
            _setter("state", state)
        if supported_modes is not None:
            _setter("supported_modes", supported_modes)
        if time_created is not None:
            _setter("time_created", time_created)
        if time_updated is not None:
            _setter("time_updated", time_updated)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[str]:
        """
        (Updatable) compartment associated with condition
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The target description.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def details(self) -> Optional[Sequence['outputs.TargetTargetResponderRecipeEffectiveResponderRuleDetail']]:
        """
        (Updatable) Details of ResponderRule.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        (Updatable) DetectorTemplate identifier.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[str]:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[str]]:
        """
        List of Policy
        """
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="responderRuleId")
    def responder_rule_id(self) -> Optional[str]:
        """
        (Updatable) Identifier for ResponderRule.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "responder_rule_id")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        (Updatable) The current state of the DetectorRule.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="supportedModes")
    def supported_modes(self) -> Optional[Sequence[str]]:
        """
        Supported Execution Modes
        """
        return pulumi.get(self, "supported_modes")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[str]:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[str]:
        """
        The date and time the target was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of Responder
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class TargetTargetResponderRecipeEffectiveResponderRuleDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetTargetResponderRecipeEffectiveResponderRuleDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetTargetResponderRecipeEffectiveResponderRuleDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetTargetResponderRecipeEffectiveResponderRuleDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: Optional[str] = None,
                 configurations: Optional[Sequence['outputs.TargetTargetResponderRecipeEffectiveResponderRuleDetailConfiguration']] = None,
                 is_enabled: Optional[bool] = None,
                 mode: Optional[str] = None):
        """
        :param str condition: (Updatable) Base condition object
        :param Sequence['TargetTargetResponderRecipeEffectiveResponderRuleDetailConfigurationArgs'] configurations: (Updatable) Configurations associated with the ResponderRule
        :param bool is_enabled: Identifies state for ResponderRule
        :param str mode: (Updatable) Execution Mode for ResponderRule
        """
        TargetTargetResponderRecipeEffectiveResponderRuleDetail._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition=condition,
            configurations=configurations,
            is_enabled=is_enabled,
            mode=mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition: Optional[str] = None,
             configurations: Optional[Sequence['outputs.TargetTargetResponderRecipeEffectiveResponderRuleDetailConfiguration']] = None,
             is_enabled: Optional[bool] = None,
             mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']

        if condition is not None:
            _setter("condition", condition)
        if configurations is not None:
            _setter("configurations", configurations)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if mode is not None:
            _setter("mode", mode)

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        """
        (Updatable) Base condition object
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def configurations(self) -> Optional[Sequence['outputs.TargetTargetResponderRecipeEffectiveResponderRuleDetailConfiguration']]:
        """
        (Updatable) Configurations associated with the ResponderRule
        """
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Identifies state for ResponderRule
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        (Updatable) Execution Mode for ResponderRule
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class TargetTargetResponderRecipeEffectiveResponderRuleDetailConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configKey":
            suggest = "config_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetTargetResponderRecipeEffectiveResponderRuleDetailConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetTargetResponderRecipeEffectiveResponderRuleDetailConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetTargetResponderRecipeEffectiveResponderRuleDetailConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_key: Optional[str] = None,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str config_key: (Updatable) Unique name of the configuration
        :param str name: (Updatable) configuration name
        :param str value: (Updatable) configuration value
        """
        TargetTargetResponderRecipeEffectiveResponderRuleDetailConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_key=config_key,
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_key: Optional[str] = None,
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'configKey' in kwargs:
            config_key = kwargs['configKey']

        if config_key is not None:
            _setter("config_key", config_key)
        if name is not None:
            _setter("name", name)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> Optional[str]:
        """
        (Updatable) Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        (Updatable) configuration name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        (Updatable) configuration value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TargetTargetResponderRecipeResponderRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "responderRuleId":
            suggest = "responder_rule_id"
        elif key == "compartmentId":
            suggest = "compartment_id"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"
        elif key == "supportedModes":
            suggest = "supported_modes"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeUpdated":
            suggest = "time_updated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetTargetResponderRecipeResponderRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetTargetResponderRecipeResponderRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetTargetResponderRecipeResponderRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 details: 'outputs.TargetTargetResponderRecipeResponderRuleDetails',
                 responder_rule_id: str,
                 compartment_id: Optional[str] = None,
                 description: Optional[str] = None,
                 display_name: Optional[str] = None,
                 lifecycle_details: Optional[str] = None,
                 policies: Optional[Sequence[str]] = None,
                 state: Optional[str] = None,
                 supported_modes: Optional[Sequence[str]] = None,
                 time_created: Optional[str] = None,
                 time_updated: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param 'TargetTargetResponderRecipeResponderRuleDetailsArgs' details: (Updatable) Details of ResponderRule.
        :param str responder_rule_id: (Updatable) Identifier for ResponderRule.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param str compartment_id: (Updatable) compartment associated with condition
        :param str description: The target description.
               
               Avoid entering confidential information.
        :param str display_name: (Updatable) DetectorTemplate identifier.
               
               Avoid entering confidential information.
        :param str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param Sequence[str] policies: List of Policy
        :param str state: (Updatable) The current state of the DetectorRule.
        :param Sequence[str] supported_modes: Supported Execution Modes
        :param str time_created: The date and time the target was created. Format defined by RFC3339.
        :param str time_updated: The date and time the target was updated. Format defined by RFC3339.
        :param str type: Type of Responder
        """
        TargetTargetResponderRecipeResponderRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            details=details,
            responder_rule_id=responder_rule_id,
            compartment_id=compartment_id,
            description=description,
            display_name=display_name,
            lifecycle_details=lifecycle_details,
            policies=policies,
            state=state,
            supported_modes=supported_modes,
            time_created=time_created,
            time_updated=time_updated,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             details: 'outputs.TargetTargetResponderRecipeResponderRuleDetails',
             responder_rule_id: str,
             compartment_id: Optional[str] = None,
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             lifecycle_details: Optional[str] = None,
             policies: Optional[Sequence[str]] = None,
             state: Optional[str] = None,
             supported_modes: Optional[Sequence[str]] = None,
             time_created: Optional[str] = None,
             time_updated: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'responderRuleId' in kwargs:
            responder_rule_id = kwargs['responderRuleId']
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if 'supportedModes' in kwargs:
            supported_modes = kwargs['supportedModes']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("details", details)
        _setter("responder_rule_id", responder_rule_id)
        if compartment_id is not None:
            _setter("compartment_id", compartment_id)
        if description is not None:
            _setter("description", description)
        if display_name is not None:
            _setter("display_name", display_name)
        if lifecycle_details is not None:
            _setter("lifecycle_details", lifecycle_details)
        if policies is not None:
            _setter("policies", policies)
        if state is not None:
            _setter("state", state)
        if supported_modes is not None:
            _setter("supported_modes", supported_modes)
        if time_created is not None:
            _setter("time_created", time_created)
        if time_updated is not None:
            _setter("time_updated", time_updated)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def details(self) -> 'outputs.TargetTargetResponderRecipeResponderRuleDetails':
        """
        (Updatable) Details of ResponderRule.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter(name="responderRuleId")
    def responder_rule_id(self) -> str:
        """
        (Updatable) Identifier for ResponderRule.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "responder_rule_id")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[str]:
        """
        (Updatable) compartment associated with condition
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The target description.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        (Updatable) DetectorTemplate identifier.

        Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[str]:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[str]]:
        """
        List of Policy
        """
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        (Updatable) The current state of the DetectorRule.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="supportedModes")
    def supported_modes(self) -> Optional[Sequence[str]]:
        """
        Supported Execution Modes
        """
        return pulumi.get(self, "supported_modes")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[str]:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[str]:
        """
        The date and time the target was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of Responder
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class TargetTargetResponderRecipeResponderRuleDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetTargetResponderRecipeResponderRuleDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetTargetResponderRecipeResponderRuleDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetTargetResponderRecipeResponderRuleDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: Optional[str] = None,
                 configurations: Optional[Sequence['outputs.TargetTargetResponderRecipeResponderRuleDetailsConfiguration']] = None,
                 is_enabled: Optional[bool] = None,
                 mode: Optional[str] = None):
        """
        :param str condition: (Updatable) Base condition object
        :param Sequence['TargetTargetResponderRecipeResponderRuleDetailsConfigurationArgs'] configurations: (Updatable) Configurations associated with the ResponderRule
        :param bool is_enabled: Identifies state for ResponderRule
        :param str mode: (Updatable) Execution Mode for ResponderRule
        """
        TargetTargetResponderRecipeResponderRuleDetails._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition=condition,
            configurations=configurations,
            is_enabled=is_enabled,
            mode=mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition: Optional[str] = None,
             configurations: Optional[Sequence['outputs.TargetTargetResponderRecipeResponderRuleDetailsConfiguration']] = None,
             is_enabled: Optional[bool] = None,
             mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']

        if condition is not None:
            _setter("condition", condition)
        if configurations is not None:
            _setter("configurations", configurations)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if mode is not None:
            _setter("mode", mode)

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        """
        (Updatable) Base condition object
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def configurations(self) -> Optional[Sequence['outputs.TargetTargetResponderRecipeResponderRuleDetailsConfiguration']]:
        """
        (Updatable) Configurations associated with the ResponderRule
        """
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Identifies state for ResponderRule
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        (Updatable) Execution Mode for ResponderRule
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class TargetTargetResponderRecipeResponderRuleDetailsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configKey":
            suggest = "config_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetTargetResponderRecipeResponderRuleDetailsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetTargetResponderRecipeResponderRuleDetailsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetTargetResponderRecipeResponderRuleDetailsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_key: str,
                 name: str,
                 value: str):
        """
        :param str config_key: (Updatable) Unique name of the configuration
        :param str name: (Updatable) configuration name
        :param str value: (Updatable) configuration value
        """
        TargetTargetResponderRecipeResponderRuleDetailsConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_key=config_key,
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_key: str,
             name: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'configKey' in kwargs:
            config_key = kwargs['configKey']

        _setter("config_key", config_key)
        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> str:
        """
        (Updatable) Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        (Updatable) configuration name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        (Updatable) configuration value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetDataMaskRuleTargetSelectedResult(dict):
    def __init__(__self__, *,
                 kind: str,
                 values: Sequence[str]):
        """
        :param str kind: Target selection.
        :param Sequence[str] values: Types of Targets
        """
        GetDataMaskRuleTargetSelectedResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            kind=kind,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             kind: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("kind", kind)
        _setter("values", values)

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        Target selection.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Types of Targets
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetDataMaskRulesDataMaskRuleCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetDataMaskRulesDataMaskRuleCollectionItemResult']):
        GetDataMaskRulesDataMaskRuleCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Sequence['outputs.GetDataMaskRulesDataMaskRuleCollectionItemResult'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetDataMaskRulesDataMaskRuleCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetDataMaskRulesDataMaskRuleCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 data_mask_categories: Sequence[str],
                 data_mask_rule_status: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 iam_group_id: str,
                 id: str,
                 lifecyle_details: str,
                 state: str,
                 system_tags: Mapping[str, Any],
                 target_selecteds: Sequence['outputs.GetDataMaskRulesDataMaskRuleCollectionItemTargetSelectedResult'],
                 time_created: str,
                 time_updated: str):
        """
        :param str compartment_id: The ID of the compartment in which to list resources.
        :param Sequence[str] data_mask_categories: Data Mask Categories
        :param str data_mask_rule_status: The status of the dataMaskRule.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param str description: The data mask rule description.
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param Mapping[str, Any] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param str iam_group_id: OCID of iamGroup
        :param str id: Unique identifier that is immutable on creation
        :param str lifecyle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param str state: The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        :param Mapping[str, Any] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). System tags can be viewed by users, but can only be created by the system.  Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param Sequence['GetDataMaskRulesDataMaskRuleCollectionItemTargetSelectedArgs'] target_selecteds: Target Selection eg select ALL or select on basis of TargetResourceTypes or TargetIds.
        :param str time_created: The date and time the target was created. Format defined by RFC3339.
        :param str time_updated: The date and time the target was updated. Format defined by RFC3339.
        """
        GetDataMaskRulesDataMaskRuleCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            data_mask_categories=data_mask_categories,
            data_mask_rule_status=data_mask_rule_status,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            freeform_tags=freeform_tags,
            iam_group_id=iam_group_id,
            id=id,
            lifecyle_details=lifecyle_details,
            state=state,
            system_tags=system_tags,
            target_selecteds=target_selecteds,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             data_mask_categories: Sequence[str],
             data_mask_rule_status: str,
             defined_tags: Mapping[str, Any],
             description: str,
             display_name: str,
             freeform_tags: Mapping[str, Any],
             iam_group_id: str,
             id: str,
             lifecyle_details: str,
             state: str,
             system_tags: Mapping[str, Any],
             target_selecteds: Sequence['outputs.GetDataMaskRulesDataMaskRuleCollectionItemTargetSelectedResult'],
             time_created: str,
             time_updated: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if 'dataMaskCategories' in kwargs:
            data_mask_categories = kwargs['dataMaskCategories']
        if 'dataMaskRuleStatus' in kwargs:
            data_mask_rule_status = kwargs['dataMaskRuleStatus']
        if 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if 'iamGroupId' in kwargs:
            iam_group_id = kwargs['iamGroupId']
        if 'lifecyleDetails' in kwargs:
            lifecyle_details = kwargs['lifecyleDetails']
        if 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if 'targetSelecteds' in kwargs:
            target_selecteds = kwargs['targetSelecteds']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("compartment_id", compartment_id)
        _setter("data_mask_categories", data_mask_categories)
        _setter("data_mask_rule_status", data_mask_rule_status)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("iam_group_id", iam_group_id)
        _setter("id", id)
        _setter("lifecyle_details", lifecyle_details)
        _setter("state", state)
        _setter("system_tags", system_tags)
        _setter("target_selecteds", target_selecteds)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="dataMaskCategories")
    def data_mask_categories(self) -> Sequence[str]:
        """
        Data Mask Categories
        """
        return pulumi.get(self, "data_mask_categories")

    @property
    @pulumi.getter(name="dataMaskRuleStatus")
    def data_mask_rule_status(self) -> str:
        """
        The status of the dataMaskRule.
        """
        return pulumi.get(self, "data_mask_rule_status")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The data mask rule description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter(name="iamGroupId")
    def iam_group_id(self) -> str:
        """
        OCID of iamGroup
        """
        return pulumi.get(self, "iam_group_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier that is immutable on creation
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecyleDetails")
    def lifecyle_details(self) -> str:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecyle_details")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). System tags can be viewed by users, but can only be created by the system.  Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="targetSelecteds")
    def target_selecteds(self) -> Sequence['outputs.GetDataMaskRulesDataMaskRuleCollectionItemTargetSelectedResult']:
        """
        Target Selection eg select ALL or select on basis of TargetResourceTypes or TargetIds.
        """
        return pulumi.get(self, "target_selecteds")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the target was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetDataMaskRulesDataMaskRuleCollectionItemTargetSelectedResult(dict):
    def __init__(__self__, *,
                 kind: str,
                 values: Sequence[str]):
        """
        :param str kind: Target selection.
        :param Sequence[str] values: Types of Targets
        """
        GetDataMaskRulesDataMaskRuleCollectionItemTargetSelectedResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            kind=kind,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             kind: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("kind", kind)
        _setter("values", values)

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        Target selection.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Types of Targets
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetDataMaskRulesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param Sequence[str] values: Types of Targets
        """
        GetDataMaskRulesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Types of Targets
        """
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDataSourceDataSourceDetailResult(dict):
    def __init__(__self__, *,
                 additional_entities_count: int,
                 data_source_feed_provider: str,
                 interval_in_minutes: int,
                 logging_query_details: Sequence['outputs.GetDataSourceDataSourceDetailLoggingQueryDetailResult'],
                 logging_query_type: str,
                 operator: str,
                 query: str,
                 query_start_times: Sequence['outputs.GetDataSourceDataSourceDetailQueryStartTimeResult'],
                 regions: Sequence[str],
                 threshold: int):
        """
        :param int additional_entities_count: The additional entities count used for data source query.
        :param str data_source_feed_provider: Possible type of dataSourceFeed Provider(LoggingQuery)
        :param int interval_in_minutes: Interval in minutes that query is run periodically.
        :param Sequence['GetDataSourceDataSourceDetailLoggingQueryDetailArgs'] logging_query_details: Additional details specific to the data source type (Sighting/Insight).
        :param str logging_query_type: Logging query type for data source (Sighting/Insight)
        :param str operator: Operator used in Data Soruce
        :param str query: The continuous query expression that is run periodically.
        :param Sequence['GetDataSourceDataSourceDetailQueryStartTimeArgs'] query_start_times: Time when the query can start, if not specified it can start immediately.
        :param Sequence[str] regions: Logging Query regions
        :param int threshold: The integer value that must be exceeded, fall below or equal to (depending on the operator), the query result to trigger an event.
        """
        GetDataSourceDataSourceDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            additional_entities_count=additional_entities_count,
            data_source_feed_provider=data_source_feed_provider,
            interval_in_minutes=interval_in_minutes,
            logging_query_details=logging_query_details,
            logging_query_type=logging_query_type,
            operator=operator,
            query=query,
            query_start_times=query_start_times,
            regions=regions,
            threshold=threshold,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             additional_entities_count: int,
             data_source_feed_provider: str,
             interval_in_minutes: int,
             logging_query_details: Sequence['outputs.GetDataSourceDataSourceDetailLoggingQueryDetailResult'],
             logging_query_type: str,
             operator: str,
             query: str,
             query_start_times: Sequence['outputs.GetDataSourceDataSourceDetailQueryStartTimeResult'],
             regions: Sequence[str],
             threshold: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'additionalEntitiesCount' in kwargs:
            additional_entities_count = kwargs['additionalEntitiesCount']
        if 'dataSourceFeedProvider' in kwargs:
            data_source_feed_provider = kwargs['dataSourceFeedProvider']
        if 'intervalInMinutes' in kwargs:
            interval_in_minutes = kwargs['intervalInMinutes']
        if 'loggingQueryDetails' in kwargs:
            logging_query_details = kwargs['loggingQueryDetails']
        if 'loggingQueryType' in kwargs:
            logging_query_type = kwargs['loggingQueryType']
        if 'queryStartTimes' in kwargs:
            query_start_times = kwargs['queryStartTimes']

        _setter("additional_entities_count", additional_entities_count)
        _setter("data_source_feed_provider", data_source_feed_provider)
        _setter("interval_in_minutes", interval_in_minutes)
        _setter("logging_query_details", logging_query_details)
        _setter("logging_query_type", logging_query_type)
        _setter("operator", operator)
        _setter("query", query)
        _setter("query_start_times", query_start_times)
        _setter("regions", regions)
        _setter("threshold", threshold)

    @property
    @pulumi.getter(name="additionalEntitiesCount")
    def additional_entities_count(self) -> int:
        """
        The additional entities count used for data source query.
        """
        return pulumi.get(self, "additional_entities_count")

    @property
    @pulumi.getter(name="dataSourceFeedProvider")
    def data_source_feed_provider(self) -> str:
        """
        Possible type of dataSourceFeed Provider(LoggingQuery)
        """
        return pulumi.get(self, "data_source_feed_provider")

    @property
    @pulumi.getter(name="intervalInMinutes")
    def interval_in_minutes(self) -> int:
        """
        Interval in minutes that query is run periodically.
        """
        return pulumi.get(self, "interval_in_minutes")

    @property
    @pulumi.getter(name="loggingQueryDetails")
    def logging_query_details(self) -> Sequence['outputs.GetDataSourceDataSourceDetailLoggingQueryDetailResult']:
        """
        Additional details specific to the data source type (Sighting/Insight).
        """
        return pulumi.get(self, "logging_query_details")

    @property
    @pulumi.getter(name="loggingQueryType")
    def logging_query_type(self) -> str:
        """
        Logging query type for data source (Sighting/Insight)
        """
        return pulumi.get(self, "logging_query_type")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator used in Data Soruce
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The continuous query expression that is run periodically.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="queryStartTimes")
    def query_start_times(self) -> Sequence['outputs.GetDataSourceDataSourceDetailQueryStartTimeResult']:
        """
        Time when the query can start, if not specified it can start immediately.
        """
        return pulumi.get(self, "query_start_times")

    @property
    @pulumi.getter
    def regions(self) -> Sequence[str]:
        """
        Logging Query regions
        """
        return pulumi.get(self, "regions")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        """
        The integer value that must be exceeded, fall below or equal to (depending on the operator), the query result to trigger an event.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class GetDataSourceDataSourceDetailLoggingQueryDetailResult(dict):
    def __init__(__self__, *,
                 key_entities_count: int,
                 logging_query_type: str):
        """
        :param int key_entities_count: The key entities count used for data source query
        :param str logging_query_type: Logging query type for data source (Sighting/Insight)
        """
        GetDataSourceDataSourceDetailLoggingQueryDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key_entities_count=key_entities_count,
            logging_query_type=logging_query_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key_entities_count: int,
             logging_query_type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'keyEntitiesCount' in kwargs:
            key_entities_count = kwargs['keyEntitiesCount']
        if 'loggingQueryType' in kwargs:
            logging_query_type = kwargs['loggingQueryType']

        _setter("key_entities_count", key_entities_count)
        _setter("logging_query_type", logging_query_type)

    @property
    @pulumi.getter(name="keyEntitiesCount")
    def key_entities_count(self) -> int:
        """
        The key entities count used for data source query
        """
        return pulumi.get(self, "key_entities_count")

    @property
    @pulumi.getter(name="loggingQueryType")
    def logging_query_type(self) -> str:
        """
        Logging query type for data source (Sighting/Insight)
        """
        return pulumi.get(self, "logging_query_type")


@pulumi.output_type
class GetDataSourceDataSourceDetailQueryStartTimeResult(dict):
    def __init__(__self__, *,
                 query_start_time: str,
                 start_policy_type: str):
        """
        :param str query_start_time: Time when the query can start, if not specified it can start immediately.
        :param str start_policy_type: policy used for deciding the query start time
        """
        GetDataSourceDataSourceDetailQueryStartTimeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query_start_time=query_start_time,
            start_policy_type=start_policy_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query_start_time: str,
             start_policy_type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'queryStartTime' in kwargs:
            query_start_time = kwargs['queryStartTime']
        if 'startPolicyType' in kwargs:
            start_policy_type = kwargs['startPolicyType']

        _setter("query_start_time", query_start_time)
        _setter("start_policy_type", start_policy_type)

    @property
    @pulumi.getter(name="queryStartTime")
    def query_start_time(self) -> str:
        """
        Time when the query can start, if not specified it can start immediately.
        """
        return pulumi.get(self, "query_start_time")

    @property
    @pulumi.getter(name="startPolicyType")
    def start_policy_type(self) -> str:
        """
        policy used for deciding the query start time
        """
        return pulumi.get(self, "start_policy_type")


@pulumi.output_type
class GetDataSourceDataSourceDetectorMappingInfoResult(dict):
    def __init__(__self__, *,
                 detector_recipe_id: str,
                 detector_rule_id: str):
        """
        :param str detector_recipe_id: Id of the attached detectorRecipeId to the Data Source.
        :param str detector_rule_id: Id of the attached detectorRuleId to the Data Source.
        """
        GetDataSourceDataSourceDetectorMappingInfoResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            detector_recipe_id=detector_recipe_id,
            detector_rule_id=detector_rule_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             detector_recipe_id: str,
             detector_rule_id: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'detectorRecipeId' in kwargs:
            detector_recipe_id = kwargs['detectorRecipeId']
        if 'detectorRuleId' in kwargs:
            detector_rule_id = kwargs['detectorRuleId']

        _setter("detector_recipe_id", detector_recipe_id)
        _setter("detector_rule_id", detector_rule_id)

    @property
    @pulumi.getter(name="detectorRecipeId")
    def detector_recipe_id(self) -> str:
        """
        Id of the attached detectorRecipeId to the Data Source.
        """
        return pulumi.get(self, "detector_recipe_id")

    @property
    @pulumi.getter(name="detectorRuleId")
    def detector_rule_id(self) -> str:
        """
        Id of the attached detectorRuleId to the Data Source.
        """
        return pulumi.get(self, "detector_rule_id")


@pulumi.output_type
class GetDataSourceEventItemResult(dict):
    def __init__(__self__, *,
                 comments: str,
                 data_source_id: str,
                 event_date: str,
                 event_infos: Sequence['outputs.GetDataSourceEventItemEventInfoResult'],
                 region: str,
                 status: str,
                 time_created: str):
        """
        :param str comments: Data source event comments
        :param str data_source_id: DataSource OCID
        :param str event_date: Data source event date time
        :param Sequence['GetDataSourceEventItemEventInfoArgs'] event_infos: Event info of a data source.
        :param str region: A filter to return only resource their region matches the given region.
        :param str status: Current data source event info status
        :param str time_created: Data source event created time
        """
        GetDataSourceEventItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comments=comments,
            data_source_id=data_source_id,
            event_date=event_date,
            event_infos=event_infos,
            region=region,
            status=status,
            time_created=time_created,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comments: str,
             data_source_id: str,
             event_date: str,
             event_infos: Sequence['outputs.GetDataSourceEventItemEventInfoResult'],
             region: str,
             status: str,
             time_created: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'dataSourceId' in kwargs:
            data_source_id = kwargs['dataSourceId']
        if 'eventDate' in kwargs:
            event_date = kwargs['eventDate']
        if 'eventInfos' in kwargs:
            event_infos = kwargs['eventInfos']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']

        _setter("comments", comments)
        _setter("data_source_id", data_source_id)
        _setter("event_date", event_date)
        _setter("event_infos", event_infos)
        _setter("region", region)
        _setter("status", status)
        _setter("time_created", time_created)

    @property
    @pulumi.getter
    def comments(self) -> str:
        """
        Data source event comments
        """
        return pulumi.get(self, "comments")

    @property
    @pulumi.getter(name="dataSourceId")
    def data_source_id(self) -> str:
        """
        DataSource OCID
        """
        return pulumi.get(self, "data_source_id")

    @property
    @pulumi.getter(name="eventDate")
    def event_date(self) -> str:
        """
        Data source event date time
        """
        return pulumi.get(self, "event_date")

    @property
    @pulumi.getter(name="eventInfos")
    def event_infos(self) -> Sequence['outputs.GetDataSourceEventItemEventInfoResult']:
        """
        Event info of a data source.
        """
        return pulumi.get(self, "event_infos")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        A filter to return only resource their region matches the given region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Current data source event info status
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        Data source event created time
        """
        return pulumi.get(self, "time_created")


@pulumi.output_type
class GetDataSourceEventItemEventInfoResult(dict):
    def __init__(__self__, *,
                 data_source_feed_provider: str,
                 log_result: str,
                 observed_value: str,
                 operator: str,
                 trigger_value: str):
        """
        :param str data_source_feed_provider: Possible type of dataSourceFeed Provider(LoggingQuery)
        """
        GetDataSourceEventItemEventInfoResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source_feed_provider=data_source_feed_provider,
            log_result=log_result,
            observed_value=observed_value,
            operator=operator,
            trigger_value=trigger_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source_feed_provider: str,
             log_result: str,
             observed_value: str,
             operator: str,
             trigger_value: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'dataSourceFeedProvider' in kwargs:
            data_source_feed_provider = kwargs['dataSourceFeedProvider']
        if 'logResult' in kwargs:
            log_result = kwargs['logResult']
        if 'observedValue' in kwargs:
            observed_value = kwargs['observedValue']
        if 'triggerValue' in kwargs:
            trigger_value = kwargs['triggerValue']

        _setter("data_source_feed_provider", data_source_feed_provider)
        _setter("log_result", log_result)
        _setter("observed_value", observed_value)
        _setter("operator", operator)
        _setter("trigger_value", trigger_value)

    @property
    @pulumi.getter(name="dataSourceFeedProvider")
    def data_source_feed_provider(self) -> str:
        """
        Possible type of dataSourceFeed Provider(LoggingQuery)
        """
        return pulumi.get(self, "data_source_feed_provider")

    @property
    @pulumi.getter(name="logResult")
    def log_result(self) -> str:
        return pulumi.get(self, "log_result")

    @property
    @pulumi.getter(name="observedValue")
    def observed_value(self) -> str:
        return pulumi.get(self, "observed_value")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="triggerValue")
    def trigger_value(self) -> str:
        return pulumi.get(self, "trigger_value")


@pulumi.output_type
class GetDataSourceEventsDataSourceEventCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetDataSourceEventsDataSourceEventCollectionItemResult']):
        """
        :param Sequence['GetDataSourceEventsDataSourceEventCollectionItemArgs'] items: List of event related to a DataSource
        """
        GetDataSourceEventsDataSourceEventCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Sequence['outputs.GetDataSourceEventsDataSourceEventCollectionItemResult'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetDataSourceEventsDataSourceEventCollectionItemResult']:
        """
        List of event related to a DataSource
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetDataSourceEventsDataSourceEventCollectionItemResult(dict):
    def __init__(__self__, *,
                 comments: str,
                 data_source_id: str,
                 event_date: str,
                 event_infos: Sequence['outputs.GetDataSourceEventsDataSourceEventCollectionItemEventInfoResult'],
                 region: str,
                 status: str,
                 time_created: str):
        """
        :param str comments: Data source event comments
        :param str data_source_id: DataSource OCID
        :param str event_date: Data source event date time
        :param Sequence['GetDataSourceEventsDataSourceEventCollectionItemEventInfoArgs'] event_infos: Event info of a data source.
        :param str region: A filter to return only resource their region matches the given region.
        :param str status: Current data source event info status
        :param str time_created: Data source event created time
        """
        GetDataSourceEventsDataSourceEventCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comments=comments,
            data_source_id=data_source_id,
            event_date=event_date,
            event_infos=event_infos,
            region=region,
            status=status,
            time_created=time_created,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comments: str,
             data_source_id: str,
             event_date: str,
             event_infos: Sequence['outputs.GetDataSourceEventsDataSourceEventCollectionItemEventInfoResult'],
             region: str,
             status: str,
             time_created: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'dataSourceId' in kwargs:
            data_source_id = kwargs['dataSourceId']
        if 'eventDate' in kwargs:
            event_date = kwargs['eventDate']
        if 'eventInfos' in kwargs:
            event_infos = kwargs['eventInfos']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']

        _setter("comments", comments)
        _setter("data_source_id", data_source_id)
        _setter("event_date", event_date)
        _setter("event_infos", event_infos)
        _setter("region", region)
        _setter("status", status)
        _setter("time_created", time_created)

    @property
    @pulumi.getter
    def comments(self) -> str:
        """
        Data source event comments
        """
        return pulumi.get(self, "comments")

    @property
    @pulumi.getter(name="dataSourceId")
    def data_source_id(self) -> str:
        """
        DataSource OCID
        """
        return pulumi.get(self, "data_source_id")

    @property
    @pulumi.getter(name="eventDate")
    def event_date(self) -> str:
        """
        Data source event date time
        """
        return pulumi.get(self, "event_date")

    @property
    @pulumi.getter(name="eventInfos")
    def event_infos(self) -> Sequence['outputs.GetDataSourceEventsDataSourceEventCollectionItemEventInfoResult']:
        """
        Event info of a data source.
        """
        return pulumi.get(self, "event_infos")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        A filter to return only resource their region matches the given region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Current data source event info status
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        Data source event created time
        """
        return pulumi.get(self, "time_created")


@pulumi.output_type
class GetDataSourceEventsDataSourceEventCollectionItemEventInfoResult(dict):
    def __init__(__self__, *,
                 data_source_feed_provider: str,
                 log_result: str,
                 observed_value: str,
                 operator: str,
                 trigger_value: str):
        """
        :param str data_source_feed_provider: Possible type of dataSourceFeed Provider(LoggingQuery)
        """
        GetDataSourceEventsDataSourceEventCollectionItemEventInfoResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source_feed_provider=data_source_feed_provider,
            log_result=log_result,
            observed_value=observed_value,
            operator=operator,
            trigger_value=trigger_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source_feed_provider: str,
             log_result: str,
             observed_value: str,
             operator: str,
             trigger_value: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'dataSourceFeedProvider' in kwargs:
            data_source_feed_provider = kwargs['dataSourceFeedProvider']
        if 'logResult' in kwargs:
            log_result = kwargs['logResult']
        if 'observedValue' in kwargs:
            observed_value = kwargs['observedValue']
        if 'triggerValue' in kwargs:
            trigger_value = kwargs['triggerValue']

        _setter("data_source_feed_provider", data_source_feed_provider)
        _setter("log_result", log_result)
        _setter("observed_value", observed_value)
        _setter("operator", operator)
        _setter("trigger_value", trigger_value)

    @property
    @pulumi.getter(name="dataSourceFeedProvider")
    def data_source_feed_provider(self) -> str:
        """
        Possible type of dataSourceFeed Provider(LoggingQuery)
        """
        return pulumi.get(self, "data_source_feed_provider")

    @property
    @pulumi.getter(name="logResult")
    def log_result(self) -> str:
        return pulumi.get(self, "log_result")

    @property
    @pulumi.getter(name="observedValue")
    def observed_value(self) -> str:
        return pulumi.get(self, "observed_value")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="triggerValue")
    def trigger_value(self) -> str:
        return pulumi.get(self, "trigger_value")


@pulumi.output_type
class GetDataSourceEventsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDataSourceEventsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDataSourceRegionStatusDetailResult(dict):
    def __init__(__self__, *,
                 region: str,
                 status: str):
        """
        :param str region: Data Source replication region.
        :param str status: Status of data Source
        """
        GetDataSourceRegionStatusDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            region=region,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             region: str,
             status: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("region", region)
        _setter("status", status)

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Data Source replication region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of data Source
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetDataSourcesDataSourceCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetDataSourcesDataSourceCollectionItemResult']):
        GetDataSourcesDataSourceCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Sequence['outputs.GetDataSourcesDataSourceCollectionItemResult'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetDataSourcesDataSourceCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetDataSourcesDataSourceCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 data_source_details: Sequence['outputs.GetDataSourcesDataSourceCollectionItemDataSourceDetailResult'],
                 data_source_detector_mapping_infos: Sequence['outputs.GetDataSourcesDataSourceCollectionItemDataSourceDetectorMappingInfoResult'],
                 data_source_feed_provider: str,
                 defined_tags: Mapping[str, Any],
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 region_status_details: Sequence['outputs.GetDataSourcesDataSourceCollectionItemRegionStatusDetailResult'],
                 state: str,
                 status: str,
                 system_tags: Mapping[str, Any],
                 time_created: str,
                 time_updated: str):
        """
        :param str compartment_id: The ID of the compartment in which to list resources.
        :param Sequence['GetDataSourcesDataSourceCollectionItemDataSourceDetailArgs'] data_source_details: Details specific to the data source type.
        :param Sequence['GetDataSourcesDataSourceCollectionItemDataSourceDetectorMappingInfoArgs'] data_source_detector_mapping_infos: Information about the detector recipe and rule attached
        :param str data_source_feed_provider: A filter to return only resources their feedProvider matches the given DataSourceFeedProvider.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param Mapping[str, Any] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param str id: Ocid for Data source
        :param Sequence['GetDataSourcesDataSourceCollectionItemRegionStatusDetailArgs'] region_status_details: Information about the region and status of query replication
        :param str state: The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        :param str status: Status of data Source
        :param Mapping[str, Any] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). System tags can be viewed by users, but can only be created by the system.  Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param str time_created: The date and time the Data source was created. Format defined by RFC3339.
        :param str time_updated: The date and time the Data source was updated. Format defined by RFC3339.
        """
        GetDataSourcesDataSourceCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            data_source_details=data_source_details,
            data_source_detector_mapping_infos=data_source_detector_mapping_infos,
            data_source_feed_provider=data_source_feed_provider,
            defined_tags=defined_tags,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            region_status_details=region_status_details,
            state=state,
            status=status,
            system_tags=system_tags,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             data_source_details: Sequence['outputs.GetDataSourcesDataSourceCollectionItemDataSourceDetailResult'],
             data_source_detector_mapping_infos: Sequence['outputs.GetDataSourcesDataSourceCollectionItemDataSourceDetectorMappingInfoResult'],
             data_source_feed_provider: str,
             defined_tags: Mapping[str, Any],
             display_name: str,
             freeform_tags: Mapping[str, Any],
             id: str,
             region_status_details: Sequence['outputs.GetDataSourcesDataSourceCollectionItemRegionStatusDetailResult'],
             state: str,
             status: str,
             system_tags: Mapping[str, Any],
             time_created: str,
             time_updated: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if 'dataSourceDetails' in kwargs:
            data_source_details = kwargs['dataSourceDetails']
        if 'dataSourceDetectorMappingInfos' in kwargs:
            data_source_detector_mapping_infos = kwargs['dataSourceDetectorMappingInfos']
        if 'dataSourceFeedProvider' in kwargs:
            data_source_feed_provider = kwargs['dataSourceFeedProvider']
        if 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if 'regionStatusDetails' in kwargs:
            region_status_details = kwargs['regionStatusDetails']
        if 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("compartment_id", compartment_id)
        _setter("data_source_details", data_source_details)
        _setter("data_source_detector_mapping_infos", data_source_detector_mapping_infos)
        _setter("data_source_feed_provider", data_source_feed_provider)
        _setter("defined_tags", defined_tags)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("region_status_details", region_status_details)
        _setter("state", state)
        _setter("status", status)
        _setter("system_tags", system_tags)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="dataSourceDetails")
    def data_source_details(self) -> Sequence['outputs.GetDataSourcesDataSourceCollectionItemDataSourceDetailResult']:
        """
        Details specific to the data source type.
        """
        return pulumi.get(self, "data_source_details")

    @property
    @pulumi.getter(name="dataSourceDetectorMappingInfos")
    def data_source_detector_mapping_infos(self) -> Sequence['outputs.GetDataSourcesDataSourceCollectionItemDataSourceDetectorMappingInfoResult']:
        """
        Information about the detector recipe and rule attached
        """
        return pulumi.get(self, "data_source_detector_mapping_infos")

    @property
    @pulumi.getter(name="dataSourceFeedProvider")
    def data_source_feed_provider(self) -> str:
        """
        A filter to return only resources their feedProvider matches the given DataSourceFeedProvider.
        """
        return pulumi.get(self, "data_source_feed_provider")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Ocid for Data source
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="regionStatusDetails")
    def region_status_details(self) -> Sequence['outputs.GetDataSourcesDataSourceCollectionItemRegionStatusDetailResult']:
        """
        Information about the region and status of query replication
        """
        return pulumi.get(self, "region_status_details")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of data Source
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). System tags can be viewed by users, but can only be created by the system.  Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the Data source was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the Data source was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetDataSourcesDataSourceCollectionItemDataSourceDetailResult(dict):
    def __init__(__self__, *,
                 additional_entities_count: int,
                 data_source_feed_provider: str,
                 interval_in_minutes: int,
                 logging_query_details: Sequence['outputs.GetDataSourcesDataSourceCollectionItemDataSourceDetailLoggingQueryDetailResult'],
                 logging_query_type: str,
                 operator: str,
                 query: str,
                 query_start_times: Sequence['outputs.GetDataSourcesDataSourceCollectionItemDataSourceDetailQueryStartTimeResult'],
                 regions: Sequence[str],
                 threshold: int):
        """
        :param int additional_entities_count: The additional entities count used for data source query.
        :param str data_source_feed_provider: A filter to return only resources their feedProvider matches the given DataSourceFeedProvider.
        :param int interval_in_minutes: Interval in minutes that query is run periodically.
        :param Sequence['GetDataSourcesDataSourceCollectionItemDataSourceDetailLoggingQueryDetailArgs'] logging_query_details: Additional details specific to the data source type (Sighting/Insight).
        :param str logging_query_type: A filter to return only resources their query type matches the given LoggingQueryType.
        :param str operator: Operator used in Data Soruce
        :param str query: The continuous query expression that is run periodically.
        :param Sequence['GetDataSourcesDataSourceCollectionItemDataSourceDetailQueryStartTimeArgs'] query_start_times: Time when the query can start, if not specified it can start immediately.
        :param Sequence[str] regions: Logging Query regions
        :param int threshold: The integer value that must be exceeded, fall below or equal to (depending on the operator), the query result to trigger an event.
        """
        GetDataSourcesDataSourceCollectionItemDataSourceDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            additional_entities_count=additional_entities_count,
            data_source_feed_provider=data_source_feed_provider,
            interval_in_minutes=interval_in_minutes,
            logging_query_details=logging_query_details,
            logging_query_type=logging_query_type,
            operator=operator,
            query=query,
            query_start_times=query_start_times,
            regions=regions,
            threshold=threshold,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             additional_entities_count: int,
             data_source_feed_provider: str,
             interval_in_minutes: int,
             logging_query_details: Sequence['outputs.GetDataSourcesDataSourceCollectionItemDataSourceDetailLoggingQueryDetailResult'],
             logging_query_type: str,
             operator: str,
             query: str,
             query_start_times: Sequence['outputs.GetDataSourcesDataSourceCollectionItemDataSourceDetailQueryStartTimeResult'],
             regions: Sequence[str],
             threshold: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'additionalEntitiesCount' in kwargs:
            additional_entities_count = kwargs['additionalEntitiesCount']
        if 'dataSourceFeedProvider' in kwargs:
            data_source_feed_provider = kwargs['dataSourceFeedProvider']
        if 'intervalInMinutes' in kwargs:
            interval_in_minutes = kwargs['intervalInMinutes']
        if 'loggingQueryDetails' in kwargs:
            logging_query_details = kwargs['loggingQueryDetails']
        if 'loggingQueryType' in kwargs:
            logging_query_type = kwargs['loggingQueryType']
        if 'queryStartTimes' in kwargs:
            query_start_times = kwargs['queryStartTimes']

        _setter("additional_entities_count", additional_entities_count)
        _setter("data_source_feed_provider", data_source_feed_provider)
        _setter("interval_in_minutes", interval_in_minutes)
        _setter("logging_query_details", logging_query_details)
        _setter("logging_query_type", logging_query_type)
        _setter("operator", operator)
        _setter("query", query)
        _setter("query_start_times", query_start_times)
        _setter("regions", regions)
        _setter("threshold", threshold)

    @property
    @pulumi.getter(name="additionalEntitiesCount")
    def additional_entities_count(self) -> int:
        """
        The additional entities count used for data source query.
        """
        return pulumi.get(self, "additional_entities_count")

    @property
    @pulumi.getter(name="dataSourceFeedProvider")
    def data_source_feed_provider(self) -> str:
        """
        A filter to return only resources their feedProvider matches the given DataSourceFeedProvider.
        """
        return pulumi.get(self, "data_source_feed_provider")

    @property
    @pulumi.getter(name="intervalInMinutes")
    def interval_in_minutes(self) -> int:
        """
        Interval in minutes that query is run periodically.
        """
        return pulumi.get(self, "interval_in_minutes")

    @property
    @pulumi.getter(name="loggingQueryDetails")
    def logging_query_details(self) -> Sequence['outputs.GetDataSourcesDataSourceCollectionItemDataSourceDetailLoggingQueryDetailResult']:
        """
        Additional details specific to the data source type (Sighting/Insight).
        """
        return pulumi.get(self, "logging_query_details")

    @property
    @pulumi.getter(name="loggingQueryType")
    def logging_query_type(self) -> str:
        """
        A filter to return only resources their query type matches the given LoggingQueryType.
        """
        return pulumi.get(self, "logging_query_type")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator used in Data Soruce
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The continuous query expression that is run periodically.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="queryStartTimes")
    def query_start_times(self) -> Sequence['outputs.GetDataSourcesDataSourceCollectionItemDataSourceDetailQueryStartTimeResult']:
        """
        Time when the query can start, if not specified it can start immediately.
        """
        return pulumi.get(self, "query_start_times")

    @property
    @pulumi.getter
    def regions(self) -> Sequence[str]:
        """
        Logging Query regions
        """
        return pulumi.get(self, "regions")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        """
        The integer value that must be exceeded, fall below or equal to (depending on the operator), the query result to trigger an event.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class GetDataSourcesDataSourceCollectionItemDataSourceDetailLoggingQueryDetailResult(dict):
    def __init__(__self__, *,
                 key_entities_count: int,
                 logging_query_type: str):
        """
        :param int key_entities_count: The key entities count used for data source query
        :param str logging_query_type: A filter to return only resources their query type matches the given LoggingQueryType.
        """
        GetDataSourcesDataSourceCollectionItemDataSourceDetailLoggingQueryDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key_entities_count=key_entities_count,
            logging_query_type=logging_query_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key_entities_count: int,
             logging_query_type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'keyEntitiesCount' in kwargs:
            key_entities_count = kwargs['keyEntitiesCount']
        if 'loggingQueryType' in kwargs:
            logging_query_type = kwargs['loggingQueryType']

        _setter("key_entities_count", key_entities_count)
        _setter("logging_query_type", logging_query_type)

    @property
    @pulumi.getter(name="keyEntitiesCount")
    def key_entities_count(self) -> int:
        """
        The key entities count used for data source query
        """
        return pulumi.get(self, "key_entities_count")

    @property
    @pulumi.getter(name="loggingQueryType")
    def logging_query_type(self) -> str:
        """
        A filter to return only resources their query type matches the given LoggingQueryType.
        """
        return pulumi.get(self, "logging_query_type")


@pulumi.output_type
class GetDataSourcesDataSourceCollectionItemDataSourceDetailQueryStartTimeResult(dict):
    def __init__(__self__, *,
                 query_start_time: str,
                 start_policy_type: str):
        """
        :param str query_start_time: Time when the query can start, if not specified it can start immediately.
        :param str start_policy_type: policy used for deciding the query start time
        """
        GetDataSourcesDataSourceCollectionItemDataSourceDetailQueryStartTimeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query_start_time=query_start_time,
            start_policy_type=start_policy_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query_start_time: str,
             start_policy_type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'queryStartTime' in kwargs:
            query_start_time = kwargs['queryStartTime']
        if 'startPolicyType' in kwargs:
            start_policy_type = kwargs['startPolicyType']

        _setter("query_start_time", query_start_time)
        _setter("start_policy_type", start_policy_type)

    @property
    @pulumi.getter(name="queryStartTime")
    def query_start_time(self) -> str:
        """
        Time when the query can start, if not specified it can start immediately.
        """
        return pulumi.get(self, "query_start_time")

    @property
    @pulumi.getter(name="startPolicyType")
    def start_policy_type(self) -> str:
        """
        policy used for deciding the query start time
        """
        return pulumi.get(self, "start_policy_type")


@pulumi.output_type
class GetDataSourcesDataSourceCollectionItemDataSourceDetectorMappingInfoResult(dict):
    def __init__(__self__, *,
                 detector_recipe_id: str,
                 detector_rule_id: str):
        """
        :param str detector_recipe_id: Id of the attached detectorRecipeId to the Data Source.
        :param str detector_rule_id: Id of the attached detectorRuleId to the Data Source.
        """
        GetDataSourcesDataSourceCollectionItemDataSourceDetectorMappingInfoResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            detector_recipe_id=detector_recipe_id,
            detector_rule_id=detector_rule_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             detector_recipe_id: str,
             detector_rule_id: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'detectorRecipeId' in kwargs:
            detector_recipe_id = kwargs['detectorRecipeId']
        if 'detectorRuleId' in kwargs:
            detector_rule_id = kwargs['detectorRuleId']

        _setter("detector_recipe_id", detector_recipe_id)
        _setter("detector_rule_id", detector_rule_id)

    @property
    @pulumi.getter(name="detectorRecipeId")
    def detector_recipe_id(self) -> str:
        """
        Id of the attached detectorRecipeId to the Data Source.
        """
        return pulumi.get(self, "detector_recipe_id")

    @property
    @pulumi.getter(name="detectorRuleId")
    def detector_rule_id(self) -> str:
        """
        Id of the attached detectorRuleId to the Data Source.
        """
        return pulumi.get(self, "detector_rule_id")


@pulumi.output_type
class GetDataSourcesDataSourceCollectionItemRegionStatusDetailResult(dict):
    def __init__(__self__, *,
                 region: str,
                 status: str):
        """
        :param str region: Data Source replication region.
        :param str status: Status of data Source
        """
        GetDataSourcesDataSourceCollectionItemRegionStatusDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            region=region,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             region: str,
             status: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("region", region)
        _setter("status", status)

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Data Source replication region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of data Source
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetDataSourcesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDataSourcesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDetectorRecipeDetectorRuleResult(dict):
    def __init__(__self__, *,
                 candidate_responder_rules: Sequence['outputs.GetDetectorRecipeDetectorRuleCandidateResponderRuleResult'],
                 data_source_id: str,
                 description: str,
                 details: Sequence['outputs.GetDetectorRecipeDetectorRuleDetailResult'],
                 detector: str,
                 detector_rule_id: str,
                 display_name: str,
                 entities_mappings: Sequence['outputs.GetDetectorRecipeDetectorRuleEntitiesMappingResult'],
                 lifecycle_details: str,
                 managed_list_types: Sequence[str],
                 recommendation: str,
                 resource_type: str,
                 service_type: str,
                 state: str,
                 time_created: str,
                 time_updated: str):
        """
        :param Sequence['GetDetectorRecipeDetectorRuleCandidateResponderRuleArgs'] candidate_responder_rules: List of CandidateResponderRule related to this rule
        :param str data_source_id: The id of the attached DataSource.
        :param str description: Description for DetectorRecipeDetectorRule.
        :param Sequence['GetDetectorRecipeDetectorRuleDetailArgs'] details: Details of a Detector Rule
        :param str detector: detector for the rule
        :param str detector_rule_id: The unique identifier of the detector rule.
        :param str display_name: The display name of entity
        :param Sequence['GetDetectorRecipeDetectorRuleEntitiesMappingArgs'] entities_mappings: Data Source entities mapping for a Detector Rule
        :param str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param Sequence[str] managed_list_types: List of cloudguard managed list types related to this rule
        :param str recommendation: Recommendation for DetectorRecipeDetectorRule
        :param str resource_type: resource type of the configuration to which the rule is applied
        :param str service_type: service type of the configuration to which the rule is applied
        :param str state: The current state of the resource.
        :param str time_created: The date and time the detector recipe was created. Format defined by RFC3339.
        :param str time_updated: The date and time the detector recipe was updated. Format defined by RFC3339.
        """
        GetDetectorRecipeDetectorRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            candidate_responder_rules=candidate_responder_rules,
            data_source_id=data_source_id,
            description=description,
            details=details,
            detector=detector,
            detector_rule_id=detector_rule_id,
            display_name=display_name,
            entities_mappings=entities_mappings,
            lifecycle_details=lifecycle_details,
            managed_list_types=managed_list_types,
            recommendation=recommendation,
            resource_type=resource_type,
            service_type=service_type,
            state=state,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             candidate_responder_rules: Sequence['outputs.GetDetectorRecipeDetectorRuleCandidateResponderRuleResult'],
             data_source_id: str,
             description: str,
             details: Sequence['outputs.GetDetectorRecipeDetectorRuleDetailResult'],
             detector: str,
             detector_rule_id: str,
             display_name: str,
             entities_mappings: Sequence['outputs.GetDetectorRecipeDetectorRuleEntitiesMappingResult'],
             lifecycle_details: str,
             managed_list_types: Sequence[str],
             recommendation: str,
             resource_type: str,
             service_type: str,
             state: str,
             time_created: str,
             time_updated: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'candidateResponderRules' in kwargs:
            candidate_responder_rules = kwargs['candidateResponderRules']
        if 'dataSourceId' in kwargs:
            data_source_id = kwargs['dataSourceId']
        if 'detectorRuleId' in kwargs:
            detector_rule_id = kwargs['detectorRuleId']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'entitiesMappings' in kwargs:
            entities_mappings = kwargs['entitiesMappings']
        if 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if 'managedListTypes' in kwargs:
            managed_list_types = kwargs['managedListTypes']
        if 'resourceType' in kwargs:
            resource_type = kwargs['resourceType']
        if 'serviceType' in kwargs:
            service_type = kwargs['serviceType']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("candidate_responder_rules", candidate_responder_rules)
        _setter("data_source_id", data_source_id)
        _setter("description", description)
        _setter("details", details)
        _setter("detector", detector)
        _setter("detector_rule_id", detector_rule_id)
        _setter("display_name", display_name)
        _setter("entities_mappings", entities_mappings)
        _setter("lifecycle_details", lifecycle_details)
        _setter("managed_list_types", managed_list_types)
        _setter("recommendation", recommendation)
        _setter("resource_type", resource_type)
        _setter("service_type", service_type)
        _setter("state", state)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="candidateResponderRules")
    def candidate_responder_rules(self) -> Sequence['outputs.GetDetectorRecipeDetectorRuleCandidateResponderRuleResult']:
        """
        List of CandidateResponderRule related to this rule
        """
        return pulumi.get(self, "candidate_responder_rules")

    @property
    @pulumi.getter(name="dataSourceId")
    def data_source_id(self) -> str:
        """
        The id of the attached DataSource.
        """
        return pulumi.get(self, "data_source_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description for DetectorRecipeDetectorRule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def details(self) -> Sequence['outputs.GetDetectorRecipeDetectorRuleDetailResult']:
        """
        Details of a Detector Rule
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def detector(self) -> str:
        """
        detector for the rule
        """
        return pulumi.get(self, "detector")

    @property
    @pulumi.getter(name="detectorRuleId")
    def detector_rule_id(self) -> str:
        """
        The unique identifier of the detector rule.
        """
        return pulumi.get(self, "detector_rule_id")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The display name of entity
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="entitiesMappings")
    def entities_mappings(self) -> Sequence['outputs.GetDetectorRecipeDetectorRuleEntitiesMappingResult']:
        """
        Data Source entities mapping for a Detector Rule
        """
        return pulumi.get(self, "entities_mappings")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="managedListTypes")
    def managed_list_types(self) -> Sequence[str]:
        """
        List of cloudguard managed list types related to this rule
        """
        return pulumi.get(self, "managed_list_types")

    @property
    @pulumi.getter
    def recommendation(self) -> str:
        """
        Recommendation for DetectorRecipeDetectorRule
        """
        return pulumi.get(self, "recommendation")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> str:
        """
        resource type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> str:
        """
        service type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "service_type")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the resource.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the detector recipe was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the detector recipe was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetDetectorRecipeDetectorRuleCandidateResponderRuleResult(dict):
    def __init__(__self__, *,
                 display_name: str,
                 id: str,
                 is_preferred: bool):
        """
        :param str display_name: The display name of entity
        :param str id: Ocid for detector recipe
        :param bool is_preferred: Preferred state
        """
        GetDetectorRecipeDetectorRuleCandidateResponderRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            id=id,
            is_preferred=is_preferred,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: str,
             id: str,
             is_preferred: bool,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'isPreferred' in kwargs:
            is_preferred = kwargs['isPreferred']

        _setter("display_name", display_name)
        _setter("id", id)
        _setter("is_preferred", is_preferred)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The display name of entity
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Ocid for detector recipe
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isPreferred")
    def is_preferred(self) -> bool:
        """
        Preferred state
        """
        return pulumi.get(self, "is_preferred")


@pulumi.output_type
class GetDetectorRecipeDetectorRuleDetailResult(dict):
    def __init__(__self__, *,
                 condition: str,
                 configurations: Sequence['outputs.GetDetectorRecipeDetectorRuleDetailConfigurationResult'],
                 data_source_id: str,
                 description: str,
                 entities_mappings: Sequence['outputs.GetDetectorRecipeDetectorRuleDetailEntitiesMappingResult'],
                 is_configuration_allowed: bool,
                 is_enabled: bool,
                 labels: Sequence[str],
                 recommendation: str,
                 risk_level: str):
        """
        :param str condition: Base condition object
        :param Sequence['GetDetectorRecipeDetectorRuleDetailConfigurationArgs'] configurations: Configuration details
        :param str data_source_id: The id of the attached DataSource.
        :param str description: Description for DetectorRecipeDetectorRule.
        :param Sequence['GetDetectorRecipeDetectorRuleDetailEntitiesMappingArgs'] entities_mappings: Data Source entities mapping for a Detector Rule
        :param bool is_configuration_allowed: configuration allowed or not
        :param bool is_enabled: Enables the control
        :param Sequence[str] labels: user defined labels for a detector rule
        :param str recommendation: Recommendation for DetectorRecipeDetectorRule
        :param str risk_level: The Risk Level
        """
        GetDetectorRecipeDetectorRuleDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition=condition,
            configurations=configurations,
            data_source_id=data_source_id,
            description=description,
            entities_mappings=entities_mappings,
            is_configuration_allowed=is_configuration_allowed,
            is_enabled=is_enabled,
            labels=labels,
            recommendation=recommendation,
            risk_level=risk_level,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition: str,
             configurations: Sequence['outputs.GetDetectorRecipeDetectorRuleDetailConfigurationResult'],
             data_source_id: str,
             description: str,
             entities_mappings: Sequence['outputs.GetDetectorRecipeDetectorRuleDetailEntitiesMappingResult'],
             is_configuration_allowed: bool,
             is_enabled: bool,
             labels: Sequence[str],
             recommendation: str,
             risk_level: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'dataSourceId' in kwargs:
            data_source_id = kwargs['dataSourceId']
        if 'entitiesMappings' in kwargs:
            entities_mappings = kwargs['entitiesMappings']
        if 'isConfigurationAllowed' in kwargs:
            is_configuration_allowed = kwargs['isConfigurationAllowed']
        if 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']
        if 'riskLevel' in kwargs:
            risk_level = kwargs['riskLevel']

        _setter("condition", condition)
        _setter("configurations", configurations)
        _setter("data_source_id", data_source_id)
        _setter("description", description)
        _setter("entities_mappings", entities_mappings)
        _setter("is_configuration_allowed", is_configuration_allowed)
        _setter("is_enabled", is_enabled)
        _setter("labels", labels)
        _setter("recommendation", recommendation)
        _setter("risk_level", risk_level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Base condition object
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def configurations(self) -> Sequence['outputs.GetDetectorRecipeDetectorRuleDetailConfigurationResult']:
        """
        Configuration details
        """
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter(name="dataSourceId")
    def data_source_id(self) -> str:
        """
        The id of the attached DataSource.
        """
        return pulumi.get(self, "data_source_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description for DetectorRecipeDetectorRule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="entitiesMappings")
    def entities_mappings(self) -> Sequence['outputs.GetDetectorRecipeDetectorRuleDetailEntitiesMappingResult']:
        """
        Data Source entities mapping for a Detector Rule
        """
        return pulumi.get(self, "entities_mappings")

    @property
    @pulumi.getter(name="isConfigurationAllowed")
    def is_configuration_allowed(self) -> bool:
        """
        configuration allowed or not
        """
        return pulumi.get(self, "is_configuration_allowed")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Enables the control
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def labels(self) -> Sequence[str]:
        """
        user defined labels for a detector rule
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def recommendation(self) -> str:
        """
        Recommendation for DetectorRecipeDetectorRule
        """
        return pulumi.get(self, "recommendation")

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> str:
        """
        The Risk Level
        """
        return pulumi.get(self, "risk_level")


@pulumi.output_type
class GetDetectorRecipeDetectorRuleDetailConfigurationResult(dict):
    def __init__(__self__, *,
                 config_key: str,
                 data_type: str,
                 name: str,
                 value: str,
                 values: Sequence['outputs.GetDetectorRecipeDetectorRuleDetailConfigurationValueResult']):
        """
        :param str config_key: Unique name of the configuration
        :param str data_type: configuration data type
        :param str name: configuration name
        :param str value: configuration value
        :param Sequence['GetDetectorRecipeDetectorRuleDetailConfigurationValueArgs'] values: List of configuration values
        """
        GetDetectorRecipeDetectorRuleDetailConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_key=config_key,
            data_type=data_type,
            name=name,
            value=value,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_key: str,
             data_type: str,
             name: str,
             value: str,
             values: Sequence['outputs.GetDetectorRecipeDetectorRuleDetailConfigurationValueResult'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'configKey' in kwargs:
            config_key = kwargs['configKey']
        if 'dataType' in kwargs:
            data_type = kwargs['dataType']

        _setter("config_key", config_key)
        _setter("data_type", data_type)
        _setter("name", name)
        _setter("value", value)
        _setter("values", values)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> str:
        """
        Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> str:
        """
        configuration data type
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        configuration name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        configuration value
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Sequence['outputs.GetDetectorRecipeDetectorRuleDetailConfigurationValueResult']:
        """
        List of configuration values
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetDetectorRecipeDetectorRuleDetailConfigurationValueResult(dict):
    def __init__(__self__, *,
                 list_type: str,
                 managed_list_type: str,
                 value: str):
        """
        :param str list_type: configuration list item type, either CUSTOM or MANAGED
        :param str managed_list_type: type of the managed list
        :param str value: configuration value
        """
        GetDetectorRecipeDetectorRuleDetailConfigurationValueResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            list_type=list_type,
            managed_list_type=managed_list_type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             list_type: str,
             managed_list_type: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'listType' in kwargs:
            list_type = kwargs['listType']
        if 'managedListType' in kwargs:
            managed_list_type = kwargs['managedListType']

        _setter("list_type", list_type)
        _setter("managed_list_type", managed_list_type)
        _setter("value", value)

    @property
    @pulumi.getter(name="listType")
    def list_type(self) -> str:
        """
        configuration list item type, either CUSTOM or MANAGED
        """
        return pulumi.get(self, "list_type")

    @property
    @pulumi.getter(name="managedListType")
    def managed_list_type(self) -> str:
        """
        type of the managed list
        """
        return pulumi.get(self, "managed_list_type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        configuration value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetDetectorRecipeDetectorRuleDetailEntitiesMappingResult(dict):
    def __init__(__self__, *,
                 display_name: str,
                 entity_type: str,
                 query_field: str):
        """
        :param str display_name: The display name of entity
        :param str entity_type: Possible type of entity
        :param str query_field: The entity value mapped to a data source query
        """
        GetDetectorRecipeDetectorRuleDetailEntitiesMappingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            entity_type=entity_type,
            query_field=query_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: str,
             entity_type: str,
             query_field: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'entityType' in kwargs:
            entity_type = kwargs['entityType']
        if 'queryField' in kwargs:
            query_field = kwargs['queryField']

        _setter("display_name", display_name)
        _setter("entity_type", entity_type)
        _setter("query_field", query_field)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The display name of entity
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Possible type of entity
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="queryField")
    def query_field(self) -> str:
        """
        The entity value mapped to a data source query
        """
        return pulumi.get(self, "query_field")


@pulumi.output_type
class GetDetectorRecipeDetectorRuleEntitiesMappingResult(dict):
    def __init__(__self__, *,
                 display_name: str,
                 entity_type: str,
                 query_field: str):
        """
        :param str display_name: The display name of entity
        :param str entity_type: Possible type of entity
        :param str query_field: The entity value mapped to a data source query
        """
        GetDetectorRecipeDetectorRuleEntitiesMappingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            entity_type=entity_type,
            query_field=query_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: str,
             entity_type: str,
             query_field: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'entityType' in kwargs:
            entity_type = kwargs['entityType']
        if 'queryField' in kwargs:
            query_field = kwargs['queryField']

        _setter("display_name", display_name)
        _setter("entity_type", entity_type)
        _setter("query_field", query_field)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The display name of entity
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Possible type of entity
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="queryField")
    def query_field(self) -> str:
        """
        The entity value mapped to a data source query
        """
        return pulumi.get(self, "query_field")


@pulumi.output_type
class GetDetectorRecipeEffectiveDetectorRuleResult(dict):
    def __init__(__self__, *,
                 candidate_responder_rules: Sequence['outputs.GetDetectorRecipeEffectiveDetectorRuleCandidateResponderRuleResult'],
                 data_source_id: str,
                 description: str,
                 details: Sequence['outputs.GetDetectorRecipeEffectiveDetectorRuleDetailResult'],
                 detector: str,
                 detector_rule_id: str,
                 display_name: str,
                 entities_mappings: Sequence['outputs.GetDetectorRecipeEffectiveDetectorRuleEntitiesMappingResult'],
                 lifecycle_details: str,
                 managed_list_types: Sequence[str],
                 recommendation: str,
                 resource_type: str,
                 service_type: str,
                 state: str,
                 time_created: str,
                 time_updated: str):
        """
        :param Sequence['GetDetectorRecipeEffectiveDetectorRuleCandidateResponderRuleArgs'] candidate_responder_rules: List of CandidateResponderRule related to this rule
        :param str data_source_id: The id of the attached DataSource.
        :param str description: Description for DetectorRecipeDetectorRule.
        :param Sequence['GetDetectorRecipeEffectiveDetectorRuleDetailArgs'] details: Details of a Detector Rule
        :param str detector: detector for the rule
        :param str detector_rule_id: The unique identifier of the detector rule.
        :param str display_name: The display name of entity
        :param Sequence['GetDetectorRecipeEffectiveDetectorRuleEntitiesMappingArgs'] entities_mappings: Data Source entities mapping for a Detector Rule
        :param str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param Sequence[str] managed_list_types: List of cloudguard managed list types related to this rule
        :param str recommendation: Recommendation for DetectorRecipeDetectorRule
        :param str resource_type: resource type of the configuration to which the rule is applied
        :param str service_type: service type of the configuration to which the rule is applied
        :param str state: The current state of the resource.
        :param str time_created: The date and time the detector recipe was created. Format defined by RFC3339.
        :param str time_updated: The date and time the detector recipe was updated. Format defined by RFC3339.
        """
        GetDetectorRecipeEffectiveDetectorRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            candidate_responder_rules=candidate_responder_rules,
            data_source_id=data_source_id,
            description=description,
            details=details,
            detector=detector,
            detector_rule_id=detector_rule_id,
            display_name=display_name,
            entities_mappings=entities_mappings,
            lifecycle_details=lifecycle_details,
            managed_list_types=managed_list_types,
            recommendation=recommendation,
            resource_type=resource_type,
            service_type=service_type,
            state=state,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             candidate_responder_rules: Sequence['outputs.GetDetectorRecipeEffectiveDetectorRuleCandidateResponderRuleResult'],
             data_source_id: str,
             description: str,
             details: Sequence['outputs.GetDetectorRecipeEffectiveDetectorRuleDetailResult'],
             detector: str,
             detector_rule_id: str,
             display_name: str,
             entities_mappings: Sequence['outputs.GetDetectorRecipeEffectiveDetectorRuleEntitiesMappingResult'],
             lifecycle_details: str,
             managed_list_types: Sequence[str],
             recommendation: str,
             resource_type: str,
             service_type: str,
             state: str,
             time_created: str,
             time_updated: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'candidateResponderRules' in kwargs:
            candidate_responder_rules = kwargs['candidateResponderRules']
        if 'dataSourceId' in kwargs:
            data_source_id = kwargs['dataSourceId']
        if 'detectorRuleId' in kwargs:
            detector_rule_id = kwargs['detectorRuleId']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'entitiesMappings' in kwargs:
            entities_mappings = kwargs['entitiesMappings']
        if 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if 'managedListTypes' in kwargs:
            managed_list_types = kwargs['managedListTypes']
        if 'resourceType' in kwargs:
            resource_type = kwargs['resourceType']
        if 'serviceType' in kwargs:
            service_type = kwargs['serviceType']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("candidate_responder_rules", candidate_responder_rules)
        _setter("data_source_id", data_source_id)
        _setter("description", description)
        _setter("details", details)
        _setter("detector", detector)
        _setter("detector_rule_id", detector_rule_id)
        _setter("display_name", display_name)
        _setter("entities_mappings", entities_mappings)
        _setter("lifecycle_details", lifecycle_details)
        _setter("managed_list_types", managed_list_types)
        _setter("recommendation", recommendation)
        _setter("resource_type", resource_type)
        _setter("service_type", service_type)
        _setter("state", state)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="candidateResponderRules")
    def candidate_responder_rules(self) -> Sequence['outputs.GetDetectorRecipeEffectiveDetectorRuleCandidateResponderRuleResult']:
        """
        List of CandidateResponderRule related to this rule
        """
        return pulumi.get(self, "candidate_responder_rules")

    @property
    @pulumi.getter(name="dataSourceId")
    def data_source_id(self) -> str:
        """
        The id of the attached DataSource.
        """
        return pulumi.get(self, "data_source_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description for DetectorRecipeDetectorRule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def details(self) -> Sequence['outputs.GetDetectorRecipeEffectiveDetectorRuleDetailResult']:
        """
        Details of a Detector Rule
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def detector(self) -> str:
        """
        detector for the rule
        """
        return pulumi.get(self, "detector")

    @property
    @pulumi.getter(name="detectorRuleId")
    def detector_rule_id(self) -> str:
        """
        The unique identifier of the detector rule.
        """
        return pulumi.get(self, "detector_rule_id")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The display name of entity
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="entitiesMappings")
    def entities_mappings(self) -> Sequence['outputs.GetDetectorRecipeEffectiveDetectorRuleEntitiesMappingResult']:
        """
        Data Source entities mapping for a Detector Rule
        """
        return pulumi.get(self, "entities_mappings")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="managedListTypes")
    def managed_list_types(self) -> Sequence[str]:
        """
        List of cloudguard managed list types related to this rule
        """
        return pulumi.get(self, "managed_list_types")

    @property
    @pulumi.getter
    def recommendation(self) -> str:
        """
        Recommendation for DetectorRecipeDetectorRule
        """
        return pulumi.get(self, "recommendation")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> str:
        """
        resource type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> str:
        """
        service type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "service_type")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the resource.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the detector recipe was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the detector recipe was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetDetectorRecipeEffectiveDetectorRuleCandidateResponderRuleResult(dict):
    def __init__(__self__, *,
                 display_name: str,
                 id: str,
                 is_preferred: bool):
        """
        :param str display_name: The display name of entity
        :param str id: Ocid for detector recipe
        :param bool is_preferred: Preferred state
        """
        GetDetectorRecipeEffectiveDetectorRuleCandidateResponderRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            id=id,
            is_preferred=is_preferred,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: str,
             id: str,
             is_preferred: bool,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'isPreferred' in kwargs:
            is_preferred = kwargs['isPreferred']

        _setter("display_name", display_name)
        _setter("id", id)
        _setter("is_preferred", is_preferred)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The display name of entity
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Ocid for detector recipe
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isPreferred")
    def is_preferred(self) -> bool:
        """
        Preferred state
        """
        return pulumi.get(self, "is_preferred")


@pulumi.output_type
class GetDetectorRecipeEffectiveDetectorRuleDetailResult(dict):
    def __init__(__self__, *,
                 condition: str,
                 configurations: Sequence['outputs.GetDetectorRecipeEffectiveDetectorRuleDetailConfigurationResult'],
                 is_configuration_allowed: bool,
                 is_enabled: bool,
                 labels: Sequence[str],
                 risk_level: str):
        """
        :param str condition: Base condition object
        :param Sequence['GetDetectorRecipeEffectiveDetectorRuleDetailConfigurationArgs'] configurations: Configuration details
        :param bool is_configuration_allowed: configuration allowed or not
        :param bool is_enabled: Enables the control
        :param Sequence[str] labels: user defined labels for a detector rule
        :param str risk_level: The Risk Level
        """
        GetDetectorRecipeEffectiveDetectorRuleDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition=condition,
            configurations=configurations,
            is_configuration_allowed=is_configuration_allowed,
            is_enabled=is_enabled,
            labels=labels,
            risk_level=risk_level,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition: str,
             configurations: Sequence['outputs.GetDetectorRecipeEffectiveDetectorRuleDetailConfigurationResult'],
             is_configuration_allowed: bool,
             is_enabled: bool,
             labels: Sequence[str],
             risk_level: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'isConfigurationAllowed' in kwargs:
            is_configuration_allowed = kwargs['isConfigurationAllowed']
        if 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']
        if 'riskLevel' in kwargs:
            risk_level = kwargs['riskLevel']

        _setter("condition", condition)
        _setter("configurations", configurations)
        _setter("is_configuration_allowed", is_configuration_allowed)
        _setter("is_enabled", is_enabled)
        _setter("labels", labels)
        _setter("risk_level", risk_level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Base condition object
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def configurations(self) -> Sequence['outputs.GetDetectorRecipeEffectiveDetectorRuleDetailConfigurationResult']:
        """
        Configuration details
        """
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter(name="isConfigurationAllowed")
    def is_configuration_allowed(self) -> bool:
        """
        configuration allowed or not
        """
        return pulumi.get(self, "is_configuration_allowed")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Enables the control
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def labels(self) -> Sequence[str]:
        """
        user defined labels for a detector rule
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> str:
        """
        The Risk Level
        """
        return pulumi.get(self, "risk_level")


@pulumi.output_type
class GetDetectorRecipeEffectiveDetectorRuleDetailConfigurationResult(dict):
    def __init__(__self__, *,
                 config_key: str,
                 data_type: str,
                 name: str,
                 value: str,
                 values: Sequence['outputs.GetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueResult']):
        """
        :param str config_key: Unique name of the configuration
        :param str data_type: configuration data type
        :param str name: configuration name
        :param str value: configuration value
        :param Sequence['GetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueArgs'] values: List of configuration values
        """
        GetDetectorRecipeEffectiveDetectorRuleDetailConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_key=config_key,
            data_type=data_type,
            name=name,
            value=value,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_key: str,
             data_type: str,
             name: str,
             value: str,
             values: Sequence['outputs.GetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueResult'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'configKey' in kwargs:
            config_key = kwargs['configKey']
        if 'dataType' in kwargs:
            data_type = kwargs['dataType']

        _setter("config_key", config_key)
        _setter("data_type", data_type)
        _setter("name", name)
        _setter("value", value)
        _setter("values", values)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> str:
        """
        Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> str:
        """
        configuration data type
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        configuration name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        configuration value
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Sequence['outputs.GetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueResult']:
        """
        List of configuration values
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueResult(dict):
    def __init__(__self__, *,
                 list_type: str,
                 managed_list_type: str,
                 value: str):
        """
        :param str list_type: configuration list item type, either CUSTOM or MANAGED
        :param str managed_list_type: type of the managed list
        :param str value: configuration value
        """
        GetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            list_type=list_type,
            managed_list_type=managed_list_type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             list_type: str,
             managed_list_type: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'listType' in kwargs:
            list_type = kwargs['listType']
        if 'managedListType' in kwargs:
            managed_list_type = kwargs['managedListType']

        _setter("list_type", list_type)
        _setter("managed_list_type", managed_list_type)
        _setter("value", value)

    @property
    @pulumi.getter(name="listType")
    def list_type(self) -> str:
        """
        configuration list item type, either CUSTOM or MANAGED
        """
        return pulumi.get(self, "list_type")

    @property
    @pulumi.getter(name="managedListType")
    def managed_list_type(self) -> str:
        """
        type of the managed list
        """
        return pulumi.get(self, "managed_list_type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        configuration value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetDetectorRecipeEffectiveDetectorRuleEntitiesMappingResult(dict):
    def __init__(__self__, *,
                 display_name: str,
                 entity_type: str,
                 query_field: str):
        """
        :param str display_name: The display name of entity
        :param str entity_type: Possible type of entity
        :param str query_field: The entity value mapped to a data source query
        """
        GetDetectorRecipeEffectiveDetectorRuleEntitiesMappingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            entity_type=entity_type,
            query_field=query_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: str,
             entity_type: str,
             query_field: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'entityType' in kwargs:
            entity_type = kwargs['entityType']
        if 'queryField' in kwargs:
            query_field = kwargs['queryField']

        _setter("display_name", display_name)
        _setter("entity_type", entity_type)
        _setter("query_field", query_field)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The display name of entity
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Possible type of entity
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="queryField")
    def query_field(self) -> str:
        """
        The entity value mapped to a data source query
        """
        return pulumi.get(self, "query_field")


@pulumi.output_type
class GetDetectorRecipesDetectorRecipeCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemResult']):
        GetDetectorRecipesDetectorRecipeCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemResult'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetDetectorRecipesDetectorRecipeCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 detector: str,
                 detector_rules: Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleResult'],
                 display_name: str,
                 effective_detector_rules: Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleResult'],
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 owner: str,
                 source_detector_recipe_id: str,
                 state: str,
                 system_tags: Mapping[str, Any],
                 target_ids: Sequence[str],
                 time_created: str,
                 time_updated: str):
        """
        :param str compartment_id: The ID of the compartment in which to list resources.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param str description: Description for DetectorRecipeDetectorRule.
        :param str detector: detector for the rule
        :param Sequence['GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleArgs'] detector_rules: List of detector rules for the detector type for recipe - user input
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param Sequence['GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleArgs'] effective_detector_rules: List of effective detector rules for the detector type for recipe after applying defaults
        :param Mapping[str, Any] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param str id: Ocid for detector recipe
        :param str owner: Owner of detector recipe
        :param str source_detector_recipe_id: Recipe Ocid of the Source Recipe to be cloned
        :param str state: The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        :param Mapping[str, Any] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). System tags can be viewed by users, but can only be created by the system.  Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param Sequence[str] target_ids: The recipe attached to targets
        :param str time_created: The date and time the detector recipe was created. Format defined by RFC3339.
        :param str time_updated: The date and time the detector recipe was updated. Format defined by RFC3339.
        """
        GetDetectorRecipesDetectorRecipeCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            description=description,
            detector=detector,
            detector_rules=detector_rules,
            display_name=display_name,
            effective_detector_rules=effective_detector_rules,
            freeform_tags=freeform_tags,
            id=id,
            owner=owner,
            source_detector_recipe_id=source_detector_recipe_id,
            state=state,
            system_tags=system_tags,
            target_ids=target_ids,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             defined_tags: Mapping[str, Any],
             description: str,
             detector: str,
             detector_rules: Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleResult'],
             display_name: str,
             effective_detector_rules: Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleResult'],
             freeform_tags: Mapping[str, Any],
             id: str,
             owner: str,
             source_detector_recipe_id: str,
             state: str,
             system_tags: Mapping[str, Any],
             target_ids: Sequence[str],
             time_created: str,
             time_updated: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if 'detectorRules' in kwargs:
            detector_rules = kwargs['detectorRules']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'effectiveDetectorRules' in kwargs:
            effective_detector_rules = kwargs['effectiveDetectorRules']
        if 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if 'sourceDetectorRecipeId' in kwargs:
            source_detector_recipe_id = kwargs['sourceDetectorRecipeId']
        if 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if 'targetIds' in kwargs:
            target_ids = kwargs['targetIds']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("detector", detector)
        _setter("detector_rules", detector_rules)
        _setter("display_name", display_name)
        _setter("effective_detector_rules", effective_detector_rules)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("owner", owner)
        _setter("source_detector_recipe_id", source_detector_recipe_id)
        _setter("state", state)
        _setter("system_tags", system_tags)
        _setter("target_ids", target_ids)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description for DetectorRecipeDetectorRule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def detector(self) -> str:
        """
        detector for the rule
        """
        return pulumi.get(self, "detector")

    @property
    @pulumi.getter(name="detectorRules")
    def detector_rules(self) -> Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleResult']:
        """
        List of detector rules for the detector type for recipe - user input
        """
        return pulumi.get(self, "detector_rules")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="effectiveDetectorRules")
    def effective_detector_rules(self) -> Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleResult']:
        """
        List of effective detector rules for the detector type for recipe after applying defaults
        """
        return pulumi.get(self, "effective_detector_rules")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Ocid for detector recipe
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def owner(self) -> str:
        """
        Owner of detector recipe
        """
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter(name="sourceDetectorRecipeId")
    def source_detector_recipe_id(self) -> str:
        """
        Recipe Ocid of the Source Recipe to be cloned
        """
        return pulumi.get(self, "source_detector_recipe_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). System tags can be viewed by users, but can only be created by the system.  Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="targetIds")
    def target_ids(self) -> Sequence[str]:
        """
        The recipe attached to targets
        """
        return pulumi.get(self, "target_ids")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the detector recipe was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the detector recipe was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleResult(dict):
    def __init__(__self__, *,
                 candidate_responder_rules: Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleCandidateResponderRuleResult'],
                 data_source_id: str,
                 description: str,
                 details: Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleDetailResult'],
                 detector: str,
                 detector_rule_id: str,
                 display_name: str,
                 entities_mappings: Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleEntitiesMappingResult'],
                 lifecycle_details: str,
                 managed_list_types: Sequence[str],
                 recommendation: str,
                 resource_type: str,
                 service_type: str,
                 state: str,
                 time_created: str,
                 time_updated: str):
        """
        :param Sequence['GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleCandidateResponderRuleArgs'] candidate_responder_rules: List of CandidateResponderRule related to this rule
        :param str data_source_id: The id of the attached DataSource.
        :param str description: Description for DetectorRecipeDetectorRule.
        :param Sequence['GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleDetailArgs'] details: Details of a Detector Rule
        :param str detector: detector for the rule
        :param str detector_rule_id: The unique identifier of the detector rule.
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param Sequence['GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleEntitiesMappingArgs'] entities_mappings: Data Source entities mapping for a Detector Rule
        :param str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param Sequence[str] managed_list_types: List of cloudguard managed list types related to this rule
        :param str recommendation: Recommendation for DetectorRecipeDetectorRule
        :param str resource_type: resource type of the configuration to which the rule is applied
        :param str service_type: service type of the configuration to which the rule is applied
        :param str state: The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        :param str time_created: The date and time the detector recipe was created. Format defined by RFC3339.
        :param str time_updated: The date and time the detector recipe was updated. Format defined by RFC3339.
        """
        GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            candidate_responder_rules=candidate_responder_rules,
            data_source_id=data_source_id,
            description=description,
            details=details,
            detector=detector,
            detector_rule_id=detector_rule_id,
            display_name=display_name,
            entities_mappings=entities_mappings,
            lifecycle_details=lifecycle_details,
            managed_list_types=managed_list_types,
            recommendation=recommendation,
            resource_type=resource_type,
            service_type=service_type,
            state=state,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             candidate_responder_rules: Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleCandidateResponderRuleResult'],
             data_source_id: str,
             description: str,
             details: Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleDetailResult'],
             detector: str,
             detector_rule_id: str,
             display_name: str,
             entities_mappings: Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleEntitiesMappingResult'],
             lifecycle_details: str,
             managed_list_types: Sequence[str],
             recommendation: str,
             resource_type: str,
             service_type: str,
             state: str,
             time_created: str,
             time_updated: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'candidateResponderRules' in kwargs:
            candidate_responder_rules = kwargs['candidateResponderRules']
        if 'dataSourceId' in kwargs:
            data_source_id = kwargs['dataSourceId']
        if 'detectorRuleId' in kwargs:
            detector_rule_id = kwargs['detectorRuleId']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'entitiesMappings' in kwargs:
            entities_mappings = kwargs['entitiesMappings']
        if 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if 'managedListTypes' in kwargs:
            managed_list_types = kwargs['managedListTypes']
        if 'resourceType' in kwargs:
            resource_type = kwargs['resourceType']
        if 'serviceType' in kwargs:
            service_type = kwargs['serviceType']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("candidate_responder_rules", candidate_responder_rules)
        _setter("data_source_id", data_source_id)
        _setter("description", description)
        _setter("details", details)
        _setter("detector", detector)
        _setter("detector_rule_id", detector_rule_id)
        _setter("display_name", display_name)
        _setter("entities_mappings", entities_mappings)
        _setter("lifecycle_details", lifecycle_details)
        _setter("managed_list_types", managed_list_types)
        _setter("recommendation", recommendation)
        _setter("resource_type", resource_type)
        _setter("service_type", service_type)
        _setter("state", state)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="candidateResponderRules")
    def candidate_responder_rules(self) -> Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleCandidateResponderRuleResult']:
        """
        List of CandidateResponderRule related to this rule
        """
        return pulumi.get(self, "candidate_responder_rules")

    @property
    @pulumi.getter(name="dataSourceId")
    def data_source_id(self) -> str:
        """
        The id of the attached DataSource.
        """
        return pulumi.get(self, "data_source_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description for DetectorRecipeDetectorRule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def details(self) -> Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleDetailResult']:
        """
        Details of a Detector Rule
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def detector(self) -> str:
        """
        detector for the rule
        """
        return pulumi.get(self, "detector")

    @property
    @pulumi.getter(name="detectorRuleId")
    def detector_rule_id(self) -> str:
        """
        The unique identifier of the detector rule.
        """
        return pulumi.get(self, "detector_rule_id")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="entitiesMappings")
    def entities_mappings(self) -> Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleEntitiesMappingResult']:
        """
        Data Source entities mapping for a Detector Rule
        """
        return pulumi.get(self, "entities_mappings")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="managedListTypes")
    def managed_list_types(self) -> Sequence[str]:
        """
        List of cloudguard managed list types related to this rule
        """
        return pulumi.get(self, "managed_list_types")

    @property
    @pulumi.getter
    def recommendation(self) -> str:
        """
        Recommendation for DetectorRecipeDetectorRule
        """
        return pulumi.get(self, "recommendation")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> str:
        """
        resource type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> str:
        """
        service type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "service_type")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the detector recipe was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the detector recipe was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleCandidateResponderRuleResult(dict):
    def __init__(__self__, *,
                 display_name: str,
                 id: str,
                 is_preferred: bool):
        """
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param str id: Ocid for detector recipe
        :param bool is_preferred: Preferred state
        """
        GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleCandidateResponderRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            id=id,
            is_preferred=is_preferred,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: str,
             id: str,
             is_preferred: bool,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'isPreferred' in kwargs:
            is_preferred = kwargs['isPreferred']

        _setter("display_name", display_name)
        _setter("id", id)
        _setter("is_preferred", is_preferred)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Ocid for detector recipe
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isPreferred")
    def is_preferred(self) -> bool:
        """
        Preferred state
        """
        return pulumi.get(self, "is_preferred")


@pulumi.output_type
class GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleDetailResult(dict):
    def __init__(__self__, *,
                 condition: str,
                 configurations: Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleDetailConfigurationResult'],
                 data_source_id: str,
                 description: str,
                 entities_mappings: Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleDetailEntitiesMappingResult'],
                 is_configuration_allowed: bool,
                 is_enabled: bool,
                 labels: Sequence[str],
                 recommendation: str,
                 risk_level: str):
        """
        :param str condition: Base condition object
        :param Sequence['GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleDetailConfigurationArgs'] configurations: Configuration details
        :param str data_source_id: The id of the attached DataSource.
        :param str description: Description for DetectorRecipeDetectorRule.
        :param Sequence['GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleDetailEntitiesMappingArgs'] entities_mappings: Data Source entities mapping for a Detector Rule
        :param bool is_configuration_allowed: configuration allowed or not
        :param bool is_enabled: Enables the control
        :param Sequence[str] labels: user defined labels for a detector rule
        :param str recommendation: Recommendation for DetectorRecipeDetectorRule
        :param str risk_level: The Risk Level
        """
        GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition=condition,
            configurations=configurations,
            data_source_id=data_source_id,
            description=description,
            entities_mappings=entities_mappings,
            is_configuration_allowed=is_configuration_allowed,
            is_enabled=is_enabled,
            labels=labels,
            recommendation=recommendation,
            risk_level=risk_level,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition: str,
             configurations: Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleDetailConfigurationResult'],
             data_source_id: str,
             description: str,
             entities_mappings: Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleDetailEntitiesMappingResult'],
             is_configuration_allowed: bool,
             is_enabled: bool,
             labels: Sequence[str],
             recommendation: str,
             risk_level: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'dataSourceId' in kwargs:
            data_source_id = kwargs['dataSourceId']
        if 'entitiesMappings' in kwargs:
            entities_mappings = kwargs['entitiesMappings']
        if 'isConfigurationAllowed' in kwargs:
            is_configuration_allowed = kwargs['isConfigurationAllowed']
        if 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']
        if 'riskLevel' in kwargs:
            risk_level = kwargs['riskLevel']

        _setter("condition", condition)
        _setter("configurations", configurations)
        _setter("data_source_id", data_source_id)
        _setter("description", description)
        _setter("entities_mappings", entities_mappings)
        _setter("is_configuration_allowed", is_configuration_allowed)
        _setter("is_enabled", is_enabled)
        _setter("labels", labels)
        _setter("recommendation", recommendation)
        _setter("risk_level", risk_level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Base condition object
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def configurations(self) -> Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleDetailConfigurationResult']:
        """
        Configuration details
        """
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter(name="dataSourceId")
    def data_source_id(self) -> str:
        """
        The id of the attached DataSource.
        """
        return pulumi.get(self, "data_source_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description for DetectorRecipeDetectorRule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="entitiesMappings")
    def entities_mappings(self) -> Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleDetailEntitiesMappingResult']:
        """
        Data Source entities mapping for a Detector Rule
        """
        return pulumi.get(self, "entities_mappings")

    @property
    @pulumi.getter(name="isConfigurationAllowed")
    def is_configuration_allowed(self) -> bool:
        """
        configuration allowed or not
        """
        return pulumi.get(self, "is_configuration_allowed")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Enables the control
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def labels(self) -> Sequence[str]:
        """
        user defined labels for a detector rule
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def recommendation(self) -> str:
        """
        Recommendation for DetectorRecipeDetectorRule
        """
        return pulumi.get(self, "recommendation")

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> str:
        """
        The Risk Level
        """
        return pulumi.get(self, "risk_level")


@pulumi.output_type
class GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleDetailConfigurationResult(dict):
    def __init__(__self__, *,
                 config_key: str,
                 data_type: str,
                 name: str,
                 value: str,
                 values: Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleDetailConfigurationValueResult']):
        """
        :param str config_key: Unique name of the configuration
        :param str data_type: configuration data type
        :param str name: configuration name
        :param str value: configuration value
        :param Sequence['GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleDetailConfigurationValueArgs'] values: List of configuration values
        """
        GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleDetailConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_key=config_key,
            data_type=data_type,
            name=name,
            value=value,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_key: str,
             data_type: str,
             name: str,
             value: str,
             values: Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleDetailConfigurationValueResult'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'configKey' in kwargs:
            config_key = kwargs['configKey']
        if 'dataType' in kwargs:
            data_type = kwargs['dataType']

        _setter("config_key", config_key)
        _setter("data_type", data_type)
        _setter("name", name)
        _setter("value", value)
        _setter("values", values)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> str:
        """
        Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> str:
        """
        configuration data type
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        configuration name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        configuration value
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleDetailConfigurationValueResult']:
        """
        List of configuration values
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleDetailConfigurationValueResult(dict):
    def __init__(__self__, *,
                 list_type: str,
                 managed_list_type: str,
                 value: str):
        """
        :param str list_type: configuration list item type, either CUSTOM or MANAGED
        :param str managed_list_type: type of the managed list
        :param str value: configuration value
        """
        GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleDetailConfigurationValueResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            list_type=list_type,
            managed_list_type=managed_list_type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             list_type: str,
             managed_list_type: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'listType' in kwargs:
            list_type = kwargs['listType']
        if 'managedListType' in kwargs:
            managed_list_type = kwargs['managedListType']

        _setter("list_type", list_type)
        _setter("managed_list_type", managed_list_type)
        _setter("value", value)

    @property
    @pulumi.getter(name="listType")
    def list_type(self) -> str:
        """
        configuration list item type, either CUSTOM or MANAGED
        """
        return pulumi.get(self, "list_type")

    @property
    @pulumi.getter(name="managedListType")
    def managed_list_type(self) -> str:
        """
        type of the managed list
        """
        return pulumi.get(self, "managed_list_type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        configuration value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleDetailEntitiesMappingResult(dict):
    def __init__(__self__, *,
                 display_name: str,
                 entity_type: str,
                 query_field: str):
        """
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param str entity_type: Possible type of entity
        :param str query_field: The entity value mapped to a data source query
        """
        GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleDetailEntitiesMappingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            entity_type=entity_type,
            query_field=query_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: str,
             entity_type: str,
             query_field: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'entityType' in kwargs:
            entity_type = kwargs['entityType']
        if 'queryField' in kwargs:
            query_field = kwargs['queryField']

        _setter("display_name", display_name)
        _setter("entity_type", entity_type)
        _setter("query_field", query_field)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Possible type of entity
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="queryField")
    def query_field(self) -> str:
        """
        The entity value mapped to a data source query
        """
        return pulumi.get(self, "query_field")


@pulumi.output_type
class GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleEntitiesMappingResult(dict):
    def __init__(__self__, *,
                 display_name: str,
                 entity_type: str,
                 query_field: str):
        """
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param str entity_type: Possible type of entity
        :param str query_field: The entity value mapped to a data source query
        """
        GetDetectorRecipesDetectorRecipeCollectionItemDetectorRuleEntitiesMappingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            entity_type=entity_type,
            query_field=query_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: str,
             entity_type: str,
             query_field: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'entityType' in kwargs:
            entity_type = kwargs['entityType']
        if 'queryField' in kwargs:
            query_field = kwargs['queryField']

        _setter("display_name", display_name)
        _setter("entity_type", entity_type)
        _setter("query_field", query_field)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Possible type of entity
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="queryField")
    def query_field(self) -> str:
        """
        The entity value mapped to a data source query
        """
        return pulumi.get(self, "query_field")


@pulumi.output_type
class GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleResult(dict):
    def __init__(__self__, *,
                 candidate_responder_rules: Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleCandidateResponderRuleResult'],
                 data_source_id: str,
                 description: str,
                 details: Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleDetailResult'],
                 detector: str,
                 detector_rule_id: str,
                 display_name: str,
                 entities_mappings: Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleEntitiesMappingResult'],
                 lifecycle_details: str,
                 managed_list_types: Sequence[str],
                 recommendation: str,
                 resource_type: str,
                 service_type: str,
                 state: str,
                 time_created: str,
                 time_updated: str):
        """
        :param Sequence['GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleCandidateResponderRuleArgs'] candidate_responder_rules: List of CandidateResponderRule related to this rule
        :param str data_source_id: The id of the attached DataSource.
        :param str description: Description for DetectorRecipeDetectorRule.
        :param Sequence['GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleDetailArgs'] details: Details of a Detector Rule
        :param str detector: detector for the rule
        :param str detector_rule_id: The unique identifier of the detector rule.
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param Sequence['GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleEntitiesMappingArgs'] entities_mappings: Data Source entities mapping for a Detector Rule
        :param str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param Sequence[str] managed_list_types: List of cloudguard managed list types related to this rule
        :param str recommendation: Recommendation for DetectorRecipeDetectorRule
        :param str resource_type: resource type of the configuration to which the rule is applied
        :param str service_type: service type of the configuration to which the rule is applied
        :param str state: The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        :param str time_created: The date and time the detector recipe was created. Format defined by RFC3339.
        :param str time_updated: The date and time the detector recipe was updated. Format defined by RFC3339.
        """
        GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            candidate_responder_rules=candidate_responder_rules,
            data_source_id=data_source_id,
            description=description,
            details=details,
            detector=detector,
            detector_rule_id=detector_rule_id,
            display_name=display_name,
            entities_mappings=entities_mappings,
            lifecycle_details=lifecycle_details,
            managed_list_types=managed_list_types,
            recommendation=recommendation,
            resource_type=resource_type,
            service_type=service_type,
            state=state,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             candidate_responder_rules: Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleCandidateResponderRuleResult'],
             data_source_id: str,
             description: str,
             details: Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleDetailResult'],
             detector: str,
             detector_rule_id: str,
             display_name: str,
             entities_mappings: Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleEntitiesMappingResult'],
             lifecycle_details: str,
             managed_list_types: Sequence[str],
             recommendation: str,
             resource_type: str,
             service_type: str,
             state: str,
             time_created: str,
             time_updated: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'candidateResponderRules' in kwargs:
            candidate_responder_rules = kwargs['candidateResponderRules']
        if 'dataSourceId' in kwargs:
            data_source_id = kwargs['dataSourceId']
        if 'detectorRuleId' in kwargs:
            detector_rule_id = kwargs['detectorRuleId']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'entitiesMappings' in kwargs:
            entities_mappings = kwargs['entitiesMappings']
        if 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if 'managedListTypes' in kwargs:
            managed_list_types = kwargs['managedListTypes']
        if 'resourceType' in kwargs:
            resource_type = kwargs['resourceType']
        if 'serviceType' in kwargs:
            service_type = kwargs['serviceType']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("candidate_responder_rules", candidate_responder_rules)
        _setter("data_source_id", data_source_id)
        _setter("description", description)
        _setter("details", details)
        _setter("detector", detector)
        _setter("detector_rule_id", detector_rule_id)
        _setter("display_name", display_name)
        _setter("entities_mappings", entities_mappings)
        _setter("lifecycle_details", lifecycle_details)
        _setter("managed_list_types", managed_list_types)
        _setter("recommendation", recommendation)
        _setter("resource_type", resource_type)
        _setter("service_type", service_type)
        _setter("state", state)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="candidateResponderRules")
    def candidate_responder_rules(self) -> Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleCandidateResponderRuleResult']:
        """
        List of CandidateResponderRule related to this rule
        """
        return pulumi.get(self, "candidate_responder_rules")

    @property
    @pulumi.getter(name="dataSourceId")
    def data_source_id(self) -> str:
        """
        The id of the attached DataSource.
        """
        return pulumi.get(self, "data_source_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description for DetectorRecipeDetectorRule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def details(self) -> Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleDetailResult']:
        """
        Details of a Detector Rule
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def detector(self) -> str:
        """
        detector for the rule
        """
        return pulumi.get(self, "detector")

    @property
    @pulumi.getter(name="detectorRuleId")
    def detector_rule_id(self) -> str:
        """
        The unique identifier of the detector rule.
        """
        return pulumi.get(self, "detector_rule_id")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="entitiesMappings")
    def entities_mappings(self) -> Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleEntitiesMappingResult']:
        """
        Data Source entities mapping for a Detector Rule
        """
        return pulumi.get(self, "entities_mappings")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="managedListTypes")
    def managed_list_types(self) -> Sequence[str]:
        """
        List of cloudguard managed list types related to this rule
        """
        return pulumi.get(self, "managed_list_types")

    @property
    @pulumi.getter
    def recommendation(self) -> str:
        """
        Recommendation for DetectorRecipeDetectorRule
        """
        return pulumi.get(self, "recommendation")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> str:
        """
        resource type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> str:
        """
        service type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "service_type")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the detector recipe was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the detector recipe was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleCandidateResponderRuleResult(dict):
    def __init__(__self__, *,
                 display_name: str,
                 id: str,
                 is_preferred: bool):
        """
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param str id: Ocid for detector recipe
        :param bool is_preferred: Preferred state
        """
        GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleCandidateResponderRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            id=id,
            is_preferred=is_preferred,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: str,
             id: str,
             is_preferred: bool,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'isPreferred' in kwargs:
            is_preferred = kwargs['isPreferred']

        _setter("display_name", display_name)
        _setter("id", id)
        _setter("is_preferred", is_preferred)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Ocid for detector recipe
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isPreferred")
    def is_preferred(self) -> bool:
        """
        Preferred state
        """
        return pulumi.get(self, "is_preferred")


@pulumi.output_type
class GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleDetailResult(dict):
    def __init__(__self__, *,
                 condition: str,
                 configurations: Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleDetailConfigurationResult'],
                 is_configuration_allowed: bool,
                 is_enabled: bool,
                 labels: Sequence[str],
                 risk_level: str):
        """
        :param str condition: Base condition object
        :param Sequence['GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleDetailConfigurationArgs'] configurations: Configuration details
        :param bool is_configuration_allowed: configuration allowed or not
        :param bool is_enabled: Enables the control
        :param Sequence[str] labels: user defined labels for a detector rule
        :param str risk_level: The Risk Level
        """
        GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition=condition,
            configurations=configurations,
            is_configuration_allowed=is_configuration_allowed,
            is_enabled=is_enabled,
            labels=labels,
            risk_level=risk_level,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition: str,
             configurations: Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleDetailConfigurationResult'],
             is_configuration_allowed: bool,
             is_enabled: bool,
             labels: Sequence[str],
             risk_level: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'isConfigurationAllowed' in kwargs:
            is_configuration_allowed = kwargs['isConfigurationAllowed']
        if 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']
        if 'riskLevel' in kwargs:
            risk_level = kwargs['riskLevel']

        _setter("condition", condition)
        _setter("configurations", configurations)
        _setter("is_configuration_allowed", is_configuration_allowed)
        _setter("is_enabled", is_enabled)
        _setter("labels", labels)
        _setter("risk_level", risk_level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Base condition object
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def configurations(self) -> Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleDetailConfigurationResult']:
        """
        Configuration details
        """
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter(name="isConfigurationAllowed")
    def is_configuration_allowed(self) -> bool:
        """
        configuration allowed or not
        """
        return pulumi.get(self, "is_configuration_allowed")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Enables the control
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def labels(self) -> Sequence[str]:
        """
        user defined labels for a detector rule
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> str:
        """
        The Risk Level
        """
        return pulumi.get(self, "risk_level")


@pulumi.output_type
class GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleDetailConfigurationResult(dict):
    def __init__(__self__, *,
                 config_key: str,
                 data_type: str,
                 name: str,
                 value: str,
                 values: Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleDetailConfigurationValueResult']):
        """
        :param str config_key: Unique name of the configuration
        :param str data_type: configuration data type
        :param str name: configuration name
        :param str value: configuration value
        :param Sequence['GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleDetailConfigurationValueArgs'] values: List of configuration values
        """
        GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleDetailConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_key=config_key,
            data_type=data_type,
            name=name,
            value=value,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_key: str,
             data_type: str,
             name: str,
             value: str,
             values: Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleDetailConfigurationValueResult'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'configKey' in kwargs:
            config_key = kwargs['configKey']
        if 'dataType' in kwargs:
            data_type = kwargs['dataType']

        _setter("config_key", config_key)
        _setter("data_type", data_type)
        _setter("name", name)
        _setter("value", value)
        _setter("values", values)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> str:
        """
        Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> str:
        """
        configuration data type
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        configuration name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        configuration value
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Sequence['outputs.GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleDetailConfigurationValueResult']:
        """
        List of configuration values
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleDetailConfigurationValueResult(dict):
    def __init__(__self__, *,
                 list_type: str,
                 managed_list_type: str,
                 value: str):
        """
        :param str list_type: configuration list item type, either CUSTOM or MANAGED
        :param str managed_list_type: type of the managed list
        :param str value: configuration value
        """
        GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleDetailConfigurationValueResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            list_type=list_type,
            managed_list_type=managed_list_type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             list_type: str,
             managed_list_type: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'listType' in kwargs:
            list_type = kwargs['listType']
        if 'managedListType' in kwargs:
            managed_list_type = kwargs['managedListType']

        _setter("list_type", list_type)
        _setter("managed_list_type", managed_list_type)
        _setter("value", value)

    @property
    @pulumi.getter(name="listType")
    def list_type(self) -> str:
        """
        configuration list item type, either CUSTOM or MANAGED
        """
        return pulumi.get(self, "list_type")

    @property
    @pulumi.getter(name="managedListType")
    def managed_list_type(self) -> str:
        """
        type of the managed list
        """
        return pulumi.get(self, "managed_list_type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        configuration value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleEntitiesMappingResult(dict):
    def __init__(__self__, *,
                 display_name: str,
                 entity_type: str,
                 query_field: str):
        """
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param str entity_type: Possible type of entity
        :param str query_field: The entity value mapped to a data source query
        """
        GetDetectorRecipesDetectorRecipeCollectionItemEffectiveDetectorRuleEntitiesMappingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            entity_type=entity_type,
            query_field=query_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: str,
             entity_type: str,
             query_field: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'entityType' in kwargs:
            entity_type = kwargs['entityType']
        if 'queryField' in kwargs:
            query_field = kwargs['queryField']

        _setter("display_name", display_name)
        _setter("entity_type", entity_type)
        _setter("query_field", query_field)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Possible type of entity
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="queryField")
    def query_field(self) -> str:
        """
        The entity value mapped to a data source query
        """
        return pulumi.get(self, "query_field")


@pulumi.output_type
class GetDetectorRecipesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: configuration name
        :param Sequence[str] values: List of configuration values
        """
        GetDetectorRecipesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        configuration name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        List of configuration values
        """
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetGuardTargetTargetDetailResult(dict):
    def __init__(__self__, *,
                 security_zone_display_name: str,
                 security_zone_id: str,
                 target_resource_type: str,
                 target_security_zone_recipes: Sequence['outputs.GetGuardTargetTargetDetailTargetSecurityZoneRecipeResult']):
        """
        :param str security_zone_display_name: The name of the security zone to associate this compartment with.
        :param str security_zone_id: The OCID of the security zone to associate this compartment with.
        :param str target_resource_type: possible type of targets
        :param Sequence['GetGuardTargetTargetDetailTargetSecurityZoneRecipeArgs'] target_security_zone_recipes: The list of security zone recipes to associate this compartment with.
        """
        GetGuardTargetTargetDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            security_zone_display_name=security_zone_display_name,
            security_zone_id=security_zone_id,
            target_resource_type=target_resource_type,
            target_security_zone_recipes=target_security_zone_recipes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             security_zone_display_name: str,
             security_zone_id: str,
             target_resource_type: str,
             target_security_zone_recipes: Sequence['outputs.GetGuardTargetTargetDetailTargetSecurityZoneRecipeResult'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'securityZoneDisplayName' in kwargs:
            security_zone_display_name = kwargs['securityZoneDisplayName']
        if 'securityZoneId' in kwargs:
            security_zone_id = kwargs['securityZoneId']
        if 'targetResourceType' in kwargs:
            target_resource_type = kwargs['targetResourceType']
        if 'targetSecurityZoneRecipes' in kwargs:
            target_security_zone_recipes = kwargs['targetSecurityZoneRecipes']

        _setter("security_zone_display_name", security_zone_display_name)
        _setter("security_zone_id", security_zone_id)
        _setter("target_resource_type", target_resource_type)
        _setter("target_security_zone_recipes", target_security_zone_recipes)

    @property
    @pulumi.getter(name="securityZoneDisplayName")
    def security_zone_display_name(self) -> str:
        """
        The name of the security zone to associate this compartment with.
        """
        return pulumi.get(self, "security_zone_display_name")

    @property
    @pulumi.getter(name="securityZoneId")
    def security_zone_id(self) -> str:
        """
        The OCID of the security zone to associate this compartment with.
        """
        return pulumi.get(self, "security_zone_id")

    @property
    @pulumi.getter(name="targetResourceType")
    def target_resource_type(self) -> str:
        """
        possible type of targets
        """
        return pulumi.get(self, "target_resource_type")

    @property
    @pulumi.getter(name="targetSecurityZoneRecipes")
    def target_security_zone_recipes(self) -> Sequence['outputs.GetGuardTargetTargetDetailTargetSecurityZoneRecipeResult']:
        """
        The list of security zone recipes to associate this compartment with.
        """
        return pulumi.get(self, "target_security_zone_recipes")


@pulumi.output_type
class GetGuardTargetTargetDetailTargetSecurityZoneRecipeResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 lifecycle_details: str,
                 owner: str,
                 security_policies: Sequence[str],
                 state: str,
                 system_tags: Mapping[str, Any],
                 time_created: str,
                 time_updated: str):
        """
        :param str compartment_id: Compartment Identifier
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param str description: ResponderRule description.
        :param str display_name: ResponderRule display name.
        :param Mapping[str, Any] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param str id: Unique identifier of TargetResponderRecipe that can't be changed after creation.
        :param str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param str owner: Owner of ResponderRecipe
        :param Sequence[str] security_policies: The list of `SecurityPolicy` ids that are included in the recipe
        :param str state: The current state of the ResponderRule.
        :param Mapping[str, Any] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). System tags can be viewed by users, but can only be created by the system.  Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param str time_created: The date and time the target was created. Format defined by RFC3339.
        :param str time_updated: The date and time the target was updated. Format defined by RFC3339.
        """
        GetGuardTargetTargetDetailTargetSecurityZoneRecipeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            lifecycle_details=lifecycle_details,
            owner=owner,
            security_policies=security_policies,
            state=state,
            system_tags=system_tags,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             defined_tags: Mapping[str, Any],
             description: str,
             display_name: str,
             freeform_tags: Mapping[str, Any],
             id: str,
             lifecycle_details: str,
             owner: str,
             security_policies: Sequence[str],
             state: str,
             system_tags: Mapping[str, Any],
             time_created: str,
             time_updated: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if 'securityPolicies' in kwargs:
            security_policies = kwargs['securityPolicies']
        if 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("owner", owner)
        _setter("security_policies", security_policies)
        _setter("state", state)
        _setter("system_tags", system_tags)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        Compartment Identifier
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        ResponderRule description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        ResponderRule display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of TargetResponderRecipe that can't be changed after creation.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def owner(self) -> str:
        """
        Owner of ResponderRecipe
        """
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter(name="securityPolicies")
    def security_policies(self) -> Sequence[str]:
        """
        The list of `SecurityPolicy` ids that are included in the recipe
        """
        return pulumi.get(self, "security_policies")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the ResponderRule.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). System tags can be viewed by users, but can only be created by the system.  Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the target was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetGuardTargetTargetDetectorRecipeResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 description: str,
                 detector: str,
                 detector_recipe_id: str,
                 detector_rules: Sequence['outputs.GetGuardTargetTargetDetectorRecipeDetectorRuleResult'],
                 display_name: str,
                 effective_detector_rules: Sequence['outputs.GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleResult'],
                 id: str,
                 owner: str,
                 state: str,
                 time_created: str,
                 time_updated: str):
        """
        :param str compartment_id: Compartment Identifier
        :param str description: ResponderRule description.
        :param str detector: detector for the rule
        :param str detector_recipe_id: Unique identifier for Detector Recipe of which this is an extension
        :param Sequence['GetGuardTargetTargetDetectorRecipeDetectorRuleArgs'] detector_rules: List of detector rules for the detector type for recipe - user input
        :param str display_name: ResponderRule display name.
        :param Sequence['GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleArgs'] effective_detector_rules: List of effective detector rules for the detector type for recipe after applying defaults
        :param str id: Unique identifier of TargetResponderRecipe that can't be changed after creation.
        :param str owner: Owner of ResponderRecipe
        :param str state: The current state of the ResponderRule.
        :param str time_created: The date and time the target was created. Format defined by RFC3339.
        :param str time_updated: The date and time the target was updated. Format defined by RFC3339.
        """
        GetGuardTargetTargetDetectorRecipeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            description=description,
            detector=detector,
            detector_recipe_id=detector_recipe_id,
            detector_rules=detector_rules,
            display_name=display_name,
            effective_detector_rules=effective_detector_rules,
            id=id,
            owner=owner,
            state=state,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             description: str,
             detector: str,
             detector_recipe_id: str,
             detector_rules: Sequence['outputs.GetGuardTargetTargetDetectorRecipeDetectorRuleResult'],
             display_name: str,
             effective_detector_rules: Sequence['outputs.GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleResult'],
             id: str,
             owner: str,
             state: str,
             time_created: str,
             time_updated: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if 'detectorRecipeId' in kwargs:
            detector_recipe_id = kwargs['detectorRecipeId']
        if 'detectorRules' in kwargs:
            detector_rules = kwargs['detectorRules']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'effectiveDetectorRules' in kwargs:
            effective_detector_rules = kwargs['effectiveDetectorRules']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("compartment_id", compartment_id)
        _setter("description", description)
        _setter("detector", detector)
        _setter("detector_recipe_id", detector_recipe_id)
        _setter("detector_rules", detector_rules)
        _setter("display_name", display_name)
        _setter("effective_detector_rules", effective_detector_rules)
        _setter("id", id)
        _setter("owner", owner)
        _setter("state", state)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        Compartment Identifier
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        ResponderRule description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def detector(self) -> str:
        """
        detector for the rule
        """
        return pulumi.get(self, "detector")

    @property
    @pulumi.getter(name="detectorRecipeId")
    def detector_recipe_id(self) -> str:
        """
        Unique identifier for Detector Recipe of which this is an extension
        """
        return pulumi.get(self, "detector_recipe_id")

    @property
    @pulumi.getter(name="detectorRules")
    def detector_rules(self) -> Sequence['outputs.GetGuardTargetTargetDetectorRecipeDetectorRuleResult']:
        """
        List of detector rules for the detector type for recipe - user input
        """
        return pulumi.get(self, "detector_rules")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        ResponderRule display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="effectiveDetectorRules")
    def effective_detector_rules(self) -> Sequence['outputs.GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleResult']:
        """
        List of effective detector rules for the detector type for recipe after applying defaults
        """
        return pulumi.get(self, "effective_detector_rules")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of TargetResponderRecipe that can't be changed after creation.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def owner(self) -> str:
        """
        Owner of ResponderRecipe
        """
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the ResponderRule.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the target was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetGuardTargetTargetDetectorRecipeDetectorRuleResult(dict):
    def __init__(__self__, *,
                 data_source_id: str,
                 description: str,
                 details: Sequence['outputs.GetGuardTargetTargetDetectorRecipeDetectorRuleDetailResult'],
                 detector: str,
                 detector_rule_id: str,
                 display_name: str,
                 entities_mappings: Sequence['outputs.GetGuardTargetTargetDetectorRecipeDetectorRuleEntitiesMappingResult'],
                 lifecycle_details: str,
                 managed_list_types: Sequence[str],
                 recommendation: str,
                 resource_type: str,
                 service_type: str,
                 state: str,
                 time_created: str,
                 time_updated: str):
        """
        :param str data_source_id: The id of the attached DataSource.
        :param str description: ResponderRule description.
        :param Sequence['GetGuardTargetTargetDetectorRecipeDetectorRuleDetailArgs'] details: Details of ResponderRule.
        :param str detector: detector for the rule
        :param str detector_rule_id: The unique identifier of the detector rule.
        :param str display_name: ResponderRule display name.
        :param Sequence['GetGuardTargetTargetDetectorRecipeDetectorRuleEntitiesMappingArgs'] entities_mappings: Data Source entities mapping for a Detector Rule
        :param str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param Sequence[str] managed_list_types: List of cloudguard managed list types related to this rule
        :param str recommendation: Recommendation for TargetDetectorRecipeDetectorRule
        :param str resource_type: resource type of the configuration to which the rule is applied
        :param str service_type: service type of the configuration to which the rule is applied
        :param str state: The current state of the ResponderRule.
        :param str time_created: The date and time the target was created. Format defined by RFC3339.
        :param str time_updated: The date and time the target was updated. Format defined by RFC3339.
        """
        GetGuardTargetTargetDetectorRecipeDetectorRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source_id=data_source_id,
            description=description,
            details=details,
            detector=detector,
            detector_rule_id=detector_rule_id,
            display_name=display_name,
            entities_mappings=entities_mappings,
            lifecycle_details=lifecycle_details,
            managed_list_types=managed_list_types,
            recommendation=recommendation,
            resource_type=resource_type,
            service_type=service_type,
            state=state,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source_id: str,
             description: str,
             details: Sequence['outputs.GetGuardTargetTargetDetectorRecipeDetectorRuleDetailResult'],
             detector: str,
             detector_rule_id: str,
             display_name: str,
             entities_mappings: Sequence['outputs.GetGuardTargetTargetDetectorRecipeDetectorRuleEntitiesMappingResult'],
             lifecycle_details: str,
             managed_list_types: Sequence[str],
             recommendation: str,
             resource_type: str,
             service_type: str,
             state: str,
             time_created: str,
             time_updated: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'dataSourceId' in kwargs:
            data_source_id = kwargs['dataSourceId']
        if 'detectorRuleId' in kwargs:
            detector_rule_id = kwargs['detectorRuleId']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'entitiesMappings' in kwargs:
            entities_mappings = kwargs['entitiesMappings']
        if 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if 'managedListTypes' in kwargs:
            managed_list_types = kwargs['managedListTypes']
        if 'resourceType' in kwargs:
            resource_type = kwargs['resourceType']
        if 'serviceType' in kwargs:
            service_type = kwargs['serviceType']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("data_source_id", data_source_id)
        _setter("description", description)
        _setter("details", details)
        _setter("detector", detector)
        _setter("detector_rule_id", detector_rule_id)
        _setter("display_name", display_name)
        _setter("entities_mappings", entities_mappings)
        _setter("lifecycle_details", lifecycle_details)
        _setter("managed_list_types", managed_list_types)
        _setter("recommendation", recommendation)
        _setter("resource_type", resource_type)
        _setter("service_type", service_type)
        _setter("state", state)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="dataSourceId")
    def data_source_id(self) -> str:
        """
        The id of the attached DataSource.
        """
        return pulumi.get(self, "data_source_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        ResponderRule description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def details(self) -> Sequence['outputs.GetGuardTargetTargetDetectorRecipeDetectorRuleDetailResult']:
        """
        Details of ResponderRule.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def detector(self) -> str:
        """
        detector for the rule
        """
        return pulumi.get(self, "detector")

    @property
    @pulumi.getter(name="detectorRuleId")
    def detector_rule_id(self) -> str:
        """
        The unique identifier of the detector rule.
        """
        return pulumi.get(self, "detector_rule_id")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        ResponderRule display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="entitiesMappings")
    def entities_mappings(self) -> Sequence['outputs.GetGuardTargetTargetDetectorRecipeDetectorRuleEntitiesMappingResult']:
        """
        Data Source entities mapping for a Detector Rule
        """
        return pulumi.get(self, "entities_mappings")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="managedListTypes")
    def managed_list_types(self) -> Sequence[str]:
        """
        List of cloudguard managed list types related to this rule
        """
        return pulumi.get(self, "managed_list_types")

    @property
    @pulumi.getter
    def recommendation(self) -> str:
        """
        Recommendation for TargetDetectorRecipeDetectorRule
        """
        return pulumi.get(self, "recommendation")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> str:
        """
        resource type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> str:
        """
        service type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "service_type")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the ResponderRule.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the target was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetGuardTargetTargetDetectorRecipeDetectorRuleDetailResult(dict):
    def __init__(__self__, *,
                 condition_groups: Sequence['outputs.GetGuardTargetTargetDetectorRecipeDetectorRuleDetailConditionGroupResult'],
                 configurations: Sequence['outputs.GetGuardTargetTargetDetectorRecipeDetectorRuleDetailConfigurationResult'],
                 is_configuration_allowed: bool,
                 is_enabled: bool,
                 labels: Sequence[str],
                 risk_level: str):
        """
        :param Sequence['GetGuardTargetTargetDetectorRecipeDetectorRuleDetailConditionGroupArgs'] condition_groups: Condition group corresponding to each compartment
        :param Sequence['GetGuardTargetTargetDetectorRecipeDetectorRuleDetailConfigurationArgs'] configurations: ResponderRule configurations
        :param bool is_configuration_allowed: configuration allowed or not
        :param bool is_enabled: Identifies state for ResponderRule
        :param Sequence[str] labels: user defined labels for a detector rule
        :param str risk_level: The Risk Level
        """
        GetGuardTargetTargetDetectorRecipeDetectorRuleDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition_groups=condition_groups,
            configurations=configurations,
            is_configuration_allowed=is_configuration_allowed,
            is_enabled=is_enabled,
            labels=labels,
            risk_level=risk_level,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition_groups: Sequence['outputs.GetGuardTargetTargetDetectorRecipeDetectorRuleDetailConditionGroupResult'],
             configurations: Sequence['outputs.GetGuardTargetTargetDetectorRecipeDetectorRuleDetailConfigurationResult'],
             is_configuration_allowed: bool,
             is_enabled: bool,
             labels: Sequence[str],
             risk_level: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'conditionGroups' in kwargs:
            condition_groups = kwargs['conditionGroups']
        if 'isConfigurationAllowed' in kwargs:
            is_configuration_allowed = kwargs['isConfigurationAllowed']
        if 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']
        if 'riskLevel' in kwargs:
            risk_level = kwargs['riskLevel']

        _setter("condition_groups", condition_groups)
        _setter("configurations", configurations)
        _setter("is_configuration_allowed", is_configuration_allowed)
        _setter("is_enabled", is_enabled)
        _setter("labels", labels)
        _setter("risk_level", risk_level)

    @property
    @pulumi.getter(name="conditionGroups")
    def condition_groups(self) -> Sequence['outputs.GetGuardTargetTargetDetectorRecipeDetectorRuleDetailConditionGroupResult']:
        """
        Condition group corresponding to each compartment
        """
        return pulumi.get(self, "condition_groups")

    @property
    @pulumi.getter
    def configurations(self) -> Sequence['outputs.GetGuardTargetTargetDetectorRecipeDetectorRuleDetailConfigurationResult']:
        """
        ResponderRule configurations
        """
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter(name="isConfigurationAllowed")
    def is_configuration_allowed(self) -> bool:
        """
        configuration allowed or not
        """
        return pulumi.get(self, "is_configuration_allowed")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Identifies state for ResponderRule
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def labels(self) -> Sequence[str]:
        """
        user defined labels for a detector rule
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> str:
        """
        The Risk Level
        """
        return pulumi.get(self, "risk_level")


@pulumi.output_type
class GetGuardTargetTargetDetectorRecipeDetectorRuleDetailConditionGroupResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 condition: str):
        """
        :param str compartment_id: Compartment Identifier
        :param str condition: Base condition object
        """
        GetGuardTargetTargetDetectorRecipeDetectorRuleDetailConditionGroupResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            condition=condition,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             condition: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']

        _setter("compartment_id", compartment_id)
        _setter("condition", condition)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        Compartment Identifier
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Base condition object
        """
        return pulumi.get(self, "condition")


@pulumi.output_type
class GetGuardTargetTargetDetectorRecipeDetectorRuleDetailConfigurationResult(dict):
    def __init__(__self__, *,
                 config_key: str,
                 data_type: str,
                 name: str,
                 value: str,
                 values: Sequence['outputs.GetGuardTargetTargetDetectorRecipeDetectorRuleDetailConfigurationValueResult']):
        """
        :param str config_key: Unique name of the configuration
        :param str data_type: configuration data type
        :param str name: configuration name
        :param str value: configuration value
        :param Sequence['GetGuardTargetTargetDetectorRecipeDetectorRuleDetailConfigurationValueArgs'] values: List of configuration values
        """
        GetGuardTargetTargetDetectorRecipeDetectorRuleDetailConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_key=config_key,
            data_type=data_type,
            name=name,
            value=value,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_key: str,
             data_type: str,
             name: str,
             value: str,
             values: Sequence['outputs.GetGuardTargetTargetDetectorRecipeDetectorRuleDetailConfigurationValueResult'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'configKey' in kwargs:
            config_key = kwargs['configKey']
        if 'dataType' in kwargs:
            data_type = kwargs['dataType']

        _setter("config_key", config_key)
        _setter("data_type", data_type)
        _setter("name", name)
        _setter("value", value)
        _setter("values", values)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> str:
        """
        Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> str:
        """
        configuration data type
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        configuration name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        configuration value
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Sequence['outputs.GetGuardTargetTargetDetectorRecipeDetectorRuleDetailConfigurationValueResult']:
        """
        List of configuration values
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetGuardTargetTargetDetectorRecipeDetectorRuleDetailConfigurationValueResult(dict):
    def __init__(__self__, *,
                 list_type: str,
                 managed_list_type: str,
                 value: str):
        """
        :param str list_type: configuration list item type, either CUSTOM or MANAGED
        :param str managed_list_type: type of the managed list
        :param str value: configuration value
        """
        GetGuardTargetTargetDetectorRecipeDetectorRuleDetailConfigurationValueResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            list_type=list_type,
            managed_list_type=managed_list_type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             list_type: str,
             managed_list_type: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'listType' in kwargs:
            list_type = kwargs['listType']
        if 'managedListType' in kwargs:
            managed_list_type = kwargs['managedListType']

        _setter("list_type", list_type)
        _setter("managed_list_type", managed_list_type)
        _setter("value", value)

    @property
    @pulumi.getter(name="listType")
    def list_type(self) -> str:
        """
        configuration list item type, either CUSTOM or MANAGED
        """
        return pulumi.get(self, "list_type")

    @property
    @pulumi.getter(name="managedListType")
    def managed_list_type(self) -> str:
        """
        type of the managed list
        """
        return pulumi.get(self, "managed_list_type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        configuration value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetGuardTargetTargetDetectorRecipeDetectorRuleEntitiesMappingResult(dict):
    def __init__(__self__, *,
                 display_name: str,
                 entity_type: str,
                 query_field: str):
        """
        :param str display_name: ResponderRule display name.
        :param str entity_type: Possible type of entity
        :param str query_field: The entity value mapped to a data source query
        """
        GetGuardTargetTargetDetectorRecipeDetectorRuleEntitiesMappingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            entity_type=entity_type,
            query_field=query_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: str,
             entity_type: str,
             query_field: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'entityType' in kwargs:
            entity_type = kwargs['entityType']
        if 'queryField' in kwargs:
            query_field = kwargs['queryField']

        _setter("display_name", display_name)
        _setter("entity_type", entity_type)
        _setter("query_field", query_field)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        ResponderRule display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Possible type of entity
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="queryField")
    def query_field(self) -> str:
        """
        The entity value mapped to a data source query
        """
        return pulumi.get(self, "query_field")


@pulumi.output_type
class GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleResult(dict):
    def __init__(__self__, *,
                 data_source_id: str,
                 description: str,
                 details: Sequence['outputs.GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailResult'],
                 detector: str,
                 detector_rule_id: str,
                 display_name: str,
                 entities_mappings: Sequence['outputs.GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleEntitiesMappingResult'],
                 lifecycle_details: str,
                 managed_list_types: Sequence[str],
                 recommendation: str,
                 resource_type: str,
                 service_type: str,
                 state: str,
                 time_created: str,
                 time_updated: str):
        """
        :param str data_source_id: The id of the attached DataSource.
        :param str description: ResponderRule description.
        :param Sequence['GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailArgs'] details: Details of ResponderRule.
        :param str detector: detector for the rule
        :param str detector_rule_id: The unique identifier of the detector rule.
        :param str display_name: ResponderRule display name.
        :param Sequence['GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleEntitiesMappingArgs'] entities_mappings: Data Source entities mapping for a Detector Rule
        :param str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param Sequence[str] managed_list_types: List of cloudguard managed list types related to this rule
        :param str recommendation: Recommendation for TargetDetectorRecipeDetectorRule
        :param str resource_type: resource type of the configuration to which the rule is applied
        :param str service_type: service type of the configuration to which the rule is applied
        :param str state: The current state of the ResponderRule.
        :param str time_created: The date and time the target was created. Format defined by RFC3339.
        :param str time_updated: The date and time the target was updated. Format defined by RFC3339.
        """
        GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source_id=data_source_id,
            description=description,
            details=details,
            detector=detector,
            detector_rule_id=detector_rule_id,
            display_name=display_name,
            entities_mappings=entities_mappings,
            lifecycle_details=lifecycle_details,
            managed_list_types=managed_list_types,
            recommendation=recommendation,
            resource_type=resource_type,
            service_type=service_type,
            state=state,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source_id: str,
             description: str,
             details: Sequence['outputs.GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailResult'],
             detector: str,
             detector_rule_id: str,
             display_name: str,
             entities_mappings: Sequence['outputs.GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleEntitiesMappingResult'],
             lifecycle_details: str,
             managed_list_types: Sequence[str],
             recommendation: str,
             resource_type: str,
             service_type: str,
             state: str,
             time_created: str,
             time_updated: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'dataSourceId' in kwargs:
            data_source_id = kwargs['dataSourceId']
        if 'detectorRuleId' in kwargs:
            detector_rule_id = kwargs['detectorRuleId']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'entitiesMappings' in kwargs:
            entities_mappings = kwargs['entitiesMappings']
        if 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if 'managedListTypes' in kwargs:
            managed_list_types = kwargs['managedListTypes']
        if 'resourceType' in kwargs:
            resource_type = kwargs['resourceType']
        if 'serviceType' in kwargs:
            service_type = kwargs['serviceType']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("data_source_id", data_source_id)
        _setter("description", description)
        _setter("details", details)
        _setter("detector", detector)
        _setter("detector_rule_id", detector_rule_id)
        _setter("display_name", display_name)
        _setter("entities_mappings", entities_mappings)
        _setter("lifecycle_details", lifecycle_details)
        _setter("managed_list_types", managed_list_types)
        _setter("recommendation", recommendation)
        _setter("resource_type", resource_type)
        _setter("service_type", service_type)
        _setter("state", state)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="dataSourceId")
    def data_source_id(self) -> str:
        """
        The id of the attached DataSource.
        """
        return pulumi.get(self, "data_source_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        ResponderRule description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def details(self) -> Sequence['outputs.GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailResult']:
        """
        Details of ResponderRule.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def detector(self) -> str:
        """
        detector for the rule
        """
        return pulumi.get(self, "detector")

    @property
    @pulumi.getter(name="detectorRuleId")
    def detector_rule_id(self) -> str:
        """
        The unique identifier of the detector rule.
        """
        return pulumi.get(self, "detector_rule_id")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        ResponderRule display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="entitiesMappings")
    def entities_mappings(self) -> Sequence['outputs.GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleEntitiesMappingResult']:
        """
        Data Source entities mapping for a Detector Rule
        """
        return pulumi.get(self, "entities_mappings")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="managedListTypes")
    def managed_list_types(self) -> Sequence[str]:
        """
        List of cloudguard managed list types related to this rule
        """
        return pulumi.get(self, "managed_list_types")

    @property
    @pulumi.getter
    def recommendation(self) -> str:
        """
        Recommendation for TargetDetectorRecipeDetectorRule
        """
        return pulumi.get(self, "recommendation")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> str:
        """
        resource type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> str:
        """
        service type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "service_type")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the ResponderRule.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the target was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailResult(dict):
    def __init__(__self__, *,
                 condition_groups: Sequence['outputs.GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroupResult'],
                 configurations: Sequence['outputs.GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationResult'],
                 is_configuration_allowed: bool,
                 is_enabled: bool,
                 labels: Sequence[str],
                 risk_level: str):
        """
        :param Sequence['GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroupArgs'] condition_groups: Condition group corresponding to each compartment
        :param Sequence['GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationArgs'] configurations: ResponderRule configurations
        :param bool is_configuration_allowed: configuration allowed or not
        :param bool is_enabled: Identifies state for ResponderRule
        :param Sequence[str] labels: user defined labels for a detector rule
        :param str risk_level: The Risk Level
        """
        GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition_groups=condition_groups,
            configurations=configurations,
            is_configuration_allowed=is_configuration_allowed,
            is_enabled=is_enabled,
            labels=labels,
            risk_level=risk_level,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition_groups: Sequence['outputs.GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroupResult'],
             configurations: Sequence['outputs.GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationResult'],
             is_configuration_allowed: bool,
             is_enabled: bool,
             labels: Sequence[str],
             risk_level: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'conditionGroups' in kwargs:
            condition_groups = kwargs['conditionGroups']
        if 'isConfigurationAllowed' in kwargs:
            is_configuration_allowed = kwargs['isConfigurationAllowed']
        if 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']
        if 'riskLevel' in kwargs:
            risk_level = kwargs['riskLevel']

        _setter("condition_groups", condition_groups)
        _setter("configurations", configurations)
        _setter("is_configuration_allowed", is_configuration_allowed)
        _setter("is_enabled", is_enabled)
        _setter("labels", labels)
        _setter("risk_level", risk_level)

    @property
    @pulumi.getter(name="conditionGroups")
    def condition_groups(self) -> Sequence['outputs.GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroupResult']:
        """
        Condition group corresponding to each compartment
        """
        return pulumi.get(self, "condition_groups")

    @property
    @pulumi.getter
    def configurations(self) -> Sequence['outputs.GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationResult']:
        """
        ResponderRule configurations
        """
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter(name="isConfigurationAllowed")
    def is_configuration_allowed(self) -> bool:
        """
        configuration allowed or not
        """
        return pulumi.get(self, "is_configuration_allowed")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Identifies state for ResponderRule
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def labels(self) -> Sequence[str]:
        """
        user defined labels for a detector rule
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> str:
        """
        The Risk Level
        """
        return pulumi.get(self, "risk_level")


@pulumi.output_type
class GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroupResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 condition: str):
        """
        :param str compartment_id: Compartment Identifier
        :param str condition: Base condition object
        """
        GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroupResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            condition=condition,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             condition: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']

        _setter("compartment_id", compartment_id)
        _setter("condition", condition)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        Compartment Identifier
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Base condition object
        """
        return pulumi.get(self, "condition")


@pulumi.output_type
class GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationResult(dict):
    def __init__(__self__, *,
                 config_key: str,
                 data_type: str,
                 name: str,
                 value: str,
                 values: Sequence['outputs.GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueResult']):
        """
        :param str config_key: Unique name of the configuration
        :param str data_type: configuration data type
        :param str name: configuration name
        :param str value: configuration value
        :param Sequence['GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueArgs'] values: List of configuration values
        """
        GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_key=config_key,
            data_type=data_type,
            name=name,
            value=value,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_key: str,
             data_type: str,
             name: str,
             value: str,
             values: Sequence['outputs.GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueResult'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'configKey' in kwargs:
            config_key = kwargs['configKey']
        if 'dataType' in kwargs:
            data_type = kwargs['dataType']

        _setter("config_key", config_key)
        _setter("data_type", data_type)
        _setter("name", name)
        _setter("value", value)
        _setter("values", values)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> str:
        """
        Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> str:
        """
        configuration data type
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        configuration name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        configuration value
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Sequence['outputs.GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueResult']:
        """
        List of configuration values
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueResult(dict):
    def __init__(__self__, *,
                 list_type: str,
                 managed_list_type: str,
                 value: str):
        """
        :param str list_type: configuration list item type, either CUSTOM or MANAGED
        :param str managed_list_type: type of the managed list
        :param str value: configuration value
        """
        GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            list_type=list_type,
            managed_list_type=managed_list_type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             list_type: str,
             managed_list_type: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'listType' in kwargs:
            list_type = kwargs['listType']
        if 'managedListType' in kwargs:
            managed_list_type = kwargs['managedListType']

        _setter("list_type", list_type)
        _setter("managed_list_type", managed_list_type)
        _setter("value", value)

    @property
    @pulumi.getter(name="listType")
    def list_type(self) -> str:
        """
        configuration list item type, either CUSTOM or MANAGED
        """
        return pulumi.get(self, "list_type")

    @property
    @pulumi.getter(name="managedListType")
    def managed_list_type(self) -> str:
        """
        type of the managed list
        """
        return pulumi.get(self, "managed_list_type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        configuration value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleEntitiesMappingResult(dict):
    def __init__(__self__, *,
                 display_name: str,
                 entity_type: str,
                 query_field: str):
        """
        :param str display_name: ResponderRule display name.
        :param str entity_type: Possible type of entity
        :param str query_field: The entity value mapped to a data source query
        """
        GetGuardTargetTargetDetectorRecipeEffectiveDetectorRuleEntitiesMappingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            entity_type=entity_type,
            query_field=query_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: str,
             entity_type: str,
             query_field: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'entityType' in kwargs:
            entity_type = kwargs['entityType']
        if 'queryField' in kwargs:
            query_field = kwargs['queryField']

        _setter("display_name", display_name)
        _setter("entity_type", entity_type)
        _setter("query_field", query_field)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        ResponderRule display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Possible type of entity
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="queryField")
    def query_field(self) -> str:
        """
        The entity value mapped to a data source query
        """
        return pulumi.get(self, "query_field")


@pulumi.output_type
class GetGuardTargetTargetResponderRecipeResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 description: str,
                 display_name: str,
                 effective_responder_rules: Sequence['outputs.GetGuardTargetTargetResponderRecipeEffectiveResponderRuleResult'],
                 id: str,
                 owner: str,
                 responder_recipe_id: str,
                 responder_rules: Sequence['outputs.GetGuardTargetTargetResponderRecipeResponderRuleResult'],
                 time_created: str,
                 time_updated: str):
        """
        :param str compartment_id: Compartment Identifier
        :param str description: ResponderRule description.
        :param str display_name: ResponderRule display name.
        :param Sequence['GetGuardTargetTargetResponderRecipeEffectiveResponderRuleArgs'] effective_responder_rules: List of responder rules associated with the recipe after applying all defaults
        :param str id: Unique identifier of TargetResponderRecipe that can't be changed after creation.
        :param str owner: Owner of ResponderRecipe
        :param str responder_recipe_id: Unique identifier for Responder Recipe of which this is an extension.
        :param Sequence['GetGuardTargetTargetResponderRecipeResponderRuleArgs'] responder_rules: List of responder rules associated with the recipe - user input
        :param str time_created: The date and time the target was created. Format defined by RFC3339.
        :param str time_updated: The date and time the target was updated. Format defined by RFC3339.
        """
        GetGuardTargetTargetResponderRecipeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            description=description,
            display_name=display_name,
            effective_responder_rules=effective_responder_rules,
            id=id,
            owner=owner,
            responder_recipe_id=responder_recipe_id,
            responder_rules=responder_rules,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             description: str,
             display_name: str,
             effective_responder_rules: Sequence['outputs.GetGuardTargetTargetResponderRecipeEffectiveResponderRuleResult'],
             id: str,
             owner: str,
             responder_recipe_id: str,
             responder_rules: Sequence['outputs.GetGuardTargetTargetResponderRecipeResponderRuleResult'],
             time_created: str,
             time_updated: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'effectiveResponderRules' in kwargs:
            effective_responder_rules = kwargs['effectiveResponderRules']
        if 'responderRecipeId' in kwargs:
            responder_recipe_id = kwargs['responderRecipeId']
        if 'responderRules' in kwargs:
            responder_rules = kwargs['responderRules']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("compartment_id", compartment_id)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("effective_responder_rules", effective_responder_rules)
        _setter("id", id)
        _setter("owner", owner)
        _setter("responder_recipe_id", responder_recipe_id)
        _setter("responder_rules", responder_rules)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        Compartment Identifier
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        ResponderRule description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        ResponderRule display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="effectiveResponderRules")
    def effective_responder_rules(self) -> Sequence['outputs.GetGuardTargetTargetResponderRecipeEffectiveResponderRuleResult']:
        """
        List of responder rules associated with the recipe after applying all defaults
        """
        return pulumi.get(self, "effective_responder_rules")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of TargetResponderRecipe that can't be changed after creation.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def owner(self) -> str:
        """
        Owner of ResponderRecipe
        """
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter(name="responderRecipeId")
    def responder_recipe_id(self) -> str:
        """
        Unique identifier for Responder Recipe of which this is an extension.
        """
        return pulumi.get(self, "responder_recipe_id")

    @property
    @pulumi.getter(name="responderRules")
    def responder_rules(self) -> Sequence['outputs.GetGuardTargetTargetResponderRecipeResponderRuleResult']:
        """
        List of responder rules associated with the recipe - user input
        """
        return pulumi.get(self, "responder_rules")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the target was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetGuardTargetTargetResponderRecipeEffectiveResponderRuleResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 description: str,
                 details: Sequence['outputs.GetGuardTargetTargetResponderRecipeEffectiveResponderRuleDetailResult'],
                 display_name: str,
                 lifecycle_details: str,
                 policies: Sequence[str],
                 responder_rule_id: str,
                 state: str,
                 supported_modes: Sequence[str],
                 time_created: str,
                 time_updated: str,
                 type: str):
        """
        :param str compartment_id: Compartment Identifier
        :param str description: ResponderRule description.
        :param Sequence['GetGuardTargetTargetResponderRecipeEffectiveResponderRuleDetailArgs'] details: Details of ResponderRule.
        :param str display_name: ResponderRule display name.
        :param str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param Sequence[str] policies: List of Policy
        :param str responder_rule_id: Unique ResponderRule identifier.
        :param str state: The current state of the ResponderRule.
        :param Sequence[str] supported_modes: Supported Execution Modes
        :param str time_created: The date and time the target was created. Format defined by RFC3339.
        :param str time_updated: The date and time the target was updated. Format defined by RFC3339.
        :param str type: Type of Responder
        """
        GetGuardTargetTargetResponderRecipeEffectiveResponderRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            description=description,
            details=details,
            display_name=display_name,
            lifecycle_details=lifecycle_details,
            policies=policies,
            responder_rule_id=responder_rule_id,
            state=state,
            supported_modes=supported_modes,
            time_created=time_created,
            time_updated=time_updated,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             description: str,
             details: Sequence['outputs.GetGuardTargetTargetResponderRecipeEffectiveResponderRuleDetailResult'],
             display_name: str,
             lifecycle_details: str,
             policies: Sequence[str],
             responder_rule_id: str,
             state: str,
             supported_modes: Sequence[str],
             time_created: str,
             time_updated: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if 'responderRuleId' in kwargs:
            responder_rule_id = kwargs['responderRuleId']
        if 'supportedModes' in kwargs:
            supported_modes = kwargs['supportedModes']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("compartment_id", compartment_id)
        _setter("description", description)
        _setter("details", details)
        _setter("display_name", display_name)
        _setter("lifecycle_details", lifecycle_details)
        _setter("policies", policies)
        _setter("responder_rule_id", responder_rule_id)
        _setter("state", state)
        _setter("supported_modes", supported_modes)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)
        _setter("type", type)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        Compartment Identifier
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        ResponderRule description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def details(self) -> Sequence['outputs.GetGuardTargetTargetResponderRecipeEffectiveResponderRuleDetailResult']:
        """
        Details of ResponderRule.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        ResponderRule display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def policies(self) -> Sequence[str]:
        """
        List of Policy
        """
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="responderRuleId")
    def responder_rule_id(self) -> str:
        """
        Unique ResponderRule identifier.
        """
        return pulumi.get(self, "responder_rule_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the ResponderRule.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="supportedModes")
    def supported_modes(self) -> Sequence[str]:
        """
        Supported Execution Modes
        """
        return pulumi.get(self, "supported_modes")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the target was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of Responder
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetGuardTargetTargetResponderRecipeEffectiveResponderRuleDetailResult(dict):
    def __init__(__self__, *,
                 condition: str,
                 configurations: Sequence['outputs.GetGuardTargetTargetResponderRecipeEffectiveResponderRuleDetailConfigurationResult'],
                 is_enabled: bool,
                 mode: str):
        """
        :param str condition: Base condition object
        :param Sequence['GetGuardTargetTargetResponderRecipeEffectiveResponderRuleDetailConfigurationArgs'] configurations: ResponderRule configurations
        :param bool is_enabled: Identifies state for ResponderRule
        :param str mode: Execution Mode for ResponderRule
        """
        GetGuardTargetTargetResponderRecipeEffectiveResponderRuleDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition=condition,
            configurations=configurations,
            is_enabled=is_enabled,
            mode=mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition: str,
             configurations: Sequence['outputs.GetGuardTargetTargetResponderRecipeEffectiveResponderRuleDetailConfigurationResult'],
             is_enabled: bool,
             mode: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']

        _setter("condition", condition)
        _setter("configurations", configurations)
        _setter("is_enabled", is_enabled)
        _setter("mode", mode)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Base condition object
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def configurations(self) -> Sequence['outputs.GetGuardTargetTargetResponderRecipeEffectiveResponderRuleDetailConfigurationResult']:
        """
        ResponderRule configurations
        """
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Identifies state for ResponderRule
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Execution Mode for ResponderRule
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetGuardTargetTargetResponderRecipeEffectiveResponderRuleDetailConfigurationResult(dict):
    def __init__(__self__, *,
                 config_key: str,
                 name: str,
                 value: str):
        """
        :param str config_key: Unique name of the configuration
        :param str name: configuration name
        :param str value: configuration value
        """
        GetGuardTargetTargetResponderRecipeEffectiveResponderRuleDetailConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_key=config_key,
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_key: str,
             name: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'configKey' in kwargs:
            config_key = kwargs['configKey']

        _setter("config_key", config_key)
        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> str:
        """
        Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        configuration name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        configuration value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetGuardTargetTargetResponderRecipeResponderRuleResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 description: str,
                 details: Sequence['outputs.GetGuardTargetTargetResponderRecipeResponderRuleDetailResult'],
                 display_name: str,
                 lifecycle_details: str,
                 policies: Sequence[str],
                 responder_rule_id: str,
                 state: str,
                 supported_modes: Sequence[str],
                 time_created: str,
                 time_updated: str,
                 type: str):
        """
        :param str compartment_id: Compartment Identifier
        :param str description: ResponderRule description.
        :param Sequence['GetGuardTargetTargetResponderRecipeResponderRuleDetailArgs'] details: Details of ResponderRule.
        :param str display_name: ResponderRule display name.
        :param str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param Sequence[str] policies: List of Policy
        :param str responder_rule_id: Unique ResponderRule identifier.
        :param str state: The current state of the ResponderRule.
        :param Sequence[str] supported_modes: Supported Execution Modes
        :param str time_created: The date and time the target was created. Format defined by RFC3339.
        :param str time_updated: The date and time the target was updated. Format defined by RFC3339.
        :param str type: Type of Responder
        """
        GetGuardTargetTargetResponderRecipeResponderRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            description=description,
            details=details,
            display_name=display_name,
            lifecycle_details=lifecycle_details,
            policies=policies,
            responder_rule_id=responder_rule_id,
            state=state,
            supported_modes=supported_modes,
            time_created=time_created,
            time_updated=time_updated,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             description: str,
             details: Sequence['outputs.GetGuardTargetTargetResponderRecipeResponderRuleDetailResult'],
             display_name: str,
             lifecycle_details: str,
             policies: Sequence[str],
             responder_rule_id: str,
             state: str,
             supported_modes: Sequence[str],
             time_created: str,
             time_updated: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if 'responderRuleId' in kwargs:
            responder_rule_id = kwargs['responderRuleId']
        if 'supportedModes' in kwargs:
            supported_modes = kwargs['supportedModes']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("compartment_id", compartment_id)
        _setter("description", description)
        _setter("details", details)
        _setter("display_name", display_name)
        _setter("lifecycle_details", lifecycle_details)
        _setter("policies", policies)
        _setter("responder_rule_id", responder_rule_id)
        _setter("state", state)
        _setter("supported_modes", supported_modes)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)
        _setter("type", type)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        Compartment Identifier
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        ResponderRule description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def details(self) -> Sequence['outputs.GetGuardTargetTargetResponderRecipeResponderRuleDetailResult']:
        """
        Details of ResponderRule.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        ResponderRule display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def policies(self) -> Sequence[str]:
        """
        List of Policy
        """
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="responderRuleId")
    def responder_rule_id(self) -> str:
        """
        Unique ResponderRule identifier.
        """
        return pulumi.get(self, "responder_rule_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the ResponderRule.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="supportedModes")
    def supported_modes(self) -> Sequence[str]:
        """
        Supported Execution Modes
        """
        return pulumi.get(self, "supported_modes")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the target was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of Responder
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetGuardTargetTargetResponderRecipeResponderRuleDetailResult(dict):
    def __init__(__self__, *,
                 condition: str,
                 configurations: Sequence['outputs.GetGuardTargetTargetResponderRecipeResponderRuleDetailConfigurationResult'],
                 is_enabled: bool,
                 mode: str):
        """
        :param str condition: Base condition object
        :param Sequence['GetGuardTargetTargetResponderRecipeResponderRuleDetailConfigurationArgs'] configurations: ResponderRule configurations
        :param bool is_enabled: Identifies state for ResponderRule
        :param str mode: Execution Mode for ResponderRule
        """
        GetGuardTargetTargetResponderRecipeResponderRuleDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition=condition,
            configurations=configurations,
            is_enabled=is_enabled,
            mode=mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition: str,
             configurations: Sequence['outputs.GetGuardTargetTargetResponderRecipeResponderRuleDetailConfigurationResult'],
             is_enabled: bool,
             mode: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']

        _setter("condition", condition)
        _setter("configurations", configurations)
        _setter("is_enabled", is_enabled)
        _setter("mode", mode)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Base condition object
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def configurations(self) -> Sequence['outputs.GetGuardTargetTargetResponderRecipeResponderRuleDetailConfigurationResult']:
        """
        ResponderRule configurations
        """
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Identifies state for ResponderRule
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Execution Mode for ResponderRule
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetGuardTargetTargetResponderRecipeResponderRuleDetailConfigurationResult(dict):
    def __init__(__self__, *,
                 config_key: str,
                 name: str,
                 value: str):
        """
        :param str config_key: Unique name of the configuration
        :param str name: configuration name
        :param str value: configuration value
        """
        GetGuardTargetTargetResponderRecipeResponderRuleDetailConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_key=config_key,
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_key: str,
             name: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'configKey' in kwargs:
            config_key = kwargs['configKey']

        _setter("config_key", config_key)
        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> str:
        """
        Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        configuration name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        configuration value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetGuardTargetsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: configuration name
        :param Sequence[str] values: List of configuration values
        """
        GetGuardTargetsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        configuration name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        List of configuration values
        """
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetGuardTargetsTargetCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetGuardTargetsTargetCollectionItemResult']):
        GetGuardTargetsTargetCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Sequence['outputs.GetGuardTargetsTargetCollectionItemResult'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetGuardTargetsTargetCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetGuardTargetsTargetCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 inherited_by_compartments: Sequence[str],
                 lifecyle_details: str,
                 recipe_count: int,
                 state: str,
                 system_tags: Mapping[str, Any],
                 target_details: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetailResult'],
                 target_detector_recipes: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeResult'],
                 target_resource_id: str,
                 target_resource_type: str,
                 target_responder_recipes: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetResponderRecipeResult'],
                 time_created: str,
                 time_updated: str):
        """
        :param str compartment_id: The ID of the compartment in which to list resources.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param str description: ResponderRule description.
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param Mapping[str, Any] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param str id: Unique identifier of TargetResponderRecipe that can't be changed after creation.
        :param Sequence[str] inherited_by_compartments: List of inherited compartments
        :param str lifecyle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param int recipe_count: Total number of recipes attached to target
        :param str state: The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        :param Mapping[str, Any] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). System tags can be viewed by users, but can only be created by the system.  Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param Sequence['GetGuardTargetsTargetCollectionItemTargetDetailArgs'] target_details: Details specific to the target type.
        :param Sequence['GetGuardTargetsTargetCollectionItemTargetDetectorRecipeArgs'] target_detector_recipes: List of detector recipes associated with target
        :param str target_resource_id: Resource ID which the target uses to monitor
        :param str target_resource_type: possible type of targets
        :param Sequence['GetGuardTargetsTargetCollectionItemTargetResponderRecipeArgs'] target_responder_recipes: List of responder recipes associated with target
        :param str time_created: The date and time the target was created. Format defined by RFC3339.
        :param str time_updated: The date and time the target was updated. Format defined by RFC3339.
        """
        GetGuardTargetsTargetCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            inherited_by_compartments=inherited_by_compartments,
            lifecyle_details=lifecyle_details,
            recipe_count=recipe_count,
            state=state,
            system_tags=system_tags,
            target_details=target_details,
            target_detector_recipes=target_detector_recipes,
            target_resource_id=target_resource_id,
            target_resource_type=target_resource_type,
            target_responder_recipes=target_responder_recipes,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             defined_tags: Mapping[str, Any],
             description: str,
             display_name: str,
             freeform_tags: Mapping[str, Any],
             id: str,
             inherited_by_compartments: Sequence[str],
             lifecyle_details: str,
             recipe_count: int,
             state: str,
             system_tags: Mapping[str, Any],
             target_details: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetailResult'],
             target_detector_recipes: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeResult'],
             target_resource_id: str,
             target_resource_type: str,
             target_responder_recipes: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetResponderRecipeResult'],
             time_created: str,
             time_updated: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if 'inheritedByCompartments' in kwargs:
            inherited_by_compartments = kwargs['inheritedByCompartments']
        if 'lifecyleDetails' in kwargs:
            lifecyle_details = kwargs['lifecyleDetails']
        if 'recipeCount' in kwargs:
            recipe_count = kwargs['recipeCount']
        if 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if 'targetDetails' in kwargs:
            target_details = kwargs['targetDetails']
        if 'targetDetectorRecipes' in kwargs:
            target_detector_recipes = kwargs['targetDetectorRecipes']
        if 'targetResourceId' in kwargs:
            target_resource_id = kwargs['targetResourceId']
        if 'targetResourceType' in kwargs:
            target_resource_type = kwargs['targetResourceType']
        if 'targetResponderRecipes' in kwargs:
            target_responder_recipes = kwargs['targetResponderRecipes']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("inherited_by_compartments", inherited_by_compartments)
        _setter("lifecyle_details", lifecyle_details)
        _setter("recipe_count", recipe_count)
        _setter("state", state)
        _setter("system_tags", system_tags)
        _setter("target_details", target_details)
        _setter("target_detector_recipes", target_detector_recipes)
        _setter("target_resource_id", target_resource_id)
        _setter("target_resource_type", target_resource_type)
        _setter("target_responder_recipes", target_responder_recipes)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        ResponderRule description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of TargetResponderRecipe that can't be changed after creation.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="inheritedByCompartments")
    def inherited_by_compartments(self) -> Sequence[str]:
        """
        List of inherited compartments
        """
        return pulumi.get(self, "inherited_by_compartments")

    @property
    @pulumi.getter(name="lifecyleDetails")
    def lifecyle_details(self) -> str:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecyle_details")

    @property
    @pulumi.getter(name="recipeCount")
    def recipe_count(self) -> int:
        """
        Total number of recipes attached to target
        """
        return pulumi.get(self, "recipe_count")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). System tags can be viewed by users, but can only be created by the system.  Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="targetDetails")
    def target_details(self) -> Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetailResult']:
        """
        Details specific to the target type.
        """
        return pulumi.get(self, "target_details")

    @property
    @pulumi.getter(name="targetDetectorRecipes")
    def target_detector_recipes(self) -> Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeResult']:
        """
        List of detector recipes associated with target
        """
        return pulumi.get(self, "target_detector_recipes")

    @property
    @pulumi.getter(name="targetResourceId")
    def target_resource_id(self) -> str:
        """
        Resource ID which the target uses to monitor
        """
        return pulumi.get(self, "target_resource_id")

    @property
    @pulumi.getter(name="targetResourceType")
    def target_resource_type(self) -> str:
        """
        possible type of targets
        """
        return pulumi.get(self, "target_resource_type")

    @property
    @pulumi.getter(name="targetResponderRecipes")
    def target_responder_recipes(self) -> Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetResponderRecipeResult']:
        """
        List of responder recipes associated with target
        """
        return pulumi.get(self, "target_responder_recipes")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the target was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetGuardTargetsTargetCollectionItemTargetDetailResult(dict):
    def __init__(__self__, *,
                 security_zone_display_name: str,
                 security_zone_id: str,
                 target_resource_type: str,
                 target_security_zone_recipes: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetailTargetSecurityZoneRecipeResult']):
        """
        :param str security_zone_display_name: The name of the security zone to associate this compartment with.
        :param str security_zone_id: The OCID of the security zone to associate this compartment with.
        :param str target_resource_type: possible type of targets
        :param Sequence['GetGuardTargetsTargetCollectionItemTargetDetailTargetSecurityZoneRecipeArgs'] target_security_zone_recipes: The list of security zone recipes to associate this compartment with.
        """
        GetGuardTargetsTargetCollectionItemTargetDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            security_zone_display_name=security_zone_display_name,
            security_zone_id=security_zone_id,
            target_resource_type=target_resource_type,
            target_security_zone_recipes=target_security_zone_recipes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             security_zone_display_name: str,
             security_zone_id: str,
             target_resource_type: str,
             target_security_zone_recipes: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetailTargetSecurityZoneRecipeResult'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'securityZoneDisplayName' in kwargs:
            security_zone_display_name = kwargs['securityZoneDisplayName']
        if 'securityZoneId' in kwargs:
            security_zone_id = kwargs['securityZoneId']
        if 'targetResourceType' in kwargs:
            target_resource_type = kwargs['targetResourceType']
        if 'targetSecurityZoneRecipes' in kwargs:
            target_security_zone_recipes = kwargs['targetSecurityZoneRecipes']

        _setter("security_zone_display_name", security_zone_display_name)
        _setter("security_zone_id", security_zone_id)
        _setter("target_resource_type", target_resource_type)
        _setter("target_security_zone_recipes", target_security_zone_recipes)

    @property
    @pulumi.getter(name="securityZoneDisplayName")
    def security_zone_display_name(self) -> str:
        """
        The name of the security zone to associate this compartment with.
        """
        return pulumi.get(self, "security_zone_display_name")

    @property
    @pulumi.getter(name="securityZoneId")
    def security_zone_id(self) -> str:
        """
        The OCID of the security zone to associate this compartment with.
        """
        return pulumi.get(self, "security_zone_id")

    @property
    @pulumi.getter(name="targetResourceType")
    def target_resource_type(self) -> str:
        """
        possible type of targets
        """
        return pulumi.get(self, "target_resource_type")

    @property
    @pulumi.getter(name="targetSecurityZoneRecipes")
    def target_security_zone_recipes(self) -> Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetailTargetSecurityZoneRecipeResult']:
        """
        The list of security zone recipes to associate this compartment with.
        """
        return pulumi.get(self, "target_security_zone_recipes")


@pulumi.output_type
class GetGuardTargetsTargetCollectionItemTargetDetailTargetSecurityZoneRecipeResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 lifecycle_details: str,
                 owner: str,
                 security_policies: Sequence[str],
                 state: str,
                 system_tags: Mapping[str, Any],
                 time_created: str,
                 time_updated: str):
        """
        :param str compartment_id: The ID of the compartment in which to list resources.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param str description: ResponderRule description.
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param Mapping[str, Any] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param str id: Unique identifier of TargetResponderRecipe that can't be changed after creation.
        :param str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param str owner: Owner of ResponderRecipe
        :param Sequence[str] security_policies: The list of `SecurityPolicy` ids that are included in the recipe
        :param str state: The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        :param Mapping[str, Any] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). System tags can be viewed by users, but can only be created by the system.  Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param str time_created: The date and time the target was created. Format defined by RFC3339.
        :param str time_updated: The date and time the target was updated. Format defined by RFC3339.
        """
        GetGuardTargetsTargetCollectionItemTargetDetailTargetSecurityZoneRecipeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            lifecycle_details=lifecycle_details,
            owner=owner,
            security_policies=security_policies,
            state=state,
            system_tags=system_tags,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             defined_tags: Mapping[str, Any],
             description: str,
             display_name: str,
             freeform_tags: Mapping[str, Any],
             id: str,
             lifecycle_details: str,
             owner: str,
             security_policies: Sequence[str],
             state: str,
             system_tags: Mapping[str, Any],
             time_created: str,
             time_updated: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if 'securityPolicies' in kwargs:
            security_policies = kwargs['securityPolicies']
        if 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("owner", owner)
        _setter("security_policies", security_policies)
        _setter("state", state)
        _setter("system_tags", system_tags)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        ResponderRule description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of TargetResponderRecipe that can't be changed after creation.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def owner(self) -> str:
        """
        Owner of ResponderRecipe
        """
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter(name="securityPolicies")
    def security_policies(self) -> Sequence[str]:
        """
        The list of `SecurityPolicy` ids that are included in the recipe
        """
        return pulumi.get(self, "security_policies")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). System tags can be viewed by users, but can only be created by the system.  Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the target was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetGuardTargetsTargetCollectionItemTargetDetectorRecipeResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 description: str,
                 detector: str,
                 detector_recipe_id: str,
                 detector_rules: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleResult'],
                 display_name: str,
                 effective_detector_rules: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleResult'],
                 id: str,
                 owner: str,
                 state: str,
                 time_created: str,
                 time_updated: str):
        """
        :param str compartment_id: The ID of the compartment in which to list resources.
        :param str description: ResponderRule description.
        :param str detector: detector for the rule
        :param str detector_recipe_id: Unique identifier for Detector Recipe of which this is an extension
        :param Sequence['GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleArgs'] detector_rules: List of detector rules for the detector type for recipe - user input
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param Sequence['GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleArgs'] effective_detector_rules: List of effective detector rules for the detector type for recipe after applying defaults
        :param str id: Unique identifier of TargetResponderRecipe that can't be changed after creation.
        :param str owner: Owner of ResponderRecipe
        :param str state: The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        :param str time_created: The date and time the target was created. Format defined by RFC3339.
        :param str time_updated: The date and time the target was updated. Format defined by RFC3339.
        """
        GetGuardTargetsTargetCollectionItemTargetDetectorRecipeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            description=description,
            detector=detector,
            detector_recipe_id=detector_recipe_id,
            detector_rules=detector_rules,
            display_name=display_name,
            effective_detector_rules=effective_detector_rules,
            id=id,
            owner=owner,
            state=state,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             description: str,
             detector: str,
             detector_recipe_id: str,
             detector_rules: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleResult'],
             display_name: str,
             effective_detector_rules: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleResult'],
             id: str,
             owner: str,
             state: str,
             time_created: str,
             time_updated: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if 'detectorRecipeId' in kwargs:
            detector_recipe_id = kwargs['detectorRecipeId']
        if 'detectorRules' in kwargs:
            detector_rules = kwargs['detectorRules']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'effectiveDetectorRules' in kwargs:
            effective_detector_rules = kwargs['effectiveDetectorRules']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("compartment_id", compartment_id)
        _setter("description", description)
        _setter("detector", detector)
        _setter("detector_recipe_id", detector_recipe_id)
        _setter("detector_rules", detector_rules)
        _setter("display_name", display_name)
        _setter("effective_detector_rules", effective_detector_rules)
        _setter("id", id)
        _setter("owner", owner)
        _setter("state", state)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        ResponderRule description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def detector(self) -> str:
        """
        detector for the rule
        """
        return pulumi.get(self, "detector")

    @property
    @pulumi.getter(name="detectorRecipeId")
    def detector_recipe_id(self) -> str:
        """
        Unique identifier for Detector Recipe of which this is an extension
        """
        return pulumi.get(self, "detector_recipe_id")

    @property
    @pulumi.getter(name="detectorRules")
    def detector_rules(self) -> Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleResult']:
        """
        List of detector rules for the detector type for recipe - user input
        """
        return pulumi.get(self, "detector_rules")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="effectiveDetectorRules")
    def effective_detector_rules(self) -> Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleResult']:
        """
        List of effective detector rules for the detector type for recipe after applying defaults
        """
        return pulumi.get(self, "effective_detector_rules")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of TargetResponderRecipe that can't be changed after creation.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def owner(self) -> str:
        """
        Owner of ResponderRecipe
        """
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the target was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleResult(dict):
    def __init__(__self__, *,
                 data_source_id: str,
                 description: str,
                 details: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleDetailResult'],
                 detector: str,
                 detector_rule_id: str,
                 display_name: str,
                 entities_mappings: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleEntitiesMappingResult'],
                 lifecycle_details: str,
                 managed_list_types: Sequence[str],
                 recommendation: str,
                 resource_type: str,
                 service_type: str,
                 state: str,
                 time_created: str,
                 time_updated: str):
        """
        :param str data_source_id: The id of the attached DataSource.
        :param str description: ResponderRule description.
        :param Sequence['GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleDetailArgs'] details: Details of ResponderRule.
        :param str detector: detector for the rule
        :param str detector_rule_id: The unique identifier of the detector rule.
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param Sequence['GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleEntitiesMappingArgs'] entities_mappings: Data Source entities mapping for a Detector Rule
        :param str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param Sequence[str] managed_list_types: List of cloudguard managed list types related to this rule
        :param str recommendation: Recommendation for TargetDetectorRecipeDetectorRule
        :param str resource_type: resource type of the configuration to which the rule is applied
        :param str service_type: service type of the configuration to which the rule is applied
        :param str state: The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        :param str time_created: The date and time the target was created. Format defined by RFC3339.
        :param str time_updated: The date and time the target was updated. Format defined by RFC3339.
        """
        GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source_id=data_source_id,
            description=description,
            details=details,
            detector=detector,
            detector_rule_id=detector_rule_id,
            display_name=display_name,
            entities_mappings=entities_mappings,
            lifecycle_details=lifecycle_details,
            managed_list_types=managed_list_types,
            recommendation=recommendation,
            resource_type=resource_type,
            service_type=service_type,
            state=state,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source_id: str,
             description: str,
             details: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleDetailResult'],
             detector: str,
             detector_rule_id: str,
             display_name: str,
             entities_mappings: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleEntitiesMappingResult'],
             lifecycle_details: str,
             managed_list_types: Sequence[str],
             recommendation: str,
             resource_type: str,
             service_type: str,
             state: str,
             time_created: str,
             time_updated: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'dataSourceId' in kwargs:
            data_source_id = kwargs['dataSourceId']
        if 'detectorRuleId' in kwargs:
            detector_rule_id = kwargs['detectorRuleId']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'entitiesMappings' in kwargs:
            entities_mappings = kwargs['entitiesMappings']
        if 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if 'managedListTypes' in kwargs:
            managed_list_types = kwargs['managedListTypes']
        if 'resourceType' in kwargs:
            resource_type = kwargs['resourceType']
        if 'serviceType' in kwargs:
            service_type = kwargs['serviceType']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("data_source_id", data_source_id)
        _setter("description", description)
        _setter("details", details)
        _setter("detector", detector)
        _setter("detector_rule_id", detector_rule_id)
        _setter("display_name", display_name)
        _setter("entities_mappings", entities_mappings)
        _setter("lifecycle_details", lifecycle_details)
        _setter("managed_list_types", managed_list_types)
        _setter("recommendation", recommendation)
        _setter("resource_type", resource_type)
        _setter("service_type", service_type)
        _setter("state", state)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="dataSourceId")
    def data_source_id(self) -> str:
        """
        The id of the attached DataSource.
        """
        return pulumi.get(self, "data_source_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        ResponderRule description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def details(self) -> Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleDetailResult']:
        """
        Details of ResponderRule.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def detector(self) -> str:
        """
        detector for the rule
        """
        return pulumi.get(self, "detector")

    @property
    @pulumi.getter(name="detectorRuleId")
    def detector_rule_id(self) -> str:
        """
        The unique identifier of the detector rule.
        """
        return pulumi.get(self, "detector_rule_id")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="entitiesMappings")
    def entities_mappings(self) -> Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleEntitiesMappingResult']:
        """
        Data Source entities mapping for a Detector Rule
        """
        return pulumi.get(self, "entities_mappings")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="managedListTypes")
    def managed_list_types(self) -> Sequence[str]:
        """
        List of cloudguard managed list types related to this rule
        """
        return pulumi.get(self, "managed_list_types")

    @property
    @pulumi.getter
    def recommendation(self) -> str:
        """
        Recommendation for TargetDetectorRecipeDetectorRule
        """
        return pulumi.get(self, "recommendation")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> str:
        """
        resource type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> str:
        """
        service type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "service_type")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the target was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleDetailResult(dict):
    def __init__(__self__, *,
                 condition_groups: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleDetailConditionGroupResult'],
                 configurations: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleDetailConfigurationResult'],
                 is_configuration_allowed: bool,
                 is_enabled: bool,
                 labels: Sequence[str],
                 risk_level: str):
        """
        :param Sequence['GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleDetailConditionGroupArgs'] condition_groups: Condition group corresponding to each compartment
        :param Sequence['GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleDetailConfigurationArgs'] configurations: ResponderRule configurations
        :param bool is_configuration_allowed: configuration allowed or not
        :param bool is_enabled: Identifies state for ResponderRule
        :param Sequence[str] labels: user defined labels for a detector rule
        :param str risk_level: The Risk Level
        """
        GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition_groups=condition_groups,
            configurations=configurations,
            is_configuration_allowed=is_configuration_allowed,
            is_enabled=is_enabled,
            labels=labels,
            risk_level=risk_level,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition_groups: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleDetailConditionGroupResult'],
             configurations: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleDetailConfigurationResult'],
             is_configuration_allowed: bool,
             is_enabled: bool,
             labels: Sequence[str],
             risk_level: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'conditionGroups' in kwargs:
            condition_groups = kwargs['conditionGroups']
        if 'isConfigurationAllowed' in kwargs:
            is_configuration_allowed = kwargs['isConfigurationAllowed']
        if 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']
        if 'riskLevel' in kwargs:
            risk_level = kwargs['riskLevel']

        _setter("condition_groups", condition_groups)
        _setter("configurations", configurations)
        _setter("is_configuration_allowed", is_configuration_allowed)
        _setter("is_enabled", is_enabled)
        _setter("labels", labels)
        _setter("risk_level", risk_level)

    @property
    @pulumi.getter(name="conditionGroups")
    def condition_groups(self) -> Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleDetailConditionGroupResult']:
        """
        Condition group corresponding to each compartment
        """
        return pulumi.get(self, "condition_groups")

    @property
    @pulumi.getter
    def configurations(self) -> Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleDetailConfigurationResult']:
        """
        ResponderRule configurations
        """
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter(name="isConfigurationAllowed")
    def is_configuration_allowed(self) -> bool:
        """
        configuration allowed or not
        """
        return pulumi.get(self, "is_configuration_allowed")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Identifies state for ResponderRule
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def labels(self) -> Sequence[str]:
        """
        user defined labels for a detector rule
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> str:
        """
        The Risk Level
        """
        return pulumi.get(self, "risk_level")


@pulumi.output_type
class GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleDetailConditionGroupResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 condition: str):
        """
        :param str compartment_id: The ID of the compartment in which to list resources.
        :param str condition: Base condition object
        """
        GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleDetailConditionGroupResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            condition=condition,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             condition: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']

        _setter("compartment_id", compartment_id)
        _setter("condition", condition)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Base condition object
        """
        return pulumi.get(self, "condition")


@pulumi.output_type
class GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleDetailConfigurationResult(dict):
    def __init__(__self__, *,
                 config_key: str,
                 data_type: str,
                 name: str,
                 value: str,
                 values: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleDetailConfigurationValueResult']):
        """
        :param str config_key: Unique name of the configuration
        :param str data_type: configuration data type
        :param str name: configuration name
        :param str value: configuration value
        :param Sequence['GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleDetailConfigurationValueArgs'] values: List of configuration values
        """
        GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleDetailConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_key=config_key,
            data_type=data_type,
            name=name,
            value=value,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_key: str,
             data_type: str,
             name: str,
             value: str,
             values: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleDetailConfigurationValueResult'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'configKey' in kwargs:
            config_key = kwargs['configKey']
        if 'dataType' in kwargs:
            data_type = kwargs['dataType']

        _setter("config_key", config_key)
        _setter("data_type", data_type)
        _setter("name", name)
        _setter("value", value)
        _setter("values", values)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> str:
        """
        Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> str:
        """
        configuration data type
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        configuration name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        configuration value
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleDetailConfigurationValueResult']:
        """
        List of configuration values
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleDetailConfigurationValueResult(dict):
    def __init__(__self__, *,
                 list_type: str,
                 managed_list_type: str,
                 value: str):
        """
        :param str list_type: configuration list item type, either CUSTOM or MANAGED
        :param str managed_list_type: type of the managed list
        :param str value: configuration value
        """
        GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleDetailConfigurationValueResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            list_type=list_type,
            managed_list_type=managed_list_type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             list_type: str,
             managed_list_type: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'listType' in kwargs:
            list_type = kwargs['listType']
        if 'managedListType' in kwargs:
            managed_list_type = kwargs['managedListType']

        _setter("list_type", list_type)
        _setter("managed_list_type", managed_list_type)
        _setter("value", value)

    @property
    @pulumi.getter(name="listType")
    def list_type(self) -> str:
        """
        configuration list item type, either CUSTOM or MANAGED
        """
        return pulumi.get(self, "list_type")

    @property
    @pulumi.getter(name="managedListType")
    def managed_list_type(self) -> str:
        """
        type of the managed list
        """
        return pulumi.get(self, "managed_list_type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        configuration value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleEntitiesMappingResult(dict):
    def __init__(__self__, *,
                 display_name: str,
                 entity_type: str,
                 query_field: str):
        """
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param str entity_type: Possible type of entity
        :param str query_field: The entity value mapped to a data source query
        """
        GetGuardTargetsTargetCollectionItemTargetDetectorRecipeDetectorRuleEntitiesMappingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            entity_type=entity_type,
            query_field=query_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: str,
             entity_type: str,
             query_field: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'entityType' in kwargs:
            entity_type = kwargs['entityType']
        if 'queryField' in kwargs:
            query_field = kwargs['queryField']

        _setter("display_name", display_name)
        _setter("entity_type", entity_type)
        _setter("query_field", query_field)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Possible type of entity
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="queryField")
    def query_field(self) -> str:
        """
        The entity value mapped to a data source query
        """
        return pulumi.get(self, "query_field")


@pulumi.output_type
class GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleResult(dict):
    def __init__(__self__, *,
                 data_source_id: str,
                 description: str,
                 details: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleDetailResult'],
                 detector: str,
                 detector_rule_id: str,
                 display_name: str,
                 entities_mappings: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleEntitiesMappingResult'],
                 lifecycle_details: str,
                 managed_list_types: Sequence[str],
                 recommendation: str,
                 resource_type: str,
                 service_type: str,
                 state: str,
                 time_created: str,
                 time_updated: str):
        """
        :param str data_source_id: The id of the attached DataSource.
        :param str description: ResponderRule description.
        :param Sequence['GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleDetailArgs'] details: Details of ResponderRule.
        :param str detector: detector for the rule
        :param str detector_rule_id: The unique identifier of the detector rule.
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param Sequence['GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleEntitiesMappingArgs'] entities_mappings: Data Source entities mapping for a Detector Rule
        :param str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param Sequence[str] managed_list_types: List of cloudguard managed list types related to this rule
        :param str recommendation: Recommendation for TargetDetectorRecipeDetectorRule
        :param str resource_type: resource type of the configuration to which the rule is applied
        :param str service_type: service type of the configuration to which the rule is applied
        :param str state: The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        :param str time_created: The date and time the target was created. Format defined by RFC3339.
        :param str time_updated: The date and time the target was updated. Format defined by RFC3339.
        """
        GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source_id=data_source_id,
            description=description,
            details=details,
            detector=detector,
            detector_rule_id=detector_rule_id,
            display_name=display_name,
            entities_mappings=entities_mappings,
            lifecycle_details=lifecycle_details,
            managed_list_types=managed_list_types,
            recommendation=recommendation,
            resource_type=resource_type,
            service_type=service_type,
            state=state,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source_id: str,
             description: str,
             details: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleDetailResult'],
             detector: str,
             detector_rule_id: str,
             display_name: str,
             entities_mappings: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleEntitiesMappingResult'],
             lifecycle_details: str,
             managed_list_types: Sequence[str],
             recommendation: str,
             resource_type: str,
             service_type: str,
             state: str,
             time_created: str,
             time_updated: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'dataSourceId' in kwargs:
            data_source_id = kwargs['dataSourceId']
        if 'detectorRuleId' in kwargs:
            detector_rule_id = kwargs['detectorRuleId']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'entitiesMappings' in kwargs:
            entities_mappings = kwargs['entitiesMappings']
        if 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if 'managedListTypes' in kwargs:
            managed_list_types = kwargs['managedListTypes']
        if 'resourceType' in kwargs:
            resource_type = kwargs['resourceType']
        if 'serviceType' in kwargs:
            service_type = kwargs['serviceType']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("data_source_id", data_source_id)
        _setter("description", description)
        _setter("details", details)
        _setter("detector", detector)
        _setter("detector_rule_id", detector_rule_id)
        _setter("display_name", display_name)
        _setter("entities_mappings", entities_mappings)
        _setter("lifecycle_details", lifecycle_details)
        _setter("managed_list_types", managed_list_types)
        _setter("recommendation", recommendation)
        _setter("resource_type", resource_type)
        _setter("service_type", service_type)
        _setter("state", state)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="dataSourceId")
    def data_source_id(self) -> str:
        """
        The id of the attached DataSource.
        """
        return pulumi.get(self, "data_source_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        ResponderRule description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def details(self) -> Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleDetailResult']:
        """
        Details of ResponderRule.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def detector(self) -> str:
        """
        detector for the rule
        """
        return pulumi.get(self, "detector")

    @property
    @pulumi.getter(name="detectorRuleId")
    def detector_rule_id(self) -> str:
        """
        The unique identifier of the detector rule.
        """
        return pulumi.get(self, "detector_rule_id")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="entitiesMappings")
    def entities_mappings(self) -> Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleEntitiesMappingResult']:
        """
        Data Source entities mapping for a Detector Rule
        """
        return pulumi.get(self, "entities_mappings")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="managedListTypes")
    def managed_list_types(self) -> Sequence[str]:
        """
        List of cloudguard managed list types related to this rule
        """
        return pulumi.get(self, "managed_list_types")

    @property
    @pulumi.getter
    def recommendation(self) -> str:
        """
        Recommendation for TargetDetectorRecipeDetectorRule
        """
        return pulumi.get(self, "recommendation")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> str:
        """
        resource type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> str:
        """
        service type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "service_type")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the target was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleDetailResult(dict):
    def __init__(__self__, *,
                 condition_groups: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroupResult'],
                 configurations: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationResult'],
                 is_configuration_allowed: bool,
                 is_enabled: bool,
                 labels: Sequence[str],
                 risk_level: str):
        """
        :param Sequence['GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroupArgs'] condition_groups: Condition group corresponding to each compartment
        :param Sequence['GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationArgs'] configurations: ResponderRule configurations
        :param bool is_configuration_allowed: configuration allowed or not
        :param bool is_enabled: Identifies state for ResponderRule
        :param Sequence[str] labels: user defined labels for a detector rule
        :param str risk_level: The Risk Level
        """
        GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition_groups=condition_groups,
            configurations=configurations,
            is_configuration_allowed=is_configuration_allowed,
            is_enabled=is_enabled,
            labels=labels,
            risk_level=risk_level,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition_groups: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroupResult'],
             configurations: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationResult'],
             is_configuration_allowed: bool,
             is_enabled: bool,
             labels: Sequence[str],
             risk_level: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'conditionGroups' in kwargs:
            condition_groups = kwargs['conditionGroups']
        if 'isConfigurationAllowed' in kwargs:
            is_configuration_allowed = kwargs['isConfigurationAllowed']
        if 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']
        if 'riskLevel' in kwargs:
            risk_level = kwargs['riskLevel']

        _setter("condition_groups", condition_groups)
        _setter("configurations", configurations)
        _setter("is_configuration_allowed", is_configuration_allowed)
        _setter("is_enabled", is_enabled)
        _setter("labels", labels)
        _setter("risk_level", risk_level)

    @property
    @pulumi.getter(name="conditionGroups")
    def condition_groups(self) -> Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroupResult']:
        """
        Condition group corresponding to each compartment
        """
        return pulumi.get(self, "condition_groups")

    @property
    @pulumi.getter
    def configurations(self) -> Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationResult']:
        """
        ResponderRule configurations
        """
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter(name="isConfigurationAllowed")
    def is_configuration_allowed(self) -> bool:
        """
        configuration allowed or not
        """
        return pulumi.get(self, "is_configuration_allowed")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Identifies state for ResponderRule
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def labels(self) -> Sequence[str]:
        """
        user defined labels for a detector rule
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> str:
        """
        The Risk Level
        """
        return pulumi.get(self, "risk_level")


@pulumi.output_type
class GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroupResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 condition: str):
        """
        :param str compartment_id: The ID of the compartment in which to list resources.
        :param str condition: Base condition object
        """
        GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleDetailConditionGroupResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            condition=condition,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             condition: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']

        _setter("compartment_id", compartment_id)
        _setter("condition", condition)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Base condition object
        """
        return pulumi.get(self, "condition")


@pulumi.output_type
class GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationResult(dict):
    def __init__(__self__, *,
                 config_key: str,
                 data_type: str,
                 name: str,
                 value: str,
                 values: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueResult']):
        """
        :param str config_key: Unique name of the configuration
        :param str data_type: configuration data type
        :param str name: configuration name
        :param str value: configuration value
        :param Sequence['GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueArgs'] values: List of configuration values
        """
        GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_key=config_key,
            data_type=data_type,
            name=name,
            value=value,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_key: str,
             data_type: str,
             name: str,
             value: str,
             values: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueResult'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'configKey' in kwargs:
            config_key = kwargs['configKey']
        if 'dataType' in kwargs:
            data_type = kwargs['dataType']

        _setter("config_key", config_key)
        _setter("data_type", data_type)
        _setter("name", name)
        _setter("value", value)
        _setter("values", values)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> str:
        """
        Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> str:
        """
        configuration data type
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        configuration name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        configuration value
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueResult']:
        """
        List of configuration values
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueResult(dict):
    def __init__(__self__, *,
                 list_type: str,
                 managed_list_type: str,
                 value: str):
        """
        :param str list_type: configuration list item type, either CUSTOM or MANAGED
        :param str managed_list_type: type of the managed list
        :param str value: configuration value
        """
        GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleDetailConfigurationValueResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            list_type=list_type,
            managed_list_type=managed_list_type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             list_type: str,
             managed_list_type: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'listType' in kwargs:
            list_type = kwargs['listType']
        if 'managedListType' in kwargs:
            managed_list_type = kwargs['managedListType']

        _setter("list_type", list_type)
        _setter("managed_list_type", managed_list_type)
        _setter("value", value)

    @property
    @pulumi.getter(name="listType")
    def list_type(self) -> str:
        """
        configuration list item type, either CUSTOM or MANAGED
        """
        return pulumi.get(self, "list_type")

    @property
    @pulumi.getter(name="managedListType")
    def managed_list_type(self) -> str:
        """
        type of the managed list
        """
        return pulumi.get(self, "managed_list_type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        configuration value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleEntitiesMappingResult(dict):
    def __init__(__self__, *,
                 display_name: str,
                 entity_type: str,
                 query_field: str):
        """
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param str entity_type: Possible type of entity
        :param str query_field: The entity value mapped to a data source query
        """
        GetGuardTargetsTargetCollectionItemTargetDetectorRecipeEffectiveDetectorRuleEntitiesMappingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            entity_type=entity_type,
            query_field=query_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: str,
             entity_type: str,
             query_field: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'entityType' in kwargs:
            entity_type = kwargs['entityType']
        if 'queryField' in kwargs:
            query_field = kwargs['queryField']

        _setter("display_name", display_name)
        _setter("entity_type", entity_type)
        _setter("query_field", query_field)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Possible type of entity
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="queryField")
    def query_field(self) -> str:
        """
        The entity value mapped to a data source query
        """
        return pulumi.get(self, "query_field")


@pulumi.output_type
class GetGuardTargetsTargetCollectionItemTargetResponderRecipeResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 description: str,
                 display_name: str,
                 effective_responder_rules: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetResponderRecipeEffectiveResponderRuleResult'],
                 id: str,
                 owner: str,
                 responder_recipe_id: str,
                 responder_rules: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetResponderRecipeResponderRuleResult'],
                 time_created: str,
                 time_updated: str):
        """
        :param str compartment_id: The ID of the compartment in which to list resources.
        :param str description: ResponderRule description.
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param Sequence['GetGuardTargetsTargetCollectionItemTargetResponderRecipeEffectiveResponderRuleArgs'] effective_responder_rules: List of responder rules associated with the recipe after applying all defaults
        :param str id: Unique identifier of TargetResponderRecipe that can't be changed after creation.
        :param str owner: Owner of ResponderRecipe
        :param str responder_recipe_id: Unique identifier for Responder Recipe of which this is an extension.
        :param Sequence['GetGuardTargetsTargetCollectionItemTargetResponderRecipeResponderRuleArgs'] responder_rules: List of responder rules associated with the recipe - user input
        :param str time_created: The date and time the target was created. Format defined by RFC3339.
        :param str time_updated: The date and time the target was updated. Format defined by RFC3339.
        """
        GetGuardTargetsTargetCollectionItemTargetResponderRecipeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            description=description,
            display_name=display_name,
            effective_responder_rules=effective_responder_rules,
            id=id,
            owner=owner,
            responder_recipe_id=responder_recipe_id,
            responder_rules=responder_rules,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             description: str,
             display_name: str,
             effective_responder_rules: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetResponderRecipeEffectiveResponderRuleResult'],
             id: str,
             owner: str,
             responder_recipe_id: str,
             responder_rules: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetResponderRecipeResponderRuleResult'],
             time_created: str,
             time_updated: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'effectiveResponderRules' in kwargs:
            effective_responder_rules = kwargs['effectiveResponderRules']
        if 'responderRecipeId' in kwargs:
            responder_recipe_id = kwargs['responderRecipeId']
        if 'responderRules' in kwargs:
            responder_rules = kwargs['responderRules']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("compartment_id", compartment_id)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("effective_responder_rules", effective_responder_rules)
        _setter("id", id)
        _setter("owner", owner)
        _setter("responder_recipe_id", responder_recipe_id)
        _setter("responder_rules", responder_rules)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        ResponderRule description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="effectiveResponderRules")
    def effective_responder_rules(self) -> Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetResponderRecipeEffectiveResponderRuleResult']:
        """
        List of responder rules associated with the recipe after applying all defaults
        """
        return pulumi.get(self, "effective_responder_rules")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of TargetResponderRecipe that can't be changed after creation.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def owner(self) -> str:
        """
        Owner of ResponderRecipe
        """
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter(name="responderRecipeId")
    def responder_recipe_id(self) -> str:
        """
        Unique identifier for Responder Recipe of which this is an extension.
        """
        return pulumi.get(self, "responder_recipe_id")

    @property
    @pulumi.getter(name="responderRules")
    def responder_rules(self) -> Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetResponderRecipeResponderRuleResult']:
        """
        List of responder rules associated with the recipe - user input
        """
        return pulumi.get(self, "responder_rules")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the target was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetGuardTargetsTargetCollectionItemTargetResponderRecipeEffectiveResponderRuleResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 description: str,
                 details: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetResponderRecipeEffectiveResponderRuleDetailResult'],
                 display_name: str,
                 lifecycle_details: str,
                 policies: Sequence[str],
                 responder_rule_id: str,
                 state: str,
                 supported_modes: Sequence[str],
                 time_created: str,
                 time_updated: str,
                 type: str):
        """
        :param str compartment_id: The ID of the compartment in which to list resources.
        :param str description: ResponderRule description.
        :param Sequence['GetGuardTargetsTargetCollectionItemTargetResponderRecipeEffectiveResponderRuleDetailArgs'] details: Details of ResponderRule.
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param Sequence[str] policies: List of Policy
        :param str responder_rule_id: Unique ResponderRule identifier.
        :param str state: The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        :param Sequence[str] supported_modes: Supported Execution Modes
        :param str time_created: The date and time the target was created. Format defined by RFC3339.
        :param str time_updated: The date and time the target was updated. Format defined by RFC3339.
        :param str type: Type of Responder
        """
        GetGuardTargetsTargetCollectionItemTargetResponderRecipeEffectiveResponderRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            description=description,
            details=details,
            display_name=display_name,
            lifecycle_details=lifecycle_details,
            policies=policies,
            responder_rule_id=responder_rule_id,
            state=state,
            supported_modes=supported_modes,
            time_created=time_created,
            time_updated=time_updated,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             description: str,
             details: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetResponderRecipeEffectiveResponderRuleDetailResult'],
             display_name: str,
             lifecycle_details: str,
             policies: Sequence[str],
             responder_rule_id: str,
             state: str,
             supported_modes: Sequence[str],
             time_created: str,
             time_updated: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if 'responderRuleId' in kwargs:
            responder_rule_id = kwargs['responderRuleId']
        if 'supportedModes' in kwargs:
            supported_modes = kwargs['supportedModes']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("compartment_id", compartment_id)
        _setter("description", description)
        _setter("details", details)
        _setter("display_name", display_name)
        _setter("lifecycle_details", lifecycle_details)
        _setter("policies", policies)
        _setter("responder_rule_id", responder_rule_id)
        _setter("state", state)
        _setter("supported_modes", supported_modes)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)
        _setter("type", type)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        ResponderRule description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def details(self) -> Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetResponderRecipeEffectiveResponderRuleDetailResult']:
        """
        Details of ResponderRule.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def policies(self) -> Sequence[str]:
        """
        List of Policy
        """
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="responderRuleId")
    def responder_rule_id(self) -> str:
        """
        Unique ResponderRule identifier.
        """
        return pulumi.get(self, "responder_rule_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="supportedModes")
    def supported_modes(self) -> Sequence[str]:
        """
        Supported Execution Modes
        """
        return pulumi.get(self, "supported_modes")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the target was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of Responder
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetGuardTargetsTargetCollectionItemTargetResponderRecipeEffectiveResponderRuleDetailResult(dict):
    def __init__(__self__, *,
                 condition: str,
                 configurations: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetResponderRecipeEffectiveResponderRuleDetailConfigurationResult'],
                 is_enabled: bool,
                 mode: str):
        """
        :param str condition: Base condition object
        :param Sequence['GetGuardTargetsTargetCollectionItemTargetResponderRecipeEffectiveResponderRuleDetailConfigurationArgs'] configurations: ResponderRule configurations
        :param bool is_enabled: Identifies state for ResponderRule
        :param str mode: Execution Mode for ResponderRule
        """
        GetGuardTargetsTargetCollectionItemTargetResponderRecipeEffectiveResponderRuleDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition=condition,
            configurations=configurations,
            is_enabled=is_enabled,
            mode=mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition: str,
             configurations: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetResponderRecipeEffectiveResponderRuleDetailConfigurationResult'],
             is_enabled: bool,
             mode: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']

        _setter("condition", condition)
        _setter("configurations", configurations)
        _setter("is_enabled", is_enabled)
        _setter("mode", mode)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Base condition object
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def configurations(self) -> Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetResponderRecipeEffectiveResponderRuleDetailConfigurationResult']:
        """
        ResponderRule configurations
        """
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Identifies state for ResponderRule
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Execution Mode for ResponderRule
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetGuardTargetsTargetCollectionItemTargetResponderRecipeEffectiveResponderRuleDetailConfigurationResult(dict):
    def __init__(__self__, *,
                 config_key: str,
                 name: str,
                 value: str):
        """
        :param str config_key: Unique name of the configuration
        :param str name: configuration name
        :param str value: configuration value
        """
        GetGuardTargetsTargetCollectionItemTargetResponderRecipeEffectiveResponderRuleDetailConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_key=config_key,
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_key: str,
             name: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'configKey' in kwargs:
            config_key = kwargs['configKey']

        _setter("config_key", config_key)
        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> str:
        """
        Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        configuration name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        configuration value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetGuardTargetsTargetCollectionItemTargetResponderRecipeResponderRuleResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 description: str,
                 details: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetResponderRecipeResponderRuleDetailResult'],
                 display_name: str,
                 lifecycle_details: str,
                 policies: Sequence[str],
                 responder_rule_id: str,
                 state: str,
                 supported_modes: Sequence[str],
                 time_created: str,
                 time_updated: str,
                 type: str):
        """
        :param str compartment_id: The ID of the compartment in which to list resources.
        :param str description: ResponderRule description.
        :param Sequence['GetGuardTargetsTargetCollectionItemTargetResponderRecipeResponderRuleDetailArgs'] details: Details of ResponderRule.
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param Sequence[str] policies: List of Policy
        :param str responder_rule_id: Unique ResponderRule identifier.
        :param str state: The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        :param Sequence[str] supported_modes: Supported Execution Modes
        :param str time_created: The date and time the target was created. Format defined by RFC3339.
        :param str time_updated: The date and time the target was updated. Format defined by RFC3339.
        :param str type: Type of Responder
        """
        GetGuardTargetsTargetCollectionItemTargetResponderRecipeResponderRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            description=description,
            details=details,
            display_name=display_name,
            lifecycle_details=lifecycle_details,
            policies=policies,
            responder_rule_id=responder_rule_id,
            state=state,
            supported_modes=supported_modes,
            time_created=time_created,
            time_updated=time_updated,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             description: str,
             details: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetResponderRecipeResponderRuleDetailResult'],
             display_name: str,
             lifecycle_details: str,
             policies: Sequence[str],
             responder_rule_id: str,
             state: str,
             supported_modes: Sequence[str],
             time_created: str,
             time_updated: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if 'responderRuleId' in kwargs:
            responder_rule_id = kwargs['responderRuleId']
        if 'supportedModes' in kwargs:
            supported_modes = kwargs['supportedModes']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("compartment_id", compartment_id)
        _setter("description", description)
        _setter("details", details)
        _setter("display_name", display_name)
        _setter("lifecycle_details", lifecycle_details)
        _setter("policies", policies)
        _setter("responder_rule_id", responder_rule_id)
        _setter("state", state)
        _setter("supported_modes", supported_modes)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)
        _setter("type", type)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        ResponderRule description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def details(self) -> Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetResponderRecipeResponderRuleDetailResult']:
        """
        Details of ResponderRule.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def policies(self) -> Sequence[str]:
        """
        List of Policy
        """
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="responderRuleId")
    def responder_rule_id(self) -> str:
        """
        Unique ResponderRule identifier.
        """
        return pulumi.get(self, "responder_rule_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="supportedModes")
    def supported_modes(self) -> Sequence[str]:
        """
        Supported Execution Modes
        """
        return pulumi.get(self, "supported_modes")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the target was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of Responder
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetGuardTargetsTargetCollectionItemTargetResponderRecipeResponderRuleDetailResult(dict):
    def __init__(__self__, *,
                 condition: str,
                 configurations: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetResponderRecipeResponderRuleDetailConfigurationResult'],
                 is_enabled: bool,
                 mode: str):
        """
        :param str condition: Base condition object
        :param Sequence['GetGuardTargetsTargetCollectionItemTargetResponderRecipeResponderRuleDetailConfigurationArgs'] configurations: ResponderRule configurations
        :param bool is_enabled: Identifies state for ResponderRule
        :param str mode: Execution Mode for ResponderRule
        """
        GetGuardTargetsTargetCollectionItemTargetResponderRecipeResponderRuleDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition=condition,
            configurations=configurations,
            is_enabled=is_enabled,
            mode=mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition: str,
             configurations: Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetResponderRecipeResponderRuleDetailConfigurationResult'],
             is_enabled: bool,
             mode: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']

        _setter("condition", condition)
        _setter("configurations", configurations)
        _setter("is_enabled", is_enabled)
        _setter("mode", mode)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Base condition object
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def configurations(self) -> Sequence['outputs.GetGuardTargetsTargetCollectionItemTargetResponderRecipeResponderRuleDetailConfigurationResult']:
        """
        ResponderRule configurations
        """
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Identifies state for ResponderRule
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Execution Mode for ResponderRule
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetGuardTargetsTargetCollectionItemTargetResponderRecipeResponderRuleDetailConfigurationResult(dict):
    def __init__(__self__, *,
                 config_key: str,
                 name: str,
                 value: str):
        """
        :param str config_key: Unique name of the configuration
        :param str name: configuration name
        :param str value: configuration value
        """
        GetGuardTargetsTargetCollectionItemTargetResponderRecipeResponderRuleDetailConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_key=config_key,
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_key: str,
             name: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'configKey' in kwargs:
            config_key = kwargs['configKey']

        _setter("config_key", config_key)
        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> str:
        """
        Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        configuration name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        configuration value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetManagedListsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetManagedListsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetManagedListsManagedListCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetManagedListsManagedListCollectionItemResult']):
        GetManagedListsManagedListCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Sequence['outputs.GetManagedListsManagedListCollectionItemResult'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetManagedListsManagedListCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetManagedListsManagedListCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 feed_provider: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 is_editable: bool,
                 lifecyle_details: str,
                 list_items: Sequence[str],
                 list_type: str,
                 source_managed_list_id: str,
                 state: str,
                 system_tags: Mapping[str, Any],
                 time_created: str,
                 time_updated: str):
        """
        :param str compartment_id: The ID of the compartment in which to list resources.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param str description: ManagedList description.
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param str feed_provider: provider of the feed
        :param Mapping[str, Any] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param str id: Unique identifier that is immutable on creation
        :param bool is_editable: If this list is editable or not
        :param str lifecyle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param Sequence[str] list_items: List of ManagedListItem
        :param str list_type: The type of the ManagedList.
        :param str source_managed_list_id: OCID of the Source ManagedList
        :param str state: The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        :param Mapping[str, Any] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). System tags can be viewed by users, but can only be created by the system.  Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param str time_created: The date and time the managed list was created. Format defined by RFC3339.
        :param str time_updated: The date and time the managed list was updated. Format defined by RFC3339.
        """
        GetManagedListsManagedListCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            feed_provider=feed_provider,
            freeform_tags=freeform_tags,
            id=id,
            is_editable=is_editable,
            lifecyle_details=lifecyle_details,
            list_items=list_items,
            list_type=list_type,
            source_managed_list_id=source_managed_list_id,
            state=state,
            system_tags=system_tags,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             defined_tags: Mapping[str, Any],
             description: str,
             display_name: str,
             feed_provider: str,
             freeform_tags: Mapping[str, Any],
             id: str,
             is_editable: bool,
             lifecyle_details: str,
             list_items: Sequence[str],
             list_type: str,
             source_managed_list_id: str,
             state: str,
             system_tags: Mapping[str, Any],
             time_created: str,
             time_updated: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'feedProvider' in kwargs:
            feed_provider = kwargs['feedProvider']
        if 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if 'isEditable' in kwargs:
            is_editable = kwargs['isEditable']
        if 'lifecyleDetails' in kwargs:
            lifecyle_details = kwargs['lifecyleDetails']
        if 'listItems' in kwargs:
            list_items = kwargs['listItems']
        if 'listType' in kwargs:
            list_type = kwargs['listType']
        if 'sourceManagedListId' in kwargs:
            source_managed_list_id = kwargs['sourceManagedListId']
        if 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("feed_provider", feed_provider)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("is_editable", is_editable)
        _setter("lifecyle_details", lifecyle_details)
        _setter("list_items", list_items)
        _setter("list_type", list_type)
        _setter("source_managed_list_id", source_managed_list_id)
        _setter("state", state)
        _setter("system_tags", system_tags)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        ManagedList description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="feedProvider")
    def feed_provider(self) -> str:
        """
        provider of the feed
        """
        return pulumi.get(self, "feed_provider")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier that is immutable on creation
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isEditable")
    def is_editable(self) -> bool:
        """
        If this list is editable or not
        """
        return pulumi.get(self, "is_editable")

    @property
    @pulumi.getter(name="lifecyleDetails")
    def lifecyle_details(self) -> str:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecyle_details")

    @property
    @pulumi.getter(name="listItems")
    def list_items(self) -> Sequence[str]:
        """
        List of ManagedListItem
        """
        return pulumi.get(self, "list_items")

    @property
    @pulumi.getter(name="listType")
    def list_type(self) -> str:
        """
        The type of the ManagedList.
        """
        return pulumi.get(self, "list_type")

    @property
    @pulumi.getter(name="sourceManagedListId")
    def source_managed_list_id(self) -> str:
        """
        OCID of the Source ManagedList
        """
        return pulumi.get(self, "source_managed_list_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). System tags can be viewed by users, but can only be created by the system.  Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the managed list was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the managed list was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetProblemEntitiesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetProblemEntitiesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetProblemEntitiesProblemEntityCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetProblemEntitiesProblemEntityCollectionItemResult']):
        """
        :param Sequence['GetProblemEntitiesProblemEntityCollectionItemArgs'] items: List of problem entities summaries related to a data source.
        """
        GetProblemEntitiesProblemEntityCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Sequence['outputs.GetProblemEntitiesProblemEntityCollectionItemResult'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetProblemEntitiesProblemEntityCollectionItemResult']:
        """
        List of problem entities summaries related to a data source.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetProblemEntitiesProblemEntityCollectionItemResult(dict):
    def __init__(__self__, *,
                 entity_details: Sequence['outputs.GetProblemEntitiesProblemEntityCollectionItemEntityDetailResult'],
                 problem_id: str,
                 regions: Sequence[str],
                 result_url: str,
                 time_first_detected: str,
                 time_last_detected: str):
        """
        :param Sequence['GetProblemEntitiesProblemEntityCollectionItemEntityDetailArgs'] entity_details: List of event related to a DataSource
        :param str problem_id: OCId of the problem.
        :param Sequence[str] regions: Data source problem entities region
        :param str result_url: Log result query url for a data source query
        :param str time_first_detected: Data source problem entities first detected time
        :param str time_last_detected: Data source problem entities last detected time
        """
        GetProblemEntitiesProblemEntityCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            entity_details=entity_details,
            problem_id=problem_id,
            regions=regions,
            result_url=result_url,
            time_first_detected=time_first_detected,
            time_last_detected=time_last_detected,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             entity_details: Sequence['outputs.GetProblemEntitiesProblemEntityCollectionItemEntityDetailResult'],
             problem_id: str,
             regions: Sequence[str],
             result_url: str,
             time_first_detected: str,
             time_last_detected: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'entityDetails' in kwargs:
            entity_details = kwargs['entityDetails']
        if 'problemId' in kwargs:
            problem_id = kwargs['problemId']
        if 'resultUrl' in kwargs:
            result_url = kwargs['resultUrl']
        if 'timeFirstDetected' in kwargs:
            time_first_detected = kwargs['timeFirstDetected']
        if 'timeLastDetected' in kwargs:
            time_last_detected = kwargs['timeLastDetected']

        _setter("entity_details", entity_details)
        _setter("problem_id", problem_id)
        _setter("regions", regions)
        _setter("result_url", result_url)
        _setter("time_first_detected", time_first_detected)
        _setter("time_last_detected", time_last_detected)

    @property
    @pulumi.getter(name="entityDetails")
    def entity_details(self) -> Sequence['outputs.GetProblemEntitiesProblemEntityCollectionItemEntityDetailResult']:
        """
        List of event related to a DataSource
        """
        return pulumi.get(self, "entity_details")

    @property
    @pulumi.getter(name="problemId")
    def problem_id(self) -> str:
        """
        OCId of the problem.
        """
        return pulumi.get(self, "problem_id")

    @property
    @pulumi.getter
    def regions(self) -> Sequence[str]:
        """
        Data source problem entities region
        """
        return pulumi.get(self, "regions")

    @property
    @pulumi.getter(name="resultUrl")
    def result_url(self) -> str:
        """
        Log result query url for a data source query
        """
        return pulumi.get(self, "result_url")

    @property
    @pulumi.getter(name="timeFirstDetected")
    def time_first_detected(self) -> str:
        """
        Data source problem entities first detected time
        """
        return pulumi.get(self, "time_first_detected")

    @property
    @pulumi.getter(name="timeLastDetected")
    def time_last_detected(self) -> str:
        """
        Data source problem entities last detected time
        """
        return pulumi.get(self, "time_last_detected")


@pulumi.output_type
class GetProblemEntitiesProblemEntityCollectionItemEntityDetailResult(dict):
    def __init__(__self__, *,
                 display_name: str,
                 type: str,
                 value: str):
        """
        :param str display_name: The display name of entity
        :param str type: Type of entity
        :param str value: The entity value
        """
        GetProblemEntitiesProblemEntityCollectionItemEntityDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            type=type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: str,
             type: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']

        _setter("display_name", display_name)
        _setter("type", type)
        _setter("value", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The display name of entity
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of entity
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The entity value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetProblemEntityItemResult(dict):
    def __init__(__self__, *,
                 entity_details: Sequence['outputs.GetProblemEntityItemEntityDetailResult'],
                 problem_id: str,
                 regions: Sequence[str],
                 result_url: str,
                 time_first_detected: str,
                 time_last_detected: str):
        """
        :param Sequence['GetProblemEntityItemEntityDetailArgs'] entity_details: List of event related to a DataSource
        :param str problem_id: OCId of the problem.
        :param Sequence[str] regions: Data source problem entities region
        :param str result_url: Log result query url for a data source query
        :param str time_first_detected: Data source problem entities first detected time
        :param str time_last_detected: Data source problem entities last detected time
        """
        GetProblemEntityItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            entity_details=entity_details,
            problem_id=problem_id,
            regions=regions,
            result_url=result_url,
            time_first_detected=time_first_detected,
            time_last_detected=time_last_detected,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             entity_details: Sequence['outputs.GetProblemEntityItemEntityDetailResult'],
             problem_id: str,
             regions: Sequence[str],
             result_url: str,
             time_first_detected: str,
             time_last_detected: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'entityDetails' in kwargs:
            entity_details = kwargs['entityDetails']
        if 'problemId' in kwargs:
            problem_id = kwargs['problemId']
        if 'resultUrl' in kwargs:
            result_url = kwargs['resultUrl']
        if 'timeFirstDetected' in kwargs:
            time_first_detected = kwargs['timeFirstDetected']
        if 'timeLastDetected' in kwargs:
            time_last_detected = kwargs['timeLastDetected']

        _setter("entity_details", entity_details)
        _setter("problem_id", problem_id)
        _setter("regions", regions)
        _setter("result_url", result_url)
        _setter("time_first_detected", time_first_detected)
        _setter("time_last_detected", time_last_detected)

    @property
    @pulumi.getter(name="entityDetails")
    def entity_details(self) -> Sequence['outputs.GetProblemEntityItemEntityDetailResult']:
        """
        List of event related to a DataSource
        """
        return pulumi.get(self, "entity_details")

    @property
    @pulumi.getter(name="problemId")
    def problem_id(self) -> str:
        """
        OCId of the problem.
        """
        return pulumi.get(self, "problem_id")

    @property
    @pulumi.getter
    def regions(self) -> Sequence[str]:
        """
        Data source problem entities region
        """
        return pulumi.get(self, "regions")

    @property
    @pulumi.getter(name="resultUrl")
    def result_url(self) -> str:
        """
        Log result query url for a data source query
        """
        return pulumi.get(self, "result_url")

    @property
    @pulumi.getter(name="timeFirstDetected")
    def time_first_detected(self) -> str:
        """
        Data source problem entities first detected time
        """
        return pulumi.get(self, "time_first_detected")

    @property
    @pulumi.getter(name="timeLastDetected")
    def time_last_detected(self) -> str:
        """
        Data source problem entities last detected time
        """
        return pulumi.get(self, "time_last_detected")


@pulumi.output_type
class GetProblemEntityItemEntityDetailResult(dict):
    def __init__(__self__, *,
                 display_name: str,
                 type: str,
                 value: str):
        """
        :param str display_name: The display name of entity
        :param str type: Type of entity
        :param str value: The entity value
        """
        GetProblemEntityItemEntityDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            type=type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: str,
             type: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']

        _setter("display_name", display_name)
        _setter("type", type)
        _setter("value", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The display name of entity
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of entity
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The entity value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetResponderRecipeEffectiveResponderRuleResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 description: str,
                 details: Sequence['outputs.GetResponderRecipeEffectiveResponderRuleDetailResult'],
                 display_name: str,
                 lifecycle_details: str,
                 policies: Sequence[str],
                 responder_rule_id: str,
                 state: str,
                 supported_modes: Sequence[str],
                 time_created: str,
                 time_updated: str,
                 type: str):
        """
        :param str compartment_id: Compartment Identifier
        :param str description: ResponderRule description.
        :param Sequence['GetResponderRecipeEffectiveResponderRuleDetailArgs'] details: Details of ResponderRule.
        :param str display_name: ResponderRule display name.
        :param str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param Sequence[str] policies: List of Policy
        :param str responder_rule_id: Identifier for ResponderRule.
        :param str state: The current state of the Example.
        :param Sequence[str] supported_modes: Supported Execution Modes
        :param str time_created: The date and time the responder recipe was created. Format defined by RFC3339.
        :param str time_updated: The date and time the responder recipe was updated. Format defined by RFC3339.
        :param str type: Type of Responder
        """
        GetResponderRecipeEffectiveResponderRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            description=description,
            details=details,
            display_name=display_name,
            lifecycle_details=lifecycle_details,
            policies=policies,
            responder_rule_id=responder_rule_id,
            state=state,
            supported_modes=supported_modes,
            time_created=time_created,
            time_updated=time_updated,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             description: str,
             details: Sequence['outputs.GetResponderRecipeEffectiveResponderRuleDetailResult'],
             display_name: str,
             lifecycle_details: str,
             policies: Sequence[str],
             responder_rule_id: str,
             state: str,
             supported_modes: Sequence[str],
             time_created: str,
             time_updated: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if 'responderRuleId' in kwargs:
            responder_rule_id = kwargs['responderRuleId']
        if 'supportedModes' in kwargs:
            supported_modes = kwargs['supportedModes']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("compartment_id", compartment_id)
        _setter("description", description)
        _setter("details", details)
        _setter("display_name", display_name)
        _setter("lifecycle_details", lifecycle_details)
        _setter("policies", policies)
        _setter("responder_rule_id", responder_rule_id)
        _setter("state", state)
        _setter("supported_modes", supported_modes)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)
        _setter("type", type)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        Compartment Identifier
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        ResponderRule description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def details(self) -> Sequence['outputs.GetResponderRecipeEffectiveResponderRuleDetailResult']:
        """
        Details of ResponderRule.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        ResponderRule display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def policies(self) -> Sequence[str]:
        """
        List of Policy
        """
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="responderRuleId")
    def responder_rule_id(self) -> str:
        """
        Identifier for ResponderRule.
        """
        return pulumi.get(self, "responder_rule_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the Example.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="supportedModes")
    def supported_modes(self) -> Sequence[str]:
        """
        Supported Execution Modes
        """
        return pulumi.get(self, "supported_modes")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the responder recipe was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the responder recipe was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of Responder
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetResponderRecipeEffectiveResponderRuleDetailResult(dict):
    def __init__(__self__, *,
                 condition: str,
                 configurations: Sequence['outputs.GetResponderRecipeEffectiveResponderRuleDetailConfigurationResult'],
                 is_enabled: bool,
                 mode: str):
        """
        :param str condition: Base condition object
        :param Sequence['GetResponderRecipeEffectiveResponderRuleDetailConfigurationArgs'] configurations: ResponderRule configurations
        :param bool is_enabled: Identifies state for ResponderRule
        :param str mode: Execution Mode for ResponderRule
        """
        GetResponderRecipeEffectiveResponderRuleDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition=condition,
            configurations=configurations,
            is_enabled=is_enabled,
            mode=mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition: str,
             configurations: Sequence['outputs.GetResponderRecipeEffectiveResponderRuleDetailConfigurationResult'],
             is_enabled: bool,
             mode: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']

        _setter("condition", condition)
        _setter("configurations", configurations)
        _setter("is_enabled", is_enabled)
        _setter("mode", mode)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Base condition object
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def configurations(self) -> Sequence['outputs.GetResponderRecipeEffectiveResponderRuleDetailConfigurationResult']:
        """
        ResponderRule configurations
        """
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Identifies state for ResponderRule
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Execution Mode for ResponderRule
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetResponderRecipeEffectiveResponderRuleDetailConfigurationResult(dict):
    def __init__(__self__, *,
                 config_key: str,
                 name: str,
                 value: str):
        """
        :param str config_key: Unique name of the configuration
        :param str name: configuration name
        :param str value: configuration value
        """
        GetResponderRecipeEffectiveResponderRuleDetailConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_key=config_key,
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_key: str,
             name: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'configKey' in kwargs:
            config_key = kwargs['configKey']

        _setter("config_key", config_key)
        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> str:
        """
        Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        configuration name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        configuration value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetResponderRecipeResponderRuleResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 description: str,
                 details: Sequence['outputs.GetResponderRecipeResponderRuleDetailResult'],
                 display_name: str,
                 lifecycle_details: str,
                 policies: Sequence[str],
                 responder_rule_id: str,
                 state: str,
                 supported_modes: Sequence[str],
                 time_created: str,
                 time_updated: str,
                 type: str):
        """
        :param str compartment_id: Compartment Identifier
        :param str description: ResponderRule description.
        :param Sequence['GetResponderRecipeResponderRuleDetailArgs'] details: Details of ResponderRule.
        :param str display_name: ResponderRule display name.
        :param str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param Sequence[str] policies: List of Policy
        :param str responder_rule_id: Identifier for ResponderRule.
        :param str state: The current state of the Example.
        :param Sequence[str] supported_modes: Supported Execution Modes
        :param str time_created: The date and time the responder recipe was created. Format defined by RFC3339.
        :param str time_updated: The date and time the responder recipe was updated. Format defined by RFC3339.
        :param str type: Type of Responder
        """
        GetResponderRecipeResponderRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            description=description,
            details=details,
            display_name=display_name,
            lifecycle_details=lifecycle_details,
            policies=policies,
            responder_rule_id=responder_rule_id,
            state=state,
            supported_modes=supported_modes,
            time_created=time_created,
            time_updated=time_updated,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             description: str,
             details: Sequence['outputs.GetResponderRecipeResponderRuleDetailResult'],
             display_name: str,
             lifecycle_details: str,
             policies: Sequence[str],
             responder_rule_id: str,
             state: str,
             supported_modes: Sequence[str],
             time_created: str,
             time_updated: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if 'responderRuleId' in kwargs:
            responder_rule_id = kwargs['responderRuleId']
        if 'supportedModes' in kwargs:
            supported_modes = kwargs['supportedModes']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("compartment_id", compartment_id)
        _setter("description", description)
        _setter("details", details)
        _setter("display_name", display_name)
        _setter("lifecycle_details", lifecycle_details)
        _setter("policies", policies)
        _setter("responder_rule_id", responder_rule_id)
        _setter("state", state)
        _setter("supported_modes", supported_modes)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)
        _setter("type", type)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        Compartment Identifier
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        ResponderRule description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def details(self) -> Sequence['outputs.GetResponderRecipeResponderRuleDetailResult']:
        """
        Details of ResponderRule.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        ResponderRule display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def policies(self) -> Sequence[str]:
        """
        List of Policy
        """
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="responderRuleId")
    def responder_rule_id(self) -> str:
        """
        Identifier for ResponderRule.
        """
        return pulumi.get(self, "responder_rule_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the Example.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="supportedModes")
    def supported_modes(self) -> Sequence[str]:
        """
        Supported Execution Modes
        """
        return pulumi.get(self, "supported_modes")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the responder recipe was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the responder recipe was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of Responder
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetResponderRecipeResponderRuleDetailResult(dict):
    def __init__(__self__, *,
                 condition: str,
                 configurations: Sequence['outputs.GetResponderRecipeResponderRuleDetailConfigurationResult'],
                 is_enabled: bool,
                 mode: str):
        """
        :param str condition: Base condition object
        :param Sequence['GetResponderRecipeResponderRuleDetailConfigurationArgs'] configurations: ResponderRule configurations
        :param bool is_enabled: Identifies state for ResponderRule
        :param str mode: Execution Mode for ResponderRule
        """
        GetResponderRecipeResponderRuleDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition=condition,
            configurations=configurations,
            is_enabled=is_enabled,
            mode=mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition: str,
             configurations: Sequence['outputs.GetResponderRecipeResponderRuleDetailConfigurationResult'],
             is_enabled: bool,
             mode: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']

        _setter("condition", condition)
        _setter("configurations", configurations)
        _setter("is_enabled", is_enabled)
        _setter("mode", mode)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Base condition object
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def configurations(self) -> Sequence['outputs.GetResponderRecipeResponderRuleDetailConfigurationResult']:
        """
        ResponderRule configurations
        """
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Identifies state for ResponderRule
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Execution Mode for ResponderRule
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetResponderRecipeResponderRuleDetailConfigurationResult(dict):
    def __init__(__self__, *,
                 config_key: str,
                 name: str,
                 value: str):
        """
        :param str config_key: Unique name of the configuration
        :param str name: configuration name
        :param str value: configuration value
        """
        GetResponderRecipeResponderRuleDetailConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_key=config_key,
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_key: str,
             name: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'configKey' in kwargs:
            config_key = kwargs['configKey']

        _setter("config_key", config_key)
        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> str:
        """
        Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        configuration name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        configuration value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetResponderRecipesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: configuration name
        """
        GetResponderRecipesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        configuration name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetResponderRecipesResponderRecipeCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetResponderRecipesResponderRecipeCollectionItemResult']):
        GetResponderRecipesResponderRecipeCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Sequence['outputs.GetResponderRecipesResponderRecipeCollectionItemResult'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetResponderRecipesResponderRecipeCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetResponderRecipesResponderRecipeCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 effective_responder_rules: Sequence['outputs.GetResponderRecipesResponderRecipeCollectionItemEffectiveResponderRuleResult'],
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 lifecycle_details: str,
                 owner: str,
                 responder_rules: Sequence['outputs.GetResponderRecipesResponderRecipeCollectionItemResponderRuleResult'],
                 source_responder_recipe_id: str,
                 state: str,
                 system_tags: Mapping[str, Any],
                 time_created: str,
                 time_updated: str):
        """
        :param str compartment_id: The ID of the compartment in which to list resources.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param str description: ResponderRule description.
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param Sequence['GetResponderRecipesResponderRecipeCollectionItemEffectiveResponderRuleArgs'] effective_responder_rules: List of responder rules associated with the recipe
        :param Mapping[str, Any] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param str id: Identifier for ResponderRecipe.
        :param str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param str owner: Owner of ResponderRecipe
        :param Sequence['GetResponderRecipesResponderRecipeCollectionItemResponderRuleArgs'] responder_rules: List of responder rules associated with the recipe
        :param str source_responder_recipe_id: The id of the source responder recipe.
        :param str state: The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        :param Mapping[str, Any] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). System tags can be viewed by users, but can only be created by the system.  Example: `{"orcl-cloud.free-tier-retained": "true"}`
        :param str time_created: The date and time the responder recipe was created. Format defined by RFC3339.
        :param str time_updated: The date and time the responder recipe was updated. Format defined by RFC3339.
        """
        GetResponderRecipesResponderRecipeCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            effective_responder_rules=effective_responder_rules,
            freeform_tags=freeform_tags,
            id=id,
            lifecycle_details=lifecycle_details,
            owner=owner,
            responder_rules=responder_rules,
            source_responder_recipe_id=source_responder_recipe_id,
            state=state,
            system_tags=system_tags,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             defined_tags: Mapping[str, Any],
             description: str,
             display_name: str,
             effective_responder_rules: Sequence['outputs.GetResponderRecipesResponderRecipeCollectionItemEffectiveResponderRuleResult'],
             freeform_tags: Mapping[str, Any],
             id: str,
             lifecycle_details: str,
             owner: str,
             responder_rules: Sequence['outputs.GetResponderRecipesResponderRecipeCollectionItemResponderRuleResult'],
             source_responder_recipe_id: str,
             state: str,
             system_tags: Mapping[str, Any],
             time_created: str,
             time_updated: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'effectiveResponderRules' in kwargs:
            effective_responder_rules = kwargs['effectiveResponderRules']
        if 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if 'responderRules' in kwargs:
            responder_rules = kwargs['responderRules']
        if 'sourceResponderRecipeId' in kwargs:
            source_responder_recipe_id = kwargs['sourceResponderRecipeId']
        if 'systemTags' in kwargs:
            system_tags = kwargs['systemTags']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("effective_responder_rules", effective_responder_rules)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("owner", owner)
        _setter("responder_rules", responder_rules)
        _setter("source_responder_recipe_id", source_responder_recipe_id)
        _setter("state", state)
        _setter("system_tags", system_tags)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        ResponderRule description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="effectiveResponderRules")
    def effective_responder_rules(self) -> Sequence['outputs.GetResponderRecipesResponderRecipeCollectionItemEffectiveResponderRuleResult']:
        """
        List of responder rules associated with the recipe
        """
        return pulumi.get(self, "effective_responder_rules")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier for ResponderRecipe.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def owner(self) -> str:
        """
        Owner of ResponderRecipe
        """
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter(name="responderRules")
    def responder_rules(self) -> Sequence['outputs.GetResponderRecipesResponderRecipeCollectionItemResponderRuleResult']:
        """
        List of responder rules associated with the recipe
        """
        return pulumi.get(self, "responder_rules")

    @property
    @pulumi.getter(name="sourceResponderRecipeId")
    def source_responder_recipe_id(self) -> str:
        """
        The id of the source responder recipe.
        """
        return pulumi.get(self, "source_responder_recipe_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm). System tags can be viewed by users, but can only be created by the system.  Example: `{"orcl-cloud.free-tier-retained": "true"}`
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the responder recipe was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the responder recipe was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetResponderRecipesResponderRecipeCollectionItemEffectiveResponderRuleResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 description: str,
                 details: Sequence['outputs.GetResponderRecipesResponderRecipeCollectionItemEffectiveResponderRuleDetailResult'],
                 display_name: str,
                 lifecycle_details: str,
                 policies: Sequence[str],
                 responder_rule_id: str,
                 state: str,
                 supported_modes: Sequence[str],
                 time_created: str,
                 time_updated: str,
                 type: str):
        """
        :param str compartment_id: The ID of the compartment in which to list resources.
        :param str description: ResponderRule description.
        :param Sequence['GetResponderRecipesResponderRecipeCollectionItemEffectiveResponderRuleDetailArgs'] details: Details of ResponderRule.
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param Sequence[str] policies: List of Policy
        :param str responder_rule_id: Identifier for ResponderRule.
        :param str state: The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        :param Sequence[str] supported_modes: Supported Execution Modes
        :param str time_created: The date and time the responder recipe was created. Format defined by RFC3339.
        :param str time_updated: The date and time the responder recipe was updated. Format defined by RFC3339.
        :param str type: Type of Responder
        """
        GetResponderRecipesResponderRecipeCollectionItemEffectiveResponderRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            description=description,
            details=details,
            display_name=display_name,
            lifecycle_details=lifecycle_details,
            policies=policies,
            responder_rule_id=responder_rule_id,
            state=state,
            supported_modes=supported_modes,
            time_created=time_created,
            time_updated=time_updated,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             description: str,
             details: Sequence['outputs.GetResponderRecipesResponderRecipeCollectionItemEffectiveResponderRuleDetailResult'],
             display_name: str,
             lifecycle_details: str,
             policies: Sequence[str],
             responder_rule_id: str,
             state: str,
             supported_modes: Sequence[str],
             time_created: str,
             time_updated: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if 'responderRuleId' in kwargs:
            responder_rule_id = kwargs['responderRuleId']
        if 'supportedModes' in kwargs:
            supported_modes = kwargs['supportedModes']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("compartment_id", compartment_id)
        _setter("description", description)
        _setter("details", details)
        _setter("display_name", display_name)
        _setter("lifecycle_details", lifecycle_details)
        _setter("policies", policies)
        _setter("responder_rule_id", responder_rule_id)
        _setter("state", state)
        _setter("supported_modes", supported_modes)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)
        _setter("type", type)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        ResponderRule description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def details(self) -> Sequence['outputs.GetResponderRecipesResponderRecipeCollectionItemEffectiveResponderRuleDetailResult']:
        """
        Details of ResponderRule.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def policies(self) -> Sequence[str]:
        """
        List of Policy
        """
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="responderRuleId")
    def responder_rule_id(self) -> str:
        """
        Identifier for ResponderRule.
        """
        return pulumi.get(self, "responder_rule_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="supportedModes")
    def supported_modes(self) -> Sequence[str]:
        """
        Supported Execution Modes
        """
        return pulumi.get(self, "supported_modes")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the responder recipe was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the responder recipe was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of Responder
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetResponderRecipesResponderRecipeCollectionItemEffectiveResponderRuleDetailResult(dict):
    def __init__(__self__, *,
                 condition: str,
                 configurations: Sequence['outputs.GetResponderRecipesResponderRecipeCollectionItemEffectiveResponderRuleDetailConfigurationResult'],
                 is_enabled: bool,
                 mode: str):
        """
        :param str condition: Base condition object
        :param Sequence['GetResponderRecipesResponderRecipeCollectionItemEffectiveResponderRuleDetailConfigurationArgs'] configurations: ResponderRule configurations
        :param bool is_enabled: Identifies state for ResponderRule
        :param str mode: Execution Mode for ResponderRule
        """
        GetResponderRecipesResponderRecipeCollectionItemEffectiveResponderRuleDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition=condition,
            configurations=configurations,
            is_enabled=is_enabled,
            mode=mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition: str,
             configurations: Sequence['outputs.GetResponderRecipesResponderRecipeCollectionItemEffectiveResponderRuleDetailConfigurationResult'],
             is_enabled: bool,
             mode: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']

        _setter("condition", condition)
        _setter("configurations", configurations)
        _setter("is_enabled", is_enabled)
        _setter("mode", mode)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Base condition object
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def configurations(self) -> Sequence['outputs.GetResponderRecipesResponderRecipeCollectionItemEffectiveResponderRuleDetailConfigurationResult']:
        """
        ResponderRule configurations
        """
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Identifies state for ResponderRule
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Execution Mode for ResponderRule
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetResponderRecipesResponderRecipeCollectionItemEffectiveResponderRuleDetailConfigurationResult(dict):
    def __init__(__self__, *,
                 config_key: str,
                 name: str,
                 value: str):
        """
        :param str config_key: Unique name of the configuration
        :param str name: configuration name
        :param str value: configuration value
        """
        GetResponderRecipesResponderRecipeCollectionItemEffectiveResponderRuleDetailConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_key=config_key,
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_key: str,
             name: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'configKey' in kwargs:
            config_key = kwargs['configKey']

        _setter("config_key", config_key)
        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> str:
        """
        Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        configuration name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        configuration value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetResponderRecipesResponderRecipeCollectionItemResponderRuleResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 description: str,
                 details: Sequence['outputs.GetResponderRecipesResponderRecipeCollectionItemResponderRuleDetailResult'],
                 display_name: str,
                 lifecycle_details: str,
                 policies: Sequence[str],
                 responder_rule_id: str,
                 state: str,
                 supported_modes: Sequence[str],
                 time_created: str,
                 time_updated: str,
                 type: str):
        """
        :param str compartment_id: The ID of the compartment in which to list resources.
        :param str description: ResponderRule description.
        :param Sequence['GetResponderRecipesResponderRecipeCollectionItemResponderRuleDetailArgs'] details: Details of ResponderRule.
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param str lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param Sequence[str] policies: List of Policy
        :param str responder_rule_id: Identifier for ResponderRule.
        :param str state: The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        :param Sequence[str] supported_modes: Supported Execution Modes
        :param str time_created: The date and time the responder recipe was created. Format defined by RFC3339.
        :param str time_updated: The date and time the responder recipe was updated. Format defined by RFC3339.
        :param str type: Type of Responder
        """
        GetResponderRecipesResponderRecipeCollectionItemResponderRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            description=description,
            details=details,
            display_name=display_name,
            lifecycle_details=lifecycle_details,
            policies=policies,
            responder_rule_id=responder_rule_id,
            state=state,
            supported_modes=supported_modes,
            time_created=time_created,
            time_updated=time_updated,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             description: str,
             details: Sequence['outputs.GetResponderRecipesResponderRecipeCollectionItemResponderRuleDetailResult'],
             display_name: str,
             lifecycle_details: str,
             policies: Sequence[str],
             responder_rule_id: str,
             state: str,
             supported_modes: Sequence[str],
             time_created: str,
             time_updated: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if 'responderRuleId' in kwargs:
            responder_rule_id = kwargs['responderRuleId']
        if 'supportedModes' in kwargs:
            supported_modes = kwargs['supportedModes']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("compartment_id", compartment_id)
        _setter("description", description)
        _setter("details", details)
        _setter("display_name", display_name)
        _setter("lifecycle_details", lifecycle_details)
        _setter("policies", policies)
        _setter("responder_rule_id", responder_rule_id)
        _setter("state", state)
        _setter("supported_modes", supported_modes)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)
        _setter("type", type)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        ResponderRule description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def details(self) -> Sequence['outputs.GetResponderRecipesResponderRecipeCollectionItemResponderRuleDetailResult']:
        """
        Details of ResponderRule.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def policies(self) -> Sequence[str]:
        """
        List of Policy
        """
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="responderRuleId")
    def responder_rule_id(self) -> str:
        """
        Identifier for ResponderRule.
        """
        return pulumi.get(self, "responder_rule_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="supportedModes")
    def supported_modes(self) -> Sequence[str]:
        """
        Supported Execution Modes
        """
        return pulumi.get(self, "supported_modes")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the responder recipe was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time the responder recipe was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of Responder
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetResponderRecipesResponderRecipeCollectionItemResponderRuleDetailResult(dict):
    def __init__(__self__, *,
                 condition: str,
                 configurations: Sequence['outputs.GetResponderRecipesResponderRecipeCollectionItemResponderRuleDetailConfigurationResult'],
                 is_enabled: bool,
                 mode: str):
        """
        :param str condition: Base condition object
        :param Sequence['GetResponderRecipesResponderRecipeCollectionItemResponderRuleDetailConfigurationArgs'] configurations: ResponderRule configurations
        :param bool is_enabled: Identifies state for ResponderRule
        :param str mode: Execution Mode for ResponderRule
        """
        GetResponderRecipesResponderRecipeCollectionItemResponderRuleDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition=condition,
            configurations=configurations,
            is_enabled=is_enabled,
            mode=mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition: str,
             configurations: Sequence['outputs.GetResponderRecipesResponderRecipeCollectionItemResponderRuleDetailConfigurationResult'],
             is_enabled: bool,
             mode: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']

        _setter("condition", condition)
        _setter("configurations", configurations)
        _setter("is_enabled", is_enabled)
        _setter("mode", mode)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Base condition object
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def configurations(self) -> Sequence['outputs.GetResponderRecipesResponderRecipeCollectionItemResponderRuleDetailConfigurationResult']:
        """
        ResponderRule configurations
        """
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Identifies state for ResponderRule
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Execution Mode for ResponderRule
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetResponderRecipesResponderRecipeCollectionItemResponderRuleDetailConfigurationResult(dict):
    def __init__(__self__, *,
                 config_key: str,
                 name: str,
                 value: str):
        """
        :param str config_key: Unique name of the configuration
        :param str name: configuration name
        :param str value: configuration value
        """
        GetResponderRecipesResponderRecipeCollectionItemResponderRuleDetailConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_key=config_key,
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_key: str,
             name: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'configKey' in kwargs:
            config_key = kwargs['configKey']

        _setter("config_key", config_key)
        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> str:
        """
        Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        configuration name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        configuration value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetSecurityPoliciesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetSecurityPoliciesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetSecurityPoliciesSecurityPolicyCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetSecurityPoliciesSecurityPolicyCollectionItemResult']):
        GetSecurityPoliciesSecurityPolicyCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Sequence['outputs.GetSecurityPoliciesSecurityPolicyCollectionItemResult'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetSecurityPoliciesSecurityPolicyCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetSecurityPoliciesSecurityPolicyCollectionItemResult(dict):
    def __init__(__self__, *,
                 category: str,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 friendly_name: str,
                 id: str,
                 lifecycle_details: str,
                 owner: str,
                 services: Sequence[str],
                 state: str,
                 time_created: str,
                 time_updated: str):
        """
        :param str category: The category of security policy
        :param str compartment_id: The ID of the compartment in which to list resources.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param str description: The security policy's description
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param Mapping[str, Any] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param str friendly_name: A shorter version of the security policy's name
        :param str id: The unique identifier of the security zone policy (`SecurityPolicy`)
        :param str lifecycle_details: A message describing the current state in more detail. For example, this can be used to provide actionable information for a resource in a `Failed` state.
        :param str owner: The owner of the security policy
        :param Sequence[str] services: The list of services that the security policy protects
        :param str state: The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        :param str time_created: The time the security policy was created. An RFC3339 formatted datetime string.
        :param str time_updated: The time the security policy was last updated. An RFC3339 formatted datetime string.
        """
        GetSecurityPoliciesSecurityPolicyCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            freeform_tags=freeform_tags,
            friendly_name=friendly_name,
            id=id,
            lifecycle_details=lifecycle_details,
            owner=owner,
            services=services,
            state=state,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: str,
             compartment_id: str,
             defined_tags: Mapping[str, Any],
             description: str,
             display_name: str,
             freeform_tags: Mapping[str, Any],
             friendly_name: str,
             id: str,
             lifecycle_details: str,
             owner: str,
             services: Sequence[str],
             state: str,
             time_created: str,
             time_updated: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if 'friendlyName' in kwargs:
            friendly_name = kwargs['friendlyName']
        if 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("category", category)
        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("friendly_name", friendly_name)
        _setter("id", id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("owner", owner)
        _setter("services", services)
        _setter("state", state)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        The category of security policy
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The security policy's description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter(name="friendlyName")
    def friendly_name(self) -> str:
        """
        A shorter version of the security policy's name
        """
        return pulumi.get(self, "friendly_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique identifier of the security zone policy (`SecurityPolicy`)
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A message describing the current state in more detail. For example, this can be used to provide actionable information for a resource in a `Failed` state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def owner(self) -> str:
        """
        The owner of the security policy
        """
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter
    def services(self) -> Sequence[str]:
        """
        The list of services that the security policy protects
        """
        return pulumi.get(self, "services")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The time the security policy was created. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The time the security policy was last updated. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetSecurityRecipesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetSecurityRecipesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetSecurityRecipesSecurityRecipeCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetSecurityRecipesSecurityRecipeCollectionItemResult']):
        GetSecurityRecipesSecurityRecipeCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Sequence['outputs.GetSecurityRecipesSecurityRecipeCollectionItemResult'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetSecurityRecipesSecurityRecipeCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetSecurityRecipesSecurityRecipeCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 lifecycle_details: str,
                 owner: str,
                 security_policies: Sequence[str],
                 state: str,
                 time_created: str,
                 time_updated: str):
        """
        :param str compartment_id: The ID of the compartment in which to list resources.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param str description: The recipe's description
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param Mapping[str, Any] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param str id: The unique identifier of the security zone recipe (`SecurityRecipe`)
        :param str lifecycle_details: A message describing the current state in more detail. For example, this can be used to provide actionable information for a recipe in the `Failed` state.
        :param str owner: The owner of the recipe
        :param Sequence[str] security_policies: The list of `SecurityPolicy` ids that are included in the recipe
        :param str state: The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        :param str time_created: The time the recipe was created. An RFC3339 formatted datetime string.
        :param str time_updated: The time the recipe was last updated. An RFC3339 formatted datetime string.
        """
        GetSecurityRecipesSecurityRecipeCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            lifecycle_details=lifecycle_details,
            owner=owner,
            security_policies=security_policies,
            state=state,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             defined_tags: Mapping[str, Any],
             description: str,
             display_name: str,
             freeform_tags: Mapping[str, Any],
             id: str,
             lifecycle_details: str,
             owner: str,
             security_policies: Sequence[str],
             state: str,
             time_created: str,
             time_updated: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if 'securityPolicies' in kwargs:
            security_policies = kwargs['securityPolicies']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("owner", owner)
        _setter("security_policies", security_policies)
        _setter("state", state)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The recipe's description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique identifier of the security zone recipe (`SecurityRecipe`)
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A message describing the current state in more detail. For example, this can be used to provide actionable information for a recipe in the `Failed` state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def owner(self) -> str:
        """
        The owner of the recipe
        """
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter(name="securityPolicies")
    def security_policies(self) -> Sequence[str]:
        """
        The list of `SecurityPolicy` ids that are included in the recipe
        """
        return pulumi.get(self, "security_policies")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The time the recipe was created. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The time the recipe was last updated. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetSecurityZonesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetSecurityZonesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetSecurityZonesSecurityZoneCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetSecurityZonesSecurityZoneCollectionItemResult']):
        GetSecurityZonesSecurityZoneCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Sequence['outputs.GetSecurityZonesSecurityZoneCollectionItemResult'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetSecurityZonesSecurityZoneCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetSecurityZonesSecurityZoneCollectionItemResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 inherited_by_compartments: Sequence[str],
                 lifecycle_details: str,
                 security_zone_recipe_id: str,
                 security_zone_target_id: str,
                 state: str,
                 time_created: str,
                 time_updated: str):
        """
        :param str compartment_id: The ID of the compartment in which to list resources.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param str description: The security zone's description
        :param str display_name: A filter to return only resources that match the entire display name given.
        :param Mapping[str, Any] freeform_tags: Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param str id: The unique identifier of the security zone (`SecurityZone`)
        :param Sequence[str] inherited_by_compartments: List of inherited compartments
        :param str lifecycle_details: A message describing the current state in more detail. For example, this can be used to provide actionable information for a zone in the `Failed` state.
        :param str security_zone_recipe_id: The OCID of the recipe (`SecurityRecipe`) for the security zone
        :param str security_zone_target_id: The OCID of the target associated with the security zone
        :param str state: The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        :param str time_created: The time the security zone was created. An RFC3339 formatted datetime string.
        :param str time_updated: The time the security zone was last updated. An RFC3339 formatted datetime string.
        """
        GetSecurityZonesSecurityZoneCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            inherited_by_compartments=inherited_by_compartments,
            lifecycle_details=lifecycle_details,
            security_zone_recipe_id=security_zone_recipe_id,
            security_zone_target_id=security_zone_target_id,
            state=state,
            time_created=time_created,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             defined_tags: Mapping[str, Any],
             description: str,
             display_name: str,
             freeform_tags: Mapping[str, Any],
             id: str,
             inherited_by_compartments: Sequence[str],
             lifecycle_details: str,
             security_zone_recipe_id: str,
             security_zone_target_id: str,
             state: str,
             time_created: str,
             time_updated: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'compartmentId' in kwargs:
            compartment_id = kwargs['compartmentId']
        if 'definedTags' in kwargs:
            defined_tags = kwargs['definedTags']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'freeformTags' in kwargs:
            freeform_tags = kwargs['freeformTags']
        if 'inheritedByCompartments' in kwargs:
            inherited_by_compartments = kwargs['inheritedByCompartments']
        if 'lifecycleDetails' in kwargs:
            lifecycle_details = kwargs['lifecycleDetails']
        if 'securityZoneRecipeId' in kwargs:
            security_zone_recipe_id = kwargs['securityZoneRecipeId']
        if 'securityZoneTargetId' in kwargs:
            security_zone_target_id = kwargs['securityZoneTargetId']
        if 'timeCreated' in kwargs:
            time_created = kwargs['timeCreated']
        if 'timeUpdated' in kwargs:
            time_updated = kwargs['timeUpdated']

        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("inherited_by_compartments", inherited_by_compartments)
        _setter("lifecycle_details", lifecycle_details)
        _setter("security_zone_recipe_id", security_zone_recipe_id)
        _setter("security_zone_target_id", security_zone_target_id)
        _setter("state", state)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The ID of the compartment in which to list resources.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The security zone's description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique identifier of the security zone (`SecurityZone`)
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="inheritedByCompartments")
    def inherited_by_compartments(self) -> Sequence[str]:
        """
        List of inherited compartments
        """
        return pulumi.get(self, "inherited_by_compartments")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A message describing the current state in more detail. For example, this can be used to provide actionable information for a zone in the `Failed` state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="securityZoneRecipeId")
    def security_zone_recipe_id(self) -> str:
        """
        The OCID of the recipe (`SecurityRecipe`) for the security zone
        """
        return pulumi.get(self, "security_zone_recipe_id")

    @property
    @pulumi.getter(name="securityZoneTargetId")
    def security_zone_target_id(self) -> str:
        """
        The OCID of the target associated with the security zone
        """
        return pulumi.get(self, "security_zone_target_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The field life cycle state. Only one state can be provided. Default value for state is active. If no value is specified state is active.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The time the security zone was created. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The time the security zone was last updated. An RFC3339 formatted datetime string.
        """
        return pulumi.get(self, "time_updated")


