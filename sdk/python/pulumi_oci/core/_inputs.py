# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'BootVolumeAutotunePolicyArgs',
    'BootVolumeBackupSourceDetailsArgs',
    'BootVolumeBootVolumeReplicaArgs',
    'BootVolumeSourceDetailsArgs',
    'CaptureFilterVtapCaptureFilterRuleArgs',
    'CaptureFilterVtapCaptureFilterRuleIcmpOptionsArgs',
    'CaptureFilterVtapCaptureFilterRuleTcpOptionsArgs',
    'CaptureFilterVtapCaptureFilterRuleTcpOptionsDestinationPortRangeArgs',
    'CaptureFilterVtapCaptureFilterRuleTcpOptionsSourcePortRangeArgs',
    'CaptureFilterVtapCaptureFilterRuleUdpOptionsArgs',
    'CaptureFilterVtapCaptureFilterRuleUdpOptionsDestinationPortRangeArgs',
    'CaptureFilterVtapCaptureFilterRuleUdpOptionsSourcePortRangeArgs',
    'ClusterNetworkClusterConfigurationArgs',
    'ClusterNetworkInstancePoolArgs',
    'ClusterNetworkInstancePoolLoadBalancerArgs',
    'ClusterNetworkInstancePoolPlacementConfigurationArgs',
    'ClusterNetworkInstancePoolPlacementConfigurationPrimaryVnicSubnetArgs',
    'ClusterNetworkInstancePoolPlacementConfigurationPrimaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs',
    'ClusterNetworkInstancePoolPlacementConfigurationSecondaryVnicSubnetArgs',
    'ClusterNetworkInstancePoolPlacementConfigurationSecondaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs',
    'ClusterNetworkPlacementConfigurationArgs',
    'ClusterNetworkPlacementConfigurationPrimaryVnicSubnetsArgs',
    'ClusterNetworkPlacementConfigurationPrimaryVnicSubnetsIpv6addressIpv6subnetCidrPairDetailArgs',
    'ClusterNetworkPlacementConfigurationSecondaryVnicSubnetArgs',
    'ClusterNetworkPlacementConfigurationSecondaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs',
    'ComputeCapacityReportShapeAvailabilityArgs',
    'ComputeCapacityReportShapeAvailabilityInstanceShapeConfigArgs',
    'ComputeCapacityReservationInstanceReservationConfigArgs',
    'ComputeCapacityReservationInstanceReservationConfigClusterConfigArgs',
    'ComputeCapacityReservationInstanceReservationConfigInstanceShapeConfigArgs',
    'CrossConnectGroupMacsecPropertiesArgs',
    'CrossConnectGroupMacsecPropertiesPrimaryKeyArgs',
    'CrossConnectMacsecPropertiesArgs',
    'CrossConnectMacsecPropertiesPrimaryKeyArgs',
    'DefaultDhcpOptionsOptionArgs',
    'DefaultRouteTableRouteRuleArgs',
    'DefaultSecurityListEgressSecurityRuleArgs',
    'DefaultSecurityListEgressSecurityRuleIcmpOptionsArgs',
    'DefaultSecurityListEgressSecurityRuleTcpOptionsArgs',
    'DefaultSecurityListEgressSecurityRuleTcpOptionsSourcePortRangeArgs',
    'DefaultSecurityListEgressSecurityRuleUdpOptionsArgs',
    'DefaultSecurityListEgressSecurityRuleUdpOptionsSourcePortRangeArgs',
    'DefaultSecurityListIngressSecurityRuleArgs',
    'DefaultSecurityListIngressSecurityRuleIcmpOptionsArgs',
    'DefaultSecurityListIngressSecurityRuleTcpOptionsArgs',
    'DefaultSecurityListIngressSecurityRuleTcpOptionsSourcePortRangeArgs',
    'DefaultSecurityListIngressSecurityRuleUdpOptionsArgs',
    'DefaultSecurityListIngressSecurityRuleUdpOptionsSourcePortRangeArgs',
    'DhcpOptionsOptionArgs',
    'DrgAttachmentManagementNetworkDetailsArgs',
    'DrgAttachmentNetworkDetailsArgs',
    'DrgAttachmentsListDrgAllAttachmentArgs',
    'DrgDefaultDrgRouteTableArgs',
    'DrgRouteDistributionStatementMatchCriteriaArgs',
    'ImageAgentFeatureArgs',
    'ImageImageSourceDetailsArgs',
    'ImageLaunchOptionArgs',
    'InstanceAgentConfigArgs',
    'InstanceAgentConfigPluginsConfigArgs',
    'InstanceAvailabilityConfigArgs',
    'InstanceConfigurationInstanceDetailsArgs',
    'InstanceConfigurationInstanceDetailsBlockVolumeArgs',
    'InstanceConfigurationInstanceDetailsBlockVolumeAttachDetailsArgs',
    'InstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsArgs',
    'InstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsAutotunePolicyArgs',
    'InstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsBlockVolumeReplicasArgs',
    'InstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsSourceDetailsArgs',
    'InstanceConfigurationInstanceDetailsLaunchDetailsArgs',
    'InstanceConfigurationInstanceDetailsLaunchDetailsAgentConfigArgs',
    'InstanceConfigurationInstanceDetailsLaunchDetailsAgentConfigPluginsConfigArgs',
    'InstanceConfigurationInstanceDetailsLaunchDetailsAvailabilityConfigArgs',
    'InstanceConfigurationInstanceDetailsLaunchDetailsCreateVnicDetailsArgs',
    'InstanceConfigurationInstanceDetailsLaunchDetailsCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs',
    'InstanceConfigurationInstanceDetailsLaunchDetailsInstanceOptionsArgs',
    'InstanceConfigurationInstanceDetailsLaunchDetailsLaunchOptionsArgs',
    'InstanceConfigurationInstanceDetailsLaunchDetailsPlatformConfigArgs',
    'InstanceConfigurationInstanceDetailsLaunchDetailsPreemptibleInstanceConfigArgs',
    'InstanceConfigurationInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionActionArgs',
    'InstanceConfigurationInstanceDetailsLaunchDetailsShapeConfigArgs',
    'InstanceConfigurationInstanceDetailsLaunchDetailsSourceDetailsArgs',
    'InstanceConfigurationInstanceDetailsLaunchDetailsSourceDetailsInstanceSourceImageFilterDetailsArgs',
    'InstanceConfigurationInstanceDetailsOptionArgs',
    'InstanceConfigurationInstanceDetailsOptionBlockVolumeArgs',
    'InstanceConfigurationInstanceDetailsOptionBlockVolumeAttachDetailsArgs',
    'InstanceConfigurationInstanceDetailsOptionBlockVolumeCreateDetailsArgs',
    'InstanceConfigurationInstanceDetailsOptionBlockVolumeCreateDetailsAutotunePolicyArgs',
    'InstanceConfigurationInstanceDetailsOptionBlockVolumeCreateDetailsBlockVolumeReplicasArgs',
    'InstanceConfigurationInstanceDetailsOptionBlockVolumeCreateDetailsSourceDetailsArgs',
    'InstanceConfigurationInstanceDetailsOptionLaunchDetailsArgs',
    'InstanceConfigurationInstanceDetailsOptionLaunchDetailsAgentConfigArgs',
    'InstanceConfigurationInstanceDetailsOptionLaunchDetailsAgentConfigPluginsConfigArgs',
    'InstanceConfigurationInstanceDetailsOptionLaunchDetailsAvailabilityConfigArgs',
    'InstanceConfigurationInstanceDetailsOptionLaunchDetailsCreateVnicDetailsArgs',
    'InstanceConfigurationInstanceDetailsOptionLaunchDetailsCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs',
    'InstanceConfigurationInstanceDetailsOptionLaunchDetailsInstanceOptionsArgs',
    'InstanceConfigurationInstanceDetailsOptionLaunchDetailsLaunchOptionsArgs',
    'InstanceConfigurationInstanceDetailsOptionLaunchDetailsPlatformConfigArgs',
    'InstanceConfigurationInstanceDetailsOptionLaunchDetailsPreemptibleInstanceConfigArgs',
    'InstanceConfigurationInstanceDetailsOptionLaunchDetailsPreemptibleInstanceConfigPreemptionActionArgs',
    'InstanceConfigurationInstanceDetailsOptionLaunchDetailsShapeConfigArgs',
    'InstanceConfigurationInstanceDetailsOptionLaunchDetailsSourceDetailsArgs',
    'InstanceConfigurationInstanceDetailsOptionLaunchDetailsSourceDetailsInstanceSourceImageFilterDetailsArgs',
    'InstanceConfigurationInstanceDetailsOptionSecondaryVnicArgs',
    'InstanceConfigurationInstanceDetailsOptionSecondaryVnicCreateVnicDetailsArgs',
    'InstanceConfigurationInstanceDetailsOptionSecondaryVnicCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs',
    'InstanceConfigurationInstanceDetailsSecondaryVnicArgs',
    'InstanceConfigurationInstanceDetailsSecondaryVnicCreateVnicDetailsArgs',
    'InstanceConfigurationInstanceDetailsSecondaryVnicCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs',
    'InstanceCreateVnicDetailsArgs',
    'InstanceCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs',
    'InstanceInstanceOptionsArgs',
    'InstanceLaunchOptionsArgs',
    'InstancePlatformConfigArgs',
    'InstancePoolInstanceLoadBalancerBackendArgs',
    'InstancePoolLoadBalancerArgs',
    'InstancePoolPlacementConfigurationArgs',
    'InstancePoolPlacementConfigurationPrimaryVnicSubnetsArgs',
    'InstancePoolPlacementConfigurationPrimaryVnicSubnetsIpv6addressIpv6subnetCidrPairDetailArgs',
    'InstancePoolPlacementConfigurationSecondaryVnicSubnetArgs',
    'InstancePoolPlacementConfigurationSecondaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs',
    'InstancePreemptibleInstanceConfigArgs',
    'InstancePreemptibleInstanceConfigPreemptionActionArgs',
    'InstanceShapeConfigArgs',
    'InstanceSourceDetailsArgs',
    'InstanceSourceDetailsInstanceSourceImageFilterDetailsArgs',
    'IpsecConnectionTunnelManagementBgpSessionInfoArgs',
    'IpsecConnectionTunnelManagementDpdConfigArgs',
    'IpsecConnectionTunnelManagementEncryptionDomainConfigArgs',
    'IpsecConnectionTunnelManagementPhaseOneDetailArgs',
    'IpsecConnectionTunnelManagementPhaseTwoDetailArgs',
    'NetworkSecurityGroupSecurityRuleIcmpOptionsArgs',
    'NetworkSecurityGroupSecurityRuleTcpOptionsArgs',
    'NetworkSecurityGroupSecurityRuleTcpOptionsDestinationPortRangeArgs',
    'NetworkSecurityGroupSecurityRuleTcpOptionsSourcePortRangeArgs',
    'NetworkSecurityGroupSecurityRuleUdpOptionsArgs',
    'NetworkSecurityGroupSecurityRuleUdpOptionsDestinationPortRangeArgs',
    'NetworkSecurityGroupSecurityRuleUdpOptionsSourcePortRangeArgs',
    'RouteTableRouteRuleArgs',
    'SecurityListEgressSecurityRuleArgs',
    'SecurityListEgressSecurityRuleIcmpOptionsArgs',
    'SecurityListEgressSecurityRuleTcpOptionsArgs',
    'SecurityListEgressSecurityRuleTcpOptionsSourcePortRangeArgs',
    'SecurityListEgressSecurityRuleUdpOptionsArgs',
    'SecurityListEgressSecurityRuleUdpOptionsSourcePortRangeArgs',
    'SecurityListIngressSecurityRuleArgs',
    'SecurityListIngressSecurityRuleIcmpOptionsArgs',
    'SecurityListIngressSecurityRuleTcpOptionsArgs',
    'SecurityListIngressSecurityRuleTcpOptionsSourcePortRangeArgs',
    'SecurityListIngressSecurityRuleUdpOptionsArgs',
    'SecurityListIngressSecurityRuleUdpOptionsSourcePortRangeArgs',
    'ServiceGatewayServiceArgs',
    'VcnByoipv6cidrDetailArgs',
    'VirtualCircuitCrossConnectMappingArgs',
    'VirtualCircuitPublicPrefixArgs',
    'VirtualNetworkByoipv6cidrDetailArgs',
    'VnicAttachmentCreateVnicDetailsArgs',
    'VnicAttachmentCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs',
    'VolumeAttachmentMultipathDeviceArgs',
    'VolumeAutotunePolicyArgs',
    'VolumeBackupPolicyScheduleArgs',
    'VolumeBackupSourceDetailsArgs',
    'VolumeBlockVolumeReplicaArgs',
    'VolumeGroupBackupSourceDetailsArgs',
    'VolumeGroupSourceDetailsArgs',
    'VolumeGroupVolumeGroupReplicaArgs',
    'VolumeSourceDetailsArgs',
    'GetAppCatalogListingResourceVersionsFilterArgs',
    'GetAppCatalogListingsFilterArgs',
    'GetAppCatalogSubscriptionsFilterArgs',
    'GetBlockVolumeReplicasFilterArgs',
    'GetBootVolumeAttachmentsFilterArgs',
    'GetBootVolumeBackupsFilterArgs',
    'GetBootVolumeReplicasFilterArgs',
    'GetBootVolumesFilterArgs',
    'GetByoipAllocatedRangesFilterArgs',
    'GetByoipRangesFilterArgs',
    'GetCaptureFiltersFilterArgs',
    'GetClusterNetworkInstancesFilterArgs',
    'GetClusterNetworksFilterArgs',
    'GetComputeCapacityReservationInstanceShapesFilterArgs',
    'GetComputeCapacityReservationInstancesFilterArgs',
    'GetComputeCapacityReservationsFilterArgs',
    'GetComputeClustersFilterArgs',
    'GetComputeGlobalImageCapabilitySchemasFilterArgs',
    'GetComputeGlobalImageCapabilitySchemasVersionsFilterArgs',
    'GetComputeImageCapabilitySchemasFilterArgs',
    'GetConsoleHistoriesFilterArgs',
    'GetCpeDeviceShapesFilterArgs',
    'GetCpesFilterArgs',
    'GetCrossConnectGroupsFilterArgs',
    'GetCrossConnectLocationsFilterArgs',
    'GetCrossConnectPortSpeedShapeFilterArgs',
    'GetCrossConnectsFilterArgs',
    'GetDedicatedVmHostInstanceShapesFilterArgs',
    'GetDedicatedVmHostInstancesFilterArgs',
    'GetDedicatedVmHostShapesFilterArgs',
    'GetDedicatedVmHostsFilterArgs',
    'GetDhcpOptionsFilterArgs',
    'GetDrgAttachmentsFilterArgs',
    'GetDrgRouteDistributionStatementsFilterArgs',
    'GetDrgRouteDistributionsFilterArgs',
    'GetDrgRouteTableRouteRulesFilterArgs',
    'GetDrgRouteTablesFilterArgs',
    'GetDrgsFilterArgs',
    'GetFastConnectProviderServicesFilterArgs',
    'GetImageShapesFilterArgs',
    'GetImagesFilterArgs',
    'GetInstanceConfigurationsFilterArgs',
    'GetInstanceConsoleConnectionsFilterArgs',
    'GetInstanceDevicesFilterArgs',
    'GetInstancePoolInstancesFilterArgs',
    'GetInstancePoolsFilterArgs',
    'GetInstancesFilterArgs',
    'GetInternetGatewaysFilterArgs',
    'GetIpsecConfigFilterArgs',
    'GetIpsecConnectionTunnelRoutesFilterArgs',
    'GetIpsecConnectionTunnelsFilterArgs',
    'GetIpsecConnectionsFilterArgs',
    'GetIpsecStatusFilterArgs',
    'GetIpv6sFilterArgs',
    'GetListingResourceVersionsFilterArgs',
    'GetLocalPeeringGatewaysFilterArgs',
    'GetNatGatewaysFilterArgs',
    'GetNetworkSecurityGroupSecurityRulesFilterArgs',
    'GetNetworkSecurityGroupVnicsFilterArgs',
    'GetNetworkSecurityGroupsFilterArgs',
    'GetPeerRegionForRemotePeeringsFilterArgs',
    'GetPrivateIpsFilterArgs',
    'GetPublicIpPoolsFilterArgs',
    'GetPublicIpsFilterArgs',
    'GetRemotePeeringConnectionsFilterArgs',
    'GetRouteTablesFilterArgs',
    'GetSecurityListsFilterArgs',
    'GetServiceGatewaysFilterArgs',
    'GetServicesFilterArgs',
    'GetShapeFilterArgs',
    'GetShapesFilterArgs',
    'GetSubnetsFilterArgs',
    'GetTunnelSecurityAssociationsFilterArgs',
    'GetVcnsFilterArgs',
    'GetVirtualCircuitAssociatedTunnelsFilterArgs',
    'GetVirtualCircuitBandwidthShapesFilterArgs',
    'GetVirtualCircuitPublicPrefixesFilterArgs',
    'GetVirtualCircuitsFilterArgs',
    'GetVirtualNetworksFilterArgs',
    'GetVlansFilterArgs',
    'GetVnicAttachmentsFilterArgs',
    'GetVolumeAttachmentsFilterArgs',
    'GetVolumeBackupPoliciesFilterArgs',
    'GetVolumeBackupPolicyAssignmentsFilterArgs',
    'GetVolumeBackupsFilterArgs',
    'GetVolumeGroupBackupsFilterArgs',
    'GetVolumeGroupReplicasFilterArgs',
    'GetVolumeGroupsFilterArgs',
    'GetVolumesFilterArgs',
    'GetVtapsFilterArgs',
]

@pulumi.input_type
class BootVolumeAutotunePolicyArgs:
    def __init__(__self__, *,
                 autotune_type: pulumi.Input[str],
                 max_vpus_per_gb: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] autotune_type: (Updatable) This specifies the type of autotunes supported by OCI.
        :param pulumi.Input[str] max_vpus_per_gb: (Updatable) This will be the maximum VPUs/GB performance level that the volume will be auto-tuned temporarily based on performance monitoring.
        """
        BootVolumeAutotunePolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autotune_type=autotune_type,
            max_vpus_per_gb=max_vpus_per_gb,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autotune_type: pulumi.Input[str],
             max_vpus_per_gb: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("autotune_type", autotune_type)
        if max_vpus_per_gb is not None:
            _setter("max_vpus_per_gb", max_vpus_per_gb)

    @property
    @pulumi.getter(name="autotuneType")
    def autotune_type(self) -> pulumi.Input[str]:
        """
        (Updatable) This specifies the type of autotunes supported by OCI.
        """
        return pulumi.get(self, "autotune_type")

    @autotune_type.setter
    def autotune_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "autotune_type", value)

    @property
    @pulumi.getter(name="maxVpusPerGb")
    def max_vpus_per_gb(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) This will be the maximum VPUs/GB performance level that the volume will be auto-tuned temporarily based on performance monitoring.
        """
        return pulumi.get(self, "max_vpus_per_gb")

    @max_vpus_per_gb.setter
    def max_vpus_per_gb(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_vpus_per_gb", value)


@pulumi.input_type
class BootVolumeBackupSourceDetailsArgs:
    def __init__(__self__, *,
                 boot_volume_backup_id: pulumi.Input[str],
                 region: pulumi.Input[str],
                 kms_key_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] region: The region of the volume backup source.
        :param pulumi.Input[str] kms_key_id: The OCID of the KMS key in the destination region which will be the master encryption key for the copied volume backup.
        """
        BootVolumeBackupSourceDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            boot_volume_backup_id=boot_volume_backup_id,
            region=region,
            kms_key_id=kms_key_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             boot_volume_backup_id: pulumi.Input[str],
             region: pulumi.Input[str],
             kms_key_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("boot_volume_backup_id", boot_volume_backup_id)
        _setter("region", region)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)

    @property
    @pulumi.getter(name="bootVolumeBackupId")
    def boot_volume_backup_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "boot_volume_backup_id")

    @boot_volume_backup_id.setter
    def boot_volume_backup_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "boot_volume_backup_id", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        The region of the volume backup source.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the KMS key in the destination region which will be the master encryption key for the copied volume backup.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)


@pulumi.input_type
class BootVolumeBootVolumeReplicaArgs:
    def __init__(__self__, *,
                 availability_domain: pulumi.Input[str],
                 boot_volume_replica_id: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] availability_domain: (Updatable) The availability domain of the boot volume replica.  Example: `Uocm:PHX-AD-1`
        :param pulumi.Input[str] boot_volume_replica_id: The boot volume replica's Oracle ID (OCID).
        :param pulumi.Input[str] display_name: (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        """
        BootVolumeBootVolumeReplicaArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_domain=availability_domain,
            boot_volume_replica_id=boot_volume_replica_id,
            display_name=display_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_domain: pulumi.Input[str],
             boot_volume_replica_id: Optional[pulumi.Input[str]] = None,
             display_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("availability_domain", availability_domain)
        if boot_volume_replica_id is not None:
            _setter("boot_volume_replica_id", boot_volume_replica_id)
        if display_name is not None:
            _setter("display_name", display_name)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> pulumi.Input[str]:
        """
        (Updatable) The availability domain of the boot volume replica.  Example: `Uocm:PHX-AD-1`
        """
        return pulumi.get(self, "availability_domain")

    @availability_domain.setter
    def availability_domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "availability_domain", value)

    @property
    @pulumi.getter(name="bootVolumeReplicaId")
    def boot_volume_replica_id(self) -> Optional[pulumi.Input[str]]:
        """
        The boot volume replica's Oracle ID (OCID).
        """
        return pulumi.get(self, "boot_volume_replica_id")

    @boot_volume_replica_id.setter
    def boot_volume_replica_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "boot_volume_replica_id", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


@pulumi.input_type
class BootVolumeSourceDetailsArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The OCID of the boot volume replica.
        :param pulumi.Input[str] type: The type can be one of these values: `bootVolume`, `bootVolumeBackup`, `bootVolumeReplica`
        """
        BootVolumeSourceDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: pulumi.Input[str],
             type: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("type", type)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The OCID of the boot volume replica.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type can be one of these values: `bootVolume`, `bootVolumeBackup`, `bootVolumeReplica`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class CaptureFilterVtapCaptureFilterRuleArgs:
    def __init__(__self__, *,
                 traffic_direction: pulumi.Input[str],
                 destination_cidr: Optional[pulumi.Input[str]] = None,
                 icmp_options: Optional[pulumi.Input['CaptureFilterVtapCaptureFilterRuleIcmpOptionsArgs']] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 rule_action: Optional[pulumi.Input[str]] = None,
                 source_cidr: Optional[pulumi.Input[str]] = None,
                 tcp_options: Optional[pulumi.Input['CaptureFilterVtapCaptureFilterRuleTcpOptionsArgs']] = None,
                 udp_options: Optional[pulumi.Input['CaptureFilterVtapCaptureFilterRuleUdpOptionsArgs']] = None):
        """
        :param pulumi.Input[str] traffic_direction: (Updatable) The traffic direction the VTAP is configured to mirror.
        :param pulumi.Input[str] destination_cidr: (Updatable) Traffic sent to this CIDR block through the VTAP source will be mirrored to the VTAP target.
        :param pulumi.Input['CaptureFilterVtapCaptureFilterRuleIcmpOptionsArgs'] icmp_options: (Updatable) Optional and valid only for ICMP and ICMPv6. Use to specify a particular ICMP type and code as defined in:
               * [ICMP Parameters](http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml)
               * [ICMPv6 Parameters](https://www.iana.org/assignments/icmpv6-parameters/icmpv6-parameters.xhtml)
               
               If you specify ICMP or ICMPv6 as the protocol but omit this object, then all ICMP types and codes are allowed. If you do provide this object, the type is required and the code is optional. To enable MTU negotiation for ingress internet traffic via IPv4, make sure to allow type 3 ("Destination Unreachable") code 4 ("Fragmentation Needed and Don't Fragment was Set"). If you need to specify multiple codes for a single type, create a separate security list rule for each.
        :param pulumi.Input[str] protocol: (Updatable) The transport protocol used in the filter. If do not choose a protocol, all protocols will be used in the filter. Supported options are:
               * 1 = ICMP
               * 6 = TCP
               * 17 = UDP
        :param pulumi.Input[str] rule_action: (Updatable) Include or exclude packets meeting this definition from mirrored traffic.
        :param pulumi.Input[str] source_cidr: (Updatable) Traffic from this CIDR block to the VTAP source will be mirrored to the VTAP target.
        :param pulumi.Input['CaptureFilterVtapCaptureFilterRuleTcpOptionsArgs'] tcp_options: (Updatable) Optional and valid only for TCP. Use to specify particular destination ports for TCP rules. If you specify TCP as the protocol but omit this object, then all destination ports are allowed.
        :param pulumi.Input['CaptureFilterVtapCaptureFilterRuleUdpOptionsArgs'] udp_options: (Updatable) Optional and valid only for UDP. Use to specify particular destination ports for UDP rules. If you specify UDP as the protocol but omit this object, then all destination ports are allowed.
        """
        CaptureFilterVtapCaptureFilterRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            traffic_direction=traffic_direction,
            destination_cidr=destination_cidr,
            icmp_options=icmp_options,
            protocol=protocol,
            rule_action=rule_action,
            source_cidr=source_cidr,
            tcp_options=tcp_options,
            udp_options=udp_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             traffic_direction: pulumi.Input[str],
             destination_cidr: Optional[pulumi.Input[str]] = None,
             icmp_options: Optional[pulumi.Input['CaptureFilterVtapCaptureFilterRuleIcmpOptionsArgs']] = None,
             protocol: Optional[pulumi.Input[str]] = None,
             rule_action: Optional[pulumi.Input[str]] = None,
             source_cidr: Optional[pulumi.Input[str]] = None,
             tcp_options: Optional[pulumi.Input['CaptureFilterVtapCaptureFilterRuleTcpOptionsArgs']] = None,
             udp_options: Optional[pulumi.Input['CaptureFilterVtapCaptureFilterRuleUdpOptionsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("traffic_direction", traffic_direction)
        if destination_cidr is not None:
            _setter("destination_cidr", destination_cidr)
        if icmp_options is not None:
            _setter("icmp_options", icmp_options)
        if protocol is not None:
            _setter("protocol", protocol)
        if rule_action is not None:
            _setter("rule_action", rule_action)
        if source_cidr is not None:
            _setter("source_cidr", source_cidr)
        if tcp_options is not None:
            _setter("tcp_options", tcp_options)
        if udp_options is not None:
            _setter("udp_options", udp_options)

    @property
    @pulumi.getter(name="trafficDirection")
    def traffic_direction(self) -> pulumi.Input[str]:
        """
        (Updatable) The traffic direction the VTAP is configured to mirror.
        """
        return pulumi.get(self, "traffic_direction")

    @traffic_direction.setter
    def traffic_direction(self, value: pulumi.Input[str]):
        pulumi.set(self, "traffic_direction", value)

    @property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Traffic sent to this CIDR block through the VTAP source will be mirrored to the VTAP target.
        """
        return pulumi.get(self, "destination_cidr")

    @destination_cidr.setter
    def destination_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_cidr", value)

    @property
    @pulumi.getter(name="icmpOptions")
    def icmp_options(self) -> Optional[pulumi.Input['CaptureFilterVtapCaptureFilterRuleIcmpOptionsArgs']]:
        """
        (Updatable) Optional and valid only for ICMP and ICMPv6. Use to specify a particular ICMP type and code as defined in:
        * [ICMP Parameters](http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml)
        * [ICMPv6 Parameters](https://www.iana.org/assignments/icmpv6-parameters/icmpv6-parameters.xhtml)

        If you specify ICMP or ICMPv6 as the protocol but omit this object, then all ICMP types and codes are allowed. If you do provide this object, the type is required and the code is optional. To enable MTU negotiation for ingress internet traffic via IPv4, make sure to allow type 3 ("Destination Unreachable") code 4 ("Fragmentation Needed and Don't Fragment was Set"). If you need to specify multiple codes for a single type, create a separate security list rule for each.
        """
        return pulumi.get(self, "icmp_options")

    @icmp_options.setter
    def icmp_options(self, value: Optional[pulumi.Input['CaptureFilterVtapCaptureFilterRuleIcmpOptionsArgs']]):
        pulumi.set(self, "icmp_options", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The transport protocol used in the filter. If do not choose a protocol, all protocols will be used in the filter. Supported options are:
        * 1 = ICMP
        * 6 = TCP
        * 17 = UDP
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="ruleAction")
    def rule_action(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Include or exclude packets meeting this definition from mirrored traffic.
        """
        return pulumi.get(self, "rule_action")

    @rule_action.setter
    def rule_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rule_action", value)

    @property
    @pulumi.getter(name="sourceCidr")
    def source_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Traffic from this CIDR block to the VTAP source will be mirrored to the VTAP target.
        """
        return pulumi.get(self, "source_cidr")

    @source_cidr.setter
    def source_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_cidr", value)

    @property
    @pulumi.getter(name="tcpOptions")
    def tcp_options(self) -> Optional[pulumi.Input['CaptureFilterVtapCaptureFilterRuleTcpOptionsArgs']]:
        """
        (Updatable) Optional and valid only for TCP. Use to specify particular destination ports for TCP rules. If you specify TCP as the protocol but omit this object, then all destination ports are allowed.
        """
        return pulumi.get(self, "tcp_options")

    @tcp_options.setter
    def tcp_options(self, value: Optional[pulumi.Input['CaptureFilterVtapCaptureFilterRuleTcpOptionsArgs']]):
        pulumi.set(self, "tcp_options", value)

    @property
    @pulumi.getter(name="udpOptions")
    def udp_options(self) -> Optional[pulumi.Input['CaptureFilterVtapCaptureFilterRuleUdpOptionsArgs']]:
        """
        (Updatable) Optional and valid only for UDP. Use to specify particular destination ports for UDP rules. If you specify UDP as the protocol but omit this object, then all destination ports are allowed.
        """
        return pulumi.get(self, "udp_options")

    @udp_options.setter
    def udp_options(self, value: Optional[pulumi.Input['CaptureFilterVtapCaptureFilterRuleUdpOptionsArgs']]):
        pulumi.set(self, "udp_options", value)


@pulumi.input_type
class CaptureFilterVtapCaptureFilterRuleIcmpOptionsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[int],
                 code: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] type: (Updatable) The ICMP type.
        :param pulumi.Input[int] code: (Updatable) The ICMP code (optional).
        """
        CaptureFilterVtapCaptureFilterRuleIcmpOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            code=code,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[int],
             code: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if code is not None:
            _setter("code", code)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[int]:
        """
        (Updatable) The ICMP type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[int]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The ICMP code (optional).
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)


@pulumi.input_type
class CaptureFilterVtapCaptureFilterRuleTcpOptionsArgs:
    def __init__(__self__, *,
                 destination_port_range: Optional[pulumi.Input['CaptureFilterVtapCaptureFilterRuleTcpOptionsDestinationPortRangeArgs']] = None,
                 source_port_range: Optional[pulumi.Input['CaptureFilterVtapCaptureFilterRuleTcpOptionsSourcePortRangeArgs']] = None):
        """
        :param pulumi.Input['CaptureFilterVtapCaptureFilterRuleTcpOptionsDestinationPortRangeArgs'] destination_port_range: (Updatable)
        :param pulumi.Input['CaptureFilterVtapCaptureFilterRuleTcpOptionsSourcePortRangeArgs'] source_port_range: (Updatable)
        """
        CaptureFilterVtapCaptureFilterRuleTcpOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_port_range=destination_port_range,
            source_port_range=source_port_range,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_port_range: Optional[pulumi.Input['CaptureFilterVtapCaptureFilterRuleTcpOptionsDestinationPortRangeArgs']] = None,
             source_port_range: Optional[pulumi.Input['CaptureFilterVtapCaptureFilterRuleTcpOptionsSourcePortRangeArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if destination_port_range is not None:
            _setter("destination_port_range", destination_port_range)
        if source_port_range is not None:
            _setter("source_port_range", source_port_range)

    @property
    @pulumi.getter(name="destinationPortRange")
    def destination_port_range(self) -> Optional[pulumi.Input['CaptureFilterVtapCaptureFilterRuleTcpOptionsDestinationPortRangeArgs']]:
        """
        (Updatable)
        """
        return pulumi.get(self, "destination_port_range")

    @destination_port_range.setter
    def destination_port_range(self, value: Optional[pulumi.Input['CaptureFilterVtapCaptureFilterRuleTcpOptionsDestinationPortRangeArgs']]):
        pulumi.set(self, "destination_port_range", value)

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional[pulumi.Input['CaptureFilterVtapCaptureFilterRuleTcpOptionsSourcePortRangeArgs']]:
        """
        (Updatable)
        """
        return pulumi.get(self, "source_port_range")

    @source_port_range.setter
    def source_port_range(self, value: Optional[pulumi.Input['CaptureFilterVtapCaptureFilterRuleTcpOptionsSourcePortRangeArgs']]):
        pulumi.set(self, "source_port_range", value)


@pulumi.input_type
class CaptureFilterVtapCaptureFilterRuleTcpOptionsDestinationPortRangeArgs:
    def __init__(__self__, *,
                 max: pulumi.Input[int],
                 min: pulumi.Input[int]):
        """
        :param pulumi.Input[int] max: (Updatable) The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        :param pulumi.Input[int] min: (Updatable) The minimum port number, which must not be greater than the maximum port number. 
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        CaptureFilterVtapCaptureFilterRuleTcpOptionsDestinationPortRangeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: pulumi.Input[int],
             min: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("max", max)
        _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> pulumi.Input[int]:
        """
        (Updatable) The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[int]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> pulumi.Input[int]:
        """
        (Updatable) The minimum port number, which must not be greater than the maximum port number. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[int]):
        pulumi.set(self, "min", value)


@pulumi.input_type
class CaptureFilterVtapCaptureFilterRuleTcpOptionsSourcePortRangeArgs:
    def __init__(__self__, *,
                 max: pulumi.Input[int],
                 min: pulumi.Input[int]):
        """
        :param pulumi.Input[int] max: (Updatable) The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        :param pulumi.Input[int] min: (Updatable) The minimum port number, which must not be greater than the maximum port number. 
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        CaptureFilterVtapCaptureFilterRuleTcpOptionsSourcePortRangeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: pulumi.Input[int],
             min: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("max", max)
        _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> pulumi.Input[int]:
        """
        (Updatable) The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[int]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> pulumi.Input[int]:
        """
        (Updatable) The minimum port number, which must not be greater than the maximum port number. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[int]):
        pulumi.set(self, "min", value)


@pulumi.input_type
class CaptureFilterVtapCaptureFilterRuleUdpOptionsArgs:
    def __init__(__self__, *,
                 destination_port_range: Optional[pulumi.Input['CaptureFilterVtapCaptureFilterRuleUdpOptionsDestinationPortRangeArgs']] = None,
                 source_port_range: Optional[pulumi.Input['CaptureFilterVtapCaptureFilterRuleUdpOptionsSourcePortRangeArgs']] = None):
        """
        :param pulumi.Input['CaptureFilterVtapCaptureFilterRuleUdpOptionsDestinationPortRangeArgs'] destination_port_range: (Updatable)
        :param pulumi.Input['CaptureFilterVtapCaptureFilterRuleUdpOptionsSourcePortRangeArgs'] source_port_range: (Updatable)
        """
        CaptureFilterVtapCaptureFilterRuleUdpOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_port_range=destination_port_range,
            source_port_range=source_port_range,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_port_range: Optional[pulumi.Input['CaptureFilterVtapCaptureFilterRuleUdpOptionsDestinationPortRangeArgs']] = None,
             source_port_range: Optional[pulumi.Input['CaptureFilterVtapCaptureFilterRuleUdpOptionsSourcePortRangeArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if destination_port_range is not None:
            _setter("destination_port_range", destination_port_range)
        if source_port_range is not None:
            _setter("source_port_range", source_port_range)

    @property
    @pulumi.getter(name="destinationPortRange")
    def destination_port_range(self) -> Optional[pulumi.Input['CaptureFilterVtapCaptureFilterRuleUdpOptionsDestinationPortRangeArgs']]:
        """
        (Updatable)
        """
        return pulumi.get(self, "destination_port_range")

    @destination_port_range.setter
    def destination_port_range(self, value: Optional[pulumi.Input['CaptureFilterVtapCaptureFilterRuleUdpOptionsDestinationPortRangeArgs']]):
        pulumi.set(self, "destination_port_range", value)

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional[pulumi.Input['CaptureFilterVtapCaptureFilterRuleUdpOptionsSourcePortRangeArgs']]:
        """
        (Updatable)
        """
        return pulumi.get(self, "source_port_range")

    @source_port_range.setter
    def source_port_range(self, value: Optional[pulumi.Input['CaptureFilterVtapCaptureFilterRuleUdpOptionsSourcePortRangeArgs']]):
        pulumi.set(self, "source_port_range", value)


@pulumi.input_type
class CaptureFilterVtapCaptureFilterRuleUdpOptionsDestinationPortRangeArgs:
    def __init__(__self__, *,
                 max: pulumi.Input[int],
                 min: pulumi.Input[int]):
        """
        :param pulumi.Input[int] max: (Updatable) The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        :param pulumi.Input[int] min: (Updatable) The minimum port number, which must not be greater than the maximum port number. 
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        CaptureFilterVtapCaptureFilterRuleUdpOptionsDestinationPortRangeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: pulumi.Input[int],
             min: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("max", max)
        _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> pulumi.Input[int]:
        """
        (Updatable) The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[int]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> pulumi.Input[int]:
        """
        (Updatable) The minimum port number, which must not be greater than the maximum port number. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[int]):
        pulumi.set(self, "min", value)


@pulumi.input_type
class CaptureFilterVtapCaptureFilterRuleUdpOptionsSourcePortRangeArgs:
    def __init__(__self__, *,
                 max: pulumi.Input[int],
                 min: pulumi.Input[int]):
        """
        :param pulumi.Input[int] max: (Updatable) The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        :param pulumi.Input[int] min: (Updatable) The minimum port number, which must not be greater than the maximum port number. 
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        CaptureFilterVtapCaptureFilterRuleUdpOptionsSourcePortRangeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: pulumi.Input[int],
             min: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("max", max)
        _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> pulumi.Input[int]:
        """
        (Updatable) The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[int]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> pulumi.Input[int]:
        """
        (Updatable) The minimum port number, which must not be greater than the maximum port number. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[int]):
        pulumi.set(self, "min", value)


@pulumi.input_type
class ClusterNetworkClusterConfigurationArgs:
    def __init__(__self__, *,
                 hpc_island_id: pulumi.Input[str],
                 network_block_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] hpc_island_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the HPC island.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] network_block_ids: The list of network block OCIDs.
        """
        ClusterNetworkClusterConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hpc_island_id=hpc_island_id,
            network_block_ids=network_block_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hpc_island_id: pulumi.Input[str],
             network_block_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("hpc_island_id", hpc_island_id)
        if network_block_ids is not None:
            _setter("network_block_ids", network_block_ids)

    @property
    @pulumi.getter(name="hpcIslandId")
    def hpc_island_id(self) -> pulumi.Input[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the HPC island.
        """
        return pulumi.get(self, "hpc_island_id")

    @hpc_island_id.setter
    def hpc_island_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "hpc_island_id", value)

    @property
    @pulumi.getter(name="networkBlockIds")
    def network_block_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of network block OCIDs.
        """
        return pulumi.get(self, "network_block_ids")

    @network_block_ids.setter
    def network_block_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "network_block_ids", value)


@pulumi.input_type
class ClusterNetworkInstancePoolArgs:
    def __init__(__self__, *,
                 instance_configuration_id: pulumi.Input[str],
                 size: pulumi.Input[int],
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 instance_display_name_formatter: Optional[pulumi.Input[str]] = None,
                 instance_hostname_formatter: Optional[pulumi.Input[str]] = None,
                 load_balancers: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkInstancePoolLoadBalancerArgs']]]] = None,
                 placement_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkInstancePoolPlacementConfigurationArgs']]]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] instance_configuration_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the instance configuration associated with the instance pool.
        :param pulumi.Input[int] size: (Updatable) The number of instances that should be in the instance pool.
        :param pulumi.Input[str] compartment_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment containing the instance pool.
        :param pulumi.Input[Mapping[str, Any]] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        :param pulumi.Input[str] display_name: The display name of the VNIC. This is also used to match against the instance configuration defined secondary VNIC.
        :param pulumi.Input[Mapping[str, Any]] freeform_tags: (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the load balancer attachment.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterNetworkInstancePoolLoadBalancerArgs']]] load_balancers: The load balancers attached to the instance pool.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterNetworkInstancePoolPlacementConfigurationArgs']]] placement_configurations: The placement configurations for the instance pool.
        :param pulumi.Input[str] state: The current state of the cluster network.
        :param pulumi.Input[str] time_created: The date and time the resource was created, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).  Example: `2016-08-25T21:10:29.600Z`
        """
        ClusterNetworkInstancePoolArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_configuration_id=instance_configuration_id,
            size=size,
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            instance_display_name_formatter=instance_display_name_formatter,
            instance_hostname_formatter=instance_hostname_formatter,
            load_balancers=load_balancers,
            placement_configurations=placement_configurations,
            state=state,
            time_created=time_created,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_configuration_id: pulumi.Input[str],
             size: pulumi.Input[int],
             compartment_id: Optional[pulumi.Input[str]] = None,
             defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             display_name: Optional[pulumi.Input[str]] = None,
             freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             id: Optional[pulumi.Input[str]] = None,
             instance_display_name_formatter: Optional[pulumi.Input[str]] = None,
             instance_hostname_formatter: Optional[pulumi.Input[str]] = None,
             load_balancers: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkInstancePoolLoadBalancerArgs']]]] = None,
             placement_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkInstancePoolPlacementConfigurationArgs']]]] = None,
             state: Optional[pulumi.Input[str]] = None,
             time_created: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("instance_configuration_id", instance_configuration_id)
        _setter("size", size)
        if compartment_id is not None:
            _setter("compartment_id", compartment_id)
        if defined_tags is not None:
            _setter("defined_tags", defined_tags)
        if display_name is not None:
            _setter("display_name", display_name)
        if freeform_tags is not None:
            _setter("freeform_tags", freeform_tags)
        if id is not None:
            _setter("id", id)
        if instance_display_name_formatter is not None:
            _setter("instance_display_name_formatter", instance_display_name_formatter)
        if instance_hostname_formatter is not None:
            _setter("instance_hostname_formatter", instance_hostname_formatter)
        if load_balancers is not None:
            _setter("load_balancers", load_balancers)
        if placement_configurations is not None:
            _setter("placement_configurations", placement_configurations)
        if state is not None:
            _setter("state", state)
        if time_created is not None:
            _setter("time_created", time_created)

    @property
    @pulumi.getter(name="instanceConfigurationId")
    def instance_configuration_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the instance configuration associated with the instance pool.
        """
        return pulumi.get(self, "instance_configuration_id")

    @instance_configuration_id.setter
    def instance_configuration_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_configuration_id", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        (Updatable) The number of instances that should be in the instance pool.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment containing the instance pool.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        The display name of the VNIC. This is also used to match against the instance configuration defined secondary VNIC.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the load balancer attachment.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="instanceDisplayNameFormatter")
    def instance_display_name_formatter(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "instance_display_name_formatter")

    @instance_display_name_formatter.setter
    def instance_display_name_formatter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_display_name_formatter", value)

    @property
    @pulumi.getter(name="instanceHostnameFormatter")
    def instance_hostname_formatter(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "instance_hostname_formatter")

    @instance_hostname_formatter.setter
    def instance_hostname_formatter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_hostname_formatter", value)

    @property
    @pulumi.getter(name="loadBalancers")
    def load_balancers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkInstancePoolLoadBalancerArgs']]]]:
        """
        The load balancers attached to the instance pool.
        """
        return pulumi.get(self, "load_balancers")

    @load_balancers.setter
    def load_balancers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkInstancePoolLoadBalancerArgs']]]]):
        pulumi.set(self, "load_balancers", value)

    @property
    @pulumi.getter(name="placementConfigurations")
    def placement_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkInstancePoolPlacementConfigurationArgs']]]]:
        """
        The placement configurations for the instance pool.
        """
        return pulumi.get(self, "placement_configurations")

    @placement_configurations.setter
    def placement_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkInstancePoolPlacementConfigurationArgs']]]]):
        pulumi.set(self, "placement_configurations", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the cluster network.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the resource was created, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).  Example: `2016-08-25T21:10:29.600Z`
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)


@pulumi.input_type
class ClusterNetworkInstancePoolLoadBalancerArgs:
    def __init__(__self__, *,
                 backend_set_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 instance_pool_id: Optional[pulumi.Input[str]] = None,
                 load_balancer_id: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 vnic_selection: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] backend_set_name: The name of the backend set on the load balancer.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the load balancer attachment.
        :param pulumi.Input[str] instance_pool_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the instance pool of the load balancer attachment.
        :param pulumi.Input[str] load_balancer_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the load balancer attached to the instance pool.
        :param pulumi.Input[int] port: The port value used for the backends.
        :param pulumi.Input[str] state: The current state of the cluster network.
        :param pulumi.Input[str] vnic_selection: Indicates which VNIC on each instance in the instance pool should be used to associate with the load balancer. Possible values are "PrimaryVnic" or the displayName of one of the secondary VNICs on the instance configuration that is associated with the instance pool.
        """
        ClusterNetworkInstancePoolLoadBalancerArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backend_set_name=backend_set_name,
            id=id,
            instance_pool_id=instance_pool_id,
            load_balancer_id=load_balancer_id,
            port=port,
            state=state,
            vnic_selection=vnic_selection,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backend_set_name: Optional[pulumi.Input[str]] = None,
             id: Optional[pulumi.Input[str]] = None,
             instance_pool_id: Optional[pulumi.Input[str]] = None,
             load_balancer_id: Optional[pulumi.Input[str]] = None,
             port: Optional[pulumi.Input[int]] = None,
             state: Optional[pulumi.Input[str]] = None,
             vnic_selection: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if backend_set_name is not None:
            _setter("backend_set_name", backend_set_name)
        if id is not None:
            _setter("id", id)
        if instance_pool_id is not None:
            _setter("instance_pool_id", instance_pool_id)
        if load_balancer_id is not None:
            _setter("load_balancer_id", load_balancer_id)
        if port is not None:
            _setter("port", port)
        if state is not None:
            _setter("state", state)
        if vnic_selection is not None:
            _setter("vnic_selection", vnic_selection)

    @property
    @pulumi.getter(name="backendSetName")
    def backend_set_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the backend set on the load balancer.
        """
        return pulumi.get(self, "backend_set_name")

    @backend_set_name.setter
    def backend_set_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backend_set_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the load balancer attachment.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the instance pool of the load balancer attachment.
        """
        return pulumi.get(self, "instance_pool_id")

    @instance_pool_id.setter
    def instance_pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_pool_id", value)

    @property
    @pulumi.getter(name="loadBalancerId")
    def load_balancer_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the load balancer attached to the instance pool.
        """
        return pulumi.get(self, "load_balancer_id")

    @load_balancer_id.setter
    def load_balancer_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancer_id", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port value used for the backends.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the cluster network.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="vnicSelection")
    def vnic_selection(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates which VNIC on each instance in the instance pool should be used to associate with the load balancer. Possible values are "PrimaryVnic" or the displayName of one of the secondary VNICs on the instance configuration that is associated with the instance pool.
        """
        return pulumi.get(self, "vnic_selection")

    @vnic_selection.setter
    def vnic_selection(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vnic_selection", value)


@pulumi.input_type
class ClusterNetworkInstancePoolPlacementConfigurationArgs:
    def __init__(__self__, *,
                 availability_domain: Optional[pulumi.Input[str]] = None,
                 fault_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 primary_subnet_id: Optional[pulumi.Input[str]] = None,
                 primary_vnic_subnets: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkInstancePoolPlacementConfigurationPrimaryVnicSubnetArgs']]]] = None,
                 secondary_vnic_subnets: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkInstancePoolPlacementConfigurationSecondaryVnicSubnetArgs']]]] = None):
        """
        :param pulumi.Input[str] availability_domain: The availability domain to place instances.  Example: `Uocm:PHX-AD-1`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] fault_domains: The fault domains to place instances.
        :param pulumi.Input[str] primary_subnet_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the primary subnet to place instances. This field is deprecated. Use `primaryVnicSubnets` instead to set VNIC data for instances in the pool.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterNetworkInstancePoolPlacementConfigurationPrimaryVnicSubnetArgs']]] primary_vnic_subnets: Details about the IPv6 primary subnet.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterNetworkInstancePoolPlacementConfigurationSecondaryVnicSubnetArgs']]] secondary_vnic_subnets: The set of secondary VNIC data for instances in the pool.
        """
        ClusterNetworkInstancePoolPlacementConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_domain=availability_domain,
            fault_domains=fault_domains,
            primary_subnet_id=primary_subnet_id,
            primary_vnic_subnets=primary_vnic_subnets,
            secondary_vnic_subnets=secondary_vnic_subnets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_domain: Optional[pulumi.Input[str]] = None,
             fault_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             primary_subnet_id: Optional[pulumi.Input[str]] = None,
             primary_vnic_subnets: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkInstancePoolPlacementConfigurationPrimaryVnicSubnetArgs']]]] = None,
             secondary_vnic_subnets: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkInstancePoolPlacementConfigurationSecondaryVnicSubnetArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if availability_domain is not None:
            _setter("availability_domain", availability_domain)
        if fault_domains is not None:
            _setter("fault_domains", fault_domains)
        if primary_subnet_id is not None:
            _setter("primary_subnet_id", primary_subnet_id)
        if primary_vnic_subnets is not None:
            _setter("primary_vnic_subnets", primary_vnic_subnets)
        if secondary_vnic_subnets is not None:
            _setter("secondary_vnic_subnets", secondary_vnic_subnets)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[pulumi.Input[str]]:
        """
        The availability domain to place instances.  Example: `Uocm:PHX-AD-1`
        """
        return pulumi.get(self, "availability_domain")

    @availability_domain.setter
    def availability_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_domain", value)

    @property
    @pulumi.getter(name="faultDomains")
    def fault_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The fault domains to place instances.
        """
        return pulumi.get(self, "fault_domains")

    @fault_domains.setter
    def fault_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "fault_domains", value)

    @property
    @pulumi.getter(name="primarySubnetId")
    def primary_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the primary subnet to place instances. This field is deprecated. Use `primaryVnicSubnets` instead to set VNIC data for instances in the pool.
        """
        return pulumi.get(self, "primary_subnet_id")

    @primary_subnet_id.setter
    def primary_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_subnet_id", value)

    @property
    @pulumi.getter(name="primaryVnicSubnets")
    def primary_vnic_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkInstancePoolPlacementConfigurationPrimaryVnicSubnetArgs']]]]:
        """
        Details about the IPv6 primary subnet.
        """
        return pulumi.get(self, "primary_vnic_subnets")

    @primary_vnic_subnets.setter
    def primary_vnic_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkInstancePoolPlacementConfigurationPrimaryVnicSubnetArgs']]]]):
        pulumi.set(self, "primary_vnic_subnets", value)

    @property
    @pulumi.getter(name="secondaryVnicSubnets")
    def secondary_vnic_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkInstancePoolPlacementConfigurationSecondaryVnicSubnetArgs']]]]:
        """
        The set of secondary VNIC data for instances in the pool.
        """
        return pulumi.get(self, "secondary_vnic_subnets")

    @secondary_vnic_subnets.setter
    def secondary_vnic_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkInstancePoolPlacementConfigurationSecondaryVnicSubnetArgs']]]]):
        pulumi.set(self, "secondary_vnic_subnets", value)


@pulumi.input_type
class ClusterNetworkInstancePoolPlacementConfigurationPrimaryVnicSubnetArgs:
    def __init__(__self__, *,
                 ipv6address_ipv6subnet_cidr_pair_details: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkInstancePoolPlacementConfigurationPrimaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs']]]] = None,
                 is_assign_ipv6ip: Optional[pulumi.Input[bool]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterNetworkInstancePoolPlacementConfigurationPrimaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs']]] ipv6address_ipv6subnet_cidr_pair_details: A list of IPv6 prefix ranges from which the VNIC should be assigned an IPv6 address. You can provide only the prefix ranges and Oracle Cloud Infrastructure will select an available address from the range. You can optionally choose to leave the prefix range empty and instead provide the specific IPv6 address that should be used from within that range.
        :param pulumi.Input[bool] is_assign_ipv6ip: Whether to allocate an IPv6 address at instance and VNIC creation from an IPv6 enabled subnet. Default: False. When provided you may optionally provide an IPv6 prefix (`ipv6SubnetCidr`) of your choice to assign the IPv6 address from. If `ipv6SubnetCidr` is not provided then an IPv6 prefix is chosen for you.
        :param pulumi.Input[str] subnet_id: The subnet [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the secondary VNIC.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        ClusterNetworkInstancePoolPlacementConfigurationPrimaryVnicSubnetArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ipv6address_ipv6subnet_cidr_pair_details=ipv6address_ipv6subnet_cidr_pair_details,
            is_assign_ipv6ip=is_assign_ipv6ip,
            subnet_id=subnet_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ipv6address_ipv6subnet_cidr_pair_details: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkInstancePoolPlacementConfigurationPrimaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs']]]] = None,
             is_assign_ipv6ip: Optional[pulumi.Input[bool]] = None,
             subnet_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ipv6address_ipv6subnet_cidr_pair_details is not None:
            _setter("ipv6address_ipv6subnet_cidr_pair_details", ipv6address_ipv6subnet_cidr_pair_details)
        if is_assign_ipv6ip is not None:
            _setter("is_assign_ipv6ip", is_assign_ipv6ip)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)

    @property
    @pulumi.getter(name="ipv6addressIpv6subnetCidrPairDetails")
    def ipv6address_ipv6subnet_cidr_pair_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkInstancePoolPlacementConfigurationPrimaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs']]]]:
        """
        A list of IPv6 prefix ranges from which the VNIC should be assigned an IPv6 address. You can provide only the prefix ranges and Oracle Cloud Infrastructure will select an available address from the range. You can optionally choose to leave the prefix range empty and instead provide the specific IPv6 address that should be used from within that range.
        """
        return pulumi.get(self, "ipv6address_ipv6subnet_cidr_pair_details")

    @ipv6address_ipv6subnet_cidr_pair_details.setter
    def ipv6address_ipv6subnet_cidr_pair_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkInstancePoolPlacementConfigurationPrimaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs']]]]):
        pulumi.set(self, "ipv6address_ipv6subnet_cidr_pair_details", value)

    @property
    @pulumi.getter(name="isAssignIpv6ip")
    def is_assign_ipv6ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allocate an IPv6 address at instance and VNIC creation from an IPv6 enabled subnet. Default: False. When provided you may optionally provide an IPv6 prefix (`ipv6SubnetCidr`) of your choice to assign the IPv6 address from. If `ipv6SubnetCidr` is not provided then an IPv6 prefix is chosen for you.
        """
        return pulumi.get(self, "is_assign_ipv6ip")

    @is_assign_ipv6ip.setter
    def is_assign_ipv6ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_assign_ipv6ip", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The subnet [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the secondary VNIC.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


@pulumi.input_type
class ClusterNetworkInstancePoolPlacementConfigurationPrimaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs:
    def __init__(__self__, *,
                 ipv6subnet_cidr: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ipv6subnet_cidr: Optional. Used to disambiguate which subnet prefix should be used to create an IPv6 allocation.
        """
        ClusterNetworkInstancePoolPlacementConfigurationPrimaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ipv6subnet_cidr=ipv6subnet_cidr,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ipv6subnet_cidr: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ipv6subnet_cidr is not None:
            _setter("ipv6subnet_cidr", ipv6subnet_cidr)

    @property
    @pulumi.getter(name="ipv6subnetCidr")
    def ipv6subnet_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Used to disambiguate which subnet prefix should be used to create an IPv6 allocation.
        """
        return pulumi.get(self, "ipv6subnet_cidr")

    @ipv6subnet_cidr.setter
    def ipv6subnet_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6subnet_cidr", value)


@pulumi.input_type
class ClusterNetworkInstancePoolPlacementConfigurationSecondaryVnicSubnetArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[str]] = None,
                 ipv6address_ipv6subnet_cidr_pair_details: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkInstancePoolPlacementConfigurationSecondaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs']]]] = None,
                 is_assign_ipv6ip: Optional[pulumi.Input[bool]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] display_name: The display name of the VNIC. This is also used to match against the instance configuration defined secondary VNIC.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterNetworkInstancePoolPlacementConfigurationSecondaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs']]] ipv6address_ipv6subnet_cidr_pair_details: A list of IPv6 prefix ranges from which the VNIC should be assigned an IPv6 address. You can provide only the prefix ranges and Oracle Cloud Infrastructure will select an available address from the range. You can optionally choose to leave the prefix range empty and instead provide the specific IPv6 address that should be used from within that range.
        :param pulumi.Input[bool] is_assign_ipv6ip: Whether to allocate an IPv6 address at instance and VNIC creation from an IPv6 enabled subnet. Default: False. When provided you may optionally provide an IPv6 prefix (`ipv6SubnetCidr`) of your choice to assign the IPv6 address from. If `ipv6SubnetCidr` is not provided then an IPv6 prefix is chosen for you.
        :param pulumi.Input[str] subnet_id: The subnet [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the secondary VNIC.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        ClusterNetworkInstancePoolPlacementConfigurationSecondaryVnicSubnetArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            ipv6address_ipv6subnet_cidr_pair_details=ipv6address_ipv6subnet_cidr_pair_details,
            is_assign_ipv6ip=is_assign_ipv6ip,
            subnet_id=subnet_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: Optional[pulumi.Input[str]] = None,
             ipv6address_ipv6subnet_cidr_pair_details: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkInstancePoolPlacementConfigurationSecondaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs']]]] = None,
             is_assign_ipv6ip: Optional[pulumi.Input[bool]] = None,
             subnet_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if display_name is not None:
            _setter("display_name", display_name)
        if ipv6address_ipv6subnet_cidr_pair_details is not None:
            _setter("ipv6address_ipv6subnet_cidr_pair_details", ipv6address_ipv6subnet_cidr_pair_details)
        if is_assign_ipv6ip is not None:
            _setter("is_assign_ipv6ip", is_assign_ipv6ip)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        The display name of the VNIC. This is also used to match against the instance configuration defined secondary VNIC.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="ipv6addressIpv6subnetCidrPairDetails")
    def ipv6address_ipv6subnet_cidr_pair_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkInstancePoolPlacementConfigurationSecondaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs']]]]:
        """
        A list of IPv6 prefix ranges from which the VNIC should be assigned an IPv6 address. You can provide only the prefix ranges and Oracle Cloud Infrastructure will select an available address from the range. You can optionally choose to leave the prefix range empty and instead provide the specific IPv6 address that should be used from within that range.
        """
        return pulumi.get(self, "ipv6address_ipv6subnet_cidr_pair_details")

    @ipv6address_ipv6subnet_cidr_pair_details.setter
    def ipv6address_ipv6subnet_cidr_pair_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkInstancePoolPlacementConfigurationSecondaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs']]]]):
        pulumi.set(self, "ipv6address_ipv6subnet_cidr_pair_details", value)

    @property
    @pulumi.getter(name="isAssignIpv6ip")
    def is_assign_ipv6ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allocate an IPv6 address at instance and VNIC creation from an IPv6 enabled subnet. Default: False. When provided you may optionally provide an IPv6 prefix (`ipv6SubnetCidr`) of your choice to assign the IPv6 address from. If `ipv6SubnetCidr` is not provided then an IPv6 prefix is chosen for you.
        """
        return pulumi.get(self, "is_assign_ipv6ip")

    @is_assign_ipv6ip.setter
    def is_assign_ipv6ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_assign_ipv6ip", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The subnet [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the secondary VNIC.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


@pulumi.input_type
class ClusterNetworkInstancePoolPlacementConfigurationSecondaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs:
    def __init__(__self__, *,
                 ipv6subnet_cidr: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ipv6subnet_cidr: Optional. Used to disambiguate which subnet prefix should be used to create an IPv6 allocation.
        """
        ClusterNetworkInstancePoolPlacementConfigurationSecondaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ipv6subnet_cidr=ipv6subnet_cidr,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ipv6subnet_cidr: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ipv6subnet_cidr is not None:
            _setter("ipv6subnet_cidr", ipv6subnet_cidr)

    @property
    @pulumi.getter(name="ipv6subnetCidr")
    def ipv6subnet_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Used to disambiguate which subnet prefix should be used to create an IPv6 allocation.
        """
        return pulumi.get(self, "ipv6subnet_cidr")

    @ipv6subnet_cidr.setter
    def ipv6subnet_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6subnet_cidr", value)


@pulumi.input_type
class ClusterNetworkPlacementConfigurationArgs:
    def __init__(__self__, *,
                 availability_domain: pulumi.Input[str],
                 placement_constraint: Optional[pulumi.Input[str]] = None,
                 primary_subnet_id: Optional[pulumi.Input[str]] = None,
                 primary_vnic_subnets: Optional[pulumi.Input['ClusterNetworkPlacementConfigurationPrimaryVnicSubnetsArgs']] = None,
                 secondary_vnic_subnets: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkPlacementConfigurationSecondaryVnicSubnetArgs']]]] = None):
        """
        :param pulumi.Input[str] availability_domain: The availability domain to place instances.  Example: `Uocm:PHX-AD-1`
        :param pulumi.Input[str] primary_subnet_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the primary subnet to place instances. This field is deprecated. Use `primaryVnicSubnets` instead to set VNIC data for instances in the pool.
        :param pulumi.Input['ClusterNetworkPlacementConfigurationPrimaryVnicSubnetsArgs'] primary_vnic_subnets: Details about the IPv6 primary subnet.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterNetworkPlacementConfigurationSecondaryVnicSubnetArgs']]] secondary_vnic_subnets: The set of secondary VNIC data for instances in the pool.
        """
        ClusterNetworkPlacementConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_domain=availability_domain,
            placement_constraint=placement_constraint,
            primary_subnet_id=primary_subnet_id,
            primary_vnic_subnets=primary_vnic_subnets,
            secondary_vnic_subnets=secondary_vnic_subnets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_domain: pulumi.Input[str],
             placement_constraint: Optional[pulumi.Input[str]] = None,
             primary_subnet_id: Optional[pulumi.Input[str]] = None,
             primary_vnic_subnets: Optional[pulumi.Input['ClusterNetworkPlacementConfigurationPrimaryVnicSubnetsArgs']] = None,
             secondary_vnic_subnets: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkPlacementConfigurationSecondaryVnicSubnetArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("availability_domain", availability_domain)
        if placement_constraint is not None:
            _setter("placement_constraint", placement_constraint)
        if primary_subnet_id is not None:
            _setter("primary_subnet_id", primary_subnet_id)
        if primary_vnic_subnets is not None:
            _setter("primary_vnic_subnets", primary_vnic_subnets)
        if secondary_vnic_subnets is not None:
            _setter("secondary_vnic_subnets", secondary_vnic_subnets)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> pulumi.Input[str]:
        """
        The availability domain to place instances.  Example: `Uocm:PHX-AD-1`
        """
        return pulumi.get(self, "availability_domain")

    @availability_domain.setter
    def availability_domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "availability_domain", value)

    @property
    @pulumi.getter(name="placementConstraint")
    def placement_constraint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "placement_constraint")

    @placement_constraint.setter
    def placement_constraint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "placement_constraint", value)

    @property
    @pulumi.getter(name="primarySubnetId")
    def primary_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the primary subnet to place instances. This field is deprecated. Use `primaryVnicSubnets` instead to set VNIC data for instances in the pool.
        """
        return pulumi.get(self, "primary_subnet_id")

    @primary_subnet_id.setter
    def primary_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_subnet_id", value)

    @property
    @pulumi.getter(name="primaryVnicSubnets")
    def primary_vnic_subnets(self) -> Optional[pulumi.Input['ClusterNetworkPlacementConfigurationPrimaryVnicSubnetsArgs']]:
        """
        Details about the IPv6 primary subnet.
        """
        return pulumi.get(self, "primary_vnic_subnets")

    @primary_vnic_subnets.setter
    def primary_vnic_subnets(self, value: Optional[pulumi.Input['ClusterNetworkPlacementConfigurationPrimaryVnicSubnetsArgs']]):
        pulumi.set(self, "primary_vnic_subnets", value)

    @property
    @pulumi.getter(name="secondaryVnicSubnets")
    def secondary_vnic_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkPlacementConfigurationSecondaryVnicSubnetArgs']]]]:
        """
        The set of secondary VNIC data for instances in the pool.
        """
        return pulumi.get(self, "secondary_vnic_subnets")

    @secondary_vnic_subnets.setter
    def secondary_vnic_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkPlacementConfigurationSecondaryVnicSubnetArgs']]]]):
        pulumi.set(self, "secondary_vnic_subnets", value)


@pulumi.input_type
class ClusterNetworkPlacementConfigurationPrimaryVnicSubnetsArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[str],
                 ipv6address_ipv6subnet_cidr_pair_details: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkPlacementConfigurationPrimaryVnicSubnetsIpv6addressIpv6subnetCidrPairDetailArgs']]]] = None,
                 is_assign_ipv6ip: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] subnet_id: The subnet [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the secondary VNIC.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param pulumi.Input[Sequence[pulumi.Input['ClusterNetworkPlacementConfigurationPrimaryVnicSubnetsIpv6addressIpv6subnetCidrPairDetailArgs']]] ipv6address_ipv6subnet_cidr_pair_details: A list of IPv6 prefix ranges from which the VNIC should be assigned an IPv6 address. You can provide only the prefix ranges and Oracle Cloud Infrastructure will select an available address from the range. You can optionally choose to leave the prefix range empty and instead provide the specific IPv6 address that should be used from within that range.
        :param pulumi.Input[bool] is_assign_ipv6ip: Whether to allocate an IPv6 address at instance and VNIC creation from an IPv6 enabled subnet. Default: False. When provided you may optionally provide an IPv6 prefix (`ipv6SubnetCidr`) of your choice to assign the IPv6 address from. If `ipv6SubnetCidr` is not provided then an IPv6 prefix is chosen for you.
        """
        ClusterNetworkPlacementConfigurationPrimaryVnicSubnetsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subnet_id=subnet_id,
            ipv6address_ipv6subnet_cidr_pair_details=ipv6address_ipv6subnet_cidr_pair_details,
            is_assign_ipv6ip=is_assign_ipv6ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subnet_id: pulumi.Input[str],
             ipv6address_ipv6subnet_cidr_pair_details: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkPlacementConfigurationPrimaryVnicSubnetsIpv6addressIpv6subnetCidrPairDetailArgs']]]] = None,
             is_assign_ipv6ip: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("subnet_id", subnet_id)
        if ipv6address_ipv6subnet_cidr_pair_details is not None:
            _setter("ipv6address_ipv6subnet_cidr_pair_details", ipv6address_ipv6subnet_cidr_pair_details)
        if is_assign_ipv6ip is not None:
            _setter("is_assign_ipv6ip", is_assign_ipv6ip)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        The subnet [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the secondary VNIC.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="ipv6addressIpv6subnetCidrPairDetails")
    def ipv6address_ipv6subnet_cidr_pair_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkPlacementConfigurationPrimaryVnicSubnetsIpv6addressIpv6subnetCidrPairDetailArgs']]]]:
        """
        A list of IPv6 prefix ranges from which the VNIC should be assigned an IPv6 address. You can provide only the prefix ranges and Oracle Cloud Infrastructure will select an available address from the range. You can optionally choose to leave the prefix range empty and instead provide the specific IPv6 address that should be used from within that range.
        """
        return pulumi.get(self, "ipv6address_ipv6subnet_cidr_pair_details")

    @ipv6address_ipv6subnet_cidr_pair_details.setter
    def ipv6address_ipv6subnet_cidr_pair_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkPlacementConfigurationPrimaryVnicSubnetsIpv6addressIpv6subnetCidrPairDetailArgs']]]]):
        pulumi.set(self, "ipv6address_ipv6subnet_cidr_pair_details", value)

    @property
    @pulumi.getter(name="isAssignIpv6ip")
    def is_assign_ipv6ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allocate an IPv6 address at instance and VNIC creation from an IPv6 enabled subnet. Default: False. When provided you may optionally provide an IPv6 prefix (`ipv6SubnetCidr`) of your choice to assign the IPv6 address from. If `ipv6SubnetCidr` is not provided then an IPv6 prefix is chosen for you.
        """
        return pulumi.get(self, "is_assign_ipv6ip")

    @is_assign_ipv6ip.setter
    def is_assign_ipv6ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_assign_ipv6ip", value)


@pulumi.input_type
class ClusterNetworkPlacementConfigurationPrimaryVnicSubnetsIpv6addressIpv6subnetCidrPairDetailArgs:
    def __init__(__self__, *,
                 ipv6subnet_cidr: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ipv6subnet_cidr: Optional. Used to disambiguate which subnet prefix should be used to create an IPv6 allocation.
        """
        ClusterNetworkPlacementConfigurationPrimaryVnicSubnetsIpv6addressIpv6subnetCidrPairDetailArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ipv6subnet_cidr=ipv6subnet_cidr,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ipv6subnet_cidr: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ipv6subnet_cidr is not None:
            _setter("ipv6subnet_cidr", ipv6subnet_cidr)

    @property
    @pulumi.getter(name="ipv6subnetCidr")
    def ipv6subnet_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Used to disambiguate which subnet prefix should be used to create an IPv6 allocation.
        """
        return pulumi.get(self, "ipv6subnet_cidr")

    @ipv6subnet_cidr.setter
    def ipv6subnet_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6subnet_cidr", value)


@pulumi.input_type
class ClusterNetworkPlacementConfigurationSecondaryVnicSubnetArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[str],
                 display_name: Optional[pulumi.Input[str]] = None,
                 ipv6address_ipv6subnet_cidr_pair_details: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkPlacementConfigurationSecondaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs']]]] = None,
                 is_assign_ipv6ip: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] subnet_id: The subnet [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the secondary VNIC.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param pulumi.Input[str] display_name: The display name of the VNIC. This is also used to match against the instance configuration defined secondary VNIC.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterNetworkPlacementConfigurationSecondaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs']]] ipv6address_ipv6subnet_cidr_pair_details: A list of IPv6 prefix ranges from which the VNIC should be assigned an IPv6 address. You can provide only the prefix ranges and Oracle Cloud Infrastructure will select an available address from the range. You can optionally choose to leave the prefix range empty and instead provide the specific IPv6 address that should be used from within that range.
        :param pulumi.Input[bool] is_assign_ipv6ip: Whether to allocate an IPv6 address at instance and VNIC creation from an IPv6 enabled subnet. Default: False. When provided you may optionally provide an IPv6 prefix (`ipv6SubnetCidr`) of your choice to assign the IPv6 address from. If `ipv6SubnetCidr` is not provided then an IPv6 prefix is chosen for you.
        """
        ClusterNetworkPlacementConfigurationSecondaryVnicSubnetArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subnet_id=subnet_id,
            display_name=display_name,
            ipv6address_ipv6subnet_cidr_pair_details=ipv6address_ipv6subnet_cidr_pair_details,
            is_assign_ipv6ip=is_assign_ipv6ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subnet_id: pulumi.Input[str],
             display_name: Optional[pulumi.Input[str]] = None,
             ipv6address_ipv6subnet_cidr_pair_details: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkPlacementConfigurationSecondaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs']]]] = None,
             is_assign_ipv6ip: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("subnet_id", subnet_id)
        if display_name is not None:
            _setter("display_name", display_name)
        if ipv6address_ipv6subnet_cidr_pair_details is not None:
            _setter("ipv6address_ipv6subnet_cidr_pair_details", ipv6address_ipv6subnet_cidr_pair_details)
        if is_assign_ipv6ip is not None:
            _setter("is_assign_ipv6ip", is_assign_ipv6ip)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        The subnet [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the secondary VNIC.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        The display name of the VNIC. This is also used to match against the instance configuration defined secondary VNIC.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="ipv6addressIpv6subnetCidrPairDetails")
    def ipv6address_ipv6subnet_cidr_pair_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkPlacementConfigurationSecondaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs']]]]:
        """
        A list of IPv6 prefix ranges from which the VNIC should be assigned an IPv6 address. You can provide only the prefix ranges and Oracle Cloud Infrastructure will select an available address from the range. You can optionally choose to leave the prefix range empty and instead provide the specific IPv6 address that should be used from within that range.
        """
        return pulumi.get(self, "ipv6address_ipv6subnet_cidr_pair_details")

    @ipv6address_ipv6subnet_cidr_pair_details.setter
    def ipv6address_ipv6subnet_cidr_pair_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterNetworkPlacementConfigurationSecondaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs']]]]):
        pulumi.set(self, "ipv6address_ipv6subnet_cidr_pair_details", value)

    @property
    @pulumi.getter(name="isAssignIpv6ip")
    def is_assign_ipv6ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allocate an IPv6 address at instance and VNIC creation from an IPv6 enabled subnet. Default: False. When provided you may optionally provide an IPv6 prefix (`ipv6SubnetCidr`) of your choice to assign the IPv6 address from. If `ipv6SubnetCidr` is not provided then an IPv6 prefix is chosen for you.
        """
        return pulumi.get(self, "is_assign_ipv6ip")

    @is_assign_ipv6ip.setter
    def is_assign_ipv6ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_assign_ipv6ip", value)


@pulumi.input_type
class ClusterNetworkPlacementConfigurationSecondaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs:
    def __init__(__self__, *,
                 ipv6subnet_cidr: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ipv6subnet_cidr: Optional. Used to disambiguate which subnet prefix should be used to create an IPv6 allocation.
        """
        ClusterNetworkPlacementConfigurationSecondaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ipv6subnet_cidr=ipv6subnet_cidr,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ipv6subnet_cidr: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ipv6subnet_cidr is not None:
            _setter("ipv6subnet_cidr", ipv6subnet_cidr)

    @property
    @pulumi.getter(name="ipv6subnetCidr")
    def ipv6subnet_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Used to disambiguate which subnet prefix should be used to create an IPv6 allocation.
        """
        return pulumi.get(self, "ipv6subnet_cidr")

    @ipv6subnet_cidr.setter
    def ipv6subnet_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6subnet_cidr", value)


@pulumi.input_type
class ComputeCapacityReportShapeAvailabilityArgs:
    def __init__(__self__, *,
                 instance_shape: pulumi.Input[str],
                 availability_status: Optional[pulumi.Input[str]] = None,
                 available_count: Optional[pulumi.Input[str]] = None,
                 fault_domain: Optional[pulumi.Input[str]] = None,
                 instance_shape_config: Optional[pulumi.Input['ComputeCapacityReportShapeAvailabilityInstanceShapeConfigArgs']] = None):
        """
        :param pulumi.Input[str] instance_shape: The shape that you want to request a capacity report for. You can enumerate all available shapes by calling [ListShapes](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Shape/ListShapes).
        :param pulumi.Input[str] availability_status: A flag denoting whether capacity is available.
        :param pulumi.Input[str] available_count: The total number of new instances that can be created with the specified shape configuration.
        :param pulumi.Input[str] fault_domain: The fault domain for the capacity report.
               
               If you do not specify a fault domain, the capacity report includes information about all fault domains.
        :param pulumi.Input['ComputeCapacityReportShapeAvailabilityInstanceShapeConfigArgs'] instance_shape_config: The shape configuration for a shape in a capacity report.
        """
        ComputeCapacityReportShapeAvailabilityArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_shape=instance_shape,
            availability_status=availability_status,
            available_count=available_count,
            fault_domain=fault_domain,
            instance_shape_config=instance_shape_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_shape: pulumi.Input[str],
             availability_status: Optional[pulumi.Input[str]] = None,
             available_count: Optional[pulumi.Input[str]] = None,
             fault_domain: Optional[pulumi.Input[str]] = None,
             instance_shape_config: Optional[pulumi.Input['ComputeCapacityReportShapeAvailabilityInstanceShapeConfigArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("instance_shape", instance_shape)
        if availability_status is not None:
            _setter("availability_status", availability_status)
        if available_count is not None:
            _setter("available_count", available_count)
        if fault_domain is not None:
            _setter("fault_domain", fault_domain)
        if instance_shape_config is not None:
            _setter("instance_shape_config", instance_shape_config)

    @property
    @pulumi.getter(name="instanceShape")
    def instance_shape(self) -> pulumi.Input[str]:
        """
        The shape that you want to request a capacity report for. You can enumerate all available shapes by calling [ListShapes](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Shape/ListShapes).
        """
        return pulumi.get(self, "instance_shape")

    @instance_shape.setter
    def instance_shape(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_shape", value)

    @property
    @pulumi.getter(name="availabilityStatus")
    def availability_status(self) -> Optional[pulumi.Input[str]]:
        """
        A flag denoting whether capacity is available.
        """
        return pulumi.get(self, "availability_status")

    @availability_status.setter
    def availability_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_status", value)

    @property
    @pulumi.getter(name="availableCount")
    def available_count(self) -> Optional[pulumi.Input[str]]:
        """
        The total number of new instances that can be created with the specified shape configuration.
        """
        return pulumi.get(self, "available_count")

    @available_count.setter
    def available_count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "available_count", value)

    @property
    @pulumi.getter(name="faultDomain")
    def fault_domain(self) -> Optional[pulumi.Input[str]]:
        """
        The fault domain for the capacity report.

        If you do not specify a fault domain, the capacity report includes information about all fault domains.
        """
        return pulumi.get(self, "fault_domain")

    @fault_domain.setter
    def fault_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fault_domain", value)

    @property
    @pulumi.getter(name="instanceShapeConfig")
    def instance_shape_config(self) -> Optional[pulumi.Input['ComputeCapacityReportShapeAvailabilityInstanceShapeConfigArgs']]:
        """
        The shape configuration for a shape in a capacity report.
        """
        return pulumi.get(self, "instance_shape_config")

    @instance_shape_config.setter
    def instance_shape_config(self, value: Optional[pulumi.Input['ComputeCapacityReportShapeAvailabilityInstanceShapeConfigArgs']]):
        pulumi.set(self, "instance_shape_config", value)


@pulumi.input_type
class ComputeCapacityReportShapeAvailabilityInstanceShapeConfigArgs:
    def __init__(__self__, *,
                 memory_in_gbs: Optional[pulumi.Input[float]] = None,
                 nvmes: Optional[pulumi.Input[int]] = None,
                 ocpus: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] memory_in_gbs: The total amount of memory available to the instance, in gigabytes.
        :param pulumi.Input[int] nvmes: The number of NVMe drives to be used for storage.
        :param pulumi.Input[float] ocpus: The total number of OCPUs available to the instance. 
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        ComputeCapacityReportShapeAvailabilityInstanceShapeConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            memory_in_gbs=memory_in_gbs,
            nvmes=nvmes,
            ocpus=ocpus,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             memory_in_gbs: Optional[pulumi.Input[float]] = None,
             nvmes: Optional[pulumi.Input[int]] = None,
             ocpus: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if memory_in_gbs is not None:
            _setter("memory_in_gbs", memory_in_gbs)
        if nvmes is not None:
            _setter("nvmes", nvmes)
        if ocpus is not None:
            _setter("ocpus", ocpus)

    @property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[pulumi.Input[float]]:
        """
        The total amount of memory available to the instance, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_in_gbs", value)

    @property
    @pulumi.getter
    def nvmes(self) -> Optional[pulumi.Input[int]]:
        """
        The number of NVMe drives to be used for storage.
        """
        return pulumi.get(self, "nvmes")

    @nvmes.setter
    def nvmes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nvmes", value)

    @property
    @pulumi.getter
    def ocpus(self) -> Optional[pulumi.Input[float]]:
        """
        The total number of OCPUs available to the instance. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "ocpus", value)


@pulumi.input_type
class ComputeCapacityReservationInstanceReservationConfigArgs:
    def __init__(__self__, *,
                 instance_shape: pulumi.Input[str],
                 reserved_count: pulumi.Input[str],
                 cluster_config: Optional[pulumi.Input['ComputeCapacityReservationInstanceReservationConfigClusterConfigArgs']] = None,
                 fault_domain: Optional[pulumi.Input[str]] = None,
                 instance_shape_config: Optional[pulumi.Input['ComputeCapacityReservationInstanceReservationConfigInstanceShapeConfigArgs']] = None,
                 used_count: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] instance_shape: (Updatable) The shape requested when launching instances using reserved capacity. The shape determines the number of CPUs, amount of memory, and other resources allocated to the instance. You can list all available shapes by calling [ListComputeCapacityReservationInstanceShapes](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/computeCapacityReservationInstanceShapes/ListComputeCapacityReservationInstanceShapes).
        :param pulumi.Input[str] reserved_count: (Updatable) The total number of instances that can be launched from the capacity configuration.
        :param pulumi.Input['ComputeCapacityReservationInstanceReservationConfigClusterConfigArgs'] cluster_config: (Updatable) The HPC cluster configuration requested when launching instances in a compute capacity reservation.
               
               If the parameter is provided, the reservation is created with the HPC island and a list of HPC blocks that you specify. If a list of HPC blocks are missing or not provided, the reservation is created with any HPC blocks in the HPC island that you specify. If the values of HPC island or HPC block that you provide are not valid, an error is returned.
        :param pulumi.Input[str] fault_domain: (Updatable) The fault domain to use for instances created using this capacity configuration. For more information, see [Fault Domains](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/regions.htm#fault). If you do not specify the fault domain, the capacity is available for an instance that does not specify a fault domain. To change the fault domain for a reservation, delete the reservation and create a new one in the preferred fault domain.
               
               To retrieve a list of fault domains, use the `ListFaultDomains` operation in the [Identity and Access Management Service API](https://www.terraform.io/iaas/api/#/en/identity/20160918/).
               
               Example: `FAULT-DOMAIN-1`
        :param pulumi.Input['ComputeCapacityReservationInstanceReservationConfigInstanceShapeConfigArgs'] instance_shape_config: (Updatable) The shape configuration requested when launching instances in a compute capacity reservation.
               
               If the parameter is provided, the reservation is created with the resources that you specify. If some properties are missing or the parameter is not provided, the reservation is created with the default configuration values for the `shape` that you specify.
               
               Each shape only supports certain configurable values. If the values that you provide are not valid for the specified `shape`, an error is returned.
               
               For more information about customizing the resources that are allocated to flexible shapes, see [Flexible Shapes](https://docs.cloud.oracle.com/iaas/Content/Compute/References/computeshapes.htm#flexible).
        :param pulumi.Input[str] used_count: The amount of capacity in use out of the total capacity reserved in this capacity configuration.
        """
        ComputeCapacityReservationInstanceReservationConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_shape=instance_shape,
            reserved_count=reserved_count,
            cluster_config=cluster_config,
            fault_domain=fault_domain,
            instance_shape_config=instance_shape_config,
            used_count=used_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_shape: pulumi.Input[str],
             reserved_count: pulumi.Input[str],
             cluster_config: Optional[pulumi.Input['ComputeCapacityReservationInstanceReservationConfigClusterConfigArgs']] = None,
             fault_domain: Optional[pulumi.Input[str]] = None,
             instance_shape_config: Optional[pulumi.Input['ComputeCapacityReservationInstanceReservationConfigInstanceShapeConfigArgs']] = None,
             used_count: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("instance_shape", instance_shape)
        _setter("reserved_count", reserved_count)
        if cluster_config is not None:
            _setter("cluster_config", cluster_config)
        if fault_domain is not None:
            _setter("fault_domain", fault_domain)
        if instance_shape_config is not None:
            _setter("instance_shape_config", instance_shape_config)
        if used_count is not None:
            _setter("used_count", used_count)

    @property
    @pulumi.getter(name="instanceShape")
    def instance_shape(self) -> pulumi.Input[str]:
        """
        (Updatable) The shape requested when launching instances using reserved capacity. The shape determines the number of CPUs, amount of memory, and other resources allocated to the instance. You can list all available shapes by calling [ListComputeCapacityReservationInstanceShapes](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/computeCapacityReservationInstanceShapes/ListComputeCapacityReservationInstanceShapes).
        """
        return pulumi.get(self, "instance_shape")

    @instance_shape.setter
    def instance_shape(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_shape", value)

    @property
    @pulumi.getter(name="reservedCount")
    def reserved_count(self) -> pulumi.Input[str]:
        """
        (Updatable) The total number of instances that can be launched from the capacity configuration.
        """
        return pulumi.get(self, "reserved_count")

    @reserved_count.setter
    def reserved_count(self, value: pulumi.Input[str]):
        pulumi.set(self, "reserved_count", value)

    @property
    @pulumi.getter(name="clusterConfig")
    def cluster_config(self) -> Optional[pulumi.Input['ComputeCapacityReservationInstanceReservationConfigClusterConfigArgs']]:
        """
        (Updatable) The HPC cluster configuration requested when launching instances in a compute capacity reservation.

        If the parameter is provided, the reservation is created with the HPC island and a list of HPC blocks that you specify. If a list of HPC blocks are missing or not provided, the reservation is created with any HPC blocks in the HPC island that you specify. If the values of HPC island or HPC block that you provide are not valid, an error is returned.
        """
        return pulumi.get(self, "cluster_config")

    @cluster_config.setter
    def cluster_config(self, value: Optional[pulumi.Input['ComputeCapacityReservationInstanceReservationConfigClusterConfigArgs']]):
        pulumi.set(self, "cluster_config", value)

    @property
    @pulumi.getter(name="faultDomain")
    def fault_domain(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The fault domain to use for instances created using this capacity configuration. For more information, see [Fault Domains](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/regions.htm#fault). If you do not specify the fault domain, the capacity is available for an instance that does not specify a fault domain. To change the fault domain for a reservation, delete the reservation and create a new one in the preferred fault domain.

        To retrieve a list of fault domains, use the `ListFaultDomains` operation in the [Identity and Access Management Service API](https://www.terraform.io/iaas/api/#/en/identity/20160918/).

        Example: `FAULT-DOMAIN-1`
        """
        return pulumi.get(self, "fault_domain")

    @fault_domain.setter
    def fault_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fault_domain", value)

    @property
    @pulumi.getter(name="instanceShapeConfig")
    def instance_shape_config(self) -> Optional[pulumi.Input['ComputeCapacityReservationInstanceReservationConfigInstanceShapeConfigArgs']]:
        """
        (Updatable) The shape configuration requested when launching instances in a compute capacity reservation.

        If the parameter is provided, the reservation is created with the resources that you specify. If some properties are missing or the parameter is not provided, the reservation is created with the default configuration values for the `shape` that you specify.

        Each shape only supports certain configurable values. If the values that you provide are not valid for the specified `shape`, an error is returned.

        For more information about customizing the resources that are allocated to flexible shapes, see [Flexible Shapes](https://docs.cloud.oracle.com/iaas/Content/Compute/References/computeshapes.htm#flexible).
        """
        return pulumi.get(self, "instance_shape_config")

    @instance_shape_config.setter
    def instance_shape_config(self, value: Optional[pulumi.Input['ComputeCapacityReservationInstanceReservationConfigInstanceShapeConfigArgs']]):
        pulumi.set(self, "instance_shape_config", value)

    @property
    @pulumi.getter(name="usedCount")
    def used_count(self) -> Optional[pulumi.Input[str]]:
        """
        The amount of capacity in use out of the total capacity reserved in this capacity configuration.
        """
        return pulumi.get(self, "used_count")

    @used_count.setter
    def used_count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "used_count", value)


@pulumi.input_type
class ComputeCapacityReservationInstanceReservationConfigClusterConfigArgs:
    def __init__(__self__, *,
                 hpc_island_id: pulumi.Input[str],
                 network_block_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] hpc_island_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the HPC island.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] network_block_ids: (Updatable) The list of OCIDs of the network blocks.
        """
        ComputeCapacityReservationInstanceReservationConfigClusterConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hpc_island_id=hpc_island_id,
            network_block_ids=network_block_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hpc_island_id: pulumi.Input[str],
             network_block_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("hpc_island_id", hpc_island_id)
        if network_block_ids is not None:
            _setter("network_block_ids", network_block_ids)

    @property
    @pulumi.getter(name="hpcIslandId")
    def hpc_island_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the HPC island.
        """
        return pulumi.get(self, "hpc_island_id")

    @hpc_island_id.setter
    def hpc_island_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "hpc_island_id", value)

    @property
    @pulumi.getter(name="networkBlockIds")
    def network_block_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) The list of OCIDs of the network blocks.
        """
        return pulumi.get(self, "network_block_ids")

    @network_block_ids.setter
    def network_block_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "network_block_ids", value)


@pulumi.input_type
class ComputeCapacityReservationInstanceReservationConfigInstanceShapeConfigArgs:
    def __init__(__self__, *,
                 memory_in_gbs: Optional[pulumi.Input[float]] = None,
                 ocpus: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] memory_in_gbs: (Updatable) The total amount of memory available to the instance, in gigabytes.
        :param pulumi.Input[float] ocpus: (Updatable) The total number of OCPUs available to the instance.
        """
        ComputeCapacityReservationInstanceReservationConfigInstanceShapeConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            memory_in_gbs=memory_in_gbs,
            ocpus=ocpus,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             memory_in_gbs: Optional[pulumi.Input[float]] = None,
             ocpus: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if memory_in_gbs is not None:
            _setter("memory_in_gbs", memory_in_gbs)
        if ocpus is not None:
            _setter("ocpus", ocpus)

    @property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[pulumi.Input[float]]:
        """
        (Updatable) The total amount of memory available to the instance, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_in_gbs", value)

    @property
    @pulumi.getter
    def ocpus(self) -> Optional[pulumi.Input[float]]:
        """
        (Updatable) The total number of OCPUs available to the instance.
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "ocpus", value)


@pulumi.input_type
class CrossConnectGroupMacsecPropertiesArgs:
    def __init__(__self__, *,
                 state: pulumi.Input[str],
                 encryption_cipher: Optional[pulumi.Input[str]] = None,
                 is_unprotected_traffic_allowed: Optional[pulumi.Input[bool]] = None,
                 primary_key: Optional[pulumi.Input['CrossConnectGroupMacsecPropertiesPrimaryKeyArgs']] = None):
        """
        :param pulumi.Input[str] state: (Updatable) Indicates whether or not MACsec is enabled.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param pulumi.Input[str] encryption_cipher: (Updatable) Type of encryption cipher suite to use for the MACsec connection.
        :param pulumi.Input[bool] is_unprotected_traffic_allowed: (Updatable) Indicates whether unencrypted traffic is allowed if MACsec Key Agreement protocol (MKA) fails.
        :param pulumi.Input['CrossConnectGroupMacsecPropertiesPrimaryKeyArgs'] primary_key: (Updatable) Defines the secret [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)s held in Vault that represent the MACsec key.
        """
        CrossConnectGroupMacsecPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            state=state,
            encryption_cipher=encryption_cipher,
            is_unprotected_traffic_allowed=is_unprotected_traffic_allowed,
            primary_key=primary_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             state: pulumi.Input[str],
             encryption_cipher: Optional[pulumi.Input[str]] = None,
             is_unprotected_traffic_allowed: Optional[pulumi.Input[bool]] = None,
             primary_key: Optional[pulumi.Input['CrossConnectGroupMacsecPropertiesPrimaryKeyArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("state", state)
        if encryption_cipher is not None:
            _setter("encryption_cipher", encryption_cipher)
        if is_unprotected_traffic_allowed is not None:
            _setter("is_unprotected_traffic_allowed", is_unprotected_traffic_allowed)
        if primary_key is not None:
            _setter("primary_key", primary_key)

    @property
    @pulumi.getter
    def state(self) -> pulumi.Input[str]:
        """
        (Updatable) Indicates whether or not MACsec is enabled.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input[str]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="encryptionCipher")
    def encryption_cipher(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Type of encryption cipher suite to use for the MACsec connection.
        """
        return pulumi.get(self, "encryption_cipher")

    @encryption_cipher.setter
    def encryption_cipher(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_cipher", value)

    @property
    @pulumi.getter(name="isUnprotectedTrafficAllowed")
    def is_unprotected_traffic_allowed(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Indicates whether unencrypted traffic is allowed if MACsec Key Agreement protocol (MKA) fails.
        """
        return pulumi.get(self, "is_unprotected_traffic_allowed")

    @is_unprotected_traffic_allowed.setter
    def is_unprotected_traffic_allowed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_unprotected_traffic_allowed", value)

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[pulumi.Input['CrossConnectGroupMacsecPropertiesPrimaryKeyArgs']]:
        """
        (Updatable) Defines the secret [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)s held in Vault that represent the MACsec key.
        """
        return pulumi.get(self, "primary_key")

    @primary_key.setter
    def primary_key(self, value: Optional[pulumi.Input['CrossConnectGroupMacsecPropertiesPrimaryKeyArgs']]):
        pulumi.set(self, "primary_key", value)


@pulumi.input_type
class CrossConnectGroupMacsecPropertiesPrimaryKeyArgs:
    def __init__(__self__, *,
                 connectivity_association_key_secret_id: pulumi.Input[str],
                 connectivity_association_name_secret_id: pulumi.Input[str],
                 connectivity_association_key_secret_version: Optional[pulumi.Input[str]] = None,
                 connectivity_association_name_secret_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] connectivity_association_key_secret_id: (Updatable) Secret [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) containing the Connectivity Association Key (CAK) of this MACsec key.
               
               NOTE: Only the latest secret version will be used.
        :param pulumi.Input[str] connectivity_association_name_secret_id: (Updatable) Secret [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) containing the Connectivity association Key Name (CKN) of this MACsec key.
               
               NOTE: Only the latest secret version will be used.
        :param pulumi.Input[str] connectivity_association_key_secret_version: The secret version of the `connectivityAssociationKey` secret in Vault.
        :param pulumi.Input[str] connectivity_association_name_secret_version: The secret version of the connectivity association name secret in Vault.
        """
        CrossConnectGroupMacsecPropertiesPrimaryKeyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connectivity_association_key_secret_id=connectivity_association_key_secret_id,
            connectivity_association_name_secret_id=connectivity_association_name_secret_id,
            connectivity_association_key_secret_version=connectivity_association_key_secret_version,
            connectivity_association_name_secret_version=connectivity_association_name_secret_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connectivity_association_key_secret_id: pulumi.Input[str],
             connectivity_association_name_secret_id: pulumi.Input[str],
             connectivity_association_key_secret_version: Optional[pulumi.Input[str]] = None,
             connectivity_association_name_secret_version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("connectivity_association_key_secret_id", connectivity_association_key_secret_id)
        _setter("connectivity_association_name_secret_id", connectivity_association_name_secret_id)
        if connectivity_association_key_secret_version is not None:
            _setter("connectivity_association_key_secret_version", connectivity_association_key_secret_version)
        if connectivity_association_name_secret_version is not None:
            _setter("connectivity_association_name_secret_version", connectivity_association_name_secret_version)

    @property
    @pulumi.getter(name="connectivityAssociationKeySecretId")
    def connectivity_association_key_secret_id(self) -> pulumi.Input[str]:
        """
        (Updatable) Secret [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) containing the Connectivity Association Key (CAK) of this MACsec key.

        NOTE: Only the latest secret version will be used.
        """
        return pulumi.get(self, "connectivity_association_key_secret_id")

    @connectivity_association_key_secret_id.setter
    def connectivity_association_key_secret_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "connectivity_association_key_secret_id", value)

    @property
    @pulumi.getter(name="connectivityAssociationNameSecretId")
    def connectivity_association_name_secret_id(self) -> pulumi.Input[str]:
        """
        (Updatable) Secret [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) containing the Connectivity association Key Name (CKN) of this MACsec key.

        NOTE: Only the latest secret version will be used.
        """
        return pulumi.get(self, "connectivity_association_name_secret_id")

    @connectivity_association_name_secret_id.setter
    def connectivity_association_name_secret_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "connectivity_association_name_secret_id", value)

    @property
    @pulumi.getter(name="connectivityAssociationKeySecretVersion")
    def connectivity_association_key_secret_version(self) -> Optional[pulumi.Input[str]]:
        """
        The secret version of the `connectivityAssociationKey` secret in Vault.
        """
        return pulumi.get(self, "connectivity_association_key_secret_version")

    @connectivity_association_key_secret_version.setter
    def connectivity_association_key_secret_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connectivity_association_key_secret_version", value)

    @property
    @pulumi.getter(name="connectivityAssociationNameSecretVersion")
    def connectivity_association_name_secret_version(self) -> Optional[pulumi.Input[str]]:
        """
        The secret version of the connectivity association name secret in Vault.
        """
        return pulumi.get(self, "connectivity_association_name_secret_version")

    @connectivity_association_name_secret_version.setter
    def connectivity_association_name_secret_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connectivity_association_name_secret_version", value)


@pulumi.input_type
class CrossConnectMacsecPropertiesArgs:
    def __init__(__self__, *,
                 state: pulumi.Input[str],
                 encryption_cipher: Optional[pulumi.Input[str]] = None,
                 is_unprotected_traffic_allowed: Optional[pulumi.Input[bool]] = None,
                 primary_key: Optional[pulumi.Input['CrossConnectMacsecPropertiesPrimaryKeyArgs']] = None):
        """
        :param pulumi.Input[str] state: (Updatable) Indicates whether or not MACsec is enabled.
        :param pulumi.Input[str] encryption_cipher: (Updatable) Type of encryption cipher suite to use for the MACsec connection.
        :param pulumi.Input[bool] is_unprotected_traffic_allowed: (Updatable) Indicates whether unencrypted traffic is allowed if MACsec Key Agreement protocol (MKA) fails.
        :param pulumi.Input['CrossConnectMacsecPropertiesPrimaryKeyArgs'] primary_key: (Updatable) Defines the secret [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)s held in Vault that represent the MACsec key.
        """
        CrossConnectMacsecPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            state=state,
            encryption_cipher=encryption_cipher,
            is_unprotected_traffic_allowed=is_unprotected_traffic_allowed,
            primary_key=primary_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             state: pulumi.Input[str],
             encryption_cipher: Optional[pulumi.Input[str]] = None,
             is_unprotected_traffic_allowed: Optional[pulumi.Input[bool]] = None,
             primary_key: Optional[pulumi.Input['CrossConnectMacsecPropertiesPrimaryKeyArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("state", state)
        if encryption_cipher is not None:
            _setter("encryption_cipher", encryption_cipher)
        if is_unprotected_traffic_allowed is not None:
            _setter("is_unprotected_traffic_allowed", is_unprotected_traffic_allowed)
        if primary_key is not None:
            _setter("primary_key", primary_key)

    @property
    @pulumi.getter
    def state(self) -> pulumi.Input[str]:
        """
        (Updatable) Indicates whether or not MACsec is enabled.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input[str]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="encryptionCipher")
    def encryption_cipher(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Type of encryption cipher suite to use for the MACsec connection.
        """
        return pulumi.get(self, "encryption_cipher")

    @encryption_cipher.setter
    def encryption_cipher(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_cipher", value)

    @property
    @pulumi.getter(name="isUnprotectedTrafficAllowed")
    def is_unprotected_traffic_allowed(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Indicates whether unencrypted traffic is allowed if MACsec Key Agreement protocol (MKA) fails.
        """
        return pulumi.get(self, "is_unprotected_traffic_allowed")

    @is_unprotected_traffic_allowed.setter
    def is_unprotected_traffic_allowed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_unprotected_traffic_allowed", value)

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[pulumi.Input['CrossConnectMacsecPropertiesPrimaryKeyArgs']]:
        """
        (Updatable) Defines the secret [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)s held in Vault that represent the MACsec key.
        """
        return pulumi.get(self, "primary_key")

    @primary_key.setter
    def primary_key(self, value: Optional[pulumi.Input['CrossConnectMacsecPropertiesPrimaryKeyArgs']]):
        pulumi.set(self, "primary_key", value)


@pulumi.input_type
class CrossConnectMacsecPropertiesPrimaryKeyArgs:
    def __init__(__self__, *,
                 connectivity_association_key_secret_id: pulumi.Input[str],
                 connectivity_association_name_secret_id: pulumi.Input[str],
                 connectivity_association_key_secret_version: Optional[pulumi.Input[str]] = None,
                 connectivity_association_name_secret_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] connectivity_association_key_secret_id: (Updatable) Secret [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) containing the Connectivity Association Key (CAK) of this MACsec key.
               
               NOTE: Only the latest secret version will be used.
        :param pulumi.Input[str] connectivity_association_name_secret_id: (Updatable) Secret [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) containing the Connectivity association Key Name (CKN) of this MACsec key.
               
               NOTE: Only the latest secret version will be used.
        :param pulumi.Input[str] connectivity_association_key_secret_version: The secret version of the `connectivityAssociationKey` secret in Vault.
        :param pulumi.Input[str] connectivity_association_name_secret_version: The secret version of the connectivity association name secret in Vault.
        """
        CrossConnectMacsecPropertiesPrimaryKeyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connectivity_association_key_secret_id=connectivity_association_key_secret_id,
            connectivity_association_name_secret_id=connectivity_association_name_secret_id,
            connectivity_association_key_secret_version=connectivity_association_key_secret_version,
            connectivity_association_name_secret_version=connectivity_association_name_secret_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connectivity_association_key_secret_id: pulumi.Input[str],
             connectivity_association_name_secret_id: pulumi.Input[str],
             connectivity_association_key_secret_version: Optional[pulumi.Input[str]] = None,
             connectivity_association_name_secret_version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("connectivity_association_key_secret_id", connectivity_association_key_secret_id)
        _setter("connectivity_association_name_secret_id", connectivity_association_name_secret_id)
        if connectivity_association_key_secret_version is not None:
            _setter("connectivity_association_key_secret_version", connectivity_association_key_secret_version)
        if connectivity_association_name_secret_version is not None:
            _setter("connectivity_association_name_secret_version", connectivity_association_name_secret_version)

    @property
    @pulumi.getter(name="connectivityAssociationKeySecretId")
    def connectivity_association_key_secret_id(self) -> pulumi.Input[str]:
        """
        (Updatable) Secret [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) containing the Connectivity Association Key (CAK) of this MACsec key.

        NOTE: Only the latest secret version will be used.
        """
        return pulumi.get(self, "connectivity_association_key_secret_id")

    @connectivity_association_key_secret_id.setter
    def connectivity_association_key_secret_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "connectivity_association_key_secret_id", value)

    @property
    @pulumi.getter(name="connectivityAssociationNameSecretId")
    def connectivity_association_name_secret_id(self) -> pulumi.Input[str]:
        """
        (Updatable) Secret [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) containing the Connectivity association Key Name (CKN) of this MACsec key.

        NOTE: Only the latest secret version will be used.
        """
        return pulumi.get(self, "connectivity_association_name_secret_id")

    @connectivity_association_name_secret_id.setter
    def connectivity_association_name_secret_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "connectivity_association_name_secret_id", value)

    @property
    @pulumi.getter(name="connectivityAssociationKeySecretVersion")
    def connectivity_association_key_secret_version(self) -> Optional[pulumi.Input[str]]:
        """
        The secret version of the `connectivityAssociationKey` secret in Vault.
        """
        return pulumi.get(self, "connectivity_association_key_secret_version")

    @connectivity_association_key_secret_version.setter
    def connectivity_association_key_secret_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connectivity_association_key_secret_version", value)

    @property
    @pulumi.getter(name="connectivityAssociationNameSecretVersion")
    def connectivity_association_name_secret_version(self) -> Optional[pulumi.Input[str]]:
        """
        The secret version of the connectivity association name secret in Vault.
        """
        return pulumi.get(self, "connectivity_association_name_secret_version")

    @connectivity_association_name_secret_version.setter
    def connectivity_association_name_secret_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connectivity_association_name_secret_version", value)


@pulumi.input_type
class DefaultDhcpOptionsOptionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 custom_dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 search_domain_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 server_type: Optional[pulumi.Input[str]] = None):
        DefaultDhcpOptionsOptionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            custom_dns_servers=custom_dns_servers,
            search_domain_names=search_domain_names,
            server_type=server_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[str],
             custom_dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             search_domain_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             server_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if custom_dns_servers is not None:
            _setter("custom_dns_servers", custom_dns_servers)
        if search_domain_names is not None:
            _setter("search_domain_names", search_domain_names)
        if server_type is not None:
            _setter("server_type", server_type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="customDnsServers")
    def custom_dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "custom_dns_servers")

    @custom_dns_servers.setter
    def custom_dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "custom_dns_servers", value)

    @property
    @pulumi.getter(name="searchDomainNames")
    def search_domain_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "search_domain_names")

    @search_domain_names.setter
    def search_domain_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "search_domain_names", value)

    @property
    @pulumi.getter(name="serverType")
    def server_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "server_type")

    @server_type.setter
    def server_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_type", value)


@pulumi.input_type
class DefaultRouteTableRouteRuleArgs:
    def __init__(__self__, *,
                 network_entity_id: pulumi.Input[str],
                 cidr_block: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 destination: Optional[pulumi.Input[str]] = None,
                 destination_type: Optional[pulumi.Input[str]] = None,
                 route_type: Optional[pulumi.Input[str]] = None):
        DefaultRouteTableRouteRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            network_entity_id=network_entity_id,
            cidr_block=cidr_block,
            description=description,
            destination=destination,
            destination_type=destination_type,
            route_type=route_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             network_entity_id: pulumi.Input[str],
             cidr_block: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             destination: Optional[pulumi.Input[str]] = None,
             destination_type: Optional[pulumi.Input[str]] = None,
             route_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("network_entity_id", network_entity_id)
        if cidr_block is not None:
            warnings.warn("""The 'cidr_block' field has been deprecated. Please use 'destination' instead.""", DeprecationWarning)
            pulumi.log.warn("""cidr_block is deprecated: The 'cidr_block' field has been deprecated. Please use 'destination' instead.""")
        if cidr_block is not None:
            _setter("cidr_block", cidr_block)
        if description is not None:
            _setter("description", description)
        if destination is not None:
            _setter("destination", destination)
        if destination_type is not None:
            _setter("destination_type", destination_type)
        if route_type is not None:
            _setter("route_type", route_type)

    @property
    @pulumi.getter(name="networkEntityId")
    def network_entity_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "network_entity_id")

    @network_entity_id.setter
    def network_entity_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_entity_id", value)

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[pulumi.Input[str]]:
        warnings.warn("""The 'cidr_block' field has been deprecated. Please use 'destination' instead.""", DeprecationWarning)
        pulumi.log.warn("""cidr_block is deprecated: The 'cidr_block' field has been deprecated. Please use 'destination' instead.""")

        return pulumi.get(self, "cidr_block")

    @cidr_block.setter
    def cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cidr_block", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination_type")

    @destination_type.setter
    def destination_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_type", value)

    @property
    @pulumi.getter(name="routeType")
    def route_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "route_type")

    @route_type.setter
    def route_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "route_type", value)


@pulumi.input_type
class DefaultSecurityListEgressSecurityRuleArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 protocol: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 destination_type: Optional[pulumi.Input[str]] = None,
                 icmp_options: Optional[pulumi.Input['DefaultSecurityListEgressSecurityRuleIcmpOptionsArgs']] = None,
                 stateless: Optional[pulumi.Input[bool]] = None,
                 tcp_options: Optional[pulumi.Input['DefaultSecurityListEgressSecurityRuleTcpOptionsArgs']] = None,
                 udp_options: Optional[pulumi.Input['DefaultSecurityListEgressSecurityRuleUdpOptionsArgs']] = None):
        DefaultSecurityListEgressSecurityRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            protocol=protocol,
            description=description,
            destination_type=destination_type,
            icmp_options=icmp_options,
            stateless=stateless,
            tcp_options=tcp_options,
            udp_options=udp_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: pulumi.Input[str],
             protocol: pulumi.Input[str],
             description: Optional[pulumi.Input[str]] = None,
             destination_type: Optional[pulumi.Input[str]] = None,
             icmp_options: Optional[pulumi.Input['DefaultSecurityListEgressSecurityRuleIcmpOptionsArgs']] = None,
             stateless: Optional[pulumi.Input[bool]] = None,
             tcp_options: Optional[pulumi.Input['DefaultSecurityListEgressSecurityRuleTcpOptionsArgs']] = None,
             udp_options: Optional[pulumi.Input['DefaultSecurityListEgressSecurityRuleUdpOptionsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("destination", destination)
        _setter("protocol", protocol)
        if description is not None:
            _setter("description", description)
        if destination_type is not None:
            _setter("destination_type", destination_type)
        if icmp_options is not None:
            _setter("icmp_options", icmp_options)
        if stateless is not None:
            _setter("stateless", stateless)
        if tcp_options is not None:
            _setter("tcp_options", tcp_options)
        if udp_options is not None:
            _setter("udp_options", udp_options)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination_type")

    @destination_type.setter
    def destination_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_type", value)

    @property
    @pulumi.getter(name="icmpOptions")
    def icmp_options(self) -> Optional[pulumi.Input['DefaultSecurityListEgressSecurityRuleIcmpOptionsArgs']]:
        return pulumi.get(self, "icmp_options")

    @icmp_options.setter
    def icmp_options(self, value: Optional[pulumi.Input['DefaultSecurityListEgressSecurityRuleIcmpOptionsArgs']]):
        pulumi.set(self, "icmp_options", value)

    @property
    @pulumi.getter
    def stateless(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "stateless")

    @stateless.setter
    def stateless(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "stateless", value)

    @property
    @pulumi.getter(name="tcpOptions")
    def tcp_options(self) -> Optional[pulumi.Input['DefaultSecurityListEgressSecurityRuleTcpOptionsArgs']]:
        return pulumi.get(self, "tcp_options")

    @tcp_options.setter
    def tcp_options(self, value: Optional[pulumi.Input['DefaultSecurityListEgressSecurityRuleTcpOptionsArgs']]):
        pulumi.set(self, "tcp_options", value)

    @property
    @pulumi.getter(name="udpOptions")
    def udp_options(self) -> Optional[pulumi.Input['DefaultSecurityListEgressSecurityRuleUdpOptionsArgs']]:
        return pulumi.get(self, "udp_options")

    @udp_options.setter
    def udp_options(self, value: Optional[pulumi.Input['DefaultSecurityListEgressSecurityRuleUdpOptionsArgs']]):
        pulumi.set(self, "udp_options", value)


@pulumi.input_type
class DefaultSecurityListEgressSecurityRuleIcmpOptionsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[int],
                 code: Optional[pulumi.Input[int]] = None):
        DefaultSecurityListEgressSecurityRuleIcmpOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            code=code,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[int],
             code: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if code is not None:
            _setter("code", code)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[int]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[int]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)


@pulumi.input_type
class DefaultSecurityListEgressSecurityRuleTcpOptionsArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[int]] = None,
                 min: Optional[pulumi.Input[int]] = None,
                 source_port_range: Optional[pulumi.Input['DefaultSecurityListEgressSecurityRuleTcpOptionsSourcePortRangeArgs']] = None):
        DefaultSecurityListEgressSecurityRuleTcpOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
            source_port_range=source_port_range,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[pulumi.Input[int]] = None,
             min: Optional[pulumi.Input[int]] = None,
             source_port_range: Optional[pulumi.Input['DefaultSecurityListEgressSecurityRuleTcpOptionsSourcePortRangeArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)
        if source_port_range is not None:
            _setter("source_port_range", source_port_range)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional[pulumi.Input['DefaultSecurityListEgressSecurityRuleTcpOptionsSourcePortRangeArgs']]:
        return pulumi.get(self, "source_port_range")

    @source_port_range.setter
    def source_port_range(self, value: Optional[pulumi.Input['DefaultSecurityListEgressSecurityRuleTcpOptionsSourcePortRangeArgs']]):
        pulumi.set(self, "source_port_range", value)


@pulumi.input_type
class DefaultSecurityListEgressSecurityRuleTcpOptionsSourcePortRangeArgs:
    def __init__(__self__, *,
                 max: pulumi.Input[int],
                 min: pulumi.Input[int]):
        DefaultSecurityListEgressSecurityRuleTcpOptionsSourcePortRangeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: pulumi.Input[int],
             min: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("max", max)
        _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> pulumi.Input[int]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[int]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> pulumi.Input[int]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[int]):
        pulumi.set(self, "min", value)


@pulumi.input_type
class DefaultSecurityListEgressSecurityRuleUdpOptionsArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[int]] = None,
                 min: Optional[pulumi.Input[int]] = None,
                 source_port_range: Optional[pulumi.Input['DefaultSecurityListEgressSecurityRuleUdpOptionsSourcePortRangeArgs']] = None):
        DefaultSecurityListEgressSecurityRuleUdpOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
            source_port_range=source_port_range,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[pulumi.Input[int]] = None,
             min: Optional[pulumi.Input[int]] = None,
             source_port_range: Optional[pulumi.Input['DefaultSecurityListEgressSecurityRuleUdpOptionsSourcePortRangeArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)
        if source_port_range is not None:
            _setter("source_port_range", source_port_range)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional[pulumi.Input['DefaultSecurityListEgressSecurityRuleUdpOptionsSourcePortRangeArgs']]:
        return pulumi.get(self, "source_port_range")

    @source_port_range.setter
    def source_port_range(self, value: Optional[pulumi.Input['DefaultSecurityListEgressSecurityRuleUdpOptionsSourcePortRangeArgs']]):
        pulumi.set(self, "source_port_range", value)


@pulumi.input_type
class DefaultSecurityListEgressSecurityRuleUdpOptionsSourcePortRangeArgs:
    def __init__(__self__, *,
                 max: pulumi.Input[int],
                 min: pulumi.Input[int]):
        DefaultSecurityListEgressSecurityRuleUdpOptionsSourcePortRangeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: pulumi.Input[int],
             min: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("max", max)
        _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> pulumi.Input[int]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[int]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> pulumi.Input[int]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[int]):
        pulumi.set(self, "min", value)


@pulumi.input_type
class DefaultSecurityListIngressSecurityRuleArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 source: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 icmp_options: Optional[pulumi.Input['DefaultSecurityListIngressSecurityRuleIcmpOptionsArgs']] = None,
                 source_type: Optional[pulumi.Input[str]] = None,
                 stateless: Optional[pulumi.Input[bool]] = None,
                 tcp_options: Optional[pulumi.Input['DefaultSecurityListIngressSecurityRuleTcpOptionsArgs']] = None,
                 udp_options: Optional[pulumi.Input['DefaultSecurityListIngressSecurityRuleUdpOptionsArgs']] = None):
        DefaultSecurityListIngressSecurityRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            protocol=protocol,
            source=source,
            description=description,
            icmp_options=icmp_options,
            source_type=source_type,
            stateless=stateless,
            tcp_options=tcp_options,
            udp_options=udp_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             protocol: pulumi.Input[str],
             source: pulumi.Input[str],
             description: Optional[pulumi.Input[str]] = None,
             icmp_options: Optional[pulumi.Input['DefaultSecurityListIngressSecurityRuleIcmpOptionsArgs']] = None,
             source_type: Optional[pulumi.Input[str]] = None,
             stateless: Optional[pulumi.Input[bool]] = None,
             tcp_options: Optional[pulumi.Input['DefaultSecurityListIngressSecurityRuleTcpOptionsArgs']] = None,
             udp_options: Optional[pulumi.Input['DefaultSecurityListIngressSecurityRuleUdpOptionsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("protocol", protocol)
        _setter("source", source)
        if description is not None:
            _setter("description", description)
        if icmp_options is not None:
            _setter("icmp_options", icmp_options)
        if source_type is not None:
            _setter("source_type", source_type)
        if stateless is not None:
            _setter("stateless", stateless)
        if tcp_options is not None:
            _setter("tcp_options", tcp_options)
        if udp_options is not None:
            _setter("udp_options", udp_options)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="icmpOptions")
    def icmp_options(self) -> Optional[pulumi.Input['DefaultSecurityListIngressSecurityRuleIcmpOptionsArgs']]:
        return pulumi.get(self, "icmp_options")

    @icmp_options.setter
    def icmp_options(self, value: Optional[pulumi.Input['DefaultSecurityListIngressSecurityRuleIcmpOptionsArgs']]):
        pulumi.set(self, "icmp_options", value)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_type", value)

    @property
    @pulumi.getter
    def stateless(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "stateless")

    @stateless.setter
    def stateless(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "stateless", value)

    @property
    @pulumi.getter(name="tcpOptions")
    def tcp_options(self) -> Optional[pulumi.Input['DefaultSecurityListIngressSecurityRuleTcpOptionsArgs']]:
        return pulumi.get(self, "tcp_options")

    @tcp_options.setter
    def tcp_options(self, value: Optional[pulumi.Input['DefaultSecurityListIngressSecurityRuleTcpOptionsArgs']]):
        pulumi.set(self, "tcp_options", value)

    @property
    @pulumi.getter(name="udpOptions")
    def udp_options(self) -> Optional[pulumi.Input['DefaultSecurityListIngressSecurityRuleUdpOptionsArgs']]:
        return pulumi.get(self, "udp_options")

    @udp_options.setter
    def udp_options(self, value: Optional[pulumi.Input['DefaultSecurityListIngressSecurityRuleUdpOptionsArgs']]):
        pulumi.set(self, "udp_options", value)


@pulumi.input_type
class DefaultSecurityListIngressSecurityRuleIcmpOptionsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[int],
                 code: Optional[pulumi.Input[int]] = None):
        DefaultSecurityListIngressSecurityRuleIcmpOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            code=code,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[int],
             code: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if code is not None:
            _setter("code", code)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[int]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[int]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)


@pulumi.input_type
class DefaultSecurityListIngressSecurityRuleTcpOptionsArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[int]] = None,
                 min: Optional[pulumi.Input[int]] = None,
                 source_port_range: Optional[pulumi.Input['DefaultSecurityListIngressSecurityRuleTcpOptionsSourcePortRangeArgs']] = None):
        DefaultSecurityListIngressSecurityRuleTcpOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
            source_port_range=source_port_range,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[pulumi.Input[int]] = None,
             min: Optional[pulumi.Input[int]] = None,
             source_port_range: Optional[pulumi.Input['DefaultSecurityListIngressSecurityRuleTcpOptionsSourcePortRangeArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)
        if source_port_range is not None:
            _setter("source_port_range", source_port_range)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional[pulumi.Input['DefaultSecurityListIngressSecurityRuleTcpOptionsSourcePortRangeArgs']]:
        return pulumi.get(self, "source_port_range")

    @source_port_range.setter
    def source_port_range(self, value: Optional[pulumi.Input['DefaultSecurityListIngressSecurityRuleTcpOptionsSourcePortRangeArgs']]):
        pulumi.set(self, "source_port_range", value)


@pulumi.input_type
class DefaultSecurityListIngressSecurityRuleTcpOptionsSourcePortRangeArgs:
    def __init__(__self__, *,
                 max: pulumi.Input[int],
                 min: pulumi.Input[int]):
        DefaultSecurityListIngressSecurityRuleTcpOptionsSourcePortRangeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: pulumi.Input[int],
             min: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("max", max)
        _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> pulumi.Input[int]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[int]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> pulumi.Input[int]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[int]):
        pulumi.set(self, "min", value)


@pulumi.input_type
class DefaultSecurityListIngressSecurityRuleUdpOptionsArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[int]] = None,
                 min: Optional[pulumi.Input[int]] = None,
                 source_port_range: Optional[pulumi.Input['DefaultSecurityListIngressSecurityRuleUdpOptionsSourcePortRangeArgs']] = None):
        DefaultSecurityListIngressSecurityRuleUdpOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
            source_port_range=source_port_range,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[pulumi.Input[int]] = None,
             min: Optional[pulumi.Input[int]] = None,
             source_port_range: Optional[pulumi.Input['DefaultSecurityListIngressSecurityRuleUdpOptionsSourcePortRangeArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)
        if source_port_range is not None:
            _setter("source_port_range", source_port_range)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional[pulumi.Input['DefaultSecurityListIngressSecurityRuleUdpOptionsSourcePortRangeArgs']]:
        return pulumi.get(self, "source_port_range")

    @source_port_range.setter
    def source_port_range(self, value: Optional[pulumi.Input['DefaultSecurityListIngressSecurityRuleUdpOptionsSourcePortRangeArgs']]):
        pulumi.set(self, "source_port_range", value)


@pulumi.input_type
class DefaultSecurityListIngressSecurityRuleUdpOptionsSourcePortRangeArgs:
    def __init__(__self__, *,
                 max: pulumi.Input[int],
                 min: pulumi.Input[int]):
        DefaultSecurityListIngressSecurityRuleUdpOptionsSourcePortRangeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: pulumi.Input[int],
             min: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("max", max)
        _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> pulumi.Input[int]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[int]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> pulumi.Input[int]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[int]):
        pulumi.set(self, "min", value)


@pulumi.input_type
class DhcpOptionsOptionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 custom_dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 search_domain_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 server_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: (Updatable) The specific DHCP option. Either `DomainNameServer` (for [DhcpDnsOption](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/DhcpDnsOption/)) or `SearchDomain` (for [DhcpSearchDomainOption](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/DhcpSearchDomainOption/)).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] custom_dns_servers: (Updatable) If you set `serverType` to `CustomDnsServer`, specify the IP address of at least one DNS server of your choice (three maximum).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] search_domain_names: (Updatable) A single search domain name according to [RFC 952](https://tools.ietf.org/html/rfc952) and [RFC 1123](https://tools.ietf.org/html/rfc1123). During a DNS query, the OS will append this search domain name to the value being queried.
               
               If you set [DhcpDnsOption](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/DhcpDnsOption/) to `VcnLocalPlusInternet`, and you assign a DNS label to the VCN during creation, the search domain name in the VCN's default set of DHCP options is automatically set to the VCN domain (for example, `vcn1.oraclevcn.com`).
               
               If you don't want to use a search domain name, omit this option from the set of DHCP options. Do not include this option with an empty list of search domain names, or with an empty string as the value for any search domain name.
        :param pulumi.Input[str] server_type: (Updatable) 
               * **VcnLocal:** Reserved for future use.
               * **VcnLocalPlusInternet:** Also referred to as "Internet and VCN Resolver". Instances can resolve internet hostnames (no internet gateway is required), and can resolve hostnames of instances in the VCN. This is the default value in the default set of DHCP options in the VCN. For the Internet and VCN Resolver to work across the VCN, there must also be a DNS label set for the VCN, a DNS label set for each subnet, and a hostname for each instance. The Internet and VCN Resolver also enables reverse DNS lookup, which lets you determine the hostname corresponding to the private IP address. For more information, see [DNS in Your Virtual Cloud Network](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/dns.htm).
               * **CustomDnsServer:** Instances use a DNS server of your choice (three maximum).
        """
        DhcpOptionsOptionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            custom_dns_servers=custom_dns_servers,
            search_domain_names=search_domain_names,
            server_type=server_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[str],
             custom_dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             search_domain_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             server_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if custom_dns_servers is not None:
            _setter("custom_dns_servers", custom_dns_servers)
        if search_domain_names is not None:
            _setter("search_domain_names", search_domain_names)
        if server_type is not None:
            _setter("server_type", server_type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) The specific DHCP option. Either `DomainNameServer` (for [DhcpDnsOption](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/DhcpDnsOption/)) or `SearchDomain` (for [DhcpSearchDomainOption](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/DhcpSearchDomainOption/)).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="customDnsServers")
    def custom_dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) If you set `serverType` to `CustomDnsServer`, specify the IP address of at least one DNS server of your choice (three maximum).
        """
        return pulumi.get(self, "custom_dns_servers")

    @custom_dns_servers.setter
    def custom_dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "custom_dns_servers", value)

    @property
    @pulumi.getter(name="searchDomainNames")
    def search_domain_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) A single search domain name according to [RFC 952](https://tools.ietf.org/html/rfc952) and [RFC 1123](https://tools.ietf.org/html/rfc1123). During a DNS query, the OS will append this search domain name to the value being queried.

        If you set [DhcpDnsOption](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/DhcpDnsOption/) to `VcnLocalPlusInternet`, and you assign a DNS label to the VCN during creation, the search domain name in the VCN's default set of DHCP options is automatically set to the VCN domain (for example, `vcn1.oraclevcn.com`).

        If you don't want to use a search domain name, omit this option from the set of DHCP options. Do not include this option with an empty list of search domain names, or with an empty string as the value for any search domain name.
        """
        return pulumi.get(self, "search_domain_names")

    @search_domain_names.setter
    def search_domain_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "search_domain_names", value)

    @property
    @pulumi.getter(name="serverType")
    def server_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) 
        * **VcnLocal:** Reserved for future use.
        * **VcnLocalPlusInternet:** Also referred to as "Internet and VCN Resolver". Instances can resolve internet hostnames (no internet gateway is required), and can resolve hostnames of instances in the VCN. This is the default value in the default set of DHCP options in the VCN. For the Internet and VCN Resolver to work across the VCN, there must also be a DNS label set for the VCN, a DNS label set for each subnet, and a hostname for each instance. The Internet and VCN Resolver also enables reverse DNS lookup, which lets you determine the hostname corresponding to the private IP address. For more information, see [DNS in Your Virtual Cloud Network](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/dns.htm).
        * **CustomDnsServer:** Instances use a DNS server of your choice (three maximum).
        """
        return pulumi.get(self, "server_type")

    @server_type.setter
    def server_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_type", value)


@pulumi.input_type
class DrgAttachmentManagementNetworkDetailsArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: pulumi.Input[str],
                 ipsec_connection_id: Optional[pulumi.Input[str]] = None,
                 route_table_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the network attached to the DRG.
        :param pulumi.Input[str] type: The type can be one of these values: `IPSEC_TUNNEL`, `REMOTE_PEERING_CONNECTION`, `VCN`,`VIRTUAL_CIRCUIT`
        :param pulumi.Input[str] ipsec_connection_id: The IPSec connection that contains the attached IPSec tunnel.
        :param pulumi.Input[str] route_table_id: The OCID of the route table the DRG attachment is using.
               
               For information about why you would associate a route table with a DRG attachment, see:
               * [Transit Routing: Access to Multiple VCNs in Same Region](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/transitrouting.htm)
               * [Transit Routing: Private Access to Oracle Services](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/transitroutingoracleservices.htm) This field is deprecated. Instead, use the `networkDetails` field to view the [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the attached resource.
        """
        DrgAttachmentManagementNetworkDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            type=type,
            ipsec_connection_id=ipsec_connection_id,
            route_table_id=route_table_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: pulumi.Input[str],
             type: pulumi.Input[str],
             ipsec_connection_id: Optional[pulumi.Input[str]] = None,
             route_table_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("type", type)
        if ipsec_connection_id is not None:
            _setter("ipsec_connection_id", ipsec_connection_id)
        if route_table_id is not None:
            _setter("route_table_id", route_table_id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the network attached to the DRG.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type can be one of these values: `IPSEC_TUNNEL`, `REMOTE_PEERING_CONNECTION`, `VCN`,`VIRTUAL_CIRCUIT`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="ipsecConnectionId")
    def ipsec_connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        The IPSec connection that contains the attached IPSec tunnel.
        """
        return pulumi.get(self, "ipsec_connection_id")

    @ipsec_connection_id.setter
    def ipsec_connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipsec_connection_id", value)

    @property
    @pulumi.getter(name="routeTableId")
    def route_table_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the route table the DRG attachment is using.

        For information about why you would associate a route table with a DRG attachment, see:
        * [Transit Routing: Access to Multiple VCNs in Same Region](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/transitrouting.htm)
        * [Transit Routing: Private Access to Oracle Services](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/transitroutingoracleservices.htm) This field is deprecated. Instead, use the `networkDetails` field to view the [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the attached resource.
        """
        return pulumi.get(self, "route_table_id")

    @route_table_id.setter
    def route_table_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "route_table_id", value)


@pulumi.input_type
class DrgAttachmentNetworkDetailsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ipsec_connection_id: Optional[pulumi.Input[str]] = None,
                 route_table_id: Optional[pulumi.Input[str]] = None,
                 transport_attachment_id: Optional[pulumi.Input[str]] = None,
                 transport_only_mode: Optional[pulumi.Input[bool]] = None,
                 vcn_route_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: (Updatable) The type can be one of these values: `IPSEC_TUNNEL`, `LOOPBACK`, `REMOTE_PEERING_CONNECTION`, `VCN`, `VIRTUAL_CIRCUIT`
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the network attached to the DRG.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ids: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the target IPSec tunnel attachment.
        :param pulumi.Input[str] ipsec_connection_id: The IPSec connection that contains the attached IPSec tunnel.
        :param pulumi.Input[str] route_table_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the route table used by the DRG attachment.
               
               If you don't specify a route table here, the DRG attachment is created without an associated route table. The Networking service does NOT automatically associate the attached VCN's default route table with the DRG attachment. For information about why you would associate a route table with a DRG attachment, see:
               * [Transit Routing: Access to Multiple VCNs in Same Region](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/transitrouting.htm)
               * [Transit Routing: Private Access to Oracle Services](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/transitroutingoracleservices.htm)
               This field is deprecated. Instead, use the networkDetails field to specify the VCN route table for this attachment.
        :param pulumi.Input[str] transport_attachment_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the virtual circuit's DRG attachment.
        :param pulumi.Input[bool] transport_only_mode: Boolean flag that determines wether all traffic over the virtual circuits is encrypted.  Example: `true`
        :param pulumi.Input[str] vcn_route_type: (Updatable) Indicates whether the VCN CIDRs or the individual subnet CIDRs are imported from the attachment. Routes from the VCN ingress route table are always imported.
        """
        DrgAttachmentNetworkDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            id=id,
            ids=ids,
            ipsec_connection_id=ipsec_connection_id,
            route_table_id=route_table_id,
            transport_attachment_id=transport_attachment_id,
            transport_only_mode=transport_only_mode,
            vcn_route_type=vcn_route_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[str],
             id: Optional[pulumi.Input[str]] = None,
             ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             ipsec_connection_id: Optional[pulumi.Input[str]] = None,
             route_table_id: Optional[pulumi.Input[str]] = None,
             transport_attachment_id: Optional[pulumi.Input[str]] = None,
             transport_only_mode: Optional[pulumi.Input[bool]] = None,
             vcn_route_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if id is not None:
            _setter("id", id)
        if ids is not None:
            _setter("ids", ids)
        if ipsec_connection_id is not None:
            _setter("ipsec_connection_id", ipsec_connection_id)
        if route_table_id is not None:
            _setter("route_table_id", route_table_id)
        if transport_attachment_id is not None:
            _setter("transport_attachment_id", transport_attachment_id)
        if transport_only_mode is not None:
            _setter("transport_only_mode", transport_only_mode)
        if vcn_route_type is not None:
            _setter("vcn_route_type", vcn_route_type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) The type can be one of these values: `IPSEC_TUNNEL`, `LOOPBACK`, `REMOTE_PEERING_CONNECTION`, `VCN`, `VIRTUAL_CIRCUIT`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the network attached to the DRG.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the target IPSec tunnel attachment.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ids", value)

    @property
    @pulumi.getter(name="ipsecConnectionId")
    def ipsec_connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        The IPSec connection that contains the attached IPSec tunnel.
        """
        return pulumi.get(self, "ipsec_connection_id")

    @ipsec_connection_id.setter
    def ipsec_connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipsec_connection_id", value)

    @property
    @pulumi.getter(name="routeTableId")
    def route_table_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the route table used by the DRG attachment.

        If you don't specify a route table here, the DRG attachment is created without an associated route table. The Networking service does NOT automatically associate the attached VCN's default route table with the DRG attachment. For information about why you would associate a route table with a DRG attachment, see:
        * [Transit Routing: Access to Multiple VCNs in Same Region](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/transitrouting.htm)
        * [Transit Routing: Private Access to Oracle Services](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/transitroutingoracleservices.htm)
        This field is deprecated. Instead, use the networkDetails field to specify the VCN route table for this attachment.
        """
        return pulumi.get(self, "route_table_id")

    @route_table_id.setter
    def route_table_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "route_table_id", value)

    @property
    @pulumi.getter(name="transportAttachmentId")
    def transport_attachment_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the virtual circuit's DRG attachment.
        """
        return pulumi.get(self, "transport_attachment_id")

    @transport_attachment_id.setter
    def transport_attachment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "transport_attachment_id", value)

    @property
    @pulumi.getter(name="transportOnlyMode")
    def transport_only_mode(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean flag that determines wether all traffic over the virtual circuits is encrypted.  Example: `true`
        """
        return pulumi.get(self, "transport_only_mode")

    @transport_only_mode.setter
    def transport_only_mode(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "transport_only_mode", value)

    @property
    @pulumi.getter(name="vcnRouteType")
    def vcn_route_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Indicates whether the VCN CIDRs or the individual subnet CIDRs are imported from the attachment. Routes from the VCN ingress route table are always imported.
        """
        return pulumi.get(self, "vcn_route_type")

    @vcn_route_type.setter
    def vcn_route_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vcn_route_type", value)


@pulumi.input_type
class DrgAttachmentsListDrgAllAttachmentArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The Oracle-assigned ID of the DRG attachment
        """
        DrgAttachmentsListDrgAllAttachmentArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The Oracle-assigned ID of the DRG attachment
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class DrgDefaultDrgRouteTableArgs:
    def __init__(__self__, *,
                 ipsec_tunnel: Optional[pulumi.Input[str]] = None,
                 remote_peering_connection: Optional[pulumi.Input[str]] = None,
                 vcn: Optional[pulumi.Input[str]] = None,
                 virtual_circuit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ipsec_tunnel: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the default DRG route table assigned to DRG attachments of type IPSEC_TUNNEL on creation.
        :param pulumi.Input[str] remote_peering_connection: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the default DRG route table to be assigned to DRG attachments of type REMOTE_PEERING_CONNECTION on creation.
        :param pulumi.Input[str] vcn: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the default DRG route table to be assigned to DRG attachments of type VCN on creation.
        :param pulumi.Input[str] virtual_circuit: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the default DRG route table to be assigned to DRG attachments of type VIRTUAL_CIRCUIT on creation.
        """
        DrgDefaultDrgRouteTableArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ipsec_tunnel=ipsec_tunnel,
            remote_peering_connection=remote_peering_connection,
            vcn=vcn,
            virtual_circuit=virtual_circuit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ipsec_tunnel: Optional[pulumi.Input[str]] = None,
             remote_peering_connection: Optional[pulumi.Input[str]] = None,
             vcn: Optional[pulumi.Input[str]] = None,
             virtual_circuit: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ipsec_tunnel is not None:
            _setter("ipsec_tunnel", ipsec_tunnel)
        if remote_peering_connection is not None:
            _setter("remote_peering_connection", remote_peering_connection)
        if vcn is not None:
            _setter("vcn", vcn)
        if virtual_circuit is not None:
            _setter("virtual_circuit", virtual_circuit)

    @property
    @pulumi.getter(name="ipsecTunnel")
    def ipsec_tunnel(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the default DRG route table assigned to DRG attachments of type IPSEC_TUNNEL on creation.
        """
        return pulumi.get(self, "ipsec_tunnel")

    @ipsec_tunnel.setter
    def ipsec_tunnel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipsec_tunnel", value)

    @property
    @pulumi.getter(name="remotePeeringConnection")
    def remote_peering_connection(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the default DRG route table to be assigned to DRG attachments of type REMOTE_PEERING_CONNECTION on creation.
        """
        return pulumi.get(self, "remote_peering_connection")

    @remote_peering_connection.setter
    def remote_peering_connection(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_peering_connection", value)

    @property
    @pulumi.getter
    def vcn(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the default DRG route table to be assigned to DRG attachments of type VCN on creation.
        """
        return pulumi.get(self, "vcn")

    @vcn.setter
    def vcn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vcn", value)

    @property
    @pulumi.getter(name="virtualCircuit")
    def virtual_circuit(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the default DRG route table to be assigned to DRG attachments of type VIRTUAL_CIRCUIT on creation.
        """
        return pulumi.get(self, "virtual_circuit")

    @virtual_circuit.setter
    def virtual_circuit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_circuit", value)


@pulumi.input_type
class DrgRouteDistributionStatementMatchCriteriaArgs:
    def __init__(__self__, *,
                 attachment_type: Optional[pulumi.Input[str]] = None,
                 drg_attachment_id: Optional[pulumi.Input[str]] = None,
                 match_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] attachment_type: The type of the network resource to be included in this match. A match for a network type implies that all DRG attachments of that type insert routes into the table.
        :param pulumi.Input[str] drg_attachment_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DRG attachment.
        :param pulumi.Input[str] match_type: (Updatable) The type of the match criteria for a route distribution statement.
        """
        DrgRouteDistributionStatementMatchCriteriaArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attachment_type=attachment_type,
            drg_attachment_id=drg_attachment_id,
            match_type=match_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attachment_type: Optional[pulumi.Input[str]] = None,
             drg_attachment_id: Optional[pulumi.Input[str]] = None,
             match_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if attachment_type is not None:
            _setter("attachment_type", attachment_type)
        if drg_attachment_id is not None:
            _setter("drg_attachment_id", drg_attachment_id)
        if match_type is not None:
            _setter("match_type", match_type)

    @property
    @pulumi.getter(name="attachmentType")
    def attachment_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the network resource to be included in this match. A match for a network type implies that all DRG attachments of that type insert routes into the table.
        """
        return pulumi.get(self, "attachment_type")

    @attachment_type.setter
    def attachment_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attachment_type", value)

    @property
    @pulumi.getter(name="drgAttachmentId")
    def drg_attachment_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DRG attachment.
        """
        return pulumi.get(self, "drg_attachment_id")

    @drg_attachment_id.setter
    def drg_attachment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "drg_attachment_id", value)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The type of the match criteria for a route distribution statement.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_type", value)


@pulumi.input_type
class ImageAgentFeatureArgs:
    def __init__(__self__, *,
                 is_management_supported: Optional[pulumi.Input[bool]] = None,
                 is_monitoring_supported: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_management_supported: This attribute is not used.
        :param pulumi.Input[bool] is_monitoring_supported: This attribute is not used.
        """
        ImageAgentFeatureArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_management_supported=is_management_supported,
            is_monitoring_supported=is_monitoring_supported,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_management_supported: Optional[pulumi.Input[bool]] = None,
             is_monitoring_supported: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_management_supported is not None:
            _setter("is_management_supported", is_management_supported)
        if is_monitoring_supported is not None:
            _setter("is_monitoring_supported", is_monitoring_supported)

    @property
    @pulumi.getter(name="isManagementSupported")
    def is_management_supported(self) -> Optional[pulumi.Input[bool]]:
        """
        This attribute is not used.
        """
        return pulumi.get(self, "is_management_supported")

    @is_management_supported.setter
    def is_management_supported(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_management_supported", value)

    @property
    @pulumi.getter(name="isMonitoringSupported")
    def is_monitoring_supported(self) -> Optional[pulumi.Input[bool]]:
        """
        This attribute is not used.
        """
        return pulumi.get(self, "is_monitoring_supported")

    @is_monitoring_supported.setter
    def is_monitoring_supported(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monitoring_supported", value)


@pulumi.input_type
class ImageImageSourceDetailsArgs:
    def __init__(__self__, *,
                 source_type: pulumi.Input[str],
                 bucket_name: Optional[pulumi.Input[str]] = None,
                 namespace_name: Optional[pulumi.Input[str]] = None,
                 object_name: Optional[pulumi.Input[str]] = None,
                 operating_system: Optional[pulumi.Input[str]] = None,
                 operating_system_version: Optional[pulumi.Input[str]] = None,
                 source_image_type: Optional[pulumi.Input[str]] = None,
                 source_uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] source_type: The source type for the image. Use `objectStorageTuple` when specifying the namespace, bucket name, and object name. Use `objectStorageUri` when specifying the Object Storage URL.
        :param pulumi.Input[str] bucket_name: The Object Storage bucket for the image.
        :param pulumi.Input[str] namespace_name: The Object Storage namespace for the image.
        :param pulumi.Input[str] object_name: The Object Storage name for the image.
        :param pulumi.Input[str] operating_system: The image's operating system.  Example: `Oracle Linux`
        :param pulumi.Input[str] operating_system_version: The image's operating system version.  Example: `7.2`
        :param pulumi.Input[str] source_image_type: The format of the image to be imported.  Only monolithic images are supported. This attribute is not used for exported Oracle images with the Oracle Cloud Infrastructure image format. Allowed values are:
        :param pulumi.Input[str] source_uri: The Object Storage URL for the image.
        """
        ImageImageSourceDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_type=source_type,
            bucket_name=bucket_name,
            namespace_name=namespace_name,
            object_name=object_name,
            operating_system=operating_system,
            operating_system_version=operating_system_version,
            source_image_type=source_image_type,
            source_uri=source_uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_type: pulumi.Input[str],
             bucket_name: Optional[pulumi.Input[str]] = None,
             namespace_name: Optional[pulumi.Input[str]] = None,
             object_name: Optional[pulumi.Input[str]] = None,
             operating_system: Optional[pulumi.Input[str]] = None,
             operating_system_version: Optional[pulumi.Input[str]] = None,
             source_image_type: Optional[pulumi.Input[str]] = None,
             source_uri: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("source_type", source_type)
        if bucket_name is not None:
            _setter("bucket_name", bucket_name)
        if namespace_name is not None:
            _setter("namespace_name", namespace_name)
        if object_name is not None:
            _setter("object_name", object_name)
        if operating_system is not None:
            _setter("operating_system", operating_system)
        if operating_system_version is not None:
            _setter("operating_system_version", operating_system_version)
        if source_image_type is not None:
            _setter("source_image_type", source_image_type)
        if source_uri is not None:
            _setter("source_uri", source_uri)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[str]:
        """
        The source type for the image. Use `objectStorageTuple` when specifying the namespace, bucket name, and object name. Use `objectStorageUri` when specifying the Object Storage URL.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_type", value)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[str]]:
        """
        The Object Storage bucket for the image.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="namespaceName")
    def namespace_name(self) -> Optional[pulumi.Input[str]]:
        """
        The Object Storage namespace for the image.
        """
        return pulumi.get(self, "namespace_name")

    @namespace_name.setter
    def namespace_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace_name", value)

    @property
    @pulumi.getter(name="objectName")
    def object_name(self) -> Optional[pulumi.Input[str]]:
        """
        The Object Storage name for the image.
        """
        return pulumi.get(self, "object_name")

    @object_name.setter
    def object_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_name", value)

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> Optional[pulumi.Input[str]]:
        """
        The image's operating system.  Example: `Oracle Linux`
        """
        return pulumi.get(self, "operating_system")

    @operating_system.setter
    def operating_system(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operating_system", value)

    @property
    @pulumi.getter(name="operatingSystemVersion")
    def operating_system_version(self) -> Optional[pulumi.Input[str]]:
        """
        The image's operating system version.  Example: `7.2`
        """
        return pulumi.get(self, "operating_system_version")

    @operating_system_version.setter
    def operating_system_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operating_system_version", value)

    @property
    @pulumi.getter(name="sourceImageType")
    def source_image_type(self) -> Optional[pulumi.Input[str]]:
        """
        The format of the image to be imported.  Only monolithic images are supported. This attribute is not used for exported Oracle images with the Oracle Cloud Infrastructure image format. Allowed values are:
        """
        return pulumi.get(self, "source_image_type")

    @source_image_type.setter
    def source_image_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_image_type", value)

    @property
    @pulumi.getter(name="sourceUri")
    def source_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The Object Storage URL for the image.
        """
        return pulumi.get(self, "source_uri")

    @source_uri.setter
    def source_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_uri", value)


@pulumi.input_type
class ImageLaunchOptionArgs:
    def __init__(__self__, *,
                 boot_volume_type: Optional[pulumi.Input[str]] = None,
                 firmware: Optional[pulumi.Input[str]] = None,
                 is_consistent_volume_naming_enabled: Optional[pulumi.Input[bool]] = None,
                 is_pv_encryption_in_transit_enabled: Optional[pulumi.Input[bool]] = None,
                 network_type: Optional[pulumi.Input[str]] = None,
                 remote_data_volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] boot_volume_type: Emulation type for the boot volume.
        :param pulumi.Input[str] firmware: Firmware used to boot VM. Select the option that matches your operating system.
        :param pulumi.Input[bool] is_consistent_volume_naming_enabled: Whether to enable consistent volume naming feature. Defaults to false.
        :param pulumi.Input[bool] is_pv_encryption_in_transit_enabled: Deprecated. Instead use `isPvEncryptionInTransitEnabled` in [LaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/datatypes/LaunchInstanceDetails).
        :param pulumi.Input[str] network_type: Emulation type for the physical network interface card (NIC).
        :param pulumi.Input[str] remote_data_volume_type: Emulation type for volume.
        """
        ImageLaunchOptionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            boot_volume_type=boot_volume_type,
            firmware=firmware,
            is_consistent_volume_naming_enabled=is_consistent_volume_naming_enabled,
            is_pv_encryption_in_transit_enabled=is_pv_encryption_in_transit_enabled,
            network_type=network_type,
            remote_data_volume_type=remote_data_volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             boot_volume_type: Optional[pulumi.Input[str]] = None,
             firmware: Optional[pulumi.Input[str]] = None,
             is_consistent_volume_naming_enabled: Optional[pulumi.Input[bool]] = None,
             is_pv_encryption_in_transit_enabled: Optional[pulumi.Input[bool]] = None,
             network_type: Optional[pulumi.Input[str]] = None,
             remote_data_volume_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if boot_volume_type is not None:
            _setter("boot_volume_type", boot_volume_type)
        if firmware is not None:
            _setter("firmware", firmware)
        if is_consistent_volume_naming_enabled is not None:
            _setter("is_consistent_volume_naming_enabled", is_consistent_volume_naming_enabled)
        if is_pv_encryption_in_transit_enabled is not None:
            _setter("is_pv_encryption_in_transit_enabled", is_pv_encryption_in_transit_enabled)
        if network_type is not None:
            _setter("network_type", network_type)
        if remote_data_volume_type is not None:
            _setter("remote_data_volume_type", remote_data_volume_type)

    @property
    @pulumi.getter(name="bootVolumeType")
    def boot_volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        Emulation type for the boot volume.
        """
        return pulumi.get(self, "boot_volume_type")

    @boot_volume_type.setter
    def boot_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "boot_volume_type", value)

    @property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[str]]:
        """
        Firmware used to boot VM. Select the option that matches your operating system.
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "firmware", value)

    @property
    @pulumi.getter(name="isConsistentVolumeNamingEnabled")
    def is_consistent_volume_naming_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable consistent volume naming feature. Defaults to false.
        """
        return pulumi.get(self, "is_consistent_volume_naming_enabled")

    @is_consistent_volume_naming_enabled.setter
    def is_consistent_volume_naming_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_consistent_volume_naming_enabled", value)

    @property
    @pulumi.getter(name="isPvEncryptionInTransitEnabled")
    def is_pv_encryption_in_transit_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Deprecated. Instead use `isPvEncryptionInTransitEnabled` in [LaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/datatypes/LaunchInstanceDetails).
        """
        return pulumi.get(self, "is_pv_encryption_in_transit_enabled")

    @is_pv_encryption_in_transit_enabled.setter
    def is_pv_encryption_in_transit_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_pv_encryption_in_transit_enabled", value)

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> Optional[pulumi.Input[str]]:
        """
        Emulation type for the physical network interface card (NIC).
        """
        return pulumi.get(self, "network_type")

    @network_type.setter
    def network_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_type", value)

    @property
    @pulumi.getter(name="remoteDataVolumeType")
    def remote_data_volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        Emulation type for volume.
        """
        return pulumi.get(self, "remote_data_volume_type")

    @remote_data_volume_type.setter
    def remote_data_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_data_volume_type", value)


@pulumi.input_type
class InstanceAgentConfigArgs:
    def __init__(__self__, *,
                 are_all_plugins_disabled: Optional[pulumi.Input[bool]] = None,
                 is_management_disabled: Optional[pulumi.Input[bool]] = None,
                 is_monitoring_disabled: Optional[pulumi.Input[bool]] = None,
                 plugins_configs: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceAgentConfigPluginsConfigArgs']]]] = None):
        """
        :param pulumi.Input[bool] are_all_plugins_disabled: (Updatable) Whether Oracle Cloud Agent can run all the available plugins. This includes the management and monitoring plugins.
               
               To get a list of available plugins, use the [ListInstanceagentAvailablePlugins](https://docs.cloud.oracle.com/iaas/api/#/en/instanceagent/20180530/Plugin/ListInstanceagentAvailablePlugins) operation in the Oracle Cloud Agent API. For more information about the available plugins, see [Managing Plugins with Oracle Cloud Agent](https://docs.cloud.oracle.com/iaas/Content/Compute/Tasks/manage-plugins.htm).
        :param pulumi.Input[bool] is_management_disabled: (Updatable) Whether Oracle Cloud Agent can run all the available management plugins. Default value is false (management plugins are enabled).
               
               These are the management plugins: OS Management Service Agent and Compute Instance Run Command.
               
               The management plugins are controlled by this parameter and by the per-plugin configuration in the `pluginsConfig` object.
               * If `isManagementDisabled` is true, all of the management plugins are disabled, regardless of the per-plugin configuration.
               * If `isManagementDisabled` is false, all of the management plugins are enabled. You can optionally disable individual management plugins by providing a value in the `pluginsConfig` object.
        :param pulumi.Input[bool] is_monitoring_disabled: (Updatable) Whether Oracle Cloud Agent can gather performance metrics and monitor the instance using the monitoring plugins. Default value is false (monitoring plugins are enabled).
               
               These are the monitoring plugins: Compute Instance Monitoring and Custom Logs Monitoring.
               
               The monitoring plugins are controlled by this parameter and by the per-plugin configuration in the `pluginsConfig` object.
               * If `isMonitoringDisabled` is true, all of the monitoring plugins are disabled, regardless of the per-plugin configuration.
               * If `isMonitoringDisabled` is false, all of the monitoring plugins are enabled. You can optionally disable individual monitoring plugins by providing a value in the `pluginsConfig` object.
        :param pulumi.Input[Sequence[pulumi.Input['InstanceAgentConfigPluginsConfigArgs']]] plugins_configs: (Updatable) The configuration of plugins associated with this instance.
        """
        InstanceAgentConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            are_all_plugins_disabled=are_all_plugins_disabled,
            is_management_disabled=is_management_disabled,
            is_monitoring_disabled=is_monitoring_disabled,
            plugins_configs=plugins_configs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             are_all_plugins_disabled: Optional[pulumi.Input[bool]] = None,
             is_management_disabled: Optional[pulumi.Input[bool]] = None,
             is_monitoring_disabled: Optional[pulumi.Input[bool]] = None,
             plugins_configs: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceAgentConfigPluginsConfigArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if are_all_plugins_disabled is not None:
            _setter("are_all_plugins_disabled", are_all_plugins_disabled)
        if is_management_disabled is not None:
            _setter("is_management_disabled", is_management_disabled)
        if is_monitoring_disabled is not None:
            _setter("is_monitoring_disabled", is_monitoring_disabled)
        if plugins_configs is not None:
            _setter("plugins_configs", plugins_configs)

    @property
    @pulumi.getter(name="areAllPluginsDisabled")
    def are_all_plugins_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether Oracle Cloud Agent can run all the available plugins. This includes the management and monitoring plugins.

        To get a list of available plugins, use the [ListInstanceagentAvailablePlugins](https://docs.cloud.oracle.com/iaas/api/#/en/instanceagent/20180530/Plugin/ListInstanceagentAvailablePlugins) operation in the Oracle Cloud Agent API. For more information about the available plugins, see [Managing Plugins with Oracle Cloud Agent](https://docs.cloud.oracle.com/iaas/Content/Compute/Tasks/manage-plugins.htm).
        """
        return pulumi.get(self, "are_all_plugins_disabled")

    @are_all_plugins_disabled.setter
    def are_all_plugins_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "are_all_plugins_disabled", value)

    @property
    @pulumi.getter(name="isManagementDisabled")
    def is_management_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether Oracle Cloud Agent can run all the available management plugins. Default value is false (management plugins are enabled).

        These are the management plugins: OS Management Service Agent and Compute Instance Run Command.

        The management plugins are controlled by this parameter and by the per-plugin configuration in the `pluginsConfig` object.
        * If `isManagementDisabled` is true, all of the management plugins are disabled, regardless of the per-plugin configuration.
        * If `isManagementDisabled` is false, all of the management plugins are enabled. You can optionally disable individual management plugins by providing a value in the `pluginsConfig` object.
        """
        return pulumi.get(self, "is_management_disabled")

    @is_management_disabled.setter
    def is_management_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_management_disabled", value)

    @property
    @pulumi.getter(name="isMonitoringDisabled")
    def is_monitoring_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether Oracle Cloud Agent can gather performance metrics and monitor the instance using the monitoring plugins. Default value is false (monitoring plugins are enabled).

        These are the monitoring plugins: Compute Instance Monitoring and Custom Logs Monitoring.

        The monitoring plugins are controlled by this parameter and by the per-plugin configuration in the `pluginsConfig` object.
        * If `isMonitoringDisabled` is true, all of the monitoring plugins are disabled, regardless of the per-plugin configuration.
        * If `isMonitoringDisabled` is false, all of the monitoring plugins are enabled. You can optionally disable individual monitoring plugins by providing a value in the `pluginsConfig` object.
        """
        return pulumi.get(self, "is_monitoring_disabled")

    @is_monitoring_disabled.setter
    def is_monitoring_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monitoring_disabled", value)

    @property
    @pulumi.getter(name="pluginsConfigs")
    def plugins_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceAgentConfigPluginsConfigArgs']]]]:
        """
        (Updatable) The configuration of plugins associated with this instance.
        """
        return pulumi.get(self, "plugins_configs")

    @plugins_configs.setter
    def plugins_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceAgentConfigPluginsConfigArgs']]]]):
        pulumi.set(self, "plugins_configs", value)


@pulumi.input_type
class InstanceAgentConfigPluginsConfigArgs:
    def __init__(__self__, *,
                 desired_state: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] desired_state: (Updatable) Whether the plugin should be enabled or disabled.
               
               To enable the monitoring and management plugins, the `isMonitoringDisabled` and `isManagementDisabled` attributes must also be set to false.
        :param pulumi.Input[str] name: (Updatable) The plugin name. To get a list of available plugins, use the [ListInstanceagentAvailablePlugins](https://docs.cloud.oracle.com/iaas/api/#/en/instanceagent/20180530/Plugin/ListInstanceagentAvailablePlugins) operation in the Oracle Cloud Agent API. For more information about the available plugins, see [Managing Plugins with Oracle Cloud Agent](https://docs.cloud.oracle.com/iaas/Content/Compute/Tasks/manage-plugins.htm).
        """
        InstanceAgentConfigPluginsConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            desired_state=desired_state,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             desired_state: pulumi.Input[str],
             name: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("desired_state", desired_state)
        _setter("name", name)

    @property
    @pulumi.getter(name="desiredState")
    def desired_state(self) -> pulumi.Input[str]:
        """
        (Updatable) Whether the plugin should be enabled or disabled.

        To enable the monitoring and management plugins, the `isMonitoringDisabled` and `isManagementDisabled` attributes must also be set to false.
        """
        return pulumi.get(self, "desired_state")

    @desired_state.setter
    def desired_state(self, value: pulumi.Input[str]):
        pulumi.set(self, "desired_state", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) The plugin name. To get a list of available plugins, use the [ListInstanceagentAvailablePlugins](https://docs.cloud.oracle.com/iaas/api/#/en/instanceagent/20180530/Plugin/ListInstanceagentAvailablePlugins) operation in the Oracle Cloud Agent API. For more information about the available plugins, see [Managing Plugins with Oracle Cloud Agent](https://docs.cloud.oracle.com/iaas/Content/Compute/Tasks/manage-plugins.htm).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class InstanceAvailabilityConfigArgs:
    def __init__(__self__, *,
                 is_live_migration_preferred: Optional[pulumi.Input[bool]] = None,
                 recovery_action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_live_migration_preferred: (Updatable) Whether to live migrate supported VM instances to a healthy physical VM host without disrupting running instances during infrastructure maintenance events. If null, Oracle chooses the best option for migrating the VM during infrastructure maintenance events.
        :param pulumi.Input[str] recovery_action: (Updatable) The lifecycle state for an instance when it is recovered after infrastructure maintenance.
        """
        InstanceAvailabilityConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_live_migration_preferred=is_live_migration_preferred,
            recovery_action=recovery_action,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_live_migration_preferred: Optional[pulumi.Input[bool]] = None,
             recovery_action: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_live_migration_preferred is not None:
            _setter("is_live_migration_preferred", is_live_migration_preferred)
        if recovery_action is not None:
            _setter("recovery_action", recovery_action)

    @property
    @pulumi.getter(name="isLiveMigrationPreferred")
    def is_live_migration_preferred(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether to live migrate supported VM instances to a healthy physical VM host without disrupting running instances during infrastructure maintenance events. If null, Oracle chooses the best option for migrating the VM during infrastructure maintenance events.
        """
        return pulumi.get(self, "is_live_migration_preferred")

    @is_live_migration_preferred.setter
    def is_live_migration_preferred(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_live_migration_preferred", value)

    @property
    @pulumi.getter(name="recoveryAction")
    def recovery_action(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The lifecycle state for an instance when it is recovered after infrastructure maintenance.
        """
        return pulumi.get(self, "recovery_action")

    @recovery_action.setter
    def recovery_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recovery_action", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsArgs:
    def __init__(__self__, *,
                 instance_type: pulumi.Input[str],
                 block_volumes: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsBlockVolumeArgs']]]] = None,
                 launch_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsArgs']] = None,
                 options: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionArgs']]]] = None,
                 secondary_vnics: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsSecondaryVnicArgs']]]] = None):
        """
        :param pulumi.Input[str] instance_type: The type of instance details. Supported instanceType is compute
        :param pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsBlockVolumeArgs']]] block_volumes: Block volume parameters.
        :param pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsArgs'] launch_details: Instance launch details for creating an instance from an instance configuration. Use the `sourceDetails` parameter to specify whether a boot volume or an image should be used to launch a new instance.
               
               See [LaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/LaunchInstanceDetails) for more information.
        :param pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionArgs']]] options: Multiple Compute Instance Configuration instance details.
        :param pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsSecondaryVnicArgs']]] secondary_vnics: Secondary VNIC parameters.
        """
        InstanceConfigurationInstanceDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_type=instance_type,
            block_volumes=block_volumes,
            launch_details=launch_details,
            options=options,
            secondary_vnics=secondary_vnics,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_type: pulumi.Input[str],
             block_volumes: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsBlockVolumeArgs']]]] = None,
             launch_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsArgs']] = None,
             options: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionArgs']]]] = None,
             secondary_vnics: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsSecondaryVnicArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("instance_type", instance_type)
        if block_volumes is not None:
            _setter("block_volumes", block_volumes)
        if launch_details is not None:
            _setter("launch_details", launch_details)
        if options is not None:
            _setter("options", options)
        if secondary_vnics is not None:
            _setter("secondary_vnics", secondary_vnics)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> pulumi.Input[str]:
        """
        The type of instance details. Supported instanceType is compute
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_type", value)

    @property
    @pulumi.getter(name="blockVolumes")
    def block_volumes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsBlockVolumeArgs']]]]:
        """
        Block volume parameters.
        """
        return pulumi.get(self, "block_volumes")

    @block_volumes.setter
    def block_volumes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsBlockVolumeArgs']]]]):
        pulumi.set(self, "block_volumes", value)

    @property
    @pulumi.getter(name="launchDetails")
    def launch_details(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsArgs']]:
        """
        Instance launch details for creating an instance from an instance configuration. Use the `sourceDetails` parameter to specify whether a boot volume or an image should be used to launch a new instance.

        See [LaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/LaunchInstanceDetails) for more information.
        """
        return pulumi.get(self, "launch_details")

    @launch_details.setter
    def launch_details(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsArgs']]):
        pulumi.set(self, "launch_details", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionArgs']]]]:
        """
        Multiple Compute Instance Configuration instance details.
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionArgs']]]]):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter(name="secondaryVnics")
    def secondary_vnics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsSecondaryVnicArgs']]]]:
        """
        Secondary VNIC parameters.
        """
        return pulumi.get(self, "secondary_vnics")

    @secondary_vnics.setter
    def secondary_vnics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsSecondaryVnicArgs']]]]):
        pulumi.set(self, "secondary_vnics", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsBlockVolumeArgs:
    def __init__(__self__, *,
                 attach_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsBlockVolumeAttachDetailsArgs']] = None,
                 create_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsArgs']] = None,
                 volume_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['InstanceConfigurationInstanceDetailsBlockVolumeAttachDetailsArgs'] attach_details: Volume attachmentDetails. Please see [AttachVolumeDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/AttachVolumeDetails/)
        :param pulumi.Input['InstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsArgs'] create_details: Creates a new block volume. Please see [CreateVolumeDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVolumeDetails/)
        :param pulumi.Input[str] volume_id: The OCID of the volume.
        """
        InstanceConfigurationInstanceDetailsBlockVolumeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attach_details=attach_details,
            create_details=create_details,
            volume_id=volume_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attach_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsBlockVolumeAttachDetailsArgs']] = None,
             create_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsArgs']] = None,
             volume_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if attach_details is not None:
            _setter("attach_details", attach_details)
        if create_details is not None:
            _setter("create_details", create_details)
        if volume_id is not None:
            _setter("volume_id", volume_id)

    @property
    @pulumi.getter(name="attachDetails")
    def attach_details(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsBlockVolumeAttachDetailsArgs']]:
        """
        Volume attachmentDetails. Please see [AttachVolumeDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/AttachVolumeDetails/)
        """
        return pulumi.get(self, "attach_details")

    @attach_details.setter
    def attach_details(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsBlockVolumeAttachDetailsArgs']]):
        pulumi.set(self, "attach_details", value)

    @property
    @pulumi.getter(name="createDetails")
    def create_details(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsArgs']]:
        """
        Creates a new block volume. Please see [CreateVolumeDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVolumeDetails/)
        """
        return pulumi.get(self, "create_details")

    @create_details.setter
    def create_details(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsArgs']]):
        pulumi.set(self, "create_details", value)

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the volume.
        """
        return pulumi.get(self, "volume_id")

    @volume_id.setter
    def volume_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_id", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsBlockVolumeAttachDetailsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 device: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 is_pv_encryption_in_transit_enabled: Optional[pulumi.Input[bool]] = None,
                 is_read_only: Optional[pulumi.Input[bool]] = None,
                 is_shareable: Optional[pulumi.Input[bool]] = None,
                 use_chap: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] type: The type of action to run when the instance is interrupted for eviction.
        :param pulumi.Input[str] device: The device name.
        :param pulumi.Input[str] display_name: A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        :param pulumi.Input[bool] is_pv_encryption_in_transit_enabled: Deprecated. Instead use `isPvEncryptionInTransitEnabled` in [InstanceConfigurationLaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/datatypes/InstanceConfigurationLaunchInstanceDetails).
        :param pulumi.Input[bool] is_read_only: Whether the attachment should be created in read-only mode.
        :param pulumi.Input[bool] is_shareable: Whether the attachment should be created in shareable mode. If an attachment is created in shareable mode, then other instances can attach the same volume, provided that they also create their attachments in shareable mode. Only certain volume types can be attached in shareable mode. Defaults to false if not specified.
        :param pulumi.Input[bool] use_chap: Whether to use CHAP authentication for the volume attachment. Defaults to false.
        """
        InstanceConfigurationInstanceDetailsBlockVolumeAttachDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            device=device,
            display_name=display_name,
            is_pv_encryption_in_transit_enabled=is_pv_encryption_in_transit_enabled,
            is_read_only=is_read_only,
            is_shareable=is_shareable,
            use_chap=use_chap,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[str],
             device: Optional[pulumi.Input[str]] = None,
             display_name: Optional[pulumi.Input[str]] = None,
             is_pv_encryption_in_transit_enabled: Optional[pulumi.Input[bool]] = None,
             is_read_only: Optional[pulumi.Input[bool]] = None,
             is_shareable: Optional[pulumi.Input[bool]] = None,
             use_chap: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if device is not None:
            _setter("device", device)
        if display_name is not None:
            _setter("display_name", display_name)
        if is_pv_encryption_in_transit_enabled is not None:
            _setter("is_pv_encryption_in_transit_enabled", is_pv_encryption_in_transit_enabled)
        if is_read_only is not None:
            _setter("is_read_only", is_read_only)
        if is_shareable is not None:
            _setter("is_shareable", is_shareable)
        if use_chap is not None:
            _setter("use_chap", use_chap)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of action to run when the instance is interrupted for eviction.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def device(self) -> Optional[pulumi.Input[str]]:
        """
        The device name.
        """
        return pulumi.get(self, "device")

    @device.setter
    def device(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="isPvEncryptionInTransitEnabled")
    def is_pv_encryption_in_transit_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Deprecated. Instead use `isPvEncryptionInTransitEnabled` in [InstanceConfigurationLaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/datatypes/InstanceConfigurationLaunchInstanceDetails).
        """
        return pulumi.get(self, "is_pv_encryption_in_transit_enabled")

    @is_pv_encryption_in_transit_enabled.setter
    def is_pv_encryption_in_transit_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_pv_encryption_in_transit_enabled", value)

    @property
    @pulumi.getter(name="isReadOnly")
    def is_read_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the attachment should be created in read-only mode.
        """
        return pulumi.get(self, "is_read_only")

    @is_read_only.setter
    def is_read_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_read_only", value)

    @property
    @pulumi.getter(name="isShareable")
    def is_shareable(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the attachment should be created in shareable mode. If an attachment is created in shareable mode, then other instances can attach the same volume, provided that they also create their attachments in shareable mode. Only certain volume types can be attached in shareable mode. Defaults to false if not specified.
        """
        return pulumi.get(self, "is_shareable")

    @is_shareable.setter
    def is_shareable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_shareable", value)

    @property
    @pulumi.getter(name="useChap")
    def use_chap(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to use CHAP authentication for the volume attachment. Defaults to false.
        """
        return pulumi.get(self, "use_chap")

    @use_chap.setter
    def use_chap(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_chap", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsArgs:
    def __init__(__self__, *,
                 autotune_policies: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsAutotunePolicyArgs']]]] = None,
                 availability_domain: Optional[pulumi.Input[str]] = None,
                 backup_policy_id: Optional[pulumi.Input[str]] = None,
                 block_volume_replicas: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsBlockVolumeReplicasArgs']] = None,
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 is_auto_tune_enabled: Optional[pulumi.Input[bool]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 size_in_gbs: Optional[pulumi.Input[str]] = None,
                 source_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsSourceDetailsArgs']] = None,
                 vpus_per_gb: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsAutotunePolicyArgs']]] autotune_policies: The list of autotune policies enabled for this volume.
        :param pulumi.Input[str] availability_domain: The availability domain of the instance.  Example: `Uocm:PHX-AD-1`
        :param pulumi.Input[str] backup_policy_id: If provided, specifies the ID of the volume backup policy to assign to the newly created volume. If omitted, no policy will be assigned.
        :param pulumi.Input['InstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsBlockVolumeReplicasArgs'] block_volume_replicas: The list of block volume replicas to be enabled for this volume in the specified destination availability domains.
        :param pulumi.Input[str] compartment_id: (Updatable) The OCID of the compartment containing images to search
        :param pulumi.Input[Mapping[str, Any]] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        :param pulumi.Input[str] display_name: A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        :param pulumi.Input[Mapping[str, Any]] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param pulumi.Input[bool] is_auto_tune_enabled: Specifies whether the auto-tune performance is enabled for this boot volume. This field is deprecated. Use the `InstanceConfigurationDetachedVolumeAutotunePolicy` instead to enable the volume for detached autotune.
        :param pulumi.Input[str] kms_key_id: The OCID of the Vault service key to assign as the master encryption key for the volume.
        :param pulumi.Input[str] size_in_gbs: The size of the volume in GBs.
        :param pulumi.Input[str] vpus_per_gb: The number of volume performance units (VPUs) that will be applied to this volume per GB, representing the Block Volume service's elastic performance options. See [Block Volume Performance Levels](https://docs.cloud.oracle.com/iaas/Content/Block/Concepts/blockvolumeperformance.htm#perf_levels) for more information.
               
               Allowed values:
        """
        InstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autotune_policies=autotune_policies,
            availability_domain=availability_domain,
            backup_policy_id=backup_policy_id,
            block_volume_replicas=block_volume_replicas,
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            display_name=display_name,
            freeform_tags=freeform_tags,
            is_auto_tune_enabled=is_auto_tune_enabled,
            kms_key_id=kms_key_id,
            size_in_gbs=size_in_gbs,
            source_details=source_details,
            vpus_per_gb=vpus_per_gb,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autotune_policies: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsAutotunePolicyArgs']]]] = None,
             availability_domain: Optional[pulumi.Input[str]] = None,
             backup_policy_id: Optional[pulumi.Input[str]] = None,
             block_volume_replicas: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsBlockVolumeReplicasArgs']] = None,
             compartment_id: Optional[pulumi.Input[str]] = None,
             defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             display_name: Optional[pulumi.Input[str]] = None,
             freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             is_auto_tune_enabled: Optional[pulumi.Input[bool]] = None,
             kms_key_id: Optional[pulumi.Input[str]] = None,
             size_in_gbs: Optional[pulumi.Input[str]] = None,
             source_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsSourceDetailsArgs']] = None,
             vpus_per_gb: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if autotune_policies is not None:
            _setter("autotune_policies", autotune_policies)
        if availability_domain is not None:
            _setter("availability_domain", availability_domain)
        if backup_policy_id is not None:
            _setter("backup_policy_id", backup_policy_id)
        if block_volume_replicas is not None:
            _setter("block_volume_replicas", block_volume_replicas)
        if compartment_id is not None:
            _setter("compartment_id", compartment_id)
        if defined_tags is not None:
            _setter("defined_tags", defined_tags)
        if display_name is not None:
            _setter("display_name", display_name)
        if freeform_tags is not None:
            _setter("freeform_tags", freeform_tags)
        if is_auto_tune_enabled is not None:
            _setter("is_auto_tune_enabled", is_auto_tune_enabled)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)
        if size_in_gbs is not None:
            _setter("size_in_gbs", size_in_gbs)
        if source_details is not None:
            _setter("source_details", source_details)
        if vpus_per_gb is not None:
            _setter("vpus_per_gb", vpus_per_gb)

    @property
    @pulumi.getter(name="autotunePolicies")
    def autotune_policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsAutotunePolicyArgs']]]]:
        """
        The list of autotune policies enabled for this volume.
        """
        return pulumi.get(self, "autotune_policies")

    @autotune_policies.setter
    def autotune_policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsAutotunePolicyArgs']]]]):
        pulumi.set(self, "autotune_policies", value)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[pulumi.Input[str]]:
        """
        The availability domain of the instance.  Example: `Uocm:PHX-AD-1`
        """
        return pulumi.get(self, "availability_domain")

    @availability_domain.setter
    def availability_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_domain", value)

    @property
    @pulumi.getter(name="backupPolicyId")
    def backup_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        If provided, specifies the ID of the volume backup policy to assign to the newly created volume. If omitted, no policy will be assigned.
        """
        return pulumi.get(self, "backup_policy_id")

    @backup_policy_id.setter
    def backup_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_policy_id", value)

    @property
    @pulumi.getter(name="blockVolumeReplicas")
    def block_volume_replicas(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsBlockVolumeReplicasArgs']]:
        """
        The list of block volume replicas to be enabled for this volume in the specified destination availability domains.
        """
        return pulumi.get(self, "block_volume_replicas")

    @block_volume_replicas.setter
    def block_volume_replicas(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsBlockVolumeReplicasArgs']]):
        pulumi.set(self, "block_volume_replicas", value)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the compartment containing images to search
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter(name="isAutoTuneEnabled")
    def is_auto_tune_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the auto-tune performance is enabled for this boot volume. This field is deprecated. Use the `InstanceConfigurationDetachedVolumeAutotunePolicy` instead to enable the volume for detached autotune.
        """
        return pulumi.get(self, "is_auto_tune_enabled")

    @is_auto_tune_enabled.setter
    def is_auto_tune_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_auto_tune_enabled", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the Vault service key to assign as the master encryption key for the volume.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="sizeInGbs")
    def size_in_gbs(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the volume in GBs.
        """
        return pulumi.get(self, "size_in_gbs")

    @size_in_gbs.setter
    def size_in_gbs(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size_in_gbs", value)

    @property
    @pulumi.getter(name="sourceDetails")
    def source_details(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsSourceDetailsArgs']]:
        return pulumi.get(self, "source_details")

    @source_details.setter
    def source_details(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsSourceDetailsArgs']]):
        pulumi.set(self, "source_details", value)

    @property
    @pulumi.getter(name="vpusPerGb")
    def vpus_per_gb(self) -> Optional[pulumi.Input[str]]:
        """
        The number of volume performance units (VPUs) that will be applied to this volume per GB, representing the Block Volume service's elastic performance options. See [Block Volume Performance Levels](https://docs.cloud.oracle.com/iaas/Content/Block/Concepts/blockvolumeperformance.htm#perf_levels) for more information.

        Allowed values:
        """
        return pulumi.get(self, "vpus_per_gb")

    @vpus_per_gb.setter
    def vpus_per_gb(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpus_per_gb", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsAutotunePolicyArgs:
    def __init__(__self__, *,
                 autotune_type: pulumi.Input[str],
                 max_vpus_per_gb: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] autotune_type: This specifies the type of autotunes supported by OCI.
        :param pulumi.Input[str] max_vpus_per_gb: This will be the maximum VPUs/GB performance level that the volume will be auto-tuned temporarily based on performance monitoring.
        """
        InstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsAutotunePolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autotune_type=autotune_type,
            max_vpus_per_gb=max_vpus_per_gb,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autotune_type: pulumi.Input[str],
             max_vpus_per_gb: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("autotune_type", autotune_type)
        if max_vpus_per_gb is not None:
            _setter("max_vpus_per_gb", max_vpus_per_gb)

    @property
    @pulumi.getter(name="autotuneType")
    def autotune_type(self) -> pulumi.Input[str]:
        """
        This specifies the type of autotunes supported by OCI.
        """
        return pulumi.get(self, "autotune_type")

    @autotune_type.setter
    def autotune_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "autotune_type", value)

    @property
    @pulumi.getter(name="maxVpusPerGb")
    def max_vpus_per_gb(self) -> Optional[pulumi.Input[str]]:
        """
        This will be the maximum VPUs/GB performance level that the volume will be auto-tuned temporarily based on performance monitoring.
        """
        return pulumi.get(self, "max_vpus_per_gb")

    @max_vpus_per_gb.setter
    def max_vpus_per_gb(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_vpus_per_gb", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsBlockVolumeReplicasArgs:
    def __init__(__self__, *,
                 availability_domain: pulumi.Input[str],
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] availability_domain: The availability domain of the instance.  Example: `Uocm:PHX-AD-1`
        :param pulumi.Input[str] display_name: A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        """
        InstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsBlockVolumeReplicasArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_domain=availability_domain,
            display_name=display_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_domain: pulumi.Input[str],
             display_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("availability_domain", availability_domain)
        if display_name is not None:
            _setter("display_name", display_name)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> pulumi.Input[str]:
        """
        The availability domain of the instance.  Example: `Uocm:PHX-AD-1`
        """
        return pulumi.get(self, "availability_domain")

    @availability_domain.setter
    def availability_domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "availability_domain", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsSourceDetailsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of action to run when the instance is interrupted for eviction.
        :param pulumi.Input[str] id: The OCID of the volume backup.
        """
        InstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsSourceDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[str],
             id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of action to run when the instance is interrupted for eviction.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the volume backup.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsLaunchDetailsArgs:
    def __init__(__self__, *,
                 agent_config: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsAgentConfigArgs']] = None,
                 availability_config: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsAvailabilityConfigArgs']] = None,
                 availability_domain: Optional[pulumi.Input[str]] = None,
                 capacity_reservation_id: Optional[pulumi.Input[str]] = None,
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 create_vnic_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsCreateVnicDetailsArgs']] = None,
                 dedicated_vm_host_id: Optional[pulumi.Input[str]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 extended_metadata: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 fault_domain: Optional[pulumi.Input[str]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 instance_options: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsInstanceOptionsArgs']] = None,
                 ipxe_script: Optional[pulumi.Input[str]] = None,
                 is_pv_encryption_in_transit_enabled: Optional[pulumi.Input[bool]] = None,
                 launch_mode: Optional[pulumi.Input[str]] = None,
                 launch_options: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsLaunchOptionsArgs']] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 platform_config: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsPlatformConfigArgs']] = None,
                 preemptible_instance_config: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsPreemptibleInstanceConfigArgs']] = None,
                 preferred_maintenance_action: Optional[pulumi.Input[str]] = None,
                 shape: Optional[pulumi.Input[str]] = None,
                 shape_config: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsShapeConfigArgs']] = None,
                 source_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsSourceDetailsArgs']] = None):
        """
        :param pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsAgentConfigArgs'] agent_config: Configuration options for the Oracle Cloud Agent software running on the instance.
        :param pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsAvailabilityConfigArgs'] availability_config: Options for defining the availabiity of a VM instance after a maintenance event that impacts the underlying hardware.
        :param pulumi.Input[str] availability_domain: The availability domain of the instance.  Example: `Uocm:PHX-AD-1`
        :param pulumi.Input[str] capacity_reservation_id: The OCID of the compute capacity reservation this instance is launched under.
        :param pulumi.Input[str] compartment_id: (Updatable) The OCID of the compartment containing images to search
        :param pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsCreateVnicDetailsArgs'] create_vnic_details: Contains the properties of the VNIC for an instance configuration. See [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) and [Instance Configurations](https://docs.cloud.oracle.com/iaas/Content/Compute/Concepts/instancemanagement.htm#config) for more information.
        :param pulumi.Input[str] dedicated_vm_host_id: The OCID of the dedicated virtual machine host to place the instance on.
               
               Dedicated VM hosts can be used when launching individual instances from an instance configuration. They cannot be used to launch instance pools.
        :param pulumi.Input[Mapping[str, Any]] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        :param pulumi.Input[str] display_name: A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        :param pulumi.Input[Mapping[str, Any]] extended_metadata: Additional metadata key/value pairs that you provide. They serve the same purpose and functionality as fields in the `metadata` object.
               
               They are distinguished from `metadata` fields in that these can be nested JSON objects (whereas `metadata` fields are string/string maps only).
               
               The combined size of the `metadata` and `extendedMetadata` objects can be a maximum of 32,000 bytes.
        :param pulumi.Input[str] fault_domain: A fault domain is a grouping of hardware and infrastructure within an availability domain. Each availability domain contains three fault domains. Fault domains let you distribute your instances so that they are not on the same physical hardware within a single availability domain. A hardware failure or Compute hardware maintenance that affects one fault domain does not affect instances in other fault domains.
               
               If you do not specify the fault domain, the system selects one for you.
               
               To get a list of fault domains, use the [ListFaultDomains](https://docs.cloud.oracle.com/iaas/api/#/en/identity/20160918/FaultDomain/ListFaultDomains) operation in the Identity and Access Management Service API.
               
               Example: `FAULT-DOMAIN-1`
        :param pulumi.Input[Mapping[str, Any]] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsInstanceOptionsArgs'] instance_options: Optional mutable instance options. As a part of Instance Metadata Service Security Header, This allows user to disable the legacy imds endpoints.
        :param pulumi.Input[str] ipxe_script: This is an advanced option.
               
               When a bare metal or virtual machine instance boots, the iPXE firmware that runs on the instance is configured to run an iPXE script to continue the boot process.
               
               If you want more control over the boot process, you can provide your own custom iPXE script that will run when the instance boots; however, you should be aware that the same iPXE script will run every time an instance boots; not only after the initial LaunchInstance call.
               
               The default iPXE script connects to the instance's local boot volume over iSCSI and performs a network boot. If you use a custom iPXE script and want to network-boot from the instance's local boot volume over iSCSI the same way as the default iPXE script, you should use the following iSCSI IP address: 169.254.0.2, and boot volume IQN: iqn.2015-02.oracle.boot.
               
               For more information about the Bring Your Own Image feature of Oracle Cloud Infrastructure, see [Bring Your Own Image](https://docs.cloud.oracle.com/iaas/Content/Compute/References/bringyourownimage.htm).
               
               For more information about iPXE, see http://ipxe.org.
        :param pulumi.Input[bool] is_pv_encryption_in_transit_enabled: Deprecated. Instead use `isPvEncryptionInTransitEnabled` in [InstanceConfigurationLaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/datatypes/InstanceConfigurationLaunchInstanceDetails).
        :param pulumi.Input[str] launch_mode: Specifies the configuration mode for launching virtual machine (VM) instances. The configuration modes are:
        :param pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsLaunchOptionsArgs'] launch_options: Options for tuning the compatibility and performance of VM shapes. The values that you specify override any default values.
        :param pulumi.Input[Mapping[str, Any]] metadata: Custom metadata key/value pairs that you provide, such as the SSH public key required to connect to the instance.
               
               A metadata service runs on every launched instance. The service is an HTTP endpoint listening on 169.254.169.254. You can use the service to:
               * Provide information to [Cloud-Init](https://cloudinit.readthedocs.org/en/latest/) to be used for various system initialization tasks.
               * Get information about the instance, including the custom metadata that you provide when you launch the instance.
               
               **Providing Cloud-Init Metadata**
               
               You can use the following metadata key names to provide information to Cloud-Init:
               
               **"ssh_authorized_keys"** - Provide one or more public SSH keys to be included in the `~/.ssh/authorized_keys` file for the default user on the instance. Use a newline character to separate multiple keys. The SSH keys must be in the format necessary for the `authorized_keys` file, as shown in the example below.
               
               **"user_data"** - Provide your own base64-encoded data to be used by Cloud-Init to run custom scripts or provide custom Cloud-Init configuration. For information about how to take advantage of user data, see the [Cloud-Init Documentation](http://cloudinit.readthedocs.org/en/latest/topics/format.html).
               
               **Metadata Example**
               
               "metadata" : { "quake_bot_level" : "Severe", "ssh_authorized_keys" : "ssh-rsa <your_public_SSH_key>== rsa-key-20160227", "user_data" : "<your_public_SSH_key>==" } **Getting Metadata on the Instance**
               
               To get information about your instance, connect to the instance using SSH and issue any of the following GET requests:
               
               curl -H "Authorization: Bearer Oracle" http://169.254.169.254/opc/v2/instance/ curl -H "Authorization: Bearer Oracle" http://169.254.169.254/opc/v2/instance/metadata/ curl -H "Authorization: Bearer Oracle" http://169.254.169.254/opc/v2/instance/metadata/<any-key-name>
               
               You'll get back a response that includes all the instance information; only the metadata information; or the metadata information for the specified key name, respectively.
               
               The combined size of the `metadata` and `extendedMetadata` objects can be a maximum of 32,000 bytes.
        :param pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsPlatformConfigArgs'] platform_config: The platform configuration requested for the instance.
               
               If you provide the parameter, the instance is created with the platform configuration that you specify. For any values that you omit, the instance uses the default configuration values for the `shape` that you specify. If you don't provide the parameter, the default values for the `shape` are used.
               
               Each shape only supports certain configurable values. If the values that you provide are not valid for the specified `shape`, an error is returned.
        :param pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsPreemptibleInstanceConfigArgs'] preemptible_instance_config: Configuration options for preemptible instances.
        :param pulumi.Input[str] preferred_maintenance_action: The preferred maintenance action for an instance. The default is LIVE_MIGRATE, if live migration is supported.
        :param pulumi.Input[str] shape: The shape of an instance. The shape determines the number of CPUs, amount of memory, and other resources allocated to the instance.
               
               You can enumerate all available shapes by calling [ListShapes](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Shape/ListShapes).
        :param pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsShapeConfigArgs'] shape_config: The shape configuration requested for the instance.
               
               If the parameter is provided, the instance is created with the resources that you specify. If some properties are missing or the entire parameter is not provided, the instance is created with the default configuration values for the `shape` that you specify.
               
               Each shape only supports certain configurable values. If the values that you provide are not valid for the specified `shape`, an error is returned.
        """
        InstanceConfigurationInstanceDetailsLaunchDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            agent_config=agent_config,
            availability_config=availability_config,
            availability_domain=availability_domain,
            capacity_reservation_id=capacity_reservation_id,
            compartment_id=compartment_id,
            create_vnic_details=create_vnic_details,
            dedicated_vm_host_id=dedicated_vm_host_id,
            defined_tags=defined_tags,
            display_name=display_name,
            extended_metadata=extended_metadata,
            fault_domain=fault_domain,
            freeform_tags=freeform_tags,
            instance_options=instance_options,
            ipxe_script=ipxe_script,
            is_pv_encryption_in_transit_enabled=is_pv_encryption_in_transit_enabled,
            launch_mode=launch_mode,
            launch_options=launch_options,
            metadata=metadata,
            platform_config=platform_config,
            preemptible_instance_config=preemptible_instance_config,
            preferred_maintenance_action=preferred_maintenance_action,
            shape=shape,
            shape_config=shape_config,
            source_details=source_details,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             agent_config: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsAgentConfigArgs']] = None,
             availability_config: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsAvailabilityConfigArgs']] = None,
             availability_domain: Optional[pulumi.Input[str]] = None,
             capacity_reservation_id: Optional[pulumi.Input[str]] = None,
             compartment_id: Optional[pulumi.Input[str]] = None,
             create_vnic_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsCreateVnicDetailsArgs']] = None,
             dedicated_vm_host_id: Optional[pulumi.Input[str]] = None,
             defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             display_name: Optional[pulumi.Input[str]] = None,
             extended_metadata: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             fault_domain: Optional[pulumi.Input[str]] = None,
             freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             instance_options: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsInstanceOptionsArgs']] = None,
             ipxe_script: Optional[pulumi.Input[str]] = None,
             is_pv_encryption_in_transit_enabled: Optional[pulumi.Input[bool]] = None,
             launch_mode: Optional[pulumi.Input[str]] = None,
             launch_options: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsLaunchOptionsArgs']] = None,
             metadata: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             platform_config: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsPlatformConfigArgs']] = None,
             preemptible_instance_config: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsPreemptibleInstanceConfigArgs']] = None,
             preferred_maintenance_action: Optional[pulumi.Input[str]] = None,
             shape: Optional[pulumi.Input[str]] = None,
             shape_config: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsShapeConfigArgs']] = None,
             source_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsSourceDetailsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if agent_config is not None:
            _setter("agent_config", agent_config)
        if availability_config is not None:
            _setter("availability_config", availability_config)
        if availability_domain is not None:
            _setter("availability_domain", availability_domain)
        if capacity_reservation_id is not None:
            _setter("capacity_reservation_id", capacity_reservation_id)
        if compartment_id is not None:
            _setter("compartment_id", compartment_id)
        if create_vnic_details is not None:
            _setter("create_vnic_details", create_vnic_details)
        if dedicated_vm_host_id is not None:
            _setter("dedicated_vm_host_id", dedicated_vm_host_id)
        if defined_tags is not None:
            _setter("defined_tags", defined_tags)
        if display_name is not None:
            _setter("display_name", display_name)
        if extended_metadata is not None:
            _setter("extended_metadata", extended_metadata)
        if fault_domain is not None:
            _setter("fault_domain", fault_domain)
        if freeform_tags is not None:
            _setter("freeform_tags", freeform_tags)
        if instance_options is not None:
            _setter("instance_options", instance_options)
        if ipxe_script is not None:
            _setter("ipxe_script", ipxe_script)
        if is_pv_encryption_in_transit_enabled is not None:
            _setter("is_pv_encryption_in_transit_enabled", is_pv_encryption_in_transit_enabled)
        if launch_mode is not None:
            _setter("launch_mode", launch_mode)
        if launch_options is not None:
            _setter("launch_options", launch_options)
        if metadata is not None:
            _setter("metadata", metadata)
        if platform_config is not None:
            _setter("platform_config", platform_config)
        if preemptible_instance_config is not None:
            _setter("preemptible_instance_config", preemptible_instance_config)
        if preferred_maintenance_action is not None:
            _setter("preferred_maintenance_action", preferred_maintenance_action)
        if shape is not None:
            _setter("shape", shape)
        if shape_config is not None:
            _setter("shape_config", shape_config)
        if source_details is not None:
            _setter("source_details", source_details)

    @property
    @pulumi.getter(name="agentConfig")
    def agent_config(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsAgentConfigArgs']]:
        """
        Configuration options for the Oracle Cloud Agent software running on the instance.
        """
        return pulumi.get(self, "agent_config")

    @agent_config.setter
    def agent_config(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsAgentConfigArgs']]):
        pulumi.set(self, "agent_config", value)

    @property
    @pulumi.getter(name="availabilityConfig")
    def availability_config(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsAvailabilityConfigArgs']]:
        """
        Options for defining the availabiity of a VM instance after a maintenance event that impacts the underlying hardware.
        """
        return pulumi.get(self, "availability_config")

    @availability_config.setter
    def availability_config(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsAvailabilityConfigArgs']]):
        pulumi.set(self, "availability_config", value)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[pulumi.Input[str]]:
        """
        The availability domain of the instance.  Example: `Uocm:PHX-AD-1`
        """
        return pulumi.get(self, "availability_domain")

    @availability_domain.setter
    def availability_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_domain", value)

    @property
    @pulumi.getter(name="capacityReservationId")
    def capacity_reservation_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the compute capacity reservation this instance is launched under.
        """
        return pulumi.get(self, "capacity_reservation_id")

    @capacity_reservation_id.setter
    def capacity_reservation_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "capacity_reservation_id", value)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the compartment containing images to search
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter(name="createVnicDetails")
    def create_vnic_details(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsCreateVnicDetailsArgs']]:
        """
        Contains the properties of the VNIC for an instance configuration. See [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) and [Instance Configurations](https://docs.cloud.oracle.com/iaas/Content/Compute/Concepts/instancemanagement.htm#config) for more information.
        """
        return pulumi.get(self, "create_vnic_details")

    @create_vnic_details.setter
    def create_vnic_details(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsCreateVnicDetailsArgs']]):
        pulumi.set(self, "create_vnic_details", value)

    @property
    @pulumi.getter(name="dedicatedVmHostId")
    def dedicated_vm_host_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the dedicated virtual machine host to place the instance on.

        Dedicated VM hosts can be used when launching individual instances from an instance configuration. They cannot be used to launch instance pools.
        """
        return pulumi.get(self, "dedicated_vm_host_id")

    @dedicated_vm_host_id.setter
    def dedicated_vm_host_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dedicated_vm_host_id", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="extendedMetadata")
    def extended_metadata(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Additional metadata key/value pairs that you provide. They serve the same purpose and functionality as fields in the `metadata` object.

        They are distinguished from `metadata` fields in that these can be nested JSON objects (whereas `metadata` fields are string/string maps only).

        The combined size of the `metadata` and `extendedMetadata` objects can be a maximum of 32,000 bytes.
        """
        return pulumi.get(self, "extended_metadata")

    @extended_metadata.setter
    def extended_metadata(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "extended_metadata", value)

    @property
    @pulumi.getter(name="faultDomain")
    def fault_domain(self) -> Optional[pulumi.Input[str]]:
        """
        A fault domain is a grouping of hardware and infrastructure within an availability domain. Each availability domain contains three fault domains. Fault domains let you distribute your instances so that they are not on the same physical hardware within a single availability domain. A hardware failure or Compute hardware maintenance that affects one fault domain does not affect instances in other fault domains.

        If you do not specify the fault domain, the system selects one for you.

        To get a list of fault domains, use the [ListFaultDomains](https://docs.cloud.oracle.com/iaas/api/#/en/identity/20160918/FaultDomain/ListFaultDomains) operation in the Identity and Access Management Service API.

        Example: `FAULT-DOMAIN-1`
        """
        return pulumi.get(self, "fault_domain")

    @fault_domain.setter
    def fault_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fault_domain", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter(name="instanceOptions")
    def instance_options(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsInstanceOptionsArgs']]:
        """
        Optional mutable instance options. As a part of Instance Metadata Service Security Header, This allows user to disable the legacy imds endpoints.
        """
        return pulumi.get(self, "instance_options")

    @instance_options.setter
    def instance_options(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsInstanceOptionsArgs']]):
        pulumi.set(self, "instance_options", value)

    @property
    @pulumi.getter(name="ipxeScript")
    def ipxe_script(self) -> Optional[pulumi.Input[str]]:
        """
        This is an advanced option.

        When a bare metal or virtual machine instance boots, the iPXE firmware that runs on the instance is configured to run an iPXE script to continue the boot process.

        If you want more control over the boot process, you can provide your own custom iPXE script that will run when the instance boots; however, you should be aware that the same iPXE script will run every time an instance boots; not only after the initial LaunchInstance call.

        The default iPXE script connects to the instance's local boot volume over iSCSI and performs a network boot. If you use a custom iPXE script and want to network-boot from the instance's local boot volume over iSCSI the same way as the default iPXE script, you should use the following iSCSI IP address: 169.254.0.2, and boot volume IQN: iqn.2015-02.oracle.boot.

        For more information about the Bring Your Own Image feature of Oracle Cloud Infrastructure, see [Bring Your Own Image](https://docs.cloud.oracle.com/iaas/Content/Compute/References/bringyourownimage.htm).

        For more information about iPXE, see http://ipxe.org.
        """
        return pulumi.get(self, "ipxe_script")

    @ipxe_script.setter
    def ipxe_script(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipxe_script", value)

    @property
    @pulumi.getter(name="isPvEncryptionInTransitEnabled")
    def is_pv_encryption_in_transit_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Deprecated. Instead use `isPvEncryptionInTransitEnabled` in [InstanceConfigurationLaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/datatypes/InstanceConfigurationLaunchInstanceDetails).
        """
        return pulumi.get(self, "is_pv_encryption_in_transit_enabled")

    @is_pv_encryption_in_transit_enabled.setter
    def is_pv_encryption_in_transit_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_pv_encryption_in_transit_enabled", value)

    @property
    @pulumi.getter(name="launchMode")
    def launch_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the configuration mode for launching virtual machine (VM) instances. The configuration modes are:
        """
        return pulumi.get(self, "launch_mode")

    @launch_mode.setter
    def launch_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "launch_mode", value)

    @property
    @pulumi.getter(name="launchOptions")
    def launch_options(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsLaunchOptionsArgs']]:
        """
        Options for tuning the compatibility and performance of VM shapes. The values that you specify override any default values.
        """
        return pulumi.get(self, "launch_options")

    @launch_options.setter
    def launch_options(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsLaunchOptionsArgs']]):
        pulumi.set(self, "launch_options", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Custom metadata key/value pairs that you provide, such as the SSH public key required to connect to the instance.

        A metadata service runs on every launched instance. The service is an HTTP endpoint listening on 169.254.169.254. You can use the service to:
        * Provide information to [Cloud-Init](https://cloudinit.readthedocs.org/en/latest/) to be used for various system initialization tasks.
        * Get information about the instance, including the custom metadata that you provide when you launch the instance.

        **Providing Cloud-Init Metadata**

        You can use the following metadata key names to provide information to Cloud-Init:

        **"ssh_authorized_keys"** - Provide one or more public SSH keys to be included in the `~/.ssh/authorized_keys` file for the default user on the instance. Use a newline character to separate multiple keys. The SSH keys must be in the format necessary for the `authorized_keys` file, as shown in the example below.

        **"user_data"** - Provide your own base64-encoded data to be used by Cloud-Init to run custom scripts or provide custom Cloud-Init configuration. For information about how to take advantage of user data, see the [Cloud-Init Documentation](http://cloudinit.readthedocs.org/en/latest/topics/format.html).

        **Metadata Example**

        "metadata" : { "quake_bot_level" : "Severe", "ssh_authorized_keys" : "ssh-rsa <your_public_SSH_key>== rsa-key-20160227", "user_data" : "<your_public_SSH_key>==" } **Getting Metadata on the Instance**

        To get information about your instance, connect to the instance using SSH and issue any of the following GET requests:

        curl -H "Authorization: Bearer Oracle" http://169.254.169.254/opc/v2/instance/ curl -H "Authorization: Bearer Oracle" http://169.254.169.254/opc/v2/instance/metadata/ curl -H "Authorization: Bearer Oracle" http://169.254.169.254/opc/v2/instance/metadata/<any-key-name>

        You'll get back a response that includes all the instance information; only the metadata information; or the metadata information for the specified key name, respectively.

        The combined size of the `metadata` and `extendedMetadata` objects can be a maximum of 32,000 bytes.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter(name="platformConfig")
    def platform_config(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsPlatformConfigArgs']]:
        """
        The platform configuration requested for the instance.

        If you provide the parameter, the instance is created with the platform configuration that you specify. For any values that you omit, the instance uses the default configuration values for the `shape` that you specify. If you don't provide the parameter, the default values for the `shape` are used.

        Each shape only supports certain configurable values. If the values that you provide are not valid for the specified `shape`, an error is returned.
        """
        return pulumi.get(self, "platform_config")

    @platform_config.setter
    def platform_config(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsPlatformConfigArgs']]):
        pulumi.set(self, "platform_config", value)

    @property
    @pulumi.getter(name="preemptibleInstanceConfig")
    def preemptible_instance_config(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsPreemptibleInstanceConfigArgs']]:
        """
        Configuration options for preemptible instances.
        """
        return pulumi.get(self, "preemptible_instance_config")

    @preemptible_instance_config.setter
    def preemptible_instance_config(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsPreemptibleInstanceConfigArgs']]):
        pulumi.set(self, "preemptible_instance_config", value)

    @property
    @pulumi.getter(name="preferredMaintenanceAction")
    def preferred_maintenance_action(self) -> Optional[pulumi.Input[str]]:
        """
        The preferred maintenance action for an instance. The default is LIVE_MIGRATE, if live migration is supported.
        """
        return pulumi.get(self, "preferred_maintenance_action")

    @preferred_maintenance_action.setter
    def preferred_maintenance_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preferred_maintenance_action", value)

    @property
    @pulumi.getter
    def shape(self) -> Optional[pulumi.Input[str]]:
        """
        The shape of an instance. The shape determines the number of CPUs, amount of memory, and other resources allocated to the instance.

        You can enumerate all available shapes by calling [ListShapes](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Shape/ListShapes).
        """
        return pulumi.get(self, "shape")

    @shape.setter
    def shape(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shape", value)

    @property
    @pulumi.getter(name="shapeConfig")
    def shape_config(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsShapeConfigArgs']]:
        """
        The shape configuration requested for the instance.

        If the parameter is provided, the instance is created with the resources that you specify. If some properties are missing or the entire parameter is not provided, the instance is created with the default configuration values for the `shape` that you specify.

        Each shape only supports certain configurable values. If the values that you provide are not valid for the specified `shape`, an error is returned.
        """
        return pulumi.get(self, "shape_config")

    @shape_config.setter
    def shape_config(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsShapeConfigArgs']]):
        pulumi.set(self, "shape_config", value)

    @property
    @pulumi.getter(name="sourceDetails")
    def source_details(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsSourceDetailsArgs']]:
        return pulumi.get(self, "source_details")

    @source_details.setter
    def source_details(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsSourceDetailsArgs']]):
        pulumi.set(self, "source_details", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsLaunchDetailsAgentConfigArgs:
    def __init__(__self__, *,
                 are_all_plugins_disabled: Optional[pulumi.Input[bool]] = None,
                 is_management_disabled: Optional[pulumi.Input[bool]] = None,
                 is_monitoring_disabled: Optional[pulumi.Input[bool]] = None,
                 plugins_configs: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsAgentConfigPluginsConfigArgs']]]] = None):
        """
        :param pulumi.Input[bool] are_all_plugins_disabled: Whether Oracle Cloud Agent can run all the available plugins. This includes the management and monitoring plugins.
               
               To get a list of available plugins, use the [ListInstanceagentAvailablePlugins](https://docs.cloud.oracle.com/iaas/api/#/en/instanceagent/20180530/Plugin/ListInstanceagentAvailablePlugins) operation in the Oracle Cloud Agent API. For more information about the available plugins, see [Managing Plugins with Oracle Cloud Agent](https://docs.cloud.oracle.com/iaas/Content/Compute/Tasks/manage-plugins.htm).
        :param pulumi.Input[bool] is_management_disabled: Whether Oracle Cloud Agent can run all the available management plugins. Default value is false (management plugins are enabled).
               
               These are the management plugins: OS Management Service Agent and Compute Instance Run Command.
               
               The management plugins are controlled by this parameter and by the per-plugin configuration in the `pluginsConfig` object.
               * If `isManagementDisabled` is true, all of the management plugins are disabled, regardless of the per-plugin configuration.
               * If `isManagementDisabled` is false, all of the management plugins are enabled. You can optionally disable individual management plugins by providing a value in the `pluginsConfig` object.
        :param pulumi.Input[bool] is_monitoring_disabled: Whether Oracle Cloud Agent can gather performance metrics and monitor the instance using the monitoring plugins. Default value is false (monitoring plugins are enabled).
               
               These are the monitoring plugins: Compute Instance Monitoring and Custom Logs Monitoring.
               
               The monitoring plugins are controlled by this parameter and by the per-plugin configuration in the `pluginsConfig` object.
               * If `isMonitoringDisabled` is true, all of the monitoring plugins are disabled, regardless of the per-plugin configuration.
               * If `isMonitoringDisabled` is false, all of the monitoring plugins are enabled. You can optionally disable individual monitoring plugins by providing a value in the `pluginsConfig` object.
        :param pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsAgentConfigPluginsConfigArgs']]] plugins_configs: The configuration of plugins associated with this instance.
        """
        InstanceConfigurationInstanceDetailsLaunchDetailsAgentConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            are_all_plugins_disabled=are_all_plugins_disabled,
            is_management_disabled=is_management_disabled,
            is_monitoring_disabled=is_monitoring_disabled,
            plugins_configs=plugins_configs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             are_all_plugins_disabled: Optional[pulumi.Input[bool]] = None,
             is_management_disabled: Optional[pulumi.Input[bool]] = None,
             is_monitoring_disabled: Optional[pulumi.Input[bool]] = None,
             plugins_configs: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsAgentConfigPluginsConfigArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if are_all_plugins_disabled is not None:
            _setter("are_all_plugins_disabled", are_all_plugins_disabled)
        if is_management_disabled is not None:
            _setter("is_management_disabled", is_management_disabled)
        if is_monitoring_disabled is not None:
            _setter("is_monitoring_disabled", is_monitoring_disabled)
        if plugins_configs is not None:
            _setter("plugins_configs", plugins_configs)

    @property
    @pulumi.getter(name="areAllPluginsDisabled")
    def are_all_plugins_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether Oracle Cloud Agent can run all the available plugins. This includes the management and monitoring plugins.

        To get a list of available plugins, use the [ListInstanceagentAvailablePlugins](https://docs.cloud.oracle.com/iaas/api/#/en/instanceagent/20180530/Plugin/ListInstanceagentAvailablePlugins) operation in the Oracle Cloud Agent API. For more information about the available plugins, see [Managing Plugins with Oracle Cloud Agent](https://docs.cloud.oracle.com/iaas/Content/Compute/Tasks/manage-plugins.htm).
        """
        return pulumi.get(self, "are_all_plugins_disabled")

    @are_all_plugins_disabled.setter
    def are_all_plugins_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "are_all_plugins_disabled", value)

    @property
    @pulumi.getter(name="isManagementDisabled")
    def is_management_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether Oracle Cloud Agent can run all the available management plugins. Default value is false (management plugins are enabled).

        These are the management plugins: OS Management Service Agent and Compute Instance Run Command.

        The management plugins are controlled by this parameter and by the per-plugin configuration in the `pluginsConfig` object.
        * If `isManagementDisabled` is true, all of the management plugins are disabled, regardless of the per-plugin configuration.
        * If `isManagementDisabled` is false, all of the management plugins are enabled. You can optionally disable individual management plugins by providing a value in the `pluginsConfig` object.
        """
        return pulumi.get(self, "is_management_disabled")

    @is_management_disabled.setter
    def is_management_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_management_disabled", value)

    @property
    @pulumi.getter(name="isMonitoringDisabled")
    def is_monitoring_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether Oracle Cloud Agent can gather performance metrics and monitor the instance using the monitoring plugins. Default value is false (monitoring plugins are enabled).

        These are the monitoring plugins: Compute Instance Monitoring and Custom Logs Monitoring.

        The monitoring plugins are controlled by this parameter and by the per-plugin configuration in the `pluginsConfig` object.
        * If `isMonitoringDisabled` is true, all of the monitoring plugins are disabled, regardless of the per-plugin configuration.
        * If `isMonitoringDisabled` is false, all of the monitoring plugins are enabled. You can optionally disable individual monitoring plugins by providing a value in the `pluginsConfig` object.
        """
        return pulumi.get(self, "is_monitoring_disabled")

    @is_monitoring_disabled.setter
    def is_monitoring_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monitoring_disabled", value)

    @property
    @pulumi.getter(name="pluginsConfigs")
    def plugins_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsAgentConfigPluginsConfigArgs']]]]:
        """
        The configuration of plugins associated with this instance.
        """
        return pulumi.get(self, "plugins_configs")

    @plugins_configs.setter
    def plugins_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsAgentConfigPluginsConfigArgs']]]]):
        pulumi.set(self, "plugins_configs", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsLaunchDetailsAgentConfigPluginsConfigArgs:
    def __init__(__self__, *,
                 desired_state: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] desired_state: Whether the plugin should be enabled or disabled.
               
               To enable the monitoring and management plugins, the `isMonitoringDisabled` and `isManagementDisabled` attributes must also be set to false.
        :param pulumi.Input[str] name: The plugin name. To get a list of available plugins, use the [ListInstanceagentAvailablePlugins](https://docs.cloud.oracle.com/iaas/api/#/en/instanceagent/20180530/Plugin/ListInstanceagentAvailablePlugins) operation in the Oracle Cloud Agent API. For more information about the available plugins, see [Managing Plugins with Oracle Cloud Agent](https://docs.cloud.oracle.com/iaas/Content/Compute/Tasks/manage-plugins.htm).
        """
        InstanceConfigurationInstanceDetailsLaunchDetailsAgentConfigPluginsConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            desired_state=desired_state,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             desired_state: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if desired_state is not None:
            _setter("desired_state", desired_state)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="desiredState")
    def desired_state(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the plugin should be enabled or disabled.

        To enable the monitoring and management plugins, the `isMonitoringDisabled` and `isManagementDisabled` attributes must also be set to false.
        """
        return pulumi.get(self, "desired_state")

    @desired_state.setter
    def desired_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "desired_state", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The plugin name. To get a list of available plugins, use the [ListInstanceagentAvailablePlugins](https://docs.cloud.oracle.com/iaas/api/#/en/instanceagent/20180530/Plugin/ListInstanceagentAvailablePlugins) operation in the Oracle Cloud Agent API. For more information about the available plugins, see [Managing Plugins with Oracle Cloud Agent](https://docs.cloud.oracle.com/iaas/Content/Compute/Tasks/manage-plugins.htm).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsLaunchDetailsAvailabilityConfigArgs:
    def __init__(__self__, *,
                 is_live_migration_preferred: Optional[pulumi.Input[bool]] = None,
                 recovery_action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_live_migration_preferred: Whether to live migrate supported VM instances to a healthy physical VM host without disrupting running instances during infrastructure maintenance events. If null, Oracle chooses the best option for migrating the VM during infrastructure maintenance events.
        :param pulumi.Input[str] recovery_action: The lifecycle state for an instance when it is recovered after infrastructure maintenance.
        """
        InstanceConfigurationInstanceDetailsLaunchDetailsAvailabilityConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_live_migration_preferred=is_live_migration_preferred,
            recovery_action=recovery_action,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_live_migration_preferred: Optional[pulumi.Input[bool]] = None,
             recovery_action: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_live_migration_preferred is not None:
            _setter("is_live_migration_preferred", is_live_migration_preferred)
        if recovery_action is not None:
            _setter("recovery_action", recovery_action)

    @property
    @pulumi.getter(name="isLiveMigrationPreferred")
    def is_live_migration_preferred(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to live migrate supported VM instances to a healthy physical VM host without disrupting running instances during infrastructure maintenance events. If null, Oracle chooses the best option for migrating the VM during infrastructure maintenance events.
        """
        return pulumi.get(self, "is_live_migration_preferred")

    @is_live_migration_preferred.setter
    def is_live_migration_preferred(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_live_migration_preferred", value)

    @property
    @pulumi.getter(name="recoveryAction")
    def recovery_action(self) -> Optional[pulumi.Input[str]]:
        """
        The lifecycle state for an instance when it is recovered after infrastructure maintenance.
        """
        return pulumi.get(self, "recovery_action")

    @recovery_action.setter
    def recovery_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recovery_action", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsLaunchDetailsCreateVnicDetailsArgs:
    def __init__(__self__, *,
                 assign_ipv6ip: Optional[pulumi.Input[bool]] = None,
                 assign_private_dns_record: Optional[pulumi.Input[bool]] = None,
                 assign_public_ip: Optional[pulumi.Input[bool]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 hostname_label: Optional[pulumi.Input[str]] = None,
                 ipv6address_ipv6subnet_cidr_pair_details: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs']]]] = None,
                 nsg_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 private_ip: Optional[pulumi.Input[str]] = None,
                 skip_source_dest_check: Optional[pulumi.Input[bool]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] assign_ipv6ip: Whether to allocate an IPv6 address at instance and VNIC creation from an IPv6 enabled subnet. Default: False. When provided you may optionally provide an IPv6 prefix (`ipv6SubnetCidr`) of your choice to assign the IPv6 address from. If `ipv6SubnetCidr` is not provided then an IPv6 prefix is chosen for you.
        :param pulumi.Input[bool] assign_private_dns_record: Whether the VNIC should be assigned a private DNS record. See the `assignPrivateDnsRecord` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        :param pulumi.Input[bool] assign_public_ip: Whether the VNIC should be assigned a public IP address. See the `assignPublicIp` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        :param pulumi.Input[Mapping[str, Any]] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        :param pulumi.Input[str] display_name: A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        :param pulumi.Input[Mapping[str, Any]] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param pulumi.Input[str] hostname_label: The hostname for the VNIC's primary private IP. See the `hostnameLabel` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        :param pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs']]] ipv6address_ipv6subnet_cidr_pair_details: A list of IPv6 prefix ranges from which the VNIC should be assigned an IPv6 address. You can provide only the prefix ranges and Oracle Cloud Infrastructure selects an available address from the range. You can optionally choose to leave the prefix range empty and instead provide the specific IPv6 address that should be used from within that range.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] nsg_ids: A list of the OCIDs of the network security groups (NSGs) to add the VNIC to. For more information about NSGs, see [NetworkSecurityGroup](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/NetworkSecurityGroup/).
        :param pulumi.Input[str] private_ip: A private IP address of your choice to assign to the VNIC. See the `privateIp` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        :param pulumi.Input[bool] skip_source_dest_check: Whether the source/destination check is disabled on the VNIC. See the `skipSourceDestCheck` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        :param pulumi.Input[str] subnet_id: The OCID of the subnet to create the VNIC in. See the `subnetId` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        InstanceConfigurationInstanceDetailsLaunchDetailsCreateVnicDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            assign_ipv6ip=assign_ipv6ip,
            assign_private_dns_record=assign_private_dns_record,
            assign_public_ip=assign_public_ip,
            defined_tags=defined_tags,
            display_name=display_name,
            freeform_tags=freeform_tags,
            hostname_label=hostname_label,
            ipv6address_ipv6subnet_cidr_pair_details=ipv6address_ipv6subnet_cidr_pair_details,
            nsg_ids=nsg_ids,
            private_ip=private_ip,
            skip_source_dest_check=skip_source_dest_check,
            subnet_id=subnet_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             assign_ipv6ip: Optional[pulumi.Input[bool]] = None,
             assign_private_dns_record: Optional[pulumi.Input[bool]] = None,
             assign_public_ip: Optional[pulumi.Input[bool]] = None,
             defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             display_name: Optional[pulumi.Input[str]] = None,
             freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             hostname_label: Optional[pulumi.Input[str]] = None,
             ipv6address_ipv6subnet_cidr_pair_details: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs']]]] = None,
             nsg_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             private_ip: Optional[pulumi.Input[str]] = None,
             skip_source_dest_check: Optional[pulumi.Input[bool]] = None,
             subnet_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if assign_ipv6ip is not None:
            _setter("assign_ipv6ip", assign_ipv6ip)
        if assign_private_dns_record is not None:
            _setter("assign_private_dns_record", assign_private_dns_record)
        if assign_public_ip is not None:
            _setter("assign_public_ip", assign_public_ip)
        if defined_tags is not None:
            _setter("defined_tags", defined_tags)
        if display_name is not None:
            _setter("display_name", display_name)
        if freeform_tags is not None:
            _setter("freeform_tags", freeform_tags)
        if hostname_label is not None:
            _setter("hostname_label", hostname_label)
        if ipv6address_ipv6subnet_cidr_pair_details is not None:
            _setter("ipv6address_ipv6subnet_cidr_pair_details", ipv6address_ipv6subnet_cidr_pair_details)
        if nsg_ids is not None:
            _setter("nsg_ids", nsg_ids)
        if private_ip is not None:
            _setter("private_ip", private_ip)
        if skip_source_dest_check is not None:
            _setter("skip_source_dest_check", skip_source_dest_check)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)

    @property
    @pulumi.getter(name="assignIpv6ip")
    def assign_ipv6ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allocate an IPv6 address at instance and VNIC creation from an IPv6 enabled subnet. Default: False. When provided you may optionally provide an IPv6 prefix (`ipv6SubnetCidr`) of your choice to assign the IPv6 address from. If `ipv6SubnetCidr` is not provided then an IPv6 prefix is chosen for you.
        """
        return pulumi.get(self, "assign_ipv6ip")

    @assign_ipv6ip.setter
    def assign_ipv6ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_ipv6ip", value)

    @property
    @pulumi.getter(name="assignPrivateDnsRecord")
    def assign_private_dns_record(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the VNIC should be assigned a private DNS record. See the `assignPrivateDnsRecord` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "assign_private_dns_record")

    @assign_private_dns_record.setter
    def assign_private_dns_record(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_private_dns_record", value)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the VNIC should be assigned a public IP address. See the `assignPublicIp` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_public_ip", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter(name="hostnameLabel")
    def hostname_label(self) -> Optional[pulumi.Input[str]]:
        """
        The hostname for the VNIC's primary private IP. See the `hostnameLabel` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "hostname_label")

    @hostname_label.setter
    def hostname_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname_label", value)

    @property
    @pulumi.getter(name="ipv6addressIpv6subnetCidrPairDetails")
    def ipv6address_ipv6subnet_cidr_pair_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs']]]]:
        """
        A list of IPv6 prefix ranges from which the VNIC should be assigned an IPv6 address. You can provide only the prefix ranges and Oracle Cloud Infrastructure selects an available address from the range. You can optionally choose to leave the prefix range empty and instead provide the specific IPv6 address that should be used from within that range.
        """
        return pulumi.get(self, "ipv6address_ipv6subnet_cidr_pair_details")

    @ipv6address_ipv6subnet_cidr_pair_details.setter
    def ipv6address_ipv6subnet_cidr_pair_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs']]]]):
        pulumi.set(self, "ipv6address_ipv6subnet_cidr_pair_details", value)

    @property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of the OCIDs of the network security groups (NSGs) to add the VNIC to. For more information about NSGs, see [NetworkSecurityGroup](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/NetworkSecurityGroup/).
        """
        return pulumi.get(self, "nsg_ids")

    @nsg_ids.setter
    def nsg_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "nsg_ids", value)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[str]]:
        """
        A private IP address of your choice to assign to the VNIC. See the `privateIp` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_ip", value)

    @property
    @pulumi.getter(name="skipSourceDestCheck")
    def skip_source_dest_check(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the source/destination check is disabled on the VNIC. See the `skipSourceDestCheck` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "skip_source_dest_check")

    @skip_source_dest_check.setter
    def skip_source_dest_check(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_source_dest_check", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the subnet to create the VNIC in. See the `subnetId` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsLaunchDetailsCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs:
    def __init__(__self__, *,
                 ipv6address: Optional[pulumi.Input[str]] = None,
                 ipv6subnet_cidr: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ipv6address: Optional. An available IPv6 address of your subnet from a valid IPv6 prefix on the subnet (otherwise the IP address is automatically assigned).
        :param pulumi.Input[str] ipv6subnet_cidr: Optional. Used to disambiguate which subnet prefix should be used to create an IPv6 allocation.
        """
        InstanceConfigurationInstanceDetailsLaunchDetailsCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ipv6address=ipv6address,
            ipv6subnet_cidr=ipv6subnet_cidr,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ipv6address: Optional[pulumi.Input[str]] = None,
             ipv6subnet_cidr: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ipv6address is not None:
            _setter("ipv6address", ipv6address)
        if ipv6subnet_cidr is not None:
            _setter("ipv6subnet_cidr", ipv6subnet_cidr)

    @property
    @pulumi.getter
    def ipv6address(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. An available IPv6 address of your subnet from a valid IPv6 prefix on the subnet (otherwise the IP address is automatically assigned).
        """
        return pulumi.get(self, "ipv6address")

    @ipv6address.setter
    def ipv6address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6address", value)

    @property
    @pulumi.getter(name="ipv6subnetCidr")
    def ipv6subnet_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Used to disambiguate which subnet prefix should be used to create an IPv6 allocation.
        """
        return pulumi.get(self, "ipv6subnet_cidr")

    @ipv6subnet_cidr.setter
    def ipv6subnet_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6subnet_cidr", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsLaunchDetailsInstanceOptionsArgs:
    def __init__(__self__, *,
                 are_legacy_imds_endpoints_disabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] are_legacy_imds_endpoints_disabled: Whether to disable the legacy (/v1) instance metadata service endpoints. Customers who have migrated to /v2 should set this to true for added security. Default is false.
        """
        InstanceConfigurationInstanceDetailsLaunchDetailsInstanceOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            are_legacy_imds_endpoints_disabled=are_legacy_imds_endpoints_disabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             are_legacy_imds_endpoints_disabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if are_legacy_imds_endpoints_disabled is not None:
            _setter("are_legacy_imds_endpoints_disabled", are_legacy_imds_endpoints_disabled)

    @property
    @pulumi.getter(name="areLegacyImdsEndpointsDisabled")
    def are_legacy_imds_endpoints_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable the legacy (/v1) instance metadata service endpoints. Customers who have migrated to /v2 should set this to true for added security. Default is false.
        """
        return pulumi.get(self, "are_legacy_imds_endpoints_disabled")

    @are_legacy_imds_endpoints_disabled.setter
    def are_legacy_imds_endpoints_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "are_legacy_imds_endpoints_disabled", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsLaunchDetailsLaunchOptionsArgs:
    def __init__(__self__, *,
                 boot_volume_type: Optional[pulumi.Input[str]] = None,
                 firmware: Optional[pulumi.Input[str]] = None,
                 is_consistent_volume_naming_enabled: Optional[pulumi.Input[bool]] = None,
                 is_pv_encryption_in_transit_enabled: Optional[pulumi.Input[bool]] = None,
                 network_type: Optional[pulumi.Input[str]] = None,
                 remote_data_volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] boot_volume_type: Emulation type for the boot volume.
        :param pulumi.Input[str] firmware: Firmware used to boot VM. Select the option that matches your operating system.
        :param pulumi.Input[bool] is_consistent_volume_naming_enabled: Whether to enable consistent volume naming feature. Defaults to false.
        :param pulumi.Input[bool] is_pv_encryption_in_transit_enabled: Deprecated. Instead use `isPvEncryptionInTransitEnabled` in [InstanceConfigurationLaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/datatypes/InstanceConfigurationLaunchInstanceDetails).
        :param pulumi.Input[str] network_type: Emulation type for the physical network interface card (NIC).
        :param pulumi.Input[str] remote_data_volume_type: Emulation type for volume.
        """
        InstanceConfigurationInstanceDetailsLaunchDetailsLaunchOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            boot_volume_type=boot_volume_type,
            firmware=firmware,
            is_consistent_volume_naming_enabled=is_consistent_volume_naming_enabled,
            is_pv_encryption_in_transit_enabled=is_pv_encryption_in_transit_enabled,
            network_type=network_type,
            remote_data_volume_type=remote_data_volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             boot_volume_type: Optional[pulumi.Input[str]] = None,
             firmware: Optional[pulumi.Input[str]] = None,
             is_consistent_volume_naming_enabled: Optional[pulumi.Input[bool]] = None,
             is_pv_encryption_in_transit_enabled: Optional[pulumi.Input[bool]] = None,
             network_type: Optional[pulumi.Input[str]] = None,
             remote_data_volume_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if boot_volume_type is not None:
            _setter("boot_volume_type", boot_volume_type)
        if firmware is not None:
            _setter("firmware", firmware)
        if is_consistent_volume_naming_enabled is not None:
            _setter("is_consistent_volume_naming_enabled", is_consistent_volume_naming_enabled)
        if is_pv_encryption_in_transit_enabled is not None:
            _setter("is_pv_encryption_in_transit_enabled", is_pv_encryption_in_transit_enabled)
        if network_type is not None:
            _setter("network_type", network_type)
        if remote_data_volume_type is not None:
            _setter("remote_data_volume_type", remote_data_volume_type)

    @property
    @pulumi.getter(name="bootVolumeType")
    def boot_volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        Emulation type for the boot volume.
        """
        return pulumi.get(self, "boot_volume_type")

    @boot_volume_type.setter
    def boot_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "boot_volume_type", value)

    @property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[str]]:
        """
        Firmware used to boot VM. Select the option that matches your operating system.
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "firmware", value)

    @property
    @pulumi.getter(name="isConsistentVolumeNamingEnabled")
    def is_consistent_volume_naming_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable consistent volume naming feature. Defaults to false.
        """
        return pulumi.get(self, "is_consistent_volume_naming_enabled")

    @is_consistent_volume_naming_enabled.setter
    def is_consistent_volume_naming_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_consistent_volume_naming_enabled", value)

    @property
    @pulumi.getter(name="isPvEncryptionInTransitEnabled")
    def is_pv_encryption_in_transit_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Deprecated. Instead use `isPvEncryptionInTransitEnabled` in [InstanceConfigurationLaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/datatypes/InstanceConfigurationLaunchInstanceDetails).
        """
        return pulumi.get(self, "is_pv_encryption_in_transit_enabled")

    @is_pv_encryption_in_transit_enabled.setter
    def is_pv_encryption_in_transit_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_pv_encryption_in_transit_enabled", value)

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> Optional[pulumi.Input[str]]:
        """
        Emulation type for the physical network interface card (NIC).
        """
        return pulumi.get(self, "network_type")

    @network_type.setter
    def network_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_type", value)

    @property
    @pulumi.getter(name="remoteDataVolumeType")
    def remote_data_volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        Emulation type for volume.
        """
        return pulumi.get(self, "remote_data_volume_type")

    @remote_data_volume_type.setter
    def remote_data_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_data_volume_type", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsLaunchDetailsPlatformConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 are_virtual_instructions_enabled: Optional[pulumi.Input[bool]] = None,
                 config_map: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 is_access_control_service_enabled: Optional[pulumi.Input[bool]] = None,
                 is_input_output_memory_management_unit_enabled: Optional[pulumi.Input[bool]] = None,
                 is_measured_boot_enabled: Optional[pulumi.Input[bool]] = None,
                 is_memory_encryption_enabled: Optional[pulumi.Input[bool]] = None,
                 is_secure_boot_enabled: Optional[pulumi.Input[bool]] = None,
                 is_symmetric_multi_threading_enabled: Optional[pulumi.Input[bool]] = None,
                 is_trusted_platform_module_enabled: Optional[pulumi.Input[bool]] = None,
                 numa_nodes_per_socket: Optional[pulumi.Input[str]] = None,
                 percentage_of_cores_enabled: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] type: The type of action to run when the instance is interrupted for eviction.
        :param pulumi.Input[bool] are_virtual_instructions_enabled: Whether virtualization instructions are available. For example, Secure Virtual Machine for AMD shapes or VT-x for Intel shapes.
        :param pulumi.Input[Mapping[str, Any]] config_map: Instance Platform Configuration Configuration Map for flexible setting input.
        :param pulumi.Input[bool] is_access_control_service_enabled: Whether the Access Control Service is enabled on the instance. When enabled, the platform can enforce PCIe device isolation, required for VFIO device pass-through.
        :param pulumi.Input[bool] is_input_output_memory_management_unit_enabled: Whether the input-output memory management unit is enabled.
        :param pulumi.Input[bool] is_measured_boot_enabled: Whether the Measured Boot feature is enabled on the instance.
        :param pulumi.Input[bool] is_memory_encryption_enabled: Whether the instance is a confidential instance. If this value is `true`, the instance is a confidential instance. The default value is `false`.
        :param pulumi.Input[bool] is_secure_boot_enabled: Whether Secure Boot is enabled on the instance.
        :param pulumi.Input[bool] is_symmetric_multi_threading_enabled: Whether symmetric multithreading is enabled on the instance. Symmetric multithreading is also called simultaneous multithreading (SMT) or Intel Hyper-Threading.
               
               Intel and AMD processors have two hardware execution threads per core (OCPU). SMT permits multiple independent threads of execution, to better use the resources and increase the efficiency of the CPU. When multithreading is disabled, only one thread is permitted to run on each core, which can provide higher or more predictable performance for some workloads.
        :param pulumi.Input[bool] is_trusted_platform_module_enabled: Whether the Trusted Platform Module (TPM) is enabled on the instance.
        :param pulumi.Input[str] numa_nodes_per_socket: The number of NUMA nodes per socket (NPS).
        :param pulumi.Input[int] percentage_of_cores_enabled: The percentage of cores enabled. Value must be a multiple of 25%. If the requested percentage results in a fractional number of cores, the system rounds up the number of cores across processors and provisions an instance with a whole number of cores.
               
               If the applications that you run on the instance use a core-based licensing model and need fewer cores than the full size of the shape, you can disable cores to reduce your licensing costs. The instance itself is billed for the full shape, regardless of whether all cores are enabled.
        """
        InstanceConfigurationInstanceDetailsLaunchDetailsPlatformConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            are_virtual_instructions_enabled=are_virtual_instructions_enabled,
            config_map=config_map,
            is_access_control_service_enabled=is_access_control_service_enabled,
            is_input_output_memory_management_unit_enabled=is_input_output_memory_management_unit_enabled,
            is_measured_boot_enabled=is_measured_boot_enabled,
            is_memory_encryption_enabled=is_memory_encryption_enabled,
            is_secure_boot_enabled=is_secure_boot_enabled,
            is_symmetric_multi_threading_enabled=is_symmetric_multi_threading_enabled,
            is_trusted_platform_module_enabled=is_trusted_platform_module_enabled,
            numa_nodes_per_socket=numa_nodes_per_socket,
            percentage_of_cores_enabled=percentage_of_cores_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[str],
             are_virtual_instructions_enabled: Optional[pulumi.Input[bool]] = None,
             config_map: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             is_access_control_service_enabled: Optional[pulumi.Input[bool]] = None,
             is_input_output_memory_management_unit_enabled: Optional[pulumi.Input[bool]] = None,
             is_measured_boot_enabled: Optional[pulumi.Input[bool]] = None,
             is_memory_encryption_enabled: Optional[pulumi.Input[bool]] = None,
             is_secure_boot_enabled: Optional[pulumi.Input[bool]] = None,
             is_symmetric_multi_threading_enabled: Optional[pulumi.Input[bool]] = None,
             is_trusted_platform_module_enabled: Optional[pulumi.Input[bool]] = None,
             numa_nodes_per_socket: Optional[pulumi.Input[str]] = None,
             percentage_of_cores_enabled: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if are_virtual_instructions_enabled is not None:
            _setter("are_virtual_instructions_enabled", are_virtual_instructions_enabled)
        if config_map is not None:
            _setter("config_map", config_map)
        if is_access_control_service_enabled is not None:
            _setter("is_access_control_service_enabled", is_access_control_service_enabled)
        if is_input_output_memory_management_unit_enabled is not None:
            _setter("is_input_output_memory_management_unit_enabled", is_input_output_memory_management_unit_enabled)
        if is_measured_boot_enabled is not None:
            _setter("is_measured_boot_enabled", is_measured_boot_enabled)
        if is_memory_encryption_enabled is not None:
            _setter("is_memory_encryption_enabled", is_memory_encryption_enabled)
        if is_secure_boot_enabled is not None:
            _setter("is_secure_boot_enabled", is_secure_boot_enabled)
        if is_symmetric_multi_threading_enabled is not None:
            _setter("is_symmetric_multi_threading_enabled", is_symmetric_multi_threading_enabled)
        if is_trusted_platform_module_enabled is not None:
            _setter("is_trusted_platform_module_enabled", is_trusted_platform_module_enabled)
        if numa_nodes_per_socket is not None:
            _setter("numa_nodes_per_socket", numa_nodes_per_socket)
        if percentage_of_cores_enabled is not None:
            _setter("percentage_of_cores_enabled", percentage_of_cores_enabled)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of action to run when the instance is interrupted for eviction.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="areVirtualInstructionsEnabled")
    def are_virtual_instructions_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether virtualization instructions are available. For example, Secure Virtual Machine for AMD shapes or VT-x for Intel shapes.
        """
        return pulumi.get(self, "are_virtual_instructions_enabled")

    @are_virtual_instructions_enabled.setter
    def are_virtual_instructions_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "are_virtual_instructions_enabled", value)

    @property
    @pulumi.getter(name="configMap")
    def config_map(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Instance Platform Configuration Configuration Map for flexible setting input.
        """
        return pulumi.get(self, "config_map")

    @config_map.setter
    def config_map(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "config_map", value)

    @property
    @pulumi.getter(name="isAccessControlServiceEnabled")
    def is_access_control_service_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the Access Control Service is enabled on the instance. When enabled, the platform can enforce PCIe device isolation, required for VFIO device pass-through.
        """
        return pulumi.get(self, "is_access_control_service_enabled")

    @is_access_control_service_enabled.setter
    def is_access_control_service_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_access_control_service_enabled", value)

    @property
    @pulumi.getter(name="isInputOutputMemoryManagementUnitEnabled")
    def is_input_output_memory_management_unit_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the input-output memory management unit is enabled.
        """
        return pulumi.get(self, "is_input_output_memory_management_unit_enabled")

    @is_input_output_memory_management_unit_enabled.setter
    def is_input_output_memory_management_unit_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_input_output_memory_management_unit_enabled", value)

    @property
    @pulumi.getter(name="isMeasuredBootEnabled")
    def is_measured_boot_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the Measured Boot feature is enabled on the instance.
        """
        return pulumi.get(self, "is_measured_boot_enabled")

    @is_measured_boot_enabled.setter
    def is_measured_boot_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_measured_boot_enabled", value)

    @property
    @pulumi.getter(name="isMemoryEncryptionEnabled")
    def is_memory_encryption_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the instance is a confidential instance. If this value is `true`, the instance is a confidential instance. The default value is `false`.
        """
        return pulumi.get(self, "is_memory_encryption_enabled")

    @is_memory_encryption_enabled.setter
    def is_memory_encryption_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_memory_encryption_enabled", value)

    @property
    @pulumi.getter(name="isSecureBootEnabled")
    def is_secure_boot_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether Secure Boot is enabled on the instance.
        """
        return pulumi.get(self, "is_secure_boot_enabled")

    @is_secure_boot_enabled.setter
    def is_secure_boot_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_secure_boot_enabled", value)

    @property
    @pulumi.getter(name="isSymmetricMultiThreadingEnabled")
    def is_symmetric_multi_threading_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether symmetric multithreading is enabled on the instance. Symmetric multithreading is also called simultaneous multithreading (SMT) or Intel Hyper-Threading.

        Intel and AMD processors have two hardware execution threads per core (OCPU). SMT permits multiple independent threads of execution, to better use the resources and increase the efficiency of the CPU. When multithreading is disabled, only one thread is permitted to run on each core, which can provide higher or more predictable performance for some workloads.
        """
        return pulumi.get(self, "is_symmetric_multi_threading_enabled")

    @is_symmetric_multi_threading_enabled.setter
    def is_symmetric_multi_threading_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_symmetric_multi_threading_enabled", value)

    @property
    @pulumi.getter(name="isTrustedPlatformModuleEnabled")
    def is_trusted_platform_module_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the Trusted Platform Module (TPM) is enabled on the instance.
        """
        return pulumi.get(self, "is_trusted_platform_module_enabled")

    @is_trusted_platform_module_enabled.setter
    def is_trusted_platform_module_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_trusted_platform_module_enabled", value)

    @property
    @pulumi.getter(name="numaNodesPerSocket")
    def numa_nodes_per_socket(self) -> Optional[pulumi.Input[str]]:
        """
        The number of NUMA nodes per socket (NPS).
        """
        return pulumi.get(self, "numa_nodes_per_socket")

    @numa_nodes_per_socket.setter
    def numa_nodes_per_socket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "numa_nodes_per_socket", value)

    @property
    @pulumi.getter(name="percentageOfCoresEnabled")
    def percentage_of_cores_enabled(self) -> Optional[pulumi.Input[int]]:
        """
        The percentage of cores enabled. Value must be a multiple of 25%. If the requested percentage results in a fractional number of cores, the system rounds up the number of cores across processors and provisions an instance with a whole number of cores.

        If the applications that you run on the instance use a core-based licensing model and need fewer cores than the full size of the shape, you can disable cores to reduce your licensing costs. The instance itself is billed for the full shape, regardless of whether all cores are enabled.
        """
        return pulumi.get(self, "percentage_of_cores_enabled")

    @percentage_of_cores_enabled.setter
    def percentage_of_cores_enabled(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "percentage_of_cores_enabled", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsLaunchDetailsPreemptibleInstanceConfigArgs:
    def __init__(__self__, *,
                 preemption_action: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionActionArgs']] = None):
        """
        :param pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionActionArgs'] preemption_action: The action to run when the preemptible instance is interrupted for eviction.
        """
        InstanceConfigurationInstanceDetailsLaunchDetailsPreemptibleInstanceConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            preemption_action=preemption_action,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             preemption_action: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionActionArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if preemption_action is not None:
            _setter("preemption_action", preemption_action)

    @property
    @pulumi.getter(name="preemptionAction")
    def preemption_action(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionActionArgs']]:
        """
        The action to run when the preemptible instance is interrupted for eviction.
        """
        return pulumi.get(self, "preemption_action")

    @preemption_action.setter
    def preemption_action(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionActionArgs']]):
        pulumi.set(self, "preemption_action", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 preserve_boot_volume: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] type: The type of action to run when the instance is interrupted for eviction.
        :param pulumi.Input[bool] preserve_boot_volume: Whether to preserve the boot volume that was used to launch the preemptible instance when the instance is terminated. Defaults to false if not specified.
        """
        InstanceConfigurationInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            preserve_boot_volume=preserve_boot_volume,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[str],
             preserve_boot_volume: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if preserve_boot_volume is not None:
            _setter("preserve_boot_volume", preserve_boot_volume)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of action to run when the instance is interrupted for eviction.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="preserveBootVolume")
    def preserve_boot_volume(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to preserve the boot volume that was used to launch the preemptible instance when the instance is terminated. Defaults to false if not specified.
        """
        return pulumi.get(self, "preserve_boot_volume")

    @preserve_boot_volume.setter
    def preserve_boot_volume(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_boot_volume", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsLaunchDetailsShapeConfigArgs:
    def __init__(__self__, *,
                 baseline_ocpu_utilization: Optional[pulumi.Input[str]] = None,
                 memory_in_gbs: Optional[pulumi.Input[float]] = None,
                 nvmes: Optional[pulumi.Input[int]] = None,
                 ocpus: Optional[pulumi.Input[float]] = None,
                 vcpus: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] baseline_ocpu_utilization: The baseline OCPU utilization for a subcore burstable VM instance. Leave this attribute blank for a non-burstable instance, or explicitly specify non-burstable with `BASELINE_1_1`.
               
               The following values are supported:
        :param pulumi.Input[float] memory_in_gbs: The total amount of memory available to the instance, in gigabytes.
        :param pulumi.Input[int] nvmes: The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        :param pulumi.Input[float] ocpus: The total number of OCPUs available to the instance.
        :param pulumi.Input[int] vcpus: The total number of VCPUs available to the instance. This can be used instead of OCPUs, in which case the actual number of OCPUs will be calculated based on this value and the actual hardware. This must be a multiple of 2.
        """
        InstanceConfigurationInstanceDetailsLaunchDetailsShapeConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            baseline_ocpu_utilization=baseline_ocpu_utilization,
            memory_in_gbs=memory_in_gbs,
            nvmes=nvmes,
            ocpus=ocpus,
            vcpus=vcpus,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             baseline_ocpu_utilization: Optional[pulumi.Input[str]] = None,
             memory_in_gbs: Optional[pulumi.Input[float]] = None,
             nvmes: Optional[pulumi.Input[int]] = None,
             ocpus: Optional[pulumi.Input[float]] = None,
             vcpus: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if baseline_ocpu_utilization is not None:
            _setter("baseline_ocpu_utilization", baseline_ocpu_utilization)
        if memory_in_gbs is not None:
            _setter("memory_in_gbs", memory_in_gbs)
        if nvmes is not None:
            _setter("nvmes", nvmes)
        if ocpus is not None:
            _setter("ocpus", ocpus)
        if vcpus is not None:
            _setter("vcpus", vcpus)

    @property
    @pulumi.getter(name="baselineOcpuUtilization")
    def baseline_ocpu_utilization(self) -> Optional[pulumi.Input[str]]:
        """
        The baseline OCPU utilization for a subcore burstable VM instance. Leave this attribute blank for a non-burstable instance, or explicitly specify non-burstable with `BASELINE_1_1`.

        The following values are supported:
        """
        return pulumi.get(self, "baseline_ocpu_utilization")

    @baseline_ocpu_utilization.setter
    def baseline_ocpu_utilization(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "baseline_ocpu_utilization", value)

    @property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[pulumi.Input[float]]:
        """
        The total amount of memory available to the instance, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_in_gbs", value)

    @property
    @pulumi.getter
    def nvmes(self) -> Optional[pulumi.Input[int]]:
        """
        The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        """
        return pulumi.get(self, "nvmes")

    @nvmes.setter
    def nvmes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nvmes", value)

    @property
    @pulumi.getter
    def ocpus(self) -> Optional[pulumi.Input[float]]:
        """
        The total number of OCPUs available to the instance.
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "ocpus", value)

    @property
    @pulumi.getter
    def vcpus(self) -> Optional[pulumi.Input[int]]:
        """
        The total number of VCPUs available to the instance. This can be used instead of OCPUs, in which case the actual number of OCPUs will be calculated based on this value and the actual hardware. This must be a multiple of 2.
        """
        return pulumi.get(self, "vcpus")

    @vcpus.setter
    def vcpus(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vcpus", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsLaunchDetailsSourceDetailsArgs:
    def __init__(__self__, *,
                 source_type: pulumi.Input[str],
                 boot_volume_id: Optional[pulumi.Input[str]] = None,
                 boot_volume_size_in_gbs: Optional[pulumi.Input[str]] = None,
                 boot_volume_vpus_per_gb: Optional[pulumi.Input[str]] = None,
                 image_id: Optional[pulumi.Input[str]] = None,
                 instance_source_image_filter_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsSourceDetailsInstanceSourceImageFilterDetailsArgs']] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] source_type: The source type for the instance. Use `image` when specifying the image OCID. Use `bootVolume` when specifying the boot volume OCID.
        :param pulumi.Input[str] boot_volume_id: The OCID of the boot volume used to boot the instance.
        :param pulumi.Input[str] boot_volume_size_in_gbs: The size of the boot volume in GBs. The minimum value is 50 GB and the maximum value is 32,768 GB (32 TB).
        :param pulumi.Input[str] boot_volume_vpus_per_gb: The number of volume performance units (VPUs) that will be applied to this volume per GB, representing the Block Volume service's elastic performance options. See [Block Volume Performance Levels](https://docs.cloud.oracle.com/iaas/Content/Block/Concepts/blockvolumeperformance.htm#perf_levels) for more information.
               
               Allowed values:
        :param pulumi.Input[str] image_id: The OCID of the image used to boot the instance.
        :param pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsSourceDetailsInstanceSourceImageFilterDetailsArgs'] instance_source_image_filter_details: These are the criteria for selecting an image. This is required if imageId is not specified.
        :param pulumi.Input[str] kms_key_id: The OCID of the Vault service key to assign as the master encryption key for the volume.
        """
        InstanceConfigurationInstanceDetailsLaunchDetailsSourceDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_type=source_type,
            boot_volume_id=boot_volume_id,
            boot_volume_size_in_gbs=boot_volume_size_in_gbs,
            boot_volume_vpus_per_gb=boot_volume_vpus_per_gb,
            image_id=image_id,
            instance_source_image_filter_details=instance_source_image_filter_details,
            kms_key_id=kms_key_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_type: pulumi.Input[str],
             boot_volume_id: Optional[pulumi.Input[str]] = None,
             boot_volume_size_in_gbs: Optional[pulumi.Input[str]] = None,
             boot_volume_vpus_per_gb: Optional[pulumi.Input[str]] = None,
             image_id: Optional[pulumi.Input[str]] = None,
             instance_source_image_filter_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsSourceDetailsInstanceSourceImageFilterDetailsArgs']] = None,
             kms_key_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("source_type", source_type)
        if boot_volume_id is not None:
            _setter("boot_volume_id", boot_volume_id)
        if boot_volume_size_in_gbs is not None:
            _setter("boot_volume_size_in_gbs", boot_volume_size_in_gbs)
        if boot_volume_vpus_per_gb is not None:
            _setter("boot_volume_vpus_per_gb", boot_volume_vpus_per_gb)
        if image_id is not None:
            _setter("image_id", image_id)
        if instance_source_image_filter_details is not None:
            _setter("instance_source_image_filter_details", instance_source_image_filter_details)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[str]:
        """
        The source type for the instance. Use `image` when specifying the image OCID. Use `bootVolume` when specifying the boot volume OCID.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_type", value)

    @property
    @pulumi.getter(name="bootVolumeId")
    def boot_volume_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the boot volume used to boot the instance.
        """
        return pulumi.get(self, "boot_volume_id")

    @boot_volume_id.setter
    def boot_volume_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "boot_volume_id", value)

    @property
    @pulumi.getter(name="bootVolumeSizeInGbs")
    def boot_volume_size_in_gbs(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the boot volume in GBs. The minimum value is 50 GB and the maximum value is 32,768 GB (32 TB).
        """
        return pulumi.get(self, "boot_volume_size_in_gbs")

    @boot_volume_size_in_gbs.setter
    def boot_volume_size_in_gbs(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "boot_volume_size_in_gbs", value)

    @property
    @pulumi.getter(name="bootVolumeVpusPerGb")
    def boot_volume_vpus_per_gb(self) -> Optional[pulumi.Input[str]]:
        """
        The number of volume performance units (VPUs) that will be applied to this volume per GB, representing the Block Volume service's elastic performance options. See [Block Volume Performance Levels](https://docs.cloud.oracle.com/iaas/Content/Block/Concepts/blockvolumeperformance.htm#perf_levels) for more information.

        Allowed values:
        """
        return pulumi.get(self, "boot_volume_vpus_per_gb")

    @boot_volume_vpus_per_gb.setter
    def boot_volume_vpus_per_gb(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "boot_volume_vpus_per_gb", value)

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the image used to boot the instance.
        """
        return pulumi.get(self, "image_id")

    @image_id.setter
    def image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_id", value)

    @property
    @pulumi.getter(name="instanceSourceImageFilterDetails")
    def instance_source_image_filter_details(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsSourceDetailsInstanceSourceImageFilterDetailsArgs']]:
        """
        These are the criteria for selecting an image. This is required if imageId is not specified.
        """
        return pulumi.get(self, "instance_source_image_filter_details")

    @instance_source_image_filter_details.setter
    def instance_source_image_filter_details(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsLaunchDetailsSourceDetailsInstanceSourceImageFilterDetailsArgs']]):
        pulumi.set(self, "instance_source_image_filter_details", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the Vault service key to assign as the master encryption key for the volume.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsLaunchDetailsSourceDetailsInstanceSourceImageFilterDetailsArgs:
    def __init__(__self__, *,
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 defined_tags_filter: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 operating_system: Optional[pulumi.Input[str]] = None,
                 operating_system_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compartment_id: (Updatable) The OCID of the compartment containing images to search
        :param pulumi.Input[Mapping[str, Any]] defined_tags_filter: Filter based on these defined tags. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param pulumi.Input[str] operating_system: The image's operating system.  Example: `Oracle Linux`
        :param pulumi.Input[str] operating_system_version: The image's operating system version.  Example: `7.2`
        """
        InstanceConfigurationInstanceDetailsLaunchDetailsSourceDetailsInstanceSourceImageFilterDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            defined_tags_filter=defined_tags_filter,
            operating_system=operating_system,
            operating_system_version=operating_system_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: Optional[pulumi.Input[str]] = None,
             defined_tags_filter: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             operating_system: Optional[pulumi.Input[str]] = None,
             operating_system_version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if compartment_id is not None:
            _setter("compartment_id", compartment_id)
        if defined_tags_filter is not None:
            _setter("defined_tags_filter", defined_tags_filter)
        if operating_system is not None:
            _setter("operating_system", operating_system)
        if operating_system_version is not None:
            _setter("operating_system_version", operating_system_version)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the compartment containing images to search
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter(name="definedTagsFilter")
    def defined_tags_filter(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Filter based on these defined tags. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags_filter")

    @defined_tags_filter.setter
    def defined_tags_filter(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags_filter", value)

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> Optional[pulumi.Input[str]]:
        """
        The image's operating system.  Example: `Oracle Linux`
        """
        return pulumi.get(self, "operating_system")

    @operating_system.setter
    def operating_system(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operating_system", value)

    @property
    @pulumi.getter(name="operatingSystemVersion")
    def operating_system_version(self) -> Optional[pulumi.Input[str]]:
        """
        The image's operating system version.  Example: `7.2`
        """
        return pulumi.get(self, "operating_system_version")

    @operating_system_version.setter
    def operating_system_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operating_system_version", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsOptionArgs:
    def __init__(__self__, *,
                 block_volumes: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionBlockVolumeArgs']]]] = None,
                 launch_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsArgs']] = None,
                 secondary_vnics: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionSecondaryVnicArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionBlockVolumeArgs']]] block_volumes: Block volume parameters.
        :param pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsArgs'] launch_details: Instance launch details for creating an instance from an instance configuration. Use the `sourceDetails` parameter to specify whether a boot volume or an image should be used to launch a new instance.
               
               See [LaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/LaunchInstanceDetails) for more information.
        :param pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionSecondaryVnicArgs']]] secondary_vnics: Secondary VNIC parameters.
        """
        InstanceConfigurationInstanceDetailsOptionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            block_volumes=block_volumes,
            launch_details=launch_details,
            secondary_vnics=secondary_vnics,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             block_volumes: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionBlockVolumeArgs']]]] = None,
             launch_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsArgs']] = None,
             secondary_vnics: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionSecondaryVnicArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if block_volumes is not None:
            _setter("block_volumes", block_volumes)
        if launch_details is not None:
            _setter("launch_details", launch_details)
        if secondary_vnics is not None:
            _setter("secondary_vnics", secondary_vnics)

    @property
    @pulumi.getter(name="blockVolumes")
    def block_volumes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionBlockVolumeArgs']]]]:
        """
        Block volume parameters.
        """
        return pulumi.get(self, "block_volumes")

    @block_volumes.setter
    def block_volumes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionBlockVolumeArgs']]]]):
        pulumi.set(self, "block_volumes", value)

    @property
    @pulumi.getter(name="launchDetails")
    def launch_details(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsArgs']]:
        """
        Instance launch details for creating an instance from an instance configuration. Use the `sourceDetails` parameter to specify whether a boot volume or an image should be used to launch a new instance.

        See [LaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/LaunchInstanceDetails) for more information.
        """
        return pulumi.get(self, "launch_details")

    @launch_details.setter
    def launch_details(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsArgs']]):
        pulumi.set(self, "launch_details", value)

    @property
    @pulumi.getter(name="secondaryVnics")
    def secondary_vnics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionSecondaryVnicArgs']]]]:
        """
        Secondary VNIC parameters.
        """
        return pulumi.get(self, "secondary_vnics")

    @secondary_vnics.setter
    def secondary_vnics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionSecondaryVnicArgs']]]]):
        pulumi.set(self, "secondary_vnics", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsOptionBlockVolumeArgs:
    def __init__(__self__, *,
                 attach_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionBlockVolumeAttachDetailsArgs']] = None,
                 create_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionBlockVolumeCreateDetailsArgs']] = None,
                 volume_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['InstanceConfigurationInstanceDetailsOptionBlockVolumeAttachDetailsArgs'] attach_details: Volume attachmentDetails. Please see [AttachVolumeDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/AttachVolumeDetails/)
        :param pulumi.Input['InstanceConfigurationInstanceDetailsOptionBlockVolumeCreateDetailsArgs'] create_details: Creates a new block volume. Please see [CreateVolumeDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVolumeDetails/)
        :param pulumi.Input[str] volume_id: The OCID of the volume.
        """
        InstanceConfigurationInstanceDetailsOptionBlockVolumeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attach_details=attach_details,
            create_details=create_details,
            volume_id=volume_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attach_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionBlockVolumeAttachDetailsArgs']] = None,
             create_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionBlockVolumeCreateDetailsArgs']] = None,
             volume_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if attach_details is not None:
            _setter("attach_details", attach_details)
        if create_details is not None:
            _setter("create_details", create_details)
        if volume_id is not None:
            _setter("volume_id", volume_id)

    @property
    @pulumi.getter(name="attachDetails")
    def attach_details(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionBlockVolumeAttachDetailsArgs']]:
        """
        Volume attachmentDetails. Please see [AttachVolumeDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/AttachVolumeDetails/)
        """
        return pulumi.get(self, "attach_details")

    @attach_details.setter
    def attach_details(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionBlockVolumeAttachDetailsArgs']]):
        pulumi.set(self, "attach_details", value)

    @property
    @pulumi.getter(name="createDetails")
    def create_details(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionBlockVolumeCreateDetailsArgs']]:
        """
        Creates a new block volume. Please see [CreateVolumeDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVolumeDetails/)
        """
        return pulumi.get(self, "create_details")

    @create_details.setter
    def create_details(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionBlockVolumeCreateDetailsArgs']]):
        pulumi.set(self, "create_details", value)

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the volume.
        """
        return pulumi.get(self, "volume_id")

    @volume_id.setter
    def volume_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_id", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsOptionBlockVolumeAttachDetailsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 device: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 is_pv_encryption_in_transit_enabled: Optional[pulumi.Input[bool]] = None,
                 is_read_only: Optional[pulumi.Input[bool]] = None,
                 is_shareable: Optional[pulumi.Input[bool]] = None,
                 use_chap: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] type: The type of action to run when the instance is interrupted for eviction.
        :param pulumi.Input[str] device: The device name.
        :param pulumi.Input[str] display_name: A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        :param pulumi.Input[bool] is_pv_encryption_in_transit_enabled: Deprecated. Instead use `isPvEncryptionInTransitEnabled` in [InstanceConfigurationLaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/datatypes/InstanceConfigurationLaunchInstanceDetails).
        :param pulumi.Input[bool] is_read_only: Whether the attachment should be created in read-only mode.
        :param pulumi.Input[bool] is_shareable: Whether the attachment should be created in shareable mode. If an attachment is created in shareable mode, then other instances can attach the same volume, provided that they also create their attachments in shareable mode. Only certain volume types can be attached in shareable mode. Defaults to false if not specified.
        :param pulumi.Input[bool] use_chap: Whether to use CHAP authentication for the volume attachment. Defaults to false.
        """
        InstanceConfigurationInstanceDetailsOptionBlockVolumeAttachDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            device=device,
            display_name=display_name,
            is_pv_encryption_in_transit_enabled=is_pv_encryption_in_transit_enabled,
            is_read_only=is_read_only,
            is_shareable=is_shareable,
            use_chap=use_chap,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[str],
             device: Optional[pulumi.Input[str]] = None,
             display_name: Optional[pulumi.Input[str]] = None,
             is_pv_encryption_in_transit_enabled: Optional[pulumi.Input[bool]] = None,
             is_read_only: Optional[pulumi.Input[bool]] = None,
             is_shareable: Optional[pulumi.Input[bool]] = None,
             use_chap: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if device is not None:
            _setter("device", device)
        if display_name is not None:
            _setter("display_name", display_name)
        if is_pv_encryption_in_transit_enabled is not None:
            _setter("is_pv_encryption_in_transit_enabled", is_pv_encryption_in_transit_enabled)
        if is_read_only is not None:
            _setter("is_read_only", is_read_only)
        if is_shareable is not None:
            _setter("is_shareable", is_shareable)
        if use_chap is not None:
            _setter("use_chap", use_chap)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of action to run when the instance is interrupted for eviction.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def device(self) -> Optional[pulumi.Input[str]]:
        """
        The device name.
        """
        return pulumi.get(self, "device")

    @device.setter
    def device(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="isPvEncryptionInTransitEnabled")
    def is_pv_encryption_in_transit_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Deprecated. Instead use `isPvEncryptionInTransitEnabled` in [InstanceConfigurationLaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/datatypes/InstanceConfigurationLaunchInstanceDetails).
        """
        return pulumi.get(self, "is_pv_encryption_in_transit_enabled")

    @is_pv_encryption_in_transit_enabled.setter
    def is_pv_encryption_in_transit_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_pv_encryption_in_transit_enabled", value)

    @property
    @pulumi.getter(name="isReadOnly")
    def is_read_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the attachment should be created in read-only mode.
        """
        return pulumi.get(self, "is_read_only")

    @is_read_only.setter
    def is_read_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_read_only", value)

    @property
    @pulumi.getter(name="isShareable")
    def is_shareable(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the attachment should be created in shareable mode. If an attachment is created in shareable mode, then other instances can attach the same volume, provided that they also create their attachments in shareable mode. Only certain volume types can be attached in shareable mode. Defaults to false if not specified.
        """
        return pulumi.get(self, "is_shareable")

    @is_shareable.setter
    def is_shareable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_shareable", value)

    @property
    @pulumi.getter(name="useChap")
    def use_chap(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to use CHAP authentication for the volume attachment. Defaults to false.
        """
        return pulumi.get(self, "use_chap")

    @use_chap.setter
    def use_chap(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_chap", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsOptionBlockVolumeCreateDetailsArgs:
    def __init__(__self__, *,
                 autotune_policies: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionBlockVolumeCreateDetailsAutotunePolicyArgs']]]] = None,
                 availability_domain: Optional[pulumi.Input[str]] = None,
                 backup_policy_id: Optional[pulumi.Input[str]] = None,
                 block_volume_replicas: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionBlockVolumeCreateDetailsBlockVolumeReplicasArgs']] = None,
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 is_auto_tune_enabled: Optional[pulumi.Input[bool]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 size_in_gbs: Optional[pulumi.Input[str]] = None,
                 source_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionBlockVolumeCreateDetailsSourceDetailsArgs']] = None,
                 vpus_per_gb: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionBlockVolumeCreateDetailsAutotunePolicyArgs']]] autotune_policies: The list of autotune policies enabled for this volume.
        :param pulumi.Input[str] availability_domain: The availability domain of the instance.  Example: `Uocm:PHX-AD-1`
        :param pulumi.Input[str] backup_policy_id: If provided, specifies the ID of the volume backup policy to assign to the newly created volume. If omitted, no policy will be assigned.
        :param pulumi.Input['InstanceConfigurationInstanceDetailsOptionBlockVolumeCreateDetailsBlockVolumeReplicasArgs'] block_volume_replicas: The list of block volume replicas to be enabled for this volume in the specified destination availability domains.
        :param pulumi.Input[str] compartment_id: (Updatable) The OCID of the compartment containing images to search
        :param pulumi.Input[Mapping[str, Any]] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        :param pulumi.Input[str] display_name: A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        :param pulumi.Input[Mapping[str, Any]] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param pulumi.Input[bool] is_auto_tune_enabled: Specifies whether the auto-tune performance is enabled for this boot volume. This field is deprecated. Use the `InstanceConfigurationDetachedVolumeAutotunePolicy` instead to enable the volume for detached autotune.
        :param pulumi.Input[str] kms_key_id: The OCID of the Vault service key to assign as the master encryption key for the volume.
        :param pulumi.Input[str] size_in_gbs: The size of the volume in GBs.
        :param pulumi.Input[str] vpus_per_gb: The number of volume performance units (VPUs) that will be applied to this volume per GB, representing the Block Volume service's elastic performance options. See [Block Volume Performance Levels](https://docs.cloud.oracle.com/iaas/Content/Block/Concepts/blockvolumeperformance.htm#perf_levels) for more information.
               
               Allowed values:
        """
        InstanceConfigurationInstanceDetailsOptionBlockVolumeCreateDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autotune_policies=autotune_policies,
            availability_domain=availability_domain,
            backup_policy_id=backup_policy_id,
            block_volume_replicas=block_volume_replicas,
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            display_name=display_name,
            freeform_tags=freeform_tags,
            is_auto_tune_enabled=is_auto_tune_enabled,
            kms_key_id=kms_key_id,
            size_in_gbs=size_in_gbs,
            source_details=source_details,
            vpus_per_gb=vpus_per_gb,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autotune_policies: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionBlockVolumeCreateDetailsAutotunePolicyArgs']]]] = None,
             availability_domain: Optional[pulumi.Input[str]] = None,
             backup_policy_id: Optional[pulumi.Input[str]] = None,
             block_volume_replicas: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionBlockVolumeCreateDetailsBlockVolumeReplicasArgs']] = None,
             compartment_id: Optional[pulumi.Input[str]] = None,
             defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             display_name: Optional[pulumi.Input[str]] = None,
             freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             is_auto_tune_enabled: Optional[pulumi.Input[bool]] = None,
             kms_key_id: Optional[pulumi.Input[str]] = None,
             size_in_gbs: Optional[pulumi.Input[str]] = None,
             source_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionBlockVolumeCreateDetailsSourceDetailsArgs']] = None,
             vpus_per_gb: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if autotune_policies is not None:
            _setter("autotune_policies", autotune_policies)
        if availability_domain is not None:
            _setter("availability_domain", availability_domain)
        if backup_policy_id is not None:
            _setter("backup_policy_id", backup_policy_id)
        if block_volume_replicas is not None:
            _setter("block_volume_replicas", block_volume_replicas)
        if compartment_id is not None:
            _setter("compartment_id", compartment_id)
        if defined_tags is not None:
            _setter("defined_tags", defined_tags)
        if display_name is not None:
            _setter("display_name", display_name)
        if freeform_tags is not None:
            _setter("freeform_tags", freeform_tags)
        if is_auto_tune_enabled is not None:
            _setter("is_auto_tune_enabled", is_auto_tune_enabled)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)
        if size_in_gbs is not None:
            _setter("size_in_gbs", size_in_gbs)
        if source_details is not None:
            _setter("source_details", source_details)
        if vpus_per_gb is not None:
            _setter("vpus_per_gb", vpus_per_gb)

    @property
    @pulumi.getter(name="autotunePolicies")
    def autotune_policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionBlockVolumeCreateDetailsAutotunePolicyArgs']]]]:
        """
        The list of autotune policies enabled for this volume.
        """
        return pulumi.get(self, "autotune_policies")

    @autotune_policies.setter
    def autotune_policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionBlockVolumeCreateDetailsAutotunePolicyArgs']]]]):
        pulumi.set(self, "autotune_policies", value)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[pulumi.Input[str]]:
        """
        The availability domain of the instance.  Example: `Uocm:PHX-AD-1`
        """
        return pulumi.get(self, "availability_domain")

    @availability_domain.setter
    def availability_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_domain", value)

    @property
    @pulumi.getter(name="backupPolicyId")
    def backup_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        If provided, specifies the ID of the volume backup policy to assign to the newly created volume. If omitted, no policy will be assigned.
        """
        return pulumi.get(self, "backup_policy_id")

    @backup_policy_id.setter
    def backup_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_policy_id", value)

    @property
    @pulumi.getter(name="blockVolumeReplicas")
    def block_volume_replicas(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionBlockVolumeCreateDetailsBlockVolumeReplicasArgs']]:
        """
        The list of block volume replicas to be enabled for this volume in the specified destination availability domains.
        """
        return pulumi.get(self, "block_volume_replicas")

    @block_volume_replicas.setter
    def block_volume_replicas(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionBlockVolumeCreateDetailsBlockVolumeReplicasArgs']]):
        pulumi.set(self, "block_volume_replicas", value)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the compartment containing images to search
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter(name="isAutoTuneEnabled")
    def is_auto_tune_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the auto-tune performance is enabled for this boot volume. This field is deprecated. Use the `InstanceConfigurationDetachedVolumeAutotunePolicy` instead to enable the volume for detached autotune.
        """
        return pulumi.get(self, "is_auto_tune_enabled")

    @is_auto_tune_enabled.setter
    def is_auto_tune_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_auto_tune_enabled", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the Vault service key to assign as the master encryption key for the volume.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="sizeInGbs")
    def size_in_gbs(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the volume in GBs.
        """
        return pulumi.get(self, "size_in_gbs")

    @size_in_gbs.setter
    def size_in_gbs(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size_in_gbs", value)

    @property
    @pulumi.getter(name="sourceDetails")
    def source_details(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionBlockVolumeCreateDetailsSourceDetailsArgs']]:
        return pulumi.get(self, "source_details")

    @source_details.setter
    def source_details(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionBlockVolumeCreateDetailsSourceDetailsArgs']]):
        pulumi.set(self, "source_details", value)

    @property
    @pulumi.getter(name="vpusPerGb")
    def vpus_per_gb(self) -> Optional[pulumi.Input[str]]:
        """
        The number of volume performance units (VPUs) that will be applied to this volume per GB, representing the Block Volume service's elastic performance options. See [Block Volume Performance Levels](https://docs.cloud.oracle.com/iaas/Content/Block/Concepts/blockvolumeperformance.htm#perf_levels) for more information.

        Allowed values:
        """
        return pulumi.get(self, "vpus_per_gb")

    @vpus_per_gb.setter
    def vpus_per_gb(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpus_per_gb", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsOptionBlockVolumeCreateDetailsAutotunePolicyArgs:
    def __init__(__self__, *,
                 autotune_type: pulumi.Input[str],
                 max_vpus_per_gb: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] autotune_type: This specifies the type of autotunes supported by OCI.
        :param pulumi.Input[str] max_vpus_per_gb: This will be the maximum VPUs/GB performance level that the volume will be auto-tuned temporarily based on performance monitoring.
        """
        InstanceConfigurationInstanceDetailsOptionBlockVolumeCreateDetailsAutotunePolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autotune_type=autotune_type,
            max_vpus_per_gb=max_vpus_per_gb,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autotune_type: pulumi.Input[str],
             max_vpus_per_gb: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("autotune_type", autotune_type)
        if max_vpus_per_gb is not None:
            _setter("max_vpus_per_gb", max_vpus_per_gb)

    @property
    @pulumi.getter(name="autotuneType")
    def autotune_type(self) -> pulumi.Input[str]:
        """
        This specifies the type of autotunes supported by OCI.
        """
        return pulumi.get(self, "autotune_type")

    @autotune_type.setter
    def autotune_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "autotune_type", value)

    @property
    @pulumi.getter(name="maxVpusPerGb")
    def max_vpus_per_gb(self) -> Optional[pulumi.Input[str]]:
        """
        This will be the maximum VPUs/GB performance level that the volume will be auto-tuned temporarily based on performance monitoring.
        """
        return pulumi.get(self, "max_vpus_per_gb")

    @max_vpus_per_gb.setter
    def max_vpus_per_gb(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_vpus_per_gb", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsOptionBlockVolumeCreateDetailsBlockVolumeReplicasArgs:
    def __init__(__self__, *,
                 availability_domain: pulumi.Input[str],
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] availability_domain: The availability domain of the instance.  Example: `Uocm:PHX-AD-1`
        :param pulumi.Input[str] display_name: A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        """
        InstanceConfigurationInstanceDetailsOptionBlockVolumeCreateDetailsBlockVolumeReplicasArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_domain=availability_domain,
            display_name=display_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_domain: pulumi.Input[str],
             display_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("availability_domain", availability_domain)
        if display_name is not None:
            _setter("display_name", display_name)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> pulumi.Input[str]:
        """
        The availability domain of the instance.  Example: `Uocm:PHX-AD-1`
        """
        return pulumi.get(self, "availability_domain")

    @availability_domain.setter
    def availability_domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "availability_domain", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsOptionBlockVolumeCreateDetailsSourceDetailsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of action to run when the instance is interrupted for eviction.
        :param pulumi.Input[str] id: The OCID of the volume backup.
        """
        InstanceConfigurationInstanceDetailsOptionBlockVolumeCreateDetailsSourceDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[str],
             id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of action to run when the instance is interrupted for eviction.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the volume backup.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsOptionLaunchDetailsArgs:
    def __init__(__self__, *,
                 agent_config: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsAgentConfigArgs']] = None,
                 availability_config: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsAvailabilityConfigArgs']] = None,
                 availability_domain: Optional[pulumi.Input[str]] = None,
                 capacity_reservation_id: Optional[pulumi.Input[str]] = None,
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 create_vnic_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsCreateVnicDetailsArgs']] = None,
                 dedicated_vm_host_id: Optional[pulumi.Input[str]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 extended_metadata: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 fault_domain: Optional[pulumi.Input[str]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 instance_options: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsInstanceOptionsArgs']] = None,
                 ipxe_script: Optional[pulumi.Input[str]] = None,
                 is_pv_encryption_in_transit_enabled: Optional[pulumi.Input[bool]] = None,
                 launch_mode: Optional[pulumi.Input[str]] = None,
                 launch_options: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsLaunchOptionsArgs']] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 platform_config: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsPlatformConfigArgs']] = None,
                 preemptible_instance_config: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsPreemptibleInstanceConfigArgs']] = None,
                 preferred_maintenance_action: Optional[pulumi.Input[str]] = None,
                 shape: Optional[pulumi.Input[str]] = None,
                 shape_config: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsShapeConfigArgs']] = None,
                 source_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsSourceDetailsArgs']] = None):
        """
        :param pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsAgentConfigArgs'] agent_config: Configuration options for the Oracle Cloud Agent software running on the instance.
        :param pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsAvailabilityConfigArgs'] availability_config: Options for defining the availabiity of a VM instance after a maintenance event that impacts the underlying hardware.
        :param pulumi.Input[str] availability_domain: The availability domain of the instance.  Example: `Uocm:PHX-AD-1`
        :param pulumi.Input[str] capacity_reservation_id: The OCID of the compute capacity reservation this instance is launched under.
        :param pulumi.Input[str] compartment_id: (Updatable) The OCID of the compartment containing images to search
        :param pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsCreateVnicDetailsArgs'] create_vnic_details: Contains the properties of the VNIC for an instance configuration. See [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) and [Instance Configurations](https://docs.cloud.oracle.com/iaas/Content/Compute/Concepts/instancemanagement.htm#config) for more information.
        :param pulumi.Input[str] dedicated_vm_host_id: The OCID of the dedicated virtual machine host to place the instance on.
               
               Dedicated VM hosts can be used when launching individual instances from an instance configuration. They cannot be used to launch instance pools.
        :param pulumi.Input[Mapping[str, Any]] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        :param pulumi.Input[str] display_name: A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        :param pulumi.Input[Mapping[str, Any]] extended_metadata: Additional metadata key/value pairs that you provide. They serve the same purpose and functionality as fields in the `metadata` object.
               
               They are distinguished from `metadata` fields in that these can be nested JSON objects (whereas `metadata` fields are string/string maps only).
               
               The combined size of the `metadata` and `extendedMetadata` objects can be a maximum of 32,000 bytes.
        :param pulumi.Input[str] fault_domain: A fault domain is a grouping of hardware and infrastructure within an availability domain. Each availability domain contains three fault domains. Fault domains let you distribute your instances so that they are not on the same physical hardware within a single availability domain. A hardware failure or Compute hardware maintenance that affects one fault domain does not affect instances in other fault domains.
               
               If you do not specify the fault domain, the system selects one for you.
               
               To get a list of fault domains, use the [ListFaultDomains](https://docs.cloud.oracle.com/iaas/api/#/en/identity/20160918/FaultDomain/ListFaultDomains) operation in the Identity and Access Management Service API.
               
               Example: `FAULT-DOMAIN-1`
        :param pulumi.Input[Mapping[str, Any]] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsInstanceOptionsArgs'] instance_options: Optional mutable instance options. As a part of Instance Metadata Service Security Header, This allows user to disable the legacy imds endpoints.
        :param pulumi.Input[str] ipxe_script: This is an advanced option.
               
               When a bare metal or virtual machine instance boots, the iPXE firmware that runs on the instance is configured to run an iPXE script to continue the boot process.
               
               If you want more control over the boot process, you can provide your own custom iPXE script that will run when the instance boots; however, you should be aware that the same iPXE script will run every time an instance boots; not only after the initial LaunchInstance call.
               
               The default iPXE script connects to the instance's local boot volume over iSCSI and performs a network boot. If you use a custom iPXE script and want to network-boot from the instance's local boot volume over iSCSI the same way as the default iPXE script, you should use the following iSCSI IP address: 169.254.0.2, and boot volume IQN: iqn.2015-02.oracle.boot.
               
               For more information about the Bring Your Own Image feature of Oracle Cloud Infrastructure, see [Bring Your Own Image](https://docs.cloud.oracle.com/iaas/Content/Compute/References/bringyourownimage.htm).
               
               For more information about iPXE, see http://ipxe.org.
        :param pulumi.Input[bool] is_pv_encryption_in_transit_enabled: Deprecated. Instead use `isPvEncryptionInTransitEnabled` in [InstanceConfigurationLaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/datatypes/InstanceConfigurationLaunchInstanceDetails).
        :param pulumi.Input[str] launch_mode: Specifies the configuration mode for launching virtual machine (VM) instances. The configuration modes are:
        :param pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsLaunchOptionsArgs'] launch_options: Options for tuning the compatibility and performance of VM shapes. The values that you specify override any default values.
        :param pulumi.Input[Mapping[str, Any]] metadata: Custom metadata key/value pairs that you provide, such as the SSH public key required to connect to the instance.
               
               A metadata service runs on every launched instance. The service is an HTTP endpoint listening on 169.254.169.254. You can use the service to:
               * Provide information to [Cloud-Init](https://cloudinit.readthedocs.org/en/latest/) to be used for various system initialization tasks.
               * Get information about the instance, including the custom metadata that you provide when you launch the instance.
               
               **Providing Cloud-Init Metadata**
               
               You can use the following metadata key names to provide information to Cloud-Init:
               
               **"ssh_authorized_keys"** - Provide one or more public SSH keys to be included in the `~/.ssh/authorized_keys` file for the default user on the instance. Use a newline character to separate multiple keys. The SSH keys must be in the format necessary for the `authorized_keys` file, as shown in the example below.
               
               **"user_data"** - Provide your own base64-encoded data to be used by Cloud-Init to run custom scripts or provide custom Cloud-Init configuration. For information about how to take advantage of user data, see the [Cloud-Init Documentation](http://cloudinit.readthedocs.org/en/latest/topics/format.html).
               
               **Metadata Example**
               
               "metadata" : { "quake_bot_level" : "Severe", "ssh_authorized_keys" : "ssh-rsa <your_public_SSH_key>== rsa-key-20160227", "user_data" : "<your_public_SSH_key>==" } **Getting Metadata on the Instance**
               
               To get information about your instance, connect to the instance using SSH and issue any of the following GET requests:
               
               curl -H "Authorization: Bearer Oracle" http://169.254.169.254/opc/v2/instance/ curl -H "Authorization: Bearer Oracle" http://169.254.169.254/opc/v2/instance/metadata/ curl -H "Authorization: Bearer Oracle" http://169.254.169.254/opc/v2/instance/metadata/<any-key-name>
               
               You'll get back a response that includes all the instance information; only the metadata information; or the metadata information for the specified key name, respectively.
               
               The combined size of the `metadata` and `extendedMetadata` objects can be a maximum of 32,000 bytes.
        :param pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsPlatformConfigArgs'] platform_config: The platform configuration requested for the instance.
               
               If you provide the parameter, the instance is created with the platform configuration that you specify. For any values that you omit, the instance uses the default configuration values for the `shape` that you specify. If you don't provide the parameter, the default values for the `shape` are used.
               
               Each shape only supports certain configurable values. If the values that you provide are not valid for the specified `shape`, an error is returned.
        :param pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsPreemptibleInstanceConfigArgs'] preemptible_instance_config: Configuration options for preemptible instances.
        :param pulumi.Input[str] preferred_maintenance_action: The preferred maintenance action for an instance. The default is LIVE_MIGRATE, if live migration is supported.
        :param pulumi.Input[str] shape: The shape of an instance. The shape determines the number of CPUs, amount of memory, and other resources allocated to the instance.
               
               You can enumerate all available shapes by calling [ListShapes](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Shape/ListShapes).
        :param pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsShapeConfigArgs'] shape_config: The shape configuration requested for the instance.
               
               If the parameter is provided, the instance is created with the resources that you specify. If some properties are missing or the entire parameter is not provided, the instance is created with the default configuration values for the `shape` that you specify.
               
               Each shape only supports certain configurable values. If the values that you provide are not valid for the specified `shape`, an error is returned.
        """
        InstanceConfigurationInstanceDetailsOptionLaunchDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            agent_config=agent_config,
            availability_config=availability_config,
            availability_domain=availability_domain,
            capacity_reservation_id=capacity_reservation_id,
            compartment_id=compartment_id,
            create_vnic_details=create_vnic_details,
            dedicated_vm_host_id=dedicated_vm_host_id,
            defined_tags=defined_tags,
            display_name=display_name,
            extended_metadata=extended_metadata,
            fault_domain=fault_domain,
            freeform_tags=freeform_tags,
            instance_options=instance_options,
            ipxe_script=ipxe_script,
            is_pv_encryption_in_transit_enabled=is_pv_encryption_in_transit_enabled,
            launch_mode=launch_mode,
            launch_options=launch_options,
            metadata=metadata,
            platform_config=platform_config,
            preemptible_instance_config=preemptible_instance_config,
            preferred_maintenance_action=preferred_maintenance_action,
            shape=shape,
            shape_config=shape_config,
            source_details=source_details,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             agent_config: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsAgentConfigArgs']] = None,
             availability_config: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsAvailabilityConfigArgs']] = None,
             availability_domain: Optional[pulumi.Input[str]] = None,
             capacity_reservation_id: Optional[pulumi.Input[str]] = None,
             compartment_id: Optional[pulumi.Input[str]] = None,
             create_vnic_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsCreateVnicDetailsArgs']] = None,
             dedicated_vm_host_id: Optional[pulumi.Input[str]] = None,
             defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             display_name: Optional[pulumi.Input[str]] = None,
             extended_metadata: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             fault_domain: Optional[pulumi.Input[str]] = None,
             freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             instance_options: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsInstanceOptionsArgs']] = None,
             ipxe_script: Optional[pulumi.Input[str]] = None,
             is_pv_encryption_in_transit_enabled: Optional[pulumi.Input[bool]] = None,
             launch_mode: Optional[pulumi.Input[str]] = None,
             launch_options: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsLaunchOptionsArgs']] = None,
             metadata: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             platform_config: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsPlatformConfigArgs']] = None,
             preemptible_instance_config: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsPreemptibleInstanceConfigArgs']] = None,
             preferred_maintenance_action: Optional[pulumi.Input[str]] = None,
             shape: Optional[pulumi.Input[str]] = None,
             shape_config: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsShapeConfigArgs']] = None,
             source_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsSourceDetailsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if agent_config is not None:
            _setter("agent_config", agent_config)
        if availability_config is not None:
            _setter("availability_config", availability_config)
        if availability_domain is not None:
            _setter("availability_domain", availability_domain)
        if capacity_reservation_id is not None:
            _setter("capacity_reservation_id", capacity_reservation_id)
        if compartment_id is not None:
            _setter("compartment_id", compartment_id)
        if create_vnic_details is not None:
            _setter("create_vnic_details", create_vnic_details)
        if dedicated_vm_host_id is not None:
            _setter("dedicated_vm_host_id", dedicated_vm_host_id)
        if defined_tags is not None:
            _setter("defined_tags", defined_tags)
        if display_name is not None:
            _setter("display_name", display_name)
        if extended_metadata is not None:
            _setter("extended_metadata", extended_metadata)
        if fault_domain is not None:
            _setter("fault_domain", fault_domain)
        if freeform_tags is not None:
            _setter("freeform_tags", freeform_tags)
        if instance_options is not None:
            _setter("instance_options", instance_options)
        if ipxe_script is not None:
            _setter("ipxe_script", ipxe_script)
        if is_pv_encryption_in_transit_enabled is not None:
            _setter("is_pv_encryption_in_transit_enabled", is_pv_encryption_in_transit_enabled)
        if launch_mode is not None:
            _setter("launch_mode", launch_mode)
        if launch_options is not None:
            _setter("launch_options", launch_options)
        if metadata is not None:
            _setter("metadata", metadata)
        if platform_config is not None:
            _setter("platform_config", platform_config)
        if preemptible_instance_config is not None:
            _setter("preemptible_instance_config", preemptible_instance_config)
        if preferred_maintenance_action is not None:
            _setter("preferred_maintenance_action", preferred_maintenance_action)
        if shape is not None:
            _setter("shape", shape)
        if shape_config is not None:
            _setter("shape_config", shape_config)
        if source_details is not None:
            _setter("source_details", source_details)

    @property
    @pulumi.getter(name="agentConfig")
    def agent_config(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsAgentConfigArgs']]:
        """
        Configuration options for the Oracle Cloud Agent software running on the instance.
        """
        return pulumi.get(self, "agent_config")

    @agent_config.setter
    def agent_config(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsAgentConfigArgs']]):
        pulumi.set(self, "agent_config", value)

    @property
    @pulumi.getter(name="availabilityConfig")
    def availability_config(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsAvailabilityConfigArgs']]:
        """
        Options for defining the availabiity of a VM instance after a maintenance event that impacts the underlying hardware.
        """
        return pulumi.get(self, "availability_config")

    @availability_config.setter
    def availability_config(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsAvailabilityConfigArgs']]):
        pulumi.set(self, "availability_config", value)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[pulumi.Input[str]]:
        """
        The availability domain of the instance.  Example: `Uocm:PHX-AD-1`
        """
        return pulumi.get(self, "availability_domain")

    @availability_domain.setter
    def availability_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_domain", value)

    @property
    @pulumi.getter(name="capacityReservationId")
    def capacity_reservation_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the compute capacity reservation this instance is launched under.
        """
        return pulumi.get(self, "capacity_reservation_id")

    @capacity_reservation_id.setter
    def capacity_reservation_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "capacity_reservation_id", value)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the compartment containing images to search
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter(name="createVnicDetails")
    def create_vnic_details(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsCreateVnicDetailsArgs']]:
        """
        Contains the properties of the VNIC for an instance configuration. See [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) and [Instance Configurations](https://docs.cloud.oracle.com/iaas/Content/Compute/Concepts/instancemanagement.htm#config) for more information.
        """
        return pulumi.get(self, "create_vnic_details")

    @create_vnic_details.setter
    def create_vnic_details(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsCreateVnicDetailsArgs']]):
        pulumi.set(self, "create_vnic_details", value)

    @property
    @pulumi.getter(name="dedicatedVmHostId")
    def dedicated_vm_host_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the dedicated virtual machine host to place the instance on.

        Dedicated VM hosts can be used when launching individual instances from an instance configuration. They cannot be used to launch instance pools.
        """
        return pulumi.get(self, "dedicated_vm_host_id")

    @dedicated_vm_host_id.setter
    def dedicated_vm_host_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dedicated_vm_host_id", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="extendedMetadata")
    def extended_metadata(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Additional metadata key/value pairs that you provide. They serve the same purpose and functionality as fields in the `metadata` object.

        They are distinguished from `metadata` fields in that these can be nested JSON objects (whereas `metadata` fields are string/string maps only).

        The combined size of the `metadata` and `extendedMetadata` objects can be a maximum of 32,000 bytes.
        """
        return pulumi.get(self, "extended_metadata")

    @extended_metadata.setter
    def extended_metadata(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "extended_metadata", value)

    @property
    @pulumi.getter(name="faultDomain")
    def fault_domain(self) -> Optional[pulumi.Input[str]]:
        """
        A fault domain is a grouping of hardware and infrastructure within an availability domain. Each availability domain contains three fault domains. Fault domains let you distribute your instances so that they are not on the same physical hardware within a single availability domain. A hardware failure or Compute hardware maintenance that affects one fault domain does not affect instances in other fault domains.

        If you do not specify the fault domain, the system selects one for you.

        To get a list of fault domains, use the [ListFaultDomains](https://docs.cloud.oracle.com/iaas/api/#/en/identity/20160918/FaultDomain/ListFaultDomains) operation in the Identity and Access Management Service API.

        Example: `FAULT-DOMAIN-1`
        """
        return pulumi.get(self, "fault_domain")

    @fault_domain.setter
    def fault_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fault_domain", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter(name="instanceOptions")
    def instance_options(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsInstanceOptionsArgs']]:
        """
        Optional mutable instance options. As a part of Instance Metadata Service Security Header, This allows user to disable the legacy imds endpoints.
        """
        return pulumi.get(self, "instance_options")

    @instance_options.setter
    def instance_options(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsInstanceOptionsArgs']]):
        pulumi.set(self, "instance_options", value)

    @property
    @pulumi.getter(name="ipxeScript")
    def ipxe_script(self) -> Optional[pulumi.Input[str]]:
        """
        This is an advanced option.

        When a bare metal or virtual machine instance boots, the iPXE firmware that runs on the instance is configured to run an iPXE script to continue the boot process.

        If you want more control over the boot process, you can provide your own custom iPXE script that will run when the instance boots; however, you should be aware that the same iPXE script will run every time an instance boots; not only after the initial LaunchInstance call.

        The default iPXE script connects to the instance's local boot volume over iSCSI and performs a network boot. If you use a custom iPXE script and want to network-boot from the instance's local boot volume over iSCSI the same way as the default iPXE script, you should use the following iSCSI IP address: 169.254.0.2, and boot volume IQN: iqn.2015-02.oracle.boot.

        For more information about the Bring Your Own Image feature of Oracle Cloud Infrastructure, see [Bring Your Own Image](https://docs.cloud.oracle.com/iaas/Content/Compute/References/bringyourownimage.htm).

        For more information about iPXE, see http://ipxe.org.
        """
        return pulumi.get(self, "ipxe_script")

    @ipxe_script.setter
    def ipxe_script(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipxe_script", value)

    @property
    @pulumi.getter(name="isPvEncryptionInTransitEnabled")
    def is_pv_encryption_in_transit_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Deprecated. Instead use `isPvEncryptionInTransitEnabled` in [InstanceConfigurationLaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/datatypes/InstanceConfigurationLaunchInstanceDetails).
        """
        return pulumi.get(self, "is_pv_encryption_in_transit_enabled")

    @is_pv_encryption_in_transit_enabled.setter
    def is_pv_encryption_in_transit_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_pv_encryption_in_transit_enabled", value)

    @property
    @pulumi.getter(name="launchMode")
    def launch_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the configuration mode for launching virtual machine (VM) instances. The configuration modes are:
        """
        return pulumi.get(self, "launch_mode")

    @launch_mode.setter
    def launch_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "launch_mode", value)

    @property
    @pulumi.getter(name="launchOptions")
    def launch_options(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsLaunchOptionsArgs']]:
        """
        Options for tuning the compatibility and performance of VM shapes. The values that you specify override any default values.
        """
        return pulumi.get(self, "launch_options")

    @launch_options.setter
    def launch_options(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsLaunchOptionsArgs']]):
        pulumi.set(self, "launch_options", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Custom metadata key/value pairs that you provide, such as the SSH public key required to connect to the instance.

        A metadata service runs on every launched instance. The service is an HTTP endpoint listening on 169.254.169.254. You can use the service to:
        * Provide information to [Cloud-Init](https://cloudinit.readthedocs.org/en/latest/) to be used for various system initialization tasks.
        * Get information about the instance, including the custom metadata that you provide when you launch the instance.

        **Providing Cloud-Init Metadata**

        You can use the following metadata key names to provide information to Cloud-Init:

        **"ssh_authorized_keys"** - Provide one or more public SSH keys to be included in the `~/.ssh/authorized_keys` file for the default user on the instance. Use a newline character to separate multiple keys. The SSH keys must be in the format necessary for the `authorized_keys` file, as shown in the example below.

        **"user_data"** - Provide your own base64-encoded data to be used by Cloud-Init to run custom scripts or provide custom Cloud-Init configuration. For information about how to take advantage of user data, see the [Cloud-Init Documentation](http://cloudinit.readthedocs.org/en/latest/topics/format.html).

        **Metadata Example**

        "metadata" : { "quake_bot_level" : "Severe", "ssh_authorized_keys" : "ssh-rsa <your_public_SSH_key>== rsa-key-20160227", "user_data" : "<your_public_SSH_key>==" } **Getting Metadata on the Instance**

        To get information about your instance, connect to the instance using SSH and issue any of the following GET requests:

        curl -H "Authorization: Bearer Oracle" http://169.254.169.254/opc/v2/instance/ curl -H "Authorization: Bearer Oracle" http://169.254.169.254/opc/v2/instance/metadata/ curl -H "Authorization: Bearer Oracle" http://169.254.169.254/opc/v2/instance/metadata/<any-key-name>

        You'll get back a response that includes all the instance information; only the metadata information; or the metadata information for the specified key name, respectively.

        The combined size of the `metadata` and `extendedMetadata` objects can be a maximum of 32,000 bytes.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter(name="platformConfig")
    def platform_config(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsPlatformConfigArgs']]:
        """
        The platform configuration requested for the instance.

        If you provide the parameter, the instance is created with the platform configuration that you specify. For any values that you omit, the instance uses the default configuration values for the `shape` that you specify. If you don't provide the parameter, the default values for the `shape` are used.

        Each shape only supports certain configurable values. If the values that you provide are not valid for the specified `shape`, an error is returned.
        """
        return pulumi.get(self, "platform_config")

    @platform_config.setter
    def platform_config(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsPlatformConfigArgs']]):
        pulumi.set(self, "platform_config", value)

    @property
    @pulumi.getter(name="preemptibleInstanceConfig")
    def preemptible_instance_config(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsPreemptibleInstanceConfigArgs']]:
        """
        Configuration options for preemptible instances.
        """
        return pulumi.get(self, "preemptible_instance_config")

    @preemptible_instance_config.setter
    def preemptible_instance_config(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsPreemptibleInstanceConfigArgs']]):
        pulumi.set(self, "preemptible_instance_config", value)

    @property
    @pulumi.getter(name="preferredMaintenanceAction")
    def preferred_maintenance_action(self) -> Optional[pulumi.Input[str]]:
        """
        The preferred maintenance action for an instance. The default is LIVE_MIGRATE, if live migration is supported.
        """
        return pulumi.get(self, "preferred_maintenance_action")

    @preferred_maintenance_action.setter
    def preferred_maintenance_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preferred_maintenance_action", value)

    @property
    @pulumi.getter
    def shape(self) -> Optional[pulumi.Input[str]]:
        """
        The shape of an instance. The shape determines the number of CPUs, amount of memory, and other resources allocated to the instance.

        You can enumerate all available shapes by calling [ListShapes](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Shape/ListShapes).
        """
        return pulumi.get(self, "shape")

    @shape.setter
    def shape(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shape", value)

    @property
    @pulumi.getter(name="shapeConfig")
    def shape_config(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsShapeConfigArgs']]:
        """
        The shape configuration requested for the instance.

        If the parameter is provided, the instance is created with the resources that you specify. If some properties are missing or the entire parameter is not provided, the instance is created with the default configuration values for the `shape` that you specify.

        Each shape only supports certain configurable values. If the values that you provide are not valid for the specified `shape`, an error is returned.
        """
        return pulumi.get(self, "shape_config")

    @shape_config.setter
    def shape_config(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsShapeConfigArgs']]):
        pulumi.set(self, "shape_config", value)

    @property
    @pulumi.getter(name="sourceDetails")
    def source_details(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsSourceDetailsArgs']]:
        return pulumi.get(self, "source_details")

    @source_details.setter
    def source_details(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsSourceDetailsArgs']]):
        pulumi.set(self, "source_details", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsOptionLaunchDetailsAgentConfigArgs:
    def __init__(__self__, *,
                 are_all_plugins_disabled: Optional[pulumi.Input[bool]] = None,
                 is_management_disabled: Optional[pulumi.Input[bool]] = None,
                 is_monitoring_disabled: Optional[pulumi.Input[bool]] = None,
                 plugins_configs: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsAgentConfigPluginsConfigArgs']]]] = None):
        """
        :param pulumi.Input[bool] are_all_plugins_disabled: Whether Oracle Cloud Agent can run all the available plugins. This includes the management and monitoring plugins.
               
               To get a list of available plugins, use the [ListInstanceagentAvailablePlugins](https://docs.cloud.oracle.com/iaas/api/#/en/instanceagent/20180530/Plugin/ListInstanceagentAvailablePlugins) operation in the Oracle Cloud Agent API. For more information about the available plugins, see [Managing Plugins with Oracle Cloud Agent](https://docs.cloud.oracle.com/iaas/Content/Compute/Tasks/manage-plugins.htm).
        :param pulumi.Input[bool] is_management_disabled: Whether Oracle Cloud Agent can run all the available management plugins. Default value is false (management plugins are enabled).
               
               These are the management plugins: OS Management Service Agent and Compute Instance Run Command.
               
               The management plugins are controlled by this parameter and by the per-plugin configuration in the `pluginsConfig` object.
               * If `isManagementDisabled` is true, all of the management plugins are disabled, regardless of the per-plugin configuration.
               * If `isManagementDisabled` is false, all of the management plugins are enabled. You can optionally disable individual management plugins by providing a value in the `pluginsConfig` object.
        :param pulumi.Input[bool] is_monitoring_disabled: Whether Oracle Cloud Agent can gather performance metrics and monitor the instance using the monitoring plugins. Default value is false (monitoring plugins are enabled).
               
               These are the monitoring plugins: Compute Instance Monitoring and Custom Logs Monitoring.
               
               The monitoring plugins are controlled by this parameter and by the per-plugin configuration in the `pluginsConfig` object.
               * If `isMonitoringDisabled` is true, all of the monitoring plugins are disabled, regardless of the per-plugin configuration.
               * If `isMonitoringDisabled` is false, all of the monitoring plugins are enabled. You can optionally disable individual monitoring plugins by providing a value in the `pluginsConfig` object.
        :param pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsAgentConfigPluginsConfigArgs']]] plugins_configs: The configuration of plugins associated with this instance.
        """
        InstanceConfigurationInstanceDetailsOptionLaunchDetailsAgentConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            are_all_plugins_disabled=are_all_plugins_disabled,
            is_management_disabled=is_management_disabled,
            is_monitoring_disabled=is_monitoring_disabled,
            plugins_configs=plugins_configs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             are_all_plugins_disabled: Optional[pulumi.Input[bool]] = None,
             is_management_disabled: Optional[pulumi.Input[bool]] = None,
             is_monitoring_disabled: Optional[pulumi.Input[bool]] = None,
             plugins_configs: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsAgentConfigPluginsConfigArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if are_all_plugins_disabled is not None:
            _setter("are_all_plugins_disabled", are_all_plugins_disabled)
        if is_management_disabled is not None:
            _setter("is_management_disabled", is_management_disabled)
        if is_monitoring_disabled is not None:
            _setter("is_monitoring_disabled", is_monitoring_disabled)
        if plugins_configs is not None:
            _setter("plugins_configs", plugins_configs)

    @property
    @pulumi.getter(name="areAllPluginsDisabled")
    def are_all_plugins_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether Oracle Cloud Agent can run all the available plugins. This includes the management and monitoring plugins.

        To get a list of available plugins, use the [ListInstanceagentAvailablePlugins](https://docs.cloud.oracle.com/iaas/api/#/en/instanceagent/20180530/Plugin/ListInstanceagentAvailablePlugins) operation in the Oracle Cloud Agent API. For more information about the available plugins, see [Managing Plugins with Oracle Cloud Agent](https://docs.cloud.oracle.com/iaas/Content/Compute/Tasks/manage-plugins.htm).
        """
        return pulumi.get(self, "are_all_plugins_disabled")

    @are_all_plugins_disabled.setter
    def are_all_plugins_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "are_all_plugins_disabled", value)

    @property
    @pulumi.getter(name="isManagementDisabled")
    def is_management_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether Oracle Cloud Agent can run all the available management plugins. Default value is false (management plugins are enabled).

        These are the management plugins: OS Management Service Agent and Compute Instance Run Command.

        The management plugins are controlled by this parameter and by the per-plugin configuration in the `pluginsConfig` object.
        * If `isManagementDisabled` is true, all of the management plugins are disabled, regardless of the per-plugin configuration.
        * If `isManagementDisabled` is false, all of the management plugins are enabled. You can optionally disable individual management plugins by providing a value in the `pluginsConfig` object.
        """
        return pulumi.get(self, "is_management_disabled")

    @is_management_disabled.setter
    def is_management_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_management_disabled", value)

    @property
    @pulumi.getter(name="isMonitoringDisabled")
    def is_monitoring_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether Oracle Cloud Agent can gather performance metrics and monitor the instance using the monitoring plugins. Default value is false (monitoring plugins are enabled).

        These are the monitoring plugins: Compute Instance Monitoring and Custom Logs Monitoring.

        The monitoring plugins are controlled by this parameter and by the per-plugin configuration in the `pluginsConfig` object.
        * If `isMonitoringDisabled` is true, all of the monitoring plugins are disabled, regardless of the per-plugin configuration.
        * If `isMonitoringDisabled` is false, all of the monitoring plugins are enabled. You can optionally disable individual monitoring plugins by providing a value in the `pluginsConfig` object.
        """
        return pulumi.get(self, "is_monitoring_disabled")

    @is_monitoring_disabled.setter
    def is_monitoring_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monitoring_disabled", value)

    @property
    @pulumi.getter(name="pluginsConfigs")
    def plugins_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsAgentConfigPluginsConfigArgs']]]]:
        """
        The configuration of plugins associated with this instance.
        """
        return pulumi.get(self, "plugins_configs")

    @plugins_configs.setter
    def plugins_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsAgentConfigPluginsConfigArgs']]]]):
        pulumi.set(self, "plugins_configs", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsOptionLaunchDetailsAgentConfigPluginsConfigArgs:
    def __init__(__self__, *,
                 desired_state: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] desired_state: Whether the plugin should be enabled or disabled.
               
               To enable the monitoring and management plugins, the `isMonitoringDisabled` and `isManagementDisabled` attributes must also be set to false.
        :param pulumi.Input[str] name: The plugin name. To get a list of available plugins, use the [ListInstanceagentAvailablePlugins](https://docs.cloud.oracle.com/iaas/api/#/en/instanceagent/20180530/Plugin/ListInstanceagentAvailablePlugins) operation in the Oracle Cloud Agent API. For more information about the available plugins, see [Managing Plugins with Oracle Cloud Agent](https://docs.cloud.oracle.com/iaas/Content/Compute/Tasks/manage-plugins.htm).
        """
        InstanceConfigurationInstanceDetailsOptionLaunchDetailsAgentConfigPluginsConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            desired_state=desired_state,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             desired_state: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if desired_state is not None:
            _setter("desired_state", desired_state)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="desiredState")
    def desired_state(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the plugin should be enabled or disabled.

        To enable the monitoring and management plugins, the `isMonitoringDisabled` and `isManagementDisabled` attributes must also be set to false.
        """
        return pulumi.get(self, "desired_state")

    @desired_state.setter
    def desired_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "desired_state", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The plugin name. To get a list of available plugins, use the [ListInstanceagentAvailablePlugins](https://docs.cloud.oracle.com/iaas/api/#/en/instanceagent/20180530/Plugin/ListInstanceagentAvailablePlugins) operation in the Oracle Cloud Agent API. For more information about the available plugins, see [Managing Plugins with Oracle Cloud Agent](https://docs.cloud.oracle.com/iaas/Content/Compute/Tasks/manage-plugins.htm).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsOptionLaunchDetailsAvailabilityConfigArgs:
    def __init__(__self__, *,
                 is_live_migration_preferred: Optional[pulumi.Input[bool]] = None,
                 recovery_action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_live_migration_preferred: Whether to live migrate supported VM instances to a healthy physical VM host without disrupting running instances during infrastructure maintenance events. If null, Oracle chooses the best option for migrating the VM during infrastructure maintenance events.
        :param pulumi.Input[str] recovery_action: The lifecycle state for an instance when it is recovered after infrastructure maintenance.
        """
        InstanceConfigurationInstanceDetailsOptionLaunchDetailsAvailabilityConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_live_migration_preferred=is_live_migration_preferred,
            recovery_action=recovery_action,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_live_migration_preferred: Optional[pulumi.Input[bool]] = None,
             recovery_action: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_live_migration_preferred is not None:
            _setter("is_live_migration_preferred", is_live_migration_preferred)
        if recovery_action is not None:
            _setter("recovery_action", recovery_action)

    @property
    @pulumi.getter(name="isLiveMigrationPreferred")
    def is_live_migration_preferred(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to live migrate supported VM instances to a healthy physical VM host without disrupting running instances during infrastructure maintenance events. If null, Oracle chooses the best option for migrating the VM during infrastructure maintenance events.
        """
        return pulumi.get(self, "is_live_migration_preferred")

    @is_live_migration_preferred.setter
    def is_live_migration_preferred(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_live_migration_preferred", value)

    @property
    @pulumi.getter(name="recoveryAction")
    def recovery_action(self) -> Optional[pulumi.Input[str]]:
        """
        The lifecycle state for an instance when it is recovered after infrastructure maintenance.
        """
        return pulumi.get(self, "recovery_action")

    @recovery_action.setter
    def recovery_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recovery_action", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsOptionLaunchDetailsCreateVnicDetailsArgs:
    def __init__(__self__, *,
                 assign_ipv6ip: Optional[pulumi.Input[bool]] = None,
                 assign_private_dns_record: Optional[pulumi.Input[bool]] = None,
                 assign_public_ip: Optional[pulumi.Input[bool]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 hostname_label: Optional[pulumi.Input[str]] = None,
                 ipv6address_ipv6subnet_cidr_pair_details: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs']]]] = None,
                 nsg_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 private_ip: Optional[pulumi.Input[str]] = None,
                 skip_source_dest_check: Optional[pulumi.Input[bool]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] assign_ipv6ip: Whether to allocate an IPv6 address at instance and VNIC creation from an IPv6 enabled subnet. Default: False. When provided you may optionally provide an IPv6 prefix (`ipv6SubnetCidr`) of your choice to assign the IPv6 address from. If `ipv6SubnetCidr` is not provided then an IPv6 prefix is chosen for you.
        :param pulumi.Input[bool] assign_private_dns_record: Whether the VNIC should be assigned a private DNS record. See the `assignPrivateDnsRecord` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        :param pulumi.Input[bool] assign_public_ip: Whether the VNIC should be assigned a public IP address. See the `assignPublicIp` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        :param pulumi.Input[Mapping[str, Any]] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        :param pulumi.Input[str] display_name: A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        :param pulumi.Input[Mapping[str, Any]] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param pulumi.Input[str] hostname_label: The hostname for the VNIC's primary private IP. See the `hostnameLabel` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        :param pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs']]] ipv6address_ipv6subnet_cidr_pair_details: A list of IPv6 prefix ranges from which the VNIC should be assigned an IPv6 address. You can provide only the prefix ranges and Oracle Cloud Infrastructure selects an available address from the range. You can optionally choose to leave the prefix range empty and instead provide the specific IPv6 address that should be used from within that range.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] nsg_ids: A list of the OCIDs of the network security groups (NSGs) to add the VNIC to. For more information about NSGs, see [NetworkSecurityGroup](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/NetworkSecurityGroup/).
        :param pulumi.Input[str] private_ip: A private IP address of your choice to assign to the VNIC. See the `privateIp` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        :param pulumi.Input[bool] skip_source_dest_check: Whether the source/destination check is disabled on the VNIC. See the `skipSourceDestCheck` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        :param pulumi.Input[str] subnet_id: The OCID of the subnet to create the VNIC in. See the `subnetId` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        InstanceConfigurationInstanceDetailsOptionLaunchDetailsCreateVnicDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            assign_ipv6ip=assign_ipv6ip,
            assign_private_dns_record=assign_private_dns_record,
            assign_public_ip=assign_public_ip,
            defined_tags=defined_tags,
            display_name=display_name,
            freeform_tags=freeform_tags,
            hostname_label=hostname_label,
            ipv6address_ipv6subnet_cidr_pair_details=ipv6address_ipv6subnet_cidr_pair_details,
            nsg_ids=nsg_ids,
            private_ip=private_ip,
            skip_source_dest_check=skip_source_dest_check,
            subnet_id=subnet_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             assign_ipv6ip: Optional[pulumi.Input[bool]] = None,
             assign_private_dns_record: Optional[pulumi.Input[bool]] = None,
             assign_public_ip: Optional[pulumi.Input[bool]] = None,
             defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             display_name: Optional[pulumi.Input[str]] = None,
             freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             hostname_label: Optional[pulumi.Input[str]] = None,
             ipv6address_ipv6subnet_cidr_pair_details: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs']]]] = None,
             nsg_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             private_ip: Optional[pulumi.Input[str]] = None,
             skip_source_dest_check: Optional[pulumi.Input[bool]] = None,
             subnet_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if assign_ipv6ip is not None:
            _setter("assign_ipv6ip", assign_ipv6ip)
        if assign_private_dns_record is not None:
            _setter("assign_private_dns_record", assign_private_dns_record)
        if assign_public_ip is not None:
            _setter("assign_public_ip", assign_public_ip)
        if defined_tags is not None:
            _setter("defined_tags", defined_tags)
        if display_name is not None:
            _setter("display_name", display_name)
        if freeform_tags is not None:
            _setter("freeform_tags", freeform_tags)
        if hostname_label is not None:
            _setter("hostname_label", hostname_label)
        if ipv6address_ipv6subnet_cidr_pair_details is not None:
            _setter("ipv6address_ipv6subnet_cidr_pair_details", ipv6address_ipv6subnet_cidr_pair_details)
        if nsg_ids is not None:
            _setter("nsg_ids", nsg_ids)
        if private_ip is not None:
            _setter("private_ip", private_ip)
        if skip_source_dest_check is not None:
            _setter("skip_source_dest_check", skip_source_dest_check)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)

    @property
    @pulumi.getter(name="assignIpv6ip")
    def assign_ipv6ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allocate an IPv6 address at instance and VNIC creation from an IPv6 enabled subnet. Default: False. When provided you may optionally provide an IPv6 prefix (`ipv6SubnetCidr`) of your choice to assign the IPv6 address from. If `ipv6SubnetCidr` is not provided then an IPv6 prefix is chosen for you.
        """
        return pulumi.get(self, "assign_ipv6ip")

    @assign_ipv6ip.setter
    def assign_ipv6ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_ipv6ip", value)

    @property
    @pulumi.getter(name="assignPrivateDnsRecord")
    def assign_private_dns_record(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the VNIC should be assigned a private DNS record. See the `assignPrivateDnsRecord` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "assign_private_dns_record")

    @assign_private_dns_record.setter
    def assign_private_dns_record(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_private_dns_record", value)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the VNIC should be assigned a public IP address. See the `assignPublicIp` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_public_ip", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter(name="hostnameLabel")
    def hostname_label(self) -> Optional[pulumi.Input[str]]:
        """
        The hostname for the VNIC's primary private IP. See the `hostnameLabel` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "hostname_label")

    @hostname_label.setter
    def hostname_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname_label", value)

    @property
    @pulumi.getter(name="ipv6addressIpv6subnetCidrPairDetails")
    def ipv6address_ipv6subnet_cidr_pair_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs']]]]:
        """
        A list of IPv6 prefix ranges from which the VNIC should be assigned an IPv6 address. You can provide only the prefix ranges and Oracle Cloud Infrastructure selects an available address from the range. You can optionally choose to leave the prefix range empty and instead provide the specific IPv6 address that should be used from within that range.
        """
        return pulumi.get(self, "ipv6address_ipv6subnet_cidr_pair_details")

    @ipv6address_ipv6subnet_cidr_pair_details.setter
    def ipv6address_ipv6subnet_cidr_pair_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs']]]]):
        pulumi.set(self, "ipv6address_ipv6subnet_cidr_pair_details", value)

    @property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of the OCIDs of the network security groups (NSGs) to add the VNIC to. For more information about NSGs, see [NetworkSecurityGroup](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/NetworkSecurityGroup/).
        """
        return pulumi.get(self, "nsg_ids")

    @nsg_ids.setter
    def nsg_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "nsg_ids", value)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[str]]:
        """
        A private IP address of your choice to assign to the VNIC. See the `privateIp` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_ip", value)

    @property
    @pulumi.getter(name="skipSourceDestCheck")
    def skip_source_dest_check(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the source/destination check is disabled on the VNIC. See the `skipSourceDestCheck` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "skip_source_dest_check")

    @skip_source_dest_check.setter
    def skip_source_dest_check(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_source_dest_check", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the subnet to create the VNIC in. See the `subnetId` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsOptionLaunchDetailsCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs:
    def __init__(__self__, *,
                 ipv6address: Optional[pulumi.Input[str]] = None,
                 ipv6subnet_cidr: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ipv6address: Optional. An available IPv6 address of your subnet from a valid IPv6 prefix on the subnet (otherwise the IP address is automatically assigned).
        :param pulumi.Input[str] ipv6subnet_cidr: Optional. Used to disambiguate which subnet prefix should be used to create an IPv6 allocation.
        """
        InstanceConfigurationInstanceDetailsOptionLaunchDetailsCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ipv6address=ipv6address,
            ipv6subnet_cidr=ipv6subnet_cidr,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ipv6address: Optional[pulumi.Input[str]] = None,
             ipv6subnet_cidr: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ipv6address is not None:
            _setter("ipv6address", ipv6address)
        if ipv6subnet_cidr is not None:
            _setter("ipv6subnet_cidr", ipv6subnet_cidr)

    @property
    @pulumi.getter
    def ipv6address(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. An available IPv6 address of your subnet from a valid IPv6 prefix on the subnet (otherwise the IP address is automatically assigned).
        """
        return pulumi.get(self, "ipv6address")

    @ipv6address.setter
    def ipv6address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6address", value)

    @property
    @pulumi.getter(name="ipv6subnetCidr")
    def ipv6subnet_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Used to disambiguate which subnet prefix should be used to create an IPv6 allocation.
        """
        return pulumi.get(self, "ipv6subnet_cidr")

    @ipv6subnet_cidr.setter
    def ipv6subnet_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6subnet_cidr", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsOptionLaunchDetailsInstanceOptionsArgs:
    def __init__(__self__, *,
                 are_legacy_imds_endpoints_disabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] are_legacy_imds_endpoints_disabled: Whether to disable the legacy (/v1) instance metadata service endpoints. Customers who have migrated to /v2 should set this to true for added security. Default is false.
        """
        InstanceConfigurationInstanceDetailsOptionLaunchDetailsInstanceOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            are_legacy_imds_endpoints_disabled=are_legacy_imds_endpoints_disabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             are_legacy_imds_endpoints_disabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if are_legacy_imds_endpoints_disabled is not None:
            _setter("are_legacy_imds_endpoints_disabled", are_legacy_imds_endpoints_disabled)

    @property
    @pulumi.getter(name="areLegacyImdsEndpointsDisabled")
    def are_legacy_imds_endpoints_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable the legacy (/v1) instance metadata service endpoints. Customers who have migrated to /v2 should set this to true for added security. Default is false.
        """
        return pulumi.get(self, "are_legacy_imds_endpoints_disabled")

    @are_legacy_imds_endpoints_disabled.setter
    def are_legacy_imds_endpoints_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "are_legacy_imds_endpoints_disabled", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsOptionLaunchDetailsLaunchOptionsArgs:
    def __init__(__self__, *,
                 boot_volume_type: Optional[pulumi.Input[str]] = None,
                 firmware: Optional[pulumi.Input[str]] = None,
                 is_consistent_volume_naming_enabled: Optional[pulumi.Input[bool]] = None,
                 is_pv_encryption_in_transit_enabled: Optional[pulumi.Input[bool]] = None,
                 network_type: Optional[pulumi.Input[str]] = None,
                 remote_data_volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] boot_volume_type: Emulation type for the boot volume.
        :param pulumi.Input[str] firmware: Firmware used to boot VM. Select the option that matches your operating system.
        :param pulumi.Input[bool] is_consistent_volume_naming_enabled: Whether to enable consistent volume naming feature. Defaults to false.
        :param pulumi.Input[bool] is_pv_encryption_in_transit_enabled: Deprecated. Instead use `isPvEncryptionInTransitEnabled` in [InstanceConfigurationLaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/datatypes/InstanceConfigurationLaunchInstanceDetails).
        :param pulumi.Input[str] network_type: Emulation type for the physical network interface card (NIC).
        :param pulumi.Input[str] remote_data_volume_type: Emulation type for volume.
        """
        InstanceConfigurationInstanceDetailsOptionLaunchDetailsLaunchOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            boot_volume_type=boot_volume_type,
            firmware=firmware,
            is_consistent_volume_naming_enabled=is_consistent_volume_naming_enabled,
            is_pv_encryption_in_transit_enabled=is_pv_encryption_in_transit_enabled,
            network_type=network_type,
            remote_data_volume_type=remote_data_volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             boot_volume_type: Optional[pulumi.Input[str]] = None,
             firmware: Optional[pulumi.Input[str]] = None,
             is_consistent_volume_naming_enabled: Optional[pulumi.Input[bool]] = None,
             is_pv_encryption_in_transit_enabled: Optional[pulumi.Input[bool]] = None,
             network_type: Optional[pulumi.Input[str]] = None,
             remote_data_volume_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if boot_volume_type is not None:
            _setter("boot_volume_type", boot_volume_type)
        if firmware is not None:
            _setter("firmware", firmware)
        if is_consistent_volume_naming_enabled is not None:
            _setter("is_consistent_volume_naming_enabled", is_consistent_volume_naming_enabled)
        if is_pv_encryption_in_transit_enabled is not None:
            _setter("is_pv_encryption_in_transit_enabled", is_pv_encryption_in_transit_enabled)
        if network_type is not None:
            _setter("network_type", network_type)
        if remote_data_volume_type is not None:
            _setter("remote_data_volume_type", remote_data_volume_type)

    @property
    @pulumi.getter(name="bootVolumeType")
    def boot_volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        Emulation type for the boot volume.
        """
        return pulumi.get(self, "boot_volume_type")

    @boot_volume_type.setter
    def boot_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "boot_volume_type", value)

    @property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[str]]:
        """
        Firmware used to boot VM. Select the option that matches your operating system.
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "firmware", value)

    @property
    @pulumi.getter(name="isConsistentVolumeNamingEnabled")
    def is_consistent_volume_naming_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable consistent volume naming feature. Defaults to false.
        """
        return pulumi.get(self, "is_consistent_volume_naming_enabled")

    @is_consistent_volume_naming_enabled.setter
    def is_consistent_volume_naming_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_consistent_volume_naming_enabled", value)

    @property
    @pulumi.getter(name="isPvEncryptionInTransitEnabled")
    def is_pv_encryption_in_transit_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Deprecated. Instead use `isPvEncryptionInTransitEnabled` in [InstanceConfigurationLaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/datatypes/InstanceConfigurationLaunchInstanceDetails).
        """
        return pulumi.get(self, "is_pv_encryption_in_transit_enabled")

    @is_pv_encryption_in_transit_enabled.setter
    def is_pv_encryption_in_transit_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_pv_encryption_in_transit_enabled", value)

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> Optional[pulumi.Input[str]]:
        """
        Emulation type for the physical network interface card (NIC).
        """
        return pulumi.get(self, "network_type")

    @network_type.setter
    def network_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_type", value)

    @property
    @pulumi.getter(name="remoteDataVolumeType")
    def remote_data_volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        Emulation type for volume.
        """
        return pulumi.get(self, "remote_data_volume_type")

    @remote_data_volume_type.setter
    def remote_data_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_data_volume_type", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsOptionLaunchDetailsPlatformConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 are_virtual_instructions_enabled: Optional[pulumi.Input[bool]] = None,
                 is_access_control_service_enabled: Optional[pulumi.Input[bool]] = None,
                 is_input_output_memory_management_unit_enabled: Optional[pulumi.Input[bool]] = None,
                 is_measured_boot_enabled: Optional[pulumi.Input[bool]] = None,
                 is_memory_encryption_enabled: Optional[pulumi.Input[bool]] = None,
                 is_secure_boot_enabled: Optional[pulumi.Input[bool]] = None,
                 is_symmetric_multi_threading_enabled: Optional[pulumi.Input[bool]] = None,
                 is_trusted_platform_module_enabled: Optional[pulumi.Input[bool]] = None,
                 numa_nodes_per_socket: Optional[pulumi.Input[str]] = None,
                 percentage_of_cores_enabled: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] type: The type of action to run when the instance is interrupted for eviction.
        :param pulumi.Input[bool] are_virtual_instructions_enabled: Whether virtualization instructions are available. For example, Secure Virtual Machine for AMD shapes or VT-x for Intel shapes.
        :param pulumi.Input[bool] is_access_control_service_enabled: Whether the Access Control Service is enabled on the instance. When enabled, the platform can enforce PCIe device isolation, required for VFIO device pass-through.
        :param pulumi.Input[bool] is_input_output_memory_management_unit_enabled: Whether the input-output memory management unit is enabled.
        :param pulumi.Input[bool] is_measured_boot_enabled: Whether the Measured Boot feature is enabled on the instance.
        :param pulumi.Input[bool] is_memory_encryption_enabled: Whether the instance is a confidential instance. If this value is `true`, the instance is a confidential instance. The default value is `false`.
        :param pulumi.Input[bool] is_secure_boot_enabled: Whether Secure Boot is enabled on the instance.
        :param pulumi.Input[bool] is_symmetric_multi_threading_enabled: Whether symmetric multithreading is enabled on the instance. Symmetric multithreading is also called simultaneous multithreading (SMT) or Intel Hyper-Threading.
               
               Intel and AMD processors have two hardware execution threads per core (OCPU). SMT permits multiple independent threads of execution, to better use the resources and increase the efficiency of the CPU. When multithreading is disabled, only one thread is permitted to run on each core, which can provide higher or more predictable performance for some workloads.
        :param pulumi.Input[bool] is_trusted_platform_module_enabled: Whether the Trusted Platform Module (TPM) is enabled on the instance.
        :param pulumi.Input[str] numa_nodes_per_socket: The number of NUMA nodes per socket (NPS).
        :param pulumi.Input[int] percentage_of_cores_enabled: The percentage of cores enabled. Value must be a multiple of 25%. If the requested percentage results in a fractional number of cores, the system rounds up the number of cores across processors and provisions an instance with a whole number of cores.
               
               If the applications that you run on the instance use a core-based licensing model and need fewer cores than the full size of the shape, you can disable cores to reduce your licensing costs. The instance itself is billed for the full shape, regardless of whether all cores are enabled.
        """
        InstanceConfigurationInstanceDetailsOptionLaunchDetailsPlatformConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            are_virtual_instructions_enabled=are_virtual_instructions_enabled,
            is_access_control_service_enabled=is_access_control_service_enabled,
            is_input_output_memory_management_unit_enabled=is_input_output_memory_management_unit_enabled,
            is_measured_boot_enabled=is_measured_boot_enabled,
            is_memory_encryption_enabled=is_memory_encryption_enabled,
            is_secure_boot_enabled=is_secure_boot_enabled,
            is_symmetric_multi_threading_enabled=is_symmetric_multi_threading_enabled,
            is_trusted_platform_module_enabled=is_trusted_platform_module_enabled,
            numa_nodes_per_socket=numa_nodes_per_socket,
            percentage_of_cores_enabled=percentage_of_cores_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[str],
             are_virtual_instructions_enabled: Optional[pulumi.Input[bool]] = None,
             is_access_control_service_enabled: Optional[pulumi.Input[bool]] = None,
             is_input_output_memory_management_unit_enabled: Optional[pulumi.Input[bool]] = None,
             is_measured_boot_enabled: Optional[pulumi.Input[bool]] = None,
             is_memory_encryption_enabled: Optional[pulumi.Input[bool]] = None,
             is_secure_boot_enabled: Optional[pulumi.Input[bool]] = None,
             is_symmetric_multi_threading_enabled: Optional[pulumi.Input[bool]] = None,
             is_trusted_platform_module_enabled: Optional[pulumi.Input[bool]] = None,
             numa_nodes_per_socket: Optional[pulumi.Input[str]] = None,
             percentage_of_cores_enabled: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if are_virtual_instructions_enabled is not None:
            _setter("are_virtual_instructions_enabled", are_virtual_instructions_enabled)
        if is_access_control_service_enabled is not None:
            _setter("is_access_control_service_enabled", is_access_control_service_enabled)
        if is_input_output_memory_management_unit_enabled is not None:
            _setter("is_input_output_memory_management_unit_enabled", is_input_output_memory_management_unit_enabled)
        if is_measured_boot_enabled is not None:
            _setter("is_measured_boot_enabled", is_measured_boot_enabled)
        if is_memory_encryption_enabled is not None:
            _setter("is_memory_encryption_enabled", is_memory_encryption_enabled)
        if is_secure_boot_enabled is not None:
            _setter("is_secure_boot_enabled", is_secure_boot_enabled)
        if is_symmetric_multi_threading_enabled is not None:
            _setter("is_symmetric_multi_threading_enabled", is_symmetric_multi_threading_enabled)
        if is_trusted_platform_module_enabled is not None:
            _setter("is_trusted_platform_module_enabled", is_trusted_platform_module_enabled)
        if numa_nodes_per_socket is not None:
            _setter("numa_nodes_per_socket", numa_nodes_per_socket)
        if percentage_of_cores_enabled is not None:
            _setter("percentage_of_cores_enabled", percentage_of_cores_enabled)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of action to run when the instance is interrupted for eviction.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="areVirtualInstructionsEnabled")
    def are_virtual_instructions_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether virtualization instructions are available. For example, Secure Virtual Machine for AMD shapes or VT-x for Intel shapes.
        """
        return pulumi.get(self, "are_virtual_instructions_enabled")

    @are_virtual_instructions_enabled.setter
    def are_virtual_instructions_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "are_virtual_instructions_enabled", value)

    @property
    @pulumi.getter(name="isAccessControlServiceEnabled")
    def is_access_control_service_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the Access Control Service is enabled on the instance. When enabled, the platform can enforce PCIe device isolation, required for VFIO device pass-through.
        """
        return pulumi.get(self, "is_access_control_service_enabled")

    @is_access_control_service_enabled.setter
    def is_access_control_service_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_access_control_service_enabled", value)

    @property
    @pulumi.getter(name="isInputOutputMemoryManagementUnitEnabled")
    def is_input_output_memory_management_unit_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the input-output memory management unit is enabled.
        """
        return pulumi.get(self, "is_input_output_memory_management_unit_enabled")

    @is_input_output_memory_management_unit_enabled.setter
    def is_input_output_memory_management_unit_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_input_output_memory_management_unit_enabled", value)

    @property
    @pulumi.getter(name="isMeasuredBootEnabled")
    def is_measured_boot_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the Measured Boot feature is enabled on the instance.
        """
        return pulumi.get(self, "is_measured_boot_enabled")

    @is_measured_boot_enabled.setter
    def is_measured_boot_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_measured_boot_enabled", value)

    @property
    @pulumi.getter(name="isMemoryEncryptionEnabled")
    def is_memory_encryption_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the instance is a confidential instance. If this value is `true`, the instance is a confidential instance. The default value is `false`.
        """
        return pulumi.get(self, "is_memory_encryption_enabled")

    @is_memory_encryption_enabled.setter
    def is_memory_encryption_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_memory_encryption_enabled", value)

    @property
    @pulumi.getter(name="isSecureBootEnabled")
    def is_secure_boot_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether Secure Boot is enabled on the instance.
        """
        return pulumi.get(self, "is_secure_boot_enabled")

    @is_secure_boot_enabled.setter
    def is_secure_boot_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_secure_boot_enabled", value)

    @property
    @pulumi.getter(name="isSymmetricMultiThreadingEnabled")
    def is_symmetric_multi_threading_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether symmetric multithreading is enabled on the instance. Symmetric multithreading is also called simultaneous multithreading (SMT) or Intel Hyper-Threading.

        Intel and AMD processors have two hardware execution threads per core (OCPU). SMT permits multiple independent threads of execution, to better use the resources and increase the efficiency of the CPU. When multithreading is disabled, only one thread is permitted to run on each core, which can provide higher or more predictable performance for some workloads.
        """
        return pulumi.get(self, "is_symmetric_multi_threading_enabled")

    @is_symmetric_multi_threading_enabled.setter
    def is_symmetric_multi_threading_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_symmetric_multi_threading_enabled", value)

    @property
    @pulumi.getter(name="isTrustedPlatformModuleEnabled")
    def is_trusted_platform_module_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the Trusted Platform Module (TPM) is enabled on the instance.
        """
        return pulumi.get(self, "is_trusted_platform_module_enabled")

    @is_trusted_platform_module_enabled.setter
    def is_trusted_platform_module_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_trusted_platform_module_enabled", value)

    @property
    @pulumi.getter(name="numaNodesPerSocket")
    def numa_nodes_per_socket(self) -> Optional[pulumi.Input[str]]:
        """
        The number of NUMA nodes per socket (NPS).
        """
        return pulumi.get(self, "numa_nodes_per_socket")

    @numa_nodes_per_socket.setter
    def numa_nodes_per_socket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "numa_nodes_per_socket", value)

    @property
    @pulumi.getter(name="percentageOfCoresEnabled")
    def percentage_of_cores_enabled(self) -> Optional[pulumi.Input[int]]:
        """
        The percentage of cores enabled. Value must be a multiple of 25%. If the requested percentage results in a fractional number of cores, the system rounds up the number of cores across processors and provisions an instance with a whole number of cores.

        If the applications that you run on the instance use a core-based licensing model and need fewer cores than the full size of the shape, you can disable cores to reduce your licensing costs. The instance itself is billed for the full shape, regardless of whether all cores are enabled.
        """
        return pulumi.get(self, "percentage_of_cores_enabled")

    @percentage_of_cores_enabled.setter
    def percentage_of_cores_enabled(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "percentage_of_cores_enabled", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsOptionLaunchDetailsPreemptibleInstanceConfigArgs:
    def __init__(__self__, *,
                 preemption_action: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsPreemptibleInstanceConfigPreemptionActionArgs']] = None):
        """
        :param pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsPreemptibleInstanceConfigPreemptionActionArgs'] preemption_action: The action to run when the preemptible instance is interrupted for eviction.
        """
        InstanceConfigurationInstanceDetailsOptionLaunchDetailsPreemptibleInstanceConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            preemption_action=preemption_action,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             preemption_action: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsPreemptibleInstanceConfigPreemptionActionArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if preemption_action is not None:
            _setter("preemption_action", preemption_action)

    @property
    @pulumi.getter(name="preemptionAction")
    def preemption_action(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsPreemptibleInstanceConfigPreemptionActionArgs']]:
        """
        The action to run when the preemptible instance is interrupted for eviction.
        """
        return pulumi.get(self, "preemption_action")

    @preemption_action.setter
    def preemption_action(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsPreemptibleInstanceConfigPreemptionActionArgs']]):
        pulumi.set(self, "preemption_action", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsOptionLaunchDetailsPreemptibleInstanceConfigPreemptionActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 preserve_boot_volume: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] type: The type of action to run when the instance is interrupted for eviction.
        :param pulumi.Input[bool] preserve_boot_volume: Whether to preserve the boot volume that was used to launch the preemptible instance when the instance is terminated. Defaults to false if not specified.
        """
        InstanceConfigurationInstanceDetailsOptionLaunchDetailsPreemptibleInstanceConfigPreemptionActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            preserve_boot_volume=preserve_boot_volume,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[str],
             preserve_boot_volume: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if preserve_boot_volume is not None:
            _setter("preserve_boot_volume", preserve_boot_volume)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of action to run when the instance is interrupted for eviction.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="preserveBootVolume")
    def preserve_boot_volume(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to preserve the boot volume that was used to launch the preemptible instance when the instance is terminated. Defaults to false if not specified.
        """
        return pulumi.get(self, "preserve_boot_volume")

    @preserve_boot_volume.setter
    def preserve_boot_volume(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_boot_volume", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsOptionLaunchDetailsShapeConfigArgs:
    def __init__(__self__, *,
                 baseline_ocpu_utilization: Optional[pulumi.Input[str]] = None,
                 memory_in_gbs: Optional[pulumi.Input[float]] = None,
                 nvmes: Optional[pulumi.Input[int]] = None,
                 ocpus: Optional[pulumi.Input[float]] = None,
                 vcpus: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] baseline_ocpu_utilization: The baseline OCPU utilization for a subcore burstable VM instance. Leave this attribute blank for a non-burstable instance, or explicitly specify non-burstable with `BASELINE_1_1`.
               
               The following values are supported:
        :param pulumi.Input[float] memory_in_gbs: The total amount of memory available to the instance, in gigabytes.
        :param pulumi.Input[int] nvmes: The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        :param pulumi.Input[float] ocpus: The total number of OCPUs available to the instance.
        :param pulumi.Input[int] vcpus: The total number of VCPUs available to the instance. This can be used instead of OCPUs, in which case the actual number of OCPUs will be calculated based on this value and the actual hardware. This must be a multiple of 2.
        """
        InstanceConfigurationInstanceDetailsOptionLaunchDetailsShapeConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            baseline_ocpu_utilization=baseline_ocpu_utilization,
            memory_in_gbs=memory_in_gbs,
            nvmes=nvmes,
            ocpus=ocpus,
            vcpus=vcpus,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             baseline_ocpu_utilization: Optional[pulumi.Input[str]] = None,
             memory_in_gbs: Optional[pulumi.Input[float]] = None,
             nvmes: Optional[pulumi.Input[int]] = None,
             ocpus: Optional[pulumi.Input[float]] = None,
             vcpus: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if baseline_ocpu_utilization is not None:
            _setter("baseline_ocpu_utilization", baseline_ocpu_utilization)
        if memory_in_gbs is not None:
            _setter("memory_in_gbs", memory_in_gbs)
        if nvmes is not None:
            _setter("nvmes", nvmes)
        if ocpus is not None:
            _setter("ocpus", ocpus)
        if vcpus is not None:
            _setter("vcpus", vcpus)

    @property
    @pulumi.getter(name="baselineOcpuUtilization")
    def baseline_ocpu_utilization(self) -> Optional[pulumi.Input[str]]:
        """
        The baseline OCPU utilization for a subcore burstable VM instance. Leave this attribute blank for a non-burstable instance, or explicitly specify non-burstable with `BASELINE_1_1`.

        The following values are supported:
        """
        return pulumi.get(self, "baseline_ocpu_utilization")

    @baseline_ocpu_utilization.setter
    def baseline_ocpu_utilization(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "baseline_ocpu_utilization", value)

    @property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[pulumi.Input[float]]:
        """
        The total amount of memory available to the instance, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_in_gbs", value)

    @property
    @pulumi.getter
    def nvmes(self) -> Optional[pulumi.Input[int]]:
        """
        The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        """
        return pulumi.get(self, "nvmes")

    @nvmes.setter
    def nvmes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nvmes", value)

    @property
    @pulumi.getter
    def ocpus(self) -> Optional[pulumi.Input[float]]:
        """
        The total number of OCPUs available to the instance.
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "ocpus", value)

    @property
    @pulumi.getter
    def vcpus(self) -> Optional[pulumi.Input[int]]:
        """
        The total number of VCPUs available to the instance. This can be used instead of OCPUs, in which case the actual number of OCPUs will be calculated based on this value and the actual hardware. This must be a multiple of 2.
        """
        return pulumi.get(self, "vcpus")

    @vcpus.setter
    def vcpus(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vcpus", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsOptionLaunchDetailsSourceDetailsArgs:
    def __init__(__self__, *,
                 source_type: pulumi.Input[str],
                 boot_volume_id: Optional[pulumi.Input[str]] = None,
                 boot_volume_size_in_gbs: Optional[pulumi.Input[str]] = None,
                 boot_volume_vpus_per_gb: Optional[pulumi.Input[str]] = None,
                 image_id: Optional[pulumi.Input[str]] = None,
                 instance_source_image_filter_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsSourceDetailsInstanceSourceImageFilterDetailsArgs']] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] source_type: The source type for the instance. Use `image` when specifying the image OCID. Use `bootVolume` when specifying the boot volume OCID.
        :param pulumi.Input[str] boot_volume_id: The OCID of the boot volume used to boot the instance.
        :param pulumi.Input[str] boot_volume_size_in_gbs: The size of the boot volume in GBs. The minimum value is 50 GB and the maximum value is 32,768 GB (32 TB).
        :param pulumi.Input[str] boot_volume_vpus_per_gb: The number of volume performance units (VPUs) that will be applied to this volume per GB, representing the Block Volume service's elastic performance options. See [Block Volume Performance Levels](https://docs.cloud.oracle.com/iaas/Content/Block/Concepts/blockvolumeperformance.htm#perf_levels) for more information.
               
               Allowed values:
        :param pulumi.Input[str] image_id: The OCID of the image used to boot the instance.
        :param pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsSourceDetailsInstanceSourceImageFilterDetailsArgs'] instance_source_image_filter_details: These are the criteria for selecting an image. This is required if imageId is not specified.
        :param pulumi.Input[str] kms_key_id: The OCID of the Vault service key to assign as the master encryption key for the volume.
        """
        InstanceConfigurationInstanceDetailsOptionLaunchDetailsSourceDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_type=source_type,
            boot_volume_id=boot_volume_id,
            boot_volume_size_in_gbs=boot_volume_size_in_gbs,
            boot_volume_vpus_per_gb=boot_volume_vpus_per_gb,
            image_id=image_id,
            instance_source_image_filter_details=instance_source_image_filter_details,
            kms_key_id=kms_key_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_type: pulumi.Input[str],
             boot_volume_id: Optional[pulumi.Input[str]] = None,
             boot_volume_size_in_gbs: Optional[pulumi.Input[str]] = None,
             boot_volume_vpus_per_gb: Optional[pulumi.Input[str]] = None,
             image_id: Optional[pulumi.Input[str]] = None,
             instance_source_image_filter_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsSourceDetailsInstanceSourceImageFilterDetailsArgs']] = None,
             kms_key_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("source_type", source_type)
        if boot_volume_id is not None:
            _setter("boot_volume_id", boot_volume_id)
        if boot_volume_size_in_gbs is not None:
            _setter("boot_volume_size_in_gbs", boot_volume_size_in_gbs)
        if boot_volume_vpus_per_gb is not None:
            _setter("boot_volume_vpus_per_gb", boot_volume_vpus_per_gb)
        if image_id is not None:
            _setter("image_id", image_id)
        if instance_source_image_filter_details is not None:
            _setter("instance_source_image_filter_details", instance_source_image_filter_details)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[str]:
        """
        The source type for the instance. Use `image` when specifying the image OCID. Use `bootVolume` when specifying the boot volume OCID.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_type", value)

    @property
    @pulumi.getter(name="bootVolumeId")
    def boot_volume_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the boot volume used to boot the instance.
        """
        return pulumi.get(self, "boot_volume_id")

    @boot_volume_id.setter
    def boot_volume_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "boot_volume_id", value)

    @property
    @pulumi.getter(name="bootVolumeSizeInGbs")
    def boot_volume_size_in_gbs(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the boot volume in GBs. The minimum value is 50 GB and the maximum value is 32,768 GB (32 TB).
        """
        return pulumi.get(self, "boot_volume_size_in_gbs")

    @boot_volume_size_in_gbs.setter
    def boot_volume_size_in_gbs(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "boot_volume_size_in_gbs", value)

    @property
    @pulumi.getter(name="bootVolumeVpusPerGb")
    def boot_volume_vpus_per_gb(self) -> Optional[pulumi.Input[str]]:
        """
        The number of volume performance units (VPUs) that will be applied to this volume per GB, representing the Block Volume service's elastic performance options. See [Block Volume Performance Levels](https://docs.cloud.oracle.com/iaas/Content/Block/Concepts/blockvolumeperformance.htm#perf_levels) for more information.

        Allowed values:
        """
        return pulumi.get(self, "boot_volume_vpus_per_gb")

    @boot_volume_vpus_per_gb.setter
    def boot_volume_vpus_per_gb(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "boot_volume_vpus_per_gb", value)

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the image used to boot the instance.
        """
        return pulumi.get(self, "image_id")

    @image_id.setter
    def image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_id", value)

    @property
    @pulumi.getter(name="instanceSourceImageFilterDetails")
    def instance_source_image_filter_details(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsSourceDetailsInstanceSourceImageFilterDetailsArgs']]:
        """
        These are the criteria for selecting an image. This is required if imageId is not specified.
        """
        return pulumi.get(self, "instance_source_image_filter_details")

    @instance_source_image_filter_details.setter
    def instance_source_image_filter_details(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionLaunchDetailsSourceDetailsInstanceSourceImageFilterDetailsArgs']]):
        pulumi.set(self, "instance_source_image_filter_details", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the Vault service key to assign as the master encryption key for the volume.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsOptionLaunchDetailsSourceDetailsInstanceSourceImageFilterDetailsArgs:
    def __init__(__self__, *,
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 defined_tags_filter: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 operating_system: Optional[pulumi.Input[str]] = None,
                 operating_system_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compartment_id: (Updatable) The OCID of the compartment containing images to search
        :param pulumi.Input[Mapping[str, Any]] defined_tags_filter: Filter based on these defined tags. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param pulumi.Input[str] operating_system: The image's operating system.  Example: `Oracle Linux`
        :param pulumi.Input[str] operating_system_version: The image's operating system version.  Example: `7.2`
        """
        InstanceConfigurationInstanceDetailsOptionLaunchDetailsSourceDetailsInstanceSourceImageFilterDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            defined_tags_filter=defined_tags_filter,
            operating_system=operating_system,
            operating_system_version=operating_system_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: Optional[pulumi.Input[str]] = None,
             defined_tags_filter: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             operating_system: Optional[pulumi.Input[str]] = None,
             operating_system_version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if compartment_id is not None:
            _setter("compartment_id", compartment_id)
        if defined_tags_filter is not None:
            _setter("defined_tags_filter", defined_tags_filter)
        if operating_system is not None:
            _setter("operating_system", operating_system)
        if operating_system_version is not None:
            _setter("operating_system_version", operating_system_version)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the compartment containing images to search
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter(name="definedTagsFilter")
    def defined_tags_filter(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Filter based on these defined tags. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags_filter")

    @defined_tags_filter.setter
    def defined_tags_filter(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags_filter", value)

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> Optional[pulumi.Input[str]]:
        """
        The image's operating system.  Example: `Oracle Linux`
        """
        return pulumi.get(self, "operating_system")

    @operating_system.setter
    def operating_system(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operating_system", value)

    @property
    @pulumi.getter(name="operatingSystemVersion")
    def operating_system_version(self) -> Optional[pulumi.Input[str]]:
        """
        The image's operating system version.  Example: `7.2`
        """
        return pulumi.get(self, "operating_system_version")

    @operating_system_version.setter
    def operating_system_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operating_system_version", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsOptionSecondaryVnicArgs:
    def __init__(__self__, *,
                 create_vnic_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionSecondaryVnicCreateVnicDetailsArgs']] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 nic_index: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['InstanceConfigurationInstanceDetailsOptionSecondaryVnicCreateVnicDetailsArgs'] create_vnic_details: Contains the properties of the VNIC for an instance configuration. See [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) and [Instance Configurations](https://docs.cloud.oracle.com/iaas/Content/Compute/Concepts/instancemanagement.htm#config) for more information.
        :param pulumi.Input[str] display_name: A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        :param pulumi.Input[int] nic_index: Which physical network interface card (NIC) the VNIC will use. Defaults to 0. Certain bare metal instance shapes have two active physical NICs (0 and 1). If you add a secondary VNIC to one of these instances, you can specify which NIC the VNIC will use. For more information, see [Virtual Network Interface Cards (VNICs)](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/managingVNICs.htm).
        """
        InstanceConfigurationInstanceDetailsOptionSecondaryVnicArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            create_vnic_details=create_vnic_details,
            display_name=display_name,
            nic_index=nic_index,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             create_vnic_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionSecondaryVnicCreateVnicDetailsArgs']] = None,
             display_name: Optional[pulumi.Input[str]] = None,
             nic_index: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if create_vnic_details is not None:
            _setter("create_vnic_details", create_vnic_details)
        if display_name is not None:
            _setter("display_name", display_name)
        if nic_index is not None:
            _setter("nic_index", nic_index)

    @property
    @pulumi.getter(name="createVnicDetails")
    def create_vnic_details(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionSecondaryVnicCreateVnicDetailsArgs']]:
        """
        Contains the properties of the VNIC for an instance configuration. See [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) and [Instance Configurations](https://docs.cloud.oracle.com/iaas/Content/Compute/Concepts/instancemanagement.htm#config) for more information.
        """
        return pulumi.get(self, "create_vnic_details")

    @create_vnic_details.setter
    def create_vnic_details(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsOptionSecondaryVnicCreateVnicDetailsArgs']]):
        pulumi.set(self, "create_vnic_details", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="nicIndex")
    def nic_index(self) -> Optional[pulumi.Input[int]]:
        """
        Which physical network interface card (NIC) the VNIC will use. Defaults to 0. Certain bare metal instance shapes have two active physical NICs (0 and 1). If you add a secondary VNIC to one of these instances, you can specify which NIC the VNIC will use. For more information, see [Virtual Network Interface Cards (VNICs)](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/managingVNICs.htm).
        """
        return pulumi.get(self, "nic_index")

    @nic_index.setter
    def nic_index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nic_index", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsOptionSecondaryVnicCreateVnicDetailsArgs:
    def __init__(__self__, *,
                 assign_ipv6ip: Optional[pulumi.Input[bool]] = None,
                 assign_private_dns_record: Optional[pulumi.Input[bool]] = None,
                 assign_public_ip: Optional[pulumi.Input[bool]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 hostname_label: Optional[pulumi.Input[str]] = None,
                 ipv6address_ipv6subnet_cidr_pair_details: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionSecondaryVnicCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs']]]] = None,
                 nsg_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 private_ip: Optional[pulumi.Input[str]] = None,
                 skip_source_dest_check: Optional[pulumi.Input[bool]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] assign_ipv6ip: Whether to allocate an IPv6 address at instance and VNIC creation from an IPv6 enabled subnet. Default: False. When provided you may optionally provide an IPv6 prefix (`ipv6SubnetCidr`) of your choice to assign the IPv6 address from. If `ipv6SubnetCidr` is not provided then an IPv6 prefix is chosen for you.
        :param pulumi.Input[bool] assign_private_dns_record: Whether the VNIC should be assigned a private DNS record. See the `assignPrivateDnsRecord` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        :param pulumi.Input[bool] assign_public_ip: Whether the VNIC should be assigned a public IP address. See the `assignPublicIp` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        :param pulumi.Input[Mapping[str, Any]] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        :param pulumi.Input[str] display_name: A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        :param pulumi.Input[Mapping[str, Any]] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param pulumi.Input[str] hostname_label: The hostname for the VNIC's primary private IP. See the `hostnameLabel` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        :param pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionSecondaryVnicCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs']]] ipv6address_ipv6subnet_cidr_pair_details: A list of IPv6 prefix ranges from which the VNIC should be assigned an IPv6 address. You can provide only the prefix ranges and Oracle Cloud Infrastructure selects an available address from the range. You can optionally choose to leave the prefix range empty and instead provide the specific IPv6 address that should be used from within that range.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] nsg_ids: A list of the OCIDs of the network security groups (NSGs) to add the VNIC to. For more information about NSGs, see [NetworkSecurityGroup](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/NetworkSecurityGroup/).
        :param pulumi.Input[str] private_ip: A private IP address of your choice to assign to the VNIC. See the `privateIp` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        :param pulumi.Input[bool] skip_source_dest_check: Whether the source/destination check is disabled on the VNIC. See the `skipSourceDestCheck` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        :param pulumi.Input[str] subnet_id: The OCID of the subnet to create the VNIC in. See the `subnetId` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        InstanceConfigurationInstanceDetailsOptionSecondaryVnicCreateVnicDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            assign_ipv6ip=assign_ipv6ip,
            assign_private_dns_record=assign_private_dns_record,
            assign_public_ip=assign_public_ip,
            defined_tags=defined_tags,
            display_name=display_name,
            freeform_tags=freeform_tags,
            hostname_label=hostname_label,
            ipv6address_ipv6subnet_cidr_pair_details=ipv6address_ipv6subnet_cidr_pair_details,
            nsg_ids=nsg_ids,
            private_ip=private_ip,
            skip_source_dest_check=skip_source_dest_check,
            subnet_id=subnet_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             assign_ipv6ip: Optional[pulumi.Input[bool]] = None,
             assign_private_dns_record: Optional[pulumi.Input[bool]] = None,
             assign_public_ip: Optional[pulumi.Input[bool]] = None,
             defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             display_name: Optional[pulumi.Input[str]] = None,
             freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             hostname_label: Optional[pulumi.Input[str]] = None,
             ipv6address_ipv6subnet_cidr_pair_details: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionSecondaryVnicCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs']]]] = None,
             nsg_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             private_ip: Optional[pulumi.Input[str]] = None,
             skip_source_dest_check: Optional[pulumi.Input[bool]] = None,
             subnet_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if assign_ipv6ip is not None:
            _setter("assign_ipv6ip", assign_ipv6ip)
        if assign_private_dns_record is not None:
            _setter("assign_private_dns_record", assign_private_dns_record)
        if assign_public_ip is not None:
            _setter("assign_public_ip", assign_public_ip)
        if defined_tags is not None:
            _setter("defined_tags", defined_tags)
        if display_name is not None:
            _setter("display_name", display_name)
        if freeform_tags is not None:
            _setter("freeform_tags", freeform_tags)
        if hostname_label is not None:
            _setter("hostname_label", hostname_label)
        if ipv6address_ipv6subnet_cidr_pair_details is not None:
            _setter("ipv6address_ipv6subnet_cidr_pair_details", ipv6address_ipv6subnet_cidr_pair_details)
        if nsg_ids is not None:
            _setter("nsg_ids", nsg_ids)
        if private_ip is not None:
            _setter("private_ip", private_ip)
        if skip_source_dest_check is not None:
            _setter("skip_source_dest_check", skip_source_dest_check)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)

    @property
    @pulumi.getter(name="assignIpv6ip")
    def assign_ipv6ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allocate an IPv6 address at instance and VNIC creation from an IPv6 enabled subnet. Default: False. When provided you may optionally provide an IPv6 prefix (`ipv6SubnetCidr`) of your choice to assign the IPv6 address from. If `ipv6SubnetCidr` is not provided then an IPv6 prefix is chosen for you.
        """
        return pulumi.get(self, "assign_ipv6ip")

    @assign_ipv6ip.setter
    def assign_ipv6ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_ipv6ip", value)

    @property
    @pulumi.getter(name="assignPrivateDnsRecord")
    def assign_private_dns_record(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the VNIC should be assigned a private DNS record. See the `assignPrivateDnsRecord` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "assign_private_dns_record")

    @assign_private_dns_record.setter
    def assign_private_dns_record(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_private_dns_record", value)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the VNIC should be assigned a public IP address. See the `assignPublicIp` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_public_ip", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter(name="hostnameLabel")
    def hostname_label(self) -> Optional[pulumi.Input[str]]:
        """
        The hostname for the VNIC's primary private IP. See the `hostnameLabel` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "hostname_label")

    @hostname_label.setter
    def hostname_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname_label", value)

    @property
    @pulumi.getter(name="ipv6addressIpv6subnetCidrPairDetails")
    def ipv6address_ipv6subnet_cidr_pair_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionSecondaryVnicCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs']]]]:
        """
        A list of IPv6 prefix ranges from which the VNIC should be assigned an IPv6 address. You can provide only the prefix ranges and Oracle Cloud Infrastructure selects an available address from the range. You can optionally choose to leave the prefix range empty and instead provide the specific IPv6 address that should be used from within that range.
        """
        return pulumi.get(self, "ipv6address_ipv6subnet_cidr_pair_details")

    @ipv6address_ipv6subnet_cidr_pair_details.setter
    def ipv6address_ipv6subnet_cidr_pair_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsOptionSecondaryVnicCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs']]]]):
        pulumi.set(self, "ipv6address_ipv6subnet_cidr_pair_details", value)

    @property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of the OCIDs of the network security groups (NSGs) to add the VNIC to. For more information about NSGs, see [NetworkSecurityGroup](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/NetworkSecurityGroup/).
        """
        return pulumi.get(self, "nsg_ids")

    @nsg_ids.setter
    def nsg_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "nsg_ids", value)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[str]]:
        """
        A private IP address of your choice to assign to the VNIC. See the `privateIp` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_ip", value)

    @property
    @pulumi.getter(name="skipSourceDestCheck")
    def skip_source_dest_check(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the source/destination check is disabled on the VNIC. See the `skipSourceDestCheck` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "skip_source_dest_check")

    @skip_source_dest_check.setter
    def skip_source_dest_check(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_source_dest_check", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the subnet to create the VNIC in. See the `subnetId` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsOptionSecondaryVnicCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs:
    def __init__(__self__, *,
                 ipv6address: Optional[pulumi.Input[str]] = None,
                 ipv6subnet_cidr: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ipv6address: Optional. An available IPv6 address of your subnet from a valid IPv6 prefix on the subnet (otherwise the IP address is automatically assigned).
        :param pulumi.Input[str] ipv6subnet_cidr: Optional. Used to disambiguate which subnet prefix should be used to create an IPv6 allocation.
        """
        InstanceConfigurationInstanceDetailsOptionSecondaryVnicCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ipv6address=ipv6address,
            ipv6subnet_cidr=ipv6subnet_cidr,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ipv6address: Optional[pulumi.Input[str]] = None,
             ipv6subnet_cidr: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ipv6address is not None:
            _setter("ipv6address", ipv6address)
        if ipv6subnet_cidr is not None:
            _setter("ipv6subnet_cidr", ipv6subnet_cidr)

    @property
    @pulumi.getter
    def ipv6address(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. An available IPv6 address of your subnet from a valid IPv6 prefix on the subnet (otherwise the IP address is automatically assigned).
        """
        return pulumi.get(self, "ipv6address")

    @ipv6address.setter
    def ipv6address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6address", value)

    @property
    @pulumi.getter(name="ipv6subnetCidr")
    def ipv6subnet_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Used to disambiguate which subnet prefix should be used to create an IPv6 allocation.
        """
        return pulumi.get(self, "ipv6subnet_cidr")

    @ipv6subnet_cidr.setter
    def ipv6subnet_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6subnet_cidr", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsSecondaryVnicArgs:
    def __init__(__self__, *,
                 create_vnic_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsSecondaryVnicCreateVnicDetailsArgs']] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 nic_index: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['InstanceConfigurationInstanceDetailsSecondaryVnicCreateVnicDetailsArgs'] create_vnic_details: Contains the properties of the VNIC for an instance configuration. See [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) and [Instance Configurations](https://docs.cloud.oracle.com/iaas/Content/Compute/Concepts/instancemanagement.htm#config) for more information.
        :param pulumi.Input[str] display_name: A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        :param pulumi.Input[int] nic_index: Which physical network interface card (NIC) the VNIC will use. Defaults to 0. Certain bare metal instance shapes have two active physical NICs (0 and 1). If you add a secondary VNIC to one of these instances, you can specify which NIC the VNIC will use. For more information, see [Virtual Network Interface Cards (VNICs)](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/managingVNICs.htm).
        """
        InstanceConfigurationInstanceDetailsSecondaryVnicArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            create_vnic_details=create_vnic_details,
            display_name=display_name,
            nic_index=nic_index,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             create_vnic_details: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsSecondaryVnicCreateVnicDetailsArgs']] = None,
             display_name: Optional[pulumi.Input[str]] = None,
             nic_index: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if create_vnic_details is not None:
            _setter("create_vnic_details", create_vnic_details)
        if display_name is not None:
            _setter("display_name", display_name)
        if nic_index is not None:
            _setter("nic_index", nic_index)

    @property
    @pulumi.getter(name="createVnicDetails")
    def create_vnic_details(self) -> Optional[pulumi.Input['InstanceConfigurationInstanceDetailsSecondaryVnicCreateVnicDetailsArgs']]:
        """
        Contains the properties of the VNIC for an instance configuration. See [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) and [Instance Configurations](https://docs.cloud.oracle.com/iaas/Content/Compute/Concepts/instancemanagement.htm#config) for more information.
        """
        return pulumi.get(self, "create_vnic_details")

    @create_vnic_details.setter
    def create_vnic_details(self, value: Optional[pulumi.Input['InstanceConfigurationInstanceDetailsSecondaryVnicCreateVnicDetailsArgs']]):
        pulumi.set(self, "create_vnic_details", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="nicIndex")
    def nic_index(self) -> Optional[pulumi.Input[int]]:
        """
        Which physical network interface card (NIC) the VNIC will use. Defaults to 0. Certain bare metal instance shapes have two active physical NICs (0 and 1). If you add a secondary VNIC to one of these instances, you can specify which NIC the VNIC will use. For more information, see [Virtual Network Interface Cards (VNICs)](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/managingVNICs.htm).
        """
        return pulumi.get(self, "nic_index")

    @nic_index.setter
    def nic_index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nic_index", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsSecondaryVnicCreateVnicDetailsArgs:
    def __init__(__self__, *,
                 assign_ipv6ip: Optional[pulumi.Input[bool]] = None,
                 assign_private_dns_record: Optional[pulumi.Input[bool]] = None,
                 assign_public_ip: Optional[pulumi.Input[bool]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 hostname_label: Optional[pulumi.Input[str]] = None,
                 ipv6address_ipv6subnet_cidr_pair_details: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsSecondaryVnicCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs']]]] = None,
                 nsg_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 private_ip: Optional[pulumi.Input[str]] = None,
                 skip_source_dest_check: Optional[pulumi.Input[bool]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] assign_ipv6ip: Whether to allocate an IPv6 address at instance and VNIC creation from an IPv6 enabled subnet. Default: False. When provided you may optionally provide an IPv6 prefix (`ipv6SubnetCidr`) of your choice to assign the IPv6 address from. If `ipv6SubnetCidr` is not provided then an IPv6 prefix is chosen for you.
        :param pulumi.Input[bool] assign_private_dns_record: Whether the VNIC should be assigned a private DNS record. See the `assignPrivateDnsRecord` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        :param pulumi.Input[bool] assign_public_ip: Whether the VNIC should be assigned a public IP address. See the `assignPublicIp` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        :param pulumi.Input[Mapping[str, Any]] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        :param pulumi.Input[str] display_name: A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        :param pulumi.Input[Mapping[str, Any]] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param pulumi.Input[str] hostname_label: The hostname for the VNIC's primary private IP. See the `hostnameLabel` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        :param pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsSecondaryVnicCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs']]] ipv6address_ipv6subnet_cidr_pair_details: A list of IPv6 prefix ranges from which the VNIC should be assigned an IPv6 address. You can provide only the prefix ranges and Oracle Cloud Infrastructure selects an available address from the range. You can optionally choose to leave the prefix range empty and instead provide the specific IPv6 address that should be used from within that range.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] nsg_ids: A list of the OCIDs of the network security groups (NSGs) to add the VNIC to. For more information about NSGs, see [NetworkSecurityGroup](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/NetworkSecurityGroup/).
        :param pulumi.Input[str] private_ip: A private IP address of your choice to assign to the VNIC. See the `privateIp` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        :param pulumi.Input[bool] skip_source_dest_check: Whether the source/destination check is disabled on the VNIC. See the `skipSourceDestCheck` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        :param pulumi.Input[str] subnet_id: The OCID of the subnet to create the VNIC in. See the `subnetId` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        InstanceConfigurationInstanceDetailsSecondaryVnicCreateVnicDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            assign_ipv6ip=assign_ipv6ip,
            assign_private_dns_record=assign_private_dns_record,
            assign_public_ip=assign_public_ip,
            defined_tags=defined_tags,
            display_name=display_name,
            freeform_tags=freeform_tags,
            hostname_label=hostname_label,
            ipv6address_ipv6subnet_cidr_pair_details=ipv6address_ipv6subnet_cidr_pair_details,
            nsg_ids=nsg_ids,
            private_ip=private_ip,
            skip_source_dest_check=skip_source_dest_check,
            subnet_id=subnet_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             assign_ipv6ip: Optional[pulumi.Input[bool]] = None,
             assign_private_dns_record: Optional[pulumi.Input[bool]] = None,
             assign_public_ip: Optional[pulumi.Input[bool]] = None,
             defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             display_name: Optional[pulumi.Input[str]] = None,
             freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             hostname_label: Optional[pulumi.Input[str]] = None,
             ipv6address_ipv6subnet_cidr_pair_details: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsSecondaryVnicCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs']]]] = None,
             nsg_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             private_ip: Optional[pulumi.Input[str]] = None,
             skip_source_dest_check: Optional[pulumi.Input[bool]] = None,
             subnet_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if assign_ipv6ip is not None:
            _setter("assign_ipv6ip", assign_ipv6ip)
        if assign_private_dns_record is not None:
            _setter("assign_private_dns_record", assign_private_dns_record)
        if assign_public_ip is not None:
            _setter("assign_public_ip", assign_public_ip)
        if defined_tags is not None:
            _setter("defined_tags", defined_tags)
        if display_name is not None:
            _setter("display_name", display_name)
        if freeform_tags is not None:
            _setter("freeform_tags", freeform_tags)
        if hostname_label is not None:
            _setter("hostname_label", hostname_label)
        if ipv6address_ipv6subnet_cidr_pair_details is not None:
            _setter("ipv6address_ipv6subnet_cidr_pair_details", ipv6address_ipv6subnet_cidr_pair_details)
        if nsg_ids is not None:
            _setter("nsg_ids", nsg_ids)
        if private_ip is not None:
            _setter("private_ip", private_ip)
        if skip_source_dest_check is not None:
            _setter("skip_source_dest_check", skip_source_dest_check)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)

    @property
    @pulumi.getter(name="assignIpv6ip")
    def assign_ipv6ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allocate an IPv6 address at instance and VNIC creation from an IPv6 enabled subnet. Default: False. When provided you may optionally provide an IPv6 prefix (`ipv6SubnetCidr`) of your choice to assign the IPv6 address from. If `ipv6SubnetCidr` is not provided then an IPv6 prefix is chosen for you.
        """
        return pulumi.get(self, "assign_ipv6ip")

    @assign_ipv6ip.setter
    def assign_ipv6ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_ipv6ip", value)

    @property
    @pulumi.getter(name="assignPrivateDnsRecord")
    def assign_private_dns_record(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the VNIC should be assigned a private DNS record. See the `assignPrivateDnsRecord` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "assign_private_dns_record")

    @assign_private_dns_record.setter
    def assign_private_dns_record(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_private_dns_record", value)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the VNIC should be assigned a public IP address. See the `assignPublicIp` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_public_ip", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter(name="hostnameLabel")
    def hostname_label(self) -> Optional[pulumi.Input[str]]:
        """
        The hostname for the VNIC's primary private IP. See the `hostnameLabel` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "hostname_label")

    @hostname_label.setter
    def hostname_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname_label", value)

    @property
    @pulumi.getter(name="ipv6addressIpv6subnetCidrPairDetails")
    def ipv6address_ipv6subnet_cidr_pair_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsSecondaryVnicCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs']]]]:
        """
        A list of IPv6 prefix ranges from which the VNIC should be assigned an IPv6 address. You can provide only the prefix ranges and Oracle Cloud Infrastructure selects an available address from the range. You can optionally choose to leave the prefix range empty and instead provide the specific IPv6 address that should be used from within that range.
        """
        return pulumi.get(self, "ipv6address_ipv6subnet_cidr_pair_details")

    @ipv6address_ipv6subnet_cidr_pair_details.setter
    def ipv6address_ipv6subnet_cidr_pair_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceConfigurationInstanceDetailsSecondaryVnicCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs']]]]):
        pulumi.set(self, "ipv6address_ipv6subnet_cidr_pair_details", value)

    @property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of the OCIDs of the network security groups (NSGs) to add the VNIC to. For more information about NSGs, see [NetworkSecurityGroup](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/NetworkSecurityGroup/).
        """
        return pulumi.get(self, "nsg_ids")

    @nsg_ids.setter
    def nsg_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "nsg_ids", value)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[str]]:
        """
        A private IP address of your choice to assign to the VNIC. See the `privateIp` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_ip", value)

    @property
    @pulumi.getter(name="skipSourceDestCheck")
    def skip_source_dest_check(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the source/destination check is disabled on the VNIC. See the `skipSourceDestCheck` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "skip_source_dest_check")

    @skip_source_dest_check.setter
    def skip_source_dest_check(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_source_dest_check", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the subnet to create the VNIC in. See the `subnetId` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


@pulumi.input_type
class InstanceConfigurationInstanceDetailsSecondaryVnicCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs:
    def __init__(__self__, *,
                 ipv6address: Optional[pulumi.Input[str]] = None,
                 ipv6subnet_cidr: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ipv6address: Optional. An available IPv6 address of your subnet from a valid IPv6 prefix on the subnet (otherwise the IP address is automatically assigned).
        :param pulumi.Input[str] ipv6subnet_cidr: Optional. Used to disambiguate which subnet prefix should be used to create an IPv6 allocation.
        """
        InstanceConfigurationInstanceDetailsSecondaryVnicCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ipv6address=ipv6address,
            ipv6subnet_cidr=ipv6subnet_cidr,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ipv6address: Optional[pulumi.Input[str]] = None,
             ipv6subnet_cidr: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ipv6address is not None:
            _setter("ipv6address", ipv6address)
        if ipv6subnet_cidr is not None:
            _setter("ipv6subnet_cidr", ipv6subnet_cidr)

    @property
    @pulumi.getter
    def ipv6address(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. An available IPv6 address of your subnet from a valid IPv6 prefix on the subnet (otherwise the IP address is automatically assigned).
        """
        return pulumi.get(self, "ipv6address")

    @ipv6address.setter
    def ipv6address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6address", value)

    @property
    @pulumi.getter(name="ipv6subnetCidr")
    def ipv6subnet_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. Used to disambiguate which subnet prefix should be used to create an IPv6 allocation.
        """
        return pulumi.get(self, "ipv6subnet_cidr")

    @ipv6subnet_cidr.setter
    def ipv6subnet_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6subnet_cidr", value)


@pulumi.input_type
class InstanceCreateVnicDetailsArgs:
    def __init__(__self__, *,
                 assign_ipv6ip: Optional[pulumi.Input[bool]] = None,
                 assign_private_dns_record: Optional[pulumi.Input[bool]] = None,
                 assign_public_ip: Optional[pulumi.Input[str]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 hostname_label: Optional[pulumi.Input[str]] = None,
                 ipv6address_ipv6subnet_cidr_pair_details: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs']]]] = None,
                 nsg_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 private_ip: Optional[pulumi.Input[str]] = None,
                 skip_source_dest_check: Optional[pulumi.Input[bool]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 vlan_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] assign_ipv6ip: Whether to allocate an IPv6 address at instance and VNIC creation from an IPv6 enabled subnet. Default: False. When provided you may optionally provide an IPv6 prefix (`ipv6SubnetCidr`) of your choice to assign the IPv6 address from. If `ipv6SubnetCidr` is not provided then an IPv6 prefix is chosen for you.
        :param pulumi.Input[bool] assign_private_dns_record: Whether the VNIC should be assigned a DNS record. If set to false, there will be no DNS record registration for the VNIC. If set to true, the DNS record will be registered. The default value is true.
               If you specify a `hostnameLabel`, the `assignPrivateDnsRecord` is require to be set to true.
        :param pulumi.Input[str] assign_public_ip: (Updatable) Whether the VNIC should be assigned a public IP address. Defaults to whether the subnet is public or private. If not set and the VNIC is being created in a private subnet (that is, where `prohibitPublicIpOnVnic` = true in the [Subnet](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Subnet/)), then no public IP address is assigned. If not set and the subnet is public (`prohibitPublicIpOnVnic` = false), then a public IP address is assigned. If set to true and `prohibitPublicIpOnVnic` = true, an error is returned.
               
               **Note:** This public IP address is associated with the primary private IP on the VNIC. For more information, see [IP Addresses](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/managingIPaddresses.htm).
               
               **Note:** There's a limit to the number of [public IPs](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PublicIp/) a VNIC or instance can have. If you try to create a secondary VNIC with an assigned public IP for an instance that has already reached its public IP limit, an error is returned. For information about the public IP limits, see [Public IP Addresses](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/managingpublicIPs.htm).
               
               Example: `false`
               
               If you specify a `vlanId`, then `assignPublicIp` must be set to false. See [Vlan](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vlan).
        :param pulumi.Input[Mapping[str, Any]] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        :param pulumi.Input[str] display_name: (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        :param pulumi.Input[Mapping[str, Any]] freeform_tags: (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param pulumi.Input[str] hostname_label: Deprecated. Instead use `hostnameLabel` in [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/). If you provide both, the values must match.
        :param pulumi.Input[Sequence[pulumi.Input['InstanceCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs']]] ipv6address_ipv6subnet_cidr_pair_details: A list of IPv6 prefix ranges from which the VNIC should be assigned an IPv6 address. You can provide only the prefix ranges from which Oracle Cloud Infrastructure will select an available address from the range. You can optionally choose to leave the prefix range empty and instead provide the specific IPv6 address that should be used from within that range.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] nsg_ids: (Updatable) A list of the OCIDs of the network security groups (NSGs) to add the VNIC to. For more information about NSGs, see [NetworkSecurityGroup](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/NetworkSecurityGroup/).
               
               If a `vlanId` is specified, the `nsgIds` cannot be specified. The `vlanId` indicates that the VNIC will belong to a VLAN instead of a subnet. With VLANs, all VNICs in the VLAN belong to the NSGs that are associated with the VLAN. See [Vlan](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vlan).
        :param pulumi.Input[str] private_ip: A private IP address of your choice to assign to the VNIC. Must be an available IP address within the subnet's CIDR. If you don't specify a value, Oracle automatically assigns a private IP address from the subnet. This is the VNIC's *primary* private IP address. The value appears in the [Vnic](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vnic/) object and also the [PrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/) object returned by [ListPrivateIps](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/ListPrivateIps) and [GetPrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/GetPrivateIp).
               
               If you specify a `vlanId`, the `privateIp` cannot be specified. See [Vlan](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vlan).
               
               Example: `10.0.3.3`
        :param pulumi.Input[bool] skip_source_dest_check: (Updatable) Whether the source/destination check is disabled on the VNIC. Defaults to `false`, which means the check is performed. For information about why you would skip the source/destination check, see [Using a Private IP as a Route Target](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/managingroutetables.htm#privateip).
               
               If you specify a `vlanId`, the `skipSourceDestCheck` cannot be specified because the source/destination check is always disabled for VNICs in a VLAN. See [Vlan](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vlan).
               
               Example: `true`
        :param pulumi.Input[str] subnet_id: Deprecated. Instead use `subnetId` in [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/). At least one of them is required; if you provide both, the values must match.
        :param pulumi.Input[str] vlan_id: Provide this attribute only if you are an Oracle Cloud VMware Solution customer and creating a secondary VNIC in a VLAN. The value is the [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VLAN. See [Vlan](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vlan).
               
               Provide a `vlanId` instead of a `subnetId`. If you provide both a `vlanId` and `subnetId`, the request fails.
        """
        InstanceCreateVnicDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            assign_ipv6ip=assign_ipv6ip,
            assign_private_dns_record=assign_private_dns_record,
            assign_public_ip=assign_public_ip,
            defined_tags=defined_tags,
            display_name=display_name,
            freeform_tags=freeform_tags,
            hostname_label=hostname_label,
            ipv6address_ipv6subnet_cidr_pair_details=ipv6address_ipv6subnet_cidr_pair_details,
            nsg_ids=nsg_ids,
            private_ip=private_ip,
            skip_source_dest_check=skip_source_dest_check,
            subnet_id=subnet_id,
            vlan_id=vlan_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             assign_ipv6ip: Optional[pulumi.Input[bool]] = None,
             assign_private_dns_record: Optional[pulumi.Input[bool]] = None,
             assign_public_ip: Optional[pulumi.Input[str]] = None,
             defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             display_name: Optional[pulumi.Input[str]] = None,
             freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             hostname_label: Optional[pulumi.Input[str]] = None,
             ipv6address_ipv6subnet_cidr_pair_details: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs']]]] = None,
             nsg_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             private_ip: Optional[pulumi.Input[str]] = None,
             skip_source_dest_check: Optional[pulumi.Input[bool]] = None,
             subnet_id: Optional[pulumi.Input[str]] = None,
             vlan_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if assign_ipv6ip is not None:
            _setter("assign_ipv6ip", assign_ipv6ip)
        if assign_private_dns_record is not None:
            _setter("assign_private_dns_record", assign_private_dns_record)
        if assign_public_ip is not None:
            _setter("assign_public_ip", assign_public_ip)
        if defined_tags is not None:
            _setter("defined_tags", defined_tags)
        if display_name is not None:
            _setter("display_name", display_name)
        if freeform_tags is not None:
            _setter("freeform_tags", freeform_tags)
        if hostname_label is not None:
            _setter("hostname_label", hostname_label)
        if ipv6address_ipv6subnet_cidr_pair_details is not None:
            _setter("ipv6address_ipv6subnet_cidr_pair_details", ipv6address_ipv6subnet_cidr_pair_details)
        if nsg_ids is not None:
            _setter("nsg_ids", nsg_ids)
        if private_ip is not None:
            _setter("private_ip", private_ip)
        if skip_source_dest_check is not None:
            _setter("skip_source_dest_check", skip_source_dest_check)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)
        if vlan_id is not None:
            _setter("vlan_id", vlan_id)

    @property
    @pulumi.getter(name="assignIpv6ip")
    def assign_ipv6ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allocate an IPv6 address at instance and VNIC creation from an IPv6 enabled subnet. Default: False. When provided you may optionally provide an IPv6 prefix (`ipv6SubnetCidr`) of your choice to assign the IPv6 address from. If `ipv6SubnetCidr` is not provided then an IPv6 prefix is chosen for you.
        """
        return pulumi.get(self, "assign_ipv6ip")

    @assign_ipv6ip.setter
    def assign_ipv6ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_ipv6ip", value)

    @property
    @pulumi.getter(name="assignPrivateDnsRecord")
    def assign_private_dns_record(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the VNIC should be assigned a DNS record. If set to false, there will be no DNS record registration for the VNIC. If set to true, the DNS record will be registered. The default value is true.
        If you specify a `hostnameLabel`, the `assignPrivateDnsRecord` is require to be set to true.
        """
        return pulumi.get(self, "assign_private_dns_record")

    @assign_private_dns_record.setter
    def assign_private_dns_record(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_private_dns_record", value)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Whether the VNIC should be assigned a public IP address. Defaults to whether the subnet is public or private. If not set and the VNIC is being created in a private subnet (that is, where `prohibitPublicIpOnVnic` = true in the [Subnet](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Subnet/)), then no public IP address is assigned. If not set and the subnet is public (`prohibitPublicIpOnVnic` = false), then a public IP address is assigned. If set to true and `prohibitPublicIpOnVnic` = true, an error is returned.

        **Note:** This public IP address is associated with the primary private IP on the VNIC. For more information, see [IP Addresses](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/managingIPaddresses.htm).

        **Note:** There's a limit to the number of [public IPs](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PublicIp/) a VNIC or instance can have. If you try to create a secondary VNIC with an assigned public IP for an instance that has already reached its public IP limit, an error is returned. For information about the public IP limits, see [Public IP Addresses](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/managingpublicIPs.htm).

        Example: `false`

        If you specify a `vlanId`, then `assignPublicIp` must be set to false. See [Vlan](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vlan).
        """
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "assign_public_ip", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter(name="hostnameLabel")
    def hostname_label(self) -> Optional[pulumi.Input[str]]:
        """
        Deprecated. Instead use `hostnameLabel` in [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/). If you provide both, the values must match.
        """
        return pulumi.get(self, "hostname_label")

    @hostname_label.setter
    def hostname_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname_label", value)

    @property
    @pulumi.getter(name="ipv6addressIpv6subnetCidrPairDetails")
    def ipv6address_ipv6subnet_cidr_pair_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs']]]]:
        """
        A list of IPv6 prefix ranges from which the VNIC should be assigned an IPv6 address. You can provide only the prefix ranges from which Oracle Cloud Infrastructure will select an available address from the range. You can optionally choose to leave the prefix range empty and instead provide the specific IPv6 address that should be used from within that range.
        """
        return pulumi.get(self, "ipv6address_ipv6subnet_cidr_pair_details")

    @ipv6address_ipv6subnet_cidr_pair_details.setter
    def ipv6address_ipv6subnet_cidr_pair_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs']]]]):
        pulumi.set(self, "ipv6address_ipv6subnet_cidr_pair_details", value)

    @property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) A list of the OCIDs of the network security groups (NSGs) to add the VNIC to. For more information about NSGs, see [NetworkSecurityGroup](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/NetworkSecurityGroup/).

        If a `vlanId` is specified, the `nsgIds` cannot be specified. The `vlanId` indicates that the VNIC will belong to a VLAN instead of a subnet. With VLANs, all VNICs in the VLAN belong to the NSGs that are associated with the VLAN. See [Vlan](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vlan).
        """
        return pulumi.get(self, "nsg_ids")

    @nsg_ids.setter
    def nsg_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "nsg_ids", value)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[str]]:
        """
        A private IP address of your choice to assign to the VNIC. Must be an available IP address within the subnet's CIDR. If you don't specify a value, Oracle automatically assigns a private IP address from the subnet. This is the VNIC's *primary* private IP address. The value appears in the [Vnic](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vnic/) object and also the [PrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/) object returned by [ListPrivateIps](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/ListPrivateIps) and [GetPrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/GetPrivateIp).

        If you specify a `vlanId`, the `privateIp` cannot be specified. See [Vlan](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vlan).

        Example: `10.0.3.3`
        """
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_ip", value)

    @property
    @pulumi.getter(name="skipSourceDestCheck")
    def skip_source_dest_check(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether the source/destination check is disabled on the VNIC. Defaults to `false`, which means the check is performed. For information about why you would skip the source/destination check, see [Using a Private IP as a Route Target](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/managingroutetables.htm#privateip).

        If you specify a `vlanId`, the `skipSourceDestCheck` cannot be specified because the source/destination check is always disabled for VNICs in a VLAN. See [Vlan](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vlan).

        Example: `true`
        """
        return pulumi.get(self, "skip_source_dest_check")

    @skip_source_dest_check.setter
    def skip_source_dest_check(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_source_dest_check", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        Deprecated. Instead use `subnetId` in [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/). At least one of them is required; if you provide both, the values must match.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[str]]:
        """
        Provide this attribute only if you are an Oracle Cloud VMware Solution customer and creating a secondary VNIC in a VLAN. The value is the [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VLAN. See [Vlan](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vlan).

        Provide a `vlanId` instead of a `subnetId`. If you provide both a `vlanId` and `subnetId`, the request fails.
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vlan_id", value)


@pulumi.input_type
class InstanceCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs:
    def __init__(__self__, *,
                 ipv6address: Optional[pulumi.Input[str]] = None,
                 ipv6subnet_cidr: Optional[pulumi.Input[str]] = None):
        InstanceCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ipv6address=ipv6address,
            ipv6subnet_cidr=ipv6subnet_cidr,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ipv6address: Optional[pulumi.Input[str]] = None,
             ipv6subnet_cidr: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ipv6address is not None:
            _setter("ipv6address", ipv6address)
        if ipv6subnet_cidr is not None:
            _setter("ipv6subnet_cidr", ipv6subnet_cidr)

    @property
    @pulumi.getter
    def ipv6address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ipv6address")

    @ipv6address.setter
    def ipv6address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6address", value)

    @property
    @pulumi.getter(name="ipv6subnetCidr")
    def ipv6subnet_cidr(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ipv6subnet_cidr")

    @ipv6subnet_cidr.setter
    def ipv6subnet_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6subnet_cidr", value)


@pulumi.input_type
class InstanceInstanceOptionsArgs:
    def __init__(__self__, *,
                 are_legacy_imds_endpoints_disabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] are_legacy_imds_endpoints_disabled: (Updatable) Whether to disable the legacy (/v1) instance metadata service endpoints. Customers who have migrated to /v2 should set this to true for added security. Default is false.
        """
        InstanceInstanceOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            are_legacy_imds_endpoints_disabled=are_legacy_imds_endpoints_disabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             are_legacy_imds_endpoints_disabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if are_legacy_imds_endpoints_disabled is not None:
            _setter("are_legacy_imds_endpoints_disabled", are_legacy_imds_endpoints_disabled)

    @property
    @pulumi.getter(name="areLegacyImdsEndpointsDisabled")
    def are_legacy_imds_endpoints_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether to disable the legacy (/v1) instance metadata service endpoints. Customers who have migrated to /v2 should set this to true for added security. Default is false.
        """
        return pulumi.get(self, "are_legacy_imds_endpoints_disabled")

    @are_legacy_imds_endpoints_disabled.setter
    def are_legacy_imds_endpoints_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "are_legacy_imds_endpoints_disabled", value)


@pulumi.input_type
class InstanceLaunchOptionsArgs:
    def __init__(__self__, *,
                 boot_volume_type: Optional[pulumi.Input[str]] = None,
                 firmware: Optional[pulumi.Input[str]] = None,
                 is_consistent_volume_naming_enabled: Optional[pulumi.Input[bool]] = None,
                 is_pv_encryption_in_transit_enabled: Optional[pulumi.Input[bool]] = None,
                 network_type: Optional[pulumi.Input[str]] = None,
                 remote_data_volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] boot_volume_type: (Updatable) Emulation type for the boot volume.
        :param pulumi.Input[str] firmware: Firmware used to boot VM. Select the option that matches your operating system.
        :param pulumi.Input[bool] is_consistent_volume_naming_enabled: Whether to enable consistent volume naming feature. Defaults to false.
        :param pulumi.Input[bool] is_pv_encryption_in_transit_enabled: (Updatable) Use this for update operation only. This field is  Deprecated during create. For create use `isPvEncryptionInTransitEnabled` in [LaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/datatypes/LaunchInstanceDetails).
        :param pulumi.Input[str] network_type: (Updatable) Emulation type for the physical network interface card (NIC).
        :param pulumi.Input[str] remote_data_volume_type: Emulation type for volume.
        """
        InstanceLaunchOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            boot_volume_type=boot_volume_type,
            firmware=firmware,
            is_consistent_volume_naming_enabled=is_consistent_volume_naming_enabled,
            is_pv_encryption_in_transit_enabled=is_pv_encryption_in_transit_enabled,
            network_type=network_type,
            remote_data_volume_type=remote_data_volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             boot_volume_type: Optional[pulumi.Input[str]] = None,
             firmware: Optional[pulumi.Input[str]] = None,
             is_consistent_volume_naming_enabled: Optional[pulumi.Input[bool]] = None,
             is_pv_encryption_in_transit_enabled: Optional[pulumi.Input[bool]] = None,
             network_type: Optional[pulumi.Input[str]] = None,
             remote_data_volume_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if boot_volume_type is not None:
            _setter("boot_volume_type", boot_volume_type)
        if firmware is not None:
            _setter("firmware", firmware)
        if is_consistent_volume_naming_enabled is not None:
            _setter("is_consistent_volume_naming_enabled", is_consistent_volume_naming_enabled)
        if is_pv_encryption_in_transit_enabled is not None:
            _setter("is_pv_encryption_in_transit_enabled", is_pv_encryption_in_transit_enabled)
        if network_type is not None:
            _setter("network_type", network_type)
        if remote_data_volume_type is not None:
            _setter("remote_data_volume_type", remote_data_volume_type)

    @property
    @pulumi.getter(name="bootVolumeType")
    def boot_volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Emulation type for the boot volume.
        """
        return pulumi.get(self, "boot_volume_type")

    @boot_volume_type.setter
    def boot_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "boot_volume_type", value)

    @property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[str]]:
        """
        Firmware used to boot VM. Select the option that matches your operating system.
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "firmware", value)

    @property
    @pulumi.getter(name="isConsistentVolumeNamingEnabled")
    def is_consistent_volume_naming_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable consistent volume naming feature. Defaults to false.
        """
        return pulumi.get(self, "is_consistent_volume_naming_enabled")

    @is_consistent_volume_naming_enabled.setter
    def is_consistent_volume_naming_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_consistent_volume_naming_enabled", value)

    @property
    @pulumi.getter(name="isPvEncryptionInTransitEnabled")
    def is_pv_encryption_in_transit_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Use this for update operation only. This field is  Deprecated during create. For create use `isPvEncryptionInTransitEnabled` in [LaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/datatypes/LaunchInstanceDetails).
        """
        return pulumi.get(self, "is_pv_encryption_in_transit_enabled")

    @is_pv_encryption_in_transit_enabled.setter
    def is_pv_encryption_in_transit_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_pv_encryption_in_transit_enabled", value)

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Emulation type for the physical network interface card (NIC).
        """
        return pulumi.get(self, "network_type")

    @network_type.setter
    def network_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_type", value)

    @property
    @pulumi.getter(name="remoteDataVolumeType")
    def remote_data_volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        Emulation type for volume.
        """
        return pulumi.get(self, "remote_data_volume_type")

    @remote_data_volume_type.setter
    def remote_data_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_data_volume_type", value)


@pulumi.input_type
class InstancePlatformConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 are_virtual_instructions_enabled: Optional[pulumi.Input[bool]] = None,
                 config_map: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 is_access_control_service_enabled: Optional[pulumi.Input[bool]] = None,
                 is_input_output_memory_management_unit_enabled: Optional[pulumi.Input[bool]] = None,
                 is_measured_boot_enabled: Optional[pulumi.Input[bool]] = None,
                 is_memory_encryption_enabled: Optional[pulumi.Input[bool]] = None,
                 is_secure_boot_enabled: Optional[pulumi.Input[bool]] = None,
                 is_symmetric_multi_threading_enabled: Optional[pulumi.Input[bool]] = None,
                 is_trusted_platform_module_enabled: Optional[pulumi.Input[bool]] = None,
                 numa_nodes_per_socket: Optional[pulumi.Input[str]] = None,
                 percentage_of_cores_enabled: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] type: The type of action to run when the instance is interrupted for eviction.
        :param pulumi.Input[bool] are_virtual_instructions_enabled: Whether virtualization instructions are available. For example, Secure Virtual Machine for AMD shapes or VT-x for Intel shapes.
        :param pulumi.Input[Mapping[str, Any]] config_map: Instance Platform Configuration Configuration Map for flexible setting input.
        :param pulumi.Input[bool] is_access_control_service_enabled: Whether the Access Control Service is enabled on the instance. When enabled, the platform can enforce PCIe device isolation, required for VFIO device pass-through.
        :param pulumi.Input[bool] is_input_output_memory_management_unit_enabled: Whether the input-output memory management unit is enabled.
        :param pulumi.Input[bool] is_measured_boot_enabled: Whether the Measured Boot feature is enabled on the instance.
        :param pulumi.Input[bool] is_memory_encryption_enabled: Whether the instance is a confidential instance. If this value is `true`, the instance is a confidential instance. The default value is `false`.
        :param pulumi.Input[bool] is_secure_boot_enabled: Whether Secure Boot is enabled on the instance.
        :param pulumi.Input[bool] is_symmetric_multi_threading_enabled: Whether symmetric multithreading is enabled on the instance. Symmetric multithreading is also called simultaneous multithreading (SMT) or Intel Hyper-Threading.
               
               Intel and AMD processors have two hardware execution threads per core (OCPU). SMT permits multiple independent threads of execution, to better use the resources and increase the efficiency of the CPU. When multithreading is disabled, only one thread is permitted to run on each core, which can provide higher or more predictable performance for some workloads.
        :param pulumi.Input[bool] is_trusted_platform_module_enabled: Whether the Trusted Platform Module (TPM) is enabled on the instance.
        :param pulumi.Input[str] numa_nodes_per_socket: The number of NUMA nodes per socket (NPS).
        :param pulumi.Input[int] percentage_of_cores_enabled: The percentage of cores enabled. Value must be a multiple of 25%. If the requested percentage results in a fractional number of cores, the system rounds up the number of cores across processors and provisions an instance with a whole number of cores.
               
               If the applications that you run on the instance use a core-based licensing model and need fewer cores than the full size of the shape, you can disable cores to reduce your licensing costs. The instance itself is billed for the full shape, regardless of whether all cores are enabled.
        """
        InstancePlatformConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            are_virtual_instructions_enabled=are_virtual_instructions_enabled,
            config_map=config_map,
            is_access_control_service_enabled=is_access_control_service_enabled,
            is_input_output_memory_management_unit_enabled=is_input_output_memory_management_unit_enabled,
            is_measured_boot_enabled=is_measured_boot_enabled,
            is_memory_encryption_enabled=is_memory_encryption_enabled,
            is_secure_boot_enabled=is_secure_boot_enabled,
            is_symmetric_multi_threading_enabled=is_symmetric_multi_threading_enabled,
            is_trusted_platform_module_enabled=is_trusted_platform_module_enabled,
            numa_nodes_per_socket=numa_nodes_per_socket,
            percentage_of_cores_enabled=percentage_of_cores_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[str],
             are_virtual_instructions_enabled: Optional[pulumi.Input[bool]] = None,
             config_map: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             is_access_control_service_enabled: Optional[pulumi.Input[bool]] = None,
             is_input_output_memory_management_unit_enabled: Optional[pulumi.Input[bool]] = None,
             is_measured_boot_enabled: Optional[pulumi.Input[bool]] = None,
             is_memory_encryption_enabled: Optional[pulumi.Input[bool]] = None,
             is_secure_boot_enabled: Optional[pulumi.Input[bool]] = None,
             is_symmetric_multi_threading_enabled: Optional[pulumi.Input[bool]] = None,
             is_trusted_platform_module_enabled: Optional[pulumi.Input[bool]] = None,
             numa_nodes_per_socket: Optional[pulumi.Input[str]] = None,
             percentage_of_cores_enabled: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if are_virtual_instructions_enabled is not None:
            _setter("are_virtual_instructions_enabled", are_virtual_instructions_enabled)
        if config_map is not None:
            _setter("config_map", config_map)
        if is_access_control_service_enabled is not None:
            _setter("is_access_control_service_enabled", is_access_control_service_enabled)
        if is_input_output_memory_management_unit_enabled is not None:
            _setter("is_input_output_memory_management_unit_enabled", is_input_output_memory_management_unit_enabled)
        if is_measured_boot_enabled is not None:
            _setter("is_measured_boot_enabled", is_measured_boot_enabled)
        if is_memory_encryption_enabled is not None:
            _setter("is_memory_encryption_enabled", is_memory_encryption_enabled)
        if is_secure_boot_enabled is not None:
            _setter("is_secure_boot_enabled", is_secure_boot_enabled)
        if is_symmetric_multi_threading_enabled is not None:
            _setter("is_symmetric_multi_threading_enabled", is_symmetric_multi_threading_enabled)
        if is_trusted_platform_module_enabled is not None:
            _setter("is_trusted_platform_module_enabled", is_trusted_platform_module_enabled)
        if numa_nodes_per_socket is not None:
            _setter("numa_nodes_per_socket", numa_nodes_per_socket)
        if percentage_of_cores_enabled is not None:
            _setter("percentage_of_cores_enabled", percentage_of_cores_enabled)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of action to run when the instance is interrupted for eviction.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="areVirtualInstructionsEnabled")
    def are_virtual_instructions_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether virtualization instructions are available. For example, Secure Virtual Machine for AMD shapes or VT-x for Intel shapes.
        """
        return pulumi.get(self, "are_virtual_instructions_enabled")

    @are_virtual_instructions_enabled.setter
    def are_virtual_instructions_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "are_virtual_instructions_enabled", value)

    @property
    @pulumi.getter(name="configMap")
    def config_map(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Instance Platform Configuration Configuration Map for flexible setting input.
        """
        return pulumi.get(self, "config_map")

    @config_map.setter
    def config_map(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "config_map", value)

    @property
    @pulumi.getter(name="isAccessControlServiceEnabled")
    def is_access_control_service_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the Access Control Service is enabled on the instance. When enabled, the platform can enforce PCIe device isolation, required for VFIO device pass-through.
        """
        return pulumi.get(self, "is_access_control_service_enabled")

    @is_access_control_service_enabled.setter
    def is_access_control_service_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_access_control_service_enabled", value)

    @property
    @pulumi.getter(name="isInputOutputMemoryManagementUnitEnabled")
    def is_input_output_memory_management_unit_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the input-output memory management unit is enabled.
        """
        return pulumi.get(self, "is_input_output_memory_management_unit_enabled")

    @is_input_output_memory_management_unit_enabled.setter
    def is_input_output_memory_management_unit_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_input_output_memory_management_unit_enabled", value)

    @property
    @pulumi.getter(name="isMeasuredBootEnabled")
    def is_measured_boot_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the Measured Boot feature is enabled on the instance.
        """
        return pulumi.get(self, "is_measured_boot_enabled")

    @is_measured_boot_enabled.setter
    def is_measured_boot_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_measured_boot_enabled", value)

    @property
    @pulumi.getter(name="isMemoryEncryptionEnabled")
    def is_memory_encryption_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the instance is a confidential instance. If this value is `true`, the instance is a confidential instance. The default value is `false`.
        """
        return pulumi.get(self, "is_memory_encryption_enabled")

    @is_memory_encryption_enabled.setter
    def is_memory_encryption_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_memory_encryption_enabled", value)

    @property
    @pulumi.getter(name="isSecureBootEnabled")
    def is_secure_boot_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether Secure Boot is enabled on the instance.
        """
        return pulumi.get(self, "is_secure_boot_enabled")

    @is_secure_boot_enabled.setter
    def is_secure_boot_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_secure_boot_enabled", value)

    @property
    @pulumi.getter(name="isSymmetricMultiThreadingEnabled")
    def is_symmetric_multi_threading_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether symmetric multithreading is enabled on the instance. Symmetric multithreading is also called simultaneous multithreading (SMT) or Intel Hyper-Threading.

        Intel and AMD processors have two hardware execution threads per core (OCPU). SMT permits multiple independent threads of execution, to better use the resources and increase the efficiency of the CPU. When multithreading is disabled, only one thread is permitted to run on each core, which can provide higher or more predictable performance for some workloads.
        """
        return pulumi.get(self, "is_symmetric_multi_threading_enabled")

    @is_symmetric_multi_threading_enabled.setter
    def is_symmetric_multi_threading_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_symmetric_multi_threading_enabled", value)

    @property
    @pulumi.getter(name="isTrustedPlatformModuleEnabled")
    def is_trusted_platform_module_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the Trusted Platform Module (TPM) is enabled on the instance.
        """
        return pulumi.get(self, "is_trusted_platform_module_enabled")

    @is_trusted_platform_module_enabled.setter
    def is_trusted_platform_module_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_trusted_platform_module_enabled", value)

    @property
    @pulumi.getter(name="numaNodesPerSocket")
    def numa_nodes_per_socket(self) -> Optional[pulumi.Input[str]]:
        """
        The number of NUMA nodes per socket (NPS).
        """
        return pulumi.get(self, "numa_nodes_per_socket")

    @numa_nodes_per_socket.setter
    def numa_nodes_per_socket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "numa_nodes_per_socket", value)

    @property
    @pulumi.getter(name="percentageOfCoresEnabled")
    def percentage_of_cores_enabled(self) -> Optional[pulumi.Input[int]]:
        """
        The percentage of cores enabled. Value must be a multiple of 25%. If the requested percentage results in a fractional number of cores, the system rounds up the number of cores across processors and provisions an instance with a whole number of cores.

        If the applications that you run on the instance use a core-based licensing model and need fewer cores than the full size of the shape, you can disable cores to reduce your licensing costs. The instance itself is billed for the full shape, regardless of whether all cores are enabled.
        """
        return pulumi.get(self, "percentage_of_cores_enabled")

    @percentage_of_cores_enabled.setter
    def percentage_of_cores_enabled(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "percentage_of_cores_enabled", value)


@pulumi.input_type
class InstancePoolInstanceLoadBalancerBackendArgs:
    def __init__(__self__, *,
                 backend_health_status: Optional[pulumi.Input[str]] = None,
                 backend_name: Optional[pulumi.Input[str]] = None,
                 backend_set_name: Optional[pulumi.Input[str]] = None,
                 load_balancer_id: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] backend_health_status: The health of the backend as observed by the load balancer.
        :param pulumi.Input[str] backend_name: The name of the backend in the backend set.
        :param pulumi.Input[str] backend_set_name: The name of the backend set on the load balancer.
        :param pulumi.Input[str] load_balancer_id: The OCID of the load balancer attached to the instance pool.
        :param pulumi.Input[str] state: The lifecycle state of the instance. Refer to `lifecycleState` in the [Instance](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Instance) resource.
        """
        InstancePoolInstanceLoadBalancerBackendArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backend_health_status=backend_health_status,
            backend_name=backend_name,
            backend_set_name=backend_set_name,
            load_balancer_id=load_balancer_id,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backend_health_status: Optional[pulumi.Input[str]] = None,
             backend_name: Optional[pulumi.Input[str]] = None,
             backend_set_name: Optional[pulumi.Input[str]] = None,
             load_balancer_id: Optional[pulumi.Input[str]] = None,
             state: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if backend_health_status is not None:
            _setter("backend_health_status", backend_health_status)
        if backend_name is not None:
            _setter("backend_name", backend_name)
        if backend_set_name is not None:
            _setter("backend_set_name", backend_set_name)
        if load_balancer_id is not None:
            _setter("load_balancer_id", load_balancer_id)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter(name="backendHealthStatus")
    def backend_health_status(self) -> Optional[pulumi.Input[str]]:
        """
        The health of the backend as observed by the load balancer.
        """
        return pulumi.get(self, "backend_health_status")

    @backend_health_status.setter
    def backend_health_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backend_health_status", value)

    @property
    @pulumi.getter(name="backendName")
    def backend_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the backend in the backend set.
        """
        return pulumi.get(self, "backend_name")

    @backend_name.setter
    def backend_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backend_name", value)

    @property
    @pulumi.getter(name="backendSetName")
    def backend_set_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the backend set on the load balancer.
        """
        return pulumi.get(self, "backend_set_name")

    @backend_set_name.setter
    def backend_set_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backend_set_name", value)

    @property
    @pulumi.getter(name="loadBalancerId")
    def load_balancer_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the load balancer attached to the instance pool.
        """
        return pulumi.get(self, "load_balancer_id")

    @load_balancer_id.setter
    def load_balancer_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancer_id", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The lifecycle state of the instance. Refer to `lifecycleState` in the [Instance](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Instance) resource.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


@pulumi.input_type
class InstancePoolLoadBalancerArgs:
    def __init__(__self__, *,
                 backend_set_name: pulumi.Input[str],
                 load_balancer_id: pulumi.Input[str],
                 port: pulumi.Input[int],
                 vnic_selection: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None,
                 instance_pool_id: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] backend_set_name: The name of the backend set on the load balancer to add instances to.
        :param pulumi.Input[str] load_balancer_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the load balancer to attach to the instance pool.
        :param pulumi.Input[int] port: The port value to use when creating the backend set.
        :param pulumi.Input[str] vnic_selection: Indicates which VNIC on each instance in the pool should be used to associate with the load balancer. Possible values are "PrimaryVnic" or the displayName of one of the secondary VNICs on the instance configuration that is associated with the instance pool.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the load balancer attachment.
        :param pulumi.Input[str] instance_pool_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the instance pool of the load balancer attachment.
        :param pulumi.Input[str] state: (Updatable) The target state for the instance pool update operation (ignored at create time and should not be set). Could be set to RUNNING or STOPPED.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        InstancePoolLoadBalancerArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backend_set_name=backend_set_name,
            load_balancer_id=load_balancer_id,
            port=port,
            vnic_selection=vnic_selection,
            id=id,
            instance_pool_id=instance_pool_id,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backend_set_name: pulumi.Input[str],
             load_balancer_id: pulumi.Input[str],
             port: pulumi.Input[int],
             vnic_selection: pulumi.Input[str],
             id: Optional[pulumi.Input[str]] = None,
             instance_pool_id: Optional[pulumi.Input[str]] = None,
             state: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("backend_set_name", backend_set_name)
        _setter("load_balancer_id", load_balancer_id)
        _setter("port", port)
        _setter("vnic_selection", vnic_selection)
        if id is not None:
            _setter("id", id)
        if instance_pool_id is not None:
            _setter("instance_pool_id", instance_pool_id)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter(name="backendSetName")
    def backend_set_name(self) -> pulumi.Input[str]:
        """
        The name of the backend set on the load balancer to add instances to.
        """
        return pulumi.get(self, "backend_set_name")

    @backend_set_name.setter
    def backend_set_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "backend_set_name", value)

    @property
    @pulumi.getter(name="loadBalancerId")
    def load_balancer_id(self) -> pulumi.Input[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the load balancer to attach to the instance pool.
        """
        return pulumi.get(self, "load_balancer_id")

    @load_balancer_id.setter
    def load_balancer_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "load_balancer_id", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        The port value to use when creating the backend set.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="vnicSelection")
    def vnic_selection(self) -> pulumi.Input[str]:
        """
        Indicates which VNIC on each instance in the pool should be used to associate with the load balancer. Possible values are "PrimaryVnic" or the displayName of one of the secondary VNICs on the instance configuration that is associated with the instance pool.
        """
        return pulumi.get(self, "vnic_selection")

    @vnic_selection.setter
    def vnic_selection(self, value: pulumi.Input[str]):
        pulumi.set(self, "vnic_selection", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the load balancer attachment.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the instance pool of the load balancer attachment.
        """
        return pulumi.get(self, "instance_pool_id")

    @instance_pool_id.setter
    def instance_pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_pool_id", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The target state for the instance pool update operation (ignored at create time and should not be set). Could be set to RUNNING or STOPPED.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


@pulumi.input_type
class InstancePoolPlacementConfigurationArgs:
    def __init__(__self__, *,
                 availability_domain: pulumi.Input[str],
                 fault_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 primary_subnet_id: Optional[pulumi.Input[str]] = None,
                 primary_vnic_subnets: Optional[pulumi.Input['InstancePoolPlacementConfigurationPrimaryVnicSubnetsArgs']] = None,
                 secondary_vnic_subnets: Optional[pulumi.Input[Sequence[pulumi.Input['InstancePoolPlacementConfigurationSecondaryVnicSubnetArgs']]]] = None):
        """
        :param pulumi.Input[str] availability_domain: (Updatable) The availability domain to place instances.  Example: `Uocm:PHX-AD-1`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] fault_domains: (Updatable) The fault domains to place instances.
               
               If you don't provide any values, the system makes a best effort to distribute instances across all fault domains based on capacity.
               
               To distribute the instances evenly across selected fault domains, provide a set of fault domains. For example, you might want instances to be evenly distributed if your applications require high availability.
               
               To get a list of fault domains, use the [ListFaultDomains](https://docs.cloud.oracle.com/iaas/api/#/en/identity/20160918/FaultDomain/ListFaultDomains) operation in the Identity and Access Management Service API.
               
               Example: `[FAULT-DOMAIN-1, FAULT-DOMAIN-2, FAULT-DOMAIN-3]`
        :param pulumi.Input[str] primary_subnet_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the primary subnet to place instances. This field is deprecated. Use `primaryVnicSubnets` instead to set VNIC data for instances in the pool.
        :param pulumi.Input['InstancePoolPlacementConfigurationPrimaryVnicSubnetsArgs'] primary_vnic_subnets: (Updatable) Details about the IPv6 primary subnet.
        :param pulumi.Input[Sequence[pulumi.Input['InstancePoolPlacementConfigurationSecondaryVnicSubnetArgs']]] secondary_vnic_subnets: (Updatable) The set of secondary VNIC data for instances in the pool.
        """
        InstancePoolPlacementConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_domain=availability_domain,
            fault_domains=fault_domains,
            primary_subnet_id=primary_subnet_id,
            primary_vnic_subnets=primary_vnic_subnets,
            secondary_vnic_subnets=secondary_vnic_subnets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_domain: pulumi.Input[str],
             fault_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             primary_subnet_id: Optional[pulumi.Input[str]] = None,
             primary_vnic_subnets: Optional[pulumi.Input['InstancePoolPlacementConfigurationPrimaryVnicSubnetsArgs']] = None,
             secondary_vnic_subnets: Optional[pulumi.Input[Sequence[pulumi.Input['InstancePoolPlacementConfigurationSecondaryVnicSubnetArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("availability_domain", availability_domain)
        if fault_domains is not None:
            _setter("fault_domains", fault_domains)
        if primary_subnet_id is not None:
            _setter("primary_subnet_id", primary_subnet_id)
        if primary_vnic_subnets is not None:
            _setter("primary_vnic_subnets", primary_vnic_subnets)
        if secondary_vnic_subnets is not None:
            _setter("secondary_vnic_subnets", secondary_vnic_subnets)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> pulumi.Input[str]:
        """
        (Updatable) The availability domain to place instances.  Example: `Uocm:PHX-AD-1`
        """
        return pulumi.get(self, "availability_domain")

    @availability_domain.setter
    def availability_domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "availability_domain", value)

    @property
    @pulumi.getter(name="faultDomains")
    def fault_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) The fault domains to place instances.

        If you don't provide any values, the system makes a best effort to distribute instances across all fault domains based on capacity.

        To distribute the instances evenly across selected fault domains, provide a set of fault domains. For example, you might want instances to be evenly distributed if your applications require high availability.

        To get a list of fault domains, use the [ListFaultDomains](https://docs.cloud.oracle.com/iaas/api/#/en/identity/20160918/FaultDomain/ListFaultDomains) operation in the Identity and Access Management Service API.

        Example: `[FAULT-DOMAIN-1, FAULT-DOMAIN-2, FAULT-DOMAIN-3]`
        """
        return pulumi.get(self, "fault_domains")

    @fault_domains.setter
    def fault_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "fault_domains", value)

    @property
    @pulumi.getter(name="primarySubnetId")
    def primary_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the primary subnet to place instances. This field is deprecated. Use `primaryVnicSubnets` instead to set VNIC data for instances in the pool.
        """
        return pulumi.get(self, "primary_subnet_id")

    @primary_subnet_id.setter
    def primary_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_subnet_id", value)

    @property
    @pulumi.getter(name="primaryVnicSubnets")
    def primary_vnic_subnets(self) -> Optional[pulumi.Input['InstancePoolPlacementConfigurationPrimaryVnicSubnetsArgs']]:
        """
        (Updatable) Details about the IPv6 primary subnet.
        """
        return pulumi.get(self, "primary_vnic_subnets")

    @primary_vnic_subnets.setter
    def primary_vnic_subnets(self, value: Optional[pulumi.Input['InstancePoolPlacementConfigurationPrimaryVnicSubnetsArgs']]):
        pulumi.set(self, "primary_vnic_subnets", value)

    @property
    @pulumi.getter(name="secondaryVnicSubnets")
    def secondary_vnic_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstancePoolPlacementConfigurationSecondaryVnicSubnetArgs']]]]:
        """
        (Updatable) The set of secondary VNIC data for instances in the pool.
        """
        return pulumi.get(self, "secondary_vnic_subnets")

    @secondary_vnic_subnets.setter
    def secondary_vnic_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstancePoolPlacementConfigurationSecondaryVnicSubnetArgs']]]]):
        pulumi.set(self, "secondary_vnic_subnets", value)


@pulumi.input_type
class InstancePoolPlacementConfigurationPrimaryVnicSubnetsArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[str],
                 ipv6address_ipv6subnet_cidr_pair_details: Optional[pulumi.Input[Sequence[pulumi.Input['InstancePoolPlacementConfigurationPrimaryVnicSubnetsIpv6addressIpv6subnetCidrPairDetailArgs']]]] = None,
                 is_assign_ipv6ip: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] subnet_id: (Updatable) The subnet [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the secondary VNIC.
        :param pulumi.Input[Sequence[pulumi.Input['InstancePoolPlacementConfigurationPrimaryVnicSubnetsIpv6addressIpv6subnetCidrPairDetailArgs']]] ipv6address_ipv6subnet_cidr_pair_details: (Updatable) A list of IPv6 prefix ranges from which the VNIC should be assigned an IPv6 address. You can provide only the prefix ranges and Oracle Cloud Infrastructure will select an available address from the range. You can optionally choose to leave the prefix range empty and instead provide the specific IPv6 address that should be used from within that range.
        :param pulumi.Input[bool] is_assign_ipv6ip: (Updatable) Whether to allocate an IPv6 address at instance and VNIC creation from an IPv6 enabled subnet. Default: False. When provided you may optionally provide an IPv6 prefix (`ipv6SubnetCidr`) of your choice to assign the IPv6 address from. If `ipv6SubnetCidr` is not provided then an IPv6 prefix is chosen for you.
        """
        InstancePoolPlacementConfigurationPrimaryVnicSubnetsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subnet_id=subnet_id,
            ipv6address_ipv6subnet_cidr_pair_details=ipv6address_ipv6subnet_cidr_pair_details,
            is_assign_ipv6ip=is_assign_ipv6ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subnet_id: pulumi.Input[str],
             ipv6address_ipv6subnet_cidr_pair_details: Optional[pulumi.Input[Sequence[pulumi.Input['InstancePoolPlacementConfigurationPrimaryVnicSubnetsIpv6addressIpv6subnetCidrPairDetailArgs']]]] = None,
             is_assign_ipv6ip: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("subnet_id", subnet_id)
        if ipv6address_ipv6subnet_cidr_pair_details is not None:
            _setter("ipv6address_ipv6subnet_cidr_pair_details", ipv6address_ipv6subnet_cidr_pair_details)
        if is_assign_ipv6ip is not None:
            _setter("is_assign_ipv6ip", is_assign_ipv6ip)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The subnet [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the secondary VNIC.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="ipv6addressIpv6subnetCidrPairDetails")
    def ipv6address_ipv6subnet_cidr_pair_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstancePoolPlacementConfigurationPrimaryVnicSubnetsIpv6addressIpv6subnetCidrPairDetailArgs']]]]:
        """
        (Updatable) A list of IPv6 prefix ranges from which the VNIC should be assigned an IPv6 address. You can provide only the prefix ranges and Oracle Cloud Infrastructure will select an available address from the range. You can optionally choose to leave the prefix range empty and instead provide the specific IPv6 address that should be used from within that range.
        """
        return pulumi.get(self, "ipv6address_ipv6subnet_cidr_pair_details")

    @ipv6address_ipv6subnet_cidr_pair_details.setter
    def ipv6address_ipv6subnet_cidr_pair_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstancePoolPlacementConfigurationPrimaryVnicSubnetsIpv6addressIpv6subnetCidrPairDetailArgs']]]]):
        pulumi.set(self, "ipv6address_ipv6subnet_cidr_pair_details", value)

    @property
    @pulumi.getter(name="isAssignIpv6ip")
    def is_assign_ipv6ip(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether to allocate an IPv6 address at instance and VNIC creation from an IPv6 enabled subnet. Default: False. When provided you may optionally provide an IPv6 prefix (`ipv6SubnetCidr`) of your choice to assign the IPv6 address from. If `ipv6SubnetCidr` is not provided then an IPv6 prefix is chosen for you.
        """
        return pulumi.get(self, "is_assign_ipv6ip")

    @is_assign_ipv6ip.setter
    def is_assign_ipv6ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_assign_ipv6ip", value)


@pulumi.input_type
class InstancePoolPlacementConfigurationPrimaryVnicSubnetsIpv6addressIpv6subnetCidrPairDetailArgs:
    def __init__(__self__, *,
                 ipv6subnet_cidr: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ipv6subnet_cidr: (Updatable) Optional. Used to disambiguate which subnet prefix should be used to create an IPv6 allocation.
        """
        InstancePoolPlacementConfigurationPrimaryVnicSubnetsIpv6addressIpv6subnetCidrPairDetailArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ipv6subnet_cidr=ipv6subnet_cidr,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ipv6subnet_cidr: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ipv6subnet_cidr is not None:
            _setter("ipv6subnet_cidr", ipv6subnet_cidr)

    @property
    @pulumi.getter(name="ipv6subnetCidr")
    def ipv6subnet_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Optional. Used to disambiguate which subnet prefix should be used to create an IPv6 allocation.
        """
        return pulumi.get(self, "ipv6subnet_cidr")

    @ipv6subnet_cidr.setter
    def ipv6subnet_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6subnet_cidr", value)


@pulumi.input_type
class InstancePoolPlacementConfigurationSecondaryVnicSubnetArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[str],
                 display_name: Optional[pulumi.Input[str]] = None,
                 ipv6address_ipv6subnet_cidr_pair_details: Optional[pulumi.Input[Sequence[pulumi.Input['InstancePoolPlacementConfigurationSecondaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs']]]] = None,
                 is_assign_ipv6ip: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] subnet_id: (Updatable) The subnet [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the secondary VNIC.
        :param pulumi.Input[str] display_name: (Updatable) The display name of the VNIC. This is also used to match against the instance configuration defined secondary VNIC.
        :param pulumi.Input[Sequence[pulumi.Input['InstancePoolPlacementConfigurationSecondaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs']]] ipv6address_ipv6subnet_cidr_pair_details: (Updatable) A list of IPv6 prefix ranges from which the VNIC should be assigned an IPv6 address. You can provide only the prefix ranges and Oracle Cloud Infrastructure will select an available address from the range. You can optionally choose to leave the prefix range empty and instead provide the specific IPv6 address that should be used from within that range.
        :param pulumi.Input[bool] is_assign_ipv6ip: (Updatable) Whether to allocate an IPv6 address at instance and VNIC creation from an IPv6 enabled subnet. Default: False. When provided you may optionally provide an IPv6 prefix (`ipv6SubnetCidr`) of your choice to assign the IPv6 address from. If `ipv6SubnetCidr` is not provided then an IPv6 prefix is chosen for you.
        """
        InstancePoolPlacementConfigurationSecondaryVnicSubnetArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subnet_id=subnet_id,
            display_name=display_name,
            ipv6address_ipv6subnet_cidr_pair_details=ipv6address_ipv6subnet_cidr_pair_details,
            is_assign_ipv6ip=is_assign_ipv6ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subnet_id: pulumi.Input[str],
             display_name: Optional[pulumi.Input[str]] = None,
             ipv6address_ipv6subnet_cidr_pair_details: Optional[pulumi.Input[Sequence[pulumi.Input['InstancePoolPlacementConfigurationSecondaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs']]]] = None,
             is_assign_ipv6ip: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("subnet_id", subnet_id)
        if display_name is not None:
            _setter("display_name", display_name)
        if ipv6address_ipv6subnet_cidr_pair_details is not None:
            _setter("ipv6address_ipv6subnet_cidr_pair_details", ipv6address_ipv6subnet_cidr_pair_details)
        if is_assign_ipv6ip is not None:
            _setter("is_assign_ipv6ip", is_assign_ipv6ip)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The subnet [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the secondary VNIC.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The display name of the VNIC. This is also used to match against the instance configuration defined secondary VNIC.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="ipv6addressIpv6subnetCidrPairDetails")
    def ipv6address_ipv6subnet_cidr_pair_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstancePoolPlacementConfigurationSecondaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs']]]]:
        """
        (Updatable) A list of IPv6 prefix ranges from which the VNIC should be assigned an IPv6 address. You can provide only the prefix ranges and Oracle Cloud Infrastructure will select an available address from the range. You can optionally choose to leave the prefix range empty and instead provide the specific IPv6 address that should be used from within that range.
        """
        return pulumi.get(self, "ipv6address_ipv6subnet_cidr_pair_details")

    @ipv6address_ipv6subnet_cidr_pair_details.setter
    def ipv6address_ipv6subnet_cidr_pair_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstancePoolPlacementConfigurationSecondaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs']]]]):
        pulumi.set(self, "ipv6address_ipv6subnet_cidr_pair_details", value)

    @property
    @pulumi.getter(name="isAssignIpv6ip")
    def is_assign_ipv6ip(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether to allocate an IPv6 address at instance and VNIC creation from an IPv6 enabled subnet. Default: False. When provided you may optionally provide an IPv6 prefix (`ipv6SubnetCidr`) of your choice to assign the IPv6 address from. If `ipv6SubnetCidr` is not provided then an IPv6 prefix is chosen for you.
        """
        return pulumi.get(self, "is_assign_ipv6ip")

    @is_assign_ipv6ip.setter
    def is_assign_ipv6ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_assign_ipv6ip", value)


@pulumi.input_type
class InstancePoolPlacementConfigurationSecondaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs:
    def __init__(__self__, *,
                 ipv6subnet_cidr: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ipv6subnet_cidr: (Updatable) Optional. Used to disambiguate which subnet prefix should be used to create an IPv6 allocation.
        """
        InstancePoolPlacementConfigurationSecondaryVnicSubnetIpv6addressIpv6subnetCidrPairDetailArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ipv6subnet_cidr=ipv6subnet_cidr,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ipv6subnet_cidr: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ipv6subnet_cidr is not None:
            _setter("ipv6subnet_cidr", ipv6subnet_cidr)

    @property
    @pulumi.getter(name="ipv6subnetCidr")
    def ipv6subnet_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Optional. Used to disambiguate which subnet prefix should be used to create an IPv6 allocation.
        """
        return pulumi.get(self, "ipv6subnet_cidr")

    @ipv6subnet_cidr.setter
    def ipv6subnet_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6subnet_cidr", value)


@pulumi.input_type
class InstancePreemptibleInstanceConfigArgs:
    def __init__(__self__, *,
                 preemption_action: pulumi.Input['InstancePreemptibleInstanceConfigPreemptionActionArgs']):
        """
        :param pulumi.Input['InstancePreemptibleInstanceConfigPreemptionActionArgs'] preemption_action: The action to run when the preemptible instance is interrupted for eviction.
        """
        InstancePreemptibleInstanceConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            preemption_action=preemption_action,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             preemption_action: pulumi.Input['InstancePreemptibleInstanceConfigPreemptionActionArgs'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("preemption_action", preemption_action)

    @property
    @pulumi.getter(name="preemptionAction")
    def preemption_action(self) -> pulumi.Input['InstancePreemptibleInstanceConfigPreemptionActionArgs']:
        """
        The action to run when the preemptible instance is interrupted for eviction.
        """
        return pulumi.get(self, "preemption_action")

    @preemption_action.setter
    def preemption_action(self, value: pulumi.Input['InstancePreemptibleInstanceConfigPreemptionActionArgs']):
        pulumi.set(self, "preemption_action", value)


@pulumi.input_type
class InstancePreemptibleInstanceConfigPreemptionActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 preserve_boot_volume: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] type: The type of action to run when the instance is interrupted for eviction.
        :param pulumi.Input[bool] preserve_boot_volume: Whether to preserve the boot volume that was used to launch the preemptible instance when the instance is terminated. Defaults to false if not specified.
        """
        InstancePreemptibleInstanceConfigPreemptionActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            preserve_boot_volume=preserve_boot_volume,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[str],
             preserve_boot_volume: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if preserve_boot_volume is not None:
            _setter("preserve_boot_volume", preserve_boot_volume)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of action to run when the instance is interrupted for eviction.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="preserveBootVolume")
    def preserve_boot_volume(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to preserve the boot volume that was used to launch the preemptible instance when the instance is terminated. Defaults to false if not specified.
        """
        return pulumi.get(self, "preserve_boot_volume")

    @preserve_boot_volume.setter
    def preserve_boot_volume(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_boot_volume", value)


@pulumi.input_type
class InstanceShapeConfigArgs:
    def __init__(__self__, *,
                 baseline_ocpu_utilization: Optional[pulumi.Input[str]] = None,
                 gpu_description: Optional[pulumi.Input[str]] = None,
                 gpus: Optional[pulumi.Input[int]] = None,
                 local_disk_description: Optional[pulumi.Input[str]] = None,
                 local_disks: Optional[pulumi.Input[int]] = None,
                 local_disks_total_size_in_gbs: Optional[pulumi.Input[float]] = None,
                 max_vnic_attachments: Optional[pulumi.Input[int]] = None,
                 memory_in_gbs: Optional[pulumi.Input[float]] = None,
                 networking_bandwidth_in_gbps: Optional[pulumi.Input[float]] = None,
                 nvmes: Optional[pulumi.Input[int]] = None,
                 ocpus: Optional[pulumi.Input[float]] = None,
                 processor_description: Optional[pulumi.Input[str]] = None,
                 vcpus: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] baseline_ocpu_utilization: (Updatable) The baseline OCPU utilization for a subcore burstable VM instance. Leave this attribute blank for a non-burstable instance, or explicitly specify non-burstable with `BASELINE_1_1`.
               
               The following values are supported:
        :param pulumi.Input[str] gpu_description: A short description of the instance's graphics processing unit (GPU).
        :param pulumi.Input[int] gpus: The number of GPUs available to the instance.
        :param pulumi.Input[str] local_disk_description: A short description of the local disks available to this instance.
        :param pulumi.Input[int] local_disks: The number of local disks available to the instance.
        :param pulumi.Input[float] local_disks_total_size_in_gbs: The aggregate size of all local disks, in gigabytes.
        :param pulumi.Input[int] max_vnic_attachments: The maximum number of VNIC attachments for the instance.
        :param pulumi.Input[float] memory_in_gbs: (Updatable) The total amount of memory available to the instance, in gigabytes.
        :param pulumi.Input[float] networking_bandwidth_in_gbps: The networking bandwidth available to the instance, in gigabits per second.
        :param pulumi.Input[int] nvmes: (Updatable) The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        :param pulumi.Input[float] ocpus: (Updatable) The total number of OCPUs available to the instance.
        :param pulumi.Input[str] processor_description: A short description of the instance's processor (CPU).
        :param pulumi.Input[int] vcpus: (Updatable) The total number of VCPUs available to the instance. This can be used instead of OCPUs, in which case the actual number of OCPUs will be calculated based on this value and the actual hardware. This must be a multiple of 2.
        """
        InstanceShapeConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            baseline_ocpu_utilization=baseline_ocpu_utilization,
            gpu_description=gpu_description,
            gpus=gpus,
            local_disk_description=local_disk_description,
            local_disks=local_disks,
            local_disks_total_size_in_gbs=local_disks_total_size_in_gbs,
            max_vnic_attachments=max_vnic_attachments,
            memory_in_gbs=memory_in_gbs,
            networking_bandwidth_in_gbps=networking_bandwidth_in_gbps,
            nvmes=nvmes,
            ocpus=ocpus,
            processor_description=processor_description,
            vcpus=vcpus,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             baseline_ocpu_utilization: Optional[pulumi.Input[str]] = None,
             gpu_description: Optional[pulumi.Input[str]] = None,
             gpus: Optional[pulumi.Input[int]] = None,
             local_disk_description: Optional[pulumi.Input[str]] = None,
             local_disks: Optional[pulumi.Input[int]] = None,
             local_disks_total_size_in_gbs: Optional[pulumi.Input[float]] = None,
             max_vnic_attachments: Optional[pulumi.Input[int]] = None,
             memory_in_gbs: Optional[pulumi.Input[float]] = None,
             networking_bandwidth_in_gbps: Optional[pulumi.Input[float]] = None,
             nvmes: Optional[pulumi.Input[int]] = None,
             ocpus: Optional[pulumi.Input[float]] = None,
             processor_description: Optional[pulumi.Input[str]] = None,
             vcpus: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if baseline_ocpu_utilization is not None:
            _setter("baseline_ocpu_utilization", baseline_ocpu_utilization)
        if gpu_description is not None:
            _setter("gpu_description", gpu_description)
        if gpus is not None:
            _setter("gpus", gpus)
        if local_disk_description is not None:
            _setter("local_disk_description", local_disk_description)
        if local_disks is not None:
            _setter("local_disks", local_disks)
        if local_disks_total_size_in_gbs is not None:
            _setter("local_disks_total_size_in_gbs", local_disks_total_size_in_gbs)
        if max_vnic_attachments is not None:
            _setter("max_vnic_attachments", max_vnic_attachments)
        if memory_in_gbs is not None:
            _setter("memory_in_gbs", memory_in_gbs)
        if networking_bandwidth_in_gbps is not None:
            _setter("networking_bandwidth_in_gbps", networking_bandwidth_in_gbps)
        if nvmes is not None:
            _setter("nvmes", nvmes)
        if ocpus is not None:
            _setter("ocpus", ocpus)
        if processor_description is not None:
            _setter("processor_description", processor_description)
        if vcpus is not None:
            _setter("vcpus", vcpus)

    @property
    @pulumi.getter(name="baselineOcpuUtilization")
    def baseline_ocpu_utilization(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The baseline OCPU utilization for a subcore burstable VM instance. Leave this attribute blank for a non-burstable instance, or explicitly specify non-burstable with `BASELINE_1_1`.

        The following values are supported:
        """
        return pulumi.get(self, "baseline_ocpu_utilization")

    @baseline_ocpu_utilization.setter
    def baseline_ocpu_utilization(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "baseline_ocpu_utilization", value)

    @property
    @pulumi.getter(name="gpuDescription")
    def gpu_description(self) -> Optional[pulumi.Input[str]]:
        """
        A short description of the instance's graphics processing unit (GPU).
        """
        return pulumi.get(self, "gpu_description")

    @gpu_description.setter
    def gpu_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gpu_description", value)

    @property
    @pulumi.getter
    def gpus(self) -> Optional[pulumi.Input[int]]:
        """
        The number of GPUs available to the instance.
        """
        return pulumi.get(self, "gpus")

    @gpus.setter
    def gpus(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "gpus", value)

    @property
    @pulumi.getter(name="localDiskDescription")
    def local_disk_description(self) -> Optional[pulumi.Input[str]]:
        """
        A short description of the local disks available to this instance.
        """
        return pulumi.get(self, "local_disk_description")

    @local_disk_description.setter
    def local_disk_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "local_disk_description", value)

    @property
    @pulumi.getter(name="localDisks")
    def local_disks(self) -> Optional[pulumi.Input[int]]:
        """
        The number of local disks available to the instance.
        """
        return pulumi.get(self, "local_disks")

    @local_disks.setter
    def local_disks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "local_disks", value)

    @property
    @pulumi.getter(name="localDisksTotalSizeInGbs")
    def local_disks_total_size_in_gbs(self) -> Optional[pulumi.Input[float]]:
        """
        The aggregate size of all local disks, in gigabytes.
        """
        return pulumi.get(self, "local_disks_total_size_in_gbs")

    @local_disks_total_size_in_gbs.setter
    def local_disks_total_size_in_gbs(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "local_disks_total_size_in_gbs", value)

    @property
    @pulumi.getter(name="maxVnicAttachments")
    def max_vnic_attachments(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of VNIC attachments for the instance.
        """
        return pulumi.get(self, "max_vnic_attachments")

    @max_vnic_attachments.setter
    def max_vnic_attachments(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_vnic_attachments", value)

    @property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[pulumi.Input[float]]:
        """
        (Updatable) The total amount of memory available to the instance, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_in_gbs", value)

    @property
    @pulumi.getter(name="networkingBandwidthInGbps")
    def networking_bandwidth_in_gbps(self) -> Optional[pulumi.Input[float]]:
        """
        The networking bandwidth available to the instance, in gigabits per second.
        """
        return pulumi.get(self, "networking_bandwidth_in_gbps")

    @networking_bandwidth_in_gbps.setter
    def networking_bandwidth_in_gbps(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "networking_bandwidth_in_gbps", value)

    @property
    @pulumi.getter
    def nvmes(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The number of NVMe drives to be used for storage. A single drive has 6.8 TB available.
        """
        return pulumi.get(self, "nvmes")

    @nvmes.setter
    def nvmes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nvmes", value)

    @property
    @pulumi.getter
    def ocpus(self) -> Optional[pulumi.Input[float]]:
        """
        (Updatable) The total number of OCPUs available to the instance.
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "ocpus", value)

    @property
    @pulumi.getter(name="processorDescription")
    def processor_description(self) -> Optional[pulumi.Input[str]]:
        """
        A short description of the instance's processor (CPU).
        """
        return pulumi.get(self, "processor_description")

    @processor_description.setter
    def processor_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "processor_description", value)

    @property
    @pulumi.getter
    def vcpus(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The total number of VCPUs available to the instance. This can be used instead of OCPUs, in which case the actual number of OCPUs will be calculated based on this value and the actual hardware. This must be a multiple of 2.
        """
        return pulumi.get(self, "vcpus")

    @vcpus.setter
    def vcpus(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vcpus", value)


@pulumi.input_type
class InstanceSourceDetailsArgs:
    def __init__(__self__, *,
                 source_type: pulumi.Input[str],
                 boot_volume_size_in_gbs: Optional[pulumi.Input[str]] = None,
                 boot_volume_vpus_per_gb: Optional[pulumi.Input[str]] = None,
                 instance_source_image_filter_details: Optional[pulumi.Input['InstanceSourceDetailsInstanceSourceImageFilterDetailsArgs']] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 source_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] source_type: The source type for the instance. Use `image` when specifying the image OCID. Use `bootVolume` when specifying the boot volume OCID.
        :param pulumi.Input[str] boot_volume_size_in_gbs: (Updatable) The size of the boot volume in GBs. Minimum value is 50 GB and maximum value is 32,768 GB (32 TB).
        :param pulumi.Input[str] boot_volume_vpus_per_gb: The number of volume performance units (VPUs) that will be applied to this volume per GB, representing the Block Volume service's elastic performance options. See [Block Volume Performance Levels](https://docs.cloud.oracle.com/iaas/Content/Block/Concepts/blockvolumeperformance.htm#perf_levels) for more information.
               
               Allowed values:
        :param pulumi.Input['InstanceSourceDetailsInstanceSourceImageFilterDetailsArgs'] instance_source_image_filter_details: These are the criteria for selecting an image. This is required if imageId is not specified.
        :param pulumi.Input[str] kms_key_id: The OCID of the Vault service key to assign as the master encryption key for the boot volume.
        :param pulumi.Input[str] source_id: The OCID of an image or a boot volume to use, depending on the value of `source_type`.
        """
        InstanceSourceDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_type=source_type,
            boot_volume_size_in_gbs=boot_volume_size_in_gbs,
            boot_volume_vpus_per_gb=boot_volume_vpus_per_gb,
            instance_source_image_filter_details=instance_source_image_filter_details,
            kms_key_id=kms_key_id,
            source_id=source_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_type: pulumi.Input[str],
             boot_volume_size_in_gbs: Optional[pulumi.Input[str]] = None,
             boot_volume_vpus_per_gb: Optional[pulumi.Input[str]] = None,
             instance_source_image_filter_details: Optional[pulumi.Input['InstanceSourceDetailsInstanceSourceImageFilterDetailsArgs']] = None,
             kms_key_id: Optional[pulumi.Input[str]] = None,
             source_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("source_type", source_type)
        if boot_volume_size_in_gbs is not None:
            _setter("boot_volume_size_in_gbs", boot_volume_size_in_gbs)
        if boot_volume_vpus_per_gb is not None:
            _setter("boot_volume_vpus_per_gb", boot_volume_vpus_per_gb)
        if instance_source_image_filter_details is not None:
            _setter("instance_source_image_filter_details", instance_source_image_filter_details)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)
        if source_id is not None:
            _setter("source_id", source_id)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[str]:
        """
        The source type for the instance. Use `image` when specifying the image OCID. Use `bootVolume` when specifying the boot volume OCID.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_type", value)

    @property
    @pulumi.getter(name="bootVolumeSizeInGbs")
    def boot_volume_size_in_gbs(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The size of the boot volume in GBs. Minimum value is 50 GB and maximum value is 32,768 GB (32 TB).
        """
        return pulumi.get(self, "boot_volume_size_in_gbs")

    @boot_volume_size_in_gbs.setter
    def boot_volume_size_in_gbs(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "boot_volume_size_in_gbs", value)

    @property
    @pulumi.getter(name="bootVolumeVpusPerGb")
    def boot_volume_vpus_per_gb(self) -> Optional[pulumi.Input[str]]:
        """
        The number of volume performance units (VPUs) that will be applied to this volume per GB, representing the Block Volume service's elastic performance options. See [Block Volume Performance Levels](https://docs.cloud.oracle.com/iaas/Content/Block/Concepts/blockvolumeperformance.htm#perf_levels) for more information.

        Allowed values:
        """
        return pulumi.get(self, "boot_volume_vpus_per_gb")

    @boot_volume_vpus_per_gb.setter
    def boot_volume_vpus_per_gb(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "boot_volume_vpus_per_gb", value)

    @property
    @pulumi.getter(name="instanceSourceImageFilterDetails")
    def instance_source_image_filter_details(self) -> Optional[pulumi.Input['InstanceSourceDetailsInstanceSourceImageFilterDetailsArgs']]:
        """
        These are the criteria for selecting an image. This is required if imageId is not specified.
        """
        return pulumi.get(self, "instance_source_image_filter_details")

    @instance_source_image_filter_details.setter
    def instance_source_image_filter_details(self, value: Optional[pulumi.Input['InstanceSourceDetailsInstanceSourceImageFilterDetailsArgs']]):
        pulumi.set(self, "instance_source_image_filter_details", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the Vault service key to assign as the master encryption key for the boot volume.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of an image or a boot volume to use, depending on the value of `source_type`.
        """
        return pulumi.get(self, "source_id")

    @source_id.setter
    def source_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_id", value)


@pulumi.input_type
class InstanceSourceDetailsInstanceSourceImageFilterDetailsArgs:
    def __init__(__self__, *,
                 compartment_id: pulumi.Input[str],
                 defined_tags_filter: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 operating_system: Optional[pulumi.Input[str]] = None,
                 operating_system_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compartment_id: (Updatable) The OCID of the compartment containing images to search
        :param pulumi.Input[Mapping[str, Any]] defined_tags_filter: Filter based on these defined tags. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param pulumi.Input[str] operating_system: The image's operating system.  Example: `Oracle Linux`
        :param pulumi.Input[str] operating_system_version: The image's operating system version.  Example: `7.2`
        """
        InstanceSourceDetailsInstanceSourceImageFilterDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            defined_tags_filter=defined_tags_filter,
            operating_system=operating_system,
            operating_system_version=operating_system_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: pulumi.Input[str],
             defined_tags_filter: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             operating_system: Optional[pulumi.Input[str]] = None,
             operating_system_version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("compartment_id", compartment_id)
        if defined_tags_filter is not None:
            _setter("defined_tags_filter", defined_tags_filter)
        if operating_system is not None:
            _setter("operating_system", operating_system)
        if operating_system_version is not None:
            _setter("operating_system_version", operating_system_version)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The OCID of the compartment containing images to search
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter(name="definedTagsFilter")
    def defined_tags_filter(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Filter based on these defined tags. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags_filter")

    @defined_tags_filter.setter
    def defined_tags_filter(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags_filter", value)

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> Optional[pulumi.Input[str]]:
        """
        The image's operating system.  Example: `Oracle Linux`
        """
        return pulumi.get(self, "operating_system")

    @operating_system.setter
    def operating_system(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operating_system", value)

    @property
    @pulumi.getter(name="operatingSystemVersion")
    def operating_system_version(self) -> Optional[pulumi.Input[str]]:
        """
        The image's operating system version.  Example: `7.2`
        """
        return pulumi.get(self, "operating_system_version")

    @operating_system_version.setter
    def operating_system_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operating_system_version", value)


@pulumi.input_type
class IpsecConnectionTunnelManagementBgpSessionInfoArgs:
    def __init__(__self__, *,
                 bgp_ipv6state: Optional[pulumi.Input[str]] = None,
                 bgp_state: Optional[pulumi.Input[str]] = None,
                 customer_bgp_asn: Optional[pulumi.Input[str]] = None,
                 customer_interface_ip: Optional[pulumi.Input[str]] = None,
                 oracle_bgp_asn: Optional[pulumi.Input[str]] = None,
                 oracle_interface_ip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bgp_ipv6state: The state of the BGP IPv6 session.
        :param pulumi.Input[str] bgp_state: The state of the BGP session.
        :param pulumi.Input[str] customer_bgp_asn: If the tunnel's `routing` attribute is set to `BGP` (see [IPSecConnectionTunnel](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/IPSecConnectionTunnel/)), this ASN is required and used for the tunnel's BGP session. This is the ASN of the network on the CPE end of the BGP session. Can be a 2-byte or 4-byte ASN. Uses "asplain" format.
               
               If the tunnel's `routing` attribute is set to `STATIC`, the `customerBgpAsn` must be null.
               
               Example: `12345` (2-byte) or `1587232876` (4-byte)
        :param pulumi.Input[str] customer_interface_ip: The IP address for the CPE end of the inside tunnel interface.
               
               If the tunnel's `routing` attribute is set to `BGP` (see [IPSecConnectionTunnel](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/IPSecConnectionTunnel/)), this IP address is required and used for the tunnel's BGP session.
               
               If `routing` is instead set to `STATIC`, this IP address is optional. You can set this IP address to troubleshoot or monitor the tunnel.
               
               The value must be a /30 or /31.
               
               Example: `10.0.0.5/31`
        :param pulumi.Input[str] oracle_bgp_asn: The Oracle BGP ASN.
        :param pulumi.Input[str] oracle_interface_ip: The IP address for the Oracle end of the inside tunnel interface.
               
               If the tunnel's `routing` attribute is set to `BGP` (see [IPSecConnectionTunnel](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/IPSecConnectionTunnel/)), this IP address is required and used for the tunnel's BGP session.
               
               If `routing` is instead set to `STATIC`, this IP address is optional. You can set this IP address to troubleshoot or monitor the tunnel.
               
               The value must be a /30 or /31.
               
               Example: `10.0.0.4/31`
        """
        IpsecConnectionTunnelManagementBgpSessionInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bgp_ipv6state=bgp_ipv6state,
            bgp_state=bgp_state,
            customer_bgp_asn=customer_bgp_asn,
            customer_interface_ip=customer_interface_ip,
            oracle_bgp_asn=oracle_bgp_asn,
            oracle_interface_ip=oracle_interface_ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bgp_ipv6state: Optional[pulumi.Input[str]] = None,
             bgp_state: Optional[pulumi.Input[str]] = None,
             customer_bgp_asn: Optional[pulumi.Input[str]] = None,
             customer_interface_ip: Optional[pulumi.Input[str]] = None,
             oracle_bgp_asn: Optional[pulumi.Input[str]] = None,
             oracle_interface_ip: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bgp_ipv6state is not None:
            _setter("bgp_ipv6state", bgp_ipv6state)
        if bgp_state is not None:
            _setter("bgp_state", bgp_state)
        if customer_bgp_asn is not None:
            _setter("customer_bgp_asn", customer_bgp_asn)
        if customer_interface_ip is not None:
            _setter("customer_interface_ip", customer_interface_ip)
        if oracle_bgp_asn is not None:
            _setter("oracle_bgp_asn", oracle_bgp_asn)
        if oracle_interface_ip is not None:
            _setter("oracle_interface_ip", oracle_interface_ip)

    @property
    @pulumi.getter(name="bgpIpv6state")
    def bgp_ipv6state(self) -> Optional[pulumi.Input[str]]:
        """
        The state of the BGP IPv6 session.
        """
        return pulumi.get(self, "bgp_ipv6state")

    @bgp_ipv6state.setter
    def bgp_ipv6state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bgp_ipv6state", value)

    @property
    @pulumi.getter(name="bgpState")
    def bgp_state(self) -> Optional[pulumi.Input[str]]:
        """
        The state of the BGP session.
        """
        return pulumi.get(self, "bgp_state")

    @bgp_state.setter
    def bgp_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bgp_state", value)

    @property
    @pulumi.getter(name="customerBgpAsn")
    def customer_bgp_asn(self) -> Optional[pulumi.Input[str]]:
        """
        If the tunnel's `routing` attribute is set to `BGP` (see [IPSecConnectionTunnel](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/IPSecConnectionTunnel/)), this ASN is required and used for the tunnel's BGP session. This is the ASN of the network on the CPE end of the BGP session. Can be a 2-byte or 4-byte ASN. Uses "asplain" format.

        If the tunnel's `routing` attribute is set to `STATIC`, the `customerBgpAsn` must be null.

        Example: `12345` (2-byte) or `1587232876` (4-byte)
        """
        return pulumi.get(self, "customer_bgp_asn")

    @customer_bgp_asn.setter
    def customer_bgp_asn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "customer_bgp_asn", value)

    @property
    @pulumi.getter(name="customerInterfaceIp")
    def customer_interface_ip(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address for the CPE end of the inside tunnel interface.

        If the tunnel's `routing` attribute is set to `BGP` (see [IPSecConnectionTunnel](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/IPSecConnectionTunnel/)), this IP address is required and used for the tunnel's BGP session.

        If `routing` is instead set to `STATIC`, this IP address is optional. You can set this IP address to troubleshoot or monitor the tunnel.

        The value must be a /30 or /31.

        Example: `10.0.0.5/31`
        """
        return pulumi.get(self, "customer_interface_ip")

    @customer_interface_ip.setter
    def customer_interface_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "customer_interface_ip", value)

    @property
    @pulumi.getter(name="oracleBgpAsn")
    def oracle_bgp_asn(self) -> Optional[pulumi.Input[str]]:
        """
        The Oracle BGP ASN.
        """
        return pulumi.get(self, "oracle_bgp_asn")

    @oracle_bgp_asn.setter
    def oracle_bgp_asn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oracle_bgp_asn", value)

    @property
    @pulumi.getter(name="oracleInterfaceIp")
    def oracle_interface_ip(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address for the Oracle end of the inside tunnel interface.

        If the tunnel's `routing` attribute is set to `BGP` (see [IPSecConnectionTunnel](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/IPSecConnectionTunnel/)), this IP address is required and used for the tunnel's BGP session.

        If `routing` is instead set to `STATIC`, this IP address is optional. You can set this IP address to troubleshoot or monitor the tunnel.

        The value must be a /30 or /31.

        Example: `10.0.0.4/31`
        """
        return pulumi.get(self, "oracle_interface_ip")

    @oracle_interface_ip.setter
    def oracle_interface_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oracle_interface_ip", value)


@pulumi.input_type
class IpsecConnectionTunnelManagementDpdConfigArgs:
    def __init__(__self__, *,
                 dpd_mode: Optional[pulumi.Input[str]] = None,
                 dpd_timeout_in_sec: Optional[pulumi.Input[int]] = None):
        IpsecConnectionTunnelManagementDpdConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dpd_mode=dpd_mode,
            dpd_timeout_in_sec=dpd_timeout_in_sec,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dpd_mode: Optional[pulumi.Input[str]] = None,
             dpd_timeout_in_sec: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dpd_mode is not None:
            _setter("dpd_mode", dpd_mode)
        if dpd_timeout_in_sec is not None:
            _setter("dpd_timeout_in_sec", dpd_timeout_in_sec)

    @property
    @pulumi.getter(name="dpdMode")
    def dpd_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "dpd_mode")

    @dpd_mode.setter
    def dpd_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dpd_mode", value)

    @property
    @pulumi.getter(name="dpdTimeoutInSec")
    def dpd_timeout_in_sec(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "dpd_timeout_in_sec")

    @dpd_timeout_in_sec.setter
    def dpd_timeout_in_sec(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dpd_timeout_in_sec", value)


@pulumi.input_type
class IpsecConnectionTunnelManagementEncryptionDomainConfigArgs:
    def __init__(__self__, *,
                 cpe_traffic_selectors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 oracle_traffic_selectors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cpe_traffic_selectors: Lists IPv4 or IPv6-enabled subnets in your on-premises network.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oracle_traffic_selectors: Lists IPv4 or IPv6-enabled subnets in your Oracle tenancy.
        """
        IpsecConnectionTunnelManagementEncryptionDomainConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cpe_traffic_selectors=cpe_traffic_selectors,
            oracle_traffic_selectors=oracle_traffic_selectors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cpe_traffic_selectors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             oracle_traffic_selectors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cpe_traffic_selectors is not None:
            _setter("cpe_traffic_selectors", cpe_traffic_selectors)
        if oracle_traffic_selectors is not None:
            _setter("oracle_traffic_selectors", oracle_traffic_selectors)

    @property
    @pulumi.getter(name="cpeTrafficSelectors")
    def cpe_traffic_selectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Lists IPv4 or IPv6-enabled subnets in your on-premises network.
        """
        return pulumi.get(self, "cpe_traffic_selectors")

    @cpe_traffic_selectors.setter
    def cpe_traffic_selectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cpe_traffic_selectors", value)

    @property
    @pulumi.getter(name="oracleTrafficSelectors")
    def oracle_traffic_selectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Lists IPv4 or IPv6-enabled subnets in your Oracle tenancy.
        """
        return pulumi.get(self, "oracle_traffic_selectors")

    @oracle_traffic_selectors.setter
    def oracle_traffic_selectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oracle_traffic_selectors", value)


@pulumi.input_type
class IpsecConnectionTunnelManagementPhaseOneDetailArgs:
    def __init__(__self__, *,
                 custom_authentication_algorithm: Optional[pulumi.Input[str]] = None,
                 custom_dh_group: Optional[pulumi.Input[str]] = None,
                 custom_encryption_algorithm: Optional[pulumi.Input[str]] = None,
                 is_custom_phase_one_config: Optional[pulumi.Input[bool]] = None,
                 is_ike_established: Optional[pulumi.Input[bool]] = None,
                 lifetime: Optional[pulumi.Input[int]] = None,
                 negotiated_authentication_algorithm: Optional[pulumi.Input[str]] = None,
                 negotiated_dh_group: Optional[pulumi.Input[str]] = None,
                 negotiated_encryption_algorithm: Optional[pulumi.Input[str]] = None,
                 remaining_lifetime: Optional[pulumi.Input[str]] = None,
                 remaining_lifetime_last_retrieved: Optional[pulumi.Input[str]] = None):
        IpsecConnectionTunnelManagementPhaseOneDetailArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_authentication_algorithm=custom_authentication_algorithm,
            custom_dh_group=custom_dh_group,
            custom_encryption_algorithm=custom_encryption_algorithm,
            is_custom_phase_one_config=is_custom_phase_one_config,
            is_ike_established=is_ike_established,
            lifetime=lifetime,
            negotiated_authentication_algorithm=negotiated_authentication_algorithm,
            negotiated_dh_group=negotiated_dh_group,
            negotiated_encryption_algorithm=negotiated_encryption_algorithm,
            remaining_lifetime=remaining_lifetime,
            remaining_lifetime_last_retrieved=remaining_lifetime_last_retrieved,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_authentication_algorithm: Optional[pulumi.Input[str]] = None,
             custom_dh_group: Optional[pulumi.Input[str]] = None,
             custom_encryption_algorithm: Optional[pulumi.Input[str]] = None,
             is_custom_phase_one_config: Optional[pulumi.Input[bool]] = None,
             is_ike_established: Optional[pulumi.Input[bool]] = None,
             lifetime: Optional[pulumi.Input[int]] = None,
             negotiated_authentication_algorithm: Optional[pulumi.Input[str]] = None,
             negotiated_dh_group: Optional[pulumi.Input[str]] = None,
             negotiated_encryption_algorithm: Optional[pulumi.Input[str]] = None,
             remaining_lifetime: Optional[pulumi.Input[str]] = None,
             remaining_lifetime_last_retrieved: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_authentication_algorithm is not None:
            _setter("custom_authentication_algorithm", custom_authentication_algorithm)
        if custom_dh_group is not None:
            _setter("custom_dh_group", custom_dh_group)
        if custom_encryption_algorithm is not None:
            _setter("custom_encryption_algorithm", custom_encryption_algorithm)
        if is_custom_phase_one_config is not None:
            _setter("is_custom_phase_one_config", is_custom_phase_one_config)
        if is_ike_established is not None:
            _setter("is_ike_established", is_ike_established)
        if lifetime is not None:
            _setter("lifetime", lifetime)
        if negotiated_authentication_algorithm is not None:
            _setter("negotiated_authentication_algorithm", negotiated_authentication_algorithm)
        if negotiated_dh_group is not None:
            _setter("negotiated_dh_group", negotiated_dh_group)
        if negotiated_encryption_algorithm is not None:
            _setter("negotiated_encryption_algorithm", negotiated_encryption_algorithm)
        if remaining_lifetime is not None:
            _setter("remaining_lifetime", remaining_lifetime)
        if remaining_lifetime_last_retrieved is not None:
            _setter("remaining_lifetime_last_retrieved", remaining_lifetime_last_retrieved)

    @property
    @pulumi.getter(name="customAuthenticationAlgorithm")
    def custom_authentication_algorithm(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "custom_authentication_algorithm")

    @custom_authentication_algorithm.setter
    def custom_authentication_algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_authentication_algorithm", value)

    @property
    @pulumi.getter(name="customDhGroup")
    def custom_dh_group(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "custom_dh_group")

    @custom_dh_group.setter
    def custom_dh_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_dh_group", value)

    @property
    @pulumi.getter(name="customEncryptionAlgorithm")
    def custom_encryption_algorithm(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "custom_encryption_algorithm")

    @custom_encryption_algorithm.setter
    def custom_encryption_algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_encryption_algorithm", value)

    @property
    @pulumi.getter(name="isCustomPhaseOneConfig")
    def is_custom_phase_one_config(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_custom_phase_one_config")

    @is_custom_phase_one_config.setter
    def is_custom_phase_one_config(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom_phase_one_config", value)

    @property
    @pulumi.getter(name="isIkeEstablished")
    def is_ike_established(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_ike_established")

    @is_ike_established.setter
    def is_ike_established(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_ike_established", value)

    @property
    @pulumi.getter
    def lifetime(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "lifetime")

    @lifetime.setter
    def lifetime(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lifetime", value)

    @property
    @pulumi.getter(name="negotiatedAuthenticationAlgorithm")
    def negotiated_authentication_algorithm(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "negotiated_authentication_algorithm")

    @negotiated_authentication_algorithm.setter
    def negotiated_authentication_algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "negotiated_authentication_algorithm", value)

    @property
    @pulumi.getter(name="negotiatedDhGroup")
    def negotiated_dh_group(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "negotiated_dh_group")

    @negotiated_dh_group.setter
    def negotiated_dh_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "negotiated_dh_group", value)

    @property
    @pulumi.getter(name="negotiatedEncryptionAlgorithm")
    def negotiated_encryption_algorithm(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "negotiated_encryption_algorithm")

    @negotiated_encryption_algorithm.setter
    def negotiated_encryption_algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "negotiated_encryption_algorithm", value)

    @property
    @pulumi.getter(name="remainingLifetime")
    def remaining_lifetime(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "remaining_lifetime")

    @remaining_lifetime.setter
    def remaining_lifetime(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remaining_lifetime", value)

    @property
    @pulumi.getter(name="remainingLifetimeLastRetrieved")
    def remaining_lifetime_last_retrieved(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "remaining_lifetime_last_retrieved")

    @remaining_lifetime_last_retrieved.setter
    def remaining_lifetime_last_retrieved(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remaining_lifetime_last_retrieved", value)


@pulumi.input_type
class IpsecConnectionTunnelManagementPhaseTwoDetailArgs:
    def __init__(__self__, *,
                 custom_authentication_algorithm: Optional[pulumi.Input[str]] = None,
                 custom_encryption_algorithm: Optional[pulumi.Input[str]] = None,
                 dh_group: Optional[pulumi.Input[str]] = None,
                 is_custom_phase_two_config: Optional[pulumi.Input[bool]] = None,
                 is_esp_established: Optional[pulumi.Input[bool]] = None,
                 is_pfs_enabled: Optional[pulumi.Input[bool]] = None,
                 lifetime: Optional[pulumi.Input[int]] = None,
                 negotiated_authentication_algorithm: Optional[pulumi.Input[str]] = None,
                 negotiated_dh_group: Optional[pulumi.Input[str]] = None,
                 negotiated_encryption_algorithm: Optional[pulumi.Input[str]] = None,
                 remaining_lifetime: Optional[pulumi.Input[str]] = None,
                 remaining_lifetime_last_retrieved: Optional[pulumi.Input[str]] = None):
        IpsecConnectionTunnelManagementPhaseTwoDetailArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_authentication_algorithm=custom_authentication_algorithm,
            custom_encryption_algorithm=custom_encryption_algorithm,
            dh_group=dh_group,
            is_custom_phase_two_config=is_custom_phase_two_config,
            is_esp_established=is_esp_established,
            is_pfs_enabled=is_pfs_enabled,
            lifetime=lifetime,
            negotiated_authentication_algorithm=negotiated_authentication_algorithm,
            negotiated_dh_group=negotiated_dh_group,
            negotiated_encryption_algorithm=negotiated_encryption_algorithm,
            remaining_lifetime=remaining_lifetime,
            remaining_lifetime_last_retrieved=remaining_lifetime_last_retrieved,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_authentication_algorithm: Optional[pulumi.Input[str]] = None,
             custom_encryption_algorithm: Optional[pulumi.Input[str]] = None,
             dh_group: Optional[pulumi.Input[str]] = None,
             is_custom_phase_two_config: Optional[pulumi.Input[bool]] = None,
             is_esp_established: Optional[pulumi.Input[bool]] = None,
             is_pfs_enabled: Optional[pulumi.Input[bool]] = None,
             lifetime: Optional[pulumi.Input[int]] = None,
             negotiated_authentication_algorithm: Optional[pulumi.Input[str]] = None,
             negotiated_dh_group: Optional[pulumi.Input[str]] = None,
             negotiated_encryption_algorithm: Optional[pulumi.Input[str]] = None,
             remaining_lifetime: Optional[pulumi.Input[str]] = None,
             remaining_lifetime_last_retrieved: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_authentication_algorithm is not None:
            _setter("custom_authentication_algorithm", custom_authentication_algorithm)
        if custom_encryption_algorithm is not None:
            _setter("custom_encryption_algorithm", custom_encryption_algorithm)
        if dh_group is not None:
            _setter("dh_group", dh_group)
        if is_custom_phase_two_config is not None:
            _setter("is_custom_phase_two_config", is_custom_phase_two_config)
        if is_esp_established is not None:
            _setter("is_esp_established", is_esp_established)
        if is_pfs_enabled is not None:
            _setter("is_pfs_enabled", is_pfs_enabled)
        if lifetime is not None:
            _setter("lifetime", lifetime)
        if negotiated_authentication_algorithm is not None:
            _setter("negotiated_authentication_algorithm", negotiated_authentication_algorithm)
        if negotiated_dh_group is not None:
            _setter("negotiated_dh_group", negotiated_dh_group)
        if negotiated_encryption_algorithm is not None:
            _setter("negotiated_encryption_algorithm", negotiated_encryption_algorithm)
        if remaining_lifetime is not None:
            _setter("remaining_lifetime", remaining_lifetime)
        if remaining_lifetime_last_retrieved is not None:
            _setter("remaining_lifetime_last_retrieved", remaining_lifetime_last_retrieved)

    @property
    @pulumi.getter(name="customAuthenticationAlgorithm")
    def custom_authentication_algorithm(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "custom_authentication_algorithm")

    @custom_authentication_algorithm.setter
    def custom_authentication_algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_authentication_algorithm", value)

    @property
    @pulumi.getter(name="customEncryptionAlgorithm")
    def custom_encryption_algorithm(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "custom_encryption_algorithm")

    @custom_encryption_algorithm.setter
    def custom_encryption_algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_encryption_algorithm", value)

    @property
    @pulumi.getter(name="dhGroup")
    def dh_group(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "dh_group")

    @dh_group.setter
    def dh_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dh_group", value)

    @property
    @pulumi.getter(name="isCustomPhaseTwoConfig")
    def is_custom_phase_two_config(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_custom_phase_two_config")

    @is_custom_phase_two_config.setter
    def is_custom_phase_two_config(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom_phase_two_config", value)

    @property
    @pulumi.getter(name="isEspEstablished")
    def is_esp_established(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_esp_established")

    @is_esp_established.setter
    def is_esp_established(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_esp_established", value)

    @property
    @pulumi.getter(name="isPfsEnabled")
    def is_pfs_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_pfs_enabled")

    @is_pfs_enabled.setter
    def is_pfs_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_pfs_enabled", value)

    @property
    @pulumi.getter
    def lifetime(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "lifetime")

    @lifetime.setter
    def lifetime(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lifetime", value)

    @property
    @pulumi.getter(name="negotiatedAuthenticationAlgorithm")
    def negotiated_authentication_algorithm(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "negotiated_authentication_algorithm")

    @negotiated_authentication_algorithm.setter
    def negotiated_authentication_algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "negotiated_authentication_algorithm", value)

    @property
    @pulumi.getter(name="negotiatedDhGroup")
    def negotiated_dh_group(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "negotiated_dh_group")

    @negotiated_dh_group.setter
    def negotiated_dh_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "negotiated_dh_group", value)

    @property
    @pulumi.getter(name="negotiatedEncryptionAlgorithm")
    def negotiated_encryption_algorithm(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "negotiated_encryption_algorithm")

    @negotiated_encryption_algorithm.setter
    def negotiated_encryption_algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "negotiated_encryption_algorithm", value)

    @property
    @pulumi.getter(name="remainingLifetime")
    def remaining_lifetime(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "remaining_lifetime")

    @remaining_lifetime.setter
    def remaining_lifetime(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remaining_lifetime", value)

    @property
    @pulumi.getter(name="remainingLifetimeLastRetrieved")
    def remaining_lifetime_last_retrieved(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "remaining_lifetime_last_retrieved")

    @remaining_lifetime_last_retrieved.setter
    def remaining_lifetime_last_retrieved(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remaining_lifetime_last_retrieved", value)


@pulumi.input_type
class NetworkSecurityGroupSecurityRuleIcmpOptionsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[int],
                 code: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] type: The ICMP type.
        :param pulumi.Input[int] code: The ICMP code (optional).
        """
        NetworkSecurityGroupSecurityRuleIcmpOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            code=code,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[int],
             code: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if code is not None:
            _setter("code", code)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[int]:
        """
        The ICMP type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[int]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        """
        The ICMP code (optional).
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)


@pulumi.input_type
class NetworkSecurityGroupSecurityRuleTcpOptionsArgs:
    def __init__(__self__, *,
                 destination_port_range: Optional[pulumi.Input['NetworkSecurityGroupSecurityRuleTcpOptionsDestinationPortRangeArgs']] = None,
                 source_port_range: Optional[pulumi.Input['NetworkSecurityGroupSecurityRuleTcpOptionsSourcePortRangeArgs']] = None):
        NetworkSecurityGroupSecurityRuleTcpOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_port_range=destination_port_range,
            source_port_range=source_port_range,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_port_range: Optional[pulumi.Input['NetworkSecurityGroupSecurityRuleTcpOptionsDestinationPortRangeArgs']] = None,
             source_port_range: Optional[pulumi.Input['NetworkSecurityGroupSecurityRuleTcpOptionsSourcePortRangeArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if destination_port_range is not None:
            _setter("destination_port_range", destination_port_range)
        if source_port_range is not None:
            _setter("source_port_range", source_port_range)

    @property
    @pulumi.getter(name="destinationPortRange")
    def destination_port_range(self) -> Optional[pulumi.Input['NetworkSecurityGroupSecurityRuleTcpOptionsDestinationPortRangeArgs']]:
        return pulumi.get(self, "destination_port_range")

    @destination_port_range.setter
    def destination_port_range(self, value: Optional[pulumi.Input['NetworkSecurityGroupSecurityRuleTcpOptionsDestinationPortRangeArgs']]):
        pulumi.set(self, "destination_port_range", value)

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional[pulumi.Input['NetworkSecurityGroupSecurityRuleTcpOptionsSourcePortRangeArgs']]:
        return pulumi.get(self, "source_port_range")

    @source_port_range.setter
    def source_port_range(self, value: Optional[pulumi.Input['NetworkSecurityGroupSecurityRuleTcpOptionsSourcePortRangeArgs']]):
        pulumi.set(self, "source_port_range", value)


@pulumi.input_type
class NetworkSecurityGroupSecurityRuleTcpOptionsDestinationPortRangeArgs:
    def __init__(__self__, *,
                 max: pulumi.Input[int],
                 min: pulumi.Input[int]):
        """
        :param pulumi.Input[int] max: The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        :param pulumi.Input[int] min: The minimum port number, which must not be greater than the maximum port number. 
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        NetworkSecurityGroupSecurityRuleTcpOptionsDestinationPortRangeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: pulumi.Input[int],
             min: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("max", max)
        _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> pulumi.Input[int]:
        """
        The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[int]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> pulumi.Input[int]:
        """
        The minimum port number, which must not be greater than the maximum port number. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[int]):
        pulumi.set(self, "min", value)


@pulumi.input_type
class NetworkSecurityGroupSecurityRuleTcpOptionsSourcePortRangeArgs:
    def __init__(__self__, *,
                 max: pulumi.Input[int],
                 min: pulumi.Input[int]):
        """
        :param pulumi.Input[int] max: The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        :param pulumi.Input[int] min: The minimum port number, which must not be greater than the maximum port number. 
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        NetworkSecurityGroupSecurityRuleTcpOptionsSourcePortRangeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: pulumi.Input[int],
             min: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("max", max)
        _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> pulumi.Input[int]:
        """
        The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[int]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> pulumi.Input[int]:
        """
        The minimum port number, which must not be greater than the maximum port number. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[int]):
        pulumi.set(self, "min", value)


@pulumi.input_type
class NetworkSecurityGroupSecurityRuleUdpOptionsArgs:
    def __init__(__self__, *,
                 destination_port_range: Optional[pulumi.Input['NetworkSecurityGroupSecurityRuleUdpOptionsDestinationPortRangeArgs']] = None,
                 source_port_range: Optional[pulumi.Input['NetworkSecurityGroupSecurityRuleUdpOptionsSourcePortRangeArgs']] = None):
        NetworkSecurityGroupSecurityRuleUdpOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_port_range=destination_port_range,
            source_port_range=source_port_range,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_port_range: Optional[pulumi.Input['NetworkSecurityGroupSecurityRuleUdpOptionsDestinationPortRangeArgs']] = None,
             source_port_range: Optional[pulumi.Input['NetworkSecurityGroupSecurityRuleUdpOptionsSourcePortRangeArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if destination_port_range is not None:
            _setter("destination_port_range", destination_port_range)
        if source_port_range is not None:
            _setter("source_port_range", source_port_range)

    @property
    @pulumi.getter(name="destinationPortRange")
    def destination_port_range(self) -> Optional[pulumi.Input['NetworkSecurityGroupSecurityRuleUdpOptionsDestinationPortRangeArgs']]:
        return pulumi.get(self, "destination_port_range")

    @destination_port_range.setter
    def destination_port_range(self, value: Optional[pulumi.Input['NetworkSecurityGroupSecurityRuleUdpOptionsDestinationPortRangeArgs']]):
        pulumi.set(self, "destination_port_range", value)

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional[pulumi.Input['NetworkSecurityGroupSecurityRuleUdpOptionsSourcePortRangeArgs']]:
        return pulumi.get(self, "source_port_range")

    @source_port_range.setter
    def source_port_range(self, value: Optional[pulumi.Input['NetworkSecurityGroupSecurityRuleUdpOptionsSourcePortRangeArgs']]):
        pulumi.set(self, "source_port_range", value)


@pulumi.input_type
class NetworkSecurityGroupSecurityRuleUdpOptionsDestinationPortRangeArgs:
    def __init__(__self__, *,
                 max: pulumi.Input[int],
                 min: pulumi.Input[int]):
        """
        :param pulumi.Input[int] max: The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        :param pulumi.Input[int] min: The minimum port number, which must not be greater than the maximum port number. 
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        NetworkSecurityGroupSecurityRuleUdpOptionsDestinationPortRangeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: pulumi.Input[int],
             min: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("max", max)
        _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> pulumi.Input[int]:
        """
        The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[int]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> pulumi.Input[int]:
        """
        The minimum port number, which must not be greater than the maximum port number. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[int]):
        pulumi.set(self, "min", value)


@pulumi.input_type
class NetworkSecurityGroupSecurityRuleUdpOptionsSourcePortRangeArgs:
    def __init__(__self__, *,
                 max: pulumi.Input[int],
                 min: pulumi.Input[int]):
        """
        :param pulumi.Input[int] max: The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        :param pulumi.Input[int] min: The minimum port number, which must not be greater than the maximum port number. 
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        NetworkSecurityGroupSecurityRuleUdpOptionsSourcePortRangeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: pulumi.Input[int],
             min: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("max", max)
        _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> pulumi.Input[int]:
        """
        The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[int]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> pulumi.Input[int]:
        """
        The minimum port number, which must not be greater than the maximum port number. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[int]):
        pulumi.set(self, "min", value)


@pulumi.input_type
class RouteTableRouteRuleArgs:
    def __init__(__self__, *,
                 network_entity_id: pulumi.Input[str],
                 cidr_block: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 destination: Optional[pulumi.Input[str]] = None,
                 destination_type: Optional[pulumi.Input[str]] = None,
                 route_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] network_entity_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the route rule's target. For information about the type of targets you can specify, see [Route Tables](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/managingroutetables.htm).
        :param pulumi.Input[str] cidr_block: (Updatable) Deprecated. Instead use `destination` and `destinationType`. Requests that include both `cidrBlock` and `destination` will be rejected.
               
               A destination IP address range in CIDR notation. Matching packets will be routed to the indicated network entity (the target).
               
               Cannot be an IPv6 prefix.
               
               Example: `0.0.0.0/0`
        :param pulumi.Input[str] description: (Updatable) An optional description of your choice for the rule.
        :param pulumi.Input[str] destination: (Updatable) Conceptually, this is the range of IP addresses used for matching when routing traffic. Required if you provide a `destinationType`.
               
               Allowed values:
               * IP address range in CIDR notation. Can be an IPv4 CIDR block or IPv6 prefix. For example: `192.168.1.0/24` or `2001:0db8:0123:45::/56`. If you set this to an IPv6 prefix, the route rule's target can only be a DRG or internet gateway. IPv6 addressing is supported for all commercial and government regions. See [IPv6 Addresses](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/ipv6.htm).
               * The `cidrBlock` value for a [Service](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Service/), if you're setting up a route rule for traffic destined for a particular `Service` through a service gateway. For example: `oci-phx-objectstorage`.
        :param pulumi.Input[str] destination_type: (Updatable) Type of destination for the rule. Required if you provide a `destination`.
        :param pulumi.Input[str] route_type: (Updatable) A route rule can be STATIC if manually added to the route table, LOCAL if added by Oracle Cloud Infrastructure to the route table.
        """
        RouteTableRouteRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            network_entity_id=network_entity_id,
            cidr_block=cidr_block,
            description=description,
            destination=destination,
            destination_type=destination_type,
            route_type=route_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             network_entity_id: pulumi.Input[str],
             cidr_block: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             destination: Optional[pulumi.Input[str]] = None,
             destination_type: Optional[pulumi.Input[str]] = None,
             route_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("network_entity_id", network_entity_id)
        if cidr_block is not None:
            warnings.warn("""The 'cidr_block' field has been deprecated. Please use 'destination' instead.""", DeprecationWarning)
            pulumi.log.warn("""cidr_block is deprecated: The 'cidr_block' field has been deprecated. Please use 'destination' instead.""")
        if cidr_block is not None:
            _setter("cidr_block", cidr_block)
        if description is not None:
            _setter("description", description)
        if destination is not None:
            _setter("destination", destination)
        if destination_type is not None:
            _setter("destination_type", destination_type)
        if route_type is not None:
            _setter("route_type", route_type)

    @property
    @pulumi.getter(name="networkEntityId")
    def network_entity_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the route rule's target. For information about the type of targets you can specify, see [Route Tables](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/managingroutetables.htm).
        """
        return pulumi.get(self, "network_entity_id")

    @network_entity_id.setter
    def network_entity_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_entity_id", value)

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Deprecated. Instead use `destination` and `destinationType`. Requests that include both `cidrBlock` and `destination` will be rejected.

        A destination IP address range in CIDR notation. Matching packets will be routed to the indicated network entity (the target).

        Cannot be an IPv6 prefix.

        Example: `0.0.0.0/0`
        """
        warnings.warn("""The 'cidr_block' field has been deprecated. Please use 'destination' instead.""", DeprecationWarning)
        pulumi.log.warn("""cidr_block is deprecated: The 'cidr_block' field has been deprecated. Please use 'destination' instead.""")

        return pulumi.get(self, "cidr_block")

    @cidr_block.setter
    def cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cidr_block", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) An optional description of your choice for the rule.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Conceptually, this is the range of IP addresses used for matching when routing traffic. Required if you provide a `destinationType`.

        Allowed values:
        * IP address range in CIDR notation. Can be an IPv4 CIDR block or IPv6 prefix. For example: `192.168.1.0/24` or `2001:0db8:0123:45::/56`. If you set this to an IPv6 prefix, the route rule's target can only be a DRG or internet gateway. IPv6 addressing is supported for all commercial and government regions. See [IPv6 Addresses](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/ipv6.htm).
        * The `cidrBlock` value for a [Service](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Service/), if you're setting up a route rule for traffic destined for a particular `Service` through a service gateway. For example: `oci-phx-objectstorage`.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Type of destination for the rule. Required if you provide a `destination`.
        """
        return pulumi.get(self, "destination_type")

    @destination_type.setter
    def destination_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_type", value)

    @property
    @pulumi.getter(name="routeType")
    def route_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A route rule can be STATIC if manually added to the route table, LOCAL if added by Oracle Cloud Infrastructure to the route table.
        """
        return pulumi.get(self, "route_type")

    @route_type.setter
    def route_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "route_type", value)


@pulumi.input_type
class SecurityListEgressSecurityRuleArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 protocol: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 destination_type: Optional[pulumi.Input[str]] = None,
                 icmp_options: Optional[pulumi.Input['SecurityListEgressSecurityRuleIcmpOptionsArgs']] = None,
                 stateless: Optional[pulumi.Input[bool]] = None,
                 tcp_options: Optional[pulumi.Input['SecurityListEgressSecurityRuleTcpOptionsArgs']] = None,
                 udp_options: Optional[pulumi.Input['SecurityListEgressSecurityRuleUdpOptionsArgs']] = None):
        """
        :param pulumi.Input[str] destination: (Updatable) Conceptually, this is the range of IP addresses that a packet originating from the instance can go to.
               
               Allowed values:
               * IP address range in CIDR notation. For example: `192.168.1.0/24` or `2001:0db8:0123:45::/56` Note that IPv6 addressing is currently supported only in certain regions. See [IPv6 Addresses](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/ipv6.htm).
               * The `cidrBlock` value for a [Service](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Service/), if you're setting up a security list rule for traffic destined for a particular `Service` through a service gateway. For example: `oci-phx-objectstorage`.
        :param pulumi.Input[str] protocol: (Updatable) The transport protocol. Specify either `all` or an IPv4 protocol number as defined in [Protocol Numbers](http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml). Options are supported only for ICMP ("1"), TCP ("6"), UDP ("17"), and ICMPv6 ("58").
        :param pulumi.Input[str] description: (Updatable) An optional description of your choice for the rule.
        :param pulumi.Input[str] destination_type: (Updatable) Type of destination for the rule. The default is `CIDR_BLOCK`.
               
               Allowed values:
        :param pulumi.Input['SecurityListEgressSecurityRuleIcmpOptionsArgs'] icmp_options: (Updatable) Optional and valid only for ICMP and ICMPv6. Use to specify a particular ICMP type and code as defined in:
               * [ICMP Parameters](http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml)
               * [ICMPv6 Parameters](https://www.iana.org/assignments/icmpv6-parameters/icmpv6-parameters.xhtml)
               
               If you specify ICMP or ICMPv6 as the protocol but omit this object, then all ICMP types and codes are allowed. If you do provide this object, the type is required and the code is optional. To enable MTU negotiation for ingress internet traffic via IPv4, make sure to allow type 3 ("Destination Unreachable") code 4 ("Fragmentation Needed and Don't Fragment was Set"). If you need to specify multiple codes for a single type, create a separate security list rule for each.
        :param pulumi.Input[bool] stateless: (Updatable) A stateless rule allows traffic in one direction. Remember to add a corresponding stateless rule in the other direction if you need to support bidirectional traffic. For example, if ingress traffic allows TCP destination port 80, there should be an egress rule to allow TCP source port 80. Defaults to false, which means the rule is stateful and a corresponding rule is not necessary for bidirectional traffic.
        :param pulumi.Input['SecurityListEgressSecurityRuleTcpOptionsArgs'] tcp_options: (Updatable) Optional and valid only for TCP. Use to specify particular destination ports for TCP rules. If you specify TCP as the protocol but omit this object, then all destination ports are allowed.
        :param pulumi.Input['SecurityListEgressSecurityRuleUdpOptionsArgs'] udp_options: (Updatable) Optional and valid only for UDP. Use to specify particular destination ports for UDP rules. If you specify UDP as the protocol but omit this object, then all destination ports are allowed.
        """
        SecurityListEgressSecurityRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            protocol=protocol,
            description=description,
            destination_type=destination_type,
            icmp_options=icmp_options,
            stateless=stateless,
            tcp_options=tcp_options,
            udp_options=udp_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: pulumi.Input[str],
             protocol: pulumi.Input[str],
             description: Optional[pulumi.Input[str]] = None,
             destination_type: Optional[pulumi.Input[str]] = None,
             icmp_options: Optional[pulumi.Input['SecurityListEgressSecurityRuleIcmpOptionsArgs']] = None,
             stateless: Optional[pulumi.Input[bool]] = None,
             tcp_options: Optional[pulumi.Input['SecurityListEgressSecurityRuleTcpOptionsArgs']] = None,
             udp_options: Optional[pulumi.Input['SecurityListEgressSecurityRuleUdpOptionsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("destination", destination)
        _setter("protocol", protocol)
        if description is not None:
            _setter("description", description)
        if destination_type is not None:
            _setter("destination_type", destination_type)
        if icmp_options is not None:
            _setter("icmp_options", icmp_options)
        if stateless is not None:
            _setter("stateless", stateless)
        if tcp_options is not None:
            _setter("tcp_options", tcp_options)
        if udp_options is not None:
            _setter("udp_options", udp_options)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        (Updatable) Conceptually, this is the range of IP addresses that a packet originating from the instance can go to.

        Allowed values:
        * IP address range in CIDR notation. For example: `192.168.1.0/24` or `2001:0db8:0123:45::/56` Note that IPv6 addressing is currently supported only in certain regions. See [IPv6 Addresses](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/ipv6.htm).
        * The `cidrBlock` value for a [Service](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Service/), if you're setting up a security list rule for traffic destined for a particular `Service` through a service gateway. For example: `oci-phx-objectstorage`.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        (Updatable) The transport protocol. Specify either `all` or an IPv4 protocol number as defined in [Protocol Numbers](http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml). Options are supported only for ICMP ("1"), TCP ("6"), UDP ("17"), and ICMPv6 ("58").
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) An optional description of your choice for the rule.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Type of destination for the rule. The default is `CIDR_BLOCK`.

        Allowed values:
        """
        return pulumi.get(self, "destination_type")

    @destination_type.setter
    def destination_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_type", value)

    @property
    @pulumi.getter(name="icmpOptions")
    def icmp_options(self) -> Optional[pulumi.Input['SecurityListEgressSecurityRuleIcmpOptionsArgs']]:
        """
        (Updatable) Optional and valid only for ICMP and ICMPv6. Use to specify a particular ICMP type and code as defined in:
        * [ICMP Parameters](http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml)
        * [ICMPv6 Parameters](https://www.iana.org/assignments/icmpv6-parameters/icmpv6-parameters.xhtml)

        If you specify ICMP or ICMPv6 as the protocol but omit this object, then all ICMP types and codes are allowed. If you do provide this object, the type is required and the code is optional. To enable MTU negotiation for ingress internet traffic via IPv4, make sure to allow type 3 ("Destination Unreachable") code 4 ("Fragmentation Needed and Don't Fragment was Set"). If you need to specify multiple codes for a single type, create a separate security list rule for each.
        """
        return pulumi.get(self, "icmp_options")

    @icmp_options.setter
    def icmp_options(self, value: Optional[pulumi.Input['SecurityListEgressSecurityRuleIcmpOptionsArgs']]):
        pulumi.set(self, "icmp_options", value)

    @property
    @pulumi.getter
    def stateless(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) A stateless rule allows traffic in one direction. Remember to add a corresponding stateless rule in the other direction if you need to support bidirectional traffic. For example, if ingress traffic allows TCP destination port 80, there should be an egress rule to allow TCP source port 80. Defaults to false, which means the rule is stateful and a corresponding rule is not necessary for bidirectional traffic.
        """
        return pulumi.get(self, "stateless")

    @stateless.setter
    def stateless(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "stateless", value)

    @property
    @pulumi.getter(name="tcpOptions")
    def tcp_options(self) -> Optional[pulumi.Input['SecurityListEgressSecurityRuleTcpOptionsArgs']]:
        """
        (Updatable) Optional and valid only for TCP. Use to specify particular destination ports for TCP rules. If you specify TCP as the protocol but omit this object, then all destination ports are allowed.
        """
        return pulumi.get(self, "tcp_options")

    @tcp_options.setter
    def tcp_options(self, value: Optional[pulumi.Input['SecurityListEgressSecurityRuleTcpOptionsArgs']]):
        pulumi.set(self, "tcp_options", value)

    @property
    @pulumi.getter(name="udpOptions")
    def udp_options(self) -> Optional[pulumi.Input['SecurityListEgressSecurityRuleUdpOptionsArgs']]:
        """
        (Updatable) Optional and valid only for UDP. Use to specify particular destination ports for UDP rules. If you specify UDP as the protocol but omit this object, then all destination ports are allowed.
        """
        return pulumi.get(self, "udp_options")

    @udp_options.setter
    def udp_options(self, value: Optional[pulumi.Input['SecurityListEgressSecurityRuleUdpOptionsArgs']]):
        pulumi.set(self, "udp_options", value)


@pulumi.input_type
class SecurityListEgressSecurityRuleIcmpOptionsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[int],
                 code: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] type: (Updatable) The ICMP type.
        :param pulumi.Input[int] code: (Updatable) The ICMP code (optional).
        """
        SecurityListEgressSecurityRuleIcmpOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            code=code,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[int],
             code: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if code is not None:
            _setter("code", code)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[int]:
        """
        (Updatable) The ICMP type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[int]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The ICMP code (optional).
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)


@pulumi.input_type
class SecurityListEgressSecurityRuleTcpOptionsArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[int]] = None,
                 min: Optional[pulumi.Input[int]] = None,
                 source_port_range: Optional[pulumi.Input['SecurityListEgressSecurityRuleTcpOptionsSourcePortRangeArgs']] = None):
        """
        :param pulumi.Input[int] max: (Updatable) The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        :param pulumi.Input[int] min: (Updatable) The minimum port number, which must not be greater than the maximum port number.
        :param pulumi.Input['SecurityListEgressSecurityRuleTcpOptionsSourcePortRangeArgs'] source_port_range: (Updatable)
        """
        SecurityListEgressSecurityRuleTcpOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
            source_port_range=source_port_range,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[pulumi.Input[int]] = None,
             min: Optional[pulumi.Input[int]] = None,
             source_port_range: Optional[pulumi.Input['SecurityListEgressSecurityRuleTcpOptionsSourcePortRangeArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)
        if source_port_range is not None:
            _setter("source_port_range", source_port_range)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The minimum port number, which must not be greater than the maximum port number.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional[pulumi.Input['SecurityListEgressSecurityRuleTcpOptionsSourcePortRangeArgs']]:
        """
        (Updatable)
        """
        return pulumi.get(self, "source_port_range")

    @source_port_range.setter
    def source_port_range(self, value: Optional[pulumi.Input['SecurityListEgressSecurityRuleTcpOptionsSourcePortRangeArgs']]):
        pulumi.set(self, "source_port_range", value)


@pulumi.input_type
class SecurityListEgressSecurityRuleTcpOptionsSourcePortRangeArgs:
    def __init__(__self__, *,
                 max: pulumi.Input[int],
                 min: pulumi.Input[int]):
        """
        :param pulumi.Input[int] max: (Updatable) The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        :param pulumi.Input[int] min: (Updatable) The minimum port number, which must not be greater than the maximum port number.
        """
        SecurityListEgressSecurityRuleTcpOptionsSourcePortRangeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: pulumi.Input[int],
             min: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("max", max)
        _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> pulumi.Input[int]:
        """
        (Updatable) The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[int]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> pulumi.Input[int]:
        """
        (Updatable) The minimum port number, which must not be greater than the maximum port number.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[int]):
        pulumi.set(self, "min", value)


@pulumi.input_type
class SecurityListEgressSecurityRuleUdpOptionsArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[int]] = None,
                 min: Optional[pulumi.Input[int]] = None,
                 source_port_range: Optional[pulumi.Input['SecurityListEgressSecurityRuleUdpOptionsSourcePortRangeArgs']] = None):
        """
        :param pulumi.Input[int] max: (Updatable) The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        :param pulumi.Input[int] min: (Updatable) The minimum port number, which must not be greater than the maximum port number.
        :param pulumi.Input['SecurityListEgressSecurityRuleUdpOptionsSourcePortRangeArgs'] source_port_range: (Updatable)
        """
        SecurityListEgressSecurityRuleUdpOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
            source_port_range=source_port_range,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[pulumi.Input[int]] = None,
             min: Optional[pulumi.Input[int]] = None,
             source_port_range: Optional[pulumi.Input['SecurityListEgressSecurityRuleUdpOptionsSourcePortRangeArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)
        if source_port_range is not None:
            _setter("source_port_range", source_port_range)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The minimum port number, which must not be greater than the maximum port number.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional[pulumi.Input['SecurityListEgressSecurityRuleUdpOptionsSourcePortRangeArgs']]:
        """
        (Updatable)
        """
        return pulumi.get(self, "source_port_range")

    @source_port_range.setter
    def source_port_range(self, value: Optional[pulumi.Input['SecurityListEgressSecurityRuleUdpOptionsSourcePortRangeArgs']]):
        pulumi.set(self, "source_port_range", value)


@pulumi.input_type
class SecurityListEgressSecurityRuleUdpOptionsSourcePortRangeArgs:
    def __init__(__self__, *,
                 max: pulumi.Input[int],
                 min: pulumi.Input[int]):
        """
        :param pulumi.Input[int] max: (Updatable) The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        :param pulumi.Input[int] min: (Updatable) The minimum port number, which must not be greater than the maximum port number.
        """
        SecurityListEgressSecurityRuleUdpOptionsSourcePortRangeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: pulumi.Input[int],
             min: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("max", max)
        _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> pulumi.Input[int]:
        """
        (Updatable) The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[int]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> pulumi.Input[int]:
        """
        (Updatable) The minimum port number, which must not be greater than the maximum port number.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[int]):
        pulumi.set(self, "min", value)


@pulumi.input_type
class SecurityListIngressSecurityRuleArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 source: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 icmp_options: Optional[pulumi.Input['SecurityListIngressSecurityRuleIcmpOptionsArgs']] = None,
                 source_type: Optional[pulumi.Input[str]] = None,
                 stateless: Optional[pulumi.Input[bool]] = None,
                 tcp_options: Optional[pulumi.Input['SecurityListIngressSecurityRuleTcpOptionsArgs']] = None,
                 udp_options: Optional[pulumi.Input['SecurityListIngressSecurityRuleUdpOptionsArgs']] = None):
        """
        :param pulumi.Input[str] protocol: (Updatable) The transport protocol. Specify either `all` or an IPv4 protocol number as defined in [Protocol Numbers](http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml). Options are supported only for ICMP ("1"), TCP ("6"), UDP ("17"), and ICMPv6 ("58").
        :param pulumi.Input[str] source: (Updatable) Conceptually, this is the range of IP addresses that a packet coming into the instance can come from.
               
               Allowed values:
               * IP address range in CIDR notation. For example: `192.168.1.0/24` or `2001:0db8:0123:45::/56`. IPv6 addressing is supported for all commercial and government regions. See [IPv6 Addresses](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/ipv6.htm).
               * The `cidrBlock` value for a [Service](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Service/), if you're setting up a security list rule for traffic coming from a particular `Service` through a service gateway. For example: `oci-phx-objectstorage`.
        :param pulumi.Input[str] description: (Updatable) An optional description of your choice for the rule.
        :param pulumi.Input['SecurityListIngressSecurityRuleIcmpOptionsArgs'] icmp_options: (Updatable) Optional and valid only for ICMP and ICMPv6. Use to specify a particular ICMP type and code as defined in:
               * [ICMP Parameters](http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml)
               * [ICMPv6 Parameters](https://www.iana.org/assignments/icmpv6-parameters/icmpv6-parameters.xhtml)
               
               If you specify ICMP or ICMPv6 as the protocol but omit this object, then all ICMP types and codes are allowed. If you do provide this object, the type is required and the code is optional. To enable MTU negotiation for ingress internet traffic via IPv4, make sure to allow type 3 ("Destination Unreachable") code 4 ("Fragmentation Needed and Don't Fragment was Set"). If you need to specify multiple codes for a single type, create a separate security list rule for each.
        :param pulumi.Input[str] source_type: (Updatable) Type of source for the rule. The default is `CIDR_BLOCK`.
        :param pulumi.Input[bool] stateless: (Updatable) A stateless rule allows traffic in one direction. Remember to add a corresponding stateless rule in the other direction if you need to support bidirectional traffic. For example, if ingress traffic allows TCP destination port 80, there should be an egress rule to allow TCP source port 80. Defaults to false, which means the rule is stateful and a corresponding rule is not necessary for bidirectional traffic.
        :param pulumi.Input['SecurityListIngressSecurityRuleTcpOptionsArgs'] tcp_options: (Updatable) Optional and valid only for TCP. Use to specify particular destination ports for TCP rules. If you specify TCP as the protocol but omit this object, then all destination ports are allowed.
        :param pulumi.Input['SecurityListIngressSecurityRuleUdpOptionsArgs'] udp_options: (Updatable) Optional and valid only for UDP. Use to specify particular destination ports for UDP rules. If you specify UDP as the protocol but omit this object, then all destination ports are allowed.
        """
        SecurityListIngressSecurityRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            protocol=protocol,
            source=source,
            description=description,
            icmp_options=icmp_options,
            source_type=source_type,
            stateless=stateless,
            tcp_options=tcp_options,
            udp_options=udp_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             protocol: pulumi.Input[str],
             source: pulumi.Input[str],
             description: Optional[pulumi.Input[str]] = None,
             icmp_options: Optional[pulumi.Input['SecurityListIngressSecurityRuleIcmpOptionsArgs']] = None,
             source_type: Optional[pulumi.Input[str]] = None,
             stateless: Optional[pulumi.Input[bool]] = None,
             tcp_options: Optional[pulumi.Input['SecurityListIngressSecurityRuleTcpOptionsArgs']] = None,
             udp_options: Optional[pulumi.Input['SecurityListIngressSecurityRuleUdpOptionsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("protocol", protocol)
        _setter("source", source)
        if description is not None:
            _setter("description", description)
        if icmp_options is not None:
            _setter("icmp_options", icmp_options)
        if source_type is not None:
            _setter("source_type", source_type)
        if stateless is not None:
            _setter("stateless", stateless)
        if tcp_options is not None:
            _setter("tcp_options", tcp_options)
        if udp_options is not None:
            _setter("udp_options", udp_options)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        (Updatable) The transport protocol. Specify either `all` or an IPv4 protocol number as defined in [Protocol Numbers](http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml). Options are supported only for ICMP ("1"), TCP ("6"), UDP ("17"), and ICMPv6 ("58").
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        (Updatable) Conceptually, this is the range of IP addresses that a packet coming into the instance can come from.

        Allowed values:
        * IP address range in CIDR notation. For example: `192.168.1.0/24` or `2001:0db8:0123:45::/56`. IPv6 addressing is supported for all commercial and government regions. See [IPv6 Addresses](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/ipv6.htm).
        * The `cidrBlock` value for a [Service](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Service/), if you're setting up a security list rule for traffic coming from a particular `Service` through a service gateway. For example: `oci-phx-objectstorage`.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) An optional description of your choice for the rule.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="icmpOptions")
    def icmp_options(self) -> Optional[pulumi.Input['SecurityListIngressSecurityRuleIcmpOptionsArgs']]:
        """
        (Updatable) Optional and valid only for ICMP and ICMPv6. Use to specify a particular ICMP type and code as defined in:
        * [ICMP Parameters](http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml)
        * [ICMPv6 Parameters](https://www.iana.org/assignments/icmpv6-parameters/icmpv6-parameters.xhtml)

        If you specify ICMP or ICMPv6 as the protocol but omit this object, then all ICMP types and codes are allowed. If you do provide this object, the type is required and the code is optional. To enable MTU negotiation for ingress internet traffic via IPv4, make sure to allow type 3 ("Destination Unreachable") code 4 ("Fragmentation Needed and Don't Fragment was Set"). If you need to specify multiple codes for a single type, create a separate security list rule for each.
        """
        return pulumi.get(self, "icmp_options")

    @icmp_options.setter
    def icmp_options(self, value: Optional[pulumi.Input['SecurityListIngressSecurityRuleIcmpOptionsArgs']]):
        pulumi.set(self, "icmp_options", value)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Type of source for the rule. The default is `CIDR_BLOCK`.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_type", value)

    @property
    @pulumi.getter
    def stateless(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) A stateless rule allows traffic in one direction. Remember to add a corresponding stateless rule in the other direction if you need to support bidirectional traffic. For example, if ingress traffic allows TCP destination port 80, there should be an egress rule to allow TCP source port 80. Defaults to false, which means the rule is stateful and a corresponding rule is not necessary for bidirectional traffic.
        """
        return pulumi.get(self, "stateless")

    @stateless.setter
    def stateless(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "stateless", value)

    @property
    @pulumi.getter(name="tcpOptions")
    def tcp_options(self) -> Optional[pulumi.Input['SecurityListIngressSecurityRuleTcpOptionsArgs']]:
        """
        (Updatable) Optional and valid only for TCP. Use to specify particular destination ports for TCP rules. If you specify TCP as the protocol but omit this object, then all destination ports are allowed.
        """
        return pulumi.get(self, "tcp_options")

    @tcp_options.setter
    def tcp_options(self, value: Optional[pulumi.Input['SecurityListIngressSecurityRuleTcpOptionsArgs']]):
        pulumi.set(self, "tcp_options", value)

    @property
    @pulumi.getter(name="udpOptions")
    def udp_options(self) -> Optional[pulumi.Input['SecurityListIngressSecurityRuleUdpOptionsArgs']]:
        """
        (Updatable) Optional and valid only for UDP. Use to specify particular destination ports for UDP rules. If you specify UDP as the protocol but omit this object, then all destination ports are allowed.
        """
        return pulumi.get(self, "udp_options")

    @udp_options.setter
    def udp_options(self, value: Optional[pulumi.Input['SecurityListIngressSecurityRuleUdpOptionsArgs']]):
        pulumi.set(self, "udp_options", value)


@pulumi.input_type
class SecurityListIngressSecurityRuleIcmpOptionsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[int],
                 code: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] type: (Updatable) The ICMP type.
        :param pulumi.Input[int] code: (Updatable) The ICMP code (optional).
        """
        SecurityListIngressSecurityRuleIcmpOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            code=code,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[int],
             code: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if code is not None:
            _setter("code", code)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[int]:
        """
        (Updatable) The ICMP type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[int]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The ICMP code (optional).
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)


@pulumi.input_type
class SecurityListIngressSecurityRuleTcpOptionsArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[int]] = None,
                 min: Optional[pulumi.Input[int]] = None,
                 source_port_range: Optional[pulumi.Input['SecurityListIngressSecurityRuleTcpOptionsSourcePortRangeArgs']] = None):
        """
        :param pulumi.Input[int] max: (Updatable) The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        :param pulumi.Input[int] min: (Updatable) The minimum port number, which must not be greater than the maximum port number.
        :param pulumi.Input['SecurityListIngressSecurityRuleTcpOptionsSourcePortRangeArgs'] source_port_range: (Updatable)
        """
        SecurityListIngressSecurityRuleTcpOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
            source_port_range=source_port_range,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[pulumi.Input[int]] = None,
             min: Optional[pulumi.Input[int]] = None,
             source_port_range: Optional[pulumi.Input['SecurityListIngressSecurityRuleTcpOptionsSourcePortRangeArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)
        if source_port_range is not None:
            _setter("source_port_range", source_port_range)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The minimum port number, which must not be greater than the maximum port number.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional[pulumi.Input['SecurityListIngressSecurityRuleTcpOptionsSourcePortRangeArgs']]:
        """
        (Updatable)
        """
        return pulumi.get(self, "source_port_range")

    @source_port_range.setter
    def source_port_range(self, value: Optional[pulumi.Input['SecurityListIngressSecurityRuleTcpOptionsSourcePortRangeArgs']]):
        pulumi.set(self, "source_port_range", value)


@pulumi.input_type
class SecurityListIngressSecurityRuleTcpOptionsSourcePortRangeArgs:
    def __init__(__self__, *,
                 max: pulumi.Input[int],
                 min: pulumi.Input[int]):
        """
        :param pulumi.Input[int] max: (Updatable) The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        :param pulumi.Input[int] min: (Updatable) The minimum port number, which must not be greater than the maximum port number.
        """
        SecurityListIngressSecurityRuleTcpOptionsSourcePortRangeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: pulumi.Input[int],
             min: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("max", max)
        _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> pulumi.Input[int]:
        """
        (Updatable) The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[int]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> pulumi.Input[int]:
        """
        (Updatable) The minimum port number, which must not be greater than the maximum port number.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[int]):
        pulumi.set(self, "min", value)


@pulumi.input_type
class SecurityListIngressSecurityRuleUdpOptionsArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[int]] = None,
                 min: Optional[pulumi.Input[int]] = None,
                 source_port_range: Optional[pulumi.Input['SecurityListIngressSecurityRuleUdpOptionsSourcePortRangeArgs']] = None):
        """
        :param pulumi.Input[int] max: (Updatable) The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        :param pulumi.Input[int] min: (Updatable) The minimum port number, which must not be greater than the maximum port number.
        :param pulumi.Input['SecurityListIngressSecurityRuleUdpOptionsSourcePortRangeArgs'] source_port_range: (Updatable)
        """
        SecurityListIngressSecurityRuleUdpOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
            source_port_range=source_port_range,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[pulumi.Input[int]] = None,
             min: Optional[pulumi.Input[int]] = None,
             source_port_range: Optional[pulumi.Input['SecurityListIngressSecurityRuleUdpOptionsSourcePortRangeArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)
        if source_port_range is not None:
            _setter("source_port_range", source_port_range)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The minimum port number, which must not be greater than the maximum port number.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional[pulumi.Input['SecurityListIngressSecurityRuleUdpOptionsSourcePortRangeArgs']]:
        """
        (Updatable)
        """
        return pulumi.get(self, "source_port_range")

    @source_port_range.setter
    def source_port_range(self, value: Optional[pulumi.Input['SecurityListIngressSecurityRuleUdpOptionsSourcePortRangeArgs']]):
        pulumi.set(self, "source_port_range", value)


@pulumi.input_type
class SecurityListIngressSecurityRuleUdpOptionsSourcePortRangeArgs:
    def __init__(__self__, *,
                 max: pulumi.Input[int],
                 min: pulumi.Input[int]):
        """
        :param pulumi.Input[int] max: (Updatable) The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        :param pulumi.Input[int] min: (Updatable) The minimum port number, which must not be greater than the maximum port number.
        """
        SecurityListIngressSecurityRuleUdpOptionsSourcePortRangeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: pulumi.Input[int],
             min: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("max", max)
        _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> pulumi.Input[int]:
        """
        (Updatable) The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[int]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> pulumi.Input[int]:
        """
        (Updatable) The minimum port number, which must not be greater than the maximum port number.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[int]):
        pulumi.set(self, "min", value)


@pulumi.input_type
class ServiceGatewayServiceArgs:
    def __init__(__self__, *,
                 service_id: pulumi.Input[str],
                 service_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] service_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [Service](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Service/).
        :param pulumi.Input[str] service_name: The name of the service.
        """
        ServiceGatewayServiceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            service_id=service_id,
            service_name=service_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             service_id: pulumi.Input[str],
             service_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("service_id", service_id)
        if service_name is not None:
            _setter("service_name", service_name)

    @property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [Service](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Service/).
        """
        return pulumi.get(self, "service_id")

    @service_id.setter
    def service_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_id", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the service.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)


@pulumi.input_type
class VcnByoipv6cidrDetailArgs:
    def __init__(__self__, *,
                 byoipv6range_id: pulumi.Input[str],
                 ipv6cidr_block: pulumi.Input[str]):
        """
        :param pulumi.Input[str] byoipv6range_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the `ByoipRange` resource to which the CIDR block belongs.
        :param pulumi.Input[str] ipv6cidr_block: An IPv6 prefix required to create a VCN with a BYOIP prefix. It could be the whole prefix identified in `byoipv6RangeId`, or a subrange. Example: `2001:0db8:0123::/48`
        """
        VcnByoipv6cidrDetailArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            byoipv6range_id=byoipv6range_id,
            ipv6cidr_block=ipv6cidr_block,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             byoipv6range_id: pulumi.Input[str],
             ipv6cidr_block: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("byoipv6range_id", byoipv6range_id)
        _setter("ipv6cidr_block", ipv6cidr_block)

    @property
    @pulumi.getter(name="byoipv6rangeId")
    def byoipv6range_id(self) -> pulumi.Input[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the `ByoipRange` resource to which the CIDR block belongs.
        """
        return pulumi.get(self, "byoipv6range_id")

    @byoipv6range_id.setter
    def byoipv6range_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "byoipv6range_id", value)

    @property
    @pulumi.getter(name="ipv6cidrBlock")
    def ipv6cidr_block(self) -> pulumi.Input[str]:
        """
        An IPv6 prefix required to create a VCN with a BYOIP prefix. It could be the whole prefix identified in `byoipv6RangeId`, or a subrange. Example: `2001:0db8:0123::/48`
        """
        return pulumi.get(self, "ipv6cidr_block")

    @ipv6cidr_block.setter
    def ipv6cidr_block(self, value: pulumi.Input[str]):
        pulumi.set(self, "ipv6cidr_block", value)


@pulumi.input_type
class VirtualCircuitCrossConnectMappingArgs:
    def __init__(__self__, *,
                 bgp_md5auth_key: Optional[pulumi.Input[str]] = None,
                 cross_connect_or_cross_connect_group_id: Optional[pulumi.Input[str]] = None,
                 customer_bgp_peering_ip: Optional[pulumi.Input[str]] = None,
                 customer_bgp_peering_ipv6: Optional[pulumi.Input[str]] = None,
                 oracle_bgp_peering_ip: Optional[pulumi.Input[str]] = None,
                 oracle_bgp_peering_ipv6: Optional[pulumi.Input[str]] = None,
                 vlan: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] bgp_md5auth_key: (Updatable) The key for BGP MD5 authentication. Only applicable if your system requires MD5 authentication. If empty or not set (null), that means you don't use BGP MD5 authentication.
        :param pulumi.Input[str] cross_connect_or_cross_connect_group_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the cross-connect or cross-connect group for this mapping. Specified by the owner of the cross-connect or cross-connect group (the customer if the customer is colocated with Oracle, or the provider if the customer is connecting via provider).
        :param pulumi.Input[str] customer_bgp_peering_ip: (Updatable) The BGP IPv4 address for the router on the other end of the BGP session from Oracle. Specified by the owner of that router. If the session goes from Oracle to a customer, this is the BGP IPv4 address of the customer's edge router. If the session goes from Oracle to a provider, this is the BGP IPv4 address of the provider's edge router. Must use a subnet mask from /28 to /31.
               
               There's one exception: for a public virtual circuit, Oracle specifies the BGP IPv4 addresses.
               
               Example: `10.0.0.18/31`
        :param pulumi.Input[str] customer_bgp_peering_ipv6: (Updatable) IPv6 is currently supported only in the Government Cloud. The BGP IPv6 address for the router on the other end of the BGP session from Oracle. Specified by the owner of that router. If the session goes from Oracle to a customer, this is the BGP IPv6 address of the customer's edge router. If the session goes from Oracle to a provider, this is the BGP IPv6 address of the provider's edge router. Only subnet masks from /64 up to /127 are allowed.
               
               There's one exception: for a public virtual circuit, Oracle specifies the BGP IPv6 addresses.
               
               IPv6 addressing is supported for all commercial and government regions. See [IPv6 Addresses](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/ipv6.htm).
               
               Example: `2001:db8::1/64`
        :param pulumi.Input[str] oracle_bgp_peering_ip: (Updatable) The IPv4 address for Oracle's end of the BGP session. Must use a subnet mask from /28 to /31. If the session goes from Oracle to a customer's edge router, the customer specifies this information. If the session goes from Oracle to a provider's edge router, the provider specifies this.
               
               There's one exception: for a public virtual circuit, Oracle specifies the BGP IPv4 addresses.
               
               Example: `10.0.0.19/31`
        :param pulumi.Input[str] oracle_bgp_peering_ipv6: (Updatable) IPv6 is currently supported only in the Government Cloud. The IPv6 address for Oracle's end of the BGP session.  Only subnet masks from /64 up to /127 are allowed. If the session goes from Oracle to a customer's edge router, the customer specifies this information. If the session goes from Oracle to a provider's edge router, the provider specifies this.
               
               There's one exception: for a public virtual circuit, Oracle specifies the BGP IPv6 addresses.
               
               Note that IPv6 addressing is currently supported only in certain regions. See [IPv6 Addresses](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/ipv6.htm).
               
               Example: `2001:db8::2/64`
        :param pulumi.Input[int] vlan: (Updatable) The number of the specific VLAN (on the cross-connect or cross-connect group) that is assigned to this virtual circuit. Specified by the owner of the cross-connect or cross-connect group (the customer if the customer is colocated with Oracle, or the provider if the customer is connecting via provider).  Example: `200`
        """
        VirtualCircuitCrossConnectMappingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bgp_md5auth_key=bgp_md5auth_key,
            cross_connect_or_cross_connect_group_id=cross_connect_or_cross_connect_group_id,
            customer_bgp_peering_ip=customer_bgp_peering_ip,
            customer_bgp_peering_ipv6=customer_bgp_peering_ipv6,
            oracle_bgp_peering_ip=oracle_bgp_peering_ip,
            oracle_bgp_peering_ipv6=oracle_bgp_peering_ipv6,
            vlan=vlan,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bgp_md5auth_key: Optional[pulumi.Input[str]] = None,
             cross_connect_or_cross_connect_group_id: Optional[pulumi.Input[str]] = None,
             customer_bgp_peering_ip: Optional[pulumi.Input[str]] = None,
             customer_bgp_peering_ipv6: Optional[pulumi.Input[str]] = None,
             oracle_bgp_peering_ip: Optional[pulumi.Input[str]] = None,
             oracle_bgp_peering_ipv6: Optional[pulumi.Input[str]] = None,
             vlan: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bgp_md5auth_key is not None:
            _setter("bgp_md5auth_key", bgp_md5auth_key)
        if cross_connect_or_cross_connect_group_id is not None:
            _setter("cross_connect_or_cross_connect_group_id", cross_connect_or_cross_connect_group_id)
        if customer_bgp_peering_ip is not None:
            _setter("customer_bgp_peering_ip", customer_bgp_peering_ip)
        if customer_bgp_peering_ipv6 is not None:
            _setter("customer_bgp_peering_ipv6", customer_bgp_peering_ipv6)
        if oracle_bgp_peering_ip is not None:
            _setter("oracle_bgp_peering_ip", oracle_bgp_peering_ip)
        if oracle_bgp_peering_ipv6 is not None:
            _setter("oracle_bgp_peering_ipv6", oracle_bgp_peering_ipv6)
        if vlan is not None:
            _setter("vlan", vlan)

    @property
    @pulumi.getter(name="bgpMd5authKey")
    def bgp_md5auth_key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The key for BGP MD5 authentication. Only applicable if your system requires MD5 authentication. If empty or not set (null), that means you don't use BGP MD5 authentication.
        """
        return pulumi.get(self, "bgp_md5auth_key")

    @bgp_md5auth_key.setter
    def bgp_md5auth_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bgp_md5auth_key", value)

    @property
    @pulumi.getter(name="crossConnectOrCrossConnectGroupId")
    def cross_connect_or_cross_connect_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the cross-connect or cross-connect group for this mapping. Specified by the owner of the cross-connect or cross-connect group (the customer if the customer is colocated with Oracle, or the provider if the customer is connecting via provider).
        """
        return pulumi.get(self, "cross_connect_or_cross_connect_group_id")

    @cross_connect_or_cross_connect_group_id.setter
    def cross_connect_or_cross_connect_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cross_connect_or_cross_connect_group_id", value)

    @property
    @pulumi.getter(name="customerBgpPeeringIp")
    def customer_bgp_peering_ip(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The BGP IPv4 address for the router on the other end of the BGP session from Oracle. Specified by the owner of that router. If the session goes from Oracle to a customer, this is the BGP IPv4 address of the customer's edge router. If the session goes from Oracle to a provider, this is the BGP IPv4 address of the provider's edge router. Must use a subnet mask from /28 to /31.

        There's one exception: for a public virtual circuit, Oracle specifies the BGP IPv4 addresses.

        Example: `10.0.0.18/31`
        """
        return pulumi.get(self, "customer_bgp_peering_ip")

    @customer_bgp_peering_ip.setter
    def customer_bgp_peering_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "customer_bgp_peering_ip", value)

    @property
    @pulumi.getter(name="customerBgpPeeringIpv6")
    def customer_bgp_peering_ipv6(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) IPv6 is currently supported only in the Government Cloud. The BGP IPv6 address for the router on the other end of the BGP session from Oracle. Specified by the owner of that router. If the session goes from Oracle to a customer, this is the BGP IPv6 address of the customer's edge router. If the session goes from Oracle to a provider, this is the BGP IPv6 address of the provider's edge router. Only subnet masks from /64 up to /127 are allowed.

        There's one exception: for a public virtual circuit, Oracle specifies the BGP IPv6 addresses.

        IPv6 addressing is supported for all commercial and government regions. See [IPv6 Addresses](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/ipv6.htm).

        Example: `2001:db8::1/64`
        """
        return pulumi.get(self, "customer_bgp_peering_ipv6")

    @customer_bgp_peering_ipv6.setter
    def customer_bgp_peering_ipv6(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "customer_bgp_peering_ipv6", value)

    @property
    @pulumi.getter(name="oracleBgpPeeringIp")
    def oracle_bgp_peering_ip(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The IPv4 address for Oracle's end of the BGP session. Must use a subnet mask from /28 to /31. If the session goes from Oracle to a customer's edge router, the customer specifies this information. If the session goes from Oracle to a provider's edge router, the provider specifies this.

        There's one exception: for a public virtual circuit, Oracle specifies the BGP IPv4 addresses.

        Example: `10.0.0.19/31`
        """
        return pulumi.get(self, "oracle_bgp_peering_ip")

    @oracle_bgp_peering_ip.setter
    def oracle_bgp_peering_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oracle_bgp_peering_ip", value)

    @property
    @pulumi.getter(name="oracleBgpPeeringIpv6")
    def oracle_bgp_peering_ipv6(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) IPv6 is currently supported only in the Government Cloud. The IPv6 address for Oracle's end of the BGP session.  Only subnet masks from /64 up to /127 are allowed. If the session goes from Oracle to a customer's edge router, the customer specifies this information. If the session goes from Oracle to a provider's edge router, the provider specifies this.

        There's one exception: for a public virtual circuit, Oracle specifies the BGP IPv6 addresses.

        Note that IPv6 addressing is currently supported only in certain regions. See [IPv6 Addresses](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/ipv6.htm).

        Example: `2001:db8::2/64`
        """
        return pulumi.get(self, "oracle_bgp_peering_ipv6")

    @oracle_bgp_peering_ipv6.setter
    def oracle_bgp_peering_ipv6(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oracle_bgp_peering_ipv6", value)

    @property
    @pulumi.getter
    def vlan(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The number of the specific VLAN (on the cross-connect or cross-connect group) that is assigned to this virtual circuit. Specified by the owner of the cross-connect or cross-connect group (the customer if the customer is colocated with Oracle, or the provider if the customer is connecting via provider).  Example: `200`
        """
        return pulumi.get(self, "vlan")

    @vlan.setter
    def vlan(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vlan", value)


@pulumi.input_type
class VirtualCircuitPublicPrefixArgs:
    def __init__(__self__, *,
                 cidr_block: pulumi.Input[str]):
        """
        :param pulumi.Input[str] cidr_block: (Updatable) An individual public IP prefix (CIDR) to add to the public virtual circuit. All prefix sizes are allowed.
        """
        VirtualCircuitPublicPrefixArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr_block=cidr_block,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr_block: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cidr_block", cidr_block)

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> pulumi.Input[str]:
        """
        (Updatable) An individual public IP prefix (CIDR) to add to the public virtual circuit. All prefix sizes are allowed.
        """
        return pulumi.get(self, "cidr_block")

    @cidr_block.setter
    def cidr_block(self, value: pulumi.Input[str]):
        pulumi.set(self, "cidr_block", value)


@pulumi.input_type
class VirtualNetworkByoipv6cidrDetailArgs:
    def __init__(__self__, *,
                 byoipv6range_id: pulumi.Input[str],
                 ipv6cidr_block: pulumi.Input[str]):
        VirtualNetworkByoipv6cidrDetailArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            byoipv6range_id=byoipv6range_id,
            ipv6cidr_block=ipv6cidr_block,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             byoipv6range_id: pulumi.Input[str],
             ipv6cidr_block: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("byoipv6range_id", byoipv6range_id)
        _setter("ipv6cidr_block", ipv6cidr_block)

    @property
    @pulumi.getter(name="byoipv6rangeId")
    def byoipv6range_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "byoipv6range_id")

    @byoipv6range_id.setter
    def byoipv6range_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "byoipv6range_id", value)

    @property
    @pulumi.getter(name="ipv6cidrBlock")
    def ipv6cidr_block(self) -> pulumi.Input[str]:
        return pulumi.get(self, "ipv6cidr_block")

    @ipv6cidr_block.setter
    def ipv6cidr_block(self, value: pulumi.Input[str]):
        pulumi.set(self, "ipv6cidr_block", value)


@pulumi.input_type
class VnicAttachmentCreateVnicDetailsArgs:
    def __init__(__self__, *,
                 assign_ipv6ip: Optional[pulumi.Input[bool]] = None,
                 assign_private_dns_record: Optional[pulumi.Input[bool]] = None,
                 assign_public_ip: Optional[pulumi.Input[str]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 hostname_label: Optional[pulumi.Input[str]] = None,
                 ipv6address_ipv6subnet_cidr_pair_details: Optional[pulumi.Input[Sequence[pulumi.Input['VnicAttachmentCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs']]]] = None,
                 nsg_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 private_ip: Optional[pulumi.Input[str]] = None,
                 skip_source_dest_check: Optional[pulumi.Input[bool]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 vlan_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] assign_ipv6ip: Whether to allocate an IPv6 address at instance and VNIC creation from an IPv6 enabled subnet. Default: False. When provided you may optionally provide an IPv6 prefix (`ipv6SubnetCidr`) of your choice to assign the IPv6 address from. If `ipv6SubnetCidr` is not provided then an IPv6 prefix is chosen for you.
        :param pulumi.Input[bool] assign_private_dns_record: Whether the VNIC should be assigned a DNS record. If set to false, no DNS record registion for the VNIC; if set to true, DNS record will be registered. Example: `true`
               
               If you specify a `hostnameLabel`, the `assignPrivateDnsRecord` is require to be set to true.
        :param pulumi.Input[str] assign_public_ip: Whether the VNIC should be assigned a public IP address. Defaults to whether the subnet is public or private. If not set and the VNIC is being created in a private subnet (that is, where `prohibitPublicIpOnVnic` = true in the [Subnet](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Subnet/)), then no public IP address is assigned. If not set and the subnet is public (`prohibitPublicIpOnVnic` = false), then a public IP address is assigned. If set to true and `prohibitPublicIpOnVnic` = true, an error is returned.
               
               **Note:** This public IP address is associated with the primary private IP on the VNIC. For more information, see [IP Addresses](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/managingIPaddresses.htm).
               
               **Note:** There's a limit to the number of [public IPs](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PublicIp/) a VNIC or instance can have. If you try to create a secondary VNIC with an assigned public IP for an instance that has already reached its public IP limit, an error is returned. For information about the public IP limits, see [Public IP Addresses](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/managingpublicIPs.htm).
               
               Example: `false`
               
               If you specify a `vlanId`, then `assignPublicIp` must be set to false. See [Vlan](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vlan).
        :param pulumi.Input[Mapping[str, Any]] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        :param pulumi.Input[str] display_name: A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        :param pulumi.Input[Mapping[str, Any]] freeform_tags: (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param pulumi.Input[str] hostname_label: (Updatable) The hostname for the VNIC's primary private IP. Used for DNS. The value is the hostname portion of the primary private IP's fully qualified domain name (FQDN) (for example, `bminstance1` in FQDN `bminstance1.subnet123.vcn1.oraclevcn.com`). Must be unique across all VNICs in the subnet and comply with [RFC 952](https://tools.ietf.org/html/rfc952) and [RFC 1123](https://tools.ietf.org/html/rfc1123). The value appears in the [Vnic](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vnic/) object and also the [PrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/) object returned by [ListPrivateIps](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/ListPrivateIps) and [GetPrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/GetPrivateIp).
               
               For more information, see [DNS in Your Virtual Cloud Network](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/dns.htm).
               
               When launching an instance, use this `hostnameLabel` instead of the deprecated `hostnameLabel` in [LaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/requests/LaunchInstanceDetails). If you provide both, the values must match.
               
               Example: `bminstance1`
               
               If you specify a `vlanId`, the `hostnameLabel` cannot be specified. VNICs on a VLAN can not be assigned a hostname. See [Vlan](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vlan).
        :param pulumi.Input[Sequence[pulumi.Input['VnicAttachmentCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs']]] ipv6address_ipv6subnet_cidr_pair_details: A list of IPv6 prefix ranges from which the VNIC should be assigned an IPv6 address. You can provide only the prefix ranges from which Oracle Cloud Infrastructure will select an available address from the range. You can optionally choose to leave the prefix range empty and instead provide the specific IPv6 address that should be used from within that range.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] nsg_ids: (Updatable) A list of the OCIDs of the network security groups (NSGs) to add the VNIC to. For more information about NSGs, see [NetworkSecurityGroup](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/NetworkSecurityGroup/).
               
               If a `vlanId` is specified, the `nsgIds` cannot be specified. The `vlanId` indicates that the VNIC will belong to a VLAN instead of a subnet. With VLANs, all VNICs in the VLAN belong to the NSGs that are associated with the VLAN. See [Vlan](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vlan).
        :param pulumi.Input[str] private_ip: A private IP address of your choice to assign to the VNIC. Must be an available IP address within the subnet's CIDR. If you don't specify a value, Oracle automatically assigns a private IP address from the subnet. This is the VNIC's *primary* private IP address. The value appears in the [Vnic](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vnic/) object and also the [PrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/) object returned by [ListPrivateIps](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/ListPrivateIps) and [GetPrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/GetPrivateIp).
               
               If you specify a `vlanId`, the `privateIp` cannot be specified. See [Vlan](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vlan).
               
               Example: `10.0.3.3`
        :param pulumi.Input[bool] skip_source_dest_check: (Updatable) Whether the source/destination check is disabled on the VNIC. Defaults to `false`, which means the check is performed. For information about why you would skip the source/destination check, see [Using a Private IP as a Route Target](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/managingroutetables.htm#privateip).
               
               If you specify a `vlanId`, the `skipSourceDestCheck` cannot be specified because the source/destination check is always disabled for VNICs in a VLAN. See [Vlan](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vlan).
               
               Example: `true`
        :param pulumi.Input[str] subnet_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet to create the VNIC in. When launching an instance, use this `subnetId` instead of the deprecated `subnetId` in [LaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/requests/LaunchInstanceDetails). At least one of them is required; if you provide both, the values must match.
               
               If you are an Oracle Cloud VMware Solution customer and creating a secondary VNIC in a VLAN instead of a subnet, provide a `vlanId` instead of a `subnetId`. If you provide both a `vlanId` and `subnetId`, the request fails.
        :param pulumi.Input[str] vlan_id: Provide this attribute only if you are an Oracle Cloud VMware Solution customer and creating a secondary VNIC in a VLAN. The value is the [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VLAN. See [Vlan](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vlan).
               
               Provide a `vlanId` instead of a `subnetId`. If you provide both a `vlanId` and `subnetId`, the request fails.
        """
        VnicAttachmentCreateVnicDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            assign_ipv6ip=assign_ipv6ip,
            assign_private_dns_record=assign_private_dns_record,
            assign_public_ip=assign_public_ip,
            defined_tags=defined_tags,
            display_name=display_name,
            freeform_tags=freeform_tags,
            hostname_label=hostname_label,
            ipv6address_ipv6subnet_cidr_pair_details=ipv6address_ipv6subnet_cidr_pair_details,
            nsg_ids=nsg_ids,
            private_ip=private_ip,
            skip_source_dest_check=skip_source_dest_check,
            subnet_id=subnet_id,
            vlan_id=vlan_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             assign_ipv6ip: Optional[pulumi.Input[bool]] = None,
             assign_private_dns_record: Optional[pulumi.Input[bool]] = None,
             assign_public_ip: Optional[pulumi.Input[str]] = None,
             defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             display_name: Optional[pulumi.Input[str]] = None,
             freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             hostname_label: Optional[pulumi.Input[str]] = None,
             ipv6address_ipv6subnet_cidr_pair_details: Optional[pulumi.Input[Sequence[pulumi.Input['VnicAttachmentCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs']]]] = None,
             nsg_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             private_ip: Optional[pulumi.Input[str]] = None,
             skip_source_dest_check: Optional[pulumi.Input[bool]] = None,
             subnet_id: Optional[pulumi.Input[str]] = None,
             vlan_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if assign_ipv6ip is not None:
            _setter("assign_ipv6ip", assign_ipv6ip)
        if assign_private_dns_record is not None:
            _setter("assign_private_dns_record", assign_private_dns_record)
        if assign_public_ip is not None:
            _setter("assign_public_ip", assign_public_ip)
        if defined_tags is not None:
            _setter("defined_tags", defined_tags)
        if display_name is not None:
            _setter("display_name", display_name)
        if freeform_tags is not None:
            _setter("freeform_tags", freeform_tags)
        if hostname_label is not None:
            _setter("hostname_label", hostname_label)
        if ipv6address_ipv6subnet_cidr_pair_details is not None:
            _setter("ipv6address_ipv6subnet_cidr_pair_details", ipv6address_ipv6subnet_cidr_pair_details)
        if nsg_ids is not None:
            _setter("nsg_ids", nsg_ids)
        if private_ip is not None:
            _setter("private_ip", private_ip)
        if skip_source_dest_check is not None:
            _setter("skip_source_dest_check", skip_source_dest_check)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)
        if vlan_id is not None:
            _setter("vlan_id", vlan_id)

    @property
    @pulumi.getter(name="assignIpv6ip")
    def assign_ipv6ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allocate an IPv6 address at instance and VNIC creation from an IPv6 enabled subnet. Default: False. When provided you may optionally provide an IPv6 prefix (`ipv6SubnetCidr`) of your choice to assign the IPv6 address from. If `ipv6SubnetCidr` is not provided then an IPv6 prefix is chosen for you.
        """
        return pulumi.get(self, "assign_ipv6ip")

    @assign_ipv6ip.setter
    def assign_ipv6ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_ipv6ip", value)

    @property
    @pulumi.getter(name="assignPrivateDnsRecord")
    def assign_private_dns_record(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the VNIC should be assigned a DNS record. If set to false, no DNS record registion for the VNIC; if set to true, DNS record will be registered. Example: `true`

        If you specify a `hostnameLabel`, the `assignPrivateDnsRecord` is require to be set to true.
        """
        return pulumi.get(self, "assign_private_dns_record")

    @assign_private_dns_record.setter
    def assign_private_dns_record(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_private_dns_record", value)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the VNIC should be assigned a public IP address. Defaults to whether the subnet is public or private. If not set and the VNIC is being created in a private subnet (that is, where `prohibitPublicIpOnVnic` = true in the [Subnet](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Subnet/)), then no public IP address is assigned. If not set and the subnet is public (`prohibitPublicIpOnVnic` = false), then a public IP address is assigned. If set to true and `prohibitPublicIpOnVnic` = true, an error is returned.

        **Note:** This public IP address is associated with the primary private IP on the VNIC. For more information, see [IP Addresses](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/managingIPaddresses.htm).

        **Note:** There's a limit to the number of [public IPs](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PublicIp/) a VNIC or instance can have. If you try to create a secondary VNIC with an assigned public IP for an instance that has already reached its public IP limit, an error is returned. For information about the public IP limits, see [Public IP Addresses](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/managingpublicIPs.htm).

        Example: `false`

        If you specify a `vlanId`, then `assignPublicIp` must be set to false. See [Vlan](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vlan).
        """
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "assign_public_ip", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter(name="hostnameLabel")
    def hostname_label(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The hostname for the VNIC's primary private IP. Used for DNS. The value is the hostname portion of the primary private IP's fully qualified domain name (FQDN) (for example, `bminstance1` in FQDN `bminstance1.subnet123.vcn1.oraclevcn.com`). Must be unique across all VNICs in the subnet and comply with [RFC 952](https://tools.ietf.org/html/rfc952) and [RFC 1123](https://tools.ietf.org/html/rfc1123). The value appears in the [Vnic](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vnic/) object and also the [PrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/) object returned by [ListPrivateIps](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/ListPrivateIps) and [GetPrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/GetPrivateIp).

        For more information, see [DNS in Your Virtual Cloud Network](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/dns.htm).

        When launching an instance, use this `hostnameLabel` instead of the deprecated `hostnameLabel` in [LaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/requests/LaunchInstanceDetails). If you provide both, the values must match.

        Example: `bminstance1`

        If you specify a `vlanId`, the `hostnameLabel` cannot be specified. VNICs on a VLAN can not be assigned a hostname. See [Vlan](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vlan).
        """
        return pulumi.get(self, "hostname_label")

    @hostname_label.setter
    def hostname_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname_label", value)

    @property
    @pulumi.getter(name="ipv6addressIpv6subnetCidrPairDetails")
    def ipv6address_ipv6subnet_cidr_pair_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VnicAttachmentCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs']]]]:
        """
        A list of IPv6 prefix ranges from which the VNIC should be assigned an IPv6 address. You can provide only the prefix ranges from which Oracle Cloud Infrastructure will select an available address from the range. You can optionally choose to leave the prefix range empty and instead provide the specific IPv6 address that should be used from within that range.
        """
        return pulumi.get(self, "ipv6address_ipv6subnet_cidr_pair_details")

    @ipv6address_ipv6subnet_cidr_pair_details.setter
    def ipv6address_ipv6subnet_cidr_pair_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VnicAttachmentCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs']]]]):
        pulumi.set(self, "ipv6address_ipv6subnet_cidr_pair_details", value)

    @property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) A list of the OCIDs of the network security groups (NSGs) to add the VNIC to. For more information about NSGs, see [NetworkSecurityGroup](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/NetworkSecurityGroup/).

        If a `vlanId` is specified, the `nsgIds` cannot be specified. The `vlanId` indicates that the VNIC will belong to a VLAN instead of a subnet. With VLANs, all VNICs in the VLAN belong to the NSGs that are associated with the VLAN. See [Vlan](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vlan).
        """
        return pulumi.get(self, "nsg_ids")

    @nsg_ids.setter
    def nsg_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "nsg_ids", value)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[str]]:
        """
        A private IP address of your choice to assign to the VNIC. Must be an available IP address within the subnet's CIDR. If you don't specify a value, Oracle automatically assigns a private IP address from the subnet. This is the VNIC's *primary* private IP address. The value appears in the [Vnic](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vnic/) object and also the [PrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/) object returned by [ListPrivateIps](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/ListPrivateIps) and [GetPrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/GetPrivateIp).

        If you specify a `vlanId`, the `privateIp` cannot be specified. See [Vlan](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vlan).

        Example: `10.0.3.3`
        """
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_ip", value)

    @property
    @pulumi.getter(name="skipSourceDestCheck")
    def skip_source_dest_check(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether the source/destination check is disabled on the VNIC. Defaults to `false`, which means the check is performed. For information about why you would skip the source/destination check, see [Using a Private IP as a Route Target](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/managingroutetables.htm#privateip).

        If you specify a `vlanId`, the `skipSourceDestCheck` cannot be specified because the source/destination check is always disabled for VNICs in a VLAN. See [Vlan](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vlan).

        Example: `true`
        """
        return pulumi.get(self, "skip_source_dest_check")

    @skip_source_dest_check.setter
    def skip_source_dest_check(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_source_dest_check", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet to create the VNIC in. When launching an instance, use this `subnetId` instead of the deprecated `subnetId` in [LaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/requests/LaunchInstanceDetails). At least one of them is required; if you provide both, the values must match.

        If you are an Oracle Cloud VMware Solution customer and creating a secondary VNIC in a VLAN instead of a subnet, provide a `vlanId` instead of a `subnetId`. If you provide both a `vlanId` and `subnetId`, the request fails.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[str]]:
        """
        Provide this attribute only if you are an Oracle Cloud VMware Solution customer and creating a secondary VNIC in a VLAN. The value is the [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VLAN. See [Vlan](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vlan).

        Provide a `vlanId` instead of a `subnetId`. If you provide both a `vlanId` and `subnetId`, the request fails.
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vlan_id", value)


@pulumi.input_type
class VnicAttachmentCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs:
    def __init__(__self__, *,
                 ipv6_address: Optional[pulumi.Input[str]] = None,
                 ipv6_subnet_cidr: Optional[pulumi.Input[str]] = None):
        VnicAttachmentCreateVnicDetailsIpv6addressIpv6subnetCidrPairDetailArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ipv6_address=ipv6_address,
            ipv6_subnet_cidr=ipv6_subnet_cidr,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ipv6_address: Optional[pulumi.Input[str]] = None,
             ipv6_subnet_cidr: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ipv6_address is not None:
            _setter("ipv6_address", ipv6_address)
        if ipv6_subnet_cidr is not None:
            _setter("ipv6_subnet_cidr", ipv6_subnet_cidr)

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ipv6_address")

    @ipv6_address.setter
    def ipv6_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_address", value)

    @property
    @pulumi.getter(name="ipv6SubnetCidr")
    def ipv6_subnet_cidr(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ipv6_subnet_cidr")

    @ipv6_subnet_cidr.setter
    def ipv6_subnet_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_subnet_cidr", value)


@pulumi.input_type
class VolumeAttachmentMultipathDeviceArgs:
    def __init__(__self__, *,
                 ipv4: Optional[pulumi.Input[str]] = None,
                 iqn: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] ipv4: The volume's iSCSI IP address.  Example: `169.254.2.2`
        :param pulumi.Input[str] iqn: The target volume's iSCSI Qualified Name in the format defined by [RFC 3720](https://tools.ietf.org/html/rfc3720#page-32).  Example: `iqn.2015-12.com.oracleiaas:40b7ee03-883f-46c6-a951-63d2841d2195`
        :param pulumi.Input[int] port: The volume's iSCSI port, usually port 860 or 3260.  Example: `3260`
        """
        VolumeAttachmentMultipathDeviceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ipv4=ipv4,
            iqn=iqn,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ipv4: Optional[pulumi.Input[str]] = None,
             iqn: Optional[pulumi.Input[str]] = None,
             port: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ipv4 is not None:
            _setter("ipv4", ipv4)
        if iqn is not None:
            _setter("iqn", iqn)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input[str]]:
        """
        The volume's iSCSI IP address.  Example: `169.254.2.2`
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv4", value)

    @property
    @pulumi.getter
    def iqn(self) -> Optional[pulumi.Input[str]]:
        """
        The target volume's iSCSI Qualified Name in the format defined by [RFC 3720](https://tools.ietf.org/html/rfc3720#page-32).  Example: `iqn.2015-12.com.oracleiaas:40b7ee03-883f-46c6-a951-63d2841d2195`
        """
        return pulumi.get(self, "iqn")

    @iqn.setter
    def iqn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "iqn", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The volume's iSCSI port, usually port 860 or 3260.  Example: `3260`
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class VolumeAutotunePolicyArgs:
    def __init__(__self__, *,
                 autotune_type: pulumi.Input[str],
                 max_vpus_per_gb: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] autotune_type: (Updatable) This specifies the type of autotunes supported by OCI.
        :param pulumi.Input[str] max_vpus_per_gb: (Updatable) This will be the maximum VPUs/GB performance level that the volume will be auto-tuned temporarily based on performance monitoring.
        """
        VolumeAutotunePolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autotune_type=autotune_type,
            max_vpus_per_gb=max_vpus_per_gb,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autotune_type: pulumi.Input[str],
             max_vpus_per_gb: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("autotune_type", autotune_type)
        if max_vpus_per_gb is not None:
            _setter("max_vpus_per_gb", max_vpus_per_gb)

    @property
    @pulumi.getter(name="autotuneType")
    def autotune_type(self) -> pulumi.Input[str]:
        """
        (Updatable) This specifies the type of autotunes supported by OCI.
        """
        return pulumi.get(self, "autotune_type")

    @autotune_type.setter
    def autotune_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "autotune_type", value)

    @property
    @pulumi.getter(name="maxVpusPerGb")
    def max_vpus_per_gb(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) This will be the maximum VPUs/GB performance level that the volume will be auto-tuned temporarily based on performance monitoring.
        """
        return pulumi.get(self, "max_vpus_per_gb")

    @max_vpus_per_gb.setter
    def max_vpus_per_gb(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_vpus_per_gb", value)


@pulumi.input_type
class VolumeBackupPolicyScheduleArgs:
    def __init__(__self__, *,
                 backup_type: pulumi.Input[str],
                 period: pulumi.Input[str],
                 retention_seconds: pulumi.Input[int],
                 day_of_month: Optional[pulumi.Input[int]] = None,
                 day_of_week: Optional[pulumi.Input[str]] = None,
                 hour_of_day: Optional[pulumi.Input[int]] = None,
                 month: Optional[pulumi.Input[str]] = None,
                 offset_seconds: Optional[pulumi.Input[int]] = None,
                 offset_type: Optional[pulumi.Input[str]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] backup_type: (Updatable) The type of volume backup to create.
        :param pulumi.Input[str] period: (Updatable) The volume backup frequency.
        :param pulumi.Input[int] retention_seconds: (Updatable) How long, in seconds, to keep the volume backups created by this schedule.
        :param pulumi.Input[int] day_of_month: (Updatable) The day of the month to schedule the volume backup.
        :param pulumi.Input[str] day_of_week: (Updatable) The day of the week to schedule the volume backup.
        :param pulumi.Input[int] hour_of_day: (Updatable) The hour of the day to schedule the volume backup.
        :param pulumi.Input[str] month: (Updatable) The month of the year to schedule the volume backup.
        :param pulumi.Input[int] offset_seconds: (Updatable) The number of seconds that the volume backup start time should be shifted from the default interval boundaries specified by the period. The volume backup start time is the frequency start time plus the offset.
        :param pulumi.Input[str] offset_type: (Updatable) Indicates how the offset is defined. If value is `STRUCTURED`, then `hourOfDay`, `dayOfWeek`, `dayOfMonth`, and `month` fields are used and `offsetSeconds` will be ignored in requests and users should ignore its value from the responses.
               
               `hourOfDay` is applicable for periods `ONE_DAY`, `ONE_WEEK`, `ONE_MONTH` and `ONE_YEAR`.
               
               `dayOfWeek` is applicable for period `ONE_WEEK`.
               
               `dayOfMonth` is applicable for periods `ONE_MONTH` and `ONE_YEAR`.
               
               'month' is applicable for period 'ONE_YEAR'.
               
               They will be ignored in the requests for inapplicable periods.
               
               If value is `NUMERIC_SECONDS`, then `offsetSeconds` will be used for both requests and responses and the structured fields will be ignored in the requests and users should ignore their values from the responses.
               
               For clients using older versions of Apis and not sending `offsetType` in their requests, the behaviour is just like `NUMERIC_SECONDS`.
        :param pulumi.Input[str] time_zone: (Updatable) Specifies what time zone is the schedule in
               enum:
        """
        VolumeBackupPolicyScheduleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backup_type=backup_type,
            period=period,
            retention_seconds=retention_seconds,
            day_of_month=day_of_month,
            day_of_week=day_of_week,
            hour_of_day=hour_of_day,
            month=month,
            offset_seconds=offset_seconds,
            offset_type=offset_type,
            time_zone=time_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backup_type: pulumi.Input[str],
             period: pulumi.Input[str],
             retention_seconds: pulumi.Input[int],
             day_of_month: Optional[pulumi.Input[int]] = None,
             day_of_week: Optional[pulumi.Input[str]] = None,
             hour_of_day: Optional[pulumi.Input[int]] = None,
             month: Optional[pulumi.Input[str]] = None,
             offset_seconds: Optional[pulumi.Input[int]] = None,
             offset_type: Optional[pulumi.Input[str]] = None,
             time_zone: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("backup_type", backup_type)
        _setter("period", period)
        _setter("retention_seconds", retention_seconds)
        if day_of_month is not None:
            _setter("day_of_month", day_of_month)
        if day_of_week is not None:
            _setter("day_of_week", day_of_week)
        if hour_of_day is not None:
            _setter("hour_of_day", hour_of_day)
        if month is not None:
            _setter("month", month)
        if offset_seconds is not None:
            _setter("offset_seconds", offset_seconds)
        if offset_type is not None:
            _setter("offset_type", offset_type)
        if time_zone is not None:
            _setter("time_zone", time_zone)

    @property
    @pulumi.getter(name="backupType")
    def backup_type(self) -> pulumi.Input[str]:
        """
        (Updatable) The type of volume backup to create.
        """
        return pulumi.get(self, "backup_type")

    @backup_type.setter
    def backup_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "backup_type", value)

    @property
    @pulumi.getter
    def period(self) -> pulumi.Input[str]:
        """
        (Updatable) The volume backup frequency.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: pulumi.Input[str]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter(name="retentionSeconds")
    def retention_seconds(self) -> pulumi.Input[int]:
        """
        (Updatable) How long, in seconds, to keep the volume backups created by this schedule.
        """
        return pulumi.get(self, "retention_seconds")

    @retention_seconds.setter
    def retention_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_seconds", value)

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The day of the month to schedule the volume backup.
        """
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day_of_month", value)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The day of the week to schedule the volume backup.
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter(name="hourOfDay")
    def hour_of_day(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The hour of the day to schedule the volume backup.
        """
        return pulumi.get(self, "hour_of_day")

    @hour_of_day.setter
    def hour_of_day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hour_of_day", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The month of the year to schedule the volume backup.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter(name="offsetSeconds")
    def offset_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The number of seconds that the volume backup start time should be shifted from the default interval boundaries specified by the period. The volume backup start time is the frequency start time plus the offset.
        """
        return pulumi.get(self, "offset_seconds")

    @offset_seconds.setter
    def offset_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "offset_seconds", value)

    @property
    @pulumi.getter(name="offsetType")
    def offset_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Indicates how the offset is defined. If value is `STRUCTURED`, then `hourOfDay`, `dayOfWeek`, `dayOfMonth`, and `month` fields are used and `offsetSeconds` will be ignored in requests and users should ignore its value from the responses.

        `hourOfDay` is applicable for periods `ONE_DAY`, `ONE_WEEK`, `ONE_MONTH` and `ONE_YEAR`.

        `dayOfWeek` is applicable for period `ONE_WEEK`.

        `dayOfMonth` is applicable for periods `ONE_MONTH` and `ONE_YEAR`.

        'month' is applicable for period 'ONE_YEAR'.

        They will be ignored in the requests for inapplicable periods.

        If value is `NUMERIC_SECONDS`, then `offsetSeconds` will be used for both requests and responses and the structured fields will be ignored in the requests and users should ignore their values from the responses.

        For clients using older versions of Apis and not sending `offsetType` in their requests, the behaviour is just like `NUMERIC_SECONDS`.
        """
        return pulumi.get(self, "offset_type")

    @offset_type.setter
    def offset_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "offset_type", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Specifies what time zone is the schedule in
        enum:
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)


@pulumi.input_type
class VolumeBackupSourceDetailsArgs:
    def __init__(__self__, *,
                 region: pulumi.Input[str],
                 volume_backup_id: pulumi.Input[str],
                 kms_key_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] region: The region of the volume backup source.
        :param pulumi.Input[str] volume_backup_id: The OCID of the source volume backup.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param pulumi.Input[str] kms_key_id: The OCID of the KMS key in the destination region which will be the master encryption key for the copied volume backup.
        """
        VolumeBackupSourceDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            region=region,
            volume_backup_id=volume_backup_id,
            kms_key_id=kms_key_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             region: pulumi.Input[str],
             volume_backup_id: pulumi.Input[str],
             kms_key_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("region", region)
        _setter("volume_backup_id", volume_backup_id)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        The region of the volume backup source.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="volumeBackupId")
    def volume_backup_id(self) -> pulumi.Input[str]:
        """
        The OCID of the source volume backup.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "volume_backup_id")

    @volume_backup_id.setter
    def volume_backup_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "volume_backup_id", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the KMS key in the destination region which will be the master encryption key for the copied volume backup.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)


@pulumi.input_type
class VolumeBlockVolumeReplicaArgs:
    def __init__(__self__, *,
                 availability_domain: pulumi.Input[str],
                 block_volume_replica_id: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] availability_domain: (Updatable) The availability domain of the block volume replica.  Example: `Uocm:PHX-AD-1`
        :param pulumi.Input[str] block_volume_replica_id: The block volume replica's Oracle ID (OCID).
        :param pulumi.Input[str] display_name: (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        """
        VolumeBlockVolumeReplicaArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_domain=availability_domain,
            block_volume_replica_id=block_volume_replica_id,
            display_name=display_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_domain: pulumi.Input[str],
             block_volume_replica_id: Optional[pulumi.Input[str]] = None,
             display_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("availability_domain", availability_domain)
        if block_volume_replica_id is not None:
            _setter("block_volume_replica_id", block_volume_replica_id)
        if display_name is not None:
            _setter("display_name", display_name)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> pulumi.Input[str]:
        """
        (Updatable) The availability domain of the block volume replica.  Example: `Uocm:PHX-AD-1`
        """
        return pulumi.get(self, "availability_domain")

    @availability_domain.setter
    def availability_domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "availability_domain", value)

    @property
    @pulumi.getter(name="blockVolumeReplicaId")
    def block_volume_replica_id(self) -> Optional[pulumi.Input[str]]:
        """
        The block volume replica's Oracle ID (OCID).
        """
        return pulumi.get(self, "block_volume_replica_id")

    @block_volume_replica_id.setter
    def block_volume_replica_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_volume_replica_id", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


@pulumi.input_type
class VolumeGroupBackupSourceDetailsArgs:
    def __init__(__self__, *,
                 region: pulumi.Input[str],
                 volume_group_backup_id: pulumi.Input[str],
                 kms_key_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] region: The region of the volume backup source.
        :param pulumi.Input[str] volume_group_backup_id: The OCID of the source volume group backup.
               
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param pulumi.Input[str] kms_key_id: The OCID of the KMS key in the destination region which will be the master encryption key for the copied volume backup.
        """
        VolumeGroupBackupSourceDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            region=region,
            volume_group_backup_id=volume_group_backup_id,
            kms_key_id=kms_key_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             region: pulumi.Input[str],
             volume_group_backup_id: pulumi.Input[str],
             kms_key_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("region", region)
        _setter("volume_group_backup_id", volume_group_backup_id)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        The region of the volume backup source.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="volumeGroupBackupId")
    def volume_group_backup_id(self) -> pulumi.Input[str]:
        """
        The OCID of the source volume group backup.



        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "volume_group_backup_id")

    @volume_group_backup_id.setter
    def volume_group_backup_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "volume_group_backup_id", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the KMS key in the destination region which will be the master encryption key for the copied volume backup.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)


@pulumi.input_type
class VolumeGroupSourceDetailsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 volume_group_backup_id: Optional[pulumi.Input[str]] = None,
                 volume_group_id: Optional[pulumi.Input[str]] = None,
                 volume_group_replica_id: Optional[pulumi.Input[str]] = None,
                 volume_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] type: The type can be one of these values: `volumeGroupBackupId`, `volumeGroupId`, `volumeGroupReplicaId`, `volumeIds`
        :param pulumi.Input[str] volume_group_backup_id: The OCID of the volume group backup to restore from.
        :param pulumi.Input[str] volume_group_id: The OCID of the volume group to clone from.
        :param pulumi.Input[str] volume_group_replica_id: The OCID of the volume group replica.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] volume_ids: OCIDs for the volumes in this volume group.
        """
        VolumeGroupSourceDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            volume_group_backup_id=volume_group_backup_id,
            volume_group_id=volume_group_id,
            volume_group_replica_id=volume_group_replica_id,
            volume_ids=volume_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[str],
             volume_group_backup_id: Optional[pulumi.Input[str]] = None,
             volume_group_id: Optional[pulumi.Input[str]] = None,
             volume_group_replica_id: Optional[pulumi.Input[str]] = None,
             volume_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if volume_group_backup_id is not None:
            _setter("volume_group_backup_id", volume_group_backup_id)
        if volume_group_id is not None:
            _setter("volume_group_id", volume_group_id)
        if volume_group_replica_id is not None:
            _setter("volume_group_replica_id", volume_group_replica_id)
        if volume_ids is not None:
            _setter("volume_ids", volume_ids)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type can be one of these values: `volumeGroupBackupId`, `volumeGroupId`, `volumeGroupReplicaId`, `volumeIds`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="volumeGroupBackupId")
    def volume_group_backup_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the volume group backup to restore from.
        """
        return pulumi.get(self, "volume_group_backup_id")

    @volume_group_backup_id.setter
    def volume_group_backup_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_group_backup_id", value)

    @property
    @pulumi.getter(name="volumeGroupId")
    def volume_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the volume group to clone from.
        """
        return pulumi.get(self, "volume_group_id")

    @volume_group_id.setter
    def volume_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_group_id", value)

    @property
    @pulumi.getter(name="volumeGroupReplicaId")
    def volume_group_replica_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the volume group replica.
        """
        return pulumi.get(self, "volume_group_replica_id")

    @volume_group_replica_id.setter
    def volume_group_replica_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_group_replica_id", value)

    @property
    @pulumi.getter(name="volumeIds")
    def volume_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        OCIDs for the volumes in this volume group.
        """
        return pulumi.get(self, "volume_ids")

    @volume_ids.setter
    def volume_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "volume_ids", value)


@pulumi.input_type
class VolumeGroupVolumeGroupReplicaArgs:
    def __init__(__self__, *,
                 availability_domain: pulumi.Input[str],
                 display_name: Optional[pulumi.Input[str]] = None,
                 volume_group_replica_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] availability_domain: (Updatable) The availability domain of the volume group replica.  Example: `Uocm:PHX-AD-1`
        :param pulumi.Input[str] display_name: (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information. 
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param pulumi.Input[str] volume_group_replica_id: The OCID of the volume group replica.
        """
        VolumeGroupVolumeGroupReplicaArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_domain=availability_domain,
            display_name=display_name,
            volume_group_replica_id=volume_group_replica_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_domain: pulumi.Input[str],
             display_name: Optional[pulumi.Input[str]] = None,
             volume_group_replica_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("availability_domain", availability_domain)
        if display_name is not None:
            _setter("display_name", display_name)
        if volume_group_replica_id is not None:
            _setter("volume_group_replica_id", volume_group_replica_id)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> pulumi.Input[str]:
        """
        (Updatable) The availability domain of the volume group replica.  Example: `Uocm:PHX-AD-1`
        """
        return pulumi.get(self, "availability_domain")

    @availability_domain.setter
    def availability_domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "availability_domain", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information. 


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="volumeGroupReplicaId")
    def volume_group_replica_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the volume group replica.
        """
        return pulumi.get(self, "volume_group_replica_id")

    @volume_group_replica_id.setter
    def volume_group_replica_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_group_replica_id", value)


@pulumi.input_type
class VolumeSourceDetailsArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The OCID of the block volume replica.
        :param pulumi.Input[str] type: The type can be one of these values: `blockVolumeReplica`, `volume`, `volumeBackup`
        """
        VolumeSourceDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: pulumi.Input[str],
             type: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("type", type)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The OCID of the block volume replica.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type can be one of these values: `blockVolumeReplica`, `volume`, `volumeBackup`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class GetAppCatalogListingResourceVersionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetAppCatalogListingResourceVersionsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetAppCatalogListingsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetAppCatalogListingsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetAppCatalogSubscriptionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetAppCatalogSubscriptionsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetBlockVolumeReplicasFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetBlockVolumeReplicasFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetBootVolumeAttachmentsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetBootVolumeAttachmentsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetBootVolumeBackupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetBootVolumeBackupsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetBootVolumeReplicasFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetBootVolumeReplicasFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetBootVolumesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetBootVolumesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetByoipAllocatedRangesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetByoipAllocatedRangesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetByoipRangesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetByoipRangesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCaptureFiltersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetCaptureFiltersFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetClusterNetworkInstancesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetClusterNetworkInstancesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetClusterNetworksFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetClusterNetworksFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetComputeCapacityReservationInstanceShapesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetComputeCapacityReservationInstanceShapesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetComputeCapacityReservationInstancesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetComputeCapacityReservationInstancesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetComputeCapacityReservationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetComputeCapacityReservationsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetComputeClustersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetComputeClustersFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetComputeGlobalImageCapabilitySchemasFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetComputeGlobalImageCapabilitySchemasFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetComputeGlobalImageCapabilitySchemasVersionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the compute global image capability schema version
        :param Sequence[str] values: the list of values for the enum
        """
        GetComputeGlobalImageCapabilitySchemasVersionsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the compute global image capability schema version
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        the list of values for the enum
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetComputeImageCapabilitySchemasFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param Sequence[str] values: the list of values for the enum
        """
        GetComputeImageCapabilitySchemasFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        the list of values for the enum
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetConsoleHistoriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetConsoleHistoriesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCpeDeviceShapesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetCpeDeviceShapesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCpesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetCpesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCrossConnectGroupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetCrossConnectGroupsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCrossConnectLocationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the location.  Example: `CyrusOne, Chandler, AZ`
        """
        GetCrossConnectLocationsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the location.  Example: `CyrusOne, Chandler, AZ`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCrossConnectPortSpeedShapeFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the port speed shape.  Example: `10 Gbps`
        """
        GetCrossConnectPortSpeedShapeFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the port speed shape.  Example: `10 Gbps`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCrossConnectsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetCrossConnectsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDedicatedVmHostInstanceShapesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDedicatedVmHostInstanceShapesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDedicatedVmHostInstancesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDedicatedVmHostInstancesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDedicatedVmHostShapesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDedicatedVmHostShapesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDedicatedVmHostsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDedicatedVmHostsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDhcpOptionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDhcpOptionsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDrgAttachmentsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDrgAttachmentsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDrgRouteDistributionStatementsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDrgRouteDistributionStatementsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDrgRouteDistributionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDrgRouteDistributionsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDrgRouteTableRouteRulesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDrgRouteTableRouteRulesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDrgRouteTablesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDrgRouteTablesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDrgsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDrgsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetFastConnectProviderServicesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetFastConnectProviderServicesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetImageShapesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetImageShapesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetImagesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetImagesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetInstanceConfigurationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The plugin name. To get a list of available plugins, use the [ListInstanceagentAvailablePlugins](https://docs.cloud.oracle.com/iaas/api/#/en/instanceagent/20180530/Plugin/ListInstanceagentAvailablePlugins) operation in the Oracle Cloud Agent API. For more information about the available plugins, see [Managing Plugins with Oracle Cloud Agent](https://docs.cloud.oracle.com/iaas/Content/Compute/Tasks/manage-plugins.htm).
        """
        GetInstanceConfigurationsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The plugin name. To get a list of available plugins, use the [ListInstanceagentAvailablePlugins](https://docs.cloud.oracle.com/iaas/api/#/en/instanceagent/20180530/Plugin/ListInstanceagentAvailablePlugins) operation in the Oracle Cloud Agent API. For more information about the available plugins, see [Managing Plugins with Oracle Cloud Agent](https://docs.cloud.oracle.com/iaas/Content/Compute/Tasks/manage-plugins.htm).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetInstanceConsoleConnectionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetInstanceConsoleConnectionsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetInstanceDevicesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to return only devices that match the given name exactly.
        """
        GetInstanceDevicesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to return only devices that match the given name exactly.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetInstancePoolInstancesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetInstancePoolInstancesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetInstancePoolsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetInstancePoolsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetInstancesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The plugin name. To get a list of available plugins, use the [ListInstanceagentAvailablePlugins](https://docs.cloud.oracle.com/iaas/api/#/en/instanceagent/20180530/Plugin/ListInstanceagentAvailablePlugins) operation in the Oracle Cloud Agent API. For more information about the available plugins, see [Managing Plugins with Oracle Cloud Agent](https://docs.cloud.oracle.com/iaas/Content/Compute/Tasks/manage-plugins.htm).
        """
        GetInstancesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The plugin name. To get a list of available plugins, use the [ListInstanceagentAvailablePlugins](https://docs.cloud.oracle.com/iaas/api/#/en/instanceagent/20180530/Plugin/ListInstanceagentAvailablePlugins) operation in the Oracle Cloud Agent API. For more information about the available plugins, see [Managing Plugins with Oracle Cloud Agent](https://docs.cloud.oracle.com/iaas/Content/Compute/Tasks/manage-plugins.htm).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetInternetGatewaysFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetInternetGatewaysFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetIpsecConfigFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetIpsecConfigFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetIpsecConnectionTunnelRoutesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetIpsecConnectionTunnelRoutesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetIpsecConnectionTunnelsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetIpsecConnectionTunnelsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetIpsecConnectionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetIpsecConnectionsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetIpsecStatusFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetIpsecStatusFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetIpv6sFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetIpv6sFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetListingResourceVersionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetListingResourceVersionsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetLocalPeeringGatewaysFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetLocalPeeringGatewaysFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetNatGatewaysFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetNatGatewaysFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetNetworkSecurityGroupSecurityRulesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetNetworkSecurityGroupSecurityRulesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetNetworkSecurityGroupVnicsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetNetworkSecurityGroupVnicsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetNetworkSecurityGroupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetNetworkSecurityGroupsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetPeerRegionForRemotePeeringsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The region's name.  Example: `us-phoenix-1`
        """
        GetPeerRegionForRemotePeeringsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The region's name.  Example: `us-phoenix-1`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetPrivateIpsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetPrivateIpsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetPublicIpPoolsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetPublicIpPoolsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetPublicIpsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetPublicIpsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetRemotePeeringConnectionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetRemotePeeringConnectionsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetRouteTablesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetRouteTablesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetSecurityListsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetSecurityListsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetServiceGatewaysFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetServiceGatewaysFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetServicesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the `Service` object. This name can change and is not guaranteed to be unique.  Example: `OCI PHX Object Storage`
        """
        GetServicesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the `Service` object. This name can change and is not guaranteed to be unique.  Example: `OCI PHX Object Storage`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetShapeFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetShapeFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetShapesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the shape. You can enumerate all available shapes by calling [ListShapes](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Shape/ListShapes).
        """
        GetShapesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the shape. You can enumerate all available shapes by calling [ListShapes](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Shape/ListShapes).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetSubnetsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetSubnetsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetTunnelSecurityAssociationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetTunnelSecurityAssociationsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetVcnsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetVcnsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetVirtualCircuitAssociatedTunnelsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetVirtualCircuitAssociatedTunnelsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetVirtualCircuitBandwidthShapesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the bandwidth shape.  Example: `10 Gbps`
        """
        GetVirtualCircuitBandwidthShapesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the bandwidth shape.  Example: `10 Gbps`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetVirtualCircuitPublicPrefixesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetVirtualCircuitPublicPrefixesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetVirtualCircuitsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetVirtualCircuitsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetVirtualNetworksFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetVirtualNetworksFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetVlansFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetVlansFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetVnicAttachmentsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetVnicAttachmentsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetVolumeAttachmentsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetVolumeAttachmentsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetVolumeBackupPoliciesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetVolumeBackupPoliciesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetVolumeBackupPolicyAssignmentsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetVolumeBackupPolicyAssignmentsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetVolumeBackupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetVolumeBackupsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetVolumeGroupBackupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetVolumeGroupBackupsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetVolumeGroupReplicasFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetVolumeGroupReplicasFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetVolumeGroupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetVolumeGroupsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetVolumesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetVolumesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetVtapsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetVtapsFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


