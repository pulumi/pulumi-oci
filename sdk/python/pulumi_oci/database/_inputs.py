# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AutonomousContainerDatabaseBackupConfigArgs',
    'AutonomousContainerDatabaseBackupConfigArgsDict',
    'AutonomousContainerDatabaseBackupConfigBackupDestinationDetailsArgs',
    'AutonomousContainerDatabaseBackupConfigBackupDestinationDetailsArgsDict',
    'AutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigArgs',
    'AutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigArgsDict',
    'AutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs',
    'AutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgsDict',
    'AutonomousContainerDatabaseKeyHistoryEntryArgs',
    'AutonomousContainerDatabaseKeyHistoryEntryArgsDict',
    'AutonomousContainerDatabaseMaintenanceWindowArgs',
    'AutonomousContainerDatabaseMaintenanceWindowArgsDict',
    'AutonomousContainerDatabaseMaintenanceWindowDaysOfWeekArgs',
    'AutonomousContainerDatabaseMaintenanceWindowDaysOfWeekArgsDict',
    'AutonomousContainerDatabaseMaintenanceWindowDetailsArgs',
    'AutonomousContainerDatabaseMaintenanceWindowDetailsArgsDict',
    'AutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeekArgs',
    'AutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeekArgsDict',
    'AutonomousContainerDatabaseMaintenanceWindowDetailsMonthArgs',
    'AutonomousContainerDatabaseMaintenanceWindowDetailsMonthArgsDict',
    'AutonomousContainerDatabaseMaintenanceWindowMonthArgs',
    'AutonomousContainerDatabaseMaintenanceWindowMonthArgsDict',
    'AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigArgs',
    'AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigArgsDict',
    'AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs',
    'AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgsDict',
    'AutonomousDatabaseApexDetailArgs',
    'AutonomousDatabaseApexDetailArgsDict',
    'AutonomousDatabaseBackupBackupDestinationDetailsArgs',
    'AutonomousDatabaseBackupBackupDestinationDetailsArgsDict',
    'AutonomousDatabaseBackupConfigArgs',
    'AutonomousDatabaseBackupConfigArgsDict',
    'AutonomousDatabaseConnectionStringArgs',
    'AutonomousDatabaseConnectionStringArgsDict',
    'AutonomousDatabaseConnectionStringProfileArgs',
    'AutonomousDatabaseConnectionStringProfileArgsDict',
    'AutonomousDatabaseConnectionUrlArgs',
    'AutonomousDatabaseConnectionUrlArgsDict',
    'AutonomousDatabaseCustomerContactArgs',
    'AutonomousDatabaseCustomerContactArgsDict',
    'AutonomousDatabaseDbToolsDetailArgs',
    'AutonomousDatabaseDbToolsDetailArgsDict',
    'AutonomousDatabaseEncryptionKeyArgs',
    'AutonomousDatabaseEncryptionKeyArgsDict',
    'AutonomousDatabaseEncryptionKeyHistoryEntryArgs',
    'AutonomousDatabaseEncryptionKeyHistoryEntryArgsDict',
    'AutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKeyArgs',
    'AutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKeyArgsDict',
    'AutonomousDatabaseKeyHistoryEntryArgs',
    'AutonomousDatabaseKeyHistoryEntryArgsDict',
    'AutonomousDatabaseLocalStandbyDbArgs',
    'AutonomousDatabaseLocalStandbyDbArgsDict',
    'AutonomousDatabaseLongTermBackupScheduleArgs',
    'AutonomousDatabaseLongTermBackupScheduleArgsDict',
    'AutonomousDatabasePublicConnectionUrlArgs',
    'AutonomousDatabasePublicConnectionUrlArgsDict',
    'AutonomousDatabaseRemoteDisasterRecoveryConfigurationArgs',
    'AutonomousDatabaseRemoteDisasterRecoveryConfigurationArgsDict',
    'AutonomousDatabaseResourcePoolSummaryArgs',
    'AutonomousDatabaseResourcePoolSummaryArgsDict',
    'AutonomousDatabaseScheduledOperationArgs',
    'AutonomousDatabaseScheduledOperationArgsDict',
    'AutonomousDatabaseScheduledOperationDayOfWeekArgs',
    'AutonomousDatabaseScheduledOperationDayOfWeekArgsDict',
    'AutonomousDatabaseStandbyDbArgs',
    'AutonomousDatabaseStandbyDbArgsDict',
    'AutonomousExadataInfrastructureMaintenanceWindowArgs',
    'AutonomousExadataInfrastructureMaintenanceWindowArgsDict',
    'AutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekArgs',
    'AutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekArgsDict',
    'AutonomousExadataInfrastructureMaintenanceWindowDetailsArgs',
    'AutonomousExadataInfrastructureMaintenanceWindowDetailsArgsDict',
    'AutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeekArgs',
    'AutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeekArgsDict',
    'AutonomousExadataInfrastructureMaintenanceWindowDetailsMonthArgs',
    'AutonomousExadataInfrastructureMaintenanceWindowDetailsMonthArgsDict',
    'AutonomousExadataInfrastructureMaintenanceWindowMonthArgs',
    'AutonomousExadataInfrastructureMaintenanceWindowMonthArgsDict',
    'AutonomousVmClusterMaintenanceWindowArgs',
    'AutonomousVmClusterMaintenanceWindowArgsDict',
    'AutonomousVmClusterMaintenanceWindowDaysOfWeekArgs',
    'AutonomousVmClusterMaintenanceWindowDaysOfWeekArgsDict',
    'AutonomousVmClusterMaintenanceWindowDetailArgs',
    'AutonomousVmClusterMaintenanceWindowDetailArgsDict',
    'AutonomousVmClusterMaintenanceWindowDetailDaysOfWeekArgs',
    'AutonomousVmClusterMaintenanceWindowDetailDaysOfWeekArgsDict',
    'AutonomousVmClusterMaintenanceWindowDetailMonthArgs',
    'AutonomousVmClusterMaintenanceWindowDetailMonthArgsDict',
    'AutonomousVmClusterMaintenanceWindowMonthArgs',
    'AutonomousVmClusterMaintenanceWindowMonthArgsDict',
    'BackupDestinationAssociatedDatabaseArgs',
    'BackupDestinationAssociatedDatabaseArgsDict',
    'BackupDestinationMountTypeDetailsArgs',
    'BackupDestinationMountTypeDetailsArgsDict',
    'CloudAutonomousVmClusterMaintenanceWindowArgs',
    'CloudAutonomousVmClusterMaintenanceWindowArgsDict',
    'CloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgs',
    'CloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgsDict',
    'CloudAutonomousVmClusterMaintenanceWindowDetailsArgs',
    'CloudAutonomousVmClusterMaintenanceWindowDetailsArgsDict',
    'CloudAutonomousVmClusterMaintenanceWindowDetailsDaysOfWeekArgs',
    'CloudAutonomousVmClusterMaintenanceWindowDetailsDaysOfWeekArgsDict',
    'CloudAutonomousVmClusterMaintenanceWindowDetailsMonthArgs',
    'CloudAutonomousVmClusterMaintenanceWindowDetailsMonthArgsDict',
    'CloudAutonomousVmClusterMaintenanceWindowMonthArgs',
    'CloudAutonomousVmClusterMaintenanceWindowMonthArgsDict',
    'CloudDatabaseManagementCredentialdetailsArgs',
    'CloudDatabaseManagementCredentialdetailsArgsDict',
    'CloudExadataInfrastructureCustomerContactArgs',
    'CloudExadataInfrastructureCustomerContactArgsDict',
    'CloudExadataInfrastructureDefinedFileSystemConfigurationArgs',
    'CloudExadataInfrastructureDefinedFileSystemConfigurationArgsDict',
    'CloudExadataInfrastructureMaintenanceWindowArgs',
    'CloudExadataInfrastructureMaintenanceWindowArgsDict',
    'CloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgs',
    'CloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgsDict',
    'CloudExadataInfrastructureMaintenanceWindowMonthArgs',
    'CloudExadataInfrastructureMaintenanceWindowMonthArgsDict',
    'CloudVmClusterCloudAutomationUpdateDetailsArgs',
    'CloudVmClusterCloudAutomationUpdateDetailsArgsDict',
    'CloudVmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreferenceArgs',
    'CloudVmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreferenceArgsDict',
    'CloudVmClusterCloudAutomationUpdateDetailsFreezePeriodArgs',
    'CloudVmClusterCloudAutomationUpdateDetailsFreezePeriodArgsDict',
    'CloudVmClusterDataCollectionOptionsArgs',
    'CloudVmClusterDataCollectionOptionsArgsDict',
    'CloudVmClusterFileSystemConfigurationDetailArgs',
    'CloudVmClusterFileSystemConfigurationDetailArgsDict',
    'CloudVmClusterIormConfigCachArgs',
    'CloudVmClusterIormConfigCachArgsDict',
    'CloudVmClusterIormConfigCachDbPlanArgs',
    'CloudVmClusterIormConfigCachDbPlanArgsDict',
    'CloudVmClusterIormConfigDbPlanArgs',
    'CloudVmClusterIormConfigDbPlanArgsDict',
    'DataGuardAssociationDataCollectionOptionsArgs',
    'DataGuardAssociationDataCollectionOptionsArgsDict',
    'DatabaseConnectionStringArgs',
    'DatabaseConnectionStringArgsDict',
    'DatabaseDatabaseArgs',
    'DatabaseDatabaseArgsDict',
    'DatabaseDatabaseDbBackupConfigArgs',
    'DatabaseDatabaseDbBackupConfigArgsDict',
    'DatabaseDatabaseDbBackupConfigBackupDestinationDetailArgs',
    'DatabaseDatabaseDbBackupConfigBackupDestinationDetailArgsDict',
    'DatabaseDatabaseManagementConfigArgs',
    'DatabaseDatabaseManagementConfigArgsDict',
    'DatabaseDbBackupConfigArgs',
    'DatabaseDbBackupConfigArgsDict',
    'DatabaseDbBackupConfigBackupDestinationDetailArgs',
    'DatabaseDbBackupConfigBackupDestinationDetailArgsDict',
    'DatabaseUpgradeConnectionStringArgs',
    'DatabaseUpgradeConnectionStringArgsDict',
    'DatabaseUpgradeDatabaseUpgradeSourceDetailsArgs',
    'DatabaseUpgradeDatabaseUpgradeSourceDetailsArgsDict',
    'DatabaseUpgradeDbBackupConfigArgs',
    'DatabaseUpgradeDbBackupConfigArgsDict',
    'DatabaseUpgradeDbBackupConfigBackupDestinationDetailArgs',
    'DatabaseUpgradeDbBackupConfigBackupDestinationDetailArgsDict',
    'DbHomeDatabaseArgs',
    'DbHomeDatabaseArgsDict',
    'DbHomeDatabaseConnectionStringArgs',
    'DbHomeDatabaseConnectionStringArgsDict',
    'DbHomeDatabaseDbBackupConfigArgs',
    'DbHomeDatabaseDbBackupConfigArgsDict',
    'DbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs',
    'DbHomeDatabaseDbBackupConfigBackupDestinationDetailArgsDict',
    'DbSystemDataCollectionOptionsArgs',
    'DbSystemDataCollectionOptionsArgsDict',
    'DbSystemDbHomeArgs',
    'DbSystemDbHomeArgsDict',
    'DbSystemDbHomeDatabaseArgs',
    'DbSystemDbHomeDatabaseArgsDict',
    'DbSystemDbHomeDatabaseConnectionStringArgs',
    'DbSystemDbHomeDatabaseConnectionStringArgsDict',
    'DbSystemDbHomeDatabaseDbBackupConfigArgs',
    'DbSystemDbHomeDatabaseDbBackupConfigArgsDict',
    'DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs',
    'DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailArgsDict',
    'DbSystemDbSystemOptionsArgs',
    'DbSystemDbSystemOptionsArgsDict',
    'DbSystemIormConfigCachArgs',
    'DbSystemIormConfigCachArgsDict',
    'DbSystemIormConfigCachDbPlanArgs',
    'DbSystemIormConfigCachDbPlanArgsDict',
    'DbSystemMaintenanceWindowArgs',
    'DbSystemMaintenanceWindowArgsDict',
    'DbSystemMaintenanceWindowDaysOfWeekArgs',
    'DbSystemMaintenanceWindowDaysOfWeekArgsDict',
    'DbSystemMaintenanceWindowDetailsArgs',
    'DbSystemMaintenanceWindowDetailsArgsDict',
    'DbSystemMaintenanceWindowDetailsDaysOfWeekArgs',
    'DbSystemMaintenanceWindowDetailsDaysOfWeekArgsDict',
    'DbSystemMaintenanceWindowDetailsMonthArgs',
    'DbSystemMaintenanceWindowDetailsMonthArgsDict',
    'DbSystemMaintenanceWindowMonthArgs',
    'DbSystemMaintenanceWindowMonthArgsDict',
    'DbSystemsUpgradeDbSystemOptionArgs',
    'DbSystemsUpgradeDbSystemOptionArgsDict',
    'DbSystemsUpgradeIormConfigCachArgs',
    'DbSystemsUpgradeIormConfigCachArgsDict',
    'DbSystemsUpgradeIormConfigCachDbPlanArgs',
    'DbSystemsUpgradeIormConfigCachDbPlanArgsDict',
    'DbSystemsUpgradeMaintenanceWindowArgs',
    'DbSystemsUpgradeMaintenanceWindowArgsDict',
    'DbSystemsUpgradeMaintenanceWindowDaysOfWeekArgs',
    'DbSystemsUpgradeMaintenanceWindowDaysOfWeekArgsDict',
    'DbSystemsUpgradeMaintenanceWindowMonthArgs',
    'DbSystemsUpgradeMaintenanceWindowMonthArgsDict',
    'ExadataInfrastructureComputeContactArgs',
    'ExadataInfrastructureComputeContactArgsDict',
    'ExadataInfrastructureComputeMaintenanceWindowArgs',
    'ExadataInfrastructureComputeMaintenanceWindowArgsDict',
    'ExadataInfrastructureComputeMaintenanceWindowDaysOfWeekArgs',
    'ExadataInfrastructureComputeMaintenanceWindowDaysOfWeekArgsDict',
    'ExadataInfrastructureComputeMaintenanceWindowMonthArgs',
    'ExadataInfrastructureComputeMaintenanceWindowMonthArgsDict',
    'ExadataInfrastructureContactArgs',
    'ExadataInfrastructureContactArgsDict',
    'ExadataInfrastructureDefinedFileSystemConfigurationArgs',
    'ExadataInfrastructureDefinedFileSystemConfigurationArgsDict',
    'ExadataInfrastructureMaintenanceWindowArgs',
    'ExadataInfrastructureMaintenanceWindowArgsDict',
    'ExadataInfrastructureMaintenanceWindowDaysOfWeekArgs',
    'ExadataInfrastructureMaintenanceWindowDaysOfWeekArgsDict',
    'ExadataInfrastructureMaintenanceWindowMonthArgs',
    'ExadataInfrastructureMaintenanceWindowMonthArgsDict',
    'ExadataInfrastructureNetworkBondingModeDetailsArgs',
    'ExadataInfrastructureNetworkBondingModeDetailsArgsDict',
    'ExadataInfrastructureStorageContactArgs',
    'ExadataInfrastructureStorageContactArgsDict',
    'ExadataInfrastructureStorageMaintenanceWindowArgs',
    'ExadataInfrastructureStorageMaintenanceWindowArgsDict',
    'ExadataInfrastructureStorageMaintenanceWindowDaysOfWeekArgs',
    'ExadataInfrastructureStorageMaintenanceWindowDaysOfWeekArgsDict',
    'ExadataInfrastructureStorageMaintenanceWindowMonthArgs',
    'ExadataInfrastructureStorageMaintenanceWindowMonthArgsDict',
    'ExadataIormConfigDbPlanArgs',
    'ExadataIormConfigDbPlanArgsDict',
    'ExadbVmClusterDataCollectionOptionsArgs',
    'ExadbVmClusterDataCollectionOptionsArgsDict',
    'ExadbVmClusterIormConfigCachArgs',
    'ExadbVmClusterIormConfigCachArgsDict',
    'ExadbVmClusterIormConfigCachDbPlanArgs',
    'ExadbVmClusterIormConfigCachDbPlanArgsDict',
    'ExadbVmClusterNodeConfigArgs',
    'ExadbVmClusterNodeConfigArgsDict',
    'ExadbVmClusterNodeResourceArgs',
    'ExadbVmClusterNodeResourceArgsDict',
    'ExascaleDbStorageVaultHighCapacityDatabaseStorageArgs',
    'ExascaleDbStorageVaultHighCapacityDatabaseStorageArgsDict',
    'ExternalContainerDatabaseDatabaseManagementConfigArgs',
    'ExternalContainerDatabaseDatabaseManagementConfigArgsDict',
    'ExternalContainerDatabaseStackMonitoringConfigArgs',
    'ExternalContainerDatabaseStackMonitoringConfigArgsDict',
    'ExternalDatabaseConnectorConnectionCredentialsArgs',
    'ExternalDatabaseConnectorConnectionCredentialsArgsDict',
    'ExternalDatabaseConnectorConnectionStringArgs',
    'ExternalDatabaseConnectorConnectionStringArgsDict',
    'ExternalNonContainerDatabaseDatabaseManagementConfigArgs',
    'ExternalNonContainerDatabaseDatabaseManagementConfigArgsDict',
    'ExternalNonContainerDatabaseOperationsInsightsConfigArgs',
    'ExternalNonContainerDatabaseOperationsInsightsConfigArgsDict',
    'ExternalNonContainerDatabaseStackMonitoringConfigArgs',
    'ExternalNonContainerDatabaseStackMonitoringConfigArgsDict',
    'ExternalPluggableDatabaseDatabaseManagementConfigArgs',
    'ExternalPluggableDatabaseDatabaseManagementConfigArgsDict',
    'ExternalPluggableDatabaseOperationsInsightsConfigArgs',
    'ExternalPluggableDatabaseOperationsInsightsConfigArgsDict',
    'ExternalPluggableDatabaseStackMonitoringConfigArgs',
    'ExternalPluggableDatabaseStackMonitoringConfigArgsDict',
    'KeyStoreAssociatedDatabaseArgs',
    'KeyStoreAssociatedDatabaseArgsDict',
    'KeyStoreTypeDetailsArgs',
    'KeyStoreTypeDetailsArgsDict',
    'MaintenanceRunEstimatedPatchingTimeArgs',
    'MaintenanceRunEstimatedPatchingTimeArgsDict',
    'PluggableDatabaseConnectionStringArgs',
    'PluggableDatabaseConnectionStringArgsDict',
    'PluggableDatabaseManagementsManagementConnectionStringArgs',
    'PluggableDatabaseManagementsManagementConnectionStringArgsDict',
    'PluggableDatabaseManagementsManagementCredentialDetailsArgs',
    'PluggableDatabaseManagementsManagementCredentialDetailsArgsDict',
    'PluggableDatabaseManagementsManagementPluggableDatabaseManagementConfigArgs',
    'PluggableDatabaseManagementsManagementPluggableDatabaseManagementConfigArgsDict',
    'PluggableDatabasePdbCreationTypeDetailsArgs',
    'PluggableDatabasePdbCreationTypeDetailsArgsDict',
    'PluggableDatabasePdbCreationTypeDetailsRefreshableCloneDetailsArgs',
    'PluggableDatabasePdbCreationTypeDetailsRefreshableCloneDetailsArgsDict',
    'PluggableDatabasePdbNodeLevelDetailArgs',
    'PluggableDatabasePdbNodeLevelDetailArgsDict',
    'PluggableDatabasePluggableDatabaseManagementConfigArgs',
    'PluggableDatabasePluggableDatabaseManagementConfigArgsDict',
    'PluggableDatabaseRefreshableCloneConfigArgs',
    'PluggableDatabaseRefreshableCloneConfigArgsDict',
    'PluggableDatabasesLocalCloneConnectionStringArgs',
    'PluggableDatabasesLocalCloneConnectionStringArgsDict',
    'PluggableDatabasesLocalClonePdbNodeLevelDetailArgs',
    'PluggableDatabasesLocalClonePdbNodeLevelDetailArgsDict',
    'PluggableDatabasesLocalClonePluggableDatabaseManagementConfigArgs',
    'PluggableDatabasesLocalClonePluggableDatabaseManagementConfigArgsDict',
    'PluggableDatabasesLocalCloneRefreshableCloneConfigArgs',
    'PluggableDatabasesLocalCloneRefreshableCloneConfigArgsDict',
    'PluggableDatabasesRemoteCloneConnectionStringArgs',
    'PluggableDatabasesRemoteCloneConnectionStringArgsDict',
    'PluggableDatabasesRemoteClonePdbNodeLevelDetailArgs',
    'PluggableDatabasesRemoteClonePdbNodeLevelDetailArgsDict',
    'PluggableDatabasesRemoteClonePluggableDatabaseManagementConfigArgs',
    'PluggableDatabasesRemoteClonePluggableDatabaseManagementConfigArgsDict',
    'PluggableDatabasesRemoteCloneRefreshableCloneConfigArgs',
    'PluggableDatabasesRemoteCloneRefreshableCloneConfigArgsDict',
    'VmClusterAddVirtualNetworkCloudAutomationUpdateDetailArgs',
    'VmClusterAddVirtualNetworkCloudAutomationUpdateDetailArgsDict',
    'VmClusterAddVirtualNetworkCloudAutomationUpdateDetailApplyUpdateTimePreferenceArgs',
    'VmClusterAddVirtualNetworkCloudAutomationUpdateDetailApplyUpdateTimePreferenceArgsDict',
    'VmClusterAddVirtualNetworkCloudAutomationUpdateDetailFreezePeriodArgs',
    'VmClusterAddVirtualNetworkCloudAutomationUpdateDetailFreezePeriodArgsDict',
    'VmClusterAddVirtualNetworkDataCollectionOptionArgs',
    'VmClusterAddVirtualNetworkDataCollectionOptionArgsDict',
    'VmClusterAddVirtualNetworkDbServerArgs',
    'VmClusterAddVirtualNetworkDbServerArgsDict',
    'VmClusterAddVirtualNetworkFileSystemConfigurationDetailArgs',
    'VmClusterAddVirtualNetworkFileSystemConfigurationDetailArgsDict',
    'VmClusterCloudAutomationUpdateDetailsArgs',
    'VmClusterCloudAutomationUpdateDetailsArgsDict',
    'VmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreferenceArgs',
    'VmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreferenceArgsDict',
    'VmClusterCloudAutomationUpdateDetailsFreezePeriodArgs',
    'VmClusterCloudAutomationUpdateDetailsFreezePeriodArgsDict',
    'VmClusterDataCollectionOptionsArgs',
    'VmClusterDataCollectionOptionsArgsDict',
    'VmClusterFileSystemConfigurationDetailArgs',
    'VmClusterFileSystemConfigurationDetailArgsDict',
    'VmClusterNetworkDrScanArgs',
    'VmClusterNetworkDrScanArgsDict',
    'VmClusterNetworkScanArgs',
    'VmClusterNetworkScanArgsDict',
    'VmClusterNetworkVmNetworkArgs',
    'VmClusterNetworkVmNetworkArgsDict',
    'VmClusterNetworkVmNetworkNodeArgs',
    'VmClusterNetworkVmNetworkNodeArgsDict',
    'VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailArgs',
    'VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailArgsDict',
    'VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailApplyUpdateTimePreferenceArgs',
    'VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailApplyUpdateTimePreferenceArgsDict',
    'VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailFreezePeriodArgs',
    'VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailFreezePeriodArgsDict',
    'VmClusterRemoveVirtualMachineDataCollectionOptionArgs',
    'VmClusterRemoveVirtualMachineDataCollectionOptionArgsDict',
    'VmClusterRemoveVirtualMachineDbServerArgs',
    'VmClusterRemoveVirtualMachineDbServerArgsDict',
    'VmClusterRemoveVirtualMachineFileSystemConfigurationDetailArgs',
    'VmClusterRemoveVirtualMachineFileSystemConfigurationDetailArgsDict',
    'GetApplicationVipsFilterArgs',
    'GetApplicationVipsFilterArgsDict',
    'GetAutonomousCharacterSetsFilterArgs',
    'GetAutonomousCharacterSetsFilterArgsDict',
    'GetAutonomousContainerDatabaseDataguardAssociationsFilterArgs',
    'GetAutonomousContainerDatabaseDataguardAssociationsFilterArgsDict',
    'GetAutonomousContainerDatabaseVersionsFilterArgs',
    'GetAutonomousContainerDatabaseVersionsFilterArgsDict',
    'GetAutonomousContainerDatabasesFilterArgs',
    'GetAutonomousContainerDatabasesFilterArgsDict',
    'GetAutonomousContainerPatchesFilterArgs',
    'GetAutonomousContainerPatchesFilterArgsDict',
    'GetAutonomousDatabaseBackupsFilterArgs',
    'GetAutonomousDatabaseBackupsFilterArgsDict',
    'GetAutonomousDatabaseDataguardAssociationsFilterArgs',
    'GetAutonomousDatabaseDataguardAssociationsFilterArgsDict',
    'GetAutonomousDatabasePeersFilterArgs',
    'GetAutonomousDatabasePeersFilterArgsDict',
    'GetAutonomousDatabaseRefreshableClonesFilterArgs',
    'GetAutonomousDatabaseRefreshableClonesFilterArgsDict',
    'GetAutonomousDatabaseSoftwareImagesFilterArgs',
    'GetAutonomousDatabaseSoftwareImagesFilterArgsDict',
    'GetAutonomousDatabasesClonesFilterArgs',
    'GetAutonomousDatabasesClonesFilterArgsDict',
    'GetAutonomousDatabasesFilterArgs',
    'GetAutonomousDatabasesFilterArgsDict',
    'GetAutonomousDbPreviewVersionsFilterArgs',
    'GetAutonomousDbPreviewVersionsFilterArgsDict',
    'GetAutonomousDbVersionsFilterArgs',
    'GetAutonomousDbVersionsFilterArgsDict',
    'GetAutonomousExadataInfrastructureShapesFilterArgs',
    'GetAutonomousExadataInfrastructureShapesFilterArgsDict',
    'GetAutonomousExadataInfrastructuresFilterArgs',
    'GetAutonomousExadataInfrastructuresFilterArgsDict',
    'GetAutonomousVirtualMachinesFilterArgs',
    'GetAutonomousVirtualMachinesFilterArgsDict',
    'GetAutonomousVmClusterAcdResourceUsagesFilterArgs',
    'GetAutonomousVmClusterAcdResourceUsagesFilterArgsDict',
    'GetAutonomousVmClustersFilterArgs',
    'GetAutonomousVmClustersFilterArgsDict',
    'GetBackupDestinationsFilterArgs',
    'GetBackupDestinationsFilterArgsDict',
    'GetBackupsFilterArgs',
    'GetBackupsFilterArgsDict',
    'GetCloudAutonomousVmClusterAcdResourceUsagesFilterArgs',
    'GetCloudAutonomousVmClusterAcdResourceUsagesFilterArgsDict',
    'GetCloudAutonomousVmClustersFilterArgs',
    'GetCloudAutonomousVmClustersFilterArgsDict',
    'GetCloudExadataInfrastructuresFilterArgs',
    'GetCloudExadataInfrastructuresFilterArgsDict',
    'GetCloudVmClustersFilterArgs',
    'GetCloudVmClustersFilterArgsDict',
    'GetDataGuardAssociationsFilterArgs',
    'GetDataGuardAssociationsFilterArgsDict',
    'GetDatabaseMaintenanceRunHistoriesFilterArgs',
    'GetDatabaseMaintenanceRunHistoriesFilterArgsDict',
    'GetDatabasePdbConversionHistoryEntriesFilterArgs',
    'GetDatabasePdbConversionHistoryEntriesFilterArgsDict',
    'GetDatabaseSoftwareImagesFilterArgs',
    'GetDatabaseSoftwareImagesFilterArgsDict',
    'GetDatabaseUpgradeHistoryEntriesFilterArgs',
    'GetDatabaseUpgradeHistoryEntriesFilterArgsDict',
    'GetDatabasesFilterArgs',
    'GetDatabasesFilterArgsDict',
    'GetDbHomePatchHistoryEntriesFilterArgs',
    'GetDbHomePatchHistoryEntriesFilterArgsDict',
    'GetDbHomePatchesFilterArgs',
    'GetDbHomePatchesFilterArgsDict',
    'GetDbHomesFilterArgs',
    'GetDbHomesFilterArgsDict',
    'GetDbNodeConsoleConnectionsFilterArgs',
    'GetDbNodeConsoleConnectionsFilterArgsDict',
    'GetDbNodeConsoleHistoriesFilterArgs',
    'GetDbNodeConsoleHistoriesFilterArgsDict',
    'GetDbNodesFilterArgs',
    'GetDbNodesFilterArgsDict',
    'GetDbServersFilterArgs',
    'GetDbServersFilterArgsDict',
    'GetDbSystemComputePerformancesFilterArgs',
    'GetDbSystemComputePerformancesFilterArgsDict',
    'GetDbSystemHistoryEntriesFilterArgs',
    'GetDbSystemHistoryEntriesFilterArgsDict',
    'GetDbSystemPatchesFilterArgs',
    'GetDbSystemPatchesFilterArgsDict',
    'GetDbSystemShapesFilterArgs',
    'GetDbSystemShapesFilterArgsDict',
    'GetDbSystemStoragePerformancesFilterArgs',
    'GetDbSystemStoragePerformancesFilterArgsDict',
    'GetDbSystemsFilterArgs',
    'GetDbSystemsFilterArgsDict',
    'GetDbSystemsUpgradeHistoryEntriesFilterArgs',
    'GetDbSystemsUpgradeHistoryEntriesFilterArgsDict',
    'GetDbVersionsFilterArgs',
    'GetDbVersionsFilterArgsDict',
    'GetExadataInfrastructuresFilterArgs',
    'GetExadataInfrastructuresFilterArgsDict',
    'GetExadbVmClusterUpdateHistoryEntriesFilterArgs',
    'GetExadbVmClusterUpdateHistoryEntriesFilterArgsDict',
    'GetExadbVmClusterUpdatesFilterArgs',
    'GetExadbVmClusterUpdatesFilterArgsDict',
    'GetExadbVmClustersFilterArgs',
    'GetExadbVmClustersFilterArgsDict',
    'GetExascaleDbStorageVaultsFilterArgs',
    'GetExascaleDbStorageVaultsFilterArgsDict',
    'GetExternalContainerDatabasesFilterArgs',
    'GetExternalContainerDatabasesFilterArgsDict',
    'GetExternalDatabaseConnectorsFilterArgs',
    'GetExternalDatabaseConnectorsFilterArgsDict',
    'GetExternalNonContainerDatabasesFilterArgs',
    'GetExternalNonContainerDatabasesFilterArgsDict',
    'GetExternalPluggableDatabasesFilterArgs',
    'GetExternalPluggableDatabasesFilterArgsDict',
    'GetFlexComponentsFilterArgs',
    'GetFlexComponentsFilterArgsDict',
    'GetGiVersionMinorVersionsFilterArgs',
    'GetGiVersionMinorVersionsFilterArgsDict',
    'GetGiVersionsFilterArgs',
    'GetGiVersionsFilterArgsDict',
    'GetKeyStoresFilterArgs',
    'GetKeyStoresFilterArgsDict',
    'GetMaintenanceRunsFilterArgs',
    'GetMaintenanceRunsFilterArgsDict',
    'GetManagedPreferredCredentialsFilterArgs',
    'GetManagedPreferredCredentialsFilterArgsDict',
    'GetOneoffPatchesFilterArgs',
    'GetOneoffPatchesFilterArgsDict',
    'GetPluggableDatabasesFilterArgs',
    'GetPluggableDatabasesFilterArgsDict',
    'GetSystemVersionsFilterArgs',
    'GetSystemVersionsFilterArgsDict',
    'GetVmClusterNetworksFilterArgs',
    'GetVmClusterNetworksFilterArgsDict',
    'GetVmClusterPatchHistoryEntriesFilterArgs',
    'GetVmClusterPatchHistoryEntriesFilterArgsDict',
    'GetVmClusterPatchesFilterArgs',
    'GetVmClusterPatchesFilterArgsDict',
    'GetVmClusterRecommendedNetworkNetworkArgs',
    'GetVmClusterRecommendedNetworkNetworkArgsDict',
    'GetVmClusterUpdateHistoryEntriesFilterArgs',
    'GetVmClusterUpdateHistoryEntriesFilterArgsDict',
    'GetVmClusterUpdatesFilterArgs',
    'GetVmClusterUpdatesFilterArgsDict',
    'GetVmClustersFilterArgs',
    'GetVmClustersFilterArgsDict',
]

MYPY = False

if not MYPY:
    class AutonomousContainerDatabaseBackupConfigArgsDict(TypedDict):
        backup_destination_details: NotRequired[pulumi.Input['AutonomousContainerDatabaseBackupConfigBackupDestinationDetailsArgsDict']]
        """
        (Updatable) Backup destination details.
        """
        recovery_window_in_days: NotRequired[pulumi.Input[int]]
        """
        (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups. If the number of specified days is 0 then there will be no backups.
        """
elif False:
    AutonomousContainerDatabaseBackupConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousContainerDatabaseBackupConfigArgs:
    def __init__(__self__, *,
                 backup_destination_details: Optional[pulumi.Input['AutonomousContainerDatabaseBackupConfigBackupDestinationDetailsArgs']] = None,
                 recovery_window_in_days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['AutonomousContainerDatabaseBackupConfigBackupDestinationDetailsArgs'] backup_destination_details: (Updatable) Backup destination details.
        :param pulumi.Input[int] recovery_window_in_days: (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups. If the number of specified days is 0 then there will be no backups.
        """
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[pulumi.Input['AutonomousContainerDatabaseBackupConfigBackupDestinationDetailsArgs']]:
        """
        (Updatable) Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @backup_destination_details.setter
    def backup_destination_details(self, value: Optional[pulumi.Input['AutonomousContainerDatabaseBackupConfigBackupDestinationDetailsArgs']]):
        pulumi.set(self, "backup_destination_details", value)

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups. If the number of specified days is 0 then there will be no backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @recovery_window_in_days.setter
    def recovery_window_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "recovery_window_in_days", value)


if not MYPY:
    class AutonomousContainerDatabaseBackupConfigBackupDestinationDetailsArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        (Updatable) Type of the database backup destination.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        internet_proxy: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Proxy URL to connect to object store.
        """
        vpc_password: NotRequired[pulumi.Input[str]]
        """
        (Updatable) For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        vpc_user: NotRequired[pulumi.Input[str]]
        """
        (Updatable) For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
elif False:
    AutonomousContainerDatabaseBackupConfigBackupDestinationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousContainerDatabaseBackupConfigBackupDestinationDetailsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None,
                 internet_proxy: Optional[pulumi.Input[str]] = None,
                 vpc_password: Optional[pulumi.Input[str]] = None,
                 vpc_user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: (Updatable) Type of the database backup destination.
        :param pulumi.Input[str] id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param pulumi.Input[str] internet_proxy: (Updatable) Proxy URL to connect to object store.
        :param pulumi.Input[str] vpc_password: (Updatable) For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param pulumi.Input[str] vpc_user: (Updatable) For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if internet_proxy is not None:
            pulumi.set(__self__, "internet_proxy", internet_proxy)
        if vpc_password is not None:
            pulumi.set(__self__, "vpc_password", vpc_password)
        if vpc_user is not None:
            pulumi.set(__self__, "vpc_user", vpc_user)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @internet_proxy.setter
    def internet_proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "internet_proxy", value)

    @property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @vpc_password.setter
    def vpc_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_password", value)

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")

    @vpc_user.setter
    def vpc_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_user", value)


if not MYPY:
    class AutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigArgsDict(TypedDict):
        backup_destination_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgsDict']]]]
        """
        Backup destination details.
        """
        recovery_window_in_days: NotRequired[pulumi.Input[int]]
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
elif False:
    AutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigArgs:
    def __init__(__self__, *,
                 backup_destination_details: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs']]]] = None,
                 recovery_window_in_days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs']]] backup_destination_details: Backup destination details.
        :param pulumi.Input[int] recovery_window_in_days: Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs']]]]:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @backup_destination_details.setter
    def backup_destination_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs']]]]):
        pulumi.set(self, "backup_destination_details", value)

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @recovery_window_in_days.setter
    def recovery_window_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "recovery_window_in_days", value)


if not MYPY:
    class AutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of the database backup destination.
        """
        dbrs_policy_id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        internet_proxy: NotRequired[pulumi.Input[str]]
        """
        Proxy URL to connect to object store.
        """
        vpc_password: NotRequired[pulumi.Input[str]]
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        vpc_user: NotRequired[pulumi.Input[str]]
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
elif False:
    AutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousContainerDatabaseDataguardAssociationPeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 dbrs_policy_id: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 internet_proxy: Optional[pulumi.Input[str]] = None,
                 vpc_password: Optional[pulumi.Input[str]] = None,
                 vpc_user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Type of the database backup destination.
        :param pulumi.Input[str] dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param pulumi.Input[str] internet_proxy: Proxy URL to connect to object store.
        :param pulumi.Input[str] vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param pulumi.Input[str] vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        pulumi.set(__self__, "type", type)
        if dbrs_policy_id is not None:
            pulumi.set(__self__, "dbrs_policy_id", dbrs_policy_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if internet_proxy is not None:
            pulumi.set(__self__, "internet_proxy", internet_proxy)
        if vpc_password is not None:
            pulumi.set(__self__, "vpc_password", vpc_password)
        if vpc_user is not None:
            pulumi.set(__self__, "vpc_user", vpc_user)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @dbrs_policy_id.setter
    def dbrs_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dbrs_policy_id", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @internet_proxy.setter
    def internet_proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "internet_proxy", value)

    @property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> Optional[pulumi.Input[str]]:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @vpc_password.setter
    def vpc_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_password", value)

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[pulumi.Input[str]]:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")

    @vpc_user.setter
    def vpc_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_user", value)


if not MYPY:
    class AutonomousContainerDatabaseKeyHistoryEntryArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        kms_key_version_id: NotRequired[pulumi.Input[str]]
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        """
        time_activated: NotRequired[pulumi.Input[str]]
        """
        The date and time the kms key activated.
        """
        vault_id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
elif False:
    AutonomousContainerDatabaseKeyHistoryEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousContainerDatabaseKeyHistoryEntryArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 kms_key_version_id: Optional[pulumi.Input[str]] = None,
                 time_activated: Optional[pulumi.Input[str]] = None,
                 vault_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param pulumi.Input[str] kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        :param pulumi.Input[str] time_activated: The date and time the kms key activated.
        :param pulumi.Input[str] vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if kms_key_version_id is not None:
            pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        if time_activated is not None:
            pulumi.set(__self__, "time_activated", time_activated)
        if vault_id is not None:
            pulumi.set(__self__, "vault_id", vault_id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        """
        return pulumi.get(self, "kms_key_version_id")

    @kms_key_version_id.setter
    def kms_key_version_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_version_id", value)

    @property
    @pulumi.getter(name="timeActivated")
    def time_activated(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the kms key activated.
        """
        return pulumi.get(self, "time_activated")

    @time_activated.setter
    def time_activated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_activated", value)

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")

    @vault_id.setter
    def vault_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vault_id", value)


if not MYPY:
    class AutonomousContainerDatabaseMaintenanceWindowArgsDict(TypedDict):
        custom_action_timeout_in_mins: NotRequired[pulumi.Input[int]]
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        days_of_weeks: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowDaysOfWeekArgsDict']]]]
        """
        Days during the week when maintenance should be performed.
        """
        hours_of_days: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        is_custom_action_timeout_enabled: NotRequired[pulumi.Input[bool]]
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        is_monthly_patching_enabled: NotRequired[pulumi.Input[bool]]
        """
        If true, enables the monthly patching option.
        """
        lead_time_in_weeks: NotRequired[pulumi.Input[int]]
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        months: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowMonthArgsDict']]]]
        """
        Months during the year when maintenance should be performed.
        """
        patching_mode: NotRequired[pulumi.Input[str]]
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        preference: NotRequired[pulumi.Input[str]]
        """
        The maintenance window scheduling preference.
        """
        skip_rus: NotRequired[pulumi.Input[Sequence[pulumi.Input[bool]]]]
        """
        If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        weeks_of_months: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
elif False:
    AutonomousContainerDatabaseMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousContainerDatabaseMaintenanceWindowArgs:
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[pulumi.Input[int]] = None,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 is_custom_action_timeout_enabled: Optional[pulumi.Input[bool]] = None,
                 is_monthly_patching_enabled: Optional[pulumi.Input[bool]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowMonthArgs']]]] = None,
                 patching_mode: Optional[pulumi.Input[str]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 skip_rus: Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[int] custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowDaysOfWeekArgs']]] days_of_weeks: Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[bool] is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param pulumi.Input[bool] is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param pulumi.Input[int] lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowMonthArgs']]] months: Months during the year when maintenance should be performed.
        :param pulumi.Input[str] patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param pulumi.Input[str] preference: The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[bool]]] skip_rus: If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if skip_rus is not None:
            pulumi.set(__self__, "skip_rus", skip_rus)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[pulumi.Input[int]]:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @custom_action_timeout_in_mins.setter
    def custom_action_timeout_in_mins(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_action_timeout_in_mins", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowDaysOfWeekArgs']]]]:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @is_custom_action_timeout_enabled.setter
    def is_custom_action_timeout_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom_action_timeout_enabled", value)

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @is_monthly_patching_enabled.setter
    def is_monthly_patching_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monthly_patching_enabled", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowMonthArgs']]]]:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @patching_mode.setter
    def patching_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patching_mode", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]]:
        """
        If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        return pulumi.get(self, "skip_rus")

    @skip_rus.setter
    def skip_rus(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]]):
        pulumi.set(self, "skip_rus", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


if not MYPY:
    class AutonomousContainerDatabaseMaintenanceWindowDaysOfWeekArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the month of the year.
        """
elif False:
    AutonomousContainerDatabaseMaintenanceWindowDaysOfWeekArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousContainerDatabaseMaintenanceWindowDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AutonomousContainerDatabaseMaintenanceWindowDetailsArgsDict(TypedDict):
        custom_action_timeout_in_mins: NotRequired[pulumi.Input[int]]
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        days_of_weeks: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeekArgsDict']]]]
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        hours_of_days: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        is_custom_action_timeout_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        is_monthly_patching_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) If true, enables the monthly patching option.
        """
        lead_time_in_weeks: NotRequired[pulumi.Input[int]]
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        months: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowDetailsMonthArgsDict']]]]
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        patching_mode: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        preference: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The maintenance window scheduling preference.
        """
        skip_rus: NotRequired[pulumi.Input[Sequence[pulumi.Input[bool]]]]
        """
        (Updatable) If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        weeks_of_months: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
elif False:
    AutonomousContainerDatabaseMaintenanceWindowDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousContainerDatabaseMaintenanceWindowDetailsArgs:
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[pulumi.Input[int]] = None,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 is_custom_action_timeout_enabled: Optional[pulumi.Input[bool]] = None,
                 is_monthly_patching_enabled: Optional[pulumi.Input[bool]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowDetailsMonthArgs']]]] = None,
                 patching_mode: Optional[pulumi.Input[str]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 skip_rus: Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[int] custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeekArgs']]] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[bool] is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param pulumi.Input[bool] is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param pulumi.Input[int] lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowDetailsMonthArgs']]] months: (Updatable) Months during the year when maintenance should be performed.
        :param pulumi.Input[str] patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param pulumi.Input[str] preference: (Updatable) The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[bool]]] skip_rus: (Updatable) If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if skip_rus is not None:
            pulumi.set(__self__, "skip_rus", skip_rus)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @custom_action_timeout_in_mins.setter
    def custom_action_timeout_in_mins(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_action_timeout_in_mins", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeekArgs']]]]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @is_custom_action_timeout_enabled.setter
    def is_custom_action_timeout_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom_action_timeout_enabled", value)

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @is_monthly_patching_enabled.setter
    def is_monthly_patching_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monthly_patching_enabled", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowDetailsMonthArgs']]]]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowDetailsMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @patching_mode.setter
    def patching_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patching_mode", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]]:
        """
        (Updatable) If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        return pulumi.get(self, "skip_rus")

    @skip_rus.setter
    def skip_rus(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]]):
        pulumi.set(self, "skip_rus", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


if not MYPY:
    class AutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeekArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        (Updatable) Name of the day of the week.
        """
elif False:
    AutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeekArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the day of the week.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the day of the week.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AutonomousContainerDatabaseMaintenanceWindowDetailsMonthArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        (Updatable) Name of the month of the year.
        """
elif False:
    AutonomousContainerDatabaseMaintenanceWindowDetailsMonthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousContainerDatabaseMaintenanceWindowDetailsMonthArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AutonomousContainerDatabaseMaintenanceWindowMonthArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the month of the year.
        """
elif False:
    AutonomousContainerDatabaseMaintenanceWindowMonthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousContainerDatabaseMaintenanceWindowMonthArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigArgsDict(TypedDict):
        backup_destination_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgsDict']]]]
        """
        Backup destination details.
        """
        recovery_window_in_days: NotRequired[pulumi.Input[int]]
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups. If the number of specified days is 0 then there will be no backups.
        """
elif False:
    AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigArgs:
    def __init__(__self__, *,
                 backup_destination_details: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs']]]] = None,
                 recovery_window_in_days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs']]] backup_destination_details: Backup destination details.
        :param pulumi.Input[int] recovery_window_in_days: Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups. If the number of specified days is 0 then there will be no backups.
        """
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs']]]]:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @backup_destination_details.setter
    def backup_destination_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs']]]]):
        pulumi.set(self, "backup_destination_details", value)

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups. If the number of specified days is 0 then there will be no backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @recovery_window_in_days.setter
    def recovery_window_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "recovery_window_in_days", value)


if not MYPY:
    class AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of the database backup destination.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        internet_proxy: NotRequired[pulumi.Input[str]]
        """
        Proxy URL to connect to object store.
        """
        vpc_password: NotRequired[pulumi.Input[str]]
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        vpc_user: NotRequired[pulumi.Input[str]]
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
elif False:
    AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None,
                 internet_proxy: Optional[pulumi.Input[str]] = None,
                 vpc_password: Optional[pulumi.Input[str]] = None,
                 vpc_user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Type of the database backup destination.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param pulumi.Input[str] internet_proxy: Proxy URL to connect to object store.
        :param pulumi.Input[str] vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param pulumi.Input[str] vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if internet_proxy is not None:
            pulumi.set(__self__, "internet_proxy", internet_proxy)
        if vpc_password is not None:
            pulumi.set(__self__, "vpc_password", vpc_password)
        if vpc_user is not None:
            pulumi.set(__self__, "vpc_user", vpc_user)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @internet_proxy.setter
    def internet_proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "internet_proxy", value)

    @property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> Optional[pulumi.Input[str]]:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @vpc_password.setter
    def vpc_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_password", value)

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[pulumi.Input[str]]:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")

    @vpc_user.setter
    def vpc_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_user", value)


if not MYPY:
    class AutonomousDatabaseApexDetailArgsDict(TypedDict):
        apex_version: NotRequired[pulumi.Input[str]]
        """
        The Oracle APEX Application Development version.
        """
        ords_version: NotRequired[pulumi.Input[str]]
        """
        The Oracle REST Data Services (ORDS) version.
        """
elif False:
    AutonomousDatabaseApexDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousDatabaseApexDetailArgs:
    def __init__(__self__, *,
                 apex_version: Optional[pulumi.Input[str]] = None,
                 ords_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] apex_version: The Oracle APEX Application Development version.
        :param pulumi.Input[str] ords_version: The Oracle REST Data Services (ORDS) version.
        """
        if apex_version is not None:
            pulumi.set(__self__, "apex_version", apex_version)
        if ords_version is not None:
            pulumi.set(__self__, "ords_version", ords_version)

    @property
    @pulumi.getter(name="apexVersion")
    def apex_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Oracle APEX Application Development version.
        """
        return pulumi.get(self, "apex_version")

    @apex_version.setter
    def apex_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "apex_version", value)

    @property
    @pulumi.getter(name="ordsVersion")
    def ords_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Oracle REST Data Services (ORDS) version.
        """
        return pulumi.get(self, "ords_version")

    @ords_version.setter
    def ords_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ords_version", value)


if not MYPY:
    class AutonomousDatabaseBackupBackupDestinationDetailsArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        The type of backup.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database backup.
        """
        internet_proxy: NotRequired[pulumi.Input[str]]
        """
        Proxy URL to connect to object store.
        """
        vpc_password: NotRequired[pulumi.Input[str]]
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        vpc_user: NotRequired[pulumi.Input[str]]
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
elif False:
    AutonomousDatabaseBackupBackupDestinationDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousDatabaseBackupBackupDestinationDetailsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None,
                 internet_proxy: Optional[pulumi.Input[str]] = None,
                 vpc_password: Optional[pulumi.Input[str]] = None,
                 vpc_user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of backup.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database backup.
        :param pulumi.Input[str] internet_proxy: Proxy URL to connect to object store.
        :param pulumi.Input[str] vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param pulumi.Input[str] vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if internet_proxy is not None:
            pulumi.set(__self__, "internet_proxy", internet_proxy)
        if vpc_password is not None:
            pulumi.set(__self__, "vpc_password", vpc_password)
        if vpc_user is not None:
            pulumi.set(__self__, "vpc_user", vpc_user)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of backup.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database backup.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @internet_proxy.setter
    def internet_proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "internet_proxy", value)

    @property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> Optional[pulumi.Input[str]]:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @vpc_password.setter
    def vpc_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_password", value)

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[pulumi.Input[str]]:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")

    @vpc_user.setter
    def vpc_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_user", value)


if not MYPY:
    class AutonomousDatabaseBackupConfigArgsDict(TypedDict):
        manual_backup_bucket_name: NotRequired[pulumi.Input[str]]
        """
        Name of [Object Storage](https://docs.cloud.oracle.com/iaas/Content/Object/Concepts/objectstorageoverview.htm) bucket to use for storing manual backups.
        """
        manual_backup_type: NotRequired[pulumi.Input[str]]
        """
        The manual backup destination type.
        """
elif False:
    AutonomousDatabaseBackupConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousDatabaseBackupConfigArgs:
    def __init__(__self__, *,
                 manual_backup_bucket_name: Optional[pulumi.Input[str]] = None,
                 manual_backup_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] manual_backup_bucket_name: Name of [Object Storage](https://docs.cloud.oracle.com/iaas/Content/Object/Concepts/objectstorageoverview.htm) bucket to use for storing manual backups.
        :param pulumi.Input[str] manual_backup_type: The manual backup destination type.
        """
        if manual_backup_bucket_name is not None:
            pulumi.set(__self__, "manual_backup_bucket_name", manual_backup_bucket_name)
        if manual_backup_type is not None:
            pulumi.set(__self__, "manual_backup_type", manual_backup_type)

    @property
    @pulumi.getter(name="manualBackupBucketName")
    def manual_backup_bucket_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of [Object Storage](https://docs.cloud.oracle.com/iaas/Content/Object/Concepts/objectstorageoverview.htm) bucket to use for storing manual backups.
        """
        return pulumi.get(self, "manual_backup_bucket_name")

    @manual_backup_bucket_name.setter
    def manual_backup_bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "manual_backup_bucket_name", value)

    @property
    @pulumi.getter(name="manualBackupType")
    def manual_backup_type(self) -> Optional[pulumi.Input[str]]:
        """
        The manual backup destination type.
        """
        return pulumi.get(self, "manual_backup_type")

    @manual_backup_type.setter
    def manual_backup_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "manual_backup_type", value)


if not MYPY:
    class AutonomousDatabaseConnectionStringArgsDict(TypedDict):
        all_connection_strings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Returns all connection strings that can be used to connect to the Autonomous Database. For more information, please see [Predefined Database Service Names for Autonomous Transaction Processing](https://docs.oracle.com/en/cloud/paas/atp-cloud/atpug/connect-predefined.html#GUID-9747539B-FD46-44F1-8FF8-F5AC650F15BE)
        """
        dedicated: NotRequired[pulumi.Input[str]]
        """
        The database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        """
        high: NotRequired[pulumi.Input[str]]
        """
        The High database service provides the highest level of resources to each SQL statement resulting in the highest performance, but supports the fewest number of concurrent SQL statements.
        """
        low: NotRequired[pulumi.Input[str]]
        """
        The Low database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        """
        medium: NotRequired[pulumi.Input[str]]
        """
        The Medium database service provides a lower level of resources to each SQL statement potentially resulting a lower level of performance, but supports more concurrent SQL statements.
        """
        profiles: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutonomousDatabaseConnectionStringProfileArgsDict']]]]
        """
        A list of connection string profiles to allow clients to group, filter and select connection string values based on structured metadata.
        """
elif False:
    AutonomousDatabaseConnectionStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousDatabaseConnectionStringArgs:
    def __init__(__self__, *,
                 all_connection_strings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 dedicated: Optional[pulumi.Input[str]] = None,
                 high: Optional[pulumi.Input[str]] = None,
                 low: Optional[pulumi.Input[str]] = None,
                 medium: Optional[pulumi.Input[str]] = None,
                 profiles: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousDatabaseConnectionStringProfileArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] all_connection_strings: Returns all connection strings that can be used to connect to the Autonomous Database. For more information, please see [Predefined Database Service Names for Autonomous Transaction Processing](https://docs.oracle.com/en/cloud/paas/atp-cloud/atpug/connect-predefined.html#GUID-9747539B-FD46-44F1-8FF8-F5AC650F15BE)
        :param pulumi.Input[str] dedicated: The database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        :param pulumi.Input[str] high: The High database service provides the highest level of resources to each SQL statement resulting in the highest performance, but supports the fewest number of concurrent SQL statements.
        :param pulumi.Input[str] low: The Low database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        :param pulumi.Input[str] medium: The Medium database service provides a lower level of resources to each SQL statement potentially resulting a lower level of performance, but supports more concurrent SQL statements.
        :param pulumi.Input[Sequence[pulumi.Input['AutonomousDatabaseConnectionStringProfileArgs']]] profiles: A list of connection string profiles to allow clients to group, filter and select connection string values based on structured metadata.
        """
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if dedicated is not None:
            pulumi.set(__self__, "dedicated", dedicated)
        if high is not None:
            pulumi.set(__self__, "high", high)
        if low is not None:
            pulumi.set(__self__, "low", low)
        if medium is not None:
            pulumi.set(__self__, "medium", medium)
        if profiles is not None:
            pulumi.set(__self__, "profiles", profiles)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Returns all connection strings that can be used to connect to the Autonomous Database. For more information, please see [Predefined Database Service Names for Autonomous Transaction Processing](https://docs.oracle.com/en/cloud/paas/atp-cloud/atpug/connect-predefined.html#GUID-9747539B-FD46-44F1-8FF8-F5AC650F15BE)
        """
        return pulumi.get(self, "all_connection_strings")

    @all_connection_strings.setter
    def all_connection_strings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "all_connection_strings", value)

    @property
    @pulumi.getter
    def dedicated(self) -> Optional[pulumi.Input[str]]:
        """
        The database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        """
        return pulumi.get(self, "dedicated")

    @dedicated.setter
    def dedicated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dedicated", value)

    @property
    @pulumi.getter
    def high(self) -> Optional[pulumi.Input[str]]:
        """
        The High database service provides the highest level of resources to each SQL statement resulting in the highest performance, but supports the fewest number of concurrent SQL statements.
        """
        return pulumi.get(self, "high")

    @high.setter
    def high(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "high", value)

    @property
    @pulumi.getter
    def low(self) -> Optional[pulumi.Input[str]]:
        """
        The Low database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        """
        return pulumi.get(self, "low")

    @low.setter
    def low(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "low", value)

    @property
    @pulumi.getter
    def medium(self) -> Optional[pulumi.Input[str]]:
        """
        The Medium database service provides a lower level of resources to each SQL statement potentially resulting a lower level of performance, but supports more concurrent SQL statements.
        """
        return pulumi.get(self, "medium")

    @medium.setter
    def medium(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "medium", value)

    @property
    @pulumi.getter
    def profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousDatabaseConnectionStringProfileArgs']]]]:
        """
        A list of connection string profiles to allow clients to group, filter and select connection string values based on structured metadata.
        """
        return pulumi.get(self, "profiles")

    @profiles.setter
    def profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousDatabaseConnectionStringProfileArgs']]]]):
        pulumi.set(self, "profiles", value)


if not MYPY:
    class AutonomousDatabaseConnectionStringProfileArgsDict(TypedDict):
        consumer_group: NotRequired[pulumi.Input[str]]
        """
        Consumer group used by the connection.
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The user-friendly name for the Autonomous Database. The name does not have to be unique.
        """
        host_format: NotRequired[pulumi.Input[str]]
        """
        Host format used in connection string.
        """
        is_regional: NotRequired[pulumi.Input[bool]]
        """
        True for a regional connection string, applicable to cross-region DG only.
        """
        protocol: NotRequired[pulumi.Input[str]]
        """
        Protocol used by the connection.
        """
        session_mode: NotRequired[pulumi.Input[str]]
        """
        Specifies whether the listener performs a direct hand-off of the session, or redirects the session. In RAC deployments where SCAN is used, sessions are redirected to a Node VIP. Use `DIRECT` for direct hand-offs. Use `REDIRECT` to redirect the session.
        """
        syntax_format: NotRequired[pulumi.Input[str]]
        """
        Specifies whether the connection string is using the long (`LONG`), Easy Connect (`EZCONNECT`), or Easy Connect Plus (`EZCONNECTPLUS`) format. Autonomous Database Serverless instances always use the long format.
        """
        tls_authentication: NotRequired[pulumi.Input[str]]
        """
        Specifies whether the TLS handshake is using one-way (`SERVER`) or mutual (`MUTUAL`) authentication.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Connection string value.
        """
elif False:
    AutonomousDatabaseConnectionStringProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousDatabaseConnectionStringProfileArgs:
    def __init__(__self__, *,
                 consumer_group: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 host_format: Optional[pulumi.Input[str]] = None,
                 is_regional: Optional[pulumi.Input[bool]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 session_mode: Optional[pulumi.Input[str]] = None,
                 syntax_format: Optional[pulumi.Input[str]] = None,
                 tls_authentication: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] consumer_group: Consumer group used by the connection.
        :param pulumi.Input[str] display_name: (Updatable) The user-friendly name for the Autonomous Database. The name does not have to be unique.
        :param pulumi.Input[str] host_format: Host format used in connection string.
        :param pulumi.Input[bool] is_regional: True for a regional connection string, applicable to cross-region DG only.
        :param pulumi.Input[str] protocol: Protocol used by the connection.
        :param pulumi.Input[str] session_mode: Specifies whether the listener performs a direct hand-off of the session, or redirects the session. In RAC deployments where SCAN is used, sessions are redirected to a Node VIP. Use `DIRECT` for direct hand-offs. Use `REDIRECT` to redirect the session.
        :param pulumi.Input[str] syntax_format: Specifies whether the connection string is using the long (`LONG`), Easy Connect (`EZCONNECT`), or Easy Connect Plus (`EZCONNECTPLUS`) format. Autonomous Database Serverless instances always use the long format.
        :param pulumi.Input[str] tls_authentication: Specifies whether the TLS handshake is using one-way (`SERVER`) or mutual (`MUTUAL`) authentication.
        :param pulumi.Input[str] value: Connection string value.
        """
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if host_format is not None:
            pulumi.set(__self__, "host_format", host_format)
        if is_regional is not None:
            pulumi.set(__self__, "is_regional", is_regional)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if session_mode is not None:
            pulumi.set(__self__, "session_mode", session_mode)
        if syntax_format is not None:
            pulumi.set(__self__, "syntax_format", syntax_format)
        if tls_authentication is not None:
            pulumi.set(__self__, "tls_authentication", tls_authentication)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[pulumi.Input[str]]:
        """
        Consumer group used by the connection.
        """
        return pulumi.get(self, "consumer_group")

    @consumer_group.setter
    def consumer_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_group", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The user-friendly name for the Autonomous Database. The name does not have to be unique.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="hostFormat")
    def host_format(self) -> Optional[pulumi.Input[str]]:
        """
        Host format used in connection string.
        """
        return pulumi.get(self, "host_format")

    @host_format.setter
    def host_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_format", value)

    @property
    @pulumi.getter(name="isRegional")
    def is_regional(self) -> Optional[pulumi.Input[bool]]:
        """
        True for a regional connection string, applicable to cross-region DG only.
        """
        return pulumi.get(self, "is_regional")

    @is_regional.setter
    def is_regional(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_regional", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Protocol used by the connection.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="sessionMode")
    def session_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether the listener performs a direct hand-off of the session, or redirects the session. In RAC deployments where SCAN is used, sessions are redirected to a Node VIP. Use `DIRECT` for direct hand-offs. Use `REDIRECT` to redirect the session.
        """
        return pulumi.get(self, "session_mode")

    @session_mode.setter
    def session_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "session_mode", value)

    @property
    @pulumi.getter(name="syntaxFormat")
    def syntax_format(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether the connection string is using the long (`LONG`), Easy Connect (`EZCONNECT`), or Easy Connect Plus (`EZCONNECTPLUS`) format. Autonomous Database Serverless instances always use the long format.
        """
        return pulumi.get(self, "syntax_format")

    @syntax_format.setter
    def syntax_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "syntax_format", value)

    @property
    @pulumi.getter(name="tlsAuthentication")
    def tls_authentication(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether the TLS handshake is using one-way (`SERVER`) or mutual (`MUTUAL`) authentication.
        """
        return pulumi.get(self, "tls_authentication")

    @tls_authentication.setter
    def tls_authentication(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_authentication", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Connection string value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AutonomousDatabaseConnectionUrlArgsDict(TypedDict):
        apex_url: NotRequired[pulumi.Input[str]]
        """
        Oracle Application Express (APEX) URL.
        """
        database_transforms_url: NotRequired[pulumi.Input[str]]
        """
        The URL of the Database Transforms for the Autonomous Database.
        """
        graph_studio_url: NotRequired[pulumi.Input[str]]
        """
        The URL of the Graph Studio for the Autonomous Database.
        """
        machine_learning_notebook_url: NotRequired[pulumi.Input[str]]
        """
        The URL of the Oracle Machine Learning (OML) Notebook for the Autonomous Database.
        """
        machine_learning_user_management_url: NotRequired[pulumi.Input[str]]
        """
        Oracle Machine Learning user management URL.
        """
        mongo_db_url: NotRequired[pulumi.Input[str]]
        """
        The URL of the MongoDB API for the Autonomous Database.
        """
        ords_url: NotRequired[pulumi.Input[str]]
        """
        The Oracle REST Data Services (ORDS) URL of the Web Access for the Autonomous Database.
        """
        sql_dev_web_url: NotRequired[pulumi.Input[str]]
        """
        Oracle SQL Developer Web URL.
        """
elif False:
    AutonomousDatabaseConnectionUrlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousDatabaseConnectionUrlArgs:
    def __init__(__self__, *,
                 apex_url: Optional[pulumi.Input[str]] = None,
                 database_transforms_url: Optional[pulumi.Input[str]] = None,
                 graph_studio_url: Optional[pulumi.Input[str]] = None,
                 machine_learning_notebook_url: Optional[pulumi.Input[str]] = None,
                 machine_learning_user_management_url: Optional[pulumi.Input[str]] = None,
                 mongo_db_url: Optional[pulumi.Input[str]] = None,
                 ords_url: Optional[pulumi.Input[str]] = None,
                 sql_dev_web_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] apex_url: Oracle Application Express (APEX) URL.
        :param pulumi.Input[str] database_transforms_url: The URL of the Database Transforms for the Autonomous Database.
        :param pulumi.Input[str] graph_studio_url: The URL of the Graph Studio for the Autonomous Database.
        :param pulumi.Input[str] machine_learning_notebook_url: The URL of the Oracle Machine Learning (OML) Notebook for the Autonomous Database.
        :param pulumi.Input[str] machine_learning_user_management_url: Oracle Machine Learning user management URL.
        :param pulumi.Input[str] mongo_db_url: The URL of the MongoDB API for the Autonomous Database.
        :param pulumi.Input[str] ords_url: The Oracle REST Data Services (ORDS) URL of the Web Access for the Autonomous Database.
        :param pulumi.Input[str] sql_dev_web_url: Oracle SQL Developer Web URL.
        """
        if apex_url is not None:
            pulumi.set(__self__, "apex_url", apex_url)
        if database_transforms_url is not None:
            pulumi.set(__self__, "database_transforms_url", database_transforms_url)
        if graph_studio_url is not None:
            pulumi.set(__self__, "graph_studio_url", graph_studio_url)
        if machine_learning_notebook_url is not None:
            pulumi.set(__self__, "machine_learning_notebook_url", machine_learning_notebook_url)
        if machine_learning_user_management_url is not None:
            pulumi.set(__self__, "machine_learning_user_management_url", machine_learning_user_management_url)
        if mongo_db_url is not None:
            pulumi.set(__self__, "mongo_db_url", mongo_db_url)
        if ords_url is not None:
            pulumi.set(__self__, "ords_url", ords_url)
        if sql_dev_web_url is not None:
            pulumi.set(__self__, "sql_dev_web_url", sql_dev_web_url)

    @property
    @pulumi.getter(name="apexUrl")
    def apex_url(self) -> Optional[pulumi.Input[str]]:
        """
        Oracle Application Express (APEX) URL.
        """
        return pulumi.get(self, "apex_url")

    @apex_url.setter
    def apex_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "apex_url", value)

    @property
    @pulumi.getter(name="databaseTransformsUrl")
    def database_transforms_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the Database Transforms for the Autonomous Database.
        """
        return pulumi.get(self, "database_transforms_url")

    @database_transforms_url.setter
    def database_transforms_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_transforms_url", value)

    @property
    @pulumi.getter(name="graphStudioUrl")
    def graph_studio_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the Graph Studio for the Autonomous Database.
        """
        return pulumi.get(self, "graph_studio_url")

    @graph_studio_url.setter
    def graph_studio_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "graph_studio_url", value)

    @property
    @pulumi.getter(name="machineLearningNotebookUrl")
    def machine_learning_notebook_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the Oracle Machine Learning (OML) Notebook for the Autonomous Database.
        """
        return pulumi.get(self, "machine_learning_notebook_url")

    @machine_learning_notebook_url.setter
    def machine_learning_notebook_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "machine_learning_notebook_url", value)

    @property
    @pulumi.getter(name="machineLearningUserManagementUrl")
    def machine_learning_user_management_url(self) -> Optional[pulumi.Input[str]]:
        """
        Oracle Machine Learning user management URL.
        """
        return pulumi.get(self, "machine_learning_user_management_url")

    @machine_learning_user_management_url.setter
    def machine_learning_user_management_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "machine_learning_user_management_url", value)

    @property
    @pulumi.getter(name="mongoDbUrl")
    def mongo_db_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the MongoDB API for the Autonomous Database.
        """
        return pulumi.get(self, "mongo_db_url")

    @mongo_db_url.setter
    def mongo_db_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mongo_db_url", value)

    @property
    @pulumi.getter(name="ordsUrl")
    def ords_url(self) -> Optional[pulumi.Input[str]]:
        """
        The Oracle REST Data Services (ORDS) URL of the Web Access for the Autonomous Database.
        """
        return pulumi.get(self, "ords_url")

    @ords_url.setter
    def ords_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ords_url", value)

    @property
    @pulumi.getter(name="sqlDevWebUrl")
    def sql_dev_web_url(self) -> Optional[pulumi.Input[str]]:
        """
        Oracle SQL Developer Web URL.
        """
        return pulumi.get(self, "sql_dev_web_url")

    @sql_dev_web_url.setter
    def sql_dev_web_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sql_dev_web_url", value)


if not MYPY:
    class AutonomousDatabaseCustomerContactArgsDict(TypedDict):
        email: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
elif False:
    AutonomousDatabaseCustomerContactArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousDatabaseCustomerContactArgs:
    def __init__(__self__, *,
                 email: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] email: (Updatable) The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        if email is not None:
            pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)


if not MYPY:
    class AutonomousDatabaseDbToolsDetailArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        (Updatable) Name of database tool.
        """
        compute_count: NotRequired[pulumi.Input[float]]
        """
        (Updatable) Compute used by database tools.
        """
        is_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Indicates whether tool is enabled.
        """
        max_idle_time_in_minutes: NotRequired[pulumi.Input[int]]
        """
        (Updatable) The max idle time, in minutes, after which the VM used by database tools will be terminated.
        """
elif False:
    AutonomousDatabaseDbToolsDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousDatabaseDbToolsDetailArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 compute_count: Optional[pulumi.Input[float]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 max_idle_time_in_minutes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) Name of database tool.
        :param pulumi.Input[float] compute_count: (Updatable) Compute used by database tools.
        :param pulumi.Input[bool] is_enabled: (Updatable) Indicates whether tool is enabled.
        :param pulumi.Input[int] max_idle_time_in_minutes: (Updatable) The max idle time, in minutes, after which the VM used by database tools will be terminated.
        """
        pulumi.set(__self__, "name", name)
        if compute_count is not None:
            pulumi.set(__self__, "compute_count", compute_count)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if max_idle_time_in_minutes is not None:
            pulumi.set(__self__, "max_idle_time_in_minutes", max_idle_time_in_minutes)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of database tool.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="computeCount")
    def compute_count(self) -> Optional[pulumi.Input[float]]:
        """
        (Updatable) Compute used by database tools.
        """
        return pulumi.get(self, "compute_count")

    @compute_count.setter
    def compute_count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "compute_count", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Indicates whether tool is enabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="maxIdleTimeInMinutes")
    def max_idle_time_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The max idle time, in minutes, after which the VM used by database tools will be terminated.
        """
        return pulumi.get(self, "max_idle_time_in_minutes")

    @max_idle_time_in_minutes.setter
    def max_idle_time_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_idle_time_in_minutes", value)


if not MYPY:
    class AutonomousDatabaseEncryptionKeyArgsDict(TypedDict):
        arn_role: NotRequired[pulumi.Input[str]]
        """
        (Updatable) AWS ARN role
        """
        autonomous_database_provider: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The provider for the Autonomous Database encryption key.
        """
        certificate_directory_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) OKV certificate directory name
        """
        certificate_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) OKV certificate id
        """
        directory_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) OKV wallet directory name
        """
        external_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) AWS external ID
        """
        key_arn: NotRequired[pulumi.Input[str]]
        """
        (Updatable) AWS key ARN
        """
        key_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Azure key name
        """
        kms_key_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        okv_kms_key: NotRequired[pulumi.Input[str]]
        """
        (Updatable) UUID of OKV KMS Key
        """
        okv_uri: NotRequired[pulumi.Input[str]]
        """
        (Updatable) URI of OKV server
        """
        service_endpoint_uri: NotRequired[pulumi.Input[str]]
        """
        (Updatable) AWS key service endpoint URI
        """
        vault_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        vault_uri: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Azure vault URI
        """
elif False:
    AutonomousDatabaseEncryptionKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousDatabaseEncryptionKeyArgs:
    def __init__(__self__, *,
                 arn_role: Optional[pulumi.Input[str]] = None,
                 autonomous_database_provider: Optional[pulumi.Input[str]] = None,
                 certificate_directory_name: Optional[pulumi.Input[str]] = None,
                 certificate_id: Optional[pulumi.Input[str]] = None,
                 directory_name: Optional[pulumi.Input[str]] = None,
                 external_id: Optional[pulumi.Input[str]] = None,
                 key_arn: Optional[pulumi.Input[str]] = None,
                 key_name: Optional[pulumi.Input[str]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 okv_kms_key: Optional[pulumi.Input[str]] = None,
                 okv_uri: Optional[pulumi.Input[str]] = None,
                 service_endpoint_uri: Optional[pulumi.Input[str]] = None,
                 vault_id: Optional[pulumi.Input[str]] = None,
                 vault_uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] arn_role: (Updatable) AWS ARN role
        :param pulumi.Input[str] autonomous_database_provider: (Updatable) The provider for the Autonomous Database encryption key.
        :param pulumi.Input[str] certificate_directory_name: (Updatable) OKV certificate directory name
        :param pulumi.Input[str] certificate_id: (Updatable) OKV certificate id
        :param pulumi.Input[str] directory_name: (Updatable) OKV wallet directory name
        :param pulumi.Input[str] external_id: (Updatable) AWS external ID
        :param pulumi.Input[str] key_arn: (Updatable) AWS key ARN
        :param pulumi.Input[str] key_name: (Updatable) Azure key name
        :param pulumi.Input[str] kms_key_id: (Updatable) The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param pulumi.Input[str] okv_kms_key: (Updatable) UUID of OKV KMS Key
        :param pulumi.Input[str] okv_uri: (Updatable) URI of OKV server
        :param pulumi.Input[str] service_endpoint_uri: (Updatable) AWS key service endpoint URI
        :param pulumi.Input[str] vault_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        :param pulumi.Input[str] vault_uri: (Updatable) Azure vault URI
        """
        if arn_role is not None:
            pulumi.set(__self__, "arn_role", arn_role)
        if autonomous_database_provider is not None:
            pulumi.set(__self__, "autonomous_database_provider", autonomous_database_provider)
        if certificate_directory_name is not None:
            pulumi.set(__self__, "certificate_directory_name", certificate_directory_name)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if directory_name is not None:
            pulumi.set(__self__, "directory_name", directory_name)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if key_arn is not None:
            pulumi.set(__self__, "key_arn", key_arn)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if okv_kms_key is not None:
            pulumi.set(__self__, "okv_kms_key", okv_kms_key)
        if okv_uri is not None:
            pulumi.set(__self__, "okv_uri", okv_uri)
        if service_endpoint_uri is not None:
            pulumi.set(__self__, "service_endpoint_uri", service_endpoint_uri)
        if vault_id is not None:
            pulumi.set(__self__, "vault_id", vault_id)
        if vault_uri is not None:
            pulumi.set(__self__, "vault_uri", vault_uri)

    @property
    @pulumi.getter(name="arnRole")
    def arn_role(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) AWS ARN role
        """
        return pulumi.get(self, "arn_role")

    @arn_role.setter
    def arn_role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arn_role", value)

    @property
    @pulumi.getter(name="autonomousDatabaseProvider")
    def autonomous_database_provider(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The provider for the Autonomous Database encryption key.
        """
        return pulumi.get(self, "autonomous_database_provider")

    @autonomous_database_provider.setter
    def autonomous_database_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "autonomous_database_provider", value)

    @property
    @pulumi.getter(name="certificateDirectoryName")
    def certificate_directory_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) OKV certificate directory name
        """
        return pulumi.get(self, "certificate_directory_name")

    @certificate_directory_name.setter
    def certificate_directory_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_directory_name", value)

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) OKV certificate id
        """
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_id", value)

    @property
    @pulumi.getter(name="directoryName")
    def directory_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) OKV wallet directory name
        """
        return pulumi.get(self, "directory_name")

    @directory_name.setter
    def directory_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "directory_name", value)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) AWS external ID
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter(name="keyArn")
    def key_arn(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) AWS key ARN
        """
        return pulumi.get(self, "key_arn")

    @key_arn.setter
    def key_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_arn", value)

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Azure key name
        """
        return pulumi.get(self, "key_name")

    @key_name.setter
    def key_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_name", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="okvKmsKey")
    def okv_kms_key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) UUID of OKV KMS Key
        """
        return pulumi.get(self, "okv_kms_key")

    @okv_kms_key.setter
    def okv_kms_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "okv_kms_key", value)

    @property
    @pulumi.getter(name="okvUri")
    def okv_uri(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) URI of OKV server
        """
        return pulumi.get(self, "okv_uri")

    @okv_uri.setter
    def okv_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "okv_uri", value)

    @property
    @pulumi.getter(name="serviceEndpointUri")
    def service_endpoint_uri(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) AWS key service endpoint URI
        """
        return pulumi.get(self, "service_endpoint_uri")

    @service_endpoint_uri.setter
    def service_endpoint_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_endpoint_uri", value)

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        return pulumi.get(self, "vault_id")

    @vault_id.setter
    def vault_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vault_id", value)

    @property
    @pulumi.getter(name="vaultUri")
    def vault_uri(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Azure vault URI
        """
        return pulumi.get(self, "vault_uri")

    @vault_uri.setter
    def vault_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vault_uri", value)


if not MYPY:
    class AutonomousDatabaseEncryptionKeyHistoryEntryArgsDict(TypedDict):
        encryption_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKeyArgsDict']]]]
        """
        (Updatable) Details of the Autonomous Database encryption key.
        """
        time_activated: NotRequired[pulumi.Input[str]]
        """
        The date and time the kms key activated.
        """
elif False:
    AutonomousDatabaseEncryptionKeyHistoryEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousDatabaseEncryptionKeyHistoryEntryArgs:
    def __init__(__self__, *,
                 encryption_keys: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKeyArgs']]]] = None,
                 time_activated: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKeyArgs']]] encryption_keys: (Updatable) Details of the Autonomous Database encryption key.
        :param pulumi.Input[str] time_activated: The date and time the kms key activated.
        """
        if encryption_keys is not None:
            pulumi.set(__self__, "encryption_keys", encryption_keys)
        if time_activated is not None:
            pulumi.set(__self__, "time_activated", time_activated)

    @property
    @pulumi.getter(name="encryptionKeys")
    def encryption_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKeyArgs']]]]:
        """
        (Updatable) Details of the Autonomous Database encryption key.
        """
        return pulumi.get(self, "encryption_keys")

    @encryption_keys.setter
    def encryption_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKeyArgs']]]]):
        pulumi.set(self, "encryption_keys", value)

    @property
    @pulumi.getter(name="timeActivated")
    def time_activated(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the kms key activated.
        """
        return pulumi.get(self, "time_activated")

    @time_activated.setter
    def time_activated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_activated", value)


if not MYPY:
    class AutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKeyArgsDict(TypedDict):
        arn_role: NotRequired[pulumi.Input[str]]
        """
        (Updatable) AWS ARN role
        """
        autonomous_database_provider: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The provider for the Autonomous Database encryption key.
        """
        certificate_directory_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) OKV certificate directory name
        """
        certificate_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) OKV certificate id
        """
        directory_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) OKV wallet directory name
        """
        external_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) AWS external ID
        """
        key_arn: NotRequired[pulumi.Input[str]]
        """
        (Updatable) AWS key ARN
        """
        key_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Azure key name
        """
        kms_key_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        okv_kms_key: NotRequired[pulumi.Input[str]]
        """
        (Updatable) UUID of OKV KMS Key
        """
        okv_uri: NotRequired[pulumi.Input[str]]
        """
        (Updatable) URI of OKV server
        """
        service_endpoint_uri: NotRequired[pulumi.Input[str]]
        """
        (Updatable) AWS key service endpoint URI
        """
        vault_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        vault_uri: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Azure vault URI
        """
elif False:
    AutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousDatabaseEncryptionKeyHistoryEntryEncryptionKeyArgs:
    def __init__(__self__, *,
                 arn_role: Optional[pulumi.Input[str]] = None,
                 autonomous_database_provider: Optional[pulumi.Input[str]] = None,
                 certificate_directory_name: Optional[pulumi.Input[str]] = None,
                 certificate_id: Optional[pulumi.Input[str]] = None,
                 directory_name: Optional[pulumi.Input[str]] = None,
                 external_id: Optional[pulumi.Input[str]] = None,
                 key_arn: Optional[pulumi.Input[str]] = None,
                 key_name: Optional[pulumi.Input[str]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 okv_kms_key: Optional[pulumi.Input[str]] = None,
                 okv_uri: Optional[pulumi.Input[str]] = None,
                 service_endpoint_uri: Optional[pulumi.Input[str]] = None,
                 vault_id: Optional[pulumi.Input[str]] = None,
                 vault_uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] arn_role: (Updatable) AWS ARN role
        :param pulumi.Input[str] autonomous_database_provider: (Updatable) The provider for the Autonomous Database encryption key.
        :param pulumi.Input[str] certificate_directory_name: (Updatable) OKV certificate directory name
        :param pulumi.Input[str] certificate_id: (Updatable) OKV certificate id
        :param pulumi.Input[str] directory_name: (Updatable) OKV wallet directory name
        :param pulumi.Input[str] external_id: (Updatable) AWS external ID
        :param pulumi.Input[str] key_arn: (Updatable) AWS key ARN
        :param pulumi.Input[str] key_name: (Updatable) Azure key name
        :param pulumi.Input[str] kms_key_id: (Updatable) The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param pulumi.Input[str] okv_kms_key: (Updatable) UUID of OKV KMS Key
        :param pulumi.Input[str] okv_uri: (Updatable) URI of OKV server
        :param pulumi.Input[str] service_endpoint_uri: (Updatable) AWS key service endpoint URI
        :param pulumi.Input[str] vault_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        :param pulumi.Input[str] vault_uri: (Updatable) Azure vault URI
        """
        if arn_role is not None:
            pulumi.set(__self__, "arn_role", arn_role)
        if autonomous_database_provider is not None:
            pulumi.set(__self__, "autonomous_database_provider", autonomous_database_provider)
        if certificate_directory_name is not None:
            pulumi.set(__self__, "certificate_directory_name", certificate_directory_name)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if directory_name is not None:
            pulumi.set(__self__, "directory_name", directory_name)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if key_arn is not None:
            pulumi.set(__self__, "key_arn", key_arn)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if okv_kms_key is not None:
            pulumi.set(__self__, "okv_kms_key", okv_kms_key)
        if okv_uri is not None:
            pulumi.set(__self__, "okv_uri", okv_uri)
        if service_endpoint_uri is not None:
            pulumi.set(__self__, "service_endpoint_uri", service_endpoint_uri)
        if vault_id is not None:
            pulumi.set(__self__, "vault_id", vault_id)
        if vault_uri is not None:
            pulumi.set(__self__, "vault_uri", vault_uri)

    @property
    @pulumi.getter(name="arnRole")
    def arn_role(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) AWS ARN role
        """
        return pulumi.get(self, "arn_role")

    @arn_role.setter
    def arn_role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arn_role", value)

    @property
    @pulumi.getter(name="autonomousDatabaseProvider")
    def autonomous_database_provider(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The provider for the Autonomous Database encryption key.
        """
        return pulumi.get(self, "autonomous_database_provider")

    @autonomous_database_provider.setter
    def autonomous_database_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "autonomous_database_provider", value)

    @property
    @pulumi.getter(name="certificateDirectoryName")
    def certificate_directory_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) OKV certificate directory name
        """
        return pulumi.get(self, "certificate_directory_name")

    @certificate_directory_name.setter
    def certificate_directory_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_directory_name", value)

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) OKV certificate id
        """
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_id", value)

    @property
    @pulumi.getter(name="directoryName")
    def directory_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) OKV wallet directory name
        """
        return pulumi.get(self, "directory_name")

    @directory_name.setter
    def directory_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "directory_name", value)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) AWS external ID
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter(name="keyArn")
    def key_arn(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) AWS key ARN
        """
        return pulumi.get(self, "key_arn")

    @key_arn.setter
    def key_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_arn", value)

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Azure key name
        """
        return pulumi.get(self, "key_name")

    @key_name.setter
    def key_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_name", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="okvKmsKey")
    def okv_kms_key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) UUID of OKV KMS Key
        """
        return pulumi.get(self, "okv_kms_key")

    @okv_kms_key.setter
    def okv_kms_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "okv_kms_key", value)

    @property
    @pulumi.getter(name="okvUri")
    def okv_uri(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) URI of OKV server
        """
        return pulumi.get(self, "okv_uri")

    @okv_uri.setter
    def okv_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "okv_uri", value)

    @property
    @pulumi.getter(name="serviceEndpointUri")
    def service_endpoint_uri(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) AWS key service endpoint URI
        """
        return pulumi.get(self, "service_endpoint_uri")

    @service_endpoint_uri.setter
    def service_endpoint_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_endpoint_uri", value)

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        return pulumi.get(self, "vault_id")

    @vault_id.setter
    def vault_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vault_id", value)

    @property
    @pulumi.getter(name="vaultUri")
    def vault_uri(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Azure vault URI
        """
        return pulumi.get(self, "vault_uri")

    @vault_uri.setter
    def vault_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vault_uri", value)


if not MYPY:
    class AutonomousDatabaseKeyHistoryEntryArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        kms_key_version_id: NotRequired[pulumi.Input[str]]
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        """
        time_activated: NotRequired[pulumi.Input[str]]
        """
        The date and time the kms key activated.
        """
        vault_id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
elif False:
    AutonomousDatabaseKeyHistoryEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousDatabaseKeyHistoryEntryArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 kms_key_version_id: Optional[pulumi.Input[str]] = None,
                 time_activated: Optional[pulumi.Input[str]] = None,
                 vault_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param pulumi.Input[str] kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        :param pulumi.Input[str] time_activated: The date and time the kms key activated.
        :param pulumi.Input[str] vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if kms_key_version_id is not None:
            pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        if time_activated is not None:
            pulumi.set(__self__, "time_activated", time_activated)
        if vault_id is not None:
            pulumi.set(__self__, "vault_id", vault_id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        """
        return pulumi.get(self, "kms_key_version_id")

    @kms_key_version_id.setter
    def kms_key_version_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_version_id", value)

    @property
    @pulumi.getter(name="timeActivated")
    def time_activated(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the kms key activated.
        """
        return pulumi.get(self, "time_activated")

    @time_activated.setter
    def time_activated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_activated", value)

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")

    @vault_id.setter
    def vault_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vault_id", value)


if not MYPY:
    class AutonomousDatabaseLocalStandbyDbArgsDict(TypedDict):
        availability_domain: NotRequired[pulumi.Input[str]]
        """
        The availability domain of a local Autonomous Data Guard standby database of an Autonomous Database Serverless instance.
        """
        lag_time_in_seconds: NotRequired[pulumi.Input[int]]
        """
        The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        """
        lifecycle_details: NotRequired[pulumi.Input[str]]
        """
        Additional information about the current lifecycle state.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        The current state of the Autonomous Database.
        """
        time_data_guard_role_changed: NotRequired[pulumi.Input[str]]
        """
        The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        """
        time_disaster_recovery_role_changed: NotRequired[pulumi.Input[str]]
        """
        The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
elif False:
    AutonomousDatabaseLocalStandbyDbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousDatabaseLocalStandbyDbArgs:
    def __init__(__self__, *,
                 availability_domain: Optional[pulumi.Input[str]] = None,
                 lag_time_in_seconds: Optional[pulumi.Input[int]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 time_data_guard_role_changed: Optional[pulumi.Input[str]] = None,
                 time_disaster_recovery_role_changed: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] availability_domain: The availability domain of a local Autonomous Data Guard standby database of an Autonomous Database Serverless instance.
        :param pulumi.Input[int] lag_time_in_seconds: The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        :param pulumi.Input[str] lifecycle_details: Additional information about the current lifecycle state.
        :param pulumi.Input[str] state: The current state of the Autonomous Database.
        :param pulumi.Input[str] time_data_guard_role_changed: The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        :param pulumi.Input[str] time_disaster_recovery_role_changed: The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        if availability_domain is not None:
            pulumi.set(__self__, "availability_domain", availability_domain)
        if lag_time_in_seconds is not None:
            pulumi.set(__self__, "lag_time_in_seconds", lag_time_in_seconds)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_data_guard_role_changed is not None:
            pulumi.set(__self__, "time_data_guard_role_changed", time_data_guard_role_changed)
        if time_disaster_recovery_role_changed is not None:
            pulumi.set(__self__, "time_disaster_recovery_role_changed", time_disaster_recovery_role_changed)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[pulumi.Input[str]]:
        """
        The availability domain of a local Autonomous Data Guard standby database of an Autonomous Database Serverless instance.
        """
        return pulumi.get(self, "availability_domain")

    @availability_domain.setter
    def availability_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_domain", value)

    @property
    @pulumi.getter(name="lagTimeInSeconds")
    def lag_time_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        """
        return pulumi.get(self, "lag_time_in_seconds")

    @lag_time_in_seconds.setter
    def lag_time_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lag_time_in_seconds", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the Autonomous Database.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeDataGuardRoleChanged")
    def time_data_guard_role_changed(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        """
        return pulumi.get(self, "time_data_guard_role_changed")

    @time_data_guard_role_changed.setter
    def time_data_guard_role_changed(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_data_guard_role_changed", value)

    @property
    @pulumi.getter(name="timeDisasterRecoveryRoleChanged")
    def time_disaster_recovery_role_changed(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        return pulumi.get(self, "time_disaster_recovery_role_changed")

    @time_disaster_recovery_role_changed.setter
    def time_disaster_recovery_role_changed(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_disaster_recovery_role_changed", value)


if not MYPY:
    class AutonomousDatabaseLongTermBackupScheduleArgsDict(TypedDict):
        is_disabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates if the long-term backup schedule should be deleted. The default value is `FALSE`.
        """
        repeat_cadence: NotRequired[pulumi.Input[str]]
        """
        The frequency of the long-term backup schedule
        """
        retention_period_in_days: NotRequired[pulumi.Input[int]]
        """
        Retention period, in days, for long-term backups
        """
        time_of_backup: NotRequired[pulumi.Input[str]]
        """
        The timestamp for the long-term backup schedule. For a MONTHLY cadence, months having fewer days than the provided date will have the backup taken on the last day of that month.
        """
elif False:
    AutonomousDatabaseLongTermBackupScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousDatabaseLongTermBackupScheduleArgs:
    def __init__(__self__, *,
                 is_disabled: Optional[pulumi.Input[bool]] = None,
                 repeat_cadence: Optional[pulumi.Input[str]] = None,
                 retention_period_in_days: Optional[pulumi.Input[int]] = None,
                 time_of_backup: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_disabled: Indicates if the long-term backup schedule should be deleted. The default value is `FALSE`.
        :param pulumi.Input[str] repeat_cadence: The frequency of the long-term backup schedule
        :param pulumi.Input[int] retention_period_in_days: Retention period, in days, for long-term backups
        :param pulumi.Input[str] time_of_backup: The timestamp for the long-term backup schedule. For a MONTHLY cadence, months having fewer days than the provided date will have the backup taken on the last day of that month.
        """
        if is_disabled is not None:
            pulumi.set(__self__, "is_disabled", is_disabled)
        if repeat_cadence is not None:
            pulumi.set(__self__, "repeat_cadence", repeat_cadence)
        if retention_period_in_days is not None:
            pulumi.set(__self__, "retention_period_in_days", retention_period_in_days)
        if time_of_backup is not None:
            pulumi.set(__self__, "time_of_backup", time_of_backup)

    @property
    @pulumi.getter(name="isDisabled")
    def is_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if the long-term backup schedule should be deleted. The default value is `FALSE`.
        """
        return pulumi.get(self, "is_disabled")

    @is_disabled.setter
    def is_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_disabled", value)

    @property
    @pulumi.getter(name="repeatCadence")
    def repeat_cadence(self) -> Optional[pulumi.Input[str]]:
        """
        The frequency of the long-term backup schedule
        """
        return pulumi.get(self, "repeat_cadence")

    @repeat_cadence.setter
    def repeat_cadence(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repeat_cadence", value)

    @property
    @pulumi.getter(name="retentionPeriodInDays")
    def retention_period_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        Retention period, in days, for long-term backups
        """
        return pulumi.get(self, "retention_period_in_days")

    @retention_period_in_days.setter
    def retention_period_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_period_in_days", value)

    @property
    @pulumi.getter(name="timeOfBackup")
    def time_of_backup(self) -> Optional[pulumi.Input[str]]:
        """
        The timestamp for the long-term backup schedule. For a MONTHLY cadence, months having fewer days than the provided date will have the backup taken on the last day of that month.
        """
        return pulumi.get(self, "time_of_backup")

    @time_of_backup.setter
    def time_of_backup(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_of_backup", value)


if not MYPY:
    class AutonomousDatabasePublicConnectionUrlArgsDict(TypedDict):
        apex_url: NotRequired[pulumi.Input[str]]
        """
        Oracle Application Express (APEX) URL.
        """
        database_transforms_url: NotRequired[pulumi.Input[str]]
        """
        The URL of the Database Transforms for the Autonomous Database.
        """
        graph_studio_url: NotRequired[pulumi.Input[str]]
        """
        The URL of the Graph Studio for the Autonomous Database.
        """
        machine_learning_notebook_url: NotRequired[pulumi.Input[str]]
        """
        The URL of the Oracle Machine Learning (OML) Notebook for the Autonomous Database.
        """
        machine_learning_user_management_url: NotRequired[pulumi.Input[str]]
        """
        Oracle Machine Learning user management URL.
        """
        mongo_db_url: NotRequired[pulumi.Input[str]]
        """
        The URL of the MongoDB API for the Autonomous Database.
        """
        ords_url: NotRequired[pulumi.Input[str]]
        """
        The Oracle REST Data Services (ORDS) URL of the Web Access for the Autonomous Database.
        """
        sql_dev_web_url: NotRequired[pulumi.Input[str]]
        """
        Oracle SQL Developer Web URL.
        """
elif False:
    AutonomousDatabasePublicConnectionUrlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousDatabasePublicConnectionUrlArgs:
    def __init__(__self__, *,
                 apex_url: Optional[pulumi.Input[str]] = None,
                 database_transforms_url: Optional[pulumi.Input[str]] = None,
                 graph_studio_url: Optional[pulumi.Input[str]] = None,
                 machine_learning_notebook_url: Optional[pulumi.Input[str]] = None,
                 machine_learning_user_management_url: Optional[pulumi.Input[str]] = None,
                 mongo_db_url: Optional[pulumi.Input[str]] = None,
                 ords_url: Optional[pulumi.Input[str]] = None,
                 sql_dev_web_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] apex_url: Oracle Application Express (APEX) URL.
        :param pulumi.Input[str] database_transforms_url: The URL of the Database Transforms for the Autonomous Database.
        :param pulumi.Input[str] graph_studio_url: The URL of the Graph Studio for the Autonomous Database.
        :param pulumi.Input[str] machine_learning_notebook_url: The URL of the Oracle Machine Learning (OML) Notebook for the Autonomous Database.
        :param pulumi.Input[str] machine_learning_user_management_url: Oracle Machine Learning user management URL.
        :param pulumi.Input[str] mongo_db_url: The URL of the MongoDB API for the Autonomous Database.
        :param pulumi.Input[str] ords_url: The Oracle REST Data Services (ORDS) URL of the Web Access for the Autonomous Database.
        :param pulumi.Input[str] sql_dev_web_url: Oracle SQL Developer Web URL.
        """
        if apex_url is not None:
            pulumi.set(__self__, "apex_url", apex_url)
        if database_transforms_url is not None:
            pulumi.set(__self__, "database_transforms_url", database_transforms_url)
        if graph_studio_url is not None:
            pulumi.set(__self__, "graph_studio_url", graph_studio_url)
        if machine_learning_notebook_url is not None:
            pulumi.set(__self__, "machine_learning_notebook_url", machine_learning_notebook_url)
        if machine_learning_user_management_url is not None:
            pulumi.set(__self__, "machine_learning_user_management_url", machine_learning_user_management_url)
        if mongo_db_url is not None:
            pulumi.set(__self__, "mongo_db_url", mongo_db_url)
        if ords_url is not None:
            pulumi.set(__self__, "ords_url", ords_url)
        if sql_dev_web_url is not None:
            pulumi.set(__self__, "sql_dev_web_url", sql_dev_web_url)

    @property
    @pulumi.getter(name="apexUrl")
    def apex_url(self) -> Optional[pulumi.Input[str]]:
        """
        Oracle Application Express (APEX) URL.
        """
        return pulumi.get(self, "apex_url")

    @apex_url.setter
    def apex_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "apex_url", value)

    @property
    @pulumi.getter(name="databaseTransformsUrl")
    def database_transforms_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the Database Transforms for the Autonomous Database.
        """
        return pulumi.get(self, "database_transforms_url")

    @database_transforms_url.setter
    def database_transforms_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_transforms_url", value)

    @property
    @pulumi.getter(name="graphStudioUrl")
    def graph_studio_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the Graph Studio for the Autonomous Database.
        """
        return pulumi.get(self, "graph_studio_url")

    @graph_studio_url.setter
    def graph_studio_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "graph_studio_url", value)

    @property
    @pulumi.getter(name="machineLearningNotebookUrl")
    def machine_learning_notebook_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the Oracle Machine Learning (OML) Notebook for the Autonomous Database.
        """
        return pulumi.get(self, "machine_learning_notebook_url")

    @machine_learning_notebook_url.setter
    def machine_learning_notebook_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "machine_learning_notebook_url", value)

    @property
    @pulumi.getter(name="machineLearningUserManagementUrl")
    def machine_learning_user_management_url(self) -> Optional[pulumi.Input[str]]:
        """
        Oracle Machine Learning user management URL.
        """
        return pulumi.get(self, "machine_learning_user_management_url")

    @machine_learning_user_management_url.setter
    def machine_learning_user_management_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "machine_learning_user_management_url", value)

    @property
    @pulumi.getter(name="mongoDbUrl")
    def mongo_db_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the MongoDB API for the Autonomous Database.
        """
        return pulumi.get(self, "mongo_db_url")

    @mongo_db_url.setter
    def mongo_db_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mongo_db_url", value)

    @property
    @pulumi.getter(name="ordsUrl")
    def ords_url(self) -> Optional[pulumi.Input[str]]:
        """
        The Oracle REST Data Services (ORDS) URL of the Web Access for the Autonomous Database.
        """
        return pulumi.get(self, "ords_url")

    @ords_url.setter
    def ords_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ords_url", value)

    @property
    @pulumi.getter(name="sqlDevWebUrl")
    def sql_dev_web_url(self) -> Optional[pulumi.Input[str]]:
        """
        Oracle SQL Developer Web URL.
        """
        return pulumi.get(self, "sql_dev_web_url")

    @sql_dev_web_url.setter
    def sql_dev_web_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sql_dev_web_url", value)


if not MYPY:
    class AutonomousDatabaseRemoteDisasterRecoveryConfigurationArgsDict(TypedDict):
        disaster_recovery_type: NotRequired[pulumi.Input[str]]
        """
        Indicates the disaster recovery (DR) type of the standby Autonomous Database Serverless instance. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
        """
        is_replicate_automatic_backups: NotRequired[pulumi.Input[bool]]
        """
        If true, 7 days worth of backups are replicated across regions for Cross-Region ADB or Backup-Based DR between Primary and Standby. If false, the backups taken on the Primary are not replicated to the Standby database.
        """
        is_snapshot_standby: NotRequired[pulumi.Input[bool]]
        """
        Indicates if user wants to convert to a snapshot standby. For example, true would set a standby database to snapshot standby database. False would set a snapshot standby database back to regular standby database.
        """
        time_snapshot_standby_enabled_till: NotRequired[pulumi.Input[str]]
        """
        Time and date stored as an RFC 3339 formatted timestamp string. For example, 2022-01-01T12:00:00.000Z would set a limit for the snapshot standby to be converted back to a cross-region standby database.
        """
elif False:
    AutonomousDatabaseRemoteDisasterRecoveryConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousDatabaseRemoteDisasterRecoveryConfigurationArgs:
    def __init__(__self__, *,
                 disaster_recovery_type: Optional[pulumi.Input[str]] = None,
                 is_replicate_automatic_backups: Optional[pulumi.Input[bool]] = None,
                 is_snapshot_standby: Optional[pulumi.Input[bool]] = None,
                 time_snapshot_standby_enabled_till: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] disaster_recovery_type: Indicates the disaster recovery (DR) type of the standby Autonomous Database Serverless instance. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
        :param pulumi.Input[bool] is_replicate_automatic_backups: If true, 7 days worth of backups are replicated across regions for Cross-Region ADB or Backup-Based DR between Primary and Standby. If false, the backups taken on the Primary are not replicated to the Standby database.
        :param pulumi.Input[bool] is_snapshot_standby: Indicates if user wants to convert to a snapshot standby. For example, true would set a standby database to snapshot standby database. False would set a snapshot standby database back to regular standby database.
        :param pulumi.Input[str] time_snapshot_standby_enabled_till: Time and date stored as an RFC 3339 formatted timestamp string. For example, 2022-01-01T12:00:00.000Z would set a limit for the snapshot standby to be converted back to a cross-region standby database.
        """
        if disaster_recovery_type is not None:
            pulumi.set(__self__, "disaster_recovery_type", disaster_recovery_type)
        if is_replicate_automatic_backups is not None:
            pulumi.set(__self__, "is_replicate_automatic_backups", is_replicate_automatic_backups)
        if is_snapshot_standby is not None:
            pulumi.set(__self__, "is_snapshot_standby", is_snapshot_standby)
        if time_snapshot_standby_enabled_till is not None:
            pulumi.set(__self__, "time_snapshot_standby_enabled_till", time_snapshot_standby_enabled_till)

    @property
    @pulumi.getter(name="disasterRecoveryType")
    def disaster_recovery_type(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates the disaster recovery (DR) type of the standby Autonomous Database Serverless instance. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
        """
        return pulumi.get(self, "disaster_recovery_type")

    @disaster_recovery_type.setter
    def disaster_recovery_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disaster_recovery_type", value)

    @property
    @pulumi.getter(name="isReplicateAutomaticBackups")
    def is_replicate_automatic_backups(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, 7 days worth of backups are replicated across regions for Cross-Region ADB or Backup-Based DR between Primary and Standby. If false, the backups taken on the Primary are not replicated to the Standby database.
        """
        return pulumi.get(self, "is_replicate_automatic_backups")

    @is_replicate_automatic_backups.setter
    def is_replicate_automatic_backups(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_replicate_automatic_backups", value)

    @property
    @pulumi.getter(name="isSnapshotStandby")
    def is_snapshot_standby(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if user wants to convert to a snapshot standby. For example, true would set a standby database to snapshot standby database. False would set a snapshot standby database back to regular standby database.
        """
        return pulumi.get(self, "is_snapshot_standby")

    @is_snapshot_standby.setter
    def is_snapshot_standby(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_snapshot_standby", value)

    @property
    @pulumi.getter(name="timeSnapshotStandbyEnabledTill")
    def time_snapshot_standby_enabled_till(self) -> Optional[pulumi.Input[str]]:
        """
        Time and date stored as an RFC 3339 formatted timestamp string. For example, 2022-01-01T12:00:00.000Z would set a limit for the snapshot standby to be converted back to a cross-region standby database.
        """
        return pulumi.get(self, "time_snapshot_standby_enabled_till")

    @time_snapshot_standby_enabled_till.setter
    def time_snapshot_standby_enabled_till(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_snapshot_standby_enabled_till", value)


if not MYPY:
    class AutonomousDatabaseResourcePoolSummaryArgsDict(TypedDict):
        is_disabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Indicates if the resource pool should be deleted for the Autonomous Database.
        """
        pool_size: NotRequired[pulumi.Input[int]]
        """
        (Updatable) Resource pool size.
        """
elif False:
    AutonomousDatabaseResourcePoolSummaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousDatabaseResourcePoolSummaryArgs:
    def __init__(__self__, *,
                 is_disabled: Optional[pulumi.Input[bool]] = None,
                 pool_size: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] is_disabled: (Updatable) Indicates if the resource pool should be deleted for the Autonomous Database.
        :param pulumi.Input[int] pool_size: (Updatable) Resource pool size.
        """
        if is_disabled is not None:
            pulumi.set(__self__, "is_disabled", is_disabled)
        if pool_size is not None:
            pulumi.set(__self__, "pool_size", pool_size)

    @property
    @pulumi.getter(name="isDisabled")
    def is_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Indicates if the resource pool should be deleted for the Autonomous Database.
        """
        return pulumi.get(self, "is_disabled")

    @is_disabled.setter
    def is_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_disabled", value)

    @property
    @pulumi.getter(name="poolSize")
    def pool_size(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Resource pool size.
        """
        return pulumi.get(self, "pool_size")

    @pool_size.setter
    def pool_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pool_size", value)


if not MYPY:
    class AutonomousDatabaseScheduledOperationArgsDict(TypedDict):
        day_of_week: pulumi.Input['AutonomousDatabaseScheduledOperationDayOfWeekArgsDict']
        """
        (Updatable) Day of the week.
        """
        scheduled_start_time: NotRequired[pulumi.Input[str]]
        """
        (Updatable) auto start time. value must be of ISO-8601 format "HH:mm"
        """
        scheduled_stop_time: NotRequired[pulumi.Input[str]]
        """
        (Updatable) auto stop time. value must be of ISO-8601 format "HH:mm"
        """
elif False:
    AutonomousDatabaseScheduledOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousDatabaseScheduledOperationArgs:
    def __init__(__self__, *,
                 day_of_week: pulumi.Input['AutonomousDatabaseScheduledOperationDayOfWeekArgs'],
                 scheduled_start_time: Optional[pulumi.Input[str]] = None,
                 scheduled_stop_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['AutonomousDatabaseScheduledOperationDayOfWeekArgs'] day_of_week: (Updatable) Day of the week.
        :param pulumi.Input[str] scheduled_start_time: (Updatable) auto start time. value must be of ISO-8601 format "HH:mm"
        :param pulumi.Input[str] scheduled_stop_time: (Updatable) auto stop time. value must be of ISO-8601 format "HH:mm"
        """
        pulumi.set(__self__, "day_of_week", day_of_week)
        if scheduled_start_time is not None:
            pulumi.set(__self__, "scheduled_start_time", scheduled_start_time)
        if scheduled_stop_time is not None:
            pulumi.set(__self__, "scheduled_stop_time", scheduled_stop_time)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> pulumi.Input['AutonomousDatabaseScheduledOperationDayOfWeekArgs']:
        """
        (Updatable) Day of the week.
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: pulumi.Input['AutonomousDatabaseScheduledOperationDayOfWeekArgs']):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter(name="scheduledStartTime")
    def scheduled_start_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) auto start time. value must be of ISO-8601 format "HH:mm"
        """
        return pulumi.get(self, "scheduled_start_time")

    @scheduled_start_time.setter
    def scheduled_start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheduled_start_time", value)

    @property
    @pulumi.getter(name="scheduledStopTime")
    def scheduled_stop_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) auto stop time. value must be of ISO-8601 format "HH:mm"
        """
        return pulumi.get(self, "scheduled_stop_time")

    @scheduled_stop_time.setter
    def scheduled_stop_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheduled_stop_time", value)


if not MYPY:
    class AutonomousDatabaseScheduledOperationDayOfWeekArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        (Updatable) Name of the day of the week.
        """
elif False:
    AutonomousDatabaseScheduledOperationDayOfWeekArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousDatabaseScheduledOperationDayOfWeekArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the day of the week.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the day of the week.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AutonomousDatabaseStandbyDbArgsDict(TypedDict):
        availability_domain: NotRequired[pulumi.Input[str]]
        """
        The availability domain of a local Autonomous Data Guard standby database of an Autonomous Database Serverless instance.
        """
        lag_time_in_seconds: NotRequired[pulumi.Input[int]]
        """
        The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        """
        lifecycle_details: NotRequired[pulumi.Input[str]]
        """
        Additional information about the current lifecycle state.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        The current state of the Autonomous Database.
        """
        time_data_guard_role_changed: NotRequired[pulumi.Input[str]]
        """
        The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        """
        time_disaster_recovery_role_changed: NotRequired[pulumi.Input[str]]
        """
        The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
elif False:
    AutonomousDatabaseStandbyDbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousDatabaseStandbyDbArgs:
    def __init__(__self__, *,
                 availability_domain: Optional[pulumi.Input[str]] = None,
                 lag_time_in_seconds: Optional[pulumi.Input[int]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 time_data_guard_role_changed: Optional[pulumi.Input[str]] = None,
                 time_disaster_recovery_role_changed: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] availability_domain: The availability domain of a local Autonomous Data Guard standby database of an Autonomous Database Serverless instance.
        :param pulumi.Input[int] lag_time_in_seconds: The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        :param pulumi.Input[str] lifecycle_details: Additional information about the current lifecycle state.
        :param pulumi.Input[str] state: The current state of the Autonomous Database.
        :param pulumi.Input[str] time_data_guard_role_changed: The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        :param pulumi.Input[str] time_disaster_recovery_role_changed: The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        if availability_domain is not None:
            pulumi.set(__self__, "availability_domain", availability_domain)
        if lag_time_in_seconds is not None:
            pulumi.set(__self__, "lag_time_in_seconds", lag_time_in_seconds)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_data_guard_role_changed is not None:
            pulumi.set(__self__, "time_data_guard_role_changed", time_data_guard_role_changed)
        if time_disaster_recovery_role_changed is not None:
            pulumi.set(__self__, "time_disaster_recovery_role_changed", time_disaster_recovery_role_changed)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[pulumi.Input[str]]:
        """
        The availability domain of a local Autonomous Data Guard standby database of an Autonomous Database Serverless instance.
        """
        return pulumi.get(self, "availability_domain")

    @availability_domain.setter
    def availability_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_domain", value)

    @property
    @pulumi.getter(name="lagTimeInSeconds")
    def lag_time_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        """
        return pulumi.get(self, "lag_time_in_seconds")

    @lag_time_in_seconds.setter
    def lag_time_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lag_time_in_seconds", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the Autonomous Database.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeDataGuardRoleChanged")
    def time_data_guard_role_changed(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        """
        return pulumi.get(self, "time_data_guard_role_changed")

    @time_data_guard_role_changed.setter
    def time_data_guard_role_changed(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_data_guard_role_changed", value)

    @property
    @pulumi.getter(name="timeDisasterRecoveryRoleChanged")
    def time_disaster_recovery_role_changed(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        return pulumi.get(self, "time_disaster_recovery_role_changed")

    @time_disaster_recovery_role_changed.setter
    def time_disaster_recovery_role_changed(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_disaster_recovery_role_changed", value)


if not MYPY:
    class AutonomousExadataInfrastructureMaintenanceWindowArgsDict(TypedDict):
        custom_action_timeout_in_mins: NotRequired[pulumi.Input[int]]
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        days_of_weeks: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekArgsDict']]]]
        """
        Days during the week when maintenance should be performed.
        """
        hours_of_days: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        is_custom_action_timeout_enabled: NotRequired[pulumi.Input[bool]]
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        is_monthly_patching_enabled: NotRequired[pulumi.Input[bool]]
        """
        If true, enables the monthly patching option.
        """
        lead_time_in_weeks: NotRequired[pulumi.Input[int]]
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        months: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowMonthArgsDict']]]]
        """
        Months during the year when maintenance should be performed.
        """
        patching_mode: NotRequired[pulumi.Input[str]]
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        preference: NotRequired[pulumi.Input[str]]
        """
        The maintenance window scheduling preference.
        """
        skip_rus: NotRequired[pulumi.Input[Sequence[pulumi.Input[bool]]]]
        """
        If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        weeks_of_months: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
elif False:
    AutonomousExadataInfrastructureMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousExadataInfrastructureMaintenanceWindowArgs:
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[pulumi.Input[int]] = None,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 is_custom_action_timeout_enabled: Optional[pulumi.Input[bool]] = None,
                 is_monthly_patching_enabled: Optional[pulumi.Input[bool]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowMonthArgs']]]] = None,
                 patching_mode: Optional[pulumi.Input[str]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 skip_rus: Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[int] custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]] days_of_weeks: Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[bool] is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param pulumi.Input[bool] is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param pulumi.Input[int] lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowMonthArgs']]] months: Months during the year when maintenance should be performed.
        :param pulumi.Input[str] patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param pulumi.Input[str] preference: The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[bool]]] skip_rus: If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if skip_rus is not None:
            pulumi.set(__self__, "skip_rus", skip_rus)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[pulumi.Input[int]]:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @custom_action_timeout_in_mins.setter
    def custom_action_timeout_in_mins(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_action_timeout_in_mins", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]]]:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @is_custom_action_timeout_enabled.setter
    def is_custom_action_timeout_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom_action_timeout_enabled", value)

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @is_monthly_patching_enabled.setter
    def is_monthly_patching_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monthly_patching_enabled", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowMonthArgs']]]]:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @patching_mode.setter
    def patching_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patching_mode", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]]:
        """
        If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        return pulumi.get(self, "skip_rus")

    @skip_rus.setter
    def skip_rus(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]]):
        pulumi.set(self, "skip_rus", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


if not MYPY:
    class AutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the month of the year.
        """
elif False:
    AutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AutonomousExadataInfrastructureMaintenanceWindowDetailsArgsDict(TypedDict):
        custom_action_timeout_in_mins: NotRequired[pulumi.Input[int]]
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        days_of_weeks: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeekArgsDict']]]]
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        hours_of_days: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        is_custom_action_timeout_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        is_monthly_patching_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) If true, enables the monthly patching option.
        """
        lead_time_in_weeks: NotRequired[pulumi.Input[int]]
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        months: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowDetailsMonthArgsDict']]]]
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        patching_mode: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        preference: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The maintenance window scheduling preference.
        """
        skip_rus: NotRequired[pulumi.Input[Sequence[pulumi.Input[bool]]]]
        """
        (Updatable) If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        weeks_of_months: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
elif False:
    AutonomousExadataInfrastructureMaintenanceWindowDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousExadataInfrastructureMaintenanceWindowDetailsArgs:
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[pulumi.Input[int]] = None,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 is_custom_action_timeout_enabled: Optional[pulumi.Input[bool]] = None,
                 is_monthly_patching_enabled: Optional[pulumi.Input[bool]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowDetailsMonthArgs']]]] = None,
                 patching_mode: Optional[pulumi.Input[str]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 skip_rus: Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[int] custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeekArgs']]] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[bool] is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param pulumi.Input[bool] is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param pulumi.Input[int] lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowDetailsMonthArgs']]] months: (Updatable) Months during the year when maintenance should be performed.
        :param pulumi.Input[str] patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param pulumi.Input[str] preference: (Updatable) The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[bool]]] skip_rus: (Updatable) If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if skip_rus is not None:
            pulumi.set(__self__, "skip_rus", skip_rus)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @custom_action_timeout_in_mins.setter
    def custom_action_timeout_in_mins(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_action_timeout_in_mins", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeekArgs']]]]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @is_custom_action_timeout_enabled.setter
    def is_custom_action_timeout_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom_action_timeout_enabled", value)

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @is_monthly_patching_enabled.setter
    def is_monthly_patching_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monthly_patching_enabled", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowDetailsMonthArgs']]]]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowDetailsMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @patching_mode.setter
    def patching_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patching_mode", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]]:
        """
        (Updatable) If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        return pulumi.get(self, "skip_rus")

    @skip_rus.setter
    def skip_rus(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]]):
        pulumi.set(self, "skip_rus", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


if not MYPY:
    class AutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeekArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        (Updatable) Name of the day of the week.
        """
elif False:
    AutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeekArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the day of the week.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the day of the week.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AutonomousExadataInfrastructureMaintenanceWindowDetailsMonthArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        (Updatable) Name of the month of the year.
        """
elif False:
    AutonomousExadataInfrastructureMaintenanceWindowDetailsMonthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousExadataInfrastructureMaintenanceWindowDetailsMonthArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AutonomousExadataInfrastructureMaintenanceWindowMonthArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the month of the year.
        """
elif False:
    AutonomousExadataInfrastructureMaintenanceWindowMonthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousExadataInfrastructureMaintenanceWindowMonthArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AutonomousVmClusterMaintenanceWindowArgsDict(TypedDict):
        custom_action_timeout_in_mins: NotRequired[pulumi.Input[int]]
        days_of_weeks: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowDaysOfWeekArgsDict']]]]
        """
        Days during the week when maintenance should be performed.
        """
        hours_of_days: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        is_custom_action_timeout_enabled: NotRequired[pulumi.Input[bool]]
        is_monthly_patching_enabled: NotRequired[pulumi.Input[bool]]
        lead_time_in_weeks: NotRequired[pulumi.Input[int]]
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        months: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowMonthArgsDict']]]]
        """
        Months during the year when maintenance should be performed.
        """
        patching_mode: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        preference: NotRequired[pulumi.Input[str]]
        """
        The maintenance window scheduling preference.
        """
        skip_rus: NotRequired[pulumi.Input[Sequence[pulumi.Input[bool]]]]
        """
        If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        weeks_of_months: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
elif False:
    AutonomousVmClusterMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousVmClusterMaintenanceWindowArgs:
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[pulumi.Input[int]] = None,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 is_custom_action_timeout_enabled: Optional[pulumi.Input[bool]] = None,
                 is_monthly_patching_enabled: Optional[pulumi.Input[bool]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowMonthArgs']]]] = None,
                 patching_mode: Optional[pulumi.Input[str]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 skip_rus: Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowDaysOfWeekArgs']]] days_of_weeks: Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[int] lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowMonthArgs']]] months: Months during the year when maintenance should be performed.
        :param pulumi.Input[str] patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param pulumi.Input[str] preference: The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[bool]]] skip_rus: If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if skip_rus is not None:
            pulumi.set(__self__, "skip_rus", skip_rus)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @custom_action_timeout_in_mins.setter
    def custom_action_timeout_in_mins(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_action_timeout_in_mins", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowDaysOfWeekArgs']]]]:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @is_custom_action_timeout_enabled.setter
    def is_custom_action_timeout_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom_action_timeout_enabled", value)

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_monthly_patching_enabled")

    @is_monthly_patching_enabled.setter
    def is_monthly_patching_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monthly_patching_enabled", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowMonthArgs']]]]:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @patching_mode.setter
    def patching_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patching_mode", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]]:
        """
        If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        return pulumi.get(self, "skip_rus")

    @skip_rus.setter
    def skip_rus(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]]):
        pulumi.set(self, "skip_rus", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


if not MYPY:
    class AutonomousVmClusterMaintenanceWindowDaysOfWeekArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the month of the year.
        """
elif False:
    AutonomousVmClusterMaintenanceWindowDaysOfWeekArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousVmClusterMaintenanceWindowDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AutonomousVmClusterMaintenanceWindowDetailArgsDict(TypedDict):
        custom_action_timeout_in_mins: NotRequired[pulumi.Input[int]]
        days_of_weeks: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowDetailDaysOfWeekArgsDict']]]]
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        hours_of_days: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        is_custom_action_timeout_enabled: NotRequired[pulumi.Input[bool]]
        is_monthly_patching_enabled: NotRequired[pulumi.Input[bool]]
        lead_time_in_weeks: NotRequired[pulumi.Input[int]]
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        months: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowDetailMonthArgsDict']]]]
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        patching_mode: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        preference: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The maintenance window scheduling preference.
        """
        skip_rus: NotRequired[pulumi.Input[Sequence[pulumi.Input[bool]]]]
        """
        (Updatable) If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        weeks_of_months: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
elif False:
    AutonomousVmClusterMaintenanceWindowDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousVmClusterMaintenanceWindowDetailArgs:
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[pulumi.Input[int]] = None,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowDetailDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 is_custom_action_timeout_enabled: Optional[pulumi.Input[bool]] = None,
                 is_monthly_patching_enabled: Optional[pulumi.Input[bool]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowDetailMonthArgs']]]] = None,
                 patching_mode: Optional[pulumi.Input[str]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 skip_rus: Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowDetailDaysOfWeekArgs']]] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[int] lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowDetailMonthArgs']]] months: (Updatable) Months during the year when maintenance should be performed.
        :param pulumi.Input[str] patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param pulumi.Input[str] preference: (Updatable) The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[bool]]] skip_rus: (Updatable) If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if skip_rus is not None:
            pulumi.set(__self__, "skip_rus", skip_rus)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @custom_action_timeout_in_mins.setter
    def custom_action_timeout_in_mins(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_action_timeout_in_mins", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowDetailDaysOfWeekArgs']]]]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowDetailDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @is_custom_action_timeout_enabled.setter
    def is_custom_action_timeout_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom_action_timeout_enabled", value)

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_monthly_patching_enabled")

    @is_monthly_patching_enabled.setter
    def is_monthly_patching_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monthly_patching_enabled", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowDetailMonthArgs']]]]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowDetailMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @patching_mode.setter
    def patching_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patching_mode", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]]:
        """
        (Updatable) If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        return pulumi.get(self, "skip_rus")

    @skip_rus.setter
    def skip_rus(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]]):
        pulumi.set(self, "skip_rus", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


if not MYPY:
    class AutonomousVmClusterMaintenanceWindowDetailDaysOfWeekArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        (Updatable) Name of the day of the week.
        """
elif False:
    AutonomousVmClusterMaintenanceWindowDetailDaysOfWeekArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousVmClusterMaintenanceWindowDetailDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the day of the week.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the day of the week.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AutonomousVmClusterMaintenanceWindowDetailMonthArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        (Updatable) Name of the month of the year.
        """
elif False:
    AutonomousVmClusterMaintenanceWindowDetailMonthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousVmClusterMaintenanceWindowDetailMonthArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AutonomousVmClusterMaintenanceWindowMonthArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the month of the year.
        """
elif False:
    AutonomousVmClusterMaintenanceWindowMonthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutonomousVmClusterMaintenanceWindowMonthArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class BackupDestinationAssociatedDatabaseArgsDict(TypedDict):
        db_name: NotRequired[pulumi.Input[str]]
        """
        The display name of the database that is associated with the backup destination.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
elif False:
    BackupDestinationAssociatedDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupDestinationAssociatedDatabaseArgs:
    def __init__(__self__, *,
                 db_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] db_name: The display name of the database that is associated with the backup destination.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[pulumi.Input[str]]:
        """
        The display name of the database that is associated with the backup destination.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class BackupDestinationMountTypeDetailsArgsDict(TypedDict):
        mount_type: pulumi.Input[str]
        """
        Mount type for backup destination.
        """
        local_mount_point_path: NotRequired[pulumi.Input[str]]
        """
        The local directory path on each VM cluster node where the NFS server location is mounted. The local directory path and the NFS server location must each be the same across all of the VM cluster nodes. Ensure that the NFS mount is maintained continuously on all of the VM cluster nodes.
        """
        nfs_server_export: NotRequired[pulumi.Input[str]]
        """
        Specifies the directory on which to mount the file system
        """
        nfs_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        IP addresses for NFS Auto mount.
        """
elif False:
    BackupDestinationMountTypeDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupDestinationMountTypeDetailsArgs:
    def __init__(__self__, *,
                 mount_type: pulumi.Input[str],
                 local_mount_point_path: Optional[pulumi.Input[str]] = None,
                 nfs_server_export: Optional[pulumi.Input[str]] = None,
                 nfs_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] mount_type: Mount type for backup destination.
        :param pulumi.Input[str] local_mount_point_path: The local directory path on each VM cluster node where the NFS server location is mounted. The local directory path and the NFS server location must each be the same across all of the VM cluster nodes. Ensure that the NFS mount is maintained continuously on all of the VM cluster nodes.
        :param pulumi.Input[str] nfs_server_export: Specifies the directory on which to mount the file system
        :param pulumi.Input[Sequence[pulumi.Input[str]]] nfs_servers: IP addresses for NFS Auto mount.
        """
        pulumi.set(__self__, "mount_type", mount_type)
        if local_mount_point_path is not None:
            pulumi.set(__self__, "local_mount_point_path", local_mount_point_path)
        if nfs_server_export is not None:
            pulumi.set(__self__, "nfs_server_export", nfs_server_export)
        if nfs_servers is not None:
            pulumi.set(__self__, "nfs_servers", nfs_servers)

    @property
    @pulumi.getter(name="mountType")
    def mount_type(self) -> pulumi.Input[str]:
        """
        Mount type for backup destination.
        """
        return pulumi.get(self, "mount_type")

    @mount_type.setter
    def mount_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "mount_type", value)

    @property
    @pulumi.getter(name="localMountPointPath")
    def local_mount_point_path(self) -> Optional[pulumi.Input[str]]:
        """
        The local directory path on each VM cluster node where the NFS server location is mounted. The local directory path and the NFS server location must each be the same across all of the VM cluster nodes. Ensure that the NFS mount is maintained continuously on all of the VM cluster nodes.
        """
        return pulumi.get(self, "local_mount_point_path")

    @local_mount_point_path.setter
    def local_mount_point_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "local_mount_point_path", value)

    @property
    @pulumi.getter(name="nfsServerExport")
    def nfs_server_export(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the directory on which to mount the file system
        """
        return pulumi.get(self, "nfs_server_export")

    @nfs_server_export.setter
    def nfs_server_export(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nfs_server_export", value)

    @property
    @pulumi.getter(name="nfsServers")
    def nfs_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        IP addresses for NFS Auto mount.
        """
        return pulumi.get(self, "nfs_servers")

    @nfs_servers.setter
    def nfs_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "nfs_servers", value)


if not MYPY:
    class CloudAutonomousVmClusterMaintenanceWindowArgsDict(TypedDict):
        custom_action_timeout_in_mins: NotRequired[pulumi.Input[int]]
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        days_of_weeks: NotRequired[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgsDict']]]]
        """
        Days during the week when maintenance should be performed.
        """
        hours_of_days: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        is_custom_action_timeout_enabled: NotRequired[pulumi.Input[bool]]
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        is_monthly_patching_enabled: NotRequired[pulumi.Input[bool]]
        """
        If true, enables the monthly patching option.
        """
        lead_time_in_weeks: NotRequired[pulumi.Input[int]]
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        months: NotRequired[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowMonthArgsDict']]]]
        """
        Months during the year when maintenance should be performed.
        """
        patching_mode: NotRequired[pulumi.Input[str]]
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        preference: NotRequired[pulumi.Input[str]]
        """
        The maintenance window scheduling preference.
        """
        skip_rus: NotRequired[pulumi.Input[Sequence[pulumi.Input[bool]]]]
        """
        If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        weeks_of_months: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
elif False:
    CloudAutonomousVmClusterMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAutonomousVmClusterMaintenanceWindowArgs:
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[pulumi.Input[int]] = None,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 is_custom_action_timeout_enabled: Optional[pulumi.Input[bool]] = None,
                 is_monthly_patching_enabled: Optional[pulumi.Input[bool]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowMonthArgs']]]] = None,
                 patching_mode: Optional[pulumi.Input[str]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 skip_rus: Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[int] custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgs']]] days_of_weeks: Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[bool] is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param pulumi.Input[bool] is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param pulumi.Input[int] lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowMonthArgs']]] months: Months during the year when maintenance should be performed.
        :param pulumi.Input[str] patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param pulumi.Input[str] preference: The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[bool]]] skip_rus: If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if skip_rus is not None:
            pulumi.set(__self__, "skip_rus", skip_rus)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[pulumi.Input[int]]:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @custom_action_timeout_in_mins.setter
    def custom_action_timeout_in_mins(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_action_timeout_in_mins", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgs']]]]:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @is_custom_action_timeout_enabled.setter
    def is_custom_action_timeout_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom_action_timeout_enabled", value)

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @is_monthly_patching_enabled.setter
    def is_monthly_patching_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monthly_patching_enabled", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowMonthArgs']]]]:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @patching_mode.setter
    def patching_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patching_mode", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]]:
        """
        If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        return pulumi.get(self, "skip_rus")

    @skip_rus.setter
    def skip_rus(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]]):
        pulumi.set(self, "skip_rus", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


if not MYPY:
    class CloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the month of the year.
        """
elif False:
    CloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CloudAutonomousVmClusterMaintenanceWindowDetailsArgsDict(TypedDict):
        custom_action_timeout_in_mins: NotRequired[pulumi.Input[int]]
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        days_of_weeks: NotRequired[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDetailsDaysOfWeekArgsDict']]]]
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        hours_of_days: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        is_custom_action_timeout_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        is_monthly_patching_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) If true, enables the monthly patching option.
        """
        lead_time_in_weeks: NotRequired[pulumi.Input[int]]
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        months: NotRequired[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDetailsMonthArgsDict']]]]
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        patching_mode: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        preference: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The maintenance window scheduling preference.
        """
        skip_rus: NotRequired[pulumi.Input[Sequence[pulumi.Input[bool]]]]
        """
        (Updatable) If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        weeks_of_months: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
elif False:
    CloudAutonomousVmClusterMaintenanceWindowDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAutonomousVmClusterMaintenanceWindowDetailsArgs:
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[pulumi.Input[int]] = None,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDetailsDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 is_custom_action_timeout_enabled: Optional[pulumi.Input[bool]] = None,
                 is_monthly_patching_enabled: Optional[pulumi.Input[bool]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDetailsMonthArgs']]]] = None,
                 patching_mode: Optional[pulumi.Input[str]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 skip_rus: Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[int] custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDetailsDaysOfWeekArgs']]] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[bool] is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param pulumi.Input[bool] is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param pulumi.Input[int] lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDetailsMonthArgs']]] months: (Updatable) Months during the year when maintenance should be performed.
        :param pulumi.Input[str] patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param pulumi.Input[str] preference: (Updatable) The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[bool]]] skip_rus: (Updatable) If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if skip_rus is not None:
            pulumi.set(__self__, "skip_rus", skip_rus)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @custom_action_timeout_in_mins.setter
    def custom_action_timeout_in_mins(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_action_timeout_in_mins", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDetailsDaysOfWeekArgs']]]]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDetailsDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @is_custom_action_timeout_enabled.setter
    def is_custom_action_timeout_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom_action_timeout_enabled", value)

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @is_monthly_patching_enabled.setter
    def is_monthly_patching_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monthly_patching_enabled", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDetailsMonthArgs']]]]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDetailsMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @patching_mode.setter
    def patching_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patching_mode", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]]:
        """
        (Updatable) If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        return pulumi.get(self, "skip_rus")

    @skip_rus.setter
    def skip_rus(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]]):
        pulumi.set(self, "skip_rus", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


if not MYPY:
    class CloudAutonomousVmClusterMaintenanceWindowDetailsDaysOfWeekArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        (Updatable) Name of the day of the week.
        """
elif False:
    CloudAutonomousVmClusterMaintenanceWindowDetailsDaysOfWeekArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAutonomousVmClusterMaintenanceWindowDetailsDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the day of the week.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the day of the week.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CloudAutonomousVmClusterMaintenanceWindowDetailsMonthArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        (Updatable) Name of the month of the year.
        """
elif False:
    CloudAutonomousVmClusterMaintenanceWindowDetailsMonthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAutonomousVmClusterMaintenanceWindowDetailsMonthArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CloudAutonomousVmClusterMaintenanceWindowMonthArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the month of the year.
        """
elif False:
    CloudAutonomousVmClusterMaintenanceWindowMonthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAutonomousVmClusterMaintenanceWindowMonthArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CloudDatabaseManagementCredentialdetailsArgsDict(TypedDict):
        password_secret_id: pulumi.Input[str]
        """
        Specific database username's password [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        user_name: pulumi.Input[str]
        """
        Database username
        """
elif False:
    CloudDatabaseManagementCredentialdetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudDatabaseManagementCredentialdetailsArgs:
    def __init__(__self__, *,
                 password_secret_id: pulumi.Input[str],
                 user_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password_secret_id: Specific database username's password [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input[str] user_name: Database username
        """
        pulumi.set(__self__, "password_secret_id", password_secret_id)
        pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="passwordSecretId")
    def password_secret_id(self) -> pulumi.Input[str]:
        """
        Specific database username's password [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "password_secret_id")

    @password_secret_id.setter
    def password_secret_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "password_secret_id", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> pulumi.Input[str]:
        """
        Database username
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class CloudExadataInfrastructureCustomerContactArgsDict(TypedDict):
        email: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
elif False:
    CloudExadataInfrastructureCustomerContactArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudExadataInfrastructureCustomerContactArgs:
    def __init__(__self__, *,
                 email: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] email: (Updatable) The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        if email is not None:
            pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)


if not MYPY:
    class CloudExadataInfrastructureDefinedFileSystemConfigurationArgsDict(TypedDict):
        is_backup_partition: NotRequired[pulumi.Input[bool]]
        """
        If true, the file system is used to create a backup prior to Exadata VM OS update.
        """
        is_resizable: NotRequired[pulumi.Input[bool]]
        """
        If true, the file system resize is allowed for the Exadata Infrastructure cluster. If false, the file system resize is not allowed.
        """
        min_size_gb: NotRequired[pulumi.Input[int]]
        """
        The minimum size of file system.
        """
        mount_point: NotRequired[pulumi.Input[str]]
        """
        The mount point of file system.
        """
elif False:
    CloudExadataInfrastructureDefinedFileSystemConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudExadataInfrastructureDefinedFileSystemConfigurationArgs:
    def __init__(__self__, *,
                 is_backup_partition: Optional[pulumi.Input[bool]] = None,
                 is_resizable: Optional[pulumi.Input[bool]] = None,
                 min_size_gb: Optional[pulumi.Input[int]] = None,
                 mount_point: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_backup_partition: If true, the file system is used to create a backup prior to Exadata VM OS update.
        :param pulumi.Input[bool] is_resizable: If true, the file system resize is allowed for the Exadata Infrastructure cluster. If false, the file system resize is not allowed.
        :param pulumi.Input[int] min_size_gb: The minimum size of file system.
        :param pulumi.Input[str] mount_point: The mount point of file system.
        """
        if is_backup_partition is not None:
            pulumi.set(__self__, "is_backup_partition", is_backup_partition)
        if is_resizable is not None:
            pulumi.set(__self__, "is_resizable", is_resizable)
        if min_size_gb is not None:
            pulumi.set(__self__, "min_size_gb", min_size_gb)
        if mount_point is not None:
            pulumi.set(__self__, "mount_point", mount_point)

    @property
    @pulumi.getter(name="isBackupPartition")
    def is_backup_partition(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the file system is used to create a backup prior to Exadata VM OS update.
        """
        return pulumi.get(self, "is_backup_partition")

    @is_backup_partition.setter
    def is_backup_partition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_backup_partition", value)

    @property
    @pulumi.getter(name="isResizable")
    def is_resizable(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the file system resize is allowed for the Exadata Infrastructure cluster. If false, the file system resize is not allowed.
        """
        return pulumi.get(self, "is_resizable")

    @is_resizable.setter
    def is_resizable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_resizable", value)

    @property
    @pulumi.getter(name="minSizeGb")
    def min_size_gb(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum size of file system.
        """
        return pulumi.get(self, "min_size_gb")

    @min_size_gb.setter
    def min_size_gb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_size_gb", value)

    @property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> Optional[pulumi.Input[str]]:
        """
        The mount point of file system.
        """
        return pulumi.get(self, "mount_point")

    @mount_point.setter
    def mount_point(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_point", value)


if not MYPY:
    class CloudExadataInfrastructureMaintenanceWindowArgsDict(TypedDict):
        custom_action_timeout_in_mins: NotRequired[pulumi.Input[int]]
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        days_of_weeks: NotRequired[pulumi.Input[Sequence[pulumi.Input['CloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgsDict']]]]
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        hours_of_days: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        is_custom_action_timeout_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        is_monthly_patching_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) If true, enables the monthly patching option.
        """
        lead_time_in_weeks: NotRequired[pulumi.Input[int]]
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        months: NotRequired[pulumi.Input[Sequence[pulumi.Input['CloudExadataInfrastructureMaintenanceWindowMonthArgsDict']]]]
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        patching_mode: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        preference: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The maintenance window scheduling preference.
        """
        skip_rus: NotRequired[pulumi.Input[Sequence[pulumi.Input[bool]]]]
        """
        (Updatable) If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        weeks_of_months: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
elif False:
    CloudExadataInfrastructureMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudExadataInfrastructureMaintenanceWindowArgs:
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[pulumi.Input[int]] = None,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['CloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 is_custom_action_timeout_enabled: Optional[pulumi.Input[bool]] = None,
                 is_monthly_patching_enabled: Optional[pulumi.Input[bool]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['CloudExadataInfrastructureMaintenanceWindowMonthArgs']]]] = None,
                 patching_mode: Optional[pulumi.Input[str]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 skip_rus: Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[int] custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param pulumi.Input[Sequence[pulumi.Input['CloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[bool] is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param pulumi.Input[bool] is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param pulumi.Input[int] lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['CloudExadataInfrastructureMaintenanceWindowMonthArgs']]] months: (Updatable) Months during the year when maintenance should be performed.
        :param pulumi.Input[str] patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param pulumi.Input[str] preference: (Updatable) The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[bool]]] skip_rus: (Updatable) If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if skip_rus is not None:
            pulumi.set(__self__, "skip_rus", skip_rus)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @custom_action_timeout_in_mins.setter
    def custom_action_timeout_in_mins(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_action_timeout_in_mins", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]]]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @is_custom_action_timeout_enabled.setter
    def is_custom_action_timeout_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom_action_timeout_enabled", value)

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @is_monthly_patching_enabled.setter
    def is_monthly_patching_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monthly_patching_enabled", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudExadataInfrastructureMaintenanceWindowMonthArgs']]]]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudExadataInfrastructureMaintenanceWindowMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @patching_mode.setter
    def patching_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patching_mode", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]]:
        """
        (Updatable) If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        return pulumi.get(self, "skip_rus")

    @skip_rus.setter
    def skip_rus(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]]):
        pulumi.set(self, "skip_rus", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


if not MYPY:
    class CloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        (Updatable) Name of the day of the week.
        """
elif False:
    CloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the day of the week.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the day of the week.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CloudExadataInfrastructureMaintenanceWindowMonthArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        (Updatable) Name of the month of the year.
        """
elif False:
    CloudExadataInfrastructureMaintenanceWindowMonthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudExadataInfrastructureMaintenanceWindowMonthArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CloudVmClusterCloudAutomationUpdateDetailsArgsDict(TypedDict):
        apply_update_time_preference: NotRequired[pulumi.Input['CloudVmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreferenceArgsDict']]
        """
        (Updatable) Configure the time slot for applying VM cloud automation software updates to the cluster. When nothing is selected, the default time slot is 12 AM to 2 AM UTC. Any 2-hour slot is available starting at 12 AM.
        """
        freeze_period: NotRequired[pulumi.Input['CloudVmClusterCloudAutomationUpdateDetailsFreezePeriodArgsDict']]
        """
        (Updatable) Enables a freeze period for the VM cluster prohibiting the VMs from getting cloud automation software updates during critical business cycles. Freeze period start date. Starts at 12:00 AM UTC on the selected date and ends at 11:59:59 PM UTC on the selected date. Validates to ensure the freeze period does not exceed 45 days.
        """
        is_early_adoption_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Annotates whether the cluster should be part of early access to apply VM cloud automation software updates. Those clusters annotated as early access will download the software bits for cloud automation in the first week after the update is available, while other clusters will have to wait until the following week.
        """
        is_freeze_period_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Specifies if the freeze period is enabled for the VM cluster to prevent the VMs from receiving cloud automation software updates during critical business cycles. Freeze period starts at 12:00 AM UTC and ends at 11:59:59 PM UTC on the selected date. Ensure that the freezing period does not exceed 45 days.
        """
elif False:
    CloudVmClusterCloudAutomationUpdateDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudVmClusterCloudAutomationUpdateDetailsArgs:
    def __init__(__self__, *,
                 apply_update_time_preference: Optional[pulumi.Input['CloudVmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreferenceArgs']] = None,
                 freeze_period: Optional[pulumi.Input['CloudVmClusterCloudAutomationUpdateDetailsFreezePeriodArgs']] = None,
                 is_early_adoption_enabled: Optional[pulumi.Input[bool]] = None,
                 is_freeze_period_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['CloudVmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreferenceArgs'] apply_update_time_preference: (Updatable) Configure the time slot for applying VM cloud automation software updates to the cluster. When nothing is selected, the default time slot is 12 AM to 2 AM UTC. Any 2-hour slot is available starting at 12 AM.
        :param pulumi.Input['CloudVmClusterCloudAutomationUpdateDetailsFreezePeriodArgs'] freeze_period: (Updatable) Enables a freeze period for the VM cluster prohibiting the VMs from getting cloud automation software updates during critical business cycles. Freeze period start date. Starts at 12:00 AM UTC on the selected date and ends at 11:59:59 PM UTC on the selected date. Validates to ensure the freeze period does not exceed 45 days.
        :param pulumi.Input[bool] is_early_adoption_enabled: (Updatable) Annotates whether the cluster should be part of early access to apply VM cloud automation software updates. Those clusters annotated as early access will download the software bits for cloud automation in the first week after the update is available, while other clusters will have to wait until the following week.
        :param pulumi.Input[bool] is_freeze_period_enabled: (Updatable) Specifies if the freeze period is enabled for the VM cluster to prevent the VMs from receiving cloud automation software updates during critical business cycles. Freeze period starts at 12:00 AM UTC and ends at 11:59:59 PM UTC on the selected date. Ensure that the freezing period does not exceed 45 days.
        """
        if apply_update_time_preference is not None:
            pulumi.set(__self__, "apply_update_time_preference", apply_update_time_preference)
        if freeze_period is not None:
            pulumi.set(__self__, "freeze_period", freeze_period)
        if is_early_adoption_enabled is not None:
            pulumi.set(__self__, "is_early_adoption_enabled", is_early_adoption_enabled)
        if is_freeze_period_enabled is not None:
            pulumi.set(__self__, "is_freeze_period_enabled", is_freeze_period_enabled)

    @property
    @pulumi.getter(name="applyUpdateTimePreference")
    def apply_update_time_preference(self) -> Optional[pulumi.Input['CloudVmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreferenceArgs']]:
        """
        (Updatable) Configure the time slot for applying VM cloud automation software updates to the cluster. When nothing is selected, the default time slot is 12 AM to 2 AM UTC. Any 2-hour slot is available starting at 12 AM.
        """
        return pulumi.get(self, "apply_update_time_preference")

    @apply_update_time_preference.setter
    def apply_update_time_preference(self, value: Optional[pulumi.Input['CloudVmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreferenceArgs']]):
        pulumi.set(self, "apply_update_time_preference", value)

    @property
    @pulumi.getter(name="freezePeriod")
    def freeze_period(self) -> Optional[pulumi.Input['CloudVmClusterCloudAutomationUpdateDetailsFreezePeriodArgs']]:
        """
        (Updatable) Enables a freeze period for the VM cluster prohibiting the VMs from getting cloud automation software updates during critical business cycles. Freeze period start date. Starts at 12:00 AM UTC on the selected date and ends at 11:59:59 PM UTC on the selected date. Validates to ensure the freeze period does not exceed 45 days.
        """
        return pulumi.get(self, "freeze_period")

    @freeze_period.setter
    def freeze_period(self, value: Optional[pulumi.Input['CloudVmClusterCloudAutomationUpdateDetailsFreezePeriodArgs']]):
        pulumi.set(self, "freeze_period", value)

    @property
    @pulumi.getter(name="isEarlyAdoptionEnabled")
    def is_early_adoption_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Annotates whether the cluster should be part of early access to apply VM cloud automation software updates. Those clusters annotated as early access will download the software bits for cloud automation in the first week after the update is available, while other clusters will have to wait until the following week.
        """
        return pulumi.get(self, "is_early_adoption_enabled")

    @is_early_adoption_enabled.setter
    def is_early_adoption_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_early_adoption_enabled", value)

    @property
    @pulumi.getter(name="isFreezePeriodEnabled")
    def is_freeze_period_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Specifies if the freeze period is enabled for the VM cluster to prevent the VMs from receiving cloud automation software updates during critical business cycles. Freeze period starts at 12:00 AM UTC and ends at 11:59:59 PM UTC on the selected date. Ensure that the freezing period does not exceed 45 days.
        """
        return pulumi.get(self, "is_freeze_period_enabled")

    @is_freeze_period_enabled.setter
    def is_freeze_period_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_freeze_period_enabled", value)


if not MYPY:
    class CloudVmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreferenceArgsDict(TypedDict):
        apply_update_preferred_end_time: NotRequired[pulumi.Input[str]]
        """
        (Updatable) End time for polling VM cloud automation software updates for the cluster. If the endTime is not specified, 2 AM UTC is used by default.
        """
        apply_update_preferred_start_time: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Start time for polling VM cloud automation software updates for the cluster. If the startTime is not specified, 12 AM UTC is used by default.
        """
elif False:
    CloudVmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudVmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreferenceArgs:
    def __init__(__self__, *,
                 apply_update_preferred_end_time: Optional[pulumi.Input[str]] = None,
                 apply_update_preferred_start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] apply_update_preferred_end_time: (Updatable) End time for polling VM cloud automation software updates for the cluster. If the endTime is not specified, 2 AM UTC is used by default.
        :param pulumi.Input[str] apply_update_preferred_start_time: (Updatable) Start time for polling VM cloud automation software updates for the cluster. If the startTime is not specified, 12 AM UTC is used by default.
        """
        if apply_update_preferred_end_time is not None:
            pulumi.set(__self__, "apply_update_preferred_end_time", apply_update_preferred_end_time)
        if apply_update_preferred_start_time is not None:
            pulumi.set(__self__, "apply_update_preferred_start_time", apply_update_preferred_start_time)

    @property
    @pulumi.getter(name="applyUpdatePreferredEndTime")
    def apply_update_preferred_end_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) End time for polling VM cloud automation software updates for the cluster. If the endTime is not specified, 2 AM UTC is used by default.
        """
        return pulumi.get(self, "apply_update_preferred_end_time")

    @apply_update_preferred_end_time.setter
    def apply_update_preferred_end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "apply_update_preferred_end_time", value)

    @property
    @pulumi.getter(name="applyUpdatePreferredStartTime")
    def apply_update_preferred_start_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Start time for polling VM cloud automation software updates for the cluster. If the startTime is not specified, 12 AM UTC is used by default.
        """
        return pulumi.get(self, "apply_update_preferred_start_time")

    @apply_update_preferred_start_time.setter
    def apply_update_preferred_start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "apply_update_preferred_start_time", value)


if not MYPY:
    class CloudVmClusterCloudAutomationUpdateDetailsFreezePeriodArgsDict(TypedDict):
        freeze_period_end_time: NotRequired[pulumi.Input[str]]
        """
        (Updatable) End time of the freeze period cycle.
        """
        freeze_period_start_time: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Start time of the freeze period cycle.
        """
elif False:
    CloudVmClusterCloudAutomationUpdateDetailsFreezePeriodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudVmClusterCloudAutomationUpdateDetailsFreezePeriodArgs:
    def __init__(__self__, *,
                 freeze_period_end_time: Optional[pulumi.Input[str]] = None,
                 freeze_period_start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] freeze_period_end_time: (Updatable) End time of the freeze period cycle.
        :param pulumi.Input[str] freeze_period_start_time: (Updatable) Start time of the freeze period cycle.
        """
        if freeze_period_end_time is not None:
            pulumi.set(__self__, "freeze_period_end_time", freeze_period_end_time)
        if freeze_period_start_time is not None:
            pulumi.set(__self__, "freeze_period_start_time", freeze_period_start_time)

    @property
    @pulumi.getter(name="freezePeriodEndTime")
    def freeze_period_end_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) End time of the freeze period cycle.
        """
        return pulumi.get(self, "freeze_period_end_time")

    @freeze_period_end_time.setter
    def freeze_period_end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "freeze_period_end_time", value)

    @property
    @pulumi.getter(name="freezePeriodStartTime")
    def freeze_period_start_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Start time of the freeze period cycle.
        """
        return pulumi.get(self, "freeze_period_start_time")

    @freeze_period_start_time.setter
    def freeze_period_start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "freeze_period_start_time", value)


if not MYPY:
    class CloudVmClusterDataCollectionOptionsArgsDict(TypedDict):
        is_diagnostics_events_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        is_health_monitoring_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        is_incident_logs_enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
elif False:
    CloudVmClusterDataCollectionOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudVmClusterDataCollectionOptionsArgs:
    def __init__(__self__, *,
                 is_diagnostics_events_enabled: Optional[pulumi.Input[bool]] = None,
                 is_health_monitoring_enabled: Optional[pulumi.Input[bool]] = None,
                 is_incident_logs_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_diagnostics_events_enabled: (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param pulumi.Input[bool] is_health_monitoring_enabled: (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param pulumi.Input[bool] is_incident_logs_enabled: Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        if is_diagnostics_events_enabled is not None:
            pulumi.set(__self__, "is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        if is_health_monitoring_enabled is not None:
            pulumi.set(__self__, "is_health_monitoring_enabled", is_health_monitoring_enabled)
        if is_incident_logs_enabled is not None:
            pulumi.set(__self__, "is_incident_logs_enabled", is_incident_logs_enabled)

    @property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @is_diagnostics_events_enabled.setter
    def is_diagnostics_events_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_diagnostics_events_enabled", value)

    @property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @is_health_monitoring_enabled.setter
    def is_health_monitoring_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_health_monitoring_enabled", value)

    @property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")

    @is_incident_logs_enabled.setter
    def is_incident_logs_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_incident_logs_enabled", value)


if not MYPY:
    class CloudVmClusterFileSystemConfigurationDetailArgsDict(TypedDict):
        file_system_size_gb: NotRequired[pulumi.Input[int]]
        """
        (Updatable) The file system size to be allocated in GBs.
        """
        mount_point: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The mount point of file system.
        """
elif False:
    CloudVmClusterFileSystemConfigurationDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudVmClusterFileSystemConfigurationDetailArgs:
    def __init__(__self__, *,
                 file_system_size_gb: Optional[pulumi.Input[int]] = None,
                 mount_point: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] file_system_size_gb: (Updatable) The file system size to be allocated in GBs.
        :param pulumi.Input[str] mount_point: (Updatable) The mount point of file system.
        """
        if file_system_size_gb is not None:
            pulumi.set(__self__, "file_system_size_gb", file_system_size_gb)
        if mount_point is not None:
            pulumi.set(__self__, "mount_point", mount_point)

    @property
    @pulumi.getter(name="fileSystemSizeGb")
    def file_system_size_gb(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The file system size to be allocated in GBs.
        """
        return pulumi.get(self, "file_system_size_gb")

    @file_system_size_gb.setter
    def file_system_size_gb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "file_system_size_gb", value)

    @property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The mount point of file system.
        """
        return pulumi.get(self, "mount_point")

    @mount_point.setter
    def mount_point(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_point", value)


if not MYPY:
    class CloudVmClusterIormConfigCachArgsDict(TypedDict):
        db_plans: NotRequired[pulumi.Input[Sequence[pulumi.Input['CloudVmClusterIormConfigCachDbPlanArgsDict']]]]
        """
        An array of IORM settings for all the database in the Exadata DB system.
        """
        lifecycle_details: NotRequired[pulumi.Input[str]]
        """
        Additional information about the current lifecycle state.
        """
        objective: NotRequired[pulumi.Input[str]]
        """
        The current value for the IORM objective. The default is `AUTO`.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        The current state of the cloud VM cluster.
        """
elif False:
    CloudVmClusterIormConfigCachArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudVmClusterIormConfigCachArgs:
    def __init__(__self__, *,
                 db_plans: Optional[pulumi.Input[Sequence[pulumi.Input['CloudVmClusterIormConfigCachDbPlanArgs']]]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 objective: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CloudVmClusterIormConfigCachDbPlanArgs']]] db_plans: An array of IORM settings for all the database in the Exadata DB system.
        :param pulumi.Input[str] lifecycle_details: Additional information about the current lifecycle state.
        :param pulumi.Input[str] objective: The current value for the IORM objective. The default is `AUTO`.
        :param pulumi.Input[str] state: The current state of the cloud VM cluster.
        """
        if db_plans is not None:
            pulumi.set(__self__, "db_plans", db_plans)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if objective is not None:
            pulumi.set(__self__, "objective", objective)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="dbPlans")
    def db_plans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudVmClusterIormConfigCachDbPlanArgs']]]]:
        """
        An array of IORM settings for all the database in the Exadata DB system.
        """
        return pulumi.get(self, "db_plans")

    @db_plans.setter
    def db_plans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudVmClusterIormConfigCachDbPlanArgs']]]]):
        pulumi.set(self, "db_plans", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter
    def objective(self) -> Optional[pulumi.Input[str]]:
        """
        The current value for the IORM objective. The default is `AUTO`.
        """
        return pulumi.get(self, "objective")

    @objective.setter
    def objective(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "objective", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the cloud VM cluster.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class CloudVmClusterIormConfigCachDbPlanArgsDict(TypedDict):
        db_name: NotRequired[pulumi.Input[str]]
        """
        The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        flash_cache_limit: NotRequired[pulumi.Input[str]]
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        share: NotRequired[pulumi.Input[int]]
        """
        The relative priority of this database.
        """
elif False:
    CloudVmClusterIormConfigCachDbPlanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudVmClusterIormConfigCachDbPlanArgs:
    def __init__(__self__, *,
                 db_name: Optional[pulumi.Input[str]] = None,
                 flash_cache_limit: Optional[pulumi.Input[str]] = None,
                 share: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] db_name: The database name. For the default `DbPlan`, the `dbName` is `default`.
        :param pulumi.Input[str] flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        :param pulumi.Input[int] share: The relative priority of this database.
        """
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if flash_cache_limit is not None:
            pulumi.set(__self__, "flash_cache_limit", flash_cache_limit)
        if share is not None:
            pulumi.set(__self__, "share", share)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[pulumi.Input[str]]:
        """
        The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")

    @flash_cache_limit.setter
    def flash_cache_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flash_cache_limit", value)

    @property
    @pulumi.getter
    def share(self) -> Optional[pulumi.Input[int]]:
        """
        The relative priority of this database.
        """
        return pulumi.get(self, "share")

    @share.setter
    def share(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "share", value)


if not MYPY:
    class CloudVmClusterIormConfigDbPlanArgsDict(TypedDict):
        db_name: pulumi.Input[str]
        """
        (Updatable) The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        share: pulumi.Input[int]
        """
        (Updatable) The relative priority of this database.
        """
        flash_cache_limit: NotRequired[pulumi.Input[str]]
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
elif False:
    CloudVmClusterIormConfigDbPlanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudVmClusterIormConfigDbPlanArgs:
    def __init__(__self__, *,
                 db_name: pulumi.Input[str],
                 share: pulumi.Input[int],
                 flash_cache_limit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] db_name: (Updatable) The database name. For the default `DbPlan`, the `dbName` is `default`.
        :param pulumi.Input[int] share: (Updatable) The relative priority of this database.
        :param pulumi.Input[str] flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "share", share)
        if flash_cache_limit is not None:
            pulumi.set(__self__, "flash_cache_limit", flash_cache_limit)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> pulumi.Input[str]:
        """
        (Updatable) The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter
    def share(self) -> pulumi.Input[int]:
        """
        (Updatable) The relative priority of this database.
        """
        return pulumi.get(self, "share")

    @share.setter
    def share(self, value: pulumi.Input[int]):
        pulumi.set(self, "share", value)

    @property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")

    @flash_cache_limit.setter
    def flash_cache_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flash_cache_limit", value)


if not MYPY:
    class DataGuardAssociationDataCollectionOptionsArgsDict(TypedDict):
        is_diagnostics_events_enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        is_health_monitoring_enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        is_incident_logs_enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
elif False:
    DataGuardAssociationDataCollectionOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataGuardAssociationDataCollectionOptionsArgs:
    def __init__(__self__, *,
                 is_diagnostics_events_enabled: Optional[pulumi.Input[bool]] = None,
                 is_health_monitoring_enabled: Optional[pulumi.Input[bool]] = None,
                 is_incident_logs_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_diagnostics_events_enabled: Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param pulumi.Input[bool] is_health_monitoring_enabled: Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param pulumi.Input[bool] is_incident_logs_enabled: Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        if is_diagnostics_events_enabled is not None:
            pulumi.set(__self__, "is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        if is_health_monitoring_enabled is not None:
            pulumi.set(__self__, "is_health_monitoring_enabled", is_health_monitoring_enabled)
        if is_incident_logs_enabled is not None:
            pulumi.set(__self__, "is_incident_logs_enabled", is_incident_logs_enabled)

    @property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @is_diagnostics_events_enabled.setter
    def is_diagnostics_events_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_diagnostics_events_enabled", value)

    @property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @is_health_monitoring_enabled.setter
    def is_health_monitoring_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_health_monitoring_enabled", value)

    @property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")

    @is_incident_logs_enabled.setter
    def is_incident_logs_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_incident_logs_enabled", value)


if not MYPY:
    class DatabaseConnectionStringArgsDict(TypedDict):
        all_connection_strings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        All connection strings to use to connect to the Database.
        """
        cdb_default: NotRequired[pulumi.Input[str]]
        """
        Host name based CDB Connection String.
        """
        cdb_ip_default: NotRequired[pulumi.Input[str]]
        """
        IP based CDB Connection String.
        """
elif False:
    DatabaseConnectionStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseConnectionStringArgs:
    def __init__(__self__, *,
                 all_connection_strings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 cdb_default: Optional[pulumi.Input[str]] = None,
                 cdb_ip_default: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] all_connection_strings: All connection strings to use to connect to the Database.
        :param pulumi.Input[str] cdb_default: Host name based CDB Connection String.
        :param pulumi.Input[str] cdb_ip_default: IP based CDB Connection String.
        """
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if cdb_default is not None:
            pulumi.set(__self__, "cdb_default", cdb_default)
        if cdb_ip_default is not None:
            pulumi.set(__self__, "cdb_ip_default", cdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        All connection strings to use to connect to the Database.
        """
        return pulumi.get(self, "all_connection_strings")

    @all_connection_strings.setter
    def all_connection_strings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "all_connection_strings", value)

    @property
    @pulumi.getter(name="cdbDefault")
    def cdb_default(self) -> Optional[pulumi.Input[str]]:
        """
        Host name based CDB Connection String.
        """
        return pulumi.get(self, "cdb_default")

    @cdb_default.setter
    def cdb_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cdb_default", value)

    @property
    @pulumi.getter(name="cdbIpDefault")
    def cdb_ip_default(self) -> Optional[pulumi.Input[str]]:
        """
        IP based CDB Connection String.
        """
        return pulumi.get(self, "cdb_ip_default")

    @cdb_ip_default.setter
    def cdb_ip_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cdb_ip_default", value)


if not MYPY:
    class DatabaseDatabaseArgsDict(TypedDict):
        admin_password: pulumi.Input[str]
        """
        A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \\#, or -.
        """
        db_name: pulumi.Input[str]
        """
        The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        """
        backup_id: NotRequired[pulumi.Input[str]]
        """
        The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        backup_tde_password: NotRequired[pulumi.Input[str]]
        """
        The password to open the TDE wallet.
        """
        character_set: NotRequired[pulumi.Input[str]]
        """
        The character set for the database.  The default is AL32UTF8. Allowed values are:

        AL32UTF8, AR8ADOS710, AR8ADOS720, AR8APTEC715, AR8ARABICMACS, AR8ASMO8X, AR8ISO8859P6, AR8MSWIN1256, AR8MUSSAD768, AR8NAFITHA711, AR8NAFITHA721, AR8SAKHR706, AR8SAKHR707, AZ8ISO8859P9E, BG8MSWIN, BG8PC437S, BLT8CP921, BLT8ISO8859P13, BLT8MSWIN1257, BLT8PC775, BN8BSCII, CDN8PC863, CEL8ISO8859P14, CL8ISO8859P5, CL8ISOIR111, CL8KOI8R, CL8KOI8U, CL8MACCYRILLICS, CL8MSWIN1251, EE8ISO8859P2, EE8MACCES, EE8MACCROATIANS, EE8MSWIN1250, EE8PC852, EL8DEC, EL8ISO8859P7, EL8MACGREEKS, EL8MSWIN1253, EL8PC437S, EL8PC851, EL8PC869, ET8MSWIN923, HU8ABMOD, HU8CWI2, IN8ISCII, IS8PC861, IW8ISO8859P8, IW8MACHEBREWS, IW8MSWIN1255, IW8PC1507, JA16EUC, JA16EUCTILDE, JA16SJIS, JA16SJISTILDE, JA16VMS, KO16KSC5601, KO16KSCCS, KO16MSWIN949, LA8ISO6937, LA8PASSPORT, LT8MSWIN921, LT8PC772, LT8PC774, LV8PC1117, LV8PC8LR, LV8RST104090, N8PC865, NE8ISO8859P10, NEE8ISO8859P4, RU8BESTA, RU8PC855, RU8PC866, SE8ISO8859P3, TH8MACTHAIS, TH8TISASCII, TR8DEC, TR8MACTURKISHS, TR8MSWIN1254, TR8PC857, US7ASCII, US8PC437, UTF8, VN8MSWIN1258, VN8VN3, WE8DEC, WE8DG, WE8ISO8859P1, WE8ISO8859P15, WE8ISO8859P9, WE8MACROMAN8S, WE8MSWIN1252, WE8NCR4970, WE8NEXTSTEP, WE8PC850, WE8PC858, WE8PC860, WE8ROMAN8, ZHS16CGB231280, ZHS16GBK, ZHT16BIG5, ZHT16CCDC, ZHT16DBT, ZHT16HKSCS, ZHT16MSWIN950, ZHT32EUC, ZHT32SOPS, ZHT32TRIS
        """
        database_software_image_id: NotRequired[pulumi.Input[str]]
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        db_backup_config: NotRequired[pulumi.Input['DatabaseDatabaseDbBackupConfigArgsDict']]
        """
        (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        """
        db_unique_name: NotRequired[pulumi.Input[str]]
        """
        The `DB_UNIQUE_NAME` of the Oracle Database being backed up.
        """
        db_workload: NotRequired[pulumi.Input[str]]
        """
        **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.

        The database workload type.
        """
        defined_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        freeform_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        kms_key_id: NotRequired[pulumi.Input[str]]
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        kms_key_version_id: NotRequired[pulumi.Input[str]]
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        """
        ncharacter_set: NotRequired[pulumi.Input[str]]
        """
        The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        """
        pdb_name: NotRequired[pulumi.Input[str]]
        """
        The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        """
        pluggable_databases: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of pluggable databases that needs to be restored into new database.
        """
        sid_prefix: NotRequired[pulumi.Input[str]]
        """
        Specifies a prefix for the `Oracle SID` of the database to be created.
        """
        tde_wallet_password: NotRequired[pulumi.Input[str]]
        """
        The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \\#, or -.
        """
        vault_id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
elif False:
    DatabaseDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseDatabaseArgs:
    def __init__(__self__, *,
                 admin_password: pulumi.Input[str],
                 db_name: pulumi.Input[str],
                 backup_id: Optional[pulumi.Input[str]] = None,
                 backup_tde_password: Optional[pulumi.Input[str]] = None,
                 character_set: Optional[pulumi.Input[str]] = None,
                 database_software_image_id: Optional[pulumi.Input[str]] = None,
                 db_backup_config: Optional[pulumi.Input['DatabaseDatabaseDbBackupConfigArgs']] = None,
                 db_unique_name: Optional[pulumi.Input[str]] = None,
                 db_workload: Optional[pulumi.Input[str]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 kms_key_version_id: Optional[pulumi.Input[str]] = None,
                 ncharacter_set: Optional[pulumi.Input[str]] = None,
                 pdb_name: Optional[pulumi.Input[str]] = None,
                 pluggable_databases: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sid_prefix: Optional[pulumi.Input[str]] = None,
                 tde_wallet_password: Optional[pulumi.Input[str]] = None,
                 vault_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] admin_password: A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \\#, or -.
        :param pulumi.Input[str] db_name: The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        :param pulumi.Input[str] backup_id: The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input[str] backup_tde_password: The password to open the TDE wallet.
        :param pulumi.Input[str] character_set: The character set for the database.  The default is AL32UTF8. Allowed values are:
               
               AL32UTF8, AR8ADOS710, AR8ADOS720, AR8APTEC715, AR8ARABICMACS, AR8ASMO8X, AR8ISO8859P6, AR8MSWIN1256, AR8MUSSAD768, AR8NAFITHA711, AR8NAFITHA721, AR8SAKHR706, AR8SAKHR707, AZ8ISO8859P9E, BG8MSWIN, BG8PC437S, BLT8CP921, BLT8ISO8859P13, BLT8MSWIN1257, BLT8PC775, BN8BSCII, CDN8PC863, CEL8ISO8859P14, CL8ISO8859P5, CL8ISOIR111, CL8KOI8R, CL8KOI8U, CL8MACCYRILLICS, CL8MSWIN1251, EE8ISO8859P2, EE8MACCES, EE8MACCROATIANS, EE8MSWIN1250, EE8PC852, EL8DEC, EL8ISO8859P7, EL8MACGREEKS, EL8MSWIN1253, EL8PC437S, EL8PC851, EL8PC869, ET8MSWIN923, HU8ABMOD, HU8CWI2, IN8ISCII, IS8PC861, IW8ISO8859P8, IW8MACHEBREWS, IW8MSWIN1255, IW8PC1507, JA16EUC, JA16EUCTILDE, JA16SJIS, JA16SJISTILDE, JA16VMS, KO16KSC5601, KO16KSCCS, KO16MSWIN949, LA8ISO6937, LA8PASSPORT, LT8MSWIN921, LT8PC772, LT8PC774, LV8PC1117, LV8PC8LR, LV8RST104090, N8PC865, NE8ISO8859P10, NEE8ISO8859P4, RU8BESTA, RU8PC855, RU8PC866, SE8ISO8859P3, TH8MACTHAIS, TH8TISASCII, TR8DEC, TR8MACTURKISHS, TR8MSWIN1254, TR8PC857, US7ASCII, US8PC437, UTF8, VN8MSWIN1258, VN8VN3, WE8DEC, WE8DG, WE8ISO8859P1, WE8ISO8859P15, WE8ISO8859P9, WE8MACROMAN8S, WE8MSWIN1252, WE8NCR4970, WE8NEXTSTEP, WE8PC850, WE8PC858, WE8PC860, WE8ROMAN8, ZHS16CGB231280, ZHS16GBK, ZHT16BIG5, ZHT16CCDC, ZHT16DBT, ZHT16HKSCS, ZHT16MSWIN950, ZHT32EUC, ZHT32SOPS, ZHT32TRIS
        :param pulumi.Input[str] database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        :param pulumi.Input['DatabaseDatabaseDbBackupConfigArgs'] db_backup_config: (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        :param pulumi.Input[str] db_unique_name: The `DB_UNIQUE_NAME` of the Oracle Database being backed up.
        :param pulumi.Input[str] db_workload: **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.
               
               The database workload type.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] freeform_tags: (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param pulumi.Input[str] kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param pulumi.Input[str] kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        :param pulumi.Input[str] ncharacter_set: The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        :param pulumi.Input[str] pdb_name: The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pluggable_databases: The list of pluggable databases that needs to be restored into new database.
        :param pulumi.Input[str] sid_prefix: Specifies a prefix for the `Oracle SID` of the database to be created.
        :param pulumi.Input[str] tde_wallet_password: The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \\#, or -.
        :param pulumi.Input[str] vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        pulumi.set(__self__, "admin_password", admin_password)
        pulumi.set(__self__, "db_name", db_name)
        if backup_id is not None:
            pulumi.set(__self__, "backup_id", backup_id)
        if backup_tde_password is not None:
            pulumi.set(__self__, "backup_tde_password", backup_tde_password)
        if character_set is not None:
            pulumi.set(__self__, "character_set", character_set)
        if database_software_image_id is not None:
            pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        if db_backup_config is not None:
            pulumi.set(__self__, "db_backup_config", db_backup_config)
        if db_unique_name is not None:
            pulumi.set(__self__, "db_unique_name", db_unique_name)
        if db_workload is not None:
            pulumi.set(__self__, "db_workload", db_workload)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if kms_key_version_id is not None:
            pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        if ncharacter_set is not None:
            pulumi.set(__self__, "ncharacter_set", ncharacter_set)
        if pdb_name is not None:
            pulumi.set(__self__, "pdb_name", pdb_name)
        if pluggable_databases is not None:
            pulumi.set(__self__, "pluggable_databases", pluggable_databases)
        if sid_prefix is not None:
            pulumi.set(__self__, "sid_prefix", sid_prefix)
        if tde_wallet_password is not None:
            pulumi.set(__self__, "tde_wallet_password", tde_wallet_password)
        if vault_id is not None:
            pulumi.set(__self__, "vault_id", vault_id)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> pulumi.Input[str]:
        """
        A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \\#, or -.
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> pulumi.Input[str]:
        """
        The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> Optional[pulumi.Input[str]]:
        """
        The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "backup_id")

    @backup_id.setter
    def backup_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_id", value)

    @property
    @pulumi.getter(name="backupTdePassword")
    def backup_tde_password(self) -> Optional[pulumi.Input[str]]:
        """
        The password to open the TDE wallet.
        """
        return pulumi.get(self, "backup_tde_password")

    @backup_tde_password.setter
    def backup_tde_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_tde_password", value)

    @property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> Optional[pulumi.Input[str]]:
        """
        The character set for the database.  The default is AL32UTF8. Allowed values are:

        AL32UTF8, AR8ADOS710, AR8ADOS720, AR8APTEC715, AR8ARABICMACS, AR8ASMO8X, AR8ISO8859P6, AR8MSWIN1256, AR8MUSSAD768, AR8NAFITHA711, AR8NAFITHA721, AR8SAKHR706, AR8SAKHR707, AZ8ISO8859P9E, BG8MSWIN, BG8PC437S, BLT8CP921, BLT8ISO8859P13, BLT8MSWIN1257, BLT8PC775, BN8BSCII, CDN8PC863, CEL8ISO8859P14, CL8ISO8859P5, CL8ISOIR111, CL8KOI8R, CL8KOI8U, CL8MACCYRILLICS, CL8MSWIN1251, EE8ISO8859P2, EE8MACCES, EE8MACCROATIANS, EE8MSWIN1250, EE8PC852, EL8DEC, EL8ISO8859P7, EL8MACGREEKS, EL8MSWIN1253, EL8PC437S, EL8PC851, EL8PC869, ET8MSWIN923, HU8ABMOD, HU8CWI2, IN8ISCII, IS8PC861, IW8ISO8859P8, IW8MACHEBREWS, IW8MSWIN1255, IW8PC1507, JA16EUC, JA16EUCTILDE, JA16SJIS, JA16SJISTILDE, JA16VMS, KO16KSC5601, KO16KSCCS, KO16MSWIN949, LA8ISO6937, LA8PASSPORT, LT8MSWIN921, LT8PC772, LT8PC774, LV8PC1117, LV8PC8LR, LV8RST104090, N8PC865, NE8ISO8859P10, NEE8ISO8859P4, RU8BESTA, RU8PC855, RU8PC866, SE8ISO8859P3, TH8MACTHAIS, TH8TISASCII, TR8DEC, TR8MACTURKISHS, TR8MSWIN1254, TR8PC857, US7ASCII, US8PC437, UTF8, VN8MSWIN1258, VN8VN3, WE8DEC, WE8DG, WE8ISO8859P1, WE8ISO8859P15, WE8ISO8859P9, WE8MACROMAN8S, WE8MSWIN1252, WE8NCR4970, WE8NEXTSTEP, WE8PC850, WE8PC858, WE8PC860, WE8ROMAN8, ZHS16CGB231280, ZHS16GBK, ZHT16BIG5, ZHT16CCDC, ZHT16DBT, ZHT16HKSCS, ZHT16MSWIN950, ZHT32EUC, ZHT32SOPS, ZHT32TRIS
        """
        return pulumi.get(self, "character_set")

    @character_set.setter
    def character_set(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "character_set", value)

    @property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> Optional[pulumi.Input[str]]:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        return pulumi.get(self, "database_software_image_id")

    @database_software_image_id.setter
    def database_software_image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_software_image_id", value)

    @property
    @pulumi.getter(name="dbBackupConfig")
    def db_backup_config(self) -> Optional[pulumi.Input['DatabaseDatabaseDbBackupConfigArgs']]:
        """
        (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        """
        return pulumi.get(self, "db_backup_config")

    @db_backup_config.setter
    def db_backup_config(self, value: Optional[pulumi.Input['DatabaseDatabaseDbBackupConfigArgs']]):
        pulumi.set(self, "db_backup_config", value)

    @property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> Optional[pulumi.Input[str]]:
        """
        The `DB_UNIQUE_NAME` of the Oracle Database being backed up.
        """
        return pulumi.get(self, "db_unique_name")

    @db_unique_name.setter
    def db_unique_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_unique_name", value)

    @property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> Optional[pulumi.Input[str]]:
        """
        **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.

        The database workload type.
        """
        return pulumi.get(self, "db_workload")

    @db_workload.setter
    def db_workload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_workload", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        """
        return pulumi.get(self, "kms_key_version_id")

    @kms_key_version_id.setter
    def kms_key_version_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_version_id", value)

    @property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> Optional[pulumi.Input[str]]:
        """
        The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        """
        return pulumi.get(self, "ncharacter_set")

    @ncharacter_set.setter
    def ncharacter_set(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ncharacter_set", value)

    @property
    @pulumi.getter(name="pdbName")
    def pdb_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        """
        return pulumi.get(self, "pdb_name")

    @pdb_name.setter
    def pdb_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pdb_name", value)

    @property
    @pulumi.getter(name="pluggableDatabases")
    def pluggable_databases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of pluggable databases that needs to be restored into new database.
        """
        return pulumi.get(self, "pluggable_databases")

    @pluggable_databases.setter
    def pluggable_databases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "pluggable_databases", value)

    @property
    @pulumi.getter(name="sidPrefix")
    def sid_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a prefix for the `Oracle SID` of the database to be created.
        """
        return pulumi.get(self, "sid_prefix")

    @sid_prefix.setter
    def sid_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sid_prefix", value)

    @property
    @pulumi.getter(name="tdeWalletPassword")
    def tde_wallet_password(self) -> Optional[pulumi.Input[str]]:
        """
        The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \\#, or -.
        """
        return pulumi.get(self, "tde_wallet_password")

    @tde_wallet_password.setter
    def tde_wallet_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tde_wallet_password", value)

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        return pulumi.get(self, "vault_id")

    @vault_id.setter
    def vault_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vault_id", value)


if not MYPY:
    class DatabaseDatabaseDbBackupConfigArgsDict(TypedDict):
        auto_backup_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        auto_backup_window: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        auto_full_backup_day: NotRequired[pulumi.Input[str]]
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        auto_full_backup_window: NotRequired[pulumi.Input[str]]
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        backup_deletion_policy: NotRequired[pulumi.Input[str]]
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        backup_destination_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['DatabaseDatabaseDbBackupConfigBackupDestinationDetailArgsDict']]]]
        """
        Backup destination details.
        """
        recovery_window_in_days: NotRequired[pulumi.Input[int]]
        """
        (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        run_immediate_full_backup: NotRequired[pulumi.Input[bool]]
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
elif False:
    DatabaseDatabaseDbBackupConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseDatabaseDbBackupConfigArgs:
    def __init__(__self__, *,
                 auto_backup_enabled: Optional[pulumi.Input[bool]] = None,
                 auto_backup_window: Optional[pulumi.Input[str]] = None,
                 auto_full_backup_day: Optional[pulumi.Input[str]] = None,
                 auto_full_backup_window: Optional[pulumi.Input[str]] = None,
                 backup_deletion_policy: Optional[pulumi.Input[str]] = None,
                 backup_destination_details: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDatabaseDbBackupConfigBackupDestinationDetailArgs']]]] = None,
                 recovery_window_in_days: Optional[pulumi.Input[int]] = None,
                 run_immediate_full_backup: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] auto_backup_enabled: (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param pulumi.Input[str] auto_backup_window: (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param pulumi.Input[str] auto_full_backup_day: Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        :param pulumi.Input[str] auto_full_backup_window: Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param pulumi.Input[str] backup_deletion_policy: This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseDatabaseDbBackupConfigBackupDestinationDetailArgs']]] backup_destination_details: Backup destination details.
        :param pulumi.Input[int] recovery_window_in_days: (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        :param pulumi.Input[bool] run_immediate_full_backup: If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        if auto_backup_enabled is not None:
            pulumi.set(__self__, "auto_backup_enabled", auto_backup_enabled)
        if auto_backup_window is not None:
            pulumi.set(__self__, "auto_backup_window", auto_backup_window)
        if auto_full_backup_day is not None:
            pulumi.set(__self__, "auto_full_backup_day", auto_full_backup_day)
        if auto_full_backup_window is not None:
            pulumi.set(__self__, "auto_full_backup_window", auto_full_backup_window)
        if backup_deletion_policy is not None:
            pulumi.set(__self__, "backup_deletion_policy", backup_deletion_policy)
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)
        if run_immediate_full_backup is not None:
            pulumi.set(__self__, "run_immediate_full_backup", run_immediate_full_backup)

    @property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @auto_backup_enabled.setter
    def auto_backup_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_backup_enabled", value)

    @property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @auto_backup_window.setter
    def auto_backup_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_backup_window", value)

    @property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> Optional[pulumi.Input[str]]:
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        return pulumi.get(self, "auto_full_backup_day")

    @auto_full_backup_day.setter
    def auto_full_backup_day(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_full_backup_day", value)

    @property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> Optional[pulumi.Input[str]]:
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_full_backup_window")

    @auto_full_backup_window.setter
    def auto_full_backup_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_full_backup_window", value)

    @property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> Optional[pulumi.Input[str]]:
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        return pulumi.get(self, "backup_deletion_policy")

    @backup_deletion_policy.setter
    def backup_deletion_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_deletion_policy", value)

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDatabaseDbBackupConfigBackupDestinationDetailArgs']]]]:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @backup_destination_details.setter
    def backup_destination_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDatabaseDbBackupConfigBackupDestinationDetailArgs']]]]):
        pulumi.set(self, "backup_destination_details", value)

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @recovery_window_in_days.setter
    def recovery_window_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "recovery_window_in_days", value)

    @property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        return pulumi.get(self, "run_immediate_full_backup")

    @run_immediate_full_backup.setter
    def run_immediate_full_backup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_immediate_full_backup", value)


if not MYPY:
    class DatabaseDatabaseDbBackupConfigBackupDestinationDetailArgsDict(TypedDict):
        dbrs_policy_id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of the database backup destination.
        """
        vpc_user: NotRequired[pulumi.Input[str]]
elif False:
    DatabaseDatabaseDbBackupConfigBackupDestinationDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseDatabaseDbBackupConfigBackupDestinationDetailArgs:
    def __init__(__self__, *,
                 dbrs_policy_id: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 vpc_user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param pulumi.Input[str] type: Type of the database backup destination.
        """
        if dbrs_policy_id is not None:
            pulumi.set(__self__, "dbrs_policy_id", dbrs_policy_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vpc_user is not None:
            pulumi.set(__self__, "vpc_user", vpc_user)

    @property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @dbrs_policy_id.setter
    def dbrs_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dbrs_policy_id", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vpc_user")

    @vpc_user.setter
    def vpc_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_user", value)


if not MYPY:
    class DatabaseDatabaseManagementConfigArgsDict(TypedDict):
        management_status: NotRequired[pulumi.Input[str]]
        """
        The status of the Database Management service.
        """
        management_type: NotRequired[pulumi.Input[str]]
        """
        The Database Management type.
        """
elif False:
    DatabaseDatabaseManagementConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseDatabaseManagementConfigArgs:
    def __init__(__self__, *,
                 management_status: Optional[pulumi.Input[str]] = None,
                 management_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] management_status: The status of the Database Management service.
        :param pulumi.Input[str] management_type: The Database Management type.
        """
        if management_status is not None:
            pulumi.set(__self__, "management_status", management_status)
        if management_type is not None:
            pulumi.set(__self__, "management_type", management_type)

    @property
    @pulumi.getter(name="managementStatus")
    def management_status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "management_status")

    @management_status.setter
    def management_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "management_status", value)

    @property
    @pulumi.getter(name="managementType")
    def management_type(self) -> Optional[pulumi.Input[str]]:
        """
        The Database Management type.
        """
        return pulumi.get(self, "management_type")

    @management_type.setter
    def management_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "management_type", value)


if not MYPY:
    class DatabaseDbBackupConfigArgsDict(TypedDict):
        auto_backup_enabled: NotRequired[pulumi.Input[bool]]
        """
        If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        auto_backup_window: NotRequired[pulumi.Input[str]]
        """
        Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        auto_full_backup_day: NotRequired[pulumi.Input[str]]
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        auto_full_backup_window: NotRequired[pulumi.Input[str]]
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        backup_deletion_policy: NotRequired[pulumi.Input[str]]
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        backup_destination_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['DatabaseDbBackupConfigBackupDestinationDetailArgsDict']]]]
        """
        Backup destination details.
        """
        recovery_window_in_days: NotRequired[pulumi.Input[int]]
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        run_immediate_full_backup: NotRequired[pulumi.Input[bool]]
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
elif False:
    DatabaseDbBackupConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseDbBackupConfigArgs:
    def __init__(__self__, *,
                 auto_backup_enabled: Optional[pulumi.Input[bool]] = None,
                 auto_backup_window: Optional[pulumi.Input[str]] = None,
                 auto_full_backup_day: Optional[pulumi.Input[str]] = None,
                 auto_full_backup_window: Optional[pulumi.Input[str]] = None,
                 backup_deletion_policy: Optional[pulumi.Input[str]] = None,
                 backup_destination_details: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbBackupConfigBackupDestinationDetailArgs']]]] = None,
                 recovery_window_in_days: Optional[pulumi.Input[int]] = None,
                 run_immediate_full_backup: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] auto_backup_enabled: If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param pulumi.Input[str] auto_backup_window: Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param pulumi.Input[str] auto_full_backup_day: Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        :param pulumi.Input[str] auto_full_backup_window: Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param pulumi.Input[str] backup_deletion_policy: This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseDbBackupConfigBackupDestinationDetailArgs']]] backup_destination_details: Backup destination details.
        :param pulumi.Input[int] recovery_window_in_days: Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        :param pulumi.Input[bool] run_immediate_full_backup: If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        if auto_backup_enabled is not None:
            pulumi.set(__self__, "auto_backup_enabled", auto_backup_enabled)
        if auto_backup_window is not None:
            pulumi.set(__self__, "auto_backup_window", auto_backup_window)
        if auto_full_backup_day is not None:
            pulumi.set(__self__, "auto_full_backup_day", auto_full_backup_day)
        if auto_full_backup_window is not None:
            pulumi.set(__self__, "auto_full_backup_window", auto_full_backup_window)
        if backup_deletion_policy is not None:
            pulumi.set(__self__, "backup_deletion_policy", backup_deletion_policy)
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)
        if run_immediate_full_backup is not None:
            pulumi.set(__self__, "run_immediate_full_backup", run_immediate_full_backup)

    @property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @auto_backup_enabled.setter
    def auto_backup_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_backup_enabled", value)

    @property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> Optional[pulumi.Input[str]]:
        """
        Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @auto_backup_window.setter
    def auto_backup_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_backup_window", value)

    @property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> Optional[pulumi.Input[str]]:
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        return pulumi.get(self, "auto_full_backup_day")

    @auto_full_backup_day.setter
    def auto_full_backup_day(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_full_backup_day", value)

    @property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> Optional[pulumi.Input[str]]:
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_full_backup_window")

    @auto_full_backup_window.setter
    def auto_full_backup_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_full_backup_window", value)

    @property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> Optional[pulumi.Input[str]]:
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        return pulumi.get(self, "backup_deletion_policy")

    @backup_deletion_policy.setter
    def backup_deletion_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_deletion_policy", value)

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbBackupConfigBackupDestinationDetailArgs']]]]:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @backup_destination_details.setter
    def backup_destination_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbBackupConfigBackupDestinationDetailArgs']]]]):
        pulumi.set(self, "backup_destination_details", value)

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @recovery_window_in_days.setter
    def recovery_window_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "recovery_window_in_days", value)

    @property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        return pulumi.get(self, "run_immediate_full_backup")

    @run_immediate_full_backup.setter
    def run_immediate_full_backup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_immediate_full_backup", value)


if not MYPY:
    class DatabaseDbBackupConfigBackupDestinationDetailArgsDict(TypedDict):
        dbrs_policy_id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of the database backup destination.
        """
        vpc_user: NotRequired[pulumi.Input[str]]
elif False:
    DatabaseDbBackupConfigBackupDestinationDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseDbBackupConfigBackupDestinationDetailArgs:
    def __init__(__self__, *,
                 dbrs_policy_id: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 vpc_user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        :param pulumi.Input[str] type: Type of the database backup destination.
        """
        if dbrs_policy_id is not None:
            pulumi.set(__self__, "dbrs_policy_id", dbrs_policy_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vpc_user is not None:
            pulumi.set(__self__, "vpc_user", vpc_user)

    @property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @dbrs_policy_id.setter
    def dbrs_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dbrs_policy_id", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vpc_user")

    @vpc_user.setter
    def vpc_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_user", value)


if not MYPY:
    class DatabaseUpgradeConnectionStringArgsDict(TypedDict):
        all_connection_strings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        All connection strings to use to connect to the Database.
        """
        cdb_default: NotRequired[pulumi.Input[str]]
        """
        Host name based CDB Connection String.
        """
        cdb_ip_default: NotRequired[pulumi.Input[str]]
        """
        IP based CDB Connection String.
        """
elif False:
    DatabaseUpgradeConnectionStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseUpgradeConnectionStringArgs:
    def __init__(__self__, *,
                 all_connection_strings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 cdb_default: Optional[pulumi.Input[str]] = None,
                 cdb_ip_default: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] all_connection_strings: All connection strings to use to connect to the Database.
        :param pulumi.Input[str] cdb_default: Host name based CDB Connection String.
        :param pulumi.Input[str] cdb_ip_default: IP based CDB Connection String.
        """
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if cdb_default is not None:
            pulumi.set(__self__, "cdb_default", cdb_default)
        if cdb_ip_default is not None:
            pulumi.set(__self__, "cdb_ip_default", cdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        All connection strings to use to connect to the Database.
        """
        return pulumi.get(self, "all_connection_strings")

    @all_connection_strings.setter
    def all_connection_strings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "all_connection_strings", value)

    @property
    @pulumi.getter(name="cdbDefault")
    def cdb_default(self) -> Optional[pulumi.Input[str]]:
        """
        Host name based CDB Connection String.
        """
        return pulumi.get(self, "cdb_default")

    @cdb_default.setter
    def cdb_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cdb_default", value)

    @property
    @pulumi.getter(name="cdbIpDefault")
    def cdb_ip_default(self) -> Optional[pulumi.Input[str]]:
        """
        IP based CDB Connection String.
        """
        return pulumi.get(self, "cdb_ip_default")

    @cdb_ip_default.setter
    def cdb_ip_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cdb_ip_default", value)


if not MYPY:
    class DatabaseUpgradeDatabaseUpgradeSourceDetailsArgsDict(TypedDict):
        database_software_image_id: NotRequired[pulumi.Input[str]]
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the image to be used to upgrade a database.
        """
        db_version: NotRequired[pulumi.Input[str]]
        """
        A valid Oracle Database version. For a list of supported versions, use the ListDbVersions operation.

        This cannot be updated in parallel with any of the following: licenseModel, dbEdition, cpuCoreCount, computeCount, computeModel, adminPassword, whitelistedIps, isMTLSConnectionRequired, openMode, permissionLevel, dbWorkload, privateEndpointLabel, nsgIds, isRefreshable, dbName, scheduledOperations, dbToolsDetails, isLocalDataGuardEnabled, or isFreeTier.
        """
        options: NotRequired[pulumi.Input[str]]
        """
        Additional upgrade options supported by DBUA(Database Upgrade Assistant). Example: "-upgradeTimezone false -keepEvents"
        """
        source: NotRequired[pulumi.Input[str]]
        """
        The source of the Oracle Database software to be used for the upgrade.
        * Use `DB_VERSION` to specify a generally-available Oracle Database software version to upgrade the database.
        * Use `DB_SOFTWARE_IMAGE` to specify a [database software image](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/databasesoftwareimage.htm) to upgrade the database.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    DatabaseUpgradeDatabaseUpgradeSourceDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseUpgradeDatabaseUpgradeSourceDetailsArgs:
    def __init__(__self__, *,
                 database_software_image_id: Optional[pulumi.Input[str]] = None,
                 db_version: Optional[pulumi.Input[str]] = None,
                 options: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the image to be used to upgrade a database.
        :param pulumi.Input[str] db_version: A valid Oracle Database version. For a list of supported versions, use the ListDbVersions operation.
               
               This cannot be updated in parallel with any of the following: licenseModel, dbEdition, cpuCoreCount, computeCount, computeModel, adminPassword, whitelistedIps, isMTLSConnectionRequired, openMode, permissionLevel, dbWorkload, privateEndpointLabel, nsgIds, isRefreshable, dbName, scheduledOperations, dbToolsDetails, isLocalDataGuardEnabled, or isFreeTier.
        :param pulumi.Input[str] options: Additional upgrade options supported by DBUA(Database Upgrade Assistant). Example: "-upgradeTimezone false -keepEvents"
        :param pulumi.Input[str] source: The source of the Oracle Database software to be used for the upgrade.
               * Use `DB_VERSION` to specify a generally-available Oracle Database software version to upgrade the database.
               * Use `DB_SOFTWARE_IMAGE` to specify a [database software image](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/databasesoftwareimage.htm) to upgrade the database.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if database_software_image_id is not None:
            pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        if db_version is not None:
            pulumi.set(__self__, "db_version", db_version)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> Optional[pulumi.Input[str]]:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the image to be used to upgrade a database.
        """
        return pulumi.get(self, "database_software_image_id")

    @database_software_image_id.setter
    def database_software_image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_software_image_id", value)

    @property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> Optional[pulumi.Input[str]]:
        """
        A valid Oracle Database version. For a list of supported versions, use the ListDbVersions operation.

        This cannot be updated in parallel with any of the following: licenseModel, dbEdition, cpuCoreCount, computeCount, computeModel, adminPassword, whitelistedIps, isMTLSConnectionRequired, openMode, permissionLevel, dbWorkload, privateEndpointLabel, nsgIds, isRefreshable, dbName, scheduledOperations, dbToolsDetails, isLocalDataGuardEnabled, or isFreeTier.
        """
        return pulumi.get(self, "db_version")

    @db_version.setter
    def db_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_version", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[str]]:
        """
        Additional upgrade options supported by DBUA(Database Upgrade Assistant). Example: "-upgradeTimezone false -keepEvents"
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The source of the Oracle Database software to be used for the upgrade.
        * Use `DB_VERSION` to specify a generally-available Oracle Database software version to upgrade the database.
        * Use `DB_SOFTWARE_IMAGE` to specify a [database software image](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/databasesoftwareimage.htm) to upgrade the database.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class DatabaseUpgradeDbBackupConfigArgsDict(TypedDict):
        auto_backup_enabled: NotRequired[pulumi.Input[bool]]
        """
        If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        auto_backup_window: NotRequired[pulumi.Input[str]]
        """
        Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        auto_full_backup_day: NotRequired[pulumi.Input[str]]
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        auto_full_backup_window: NotRequired[pulumi.Input[str]]
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        backup_deletion_policy: NotRequired[pulumi.Input[str]]
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        backup_destination_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['DatabaseUpgradeDbBackupConfigBackupDestinationDetailArgsDict']]]]
        """
        Backup destination details.
        """
        recovery_window_in_days: NotRequired[pulumi.Input[int]]
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        run_immediate_full_backup: NotRequired[pulumi.Input[bool]]
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
elif False:
    DatabaseUpgradeDbBackupConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseUpgradeDbBackupConfigArgs:
    def __init__(__self__, *,
                 auto_backup_enabled: Optional[pulumi.Input[bool]] = None,
                 auto_backup_window: Optional[pulumi.Input[str]] = None,
                 auto_full_backup_day: Optional[pulumi.Input[str]] = None,
                 auto_full_backup_window: Optional[pulumi.Input[str]] = None,
                 backup_deletion_policy: Optional[pulumi.Input[str]] = None,
                 backup_destination_details: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseUpgradeDbBackupConfigBackupDestinationDetailArgs']]]] = None,
                 recovery_window_in_days: Optional[pulumi.Input[int]] = None,
                 run_immediate_full_backup: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] auto_backup_enabled: If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param pulumi.Input[str] auto_backup_window: Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param pulumi.Input[str] auto_full_backup_day: Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        :param pulumi.Input[str] auto_full_backup_window: Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param pulumi.Input[str] backup_deletion_policy: This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseUpgradeDbBackupConfigBackupDestinationDetailArgs']]] backup_destination_details: Backup destination details.
        :param pulumi.Input[int] recovery_window_in_days: Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        :param pulumi.Input[bool] run_immediate_full_backup: If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        if auto_backup_enabled is not None:
            pulumi.set(__self__, "auto_backup_enabled", auto_backup_enabled)
        if auto_backup_window is not None:
            pulumi.set(__self__, "auto_backup_window", auto_backup_window)
        if auto_full_backup_day is not None:
            pulumi.set(__self__, "auto_full_backup_day", auto_full_backup_day)
        if auto_full_backup_window is not None:
            pulumi.set(__self__, "auto_full_backup_window", auto_full_backup_window)
        if backup_deletion_policy is not None:
            pulumi.set(__self__, "backup_deletion_policy", backup_deletion_policy)
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)
        if run_immediate_full_backup is not None:
            pulumi.set(__self__, "run_immediate_full_backup", run_immediate_full_backup)

    @property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @auto_backup_enabled.setter
    def auto_backup_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_backup_enabled", value)

    @property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> Optional[pulumi.Input[str]]:
        """
        Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @auto_backup_window.setter
    def auto_backup_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_backup_window", value)

    @property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> Optional[pulumi.Input[str]]:
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        return pulumi.get(self, "auto_full_backup_day")

    @auto_full_backup_day.setter
    def auto_full_backup_day(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_full_backup_day", value)

    @property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> Optional[pulumi.Input[str]]:
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_full_backup_window")

    @auto_full_backup_window.setter
    def auto_full_backup_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_full_backup_window", value)

    @property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> Optional[pulumi.Input[str]]:
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        return pulumi.get(self, "backup_deletion_policy")

    @backup_deletion_policy.setter
    def backup_deletion_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_deletion_policy", value)

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseUpgradeDbBackupConfigBackupDestinationDetailArgs']]]]:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @backup_destination_details.setter
    def backup_destination_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseUpgradeDbBackupConfigBackupDestinationDetailArgs']]]]):
        pulumi.set(self, "backup_destination_details", value)

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @recovery_window_in_days.setter
    def recovery_window_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "recovery_window_in_days", value)

    @property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        return pulumi.get(self, "run_immediate_full_backup")

    @run_immediate_full_backup.setter
    def run_immediate_full_backup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_immediate_full_backup", value)


if not MYPY:
    class DatabaseUpgradeDbBackupConfigBackupDestinationDetailArgsDict(TypedDict):
        dbrs_policy_id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        """
        internet_proxy: NotRequired[pulumi.Input[str]]
        """
        Proxy URL to connect to object store.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of the database backup destination.
        """
        vpc_password: NotRequired[pulumi.Input[str]]
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        vpc_user: NotRequired[pulumi.Input[str]]
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
elif False:
    DatabaseUpgradeDbBackupConfigBackupDestinationDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseUpgradeDbBackupConfigBackupDestinationDetailArgs:
    def __init__(__self__, *,
                 dbrs_policy_id: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 internet_proxy: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 vpc_password: Optional[pulumi.Input[str]] = None,
                 vpc_user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        :param pulumi.Input[str] internet_proxy: Proxy URL to connect to object store.
        :param pulumi.Input[str] type: Type of the database backup destination.
        :param pulumi.Input[str] vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param pulumi.Input[str] vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        if dbrs_policy_id is not None:
            pulumi.set(__self__, "dbrs_policy_id", dbrs_policy_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if internet_proxy is not None:
            pulumi.set(__self__, "internet_proxy", internet_proxy)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vpc_password is not None:
            pulumi.set(__self__, "vpc_password", vpc_password)
        if vpc_user is not None:
            pulumi.set(__self__, "vpc_user", vpc_user)

    @property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @dbrs_policy_id.setter
    def dbrs_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dbrs_policy_id", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @internet_proxy.setter
    def internet_proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "internet_proxy", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> Optional[pulumi.Input[str]]:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @vpc_password.setter
    def vpc_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_password", value)

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[pulumi.Input[str]]:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")

    @vpc_user.setter
    def vpc_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_user", value)


if not MYPY:
    class DbHomeDatabaseArgsDict(TypedDict):
        admin_password: pulumi.Input[str]
        """
        A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \\#, or -.
        """
        backup_id: NotRequired[pulumi.Input[str]]
        """
        The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        backup_tde_password: NotRequired[pulumi.Input[str]]
        """
        The password to open the TDE wallet.
        """
        character_set: NotRequired[pulumi.Input[str]]
        """
        The character set for the database.  The default is AL32UTF8. Allowed values are:

        AL32UTF8, AR8ADOS710, AR8ADOS720, AR8APTEC715, AR8ARABICMACS, AR8ASMO8X, AR8ISO8859P6, AR8MSWIN1256, AR8MUSSAD768, AR8NAFITHA711, AR8NAFITHA721, AR8SAKHR706, AR8SAKHR707, AZ8ISO8859P9E, BG8MSWIN, BG8PC437S, BLT8CP921, BLT8ISO8859P13, BLT8MSWIN1257, BLT8PC775, BN8BSCII, CDN8PC863, CEL8ISO8859P14, CL8ISO8859P5, CL8ISOIR111, CL8KOI8R, CL8KOI8U, CL8MACCYRILLICS, CL8MSWIN1251, EE8ISO8859P2, EE8MACCES, EE8MACCROATIANS, EE8MSWIN1250, EE8PC852, EL8DEC, EL8ISO8859P7, EL8MACGREEKS, EL8MSWIN1253, EL8PC437S, EL8PC851, EL8PC869, ET8MSWIN923, HU8ABMOD, HU8CWI2, IN8ISCII, IS8PC861, IW8ISO8859P8, IW8MACHEBREWS, IW8MSWIN1255, IW8PC1507, JA16EUC, JA16EUCTILDE, JA16SJIS, JA16SJISTILDE, JA16VMS, KO16KSC5601, KO16KSCCS, KO16MSWIN949, LA8ISO6937, LA8PASSPORT, LT8MSWIN921, LT8PC772, LT8PC774, LV8PC1117, LV8PC8LR, LV8RST104090, N8PC865, NE8ISO8859P10, NEE8ISO8859P4, RU8BESTA, RU8PC855, RU8PC866, SE8ISO8859P3, TH8MACTHAIS, TH8TISASCII, TR8DEC, TR8MACTURKISHS, TR8MSWIN1254, TR8PC857, US7ASCII, US8PC437, UTF8, VN8MSWIN1258, VN8VN3, WE8DEC, WE8DG, WE8ISO8859P1, WE8ISO8859P15, WE8ISO8859P9, WE8MACROMAN8S, WE8MSWIN1252, WE8NCR4970, WE8NEXTSTEP, WE8PC850, WE8PC858, WE8PC860, WE8ROMAN8, ZHS16CGB231280, ZHS16GBK, ZHT16BIG5, ZHT16CCDC, ZHT16DBT, ZHT16HKSCS, ZHT16MSWIN950, ZHT32EUC, ZHT32SOPS, ZHT32TRIS
        """
        connection_strings: NotRequired[pulumi.Input[Sequence[pulumi.Input['DbHomeDatabaseConnectionStringArgsDict']]]]
        database_id: NotRequired[pulumi.Input[str]]
        """
        The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        database_software_image_id: NotRequired[pulumi.Input[str]]
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        db_backup_config: NotRequired[pulumi.Input['DbHomeDatabaseDbBackupConfigArgsDict']]
        """
        (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        """
        db_name: NotRequired[pulumi.Input[str]]
        """
        The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        """
        db_unique_name: NotRequired[pulumi.Input[str]]
        db_workload: NotRequired[pulumi.Input[str]]
        """
        **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.

        The database workload type.
        """
        defined_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        freeform_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        """
        key_store_id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store of Oracle Vault.
        """
        kms_key_id: NotRequired[pulumi.Input[str]]
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        kms_key_version_id: NotRequired[pulumi.Input[str]]
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        """
        lifecycle_details: NotRequired[pulumi.Input[str]]
        """
        Additional information about the current lifecycle state.
        """
        ncharacter_set: NotRequired[pulumi.Input[str]]
        """
        The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        """
        one_off_patches: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of one-off patches for Database Homes.
        """
        pdb_name: NotRequired[pulumi.Input[str]]
        """
        The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        """
        pluggable_databases: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of pluggable databases that needs to be restored into new database.
        """
        sid_prefix: NotRequired[pulumi.Input[str]]
        """
        Specifies a prefix for the `Oracle SID` of the database to be created.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        The current state of the Database Home.
        """
        tde_wallet_password: NotRequired[pulumi.Input[str]]
        """
        The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \\#, or -.
        """
        time_created: NotRequired[pulumi.Input[str]]
        """
        The date and time the Database Home was created.
        """
        time_stamp_for_point_in_time_recovery: NotRequired[pulumi.Input[str]]
        """
        The point in time of the original database from which the new database is created. If not specifed, the latest backup is used to create the database.
        """
        vault_id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
elif False:
    DbHomeDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbHomeDatabaseArgs:
    def __init__(__self__, *,
                 admin_password: pulumi.Input[str],
                 backup_id: Optional[pulumi.Input[str]] = None,
                 backup_tde_password: Optional[pulumi.Input[str]] = None,
                 character_set: Optional[pulumi.Input[str]] = None,
                 connection_strings: Optional[pulumi.Input[Sequence[pulumi.Input['DbHomeDatabaseConnectionStringArgs']]]] = None,
                 database_id: Optional[pulumi.Input[str]] = None,
                 database_software_image_id: Optional[pulumi.Input[str]] = None,
                 db_backup_config: Optional[pulumi.Input['DbHomeDatabaseDbBackupConfigArgs']] = None,
                 db_name: Optional[pulumi.Input[str]] = None,
                 db_unique_name: Optional[pulumi.Input[str]] = None,
                 db_workload: Optional[pulumi.Input[str]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 key_store_id: Optional[pulumi.Input[str]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 kms_key_version_id: Optional[pulumi.Input[str]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 ncharacter_set: Optional[pulumi.Input[str]] = None,
                 one_off_patches: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 pdb_name: Optional[pulumi.Input[str]] = None,
                 pluggable_databases: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sid_prefix: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 tde_wallet_password: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_stamp_for_point_in_time_recovery: Optional[pulumi.Input[str]] = None,
                 vault_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] admin_password: A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \\#, or -.
        :param pulumi.Input[str] backup_id: The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input[str] backup_tde_password: The password to open the TDE wallet.
        :param pulumi.Input[str] character_set: The character set for the database.  The default is AL32UTF8. Allowed values are:
               
               AL32UTF8, AR8ADOS710, AR8ADOS720, AR8APTEC715, AR8ARABICMACS, AR8ASMO8X, AR8ISO8859P6, AR8MSWIN1256, AR8MUSSAD768, AR8NAFITHA711, AR8NAFITHA721, AR8SAKHR706, AR8SAKHR707, AZ8ISO8859P9E, BG8MSWIN, BG8PC437S, BLT8CP921, BLT8ISO8859P13, BLT8MSWIN1257, BLT8PC775, BN8BSCII, CDN8PC863, CEL8ISO8859P14, CL8ISO8859P5, CL8ISOIR111, CL8KOI8R, CL8KOI8U, CL8MACCYRILLICS, CL8MSWIN1251, EE8ISO8859P2, EE8MACCES, EE8MACCROATIANS, EE8MSWIN1250, EE8PC852, EL8DEC, EL8ISO8859P7, EL8MACGREEKS, EL8MSWIN1253, EL8PC437S, EL8PC851, EL8PC869, ET8MSWIN923, HU8ABMOD, HU8CWI2, IN8ISCII, IS8PC861, IW8ISO8859P8, IW8MACHEBREWS, IW8MSWIN1255, IW8PC1507, JA16EUC, JA16EUCTILDE, JA16SJIS, JA16SJISTILDE, JA16VMS, KO16KSC5601, KO16KSCCS, KO16MSWIN949, LA8ISO6937, LA8PASSPORT, LT8MSWIN921, LT8PC772, LT8PC774, LV8PC1117, LV8PC8LR, LV8RST104090, N8PC865, NE8ISO8859P10, NEE8ISO8859P4, RU8BESTA, RU8PC855, RU8PC866, SE8ISO8859P3, TH8MACTHAIS, TH8TISASCII, TR8DEC, TR8MACTURKISHS, TR8MSWIN1254, TR8PC857, US7ASCII, US8PC437, UTF8, VN8MSWIN1258, VN8VN3, WE8DEC, WE8DG, WE8ISO8859P1, WE8ISO8859P15, WE8ISO8859P9, WE8MACROMAN8S, WE8MSWIN1252, WE8NCR4970, WE8NEXTSTEP, WE8PC850, WE8PC858, WE8PC860, WE8ROMAN8, ZHS16CGB231280, ZHS16GBK, ZHT16BIG5, ZHT16CCDC, ZHT16DBT, ZHT16HKSCS, ZHT16MSWIN950, ZHT32EUC, ZHT32SOPS, ZHT32TRIS
        :param pulumi.Input[str] database_id: The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input[str] database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        :param pulumi.Input['DbHomeDatabaseDbBackupConfigArgs'] db_backup_config: (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        :param pulumi.Input[str] db_name: The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        :param pulumi.Input[str] db_workload: **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.
               
               The database workload type.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] freeform_tags: (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        :param pulumi.Input[str] key_store_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store of Oracle Vault.
        :param pulumi.Input[str] kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param pulumi.Input[str] kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        :param pulumi.Input[str] lifecycle_details: Additional information about the current lifecycle state.
        :param pulumi.Input[str] ncharacter_set: The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] one_off_patches: List of one-off patches for Database Homes.
        :param pulumi.Input[str] pdb_name: The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pluggable_databases: The list of pluggable databases that needs to be restored into new database.
        :param pulumi.Input[str] sid_prefix: Specifies a prefix for the `Oracle SID` of the database to be created.
        :param pulumi.Input[str] state: The current state of the Database Home.
        :param pulumi.Input[str] tde_wallet_password: The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \\#, or -.
        :param pulumi.Input[str] time_created: The date and time the Database Home was created.
        :param pulumi.Input[str] time_stamp_for_point_in_time_recovery: The point in time of the original database from which the new database is created. If not specifed, the latest backup is used to create the database.
        :param pulumi.Input[str] vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        pulumi.set(__self__, "admin_password", admin_password)
        if backup_id is not None:
            pulumi.set(__self__, "backup_id", backup_id)
        if backup_tde_password is not None:
            pulumi.set(__self__, "backup_tde_password", backup_tde_password)
        if character_set is not None:
            pulumi.set(__self__, "character_set", character_set)
        if connection_strings is not None:
            pulumi.set(__self__, "connection_strings", connection_strings)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if database_software_image_id is not None:
            pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        if db_backup_config is not None:
            pulumi.set(__self__, "db_backup_config", db_backup_config)
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if db_unique_name is not None:
            pulumi.set(__self__, "db_unique_name", db_unique_name)
        if db_workload is not None:
            pulumi.set(__self__, "db_workload", db_workload)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if key_store_id is not None:
            pulumi.set(__self__, "key_store_id", key_store_id)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if kms_key_version_id is not None:
            pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if ncharacter_set is not None:
            pulumi.set(__self__, "ncharacter_set", ncharacter_set)
        if one_off_patches is not None:
            pulumi.set(__self__, "one_off_patches", one_off_patches)
        if pdb_name is not None:
            pulumi.set(__self__, "pdb_name", pdb_name)
        if pluggable_databases is not None:
            pulumi.set(__self__, "pluggable_databases", pluggable_databases)
        if sid_prefix is not None:
            pulumi.set(__self__, "sid_prefix", sid_prefix)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if tde_wallet_password is not None:
            pulumi.set(__self__, "tde_wallet_password", tde_wallet_password)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_stamp_for_point_in_time_recovery is not None:
            pulumi.set(__self__, "time_stamp_for_point_in_time_recovery", time_stamp_for_point_in_time_recovery)
        if vault_id is not None:
            pulumi.set(__self__, "vault_id", vault_id)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> pulumi.Input[str]:
        """
        A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \\#, or -.
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> Optional[pulumi.Input[str]]:
        """
        The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "backup_id")

    @backup_id.setter
    def backup_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_id", value)

    @property
    @pulumi.getter(name="backupTdePassword")
    def backup_tde_password(self) -> Optional[pulumi.Input[str]]:
        """
        The password to open the TDE wallet.
        """
        return pulumi.get(self, "backup_tde_password")

    @backup_tde_password.setter
    def backup_tde_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_tde_password", value)

    @property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> Optional[pulumi.Input[str]]:
        """
        The character set for the database.  The default is AL32UTF8. Allowed values are:

        AL32UTF8, AR8ADOS710, AR8ADOS720, AR8APTEC715, AR8ARABICMACS, AR8ASMO8X, AR8ISO8859P6, AR8MSWIN1256, AR8MUSSAD768, AR8NAFITHA711, AR8NAFITHA721, AR8SAKHR706, AR8SAKHR707, AZ8ISO8859P9E, BG8MSWIN, BG8PC437S, BLT8CP921, BLT8ISO8859P13, BLT8MSWIN1257, BLT8PC775, BN8BSCII, CDN8PC863, CEL8ISO8859P14, CL8ISO8859P5, CL8ISOIR111, CL8KOI8R, CL8KOI8U, CL8MACCYRILLICS, CL8MSWIN1251, EE8ISO8859P2, EE8MACCES, EE8MACCROATIANS, EE8MSWIN1250, EE8PC852, EL8DEC, EL8ISO8859P7, EL8MACGREEKS, EL8MSWIN1253, EL8PC437S, EL8PC851, EL8PC869, ET8MSWIN923, HU8ABMOD, HU8CWI2, IN8ISCII, IS8PC861, IW8ISO8859P8, IW8MACHEBREWS, IW8MSWIN1255, IW8PC1507, JA16EUC, JA16EUCTILDE, JA16SJIS, JA16SJISTILDE, JA16VMS, KO16KSC5601, KO16KSCCS, KO16MSWIN949, LA8ISO6937, LA8PASSPORT, LT8MSWIN921, LT8PC772, LT8PC774, LV8PC1117, LV8PC8LR, LV8RST104090, N8PC865, NE8ISO8859P10, NEE8ISO8859P4, RU8BESTA, RU8PC855, RU8PC866, SE8ISO8859P3, TH8MACTHAIS, TH8TISASCII, TR8DEC, TR8MACTURKISHS, TR8MSWIN1254, TR8PC857, US7ASCII, US8PC437, UTF8, VN8MSWIN1258, VN8VN3, WE8DEC, WE8DG, WE8ISO8859P1, WE8ISO8859P15, WE8ISO8859P9, WE8MACROMAN8S, WE8MSWIN1252, WE8NCR4970, WE8NEXTSTEP, WE8PC850, WE8PC858, WE8PC860, WE8ROMAN8, ZHS16CGB231280, ZHS16GBK, ZHT16BIG5, ZHT16CCDC, ZHT16DBT, ZHT16HKSCS, ZHT16MSWIN950, ZHT32EUC, ZHT32SOPS, ZHT32TRIS
        """
        return pulumi.get(self, "character_set")

    @character_set.setter
    def character_set(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "character_set", value)

    @property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DbHomeDatabaseConnectionStringArgs']]]]:
        return pulumi.get(self, "connection_strings")

    @connection_strings.setter
    def connection_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DbHomeDatabaseConnectionStringArgs']]]]):
        pulumi.set(self, "connection_strings", value)

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[pulumi.Input[str]]:
        """
        The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "database_id")

    @database_id.setter
    def database_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_id", value)

    @property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> Optional[pulumi.Input[str]]:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        return pulumi.get(self, "database_software_image_id")

    @database_software_image_id.setter
    def database_software_image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_software_image_id", value)

    @property
    @pulumi.getter(name="dbBackupConfig")
    def db_backup_config(self) -> Optional[pulumi.Input['DbHomeDatabaseDbBackupConfigArgs']]:
        """
        (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        """
        return pulumi.get(self, "db_backup_config")

    @db_backup_config.setter
    def db_backup_config(self, value: Optional[pulumi.Input['DbHomeDatabaseDbBackupConfigArgs']]):
        pulumi.set(self, "db_backup_config", value)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[pulumi.Input[str]]:
        """
        The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "db_unique_name")

    @db_unique_name.setter
    def db_unique_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_unique_name", value)

    @property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> Optional[pulumi.Input[str]]:
        """
        **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.

        The database workload type.
        """
        return pulumi.get(self, "db_workload")

    @db_workload.setter
    def db_workload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_workload", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="keyStoreId")
    def key_store_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store of Oracle Vault.
        """
        return pulumi.get(self, "key_store_id")

    @key_store_id.setter
    def key_store_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_store_id", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        """
        return pulumi.get(self, "kms_key_version_id")

    @kms_key_version_id.setter
    def kms_key_version_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_version_id", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> Optional[pulumi.Input[str]]:
        """
        The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        """
        return pulumi.get(self, "ncharacter_set")

    @ncharacter_set.setter
    def ncharacter_set(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ncharacter_set", value)

    @property
    @pulumi.getter(name="oneOffPatches")
    def one_off_patches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of one-off patches for Database Homes.
        """
        return pulumi.get(self, "one_off_patches")

    @one_off_patches.setter
    def one_off_patches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "one_off_patches", value)

    @property
    @pulumi.getter(name="pdbName")
    def pdb_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        """
        return pulumi.get(self, "pdb_name")

    @pdb_name.setter
    def pdb_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pdb_name", value)

    @property
    @pulumi.getter(name="pluggableDatabases")
    def pluggable_databases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of pluggable databases that needs to be restored into new database.
        """
        return pulumi.get(self, "pluggable_databases")

    @pluggable_databases.setter
    def pluggable_databases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "pluggable_databases", value)

    @property
    @pulumi.getter(name="sidPrefix")
    def sid_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a prefix for the `Oracle SID` of the database to be created.
        """
        return pulumi.get(self, "sid_prefix")

    @sid_prefix.setter
    def sid_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sid_prefix", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the Database Home.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="tdeWalletPassword")
    def tde_wallet_password(self) -> Optional[pulumi.Input[str]]:
        """
        The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \\#, or -.
        """
        return pulumi.get(self, "tde_wallet_password")

    @tde_wallet_password.setter
    def tde_wallet_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tde_wallet_password", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the Database Home was created.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeStampForPointInTimeRecovery")
    def time_stamp_for_point_in_time_recovery(self) -> Optional[pulumi.Input[str]]:
        """
        The point in time of the original database from which the new database is created. If not specifed, the latest backup is used to create the database.
        """
        return pulumi.get(self, "time_stamp_for_point_in_time_recovery")

    @time_stamp_for_point_in_time_recovery.setter
    def time_stamp_for_point_in_time_recovery(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_stamp_for_point_in_time_recovery", value)

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        return pulumi.get(self, "vault_id")

    @vault_id.setter
    def vault_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vault_id", value)


if not MYPY:
    class DbHomeDatabaseConnectionStringArgsDict(TypedDict):
        all_connection_strings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        cdb_default: NotRequired[pulumi.Input[str]]
        cdb_ip_default: NotRequired[pulumi.Input[str]]
elif False:
    DbHomeDatabaseConnectionStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbHomeDatabaseConnectionStringArgs:
    def __init__(__self__, *,
                 all_connection_strings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 cdb_default: Optional[pulumi.Input[str]] = None,
                 cdb_ip_default: Optional[pulumi.Input[str]] = None):
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if cdb_default is not None:
            pulumi.set(__self__, "cdb_default", cdb_default)
        if cdb_ip_default is not None:
            pulumi.set(__self__, "cdb_ip_default", cdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "all_connection_strings")

    @all_connection_strings.setter
    def all_connection_strings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "all_connection_strings", value)

    @property
    @pulumi.getter(name="cdbDefault")
    def cdb_default(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cdb_default")

    @cdb_default.setter
    def cdb_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cdb_default", value)

    @property
    @pulumi.getter(name="cdbIpDefault")
    def cdb_ip_default(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cdb_ip_default")

    @cdb_ip_default.setter
    def cdb_ip_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cdb_ip_default", value)


if not MYPY:
    class DbHomeDatabaseDbBackupConfigArgsDict(TypedDict):
        auto_backup_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        auto_backup_window: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        auto_full_backup_day: NotRequired[pulumi.Input[str]]
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        auto_full_backup_window: NotRequired[pulumi.Input[str]]
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        backup_deletion_policy: NotRequired[pulumi.Input[str]]
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        backup_destination_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['DbHomeDatabaseDbBackupConfigBackupDestinationDetailArgsDict']]]]
        """
        Backup destination details.
        """
        recovery_window_in_days: NotRequired[pulumi.Input[int]]
        """
        (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        run_immediate_full_backup: NotRequired[pulumi.Input[bool]]
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
elif False:
    DbHomeDatabaseDbBackupConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbHomeDatabaseDbBackupConfigArgs:
    def __init__(__self__, *,
                 auto_backup_enabled: Optional[pulumi.Input[bool]] = None,
                 auto_backup_window: Optional[pulumi.Input[str]] = None,
                 auto_full_backup_day: Optional[pulumi.Input[str]] = None,
                 auto_full_backup_window: Optional[pulumi.Input[str]] = None,
                 backup_deletion_policy: Optional[pulumi.Input[str]] = None,
                 backup_destination_details: Optional[pulumi.Input[Sequence[pulumi.Input['DbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs']]]] = None,
                 recovery_window_in_days: Optional[pulumi.Input[int]] = None,
                 run_immediate_full_backup: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] auto_backup_enabled: (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param pulumi.Input[str] auto_backup_window: (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param pulumi.Input[str] auto_full_backup_day: Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        :param pulumi.Input[str] auto_full_backup_window: Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param pulumi.Input[str] backup_deletion_policy: This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        :param pulumi.Input[Sequence[pulumi.Input['DbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs']]] backup_destination_details: Backup destination details.
        :param pulumi.Input[int] recovery_window_in_days: (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        :param pulumi.Input[bool] run_immediate_full_backup: If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        if auto_backup_enabled is not None:
            pulumi.set(__self__, "auto_backup_enabled", auto_backup_enabled)
        if auto_backup_window is not None:
            pulumi.set(__self__, "auto_backup_window", auto_backup_window)
        if auto_full_backup_day is not None:
            pulumi.set(__self__, "auto_full_backup_day", auto_full_backup_day)
        if auto_full_backup_window is not None:
            pulumi.set(__self__, "auto_full_backup_window", auto_full_backup_window)
        if backup_deletion_policy is not None:
            pulumi.set(__self__, "backup_deletion_policy", backup_deletion_policy)
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)
        if run_immediate_full_backup is not None:
            pulumi.set(__self__, "run_immediate_full_backup", run_immediate_full_backup)

    @property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @auto_backup_enabled.setter
    def auto_backup_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_backup_enabled", value)

    @property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @auto_backup_window.setter
    def auto_backup_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_backup_window", value)

    @property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> Optional[pulumi.Input[str]]:
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        return pulumi.get(self, "auto_full_backup_day")

    @auto_full_backup_day.setter
    def auto_full_backup_day(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_full_backup_day", value)

    @property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> Optional[pulumi.Input[str]]:
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_full_backup_window")

    @auto_full_backup_window.setter
    def auto_full_backup_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_full_backup_window", value)

    @property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> Optional[pulumi.Input[str]]:
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        return pulumi.get(self, "backup_deletion_policy")

    @backup_deletion_policy.setter
    def backup_deletion_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_deletion_policy", value)

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs']]]]:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @backup_destination_details.setter
    def backup_destination_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs']]]]):
        pulumi.set(self, "backup_destination_details", value)

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @recovery_window_in_days.setter
    def recovery_window_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "recovery_window_in_days", value)

    @property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        return pulumi.get(self, "run_immediate_full_backup")

    @run_immediate_full_backup.setter
    def run_immediate_full_backup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_immediate_full_backup", value)


if not MYPY:
    class DbHomeDatabaseDbBackupConfigBackupDestinationDetailArgsDict(TypedDict):
        dbrs_policy_id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of the database backup destination. Supported values: `NFS`.
        """
elif False:
    DbHomeDatabaseDbBackupConfigBackupDestinationDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs:
    def __init__(__self__, *,
                 dbrs_policy_id: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param pulumi.Input[str] type: Type of the database backup destination. Supported values: `NFS`.
        """
        if dbrs_policy_id is not None:
            pulumi.set(__self__, "dbrs_policy_id", dbrs_policy_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @dbrs_policy_id.setter
    def dbrs_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dbrs_policy_id", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the database backup destination. Supported values: `NFS`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DbSystemDataCollectionOptionsArgsDict(TypedDict):
        is_diagnostics_events_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        is_health_monitoring_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        is_incident_logs_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
elif False:
    DbSystemDataCollectionOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbSystemDataCollectionOptionsArgs:
    def __init__(__self__, *,
                 is_diagnostics_events_enabled: Optional[pulumi.Input[bool]] = None,
                 is_health_monitoring_enabled: Optional[pulumi.Input[bool]] = None,
                 is_incident_logs_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_diagnostics_events_enabled: (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param pulumi.Input[bool] is_health_monitoring_enabled: (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param pulumi.Input[bool] is_incident_logs_enabled: (Updatable) Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        if is_diagnostics_events_enabled is not None:
            pulumi.set(__self__, "is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        if is_health_monitoring_enabled is not None:
            pulumi.set(__self__, "is_health_monitoring_enabled", is_health_monitoring_enabled)
        if is_incident_logs_enabled is not None:
            pulumi.set(__self__, "is_incident_logs_enabled", is_incident_logs_enabled)

    @property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @is_diagnostics_events_enabled.setter
    def is_diagnostics_events_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_diagnostics_events_enabled", value)

    @property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @is_health_monitoring_enabled.setter
    def is_health_monitoring_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_health_monitoring_enabled", value)

    @property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")

    @is_incident_logs_enabled.setter
    def is_incident_logs_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_incident_logs_enabled", value)


if not MYPY:
    class DbSystemDbHomeArgsDict(TypedDict):
        database: pulumi.Input['DbSystemDbHomeDatabaseArgsDict']
        """
        (Updatable) Details for creating a database by restoring from a source database system.

        **Warning:** Oracle recommends that you avoid using any confidential information when you supply string values using the API.
        """
        create_async: NotRequired[pulumi.Input[bool]]
        database_software_image_id: NotRequired[pulumi.Input[str]]
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the image to be used to restore a database.
        """
        db_home_location: NotRequired[pulumi.Input[str]]
        db_version: NotRequired[pulumi.Input[str]]
        """
        A valid Oracle Database version. For a list of supported versions, use the ListDbVersions operation.

        This cannot be updated in parallel with any of the following: licenseModel, dbEdition, cpuCoreCount, computeCount, computeModel, adminPassword, whitelistedIps, isMTLSConnectionRequired, openMode, permissionLevel, dbWorkload, privateEndpointLabel, nsgIds, isRefreshable, dbName, scheduledOperations, dbToolsDetails, isLocalDataGuardEnabled, or isFreeTier.
        """
        defined_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        The user-provided name of the Database Home.
        """
        freeform_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        """
        is_unified_auditing_enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether unified auditing is enabled or not
        """
        last_patch_history_entry_id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last patch history. This value is updated as soon as a patch operation starts.
        """
        lifecycle_details: NotRequired[pulumi.Input[str]]
        """
        Additional information about the current lifecycle state.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        The current state of the DB system.
        """
        time_created: NotRequired[pulumi.Input[str]]
        """
        The date and time the DB system was created.
        """
elif False:
    DbSystemDbHomeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbSystemDbHomeArgs:
    def __init__(__self__, *,
                 database: pulumi.Input['DbSystemDbHomeDatabaseArgs'],
                 create_async: Optional[pulumi.Input[bool]] = None,
                 database_software_image_id: Optional[pulumi.Input[str]] = None,
                 db_home_location: Optional[pulumi.Input[str]] = None,
                 db_version: Optional[pulumi.Input[str]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 is_unified_auditing_enabled: Optional[pulumi.Input[bool]] = None,
                 last_patch_history_entry_id: Optional[pulumi.Input[str]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DbSystemDbHomeDatabaseArgs'] database: (Updatable) Details for creating a database by restoring from a source database system.
               
               **Warning:** Oracle recommends that you avoid using any confidential information when you supply string values using the API.
        :param pulumi.Input[str] database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the image to be used to restore a database.
        :param pulumi.Input[str] db_version: A valid Oracle Database version. For a list of supported versions, use the ListDbVersions operation.
               
               This cannot be updated in parallel with any of the following: licenseModel, dbEdition, cpuCoreCount, computeCount, computeModel, adminPassword, whitelistedIps, isMTLSConnectionRequired, openMode, permissionLevel, dbWorkload, privateEndpointLabel, nsgIds, isRefreshable, dbName, scheduledOperations, dbToolsDetails, isLocalDataGuardEnabled, or isFreeTier.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param pulumi.Input[str] display_name: The user-provided name of the Database Home.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        :param pulumi.Input[bool] is_unified_auditing_enabled: Indicates whether unified auditing is enabled or not
        :param pulumi.Input[str] last_patch_history_entry_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last patch history. This value is updated as soon as a patch operation starts.
        :param pulumi.Input[str] lifecycle_details: Additional information about the current lifecycle state.
        :param pulumi.Input[str] state: The current state of the DB system.
        :param pulumi.Input[str] time_created: The date and time the DB system was created.
        """
        pulumi.set(__self__, "database", database)
        if create_async is not None:
            pulumi.set(__self__, "create_async", create_async)
        if database_software_image_id is not None:
            pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        if db_home_location is not None:
            pulumi.set(__self__, "db_home_location", db_home_location)
        if db_version is not None:
            pulumi.set(__self__, "db_version", db_version)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_unified_auditing_enabled is not None:
            pulumi.set(__self__, "is_unified_auditing_enabled", is_unified_auditing_enabled)
        if last_patch_history_entry_id is not None:
            pulumi.set(__self__, "last_patch_history_entry_id", last_patch_history_entry_id)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input['DbSystemDbHomeDatabaseArgs']:
        """
        (Updatable) Details for creating a database by restoring from a source database system.

        **Warning:** Oracle recommends that you avoid using any confidential information when you supply string values using the API.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input['DbSystemDbHomeDatabaseArgs']):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="createAsync")
    def create_async(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "create_async")

    @create_async.setter
    def create_async(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "create_async", value)

    @property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> Optional[pulumi.Input[str]]:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the image to be used to restore a database.
        """
        return pulumi.get(self, "database_software_image_id")

    @database_software_image_id.setter
    def database_software_image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_software_image_id", value)

    @property
    @pulumi.getter(name="dbHomeLocation")
    def db_home_location(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "db_home_location")

    @db_home_location.setter
    def db_home_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_home_location", value)

    @property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> Optional[pulumi.Input[str]]:
        """
        A valid Oracle Database version. For a list of supported versions, use the ListDbVersions operation.

        This cannot be updated in parallel with any of the following: licenseModel, dbEdition, cpuCoreCount, computeCount, computeModel, adminPassword, whitelistedIps, isMTLSConnectionRequired, openMode, permissionLevel, dbWorkload, privateEndpointLabel, nsgIds, isRefreshable, dbName, scheduledOperations, dbToolsDetails, isLocalDataGuardEnabled, or isFreeTier.
        """
        return pulumi.get(self, "db_version")

    @db_version.setter
    def db_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_version", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        The user-provided name of the Database Home.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="isUnifiedAuditingEnabled")
    def is_unified_auditing_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether unified auditing is enabled or not
        """
        return pulumi.get(self, "is_unified_auditing_enabled")

    @is_unified_auditing_enabled.setter
    def is_unified_auditing_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_unified_auditing_enabled", value)

    @property
    @pulumi.getter(name="lastPatchHistoryEntryId")
    def last_patch_history_entry_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last patch history. This value is updated as soon as a patch operation starts.
        """
        return pulumi.get(self, "last_patch_history_entry_id")

    @last_patch_history_entry_id.setter
    def last_patch_history_entry_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_patch_history_entry_id", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the DB system.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the DB system was created.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)


if not MYPY:
    class DbSystemDbHomeDatabaseArgsDict(TypedDict):
        admin_password: pulumi.Input[str]
        """
        A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \\#, or -.
        """
        backup_id: NotRequired[pulumi.Input[str]]
        """
        The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        backup_tde_password: NotRequired[pulumi.Input[str]]
        """
        The password to open the TDE wallet.
        """
        character_set: NotRequired[pulumi.Input[str]]
        """
        The character set for the database.  The default is AL32UTF8. Allowed values are:

        AL32UTF8, AR8ADOS710, AR8ADOS720, AR8APTEC715, AR8ARABICMACS, AR8ASMO8X, AR8ISO8859P6, AR8MSWIN1256, AR8MUSSAD768, AR8NAFITHA711, AR8NAFITHA721, AR8SAKHR706, AR8SAKHR707, AZ8ISO8859P9E, BG8MSWIN, BG8PC437S, BLT8CP921, BLT8ISO8859P13, BLT8MSWIN1257, BLT8PC775, BN8BSCII, CDN8PC863, CEL8ISO8859P14, CL8ISO8859P5, CL8ISOIR111, CL8KOI8R, CL8KOI8U, CL8MACCYRILLICS, CL8MSWIN1251, EE8ISO8859P2, EE8MACCES, EE8MACCROATIANS, EE8MSWIN1250, EE8PC852, EL8DEC, EL8ISO8859P7, EL8MACGREEKS, EL8MSWIN1253, EL8PC437S, EL8PC851, EL8PC869, ET8MSWIN923, HU8ABMOD, HU8CWI2, IN8ISCII, IS8PC861, IW8ISO8859P8, IW8MACHEBREWS, IW8MSWIN1255, IW8PC1507, JA16EUC, JA16EUCTILDE, JA16SJIS, JA16SJISTILDE, JA16VMS, KO16KSC5601, KO16KSCCS, KO16MSWIN949, LA8ISO6937, LA8PASSPORT, LT8MSWIN921, LT8PC772, LT8PC774, LV8PC1117, LV8PC8LR, LV8RST104090, N8PC865, NE8ISO8859P10, NEE8ISO8859P4, RU8BESTA, RU8PC855, RU8PC866, SE8ISO8859P3, TH8MACTHAIS, TH8TISASCII, TR8DEC, TR8MACTURKISHS, TR8MSWIN1254, TR8PC857, US7ASCII, US8PC437, UTF8, VN8MSWIN1258, VN8VN3, WE8DEC, WE8DG, WE8ISO8859P1, WE8ISO8859P15, WE8ISO8859P9, WE8MACROMAN8S, WE8MSWIN1252, WE8NCR4970, WE8NEXTSTEP, WE8PC850, WE8PC858, WE8PC860, WE8ROMAN8, ZHS16CGB231280, ZHS16GBK, ZHT16BIG5, ZHT16CCDC, ZHT16DBT, ZHT16HKSCS, ZHT16MSWIN950, ZHT32EUC, ZHT32SOPS, ZHT32TRIS
        """
        connection_strings: NotRequired[pulumi.Input[Sequence[pulumi.Input['DbSystemDbHomeDatabaseConnectionStringArgsDict']]]]
        database_id: NotRequired[pulumi.Input[str]]
        """
        The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        database_software_image_id: NotRequired[pulumi.Input[str]]
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        db_backup_config: NotRequired[pulumi.Input['DbSystemDbHomeDatabaseDbBackupConfigArgsDict']]
        """
        (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        """
        db_domain: NotRequired[pulumi.Input[str]]
        """
        The database domain. In a distributed database system, DB_DOMAIN specifies the logical location of the database within the network structure.
        """
        db_name: NotRequired[pulumi.Input[str]]
        """
        The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        """
        db_unique_name: NotRequired[pulumi.Input[str]]
        """
        The `DB_UNIQUE_NAME` of the Oracle Database.
        """
        db_workload: NotRequired[pulumi.Input[str]]
        """
        **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.

        The database workload type.
        """
        defined_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        freeform_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        """
        kms_key_id: NotRequired[pulumi.Input[str]]
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        kms_key_version_id: NotRequired[pulumi.Input[str]]
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        """
        lifecycle_details: NotRequired[pulumi.Input[str]]
        """
        Additional information about the current lifecycle state.
        """
        ncharacter_set: NotRequired[pulumi.Input[str]]
        """
        The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        """
        pdb_name: NotRequired[pulumi.Input[str]]
        """
        The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        """
        pluggable_databases: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of pluggable databases that needs to be restored into new database.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        The current state of the DB system.
        """
        tde_wallet_password: NotRequired[pulumi.Input[str]]
        """
        The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \\#, or -.
        """
        time_created: NotRequired[pulumi.Input[str]]
        """
        The date and time the DB system was created.
        """
        time_stamp_for_point_in_time_recovery: NotRequired[pulumi.Input[str]]
        """
        The point in time of the original database from which the new database is created. If not specifed, the latest backup is used to create the database.
        """
        vault_id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
elif False:
    DbSystemDbHomeDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbSystemDbHomeDatabaseArgs:
    def __init__(__self__, *,
                 admin_password: pulumi.Input[str],
                 backup_id: Optional[pulumi.Input[str]] = None,
                 backup_tde_password: Optional[pulumi.Input[str]] = None,
                 character_set: Optional[pulumi.Input[str]] = None,
                 connection_strings: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemDbHomeDatabaseConnectionStringArgs']]]] = None,
                 database_id: Optional[pulumi.Input[str]] = None,
                 database_software_image_id: Optional[pulumi.Input[str]] = None,
                 db_backup_config: Optional[pulumi.Input['DbSystemDbHomeDatabaseDbBackupConfigArgs']] = None,
                 db_domain: Optional[pulumi.Input[str]] = None,
                 db_name: Optional[pulumi.Input[str]] = None,
                 db_unique_name: Optional[pulumi.Input[str]] = None,
                 db_workload: Optional[pulumi.Input[str]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 kms_key_version_id: Optional[pulumi.Input[str]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 ncharacter_set: Optional[pulumi.Input[str]] = None,
                 pdb_name: Optional[pulumi.Input[str]] = None,
                 pluggable_databases: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 tde_wallet_password: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_stamp_for_point_in_time_recovery: Optional[pulumi.Input[str]] = None,
                 vault_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] admin_password: A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \\#, or -.
        :param pulumi.Input[str] backup_id: The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input[str] backup_tde_password: The password to open the TDE wallet.
        :param pulumi.Input[str] character_set: The character set for the database.  The default is AL32UTF8. Allowed values are:
               
               AL32UTF8, AR8ADOS710, AR8ADOS720, AR8APTEC715, AR8ARABICMACS, AR8ASMO8X, AR8ISO8859P6, AR8MSWIN1256, AR8MUSSAD768, AR8NAFITHA711, AR8NAFITHA721, AR8SAKHR706, AR8SAKHR707, AZ8ISO8859P9E, BG8MSWIN, BG8PC437S, BLT8CP921, BLT8ISO8859P13, BLT8MSWIN1257, BLT8PC775, BN8BSCII, CDN8PC863, CEL8ISO8859P14, CL8ISO8859P5, CL8ISOIR111, CL8KOI8R, CL8KOI8U, CL8MACCYRILLICS, CL8MSWIN1251, EE8ISO8859P2, EE8MACCES, EE8MACCROATIANS, EE8MSWIN1250, EE8PC852, EL8DEC, EL8ISO8859P7, EL8MACGREEKS, EL8MSWIN1253, EL8PC437S, EL8PC851, EL8PC869, ET8MSWIN923, HU8ABMOD, HU8CWI2, IN8ISCII, IS8PC861, IW8ISO8859P8, IW8MACHEBREWS, IW8MSWIN1255, IW8PC1507, JA16EUC, JA16EUCTILDE, JA16SJIS, JA16SJISTILDE, JA16VMS, KO16KSC5601, KO16KSCCS, KO16MSWIN949, LA8ISO6937, LA8PASSPORT, LT8MSWIN921, LT8PC772, LT8PC774, LV8PC1117, LV8PC8LR, LV8RST104090, N8PC865, NE8ISO8859P10, NEE8ISO8859P4, RU8BESTA, RU8PC855, RU8PC866, SE8ISO8859P3, TH8MACTHAIS, TH8TISASCII, TR8DEC, TR8MACTURKISHS, TR8MSWIN1254, TR8PC857, US7ASCII, US8PC437, UTF8, VN8MSWIN1258, VN8VN3, WE8DEC, WE8DG, WE8ISO8859P1, WE8ISO8859P15, WE8ISO8859P9, WE8MACROMAN8S, WE8MSWIN1252, WE8NCR4970, WE8NEXTSTEP, WE8PC850, WE8PC858, WE8PC860, WE8ROMAN8, ZHS16CGB231280, ZHS16GBK, ZHT16BIG5, ZHT16CCDC, ZHT16DBT, ZHT16HKSCS, ZHT16MSWIN950, ZHT32EUC, ZHT32SOPS, ZHT32TRIS
        :param pulumi.Input[str] database_id: The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input[str] database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        :param pulumi.Input['DbSystemDbHomeDatabaseDbBackupConfigArgs'] db_backup_config: (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        :param pulumi.Input[str] db_domain: The database domain. In a distributed database system, DB_DOMAIN specifies the logical location of the database within the network structure.
        :param pulumi.Input[str] db_name: The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        :param pulumi.Input[str] db_unique_name: The `DB_UNIQUE_NAME` of the Oracle Database.
        :param pulumi.Input[str] db_workload: **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.
               
               The database workload type.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] freeform_tags: (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        :param pulumi.Input[str] kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param pulumi.Input[str] kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        :param pulumi.Input[str] lifecycle_details: Additional information about the current lifecycle state.
        :param pulumi.Input[str] ncharacter_set: The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        :param pulumi.Input[str] pdb_name: The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pluggable_databases: The list of pluggable databases that needs to be restored into new database.
        :param pulumi.Input[str] state: The current state of the DB system.
        :param pulumi.Input[str] tde_wallet_password: The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \\#, or -.
        :param pulumi.Input[str] time_created: The date and time the DB system was created.
        :param pulumi.Input[str] time_stamp_for_point_in_time_recovery: The point in time of the original database from which the new database is created. If not specifed, the latest backup is used to create the database.
        :param pulumi.Input[str] vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        pulumi.set(__self__, "admin_password", admin_password)
        if backup_id is not None:
            pulumi.set(__self__, "backup_id", backup_id)
        if backup_tde_password is not None:
            pulumi.set(__self__, "backup_tde_password", backup_tde_password)
        if character_set is not None:
            pulumi.set(__self__, "character_set", character_set)
        if connection_strings is not None:
            pulumi.set(__self__, "connection_strings", connection_strings)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if database_software_image_id is not None:
            pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        if db_backup_config is not None:
            pulumi.set(__self__, "db_backup_config", db_backup_config)
        if db_domain is not None:
            pulumi.set(__self__, "db_domain", db_domain)
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if db_unique_name is not None:
            pulumi.set(__self__, "db_unique_name", db_unique_name)
        if db_workload is not None:
            pulumi.set(__self__, "db_workload", db_workload)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if kms_key_version_id is not None:
            pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if ncharacter_set is not None:
            pulumi.set(__self__, "ncharacter_set", ncharacter_set)
        if pdb_name is not None:
            pulumi.set(__self__, "pdb_name", pdb_name)
        if pluggable_databases is not None:
            pulumi.set(__self__, "pluggable_databases", pluggable_databases)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if tde_wallet_password is not None:
            pulumi.set(__self__, "tde_wallet_password", tde_wallet_password)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_stamp_for_point_in_time_recovery is not None:
            pulumi.set(__self__, "time_stamp_for_point_in_time_recovery", time_stamp_for_point_in_time_recovery)
        if vault_id is not None:
            pulumi.set(__self__, "vault_id", vault_id)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> pulumi.Input[str]:
        """
        A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \\#, or -.
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> Optional[pulumi.Input[str]]:
        """
        The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "backup_id")

    @backup_id.setter
    def backup_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_id", value)

    @property
    @pulumi.getter(name="backupTdePassword")
    def backup_tde_password(self) -> Optional[pulumi.Input[str]]:
        """
        The password to open the TDE wallet.
        """
        return pulumi.get(self, "backup_tde_password")

    @backup_tde_password.setter
    def backup_tde_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_tde_password", value)

    @property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> Optional[pulumi.Input[str]]:
        """
        The character set for the database.  The default is AL32UTF8. Allowed values are:

        AL32UTF8, AR8ADOS710, AR8ADOS720, AR8APTEC715, AR8ARABICMACS, AR8ASMO8X, AR8ISO8859P6, AR8MSWIN1256, AR8MUSSAD768, AR8NAFITHA711, AR8NAFITHA721, AR8SAKHR706, AR8SAKHR707, AZ8ISO8859P9E, BG8MSWIN, BG8PC437S, BLT8CP921, BLT8ISO8859P13, BLT8MSWIN1257, BLT8PC775, BN8BSCII, CDN8PC863, CEL8ISO8859P14, CL8ISO8859P5, CL8ISOIR111, CL8KOI8R, CL8KOI8U, CL8MACCYRILLICS, CL8MSWIN1251, EE8ISO8859P2, EE8MACCES, EE8MACCROATIANS, EE8MSWIN1250, EE8PC852, EL8DEC, EL8ISO8859P7, EL8MACGREEKS, EL8MSWIN1253, EL8PC437S, EL8PC851, EL8PC869, ET8MSWIN923, HU8ABMOD, HU8CWI2, IN8ISCII, IS8PC861, IW8ISO8859P8, IW8MACHEBREWS, IW8MSWIN1255, IW8PC1507, JA16EUC, JA16EUCTILDE, JA16SJIS, JA16SJISTILDE, JA16VMS, KO16KSC5601, KO16KSCCS, KO16MSWIN949, LA8ISO6937, LA8PASSPORT, LT8MSWIN921, LT8PC772, LT8PC774, LV8PC1117, LV8PC8LR, LV8RST104090, N8PC865, NE8ISO8859P10, NEE8ISO8859P4, RU8BESTA, RU8PC855, RU8PC866, SE8ISO8859P3, TH8MACTHAIS, TH8TISASCII, TR8DEC, TR8MACTURKISHS, TR8MSWIN1254, TR8PC857, US7ASCII, US8PC437, UTF8, VN8MSWIN1258, VN8VN3, WE8DEC, WE8DG, WE8ISO8859P1, WE8ISO8859P15, WE8ISO8859P9, WE8MACROMAN8S, WE8MSWIN1252, WE8NCR4970, WE8NEXTSTEP, WE8PC850, WE8PC858, WE8PC860, WE8ROMAN8, ZHS16CGB231280, ZHS16GBK, ZHT16BIG5, ZHT16CCDC, ZHT16DBT, ZHT16HKSCS, ZHT16MSWIN950, ZHT32EUC, ZHT32SOPS, ZHT32TRIS
        """
        return pulumi.get(self, "character_set")

    @character_set.setter
    def character_set(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "character_set", value)

    @property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemDbHomeDatabaseConnectionStringArgs']]]]:
        return pulumi.get(self, "connection_strings")

    @connection_strings.setter
    def connection_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemDbHomeDatabaseConnectionStringArgs']]]]):
        pulumi.set(self, "connection_strings", value)

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[pulumi.Input[str]]:
        """
        The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "database_id")

    @database_id.setter
    def database_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_id", value)

    @property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> Optional[pulumi.Input[str]]:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        return pulumi.get(self, "database_software_image_id")

    @database_software_image_id.setter
    def database_software_image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_software_image_id", value)

    @property
    @pulumi.getter(name="dbBackupConfig")
    def db_backup_config(self) -> Optional[pulumi.Input['DbSystemDbHomeDatabaseDbBackupConfigArgs']]:
        """
        (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        """
        return pulumi.get(self, "db_backup_config")

    @db_backup_config.setter
    def db_backup_config(self, value: Optional[pulumi.Input['DbSystemDbHomeDatabaseDbBackupConfigArgs']]):
        pulumi.set(self, "db_backup_config", value)

    @property
    @pulumi.getter(name="dbDomain")
    def db_domain(self) -> Optional[pulumi.Input[str]]:
        """
        The database domain. In a distributed database system, DB_DOMAIN specifies the logical location of the database within the network structure.
        """
        return pulumi.get(self, "db_domain")

    @db_domain.setter
    def db_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_domain", value)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[pulumi.Input[str]]:
        """
        The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> Optional[pulumi.Input[str]]:
        """
        The `DB_UNIQUE_NAME` of the Oracle Database.
        """
        return pulumi.get(self, "db_unique_name")

    @db_unique_name.setter
    def db_unique_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_unique_name", value)

    @property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> Optional[pulumi.Input[str]]:
        """
        **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.

        The database workload type.
        """
        return pulumi.get(self, "db_workload")

    @db_workload.setter
    def db_workload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_workload", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation. Autonomous Database Serverless does not use key versions, hence is not applicable for Autonomous Database Serverless instances.
        """
        return pulumi.get(self, "kms_key_version_id")

    @kms_key_version_id.setter
    def kms_key_version_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_version_id", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> Optional[pulumi.Input[str]]:
        """
        The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        """
        return pulumi.get(self, "ncharacter_set")

    @ncharacter_set.setter
    def ncharacter_set(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ncharacter_set", value)

    @property
    @pulumi.getter(name="pdbName")
    def pdb_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        """
        return pulumi.get(self, "pdb_name")

    @pdb_name.setter
    def pdb_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pdb_name", value)

    @property
    @pulumi.getter(name="pluggableDatabases")
    def pluggable_databases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of pluggable databases that needs to be restored into new database.
        """
        return pulumi.get(self, "pluggable_databases")

    @pluggable_databases.setter
    def pluggable_databases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "pluggable_databases", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the DB system.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="tdeWalletPassword")
    def tde_wallet_password(self) -> Optional[pulumi.Input[str]]:
        """
        The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \\#, or -.
        """
        return pulumi.get(self, "tde_wallet_password")

    @tde_wallet_password.setter
    def tde_wallet_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tde_wallet_password", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the DB system was created.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeStampForPointInTimeRecovery")
    def time_stamp_for_point_in_time_recovery(self) -> Optional[pulumi.Input[str]]:
        """
        The point in time of the original database from which the new database is created. If not specifed, the latest backup is used to create the database.
        """
        return pulumi.get(self, "time_stamp_for_point_in_time_recovery")

    @time_stamp_for_point_in_time_recovery.setter
    def time_stamp_for_point_in_time_recovery(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_stamp_for_point_in_time_recovery", value)

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
        """
        return pulumi.get(self, "vault_id")

    @vault_id.setter
    def vault_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vault_id", value)


if not MYPY:
    class DbSystemDbHomeDatabaseConnectionStringArgsDict(TypedDict):
        all_connection_strings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        cdb_default: NotRequired[pulumi.Input[str]]
        cdb_ip_default: NotRequired[pulumi.Input[str]]
elif False:
    DbSystemDbHomeDatabaseConnectionStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbSystemDbHomeDatabaseConnectionStringArgs:
    def __init__(__self__, *,
                 all_connection_strings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 cdb_default: Optional[pulumi.Input[str]] = None,
                 cdb_ip_default: Optional[pulumi.Input[str]] = None):
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if cdb_default is not None:
            pulumi.set(__self__, "cdb_default", cdb_default)
        if cdb_ip_default is not None:
            pulumi.set(__self__, "cdb_ip_default", cdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "all_connection_strings")

    @all_connection_strings.setter
    def all_connection_strings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "all_connection_strings", value)

    @property
    @pulumi.getter(name="cdbDefault")
    def cdb_default(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cdb_default")

    @cdb_default.setter
    def cdb_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cdb_default", value)

    @property
    @pulumi.getter(name="cdbIpDefault")
    def cdb_ip_default(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cdb_ip_default")

    @cdb_ip_default.setter
    def cdb_ip_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cdb_ip_default", value)


if not MYPY:
    class DbSystemDbHomeDatabaseDbBackupConfigArgsDict(TypedDict):
        auto_backup_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        auto_backup_window: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        auto_full_backup_day: NotRequired[pulumi.Input[str]]
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        auto_full_backup_window: NotRequired[pulumi.Input[str]]
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        backup_deletion_policy: NotRequired[pulumi.Input[str]]
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        backup_destination_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailArgsDict']]]]
        """
        (Updatable) Backup destination details.
        """
        recovery_window_in_days: NotRequired[pulumi.Input[int]]
        """
        (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        run_immediate_full_backup: NotRequired[pulumi.Input[bool]]
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
elif False:
    DbSystemDbHomeDatabaseDbBackupConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbSystemDbHomeDatabaseDbBackupConfigArgs:
    def __init__(__self__, *,
                 auto_backup_enabled: Optional[pulumi.Input[bool]] = None,
                 auto_backup_window: Optional[pulumi.Input[str]] = None,
                 auto_full_backup_day: Optional[pulumi.Input[str]] = None,
                 auto_full_backup_window: Optional[pulumi.Input[str]] = None,
                 backup_deletion_policy: Optional[pulumi.Input[str]] = None,
                 backup_destination_details: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs']]]] = None,
                 recovery_window_in_days: Optional[pulumi.Input[int]] = None,
                 run_immediate_full_backup: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] auto_backup_enabled: (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param pulumi.Input[str] auto_backup_window: (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param pulumi.Input[str] auto_full_backup_day: Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        :param pulumi.Input[str] auto_full_backup_window: Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param pulumi.Input[str] backup_deletion_policy: This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        :param pulumi.Input[Sequence[pulumi.Input['DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs']]] backup_destination_details: (Updatable) Backup destination details.
        :param pulumi.Input[int] recovery_window_in_days: (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        :param pulumi.Input[bool] run_immediate_full_backup: If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        if auto_backup_enabled is not None:
            pulumi.set(__self__, "auto_backup_enabled", auto_backup_enabled)
        if auto_backup_window is not None:
            pulumi.set(__self__, "auto_backup_window", auto_backup_window)
        if auto_full_backup_day is not None:
            pulumi.set(__self__, "auto_full_backup_day", auto_full_backup_day)
        if auto_full_backup_window is not None:
            pulumi.set(__self__, "auto_full_backup_window", auto_full_backup_window)
        if backup_deletion_policy is not None:
            pulumi.set(__self__, "backup_deletion_policy", backup_deletion_policy)
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)
        if run_immediate_full_backup is not None:
            pulumi.set(__self__, "run_immediate_full_backup", run_immediate_full_backup)

    @property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @auto_backup_enabled.setter
    def auto_backup_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_backup_enabled", value)

    @property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @auto_backup_window.setter
    def auto_backup_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_backup_window", value)

    @property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> Optional[pulumi.Input[str]]:
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        return pulumi.get(self, "auto_full_backup_day")

    @auto_full_backup_day.setter
    def auto_full_backup_day(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_full_backup_day", value)

    @property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> Optional[pulumi.Input[str]]:
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_full_backup_window")

    @auto_full_backup_window.setter
    def auto_full_backup_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_full_backup_window", value)

    @property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> Optional[pulumi.Input[str]]:
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        return pulumi.get(self, "backup_deletion_policy")

    @backup_deletion_policy.setter
    def backup_deletion_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_deletion_policy", value)

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs']]]]:
        """
        (Updatable) Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @backup_destination_details.setter
    def backup_destination_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs']]]]):
        pulumi.set(self, "backup_destination_details", value)

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @recovery_window_in_days.setter
    def recovery_window_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "recovery_window_in_days", value)

    @property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        return pulumi.get(self, "run_immediate_full_backup")

    @run_immediate_full_backup.setter
    def run_immediate_full_backup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_immediate_full_backup", value)


if not MYPY:
    class DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailArgsDict(TypedDict):
        dbrs_policy_id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of the database backup destination.
        """
elif False:
    DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs:
    def __init__(__self__, *,
                 dbrs_policy_id: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param pulumi.Input[str] type: Type of the database backup destination.
        """
        if dbrs_policy_id is not None:
            pulumi.set(__self__, "dbrs_policy_id", dbrs_policy_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @dbrs_policy_id.setter
    def dbrs_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dbrs_policy_id", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DbSystemDbSystemOptionsArgsDict(TypedDict):
        storage_management: NotRequired[pulumi.Input[str]]
        """
        The storage option used in DB system. ASM - Automatic storage management LVM - Logical Volume management
        """
elif False:
    DbSystemDbSystemOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbSystemDbSystemOptionsArgs:
    def __init__(__self__, *,
                 storage_management: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] storage_management: The storage option used in DB system. ASM - Automatic storage management LVM - Logical Volume management
        """
        if storage_management is not None:
            pulumi.set(__self__, "storage_management", storage_management)

    @property
    @pulumi.getter(name="storageManagement")
    def storage_management(self) -> Optional[pulumi.Input[str]]:
        """
        The storage option used in DB system. ASM - Automatic storage management LVM - Logical Volume management
        """
        return pulumi.get(self, "storage_management")

    @storage_management.setter
    def storage_management(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_management", value)


if not MYPY:
    class DbSystemIormConfigCachArgsDict(TypedDict):
        db_plans: NotRequired[pulumi.Input[Sequence[pulumi.Input['DbSystemIormConfigCachDbPlanArgsDict']]]]
        """
        An array of IORM settings for all the database in the Exadata DB system.
        """
        db_system_id: NotRequired[pulumi.Input[str]]
        lifecycle_details: NotRequired[pulumi.Input[str]]
        """
        Additional information about the current lifecycle state.
        """
        objective: NotRequired[pulumi.Input[str]]
        """
        The current value for the IORM objective. The default is `AUTO`.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        The current state of the DB system.
        """
elif False:
    DbSystemIormConfigCachArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbSystemIormConfigCachArgs:
    def __init__(__self__, *,
                 db_plans: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemIormConfigCachDbPlanArgs']]]] = None,
                 db_system_id: Optional[pulumi.Input[str]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 objective: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DbSystemIormConfigCachDbPlanArgs']]] db_plans: An array of IORM settings for all the database in the Exadata DB system.
        :param pulumi.Input[str] lifecycle_details: Additional information about the current lifecycle state.
        :param pulumi.Input[str] objective: The current value for the IORM objective. The default is `AUTO`.
        :param pulumi.Input[str] state: The current state of the DB system.
        """
        if db_plans is not None:
            pulumi.set(__self__, "db_plans", db_plans)
        if db_system_id is not None:
            pulumi.set(__self__, "db_system_id", db_system_id)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if objective is not None:
            pulumi.set(__self__, "objective", objective)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="dbPlans")
    def db_plans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemIormConfigCachDbPlanArgs']]]]:
        """
        An array of IORM settings for all the database in the Exadata DB system.
        """
        return pulumi.get(self, "db_plans")

    @db_plans.setter
    def db_plans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemIormConfigCachDbPlanArgs']]]]):
        pulumi.set(self, "db_plans", value)

    @property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "db_system_id")

    @db_system_id.setter
    def db_system_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_system_id", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter
    def objective(self) -> Optional[pulumi.Input[str]]:
        """
        The current value for the IORM objective. The default is `AUTO`.
        """
        return pulumi.get(self, "objective")

    @objective.setter
    def objective(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "objective", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the DB system.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class DbSystemIormConfigCachDbPlanArgsDict(TypedDict):
        db_name: NotRequired[pulumi.Input[str]]
        """
        The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        flash_cache_limit: NotRequired[pulumi.Input[str]]
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        share: NotRequired[pulumi.Input[int]]
        """
        The relative priority of this database.
        """
elif False:
    DbSystemIormConfigCachDbPlanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbSystemIormConfigCachDbPlanArgs:
    def __init__(__self__, *,
                 db_name: Optional[pulumi.Input[str]] = None,
                 flash_cache_limit: Optional[pulumi.Input[str]] = None,
                 share: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] db_name: The database name. For the default `DbPlan`, the `dbName` is `default`.
        :param pulumi.Input[str] flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        :param pulumi.Input[int] share: The relative priority of this database.
        """
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if flash_cache_limit is not None:
            pulumi.set(__self__, "flash_cache_limit", flash_cache_limit)
        if share is not None:
            pulumi.set(__self__, "share", share)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[pulumi.Input[str]]:
        """
        The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")

    @flash_cache_limit.setter
    def flash_cache_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flash_cache_limit", value)

    @property
    @pulumi.getter
    def share(self) -> Optional[pulumi.Input[int]]:
        """
        The relative priority of this database.
        """
        return pulumi.get(self, "share")

    @share.setter
    def share(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "share", value)


if not MYPY:
    class DbSystemMaintenanceWindowArgsDict(TypedDict):
        custom_action_timeout_in_mins: NotRequired[pulumi.Input[int]]
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        days_of_weeks: NotRequired[pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowDaysOfWeekArgsDict']]]]
        """
        Days during the week when maintenance should be performed.
        """
        hours_of_days: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        is_custom_action_timeout_enabled: NotRequired[pulumi.Input[bool]]
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        is_monthly_patching_enabled: NotRequired[pulumi.Input[bool]]
        """
        If true, enables the monthly patching option.
        """
        lead_time_in_weeks: NotRequired[pulumi.Input[int]]
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        months: NotRequired[pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowMonthArgsDict']]]]
        """
        Months during the year when maintenance should be performed.
        """
        patching_mode: NotRequired[pulumi.Input[str]]
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        preference: NotRequired[pulumi.Input[str]]
        """
        The maintenance window scheduling preference.
        """
        skip_rus: NotRequired[pulumi.Input[Sequence[pulumi.Input[bool]]]]
        """
        If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        weeks_of_months: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
elif False:
    DbSystemMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbSystemMaintenanceWindowArgs:
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[pulumi.Input[int]] = None,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 is_custom_action_timeout_enabled: Optional[pulumi.Input[bool]] = None,
                 is_monthly_patching_enabled: Optional[pulumi.Input[bool]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowMonthArgs']]]] = None,
                 patching_mode: Optional[pulumi.Input[str]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 skip_rus: Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[int] custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowDaysOfWeekArgs']]] days_of_weeks: Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[bool] is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param pulumi.Input[bool] is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param pulumi.Input[int] lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowMonthArgs']]] months: Months during the year when maintenance should be performed.
        :param pulumi.Input[str] patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param pulumi.Input[str] preference: The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[bool]]] skip_rus: If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if skip_rus is not None:
            pulumi.set(__self__, "skip_rus", skip_rus)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[pulumi.Input[int]]:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @custom_action_timeout_in_mins.setter
    def custom_action_timeout_in_mins(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_action_timeout_in_mins", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowDaysOfWeekArgs']]]]:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @is_custom_action_timeout_enabled.setter
    def is_custom_action_timeout_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom_action_timeout_enabled", value)

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @is_monthly_patching_enabled.setter
    def is_monthly_patching_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monthly_patching_enabled", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowMonthArgs']]]]:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @patching_mode.setter
    def patching_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patching_mode", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]]:
        """
        If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        return pulumi.get(self, "skip_rus")

    @skip_rus.setter
    def skip_rus(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]]):
        pulumi.set(self, "skip_rus", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


if not MYPY:
    class DbSystemMaintenanceWindowDaysOfWeekArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the month of the year.
        """
elif False:
    DbSystemMaintenanceWindowDaysOfWeekArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbSystemMaintenanceWindowDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DbSystemMaintenanceWindowDetailsArgsDict(TypedDict):
        custom_action_timeout_in_mins: NotRequired[pulumi.Input[int]]
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        days_of_weeks: NotRequired[pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowDetailsDaysOfWeekArgsDict']]]]
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        hours_of_days: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        is_custom_action_timeout_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        is_monthly_patching_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) If true, enables the monthly patching option.
        """
        lead_time_in_weeks: NotRequired[pulumi.Input[int]]
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        months: NotRequired[pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowDetailsMonthArgsDict']]]]
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        patching_mode: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        preference: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The maintenance window scheduling preference.
        """
        skip_rus: NotRequired[pulumi.Input[Sequence[pulumi.Input[bool]]]]
        """
        (Updatable) If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        weeks_of_months: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
elif False:
    DbSystemMaintenanceWindowDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbSystemMaintenanceWindowDetailsArgs:
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[pulumi.Input[int]] = None,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowDetailsDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 is_custom_action_timeout_enabled: Optional[pulumi.Input[bool]] = None,
                 is_monthly_patching_enabled: Optional[pulumi.Input[bool]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowDetailsMonthArgs']]]] = None,
                 patching_mode: Optional[pulumi.Input[str]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 skip_rus: Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[int] custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowDetailsDaysOfWeekArgs']]] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[bool] is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param pulumi.Input[bool] is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param pulumi.Input[int] lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowDetailsMonthArgs']]] months: (Updatable) Months during the year when maintenance should be performed.
        :param pulumi.Input[str] patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param pulumi.Input[str] preference: (Updatable) The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[bool]]] skip_rus: (Updatable) If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if skip_rus is not None:
            pulumi.set(__self__, "skip_rus", skip_rus)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @custom_action_timeout_in_mins.setter
    def custom_action_timeout_in_mins(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_action_timeout_in_mins", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowDetailsDaysOfWeekArgs']]]]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowDetailsDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @is_custom_action_timeout_enabled.setter
    def is_custom_action_timeout_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom_action_timeout_enabled", value)

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @is_monthly_patching_enabled.setter
    def is_monthly_patching_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monthly_patching_enabled", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowDetailsMonthArgs']]]]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowDetailsMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @patching_mode.setter
    def patching_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patching_mode", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]]:
        """
        (Updatable) If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        return pulumi.get(self, "skip_rus")

    @skip_rus.setter
    def skip_rus(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]]):
        pulumi.set(self, "skip_rus", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


if not MYPY:
    class DbSystemMaintenanceWindowDetailsDaysOfWeekArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Name of the day of the week.
        """
elif False:
    DbSystemMaintenanceWindowDetailsDaysOfWeekArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbSystemMaintenanceWindowDetailsDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the day of the week.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the day of the week.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DbSystemMaintenanceWindowDetailsMonthArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Name of the month of the year.
        """
elif False:
    DbSystemMaintenanceWindowDetailsMonthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbSystemMaintenanceWindowDetailsMonthArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DbSystemMaintenanceWindowMonthArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the month of the year.
        """
elif False:
    DbSystemMaintenanceWindowMonthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbSystemMaintenanceWindowMonthArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DbSystemsUpgradeDbSystemOptionArgsDict(TypedDict):
        storage_management: NotRequired[pulumi.Input[str]]
        """
        The storage option used in DB system. ASM - Automatic storage management LVM - Logical Volume management
        """
elif False:
    DbSystemsUpgradeDbSystemOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbSystemsUpgradeDbSystemOptionArgs:
    def __init__(__self__, *,
                 storage_management: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] storage_management: The storage option used in DB system. ASM - Automatic storage management LVM - Logical Volume management
        """
        if storage_management is not None:
            pulumi.set(__self__, "storage_management", storage_management)

    @property
    @pulumi.getter(name="storageManagement")
    def storage_management(self) -> Optional[pulumi.Input[str]]:
        """
        The storage option used in DB system. ASM - Automatic storage management LVM - Logical Volume management
        """
        return pulumi.get(self, "storage_management")

    @storage_management.setter
    def storage_management(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_management", value)


if not MYPY:
    class DbSystemsUpgradeIormConfigCachArgsDict(TypedDict):
        db_plans: NotRequired[pulumi.Input[Sequence[pulumi.Input['DbSystemsUpgradeIormConfigCachDbPlanArgsDict']]]]
        """
        An array of IORM settings for all the database in the Exadata DB system.
        """
        lifecycle_details: NotRequired[pulumi.Input[str]]
        """
        Additional information about the current lifecycle state.
        """
        objective: NotRequired[pulumi.Input[str]]
        """
        The current value for the IORM objective. The default is `AUTO`.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        The current state of the DB system.
        """
elif False:
    DbSystemsUpgradeIormConfigCachArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbSystemsUpgradeIormConfigCachArgs:
    def __init__(__self__, *,
                 db_plans: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemsUpgradeIormConfigCachDbPlanArgs']]]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 objective: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DbSystemsUpgradeIormConfigCachDbPlanArgs']]] db_plans: An array of IORM settings for all the database in the Exadata DB system.
        :param pulumi.Input[str] lifecycle_details: Additional information about the current lifecycle state.
        :param pulumi.Input[str] objective: The current value for the IORM objective. The default is `AUTO`.
        :param pulumi.Input[str] state: The current state of the DB system.
        """
        if db_plans is not None:
            pulumi.set(__self__, "db_plans", db_plans)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if objective is not None:
            pulumi.set(__self__, "objective", objective)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="dbPlans")
    def db_plans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemsUpgradeIormConfigCachDbPlanArgs']]]]:
        """
        An array of IORM settings for all the database in the Exadata DB system.
        """
        return pulumi.get(self, "db_plans")

    @db_plans.setter
    def db_plans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemsUpgradeIormConfigCachDbPlanArgs']]]]):
        pulumi.set(self, "db_plans", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter
    def objective(self) -> Optional[pulumi.Input[str]]:
        """
        The current value for the IORM objective. The default is `AUTO`.
        """
        return pulumi.get(self, "objective")

    @objective.setter
    def objective(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "objective", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the DB system.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class DbSystemsUpgradeIormConfigCachDbPlanArgsDict(TypedDict):
        db_name: NotRequired[pulumi.Input[str]]
        """
        The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        flash_cache_limit: NotRequired[pulumi.Input[str]]
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        share: NotRequired[pulumi.Input[int]]
        """
        The relative priority of this database.
        """
elif False:
    DbSystemsUpgradeIormConfigCachDbPlanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbSystemsUpgradeIormConfigCachDbPlanArgs:
    def __init__(__self__, *,
                 db_name: Optional[pulumi.Input[str]] = None,
                 flash_cache_limit: Optional[pulumi.Input[str]] = None,
                 share: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] db_name: The database name. For the default `DbPlan`, the `dbName` is `default`.
        :param pulumi.Input[str] flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        :param pulumi.Input[int] share: The relative priority of this database.
        """
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if flash_cache_limit is not None:
            pulumi.set(__self__, "flash_cache_limit", flash_cache_limit)
        if share is not None:
            pulumi.set(__self__, "share", share)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[pulumi.Input[str]]:
        """
        The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")

    @flash_cache_limit.setter
    def flash_cache_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flash_cache_limit", value)

    @property
    @pulumi.getter
    def share(self) -> Optional[pulumi.Input[int]]:
        """
        The relative priority of this database.
        """
        return pulumi.get(self, "share")

    @share.setter
    def share(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "share", value)


if not MYPY:
    class DbSystemsUpgradeMaintenanceWindowArgsDict(TypedDict):
        days_of_weeks: NotRequired[pulumi.Input[Sequence[pulumi.Input['DbSystemsUpgradeMaintenanceWindowDaysOfWeekArgsDict']]]]
        """
        Days during the week when maintenance should be performed.
        """
        hours_of_days: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        lead_time_in_weeks: NotRequired[pulumi.Input[int]]
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        months: NotRequired[pulumi.Input[Sequence[pulumi.Input['DbSystemsUpgradeMaintenanceWindowMonthArgsDict']]]]
        """
        Months during the year when maintenance should be performed.
        """
        preference: NotRequired[pulumi.Input[str]]
        """
        The maintenance window scheduling preference.
        """
        weeks_of_months: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
elif False:
    DbSystemsUpgradeMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbSystemsUpgradeMaintenanceWindowArgs:
    def __init__(__self__, *,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemsUpgradeMaintenanceWindowDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemsUpgradeMaintenanceWindowMonthArgs']]]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DbSystemsUpgradeMaintenanceWindowDaysOfWeekArgs']]] days_of_weeks: Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[int] lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['DbSystemsUpgradeMaintenanceWindowMonthArgs']]] months: Months during the year when maintenance should be performed.
        :param pulumi.Input[str] preference: The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemsUpgradeMaintenanceWindowDaysOfWeekArgs']]]]:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemsUpgradeMaintenanceWindowDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemsUpgradeMaintenanceWindowMonthArgs']]]]:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemsUpgradeMaintenanceWindowMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


if not MYPY:
    class DbSystemsUpgradeMaintenanceWindowDaysOfWeekArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the month of the year.
        """
elif False:
    DbSystemsUpgradeMaintenanceWindowDaysOfWeekArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbSystemsUpgradeMaintenanceWindowDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DbSystemsUpgradeMaintenanceWindowMonthArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the month of the year.
        """
elif False:
    DbSystemsUpgradeMaintenanceWindowMonthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbSystemsUpgradeMaintenanceWindowMonthArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ExadataInfrastructureComputeContactArgsDict(TypedDict):
        email: NotRequired[pulumi.Input[str]]
        """
        The email for the Exadata Infrastructure contact.
        """
        is_contact_mos_validated: NotRequired[pulumi.Input[bool]]
        """
        If `true`, this Exadata Infrastructure contact is a valid My Oracle Support (MOS) contact. If `false`, this Exadata Infrastructure contact is not a valid MOS contact.
        """
        is_primary: NotRequired[pulumi.Input[bool]]
        """
        If `true`, this Exadata Infrastructure contact is a primary contact. If `false`, this Exadata Infrastructure is a secondary contact.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the month of the year.
        """
        phone_number: NotRequired[pulumi.Input[str]]
        """
        The phone number for the Exadata Infrastructure contact.
        """
elif False:
    ExadataInfrastructureComputeContactArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExadataInfrastructureComputeContactArgs:
    def __init__(__self__, *,
                 email: Optional[pulumi.Input[str]] = None,
                 is_contact_mos_validated: Optional[pulumi.Input[bool]] = None,
                 is_primary: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 phone_number: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] email: The email for the Exadata Infrastructure contact.
        :param pulumi.Input[bool] is_contact_mos_validated: If `true`, this Exadata Infrastructure contact is a valid My Oracle Support (MOS) contact. If `false`, this Exadata Infrastructure contact is not a valid MOS contact.
        :param pulumi.Input[bool] is_primary: If `true`, this Exadata Infrastructure contact is a primary contact. If `false`, this Exadata Infrastructure is a secondary contact.
        :param pulumi.Input[str] name: Name of the month of the year.
        :param pulumi.Input[str] phone_number: The phone number for the Exadata Infrastructure contact.
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if is_contact_mos_validated is not None:
            pulumi.set(__self__, "is_contact_mos_validated", is_contact_mos_validated)
        if is_primary is not None:
            pulumi.set(__self__, "is_primary", is_primary)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if phone_number is not None:
            pulumi.set(__self__, "phone_number", phone_number)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        The email for the Exadata Infrastructure contact.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="isContactMosValidated")
    def is_contact_mos_validated(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true`, this Exadata Infrastructure contact is a valid My Oracle Support (MOS) contact. If `false`, this Exadata Infrastructure contact is not a valid MOS contact.
        """
        return pulumi.get(self, "is_contact_mos_validated")

    @is_contact_mos_validated.setter
    def is_contact_mos_validated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_contact_mos_validated", value)

    @property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true`, this Exadata Infrastructure contact is a primary contact. If `false`, this Exadata Infrastructure is a secondary contact.
        """
        return pulumi.get(self, "is_primary")

    @is_primary.setter
    def is_primary(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_primary", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[pulumi.Input[str]]:
        """
        The phone number for the Exadata Infrastructure contact.
        """
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phone_number", value)


if not MYPY:
    class ExadataInfrastructureComputeMaintenanceWindowArgsDict(TypedDict):
        custom_action_timeout_in_mins: NotRequired[pulumi.Input[int]]
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        days_of_weeks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureComputeMaintenanceWindowDaysOfWeekArgsDict']]]]
        """
        Days during the week when maintenance should be performed.
        """
        hours_of_days: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        is_custom_action_timeout_enabled: NotRequired[pulumi.Input[bool]]
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        is_monthly_patching_enabled: NotRequired[pulumi.Input[bool]]
        """
        If true, enables the monthly patching option.
        """
        lead_time_in_weeks: NotRequired[pulumi.Input[int]]
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        months: NotRequired[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureComputeMaintenanceWindowMonthArgsDict']]]]
        """
        Months during the year when maintenance should be performed.
        """
        patching_mode: NotRequired[pulumi.Input[str]]
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        preference: NotRequired[pulumi.Input[str]]
        """
        The maintenance window scheduling preference.
        """
        weeks_of_months: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
elif False:
    ExadataInfrastructureComputeMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExadataInfrastructureComputeMaintenanceWindowArgs:
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[pulumi.Input[int]] = None,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureComputeMaintenanceWindowDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 is_custom_action_timeout_enabled: Optional[pulumi.Input[bool]] = None,
                 is_monthly_patching_enabled: Optional[pulumi.Input[bool]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureComputeMaintenanceWindowMonthArgs']]]] = None,
                 patching_mode: Optional[pulumi.Input[str]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[int] custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureComputeMaintenanceWindowDaysOfWeekArgs']]] days_of_weeks: Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[bool] is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param pulumi.Input[bool] is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param pulumi.Input[int] lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureComputeMaintenanceWindowMonthArgs']]] months: Months during the year when maintenance should be performed.
        :param pulumi.Input[str] patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param pulumi.Input[str] preference: The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[pulumi.Input[int]]:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @custom_action_timeout_in_mins.setter
    def custom_action_timeout_in_mins(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_action_timeout_in_mins", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureComputeMaintenanceWindowDaysOfWeekArgs']]]]:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureComputeMaintenanceWindowDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @is_custom_action_timeout_enabled.setter
    def is_custom_action_timeout_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom_action_timeout_enabled", value)

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @is_monthly_patching_enabled.setter
    def is_monthly_patching_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monthly_patching_enabled", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureComputeMaintenanceWindowMonthArgs']]]]:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureComputeMaintenanceWindowMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @patching_mode.setter
    def patching_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patching_mode", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


if not MYPY:
    class ExadataInfrastructureComputeMaintenanceWindowDaysOfWeekArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the month of the year.
        """
elif False:
    ExadataInfrastructureComputeMaintenanceWindowDaysOfWeekArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExadataInfrastructureComputeMaintenanceWindowDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ExadataInfrastructureComputeMaintenanceWindowMonthArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the month of the year.
        """
elif False:
    ExadataInfrastructureComputeMaintenanceWindowMonthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExadataInfrastructureComputeMaintenanceWindowMonthArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ExadataInfrastructureContactArgsDict(TypedDict):
        email: pulumi.Input[str]
        """
        (Updatable) The email for the Exadata Infrastructure contact.
        """
        is_primary: pulumi.Input[bool]
        """
        (Updatable) If `true`, this Exadata Infrastructure contact is a primary contact. If `false`, this Exadata Infrastructure is a secondary contact.
        """
        name: pulumi.Input[str]
        """
        (Updatable) The name of the Exadata Infrastructure contact.
        """
        is_contact_mos_validated: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) If `true`, this Exadata Infrastructure contact is a valid My Oracle Support (MOS) contact. If `false`, this Exadata Infrastructure contact is not a valid MOS contact.
        """
        phone_number: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The phone number for the Exadata Infrastructure contact.
        """
elif False:
    ExadataInfrastructureContactArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExadataInfrastructureContactArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[str],
                 is_primary: pulumi.Input[bool],
                 name: pulumi.Input[str],
                 is_contact_mos_validated: Optional[pulumi.Input[bool]] = None,
                 phone_number: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] email: (Updatable) The email for the Exadata Infrastructure contact.
        :param pulumi.Input[bool] is_primary: (Updatable) If `true`, this Exadata Infrastructure contact is a primary contact. If `false`, this Exadata Infrastructure is a secondary contact.
        :param pulumi.Input[str] name: (Updatable) The name of the Exadata Infrastructure contact.
        :param pulumi.Input[bool] is_contact_mos_validated: (Updatable) If `true`, this Exadata Infrastructure contact is a valid My Oracle Support (MOS) contact. If `false`, this Exadata Infrastructure contact is not a valid MOS contact.
        :param pulumi.Input[str] phone_number: (Updatable) The phone number for the Exadata Infrastructure contact.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "is_primary", is_primary)
        pulumi.set(__self__, "name", name)
        if is_contact_mos_validated is not None:
            pulumi.set(__self__, "is_contact_mos_validated", is_contact_mos_validated)
        if phone_number is not None:
            pulumi.set(__self__, "phone_number", phone_number)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        (Updatable) The email for the Exadata Infrastructure contact.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> pulumi.Input[bool]:
        """
        (Updatable) If `true`, this Exadata Infrastructure contact is a primary contact. If `false`, this Exadata Infrastructure is a secondary contact.
        """
        return pulumi.get(self, "is_primary")

    @is_primary.setter
    def is_primary(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_primary", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) The name of the Exadata Infrastructure contact.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="isContactMosValidated")
    def is_contact_mos_validated(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If `true`, this Exadata Infrastructure contact is a valid My Oracle Support (MOS) contact. If `false`, this Exadata Infrastructure contact is not a valid MOS contact.
        """
        return pulumi.get(self, "is_contact_mos_validated")

    @is_contact_mos_validated.setter
    def is_contact_mos_validated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_contact_mos_validated", value)

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The phone number for the Exadata Infrastructure contact.
        """
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phone_number", value)


if not MYPY:
    class ExadataInfrastructureDefinedFileSystemConfigurationArgsDict(TypedDict):
        is_backup_partition: NotRequired[pulumi.Input[bool]]
        """
        If true, the file system is used to create a backup prior to Exadata VM OS update.
        """
        is_resizable: NotRequired[pulumi.Input[bool]]
        """
        If true, the file system resize is allowed for the Exadata Infrastructure cluster. If false, the file system resize is not allowed.
        """
        min_size_gb: NotRequired[pulumi.Input[int]]
        """
        The minimum size of file system.
        """
        mount_point: NotRequired[pulumi.Input[str]]
        """
        The mount point of file system.
        """
elif False:
    ExadataInfrastructureDefinedFileSystemConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExadataInfrastructureDefinedFileSystemConfigurationArgs:
    def __init__(__self__, *,
                 is_backup_partition: Optional[pulumi.Input[bool]] = None,
                 is_resizable: Optional[pulumi.Input[bool]] = None,
                 min_size_gb: Optional[pulumi.Input[int]] = None,
                 mount_point: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_backup_partition: If true, the file system is used to create a backup prior to Exadata VM OS update.
        :param pulumi.Input[bool] is_resizable: If true, the file system resize is allowed for the Exadata Infrastructure cluster. If false, the file system resize is not allowed.
        :param pulumi.Input[int] min_size_gb: The minimum size of file system.
        :param pulumi.Input[str] mount_point: The mount point of file system.
        """
        if is_backup_partition is not None:
            pulumi.set(__self__, "is_backup_partition", is_backup_partition)
        if is_resizable is not None:
            pulumi.set(__self__, "is_resizable", is_resizable)
        if min_size_gb is not None:
            pulumi.set(__self__, "min_size_gb", min_size_gb)
        if mount_point is not None:
            pulumi.set(__self__, "mount_point", mount_point)

    @property
    @pulumi.getter(name="isBackupPartition")
    def is_backup_partition(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the file system is used to create a backup prior to Exadata VM OS update.
        """
        return pulumi.get(self, "is_backup_partition")

    @is_backup_partition.setter
    def is_backup_partition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_backup_partition", value)

    @property
    @pulumi.getter(name="isResizable")
    def is_resizable(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the file system resize is allowed for the Exadata Infrastructure cluster. If false, the file system resize is not allowed.
        """
        return pulumi.get(self, "is_resizable")

    @is_resizable.setter
    def is_resizable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_resizable", value)

    @property
    @pulumi.getter(name="minSizeGb")
    def min_size_gb(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum size of file system.
        """
        return pulumi.get(self, "min_size_gb")

    @min_size_gb.setter
    def min_size_gb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_size_gb", value)

    @property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> Optional[pulumi.Input[str]]:
        """
        The mount point of file system.
        """
        return pulumi.get(self, "mount_point")

    @mount_point.setter
    def mount_point(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_point", value)


if not MYPY:
    class ExadataInfrastructureMaintenanceWindowArgsDict(TypedDict):
        custom_action_timeout_in_mins: NotRequired[pulumi.Input[int]]
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        days_of_weeks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureMaintenanceWindowDaysOfWeekArgsDict']]]]
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        hours_of_days: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        is_custom_action_timeout_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        is_monthly_patching_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) If true, enables the monthly patching option.
        """
        lead_time_in_weeks: NotRequired[pulumi.Input[int]]
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        months: NotRequired[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureMaintenanceWindowMonthArgsDict']]]]
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        patching_mode: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        preference: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The maintenance window scheduling preference.
        """
        skip_rus: NotRequired[pulumi.Input[Sequence[pulumi.Input[bool]]]]
        """
        (Updatable) If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        weeks_of_months: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
elif False:
    ExadataInfrastructureMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExadataInfrastructureMaintenanceWindowArgs:
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[pulumi.Input[int]] = None,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 is_custom_action_timeout_enabled: Optional[pulumi.Input[bool]] = None,
                 is_monthly_patching_enabled: Optional[pulumi.Input[bool]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureMaintenanceWindowMonthArgs']]]] = None,
                 patching_mode: Optional[pulumi.Input[str]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 skip_rus: Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[int] custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[bool] is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param pulumi.Input[bool] is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param pulumi.Input[int] lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureMaintenanceWindowMonthArgs']]] months: (Updatable) Months during the year when maintenance should be performed.
        :param pulumi.Input[str] patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param pulumi.Input[str] preference: (Updatable) The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[bool]]] skip_rus: (Updatable) If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if skip_rus is not None:
            pulumi.set(__self__, "skip_rus", skip_rus)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @custom_action_timeout_in_mins.setter
    def custom_action_timeout_in_mins(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_action_timeout_in_mins", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]]]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @is_custom_action_timeout_enabled.setter
    def is_custom_action_timeout_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom_action_timeout_enabled", value)

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @is_monthly_patching_enabled.setter
    def is_monthly_patching_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monthly_patching_enabled", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureMaintenanceWindowMonthArgs']]]]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureMaintenanceWindowMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @patching_mode.setter
    def patching_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patching_mode", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="skipRus")
    def skip_rus(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]]:
        """
        (Updatable) If true, skips the release update (RU) for the quarter. You cannot skip two consecutive quarters. An RU skip request will only be honoured if the current version of the Autonomous Container Database is supported for current quarter.
        """
        return pulumi.get(self, "skip_rus")

    @skip_rus.setter
    def skip_rus(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[bool]]]]):
        pulumi.set(self, "skip_rus", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


if not MYPY:
    class ExadataInfrastructureMaintenanceWindowDaysOfWeekArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        (Updatable) Name of the day of the week.
        """
elif False:
    ExadataInfrastructureMaintenanceWindowDaysOfWeekArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExadataInfrastructureMaintenanceWindowDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the day of the week.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the day of the week.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ExadataInfrastructureMaintenanceWindowMonthArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        (Updatable) Name of the month of the year.
        """
elif False:
    ExadataInfrastructureMaintenanceWindowMonthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExadataInfrastructureMaintenanceWindowMonthArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ExadataInfrastructureNetworkBondingModeDetailsArgsDict(TypedDict):
        backup_network_bonding_mode: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The network bonding mode for the Exadata infrastructure.
        """
        client_network_bonding_mode: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The network bonding mode for the Exadata infrastructure.
        """
        dr_network_bonding_mode: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The network bonding mode for the Exadata infrastructure.
        """
elif False:
    ExadataInfrastructureNetworkBondingModeDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExadataInfrastructureNetworkBondingModeDetailsArgs:
    def __init__(__self__, *,
                 backup_network_bonding_mode: Optional[pulumi.Input[str]] = None,
                 client_network_bonding_mode: Optional[pulumi.Input[str]] = None,
                 dr_network_bonding_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] backup_network_bonding_mode: (Updatable) The network bonding mode for the Exadata infrastructure.
        :param pulumi.Input[str] client_network_bonding_mode: (Updatable) The network bonding mode for the Exadata infrastructure.
        :param pulumi.Input[str] dr_network_bonding_mode: (Updatable) The network bonding mode for the Exadata infrastructure.
        """
        if backup_network_bonding_mode is not None:
            pulumi.set(__self__, "backup_network_bonding_mode", backup_network_bonding_mode)
        if client_network_bonding_mode is not None:
            pulumi.set(__self__, "client_network_bonding_mode", client_network_bonding_mode)
        if dr_network_bonding_mode is not None:
            pulumi.set(__self__, "dr_network_bonding_mode", dr_network_bonding_mode)

    @property
    @pulumi.getter(name="backupNetworkBondingMode")
    def backup_network_bonding_mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The network bonding mode for the Exadata infrastructure.
        """
        return pulumi.get(self, "backup_network_bonding_mode")

    @backup_network_bonding_mode.setter
    def backup_network_bonding_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_network_bonding_mode", value)

    @property
    @pulumi.getter(name="clientNetworkBondingMode")
    def client_network_bonding_mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The network bonding mode for the Exadata infrastructure.
        """
        return pulumi.get(self, "client_network_bonding_mode")

    @client_network_bonding_mode.setter
    def client_network_bonding_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_network_bonding_mode", value)

    @property
    @pulumi.getter(name="drNetworkBondingMode")
    def dr_network_bonding_mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The network bonding mode for the Exadata infrastructure.
        """
        return pulumi.get(self, "dr_network_bonding_mode")

    @dr_network_bonding_mode.setter
    def dr_network_bonding_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dr_network_bonding_mode", value)


if not MYPY:
    class ExadataInfrastructureStorageContactArgsDict(TypedDict):
        email: pulumi.Input[str]
        is_primary: pulumi.Input[bool]
        name: pulumi.Input[str]
        is_contact_mos_validated: NotRequired[pulumi.Input[bool]]
        phone_number: NotRequired[pulumi.Input[str]]
elif False:
    ExadataInfrastructureStorageContactArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExadataInfrastructureStorageContactArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[str],
                 is_primary: pulumi.Input[bool],
                 name: pulumi.Input[str],
                 is_contact_mos_validated: Optional[pulumi.Input[bool]] = None,
                 phone_number: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "is_primary", is_primary)
        pulumi.set(__self__, "name", name)
        if is_contact_mos_validated is not None:
            pulumi.set(__self__, "is_contact_mos_validated", is_contact_mos_validated)
        if phone_number is not None:
            pulumi.set(__self__, "phone_number", phone_number)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "is_primary")

    @is_primary.setter
    def is_primary(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_primary", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="isContactMosValidated")
    def is_contact_mos_validated(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_contact_mos_validated")

    @is_contact_mos_validated.setter
    def is_contact_mos_validated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_contact_mos_validated", value)

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phone_number", value)


if not MYPY:
    class ExadataInfrastructureStorageMaintenanceWindowArgsDict(TypedDict):
        preference: pulumi.Input[str]
        days_of_weeks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureStorageMaintenanceWindowDaysOfWeekArgsDict']]]]
        hours_of_days: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        lead_time_in_weeks: NotRequired[pulumi.Input[int]]
        months: NotRequired[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureStorageMaintenanceWindowMonthArgsDict']]]]
        weeks_of_months: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
elif False:
    ExadataInfrastructureStorageMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExadataInfrastructureStorageMaintenanceWindowArgs:
    def __init__(__self__, *,
                 preference: pulumi.Input[str],
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureStorageMaintenanceWindowDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureStorageMaintenanceWindowMonthArgs']]]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        pulumi.set(__self__, "preference", preference)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter
    def preference(self) -> pulumi.Input[str]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: pulumi.Input[str]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureStorageMaintenanceWindowDaysOfWeekArgs']]]]:
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureStorageMaintenanceWindowDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureStorageMaintenanceWindowMonthArgs']]]]:
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureStorageMaintenanceWindowMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


if not MYPY:
    class ExadataInfrastructureStorageMaintenanceWindowDaysOfWeekArgsDict(TypedDict):
        name: pulumi.Input[str]
elif False:
    ExadataInfrastructureStorageMaintenanceWindowDaysOfWeekArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExadataInfrastructureStorageMaintenanceWindowDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ExadataInfrastructureStorageMaintenanceWindowMonthArgsDict(TypedDict):
        name: pulumi.Input[str]
elif False:
    ExadataInfrastructureStorageMaintenanceWindowMonthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExadataInfrastructureStorageMaintenanceWindowMonthArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ExadataIormConfigDbPlanArgsDict(TypedDict):
        db_name: pulumi.Input[str]
        """
        (Updatable) The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        share: pulumi.Input[int]
        """
        (Updatable) The relative priority of this database.
        """
        flash_cache_limit: NotRequired[pulumi.Input[str]]
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
elif False:
    ExadataIormConfigDbPlanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExadataIormConfigDbPlanArgs:
    def __init__(__self__, *,
                 db_name: pulumi.Input[str],
                 share: pulumi.Input[int],
                 flash_cache_limit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] db_name: (Updatable) The database name. For the default `DbPlan`, the `dbName` is `default`.
        :param pulumi.Input[int] share: (Updatable) The relative priority of this database.
        :param pulumi.Input[str] flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "share", share)
        if flash_cache_limit is not None:
            pulumi.set(__self__, "flash_cache_limit", flash_cache_limit)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> pulumi.Input[str]:
        """
        (Updatable) The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter
    def share(self) -> pulumi.Input[int]:
        """
        (Updatable) The relative priority of this database.
        """
        return pulumi.get(self, "share")

    @share.setter
    def share(self, value: pulumi.Input[int]):
        pulumi.set(self, "share", value)

    @property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")

    @flash_cache_limit.setter
    def flash_cache_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flash_cache_limit", value)


if not MYPY:
    class ExadbVmClusterDataCollectionOptionsArgsDict(TypedDict):
        is_diagnostics_events_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        is_health_monitoring_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        is_incident_logs_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
elif False:
    ExadbVmClusterDataCollectionOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExadbVmClusterDataCollectionOptionsArgs:
    def __init__(__self__, *,
                 is_diagnostics_events_enabled: Optional[pulumi.Input[bool]] = None,
                 is_health_monitoring_enabled: Optional[pulumi.Input[bool]] = None,
                 is_incident_logs_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_diagnostics_events_enabled: (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param pulumi.Input[bool] is_health_monitoring_enabled: (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param pulumi.Input[bool] is_incident_logs_enabled: (Updatable) Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        if is_diagnostics_events_enabled is not None:
            pulumi.set(__self__, "is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        if is_health_monitoring_enabled is not None:
            pulumi.set(__self__, "is_health_monitoring_enabled", is_health_monitoring_enabled)
        if is_incident_logs_enabled is not None:
            pulumi.set(__self__, "is_incident_logs_enabled", is_incident_logs_enabled)

    @property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @is_diagnostics_events_enabled.setter
    def is_diagnostics_events_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_diagnostics_events_enabled", value)

    @property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @is_health_monitoring_enabled.setter
    def is_health_monitoring_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_health_monitoring_enabled", value)

    @property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")

    @is_incident_logs_enabled.setter
    def is_incident_logs_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_incident_logs_enabled", value)


if not MYPY:
    class ExadbVmClusterIormConfigCachArgsDict(TypedDict):
        db_plans: NotRequired[pulumi.Input[Sequence[pulumi.Input['ExadbVmClusterIormConfigCachDbPlanArgsDict']]]]
        """
        An array of IORM settings for all the database in the Exadata DB system.
        """
        lifecycle_details: NotRequired[pulumi.Input[str]]
        """
        Additional information about the current lifecycle state.
        """
        objective: NotRequired[pulumi.Input[str]]
        """
        The current value for the IORM objective. The default is `AUTO`.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        The current state of the Exadata VM cluster on Exascale Infrastructure.
        """
elif False:
    ExadbVmClusterIormConfigCachArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExadbVmClusterIormConfigCachArgs:
    def __init__(__self__, *,
                 db_plans: Optional[pulumi.Input[Sequence[pulumi.Input['ExadbVmClusterIormConfigCachDbPlanArgs']]]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 objective: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ExadbVmClusterIormConfigCachDbPlanArgs']]] db_plans: An array of IORM settings for all the database in the Exadata DB system.
        :param pulumi.Input[str] lifecycle_details: Additional information about the current lifecycle state.
        :param pulumi.Input[str] objective: The current value for the IORM objective. The default is `AUTO`.
        :param pulumi.Input[str] state: The current state of the Exadata VM cluster on Exascale Infrastructure.
        """
        if db_plans is not None:
            pulumi.set(__self__, "db_plans", db_plans)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if objective is not None:
            pulumi.set(__self__, "objective", objective)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="dbPlans")
    def db_plans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExadbVmClusterIormConfigCachDbPlanArgs']]]]:
        """
        An array of IORM settings for all the database in the Exadata DB system.
        """
        return pulumi.get(self, "db_plans")

    @db_plans.setter
    def db_plans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExadbVmClusterIormConfigCachDbPlanArgs']]]]):
        pulumi.set(self, "db_plans", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter
    def objective(self) -> Optional[pulumi.Input[str]]:
        """
        The current value for the IORM objective. The default is `AUTO`.
        """
        return pulumi.get(self, "objective")

    @objective.setter
    def objective(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "objective", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the Exadata VM cluster on Exascale Infrastructure.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class ExadbVmClusterIormConfigCachDbPlanArgsDict(TypedDict):
        db_name: NotRequired[pulumi.Input[str]]
        """
        The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        flash_cache_limit: NotRequired[pulumi.Input[str]]
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        share: NotRequired[pulumi.Input[int]]
        """
        The relative priority of this database.
        """
elif False:
    ExadbVmClusterIormConfigCachDbPlanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExadbVmClusterIormConfigCachDbPlanArgs:
    def __init__(__self__, *,
                 db_name: Optional[pulumi.Input[str]] = None,
                 flash_cache_limit: Optional[pulumi.Input[str]] = None,
                 share: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] db_name: The database name. For the default `DbPlan`, the `dbName` is `default`.
        :param pulumi.Input[str] flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        :param pulumi.Input[int] share: The relative priority of this database.
        """
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if flash_cache_limit is not None:
            pulumi.set(__self__, "flash_cache_limit", flash_cache_limit)
        if share is not None:
            pulumi.set(__self__, "share", share)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[pulumi.Input[str]]:
        """
        The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")

    @flash_cache_limit.setter
    def flash_cache_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flash_cache_limit", value)

    @property
    @pulumi.getter
    def share(self) -> Optional[pulumi.Input[int]]:
        """
        The relative priority of this database.
        """
        return pulumi.get(self, "share")

    @share.setter
    def share(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "share", value)


if not MYPY:
    class ExadbVmClusterNodeConfigArgsDict(TypedDict):
        enabled_ecpu_count_per_node: pulumi.Input[int]
        """
        (Updatable) The number of ECPUs to enable for each node.
        """
        total_ecpu_count_per_node: pulumi.Input[int]
        """
        (Updatable) The number of Total ECPUs for each node.
        """
        vm_file_system_storage_size_gbs_per_node: pulumi.Input[int]
        """
        (Updatable) The file system storage in GBs for each node.
        """
        memory_size_in_gbs_per_node: NotRequired[pulumi.Input[int]]
        """
        The memory that you want to be allocated in GBs to each node. Memory is calculated based on 11 GB per VM core reserved.
        """
        snapshot_file_system_storage_size_gbs_per_node: NotRequired[pulumi.Input[int]]
        """
        The file system storage in GBs for snapshot for each node.
        """
        total_file_system_storage_size_gbs_per_node: NotRequired[pulumi.Input[int]]
        """
        Total file system storage in GBs for each node.
        """
elif False:
    ExadbVmClusterNodeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExadbVmClusterNodeConfigArgs:
    def __init__(__self__, *,
                 enabled_ecpu_count_per_node: pulumi.Input[int],
                 total_ecpu_count_per_node: pulumi.Input[int],
                 vm_file_system_storage_size_gbs_per_node: pulumi.Input[int],
                 memory_size_in_gbs_per_node: Optional[pulumi.Input[int]] = None,
                 snapshot_file_system_storage_size_gbs_per_node: Optional[pulumi.Input[int]] = None,
                 total_file_system_storage_size_gbs_per_node: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] enabled_ecpu_count_per_node: (Updatable) The number of ECPUs to enable for each node.
        :param pulumi.Input[int] total_ecpu_count_per_node: (Updatable) The number of Total ECPUs for each node.
        :param pulumi.Input[int] vm_file_system_storage_size_gbs_per_node: (Updatable) The file system storage in GBs for each node.
        :param pulumi.Input[int] memory_size_in_gbs_per_node: The memory that you want to be allocated in GBs to each node. Memory is calculated based on 11 GB per VM core reserved.
        :param pulumi.Input[int] snapshot_file_system_storage_size_gbs_per_node: The file system storage in GBs for snapshot for each node.
        :param pulumi.Input[int] total_file_system_storage_size_gbs_per_node: Total file system storage in GBs for each node.
        """
        pulumi.set(__self__, "enabled_ecpu_count_per_node", enabled_ecpu_count_per_node)
        pulumi.set(__self__, "total_ecpu_count_per_node", total_ecpu_count_per_node)
        pulumi.set(__self__, "vm_file_system_storage_size_gbs_per_node", vm_file_system_storage_size_gbs_per_node)
        if memory_size_in_gbs_per_node is not None:
            pulumi.set(__self__, "memory_size_in_gbs_per_node", memory_size_in_gbs_per_node)
        if snapshot_file_system_storage_size_gbs_per_node is not None:
            pulumi.set(__self__, "snapshot_file_system_storage_size_gbs_per_node", snapshot_file_system_storage_size_gbs_per_node)
        if total_file_system_storage_size_gbs_per_node is not None:
            pulumi.set(__self__, "total_file_system_storage_size_gbs_per_node", total_file_system_storage_size_gbs_per_node)

    @property
    @pulumi.getter(name="enabledEcpuCountPerNode")
    def enabled_ecpu_count_per_node(self) -> pulumi.Input[int]:
        """
        (Updatable) The number of ECPUs to enable for each node.
        """
        return pulumi.get(self, "enabled_ecpu_count_per_node")

    @enabled_ecpu_count_per_node.setter
    def enabled_ecpu_count_per_node(self, value: pulumi.Input[int]):
        pulumi.set(self, "enabled_ecpu_count_per_node", value)

    @property
    @pulumi.getter(name="totalEcpuCountPerNode")
    def total_ecpu_count_per_node(self) -> pulumi.Input[int]:
        """
        (Updatable) The number of Total ECPUs for each node.
        """
        return pulumi.get(self, "total_ecpu_count_per_node")

    @total_ecpu_count_per_node.setter
    def total_ecpu_count_per_node(self, value: pulumi.Input[int]):
        pulumi.set(self, "total_ecpu_count_per_node", value)

    @property
    @pulumi.getter(name="vmFileSystemStorageSizeGbsPerNode")
    def vm_file_system_storage_size_gbs_per_node(self) -> pulumi.Input[int]:
        """
        (Updatable) The file system storage in GBs for each node.
        """
        return pulumi.get(self, "vm_file_system_storage_size_gbs_per_node")

    @vm_file_system_storage_size_gbs_per_node.setter
    def vm_file_system_storage_size_gbs_per_node(self, value: pulumi.Input[int]):
        pulumi.set(self, "vm_file_system_storage_size_gbs_per_node", value)

    @property
    @pulumi.getter(name="memorySizeInGbsPerNode")
    def memory_size_in_gbs_per_node(self) -> Optional[pulumi.Input[int]]:
        """
        The memory that you want to be allocated in GBs to each node. Memory is calculated based on 11 GB per VM core reserved.
        """
        return pulumi.get(self, "memory_size_in_gbs_per_node")

    @memory_size_in_gbs_per_node.setter
    def memory_size_in_gbs_per_node(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_size_in_gbs_per_node", value)

    @property
    @pulumi.getter(name="snapshotFileSystemStorageSizeGbsPerNode")
    def snapshot_file_system_storage_size_gbs_per_node(self) -> Optional[pulumi.Input[int]]:
        """
        The file system storage in GBs for snapshot for each node.
        """
        return pulumi.get(self, "snapshot_file_system_storage_size_gbs_per_node")

    @snapshot_file_system_storage_size_gbs_per_node.setter
    def snapshot_file_system_storage_size_gbs_per_node(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "snapshot_file_system_storage_size_gbs_per_node", value)

    @property
    @pulumi.getter(name="totalFileSystemStorageSizeGbsPerNode")
    def total_file_system_storage_size_gbs_per_node(self) -> Optional[pulumi.Input[int]]:
        """
        Total file system storage in GBs for each node.
        """
        return pulumi.get(self, "total_file_system_storage_size_gbs_per_node")

    @total_file_system_storage_size_gbs_per_node.setter
    def total_file_system_storage_size_gbs_per_node(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "total_file_system_storage_size_gbs_per_node", value)


if not MYPY:
    class ExadbVmClusterNodeResourceArgsDict(TypedDict):
        node_name: pulumi.Input[str]
        node_hostname: NotRequired[pulumi.Input[str]]
        """
        The host name for the node.
        """
        node_id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the node.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        The current state of the Exadata VM cluster on Exascale Infrastructure.
        """
elif False:
    ExadbVmClusterNodeResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExadbVmClusterNodeResourceArgs:
    def __init__(__self__, *,
                 node_name: pulumi.Input[str],
                 node_hostname: Optional[pulumi.Input[str]] = None,
                 node_id: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] node_hostname: The host name for the node.
        :param pulumi.Input[str] node_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the node.
        :param pulumi.Input[str] state: The current state of the Exadata VM cluster on Exascale Infrastructure.
        """
        pulumi.set(__self__, "node_name", node_name)
        if node_hostname is not None:
            pulumi.set(__self__, "node_hostname", node_hostname)
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "node_name")

    @node_name.setter
    def node_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "node_name", value)

    @property
    @pulumi.getter(name="nodeHostname")
    def node_hostname(self) -> Optional[pulumi.Input[str]]:
        """
        The host name for the node.
        """
        return pulumi.get(self, "node_hostname")

    @node_hostname.setter
    def node_hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_hostname", value)

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the node.
        """
        return pulumi.get(self, "node_id")

    @node_id.setter
    def node_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_id", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the Exadata VM cluster on Exascale Infrastructure.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class ExascaleDbStorageVaultHighCapacityDatabaseStorageArgsDict(TypedDict):
        total_size_in_gbs: pulumi.Input[int]
        """
        (Updatable) Total Capacity
        """
        available_size_in_gbs: NotRequired[pulumi.Input[int]]
        """
        Available Capacity
        """
elif False:
    ExascaleDbStorageVaultHighCapacityDatabaseStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExascaleDbStorageVaultHighCapacityDatabaseStorageArgs:
    def __init__(__self__, *,
                 total_size_in_gbs: pulumi.Input[int],
                 available_size_in_gbs: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] total_size_in_gbs: (Updatable) Total Capacity
        :param pulumi.Input[int] available_size_in_gbs: Available Capacity
        """
        pulumi.set(__self__, "total_size_in_gbs", total_size_in_gbs)
        if available_size_in_gbs is not None:
            pulumi.set(__self__, "available_size_in_gbs", available_size_in_gbs)

    @property
    @pulumi.getter(name="totalSizeInGbs")
    def total_size_in_gbs(self) -> pulumi.Input[int]:
        """
        (Updatable) Total Capacity
        """
        return pulumi.get(self, "total_size_in_gbs")

    @total_size_in_gbs.setter
    def total_size_in_gbs(self, value: pulumi.Input[int]):
        pulumi.set(self, "total_size_in_gbs", value)

    @property
    @pulumi.getter(name="availableSizeInGbs")
    def available_size_in_gbs(self) -> Optional[pulumi.Input[int]]:
        """
        Available Capacity
        """
        return pulumi.get(self, "available_size_in_gbs")

    @available_size_in_gbs.setter
    def available_size_in_gbs(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "available_size_in_gbs", value)


if not MYPY:
    class ExternalContainerDatabaseDatabaseManagementConfigArgsDict(TypedDict):
        database_management_connection_id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        database_management_status: NotRequired[pulumi.Input[str]]
        """
        The status of the Database Management service.
        """
        license_model: NotRequired[pulumi.Input[str]]
        """
        The Oracle license model that applies to the external database.
        """
elif False:
    ExternalContainerDatabaseDatabaseManagementConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalContainerDatabaseDatabaseManagementConfigArgs:
    def __init__(__self__, *,
                 database_management_connection_id: Optional[pulumi.Input[str]] = None,
                 database_management_status: Optional[pulumi.Input[str]] = None,
                 license_model: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database_management_connection_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param pulumi.Input[str] database_management_status: The status of the Database Management service.
        :param pulumi.Input[str] license_model: The Oracle license model that applies to the external database.
        """
        if database_management_connection_id is not None:
            pulumi.set(__self__, "database_management_connection_id", database_management_connection_id)
        if database_management_status is not None:
            pulumi.set(__self__, "database_management_status", database_management_status)
        if license_model is not None:
            pulumi.set(__self__, "license_model", license_model)

    @property
    @pulumi.getter(name="databaseManagementConnectionId")
    def database_management_connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "database_management_connection_id")

    @database_management_connection_id.setter
    def database_management_connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_management_connection_id", value)

    @property
    @pulumi.getter(name="databaseManagementStatus")
    def database_management_status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "database_management_status")

    @database_management_status.setter
    def database_management_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_management_status", value)

    @property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> Optional[pulumi.Input[str]]:
        """
        The Oracle license model that applies to the external database.
        """
        return pulumi.get(self, "license_model")

    @license_model.setter
    def license_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "license_model", value)


if not MYPY:
    class ExternalContainerDatabaseStackMonitoringConfigArgsDict(TypedDict):
        stack_monitoring_connector_id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        stack_monitoring_status: NotRequired[pulumi.Input[str]]
        """
        The status of Stack Monitoring.
        """
elif False:
    ExternalContainerDatabaseStackMonitoringConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalContainerDatabaseStackMonitoringConfigArgs:
    def __init__(__self__, *,
                 stack_monitoring_connector_id: Optional[pulumi.Input[str]] = None,
                 stack_monitoring_status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] stack_monitoring_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param pulumi.Input[str] stack_monitoring_status: The status of Stack Monitoring.
        """
        if stack_monitoring_connector_id is not None:
            pulumi.set(__self__, "stack_monitoring_connector_id", stack_monitoring_connector_id)
        if stack_monitoring_status is not None:
            pulumi.set(__self__, "stack_monitoring_status", stack_monitoring_status)

    @property
    @pulumi.getter(name="stackMonitoringConnectorId")
    def stack_monitoring_connector_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "stack_monitoring_connector_id")

    @stack_monitoring_connector_id.setter
    def stack_monitoring_connector_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stack_monitoring_connector_id", value)

    @property
    @pulumi.getter(name="stackMonitoringStatus")
    def stack_monitoring_status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of Stack Monitoring.
        """
        return pulumi.get(self, "stack_monitoring_status")

    @stack_monitoring_status.setter
    def stack_monitoring_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stack_monitoring_status", value)


if not MYPY:
    class ExternalDatabaseConnectorConnectionCredentialsArgsDict(TypedDict):
        credential_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The name of the credential information that used to connect to the database. The name should be in "x.y" format, where the length of "x" has a maximum of 64 characters, and length of "y" has a maximum of 199 characters. The name strings can contain letters, numbers and the underscore character only. Other characters are not valid, except for the "." character that separates the "x" and "y" portions of the name. *IMPORTANT* - The name must be unique within the Oracle Cloud Infrastructure region the credential is being created in. If you specify a name that duplicates the name of another credential within the same Oracle Cloud Infrastructure region, you may overwrite or corrupt the credential that is already using the name.

        For example: inventorydb.abc112233445566778899
        """
        credential_type: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The type of credential used to connect to the database.
        """
        password: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The password that will be used to connect to the database.
        """
        role: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The role of the user that will be connecting to the database.
        """
        ssl_secret_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        username: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The username that will be used to connect to the database.
        """
elif False:
    ExternalDatabaseConnectorConnectionCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDatabaseConnectorConnectionCredentialsArgs:
    def __init__(__self__, *,
                 credential_name: Optional[pulumi.Input[str]] = None,
                 credential_type: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 ssl_secret_id: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] credential_name: (Updatable) The name of the credential information that used to connect to the database. The name should be in "x.y" format, where the length of "x" has a maximum of 64 characters, and length of "y" has a maximum of 199 characters. The name strings can contain letters, numbers and the underscore character only. Other characters are not valid, except for the "." character that separates the "x" and "y" portions of the name. *IMPORTANT* - The name must be unique within the Oracle Cloud Infrastructure region the credential is being created in. If you specify a name that duplicates the name of another credential within the same Oracle Cloud Infrastructure region, you may overwrite or corrupt the credential that is already using the name.
               
               For example: inventorydb.abc112233445566778899
        :param pulumi.Input[str] credential_type: (Updatable) The type of credential used to connect to the database.
        :param pulumi.Input[str] password: (Updatable) The password that will be used to connect to the database.
        :param pulumi.Input[str] role: (Updatable) The role of the user that will be connecting to the database.
        :param pulumi.Input[str] ssl_secret_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        :param pulumi.Input[str] username: (Updatable) The username that will be used to connect to the database.
        """
        if credential_name is not None:
            pulumi.set(__self__, "credential_name", credential_name)
        if credential_type is not None:
            pulumi.set(__self__, "credential_type", credential_type)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if ssl_secret_id is not None:
            pulumi.set(__self__, "ssl_secret_id", ssl_secret_id)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="credentialName")
    def credential_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The name of the credential information that used to connect to the database. The name should be in "x.y" format, where the length of "x" has a maximum of 64 characters, and length of "y" has a maximum of 199 characters. The name strings can contain letters, numbers and the underscore character only. Other characters are not valid, except for the "." character that separates the "x" and "y" portions of the name. *IMPORTANT* - The name must be unique within the Oracle Cloud Infrastructure region the credential is being created in. If you specify a name that duplicates the name of another credential within the same Oracle Cloud Infrastructure region, you may overwrite or corrupt the credential that is already using the name.

        For example: inventorydb.abc112233445566778899
        """
        return pulumi.get(self, "credential_name")

    @credential_name.setter
    def credential_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credential_name", value)

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The type of credential used to connect to the database.
        """
        return pulumi.get(self, "credential_type")

    @credential_type.setter
    def credential_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credential_type", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The password that will be used to connect to the database.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The role of the user that will be connecting to the database.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter(name="sslSecretId")
    def ssl_secret_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "ssl_secret_id")

    @ssl_secret_id.setter
    def ssl_secret_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssl_secret_id", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The username that will be used to connect to the database.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ExternalDatabaseConnectorConnectionStringArgsDict(TypedDict):
        hostname: pulumi.Input[str]
        """
        (Updatable) The host name of the database.
        """
        port: pulumi.Input[int]
        """
        (Updatable) The port used to connect to the database.
        """
        protocol: pulumi.Input[str]
        """
        (Updatable) The protocol used to connect to the database.
        """
        service: pulumi.Input[str]
        """
        (Updatable) The name of the service alias used to connect to the database.
        """
elif False:
    ExternalDatabaseConnectorConnectionStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalDatabaseConnectorConnectionStringArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[str],
                 port: pulumi.Input[int],
                 protocol: pulumi.Input[str],
                 service: pulumi.Input[str]):
        """
        :param pulumi.Input[str] hostname: (Updatable) The host name of the database.
        :param pulumi.Input[int] port: (Updatable) The port used to connect to the database.
        :param pulumi.Input[str] protocol: (Updatable) The protocol used to connect to the database.
        :param pulumi.Input[str] service: (Updatable) The name of the service alias used to connect to the database.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[str]:
        """
        (Updatable) The host name of the database.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        (Updatable) The port used to connect to the database.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        (Updatable) The protocol used to connect to the database.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        (Updatable) The name of the service alias used to connect to the database.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)


if not MYPY:
    class ExternalNonContainerDatabaseDatabaseManagementConfigArgsDict(TypedDict):
        database_management_connection_id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        database_management_status: NotRequired[pulumi.Input[str]]
        """
        The status of the Database Management service.
        """
        license_model: NotRequired[pulumi.Input[str]]
        """
        The Oracle license model that applies to the external database.
        """
elif False:
    ExternalNonContainerDatabaseDatabaseManagementConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalNonContainerDatabaseDatabaseManagementConfigArgs:
    def __init__(__self__, *,
                 database_management_connection_id: Optional[pulumi.Input[str]] = None,
                 database_management_status: Optional[pulumi.Input[str]] = None,
                 license_model: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database_management_connection_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param pulumi.Input[str] database_management_status: The status of the Database Management service.
        :param pulumi.Input[str] license_model: The Oracle license model that applies to the external database.
        """
        if database_management_connection_id is not None:
            pulumi.set(__self__, "database_management_connection_id", database_management_connection_id)
        if database_management_status is not None:
            pulumi.set(__self__, "database_management_status", database_management_status)
        if license_model is not None:
            pulumi.set(__self__, "license_model", license_model)

    @property
    @pulumi.getter(name="databaseManagementConnectionId")
    def database_management_connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "database_management_connection_id")

    @database_management_connection_id.setter
    def database_management_connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_management_connection_id", value)

    @property
    @pulumi.getter(name="databaseManagementStatus")
    def database_management_status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "database_management_status")

    @database_management_status.setter
    def database_management_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_management_status", value)

    @property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> Optional[pulumi.Input[str]]:
        """
        The Oracle license model that applies to the external database.
        """
        return pulumi.get(self, "license_model")

    @license_model.setter
    def license_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "license_model", value)


if not MYPY:
    class ExternalNonContainerDatabaseOperationsInsightsConfigArgsDict(TypedDict):
        operations_insights_connector_id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        operations_insights_status: NotRequired[pulumi.Input[str]]
        """
        The status of Operations Insights
        """
elif False:
    ExternalNonContainerDatabaseOperationsInsightsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalNonContainerDatabaseOperationsInsightsConfigArgs:
    def __init__(__self__, *,
                 operations_insights_connector_id: Optional[pulumi.Input[str]] = None,
                 operations_insights_status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] operations_insights_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param pulumi.Input[str] operations_insights_status: The status of Operations Insights
        """
        if operations_insights_connector_id is not None:
            pulumi.set(__self__, "operations_insights_connector_id", operations_insights_connector_id)
        if operations_insights_status is not None:
            pulumi.set(__self__, "operations_insights_status", operations_insights_status)

    @property
    @pulumi.getter(name="operationsInsightsConnectorId")
    def operations_insights_connector_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "operations_insights_connector_id")

    @operations_insights_connector_id.setter
    def operations_insights_connector_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operations_insights_connector_id", value)

    @property
    @pulumi.getter(name="operationsInsightsStatus")
    def operations_insights_status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of Operations Insights
        """
        return pulumi.get(self, "operations_insights_status")

    @operations_insights_status.setter
    def operations_insights_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operations_insights_status", value)


if not MYPY:
    class ExternalNonContainerDatabaseStackMonitoringConfigArgsDict(TypedDict):
        stack_monitoring_connector_id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        stack_monitoring_status: NotRequired[pulumi.Input[str]]
        """
        The status of Stack Monitoring.
        """
elif False:
    ExternalNonContainerDatabaseStackMonitoringConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalNonContainerDatabaseStackMonitoringConfigArgs:
    def __init__(__self__, *,
                 stack_monitoring_connector_id: Optional[pulumi.Input[str]] = None,
                 stack_monitoring_status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] stack_monitoring_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param pulumi.Input[str] stack_monitoring_status: The status of Stack Monitoring.
        """
        if stack_monitoring_connector_id is not None:
            pulumi.set(__self__, "stack_monitoring_connector_id", stack_monitoring_connector_id)
        if stack_monitoring_status is not None:
            pulumi.set(__self__, "stack_monitoring_status", stack_monitoring_status)

    @property
    @pulumi.getter(name="stackMonitoringConnectorId")
    def stack_monitoring_connector_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "stack_monitoring_connector_id")

    @stack_monitoring_connector_id.setter
    def stack_monitoring_connector_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stack_monitoring_connector_id", value)

    @property
    @pulumi.getter(name="stackMonitoringStatus")
    def stack_monitoring_status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of Stack Monitoring.
        """
        return pulumi.get(self, "stack_monitoring_status")

    @stack_monitoring_status.setter
    def stack_monitoring_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stack_monitoring_status", value)


if not MYPY:
    class ExternalPluggableDatabaseDatabaseManagementConfigArgsDict(TypedDict):
        database_management_connection_id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        database_management_status: NotRequired[pulumi.Input[str]]
        """
        The status of the Database Management service.
        """
        license_model: NotRequired[pulumi.Input[str]]
        """
        The Oracle license model that applies to the external database.
        """
elif False:
    ExternalPluggableDatabaseDatabaseManagementConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalPluggableDatabaseDatabaseManagementConfigArgs:
    def __init__(__self__, *,
                 database_management_connection_id: Optional[pulumi.Input[str]] = None,
                 database_management_status: Optional[pulumi.Input[str]] = None,
                 license_model: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database_management_connection_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param pulumi.Input[str] database_management_status: The status of the Database Management service.
        :param pulumi.Input[str] license_model: The Oracle license model that applies to the external database.
        """
        if database_management_connection_id is not None:
            pulumi.set(__self__, "database_management_connection_id", database_management_connection_id)
        if database_management_status is not None:
            pulumi.set(__self__, "database_management_status", database_management_status)
        if license_model is not None:
            pulumi.set(__self__, "license_model", license_model)

    @property
    @pulumi.getter(name="databaseManagementConnectionId")
    def database_management_connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "database_management_connection_id")

    @database_management_connection_id.setter
    def database_management_connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_management_connection_id", value)

    @property
    @pulumi.getter(name="databaseManagementStatus")
    def database_management_status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "database_management_status")

    @database_management_status.setter
    def database_management_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_management_status", value)

    @property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> Optional[pulumi.Input[str]]:
        """
        The Oracle license model that applies to the external database.
        """
        return pulumi.get(self, "license_model")

    @license_model.setter
    def license_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "license_model", value)


if not MYPY:
    class ExternalPluggableDatabaseOperationsInsightsConfigArgsDict(TypedDict):
        operations_insights_connector_id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        operations_insights_status: NotRequired[pulumi.Input[str]]
        """
        The status of Operations Insights
        """
elif False:
    ExternalPluggableDatabaseOperationsInsightsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalPluggableDatabaseOperationsInsightsConfigArgs:
    def __init__(__self__, *,
                 operations_insights_connector_id: Optional[pulumi.Input[str]] = None,
                 operations_insights_status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] operations_insights_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param pulumi.Input[str] operations_insights_status: The status of Operations Insights
        """
        if operations_insights_connector_id is not None:
            pulumi.set(__self__, "operations_insights_connector_id", operations_insights_connector_id)
        if operations_insights_status is not None:
            pulumi.set(__self__, "operations_insights_status", operations_insights_status)

    @property
    @pulumi.getter(name="operationsInsightsConnectorId")
    def operations_insights_connector_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "operations_insights_connector_id")

    @operations_insights_connector_id.setter
    def operations_insights_connector_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operations_insights_connector_id", value)

    @property
    @pulumi.getter(name="operationsInsightsStatus")
    def operations_insights_status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of Operations Insights
        """
        return pulumi.get(self, "operations_insights_status")

    @operations_insights_status.setter
    def operations_insights_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operations_insights_status", value)


if not MYPY:
    class ExternalPluggableDatabaseStackMonitoringConfigArgsDict(TypedDict):
        stack_monitoring_connector_id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        stack_monitoring_status: NotRequired[pulumi.Input[str]]
        """
        The status of Stack Monitoring.
        """
elif False:
    ExternalPluggableDatabaseStackMonitoringConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalPluggableDatabaseStackMonitoringConfigArgs:
    def __init__(__self__, *,
                 stack_monitoring_connector_id: Optional[pulumi.Input[str]] = None,
                 stack_monitoring_status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] stack_monitoring_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param pulumi.Input[str] stack_monitoring_status: The status of Stack Monitoring.
        """
        if stack_monitoring_connector_id is not None:
            pulumi.set(__self__, "stack_monitoring_connector_id", stack_monitoring_connector_id)
        if stack_monitoring_status is not None:
            pulumi.set(__self__, "stack_monitoring_status", stack_monitoring_status)

    @property
    @pulumi.getter(name="stackMonitoringConnectorId")
    def stack_monitoring_connector_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "stack_monitoring_connector_id")

    @stack_monitoring_connector_id.setter
    def stack_monitoring_connector_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stack_monitoring_connector_id", value)

    @property
    @pulumi.getter(name="stackMonitoringStatus")
    def stack_monitoring_status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of Stack Monitoring.
        """
        return pulumi.get(self, "stack_monitoring_status")

    @stack_monitoring_status.setter
    def stack_monitoring_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stack_monitoring_status", value)


if not MYPY:
    class KeyStoreAssociatedDatabaseArgsDict(TypedDict):
        db_name: NotRequired[pulumi.Input[str]]
        """
        The name of the database that is associated with the key store.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        """
elif False:
    KeyStoreAssociatedDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeyStoreAssociatedDatabaseArgs:
    def __init__(__self__, *,
                 db_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] db_name: The name of the database that is associated with the key store.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        """
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the database that is associated with the key store.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class KeyStoreTypeDetailsArgsDict(TypedDict):
        admin_username: pulumi.Input[str]
        """
        (Updatable) The administrator username to connect to Oracle Key Vault
        """
        connection_ips: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        (Updatable) The list of Oracle Key Vault connection IP addresses.
        """
        secret_id: pulumi.Input[str]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        type: pulumi.Input[str]
        """
        (Updatable) The type of key store.
        """
        vault_id: pulumi.Input[str]
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    KeyStoreTypeDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeyStoreTypeDetailsArgs:
    def __init__(__self__, *,
                 admin_username: pulumi.Input[str],
                 connection_ips: pulumi.Input[Sequence[pulumi.Input[str]]],
                 secret_id: pulumi.Input[str],
                 type: pulumi.Input[str],
                 vault_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] admin_username: (Updatable) The administrator username to connect to Oracle Key Vault
        :param pulumi.Input[Sequence[pulumi.Input[str]]] connection_ips: (Updatable) The list of Oracle Key Vault connection IP addresses.
        :param pulumi.Input[str] secret_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        :param pulumi.Input[str] type: (Updatable) The type of key store.
        :param pulumi.Input[str] vault_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "admin_username", admin_username)
        pulumi.set(__self__, "connection_ips", connection_ips)
        pulumi.set(__self__, "secret_id", secret_id)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vault_id", vault_id)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> pulumi.Input[str]:
        """
        (Updatable) The administrator username to connect to Oracle Key Vault
        """
        return pulumi.get(self, "admin_username")

    @admin_username.setter
    def admin_username(self, value: pulumi.Input[str]):
        pulumi.set(self, "admin_username", value)

    @property
    @pulumi.getter(name="connectionIps")
    def connection_ips(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        (Updatable) The list of Oracle Key Vault connection IP addresses.
        """
        return pulumi.get(self, "connection_ips")

    @connection_ips.setter
    def connection_ips(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "connection_ips", value)

    @property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "secret_id")

    @secret_id.setter
    def secret_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) The type of key store.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts). This parameter and `secretId` are required for Customer Managed Keys.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "vault_id")

    @vault_id.setter
    def vault_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "vault_id", value)


if not MYPY:
    class MaintenanceRunEstimatedPatchingTimeArgsDict(TypedDict):
        estimated_db_server_patching_time: NotRequired[pulumi.Input[int]]
        """
        The estimated time required in minutes for database server patching.
        """
        estimated_network_switches_patching_time: NotRequired[pulumi.Input[int]]
        """
        The estimated time required in minutes for network switch patching.
        """
        estimated_storage_server_patching_time: NotRequired[pulumi.Input[int]]
        """
        The estimated time required in minutes for storage server patching.
        """
        total_estimated_patching_time: NotRequired[pulumi.Input[int]]
        """
        The estimated total time required in minutes for all patching operations.
        """
elif False:
    MaintenanceRunEstimatedPatchingTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceRunEstimatedPatchingTimeArgs:
    def __init__(__self__, *,
                 estimated_db_server_patching_time: Optional[pulumi.Input[int]] = None,
                 estimated_network_switches_patching_time: Optional[pulumi.Input[int]] = None,
                 estimated_storage_server_patching_time: Optional[pulumi.Input[int]] = None,
                 total_estimated_patching_time: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] estimated_db_server_patching_time: The estimated time required in minutes for database server patching.
        :param pulumi.Input[int] estimated_network_switches_patching_time: The estimated time required in minutes for network switch patching.
        :param pulumi.Input[int] estimated_storage_server_patching_time: The estimated time required in minutes for storage server patching.
        :param pulumi.Input[int] total_estimated_patching_time: The estimated total time required in minutes for all patching operations.
        """
        if estimated_db_server_patching_time is not None:
            pulumi.set(__self__, "estimated_db_server_patching_time", estimated_db_server_patching_time)
        if estimated_network_switches_patching_time is not None:
            pulumi.set(__self__, "estimated_network_switches_patching_time", estimated_network_switches_patching_time)
        if estimated_storage_server_patching_time is not None:
            pulumi.set(__self__, "estimated_storage_server_patching_time", estimated_storage_server_patching_time)
        if total_estimated_patching_time is not None:
            pulumi.set(__self__, "total_estimated_patching_time", total_estimated_patching_time)

    @property
    @pulumi.getter(name="estimatedDbServerPatchingTime")
    def estimated_db_server_patching_time(self) -> Optional[pulumi.Input[int]]:
        """
        The estimated time required in minutes for database server patching.
        """
        return pulumi.get(self, "estimated_db_server_patching_time")

    @estimated_db_server_patching_time.setter
    def estimated_db_server_patching_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "estimated_db_server_patching_time", value)

    @property
    @pulumi.getter(name="estimatedNetworkSwitchesPatchingTime")
    def estimated_network_switches_patching_time(self) -> Optional[pulumi.Input[int]]:
        """
        The estimated time required in minutes for network switch patching.
        """
        return pulumi.get(self, "estimated_network_switches_patching_time")

    @estimated_network_switches_patching_time.setter
    def estimated_network_switches_patching_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "estimated_network_switches_patching_time", value)

    @property
    @pulumi.getter(name="estimatedStorageServerPatchingTime")
    def estimated_storage_server_patching_time(self) -> Optional[pulumi.Input[int]]:
        """
        The estimated time required in minutes for storage server patching.
        """
        return pulumi.get(self, "estimated_storage_server_patching_time")

    @estimated_storage_server_patching_time.setter
    def estimated_storage_server_patching_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "estimated_storage_server_patching_time", value)

    @property
    @pulumi.getter(name="totalEstimatedPatchingTime")
    def total_estimated_patching_time(self) -> Optional[pulumi.Input[int]]:
        """
        The estimated total time required in minutes for all patching operations.
        """
        return pulumi.get(self, "total_estimated_patching_time")

    @total_estimated_patching_time.setter
    def total_estimated_patching_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "total_estimated_patching_time", value)


if not MYPY:
    class PluggableDatabaseConnectionStringArgsDict(TypedDict):
        all_connection_strings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        All connection strings to use to connect to the pluggable database.
        """
        pdb_default: NotRequired[pulumi.Input[str]]
        """
        A host name-based PDB connection string.
        """
        pdb_ip_default: NotRequired[pulumi.Input[str]]
        """
        An IP-based PDB connection string.
        """
elif False:
    PluggableDatabaseConnectionStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PluggableDatabaseConnectionStringArgs:
    def __init__(__self__, *,
                 all_connection_strings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 pdb_default: Optional[pulumi.Input[str]] = None,
                 pdb_ip_default: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] all_connection_strings: All connection strings to use to connect to the pluggable database.
        :param pulumi.Input[str] pdb_default: A host name-based PDB connection string.
        :param pulumi.Input[str] pdb_ip_default: An IP-based PDB connection string.
        """
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if pdb_default is not None:
            pulumi.set(__self__, "pdb_default", pdb_default)
        if pdb_ip_default is not None:
            pulumi.set(__self__, "pdb_ip_default", pdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        All connection strings to use to connect to the pluggable database.
        """
        return pulumi.get(self, "all_connection_strings")

    @all_connection_strings.setter
    def all_connection_strings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "all_connection_strings", value)

    @property
    @pulumi.getter(name="pdbDefault")
    def pdb_default(self) -> Optional[pulumi.Input[str]]:
        """
        A host name-based PDB connection string.
        """
        return pulumi.get(self, "pdb_default")

    @pdb_default.setter
    def pdb_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pdb_default", value)

    @property
    @pulumi.getter(name="pdbIpDefault")
    def pdb_ip_default(self) -> Optional[pulumi.Input[str]]:
        """
        An IP-based PDB connection string.
        """
        return pulumi.get(self, "pdb_ip_default")

    @pdb_ip_default.setter
    def pdb_ip_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pdb_ip_default", value)


if not MYPY:
    class PluggableDatabaseManagementsManagementConnectionStringArgsDict(TypedDict):
        enable_pluggabledatabasemanagement: pulumi.Input[bool]
        """
        (Updatable) A required field when set to `true` calls enable action and when set to `false` calls disable action.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        all_connection_strings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        All connection strings to use to connect to the pluggable database.
        """
        pdb_default: NotRequired[pulumi.Input[str]]
        """
        A host name-based PDB connection string.
        """
        pdb_ip_default: NotRequired[pulumi.Input[str]]
        """
        An IP-based PDB connection string.
        """
elif False:
    PluggableDatabaseManagementsManagementConnectionStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PluggableDatabaseManagementsManagementConnectionStringArgs:
    def __init__(__self__, *,
                 enable_pluggabledatabasemanagement: pulumi.Input[bool],
                 all_connection_strings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 pdb_default: Optional[pulumi.Input[str]] = None,
                 pdb_ip_default: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enable_pluggabledatabasemanagement: (Updatable) A required field when set to `true` calls enable action and when set to `false` calls disable action.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] all_connection_strings: All connection strings to use to connect to the pluggable database.
        :param pulumi.Input[str] pdb_default: A host name-based PDB connection string.
        :param pulumi.Input[str] pdb_ip_default: An IP-based PDB connection string.
        """
        pulumi.set(__self__, "enable_pluggabledatabasemanagement", enable_pluggabledatabasemanagement)
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if pdb_default is not None:
            pulumi.set(__self__, "pdb_default", pdb_default)
        if pdb_ip_default is not None:
            pulumi.set(__self__, "pdb_ip_default", pdb_ip_default)

    @property
    @pulumi.getter(name="enablePluggabledatabasemanagement")
    def enable_pluggabledatabasemanagement(self) -> pulumi.Input[bool]:
        """
        (Updatable) A required field when set to `true` calls enable action and when set to `false` calls disable action.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "enable_pluggabledatabasemanagement")

    @enable_pluggabledatabasemanagement.setter
    def enable_pluggabledatabasemanagement(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enable_pluggabledatabasemanagement", value)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        All connection strings to use to connect to the pluggable database.
        """
        return pulumi.get(self, "all_connection_strings")

    @all_connection_strings.setter
    def all_connection_strings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "all_connection_strings", value)

    @property
    @pulumi.getter(name="pdbDefault")
    def pdb_default(self) -> Optional[pulumi.Input[str]]:
        """
        A host name-based PDB connection string.
        """
        return pulumi.get(self, "pdb_default")

    @pdb_default.setter
    def pdb_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pdb_default", value)

    @property
    @pulumi.getter(name="pdbIpDefault")
    def pdb_ip_default(self) -> Optional[pulumi.Input[str]]:
        """
        An IP-based PDB connection string.
        """
        return pulumi.get(self, "pdb_ip_default")

    @pdb_ip_default.setter
    def pdb_ip_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pdb_ip_default", value)


if not MYPY:
    class PluggableDatabaseManagementsManagementCredentialDetailsArgsDict(TypedDict):
        password_secret_id: pulumi.Input[str]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        user_name: pulumi.Input[str]
        """
        The name of the Oracle Database user that will be used to connect to the database.
        """
elif False:
    PluggableDatabaseManagementsManagementCredentialDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PluggableDatabaseManagementsManagementCredentialDetailsArgs:
    def __init__(__self__, *,
                 password_secret_id: pulumi.Input[str],
                 user_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password_secret_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        :param pulumi.Input[str] user_name: The name of the Oracle Database user that will be used to connect to the database.
        """
        pulumi.set(__self__, "password_secret_id", password_secret_id)
        pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="passwordSecretId")
    def password_secret_id(self) -> pulumi.Input[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "password_secret_id")

    @password_secret_id.setter
    def password_secret_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "password_secret_id", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> pulumi.Input[str]:
        """
        The name of the Oracle Database user that will be used to connect to the database.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class PluggableDatabaseManagementsManagementPluggableDatabaseManagementConfigArgsDict(TypedDict):
        enable_pluggabledatabasemanagement: pulumi.Input[bool]
        """
        (Updatable) A required field when set to `true` calls enable action and when set to `false` calls disable action.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        management_status: NotRequired[pulumi.Input[str]]
        """
        The status of the Pluggable Database Management service.
        """
elif False:
    PluggableDatabaseManagementsManagementPluggableDatabaseManagementConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PluggableDatabaseManagementsManagementPluggableDatabaseManagementConfigArgs:
    def __init__(__self__, *,
                 enable_pluggabledatabasemanagement: pulumi.Input[bool],
                 management_status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enable_pluggabledatabasemanagement: (Updatable) A required field when set to `true` calls enable action and when set to `false` calls disable action.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param pulumi.Input[str] management_status: The status of the Pluggable Database Management service.
        """
        pulumi.set(__self__, "enable_pluggabledatabasemanagement", enable_pluggabledatabasemanagement)
        if management_status is not None:
            pulumi.set(__self__, "management_status", management_status)

    @property
    @pulumi.getter(name="enablePluggabledatabasemanagement")
    def enable_pluggabledatabasemanagement(self) -> pulumi.Input[bool]:
        """
        (Updatable) A required field when set to `true` calls enable action and when set to `false` calls disable action.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "enable_pluggabledatabasemanagement")

    @enable_pluggabledatabasemanagement.setter
    def enable_pluggabledatabasemanagement(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enable_pluggabledatabasemanagement", value)

    @property
    @pulumi.getter(name="managementStatus")
    def management_status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the Pluggable Database Management service.
        """
        return pulumi.get(self, "management_status")

    @management_status.setter
    def management_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "management_status", value)


if not MYPY:
    class PluggableDatabasePdbCreationTypeDetailsArgsDict(TypedDict):
        creation_type: pulumi.Input[str]
        """
        The Pluggable Database creation type.
        """
        source_pluggable_database_id: pulumi.Input[str]
        """
        The OCID of the Source Pluggable Database.
        """
        dblink_user_password: NotRequired[pulumi.Input[str]]
        """
        The DB link user password.
        """
        dblink_username: NotRequired[pulumi.Input[str]]
        """
        The name of the DB link user.
        """
        is_thin_clone: NotRequired[pulumi.Input[bool]]
        """
        True if Pluggable Database needs to be thin cloned and false if Pluggable Database needs to be thick cloned.
        """
        refreshable_clone_details: NotRequired[pulumi.Input['PluggableDatabasePdbCreationTypeDetailsRefreshableCloneDetailsArgsDict']]
        """
        Parameters for creating Pluggable Database Refreshable Clone. **Warning:** Oracle recommends that you avoid using any confidential information when you supply string values using the API.
        """
        source_container_database_admin_password: NotRequired[pulumi.Input[str]]
        """
        The DB system administrator password of the source Container Database.
        """
elif False:
    PluggableDatabasePdbCreationTypeDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PluggableDatabasePdbCreationTypeDetailsArgs:
    def __init__(__self__, *,
                 creation_type: pulumi.Input[str],
                 source_pluggable_database_id: pulumi.Input[str],
                 dblink_user_password: Optional[pulumi.Input[str]] = None,
                 dblink_username: Optional[pulumi.Input[str]] = None,
                 is_thin_clone: Optional[pulumi.Input[bool]] = None,
                 refreshable_clone_details: Optional[pulumi.Input['PluggableDatabasePdbCreationTypeDetailsRefreshableCloneDetailsArgs']] = None,
                 source_container_database_admin_password: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] creation_type: The Pluggable Database creation type.
        :param pulumi.Input[str] source_pluggable_database_id: The OCID of the Source Pluggable Database.
        :param pulumi.Input[str] dblink_user_password: The DB link user password.
        :param pulumi.Input[str] dblink_username: The name of the DB link user.
        :param pulumi.Input[bool] is_thin_clone: True if Pluggable Database needs to be thin cloned and false if Pluggable Database needs to be thick cloned.
        :param pulumi.Input['PluggableDatabasePdbCreationTypeDetailsRefreshableCloneDetailsArgs'] refreshable_clone_details: Parameters for creating Pluggable Database Refreshable Clone. **Warning:** Oracle recommends that you avoid using any confidential information when you supply string values using the API.
        :param pulumi.Input[str] source_container_database_admin_password: The DB system administrator password of the source Container Database.
        """
        pulumi.set(__self__, "creation_type", creation_type)
        pulumi.set(__self__, "source_pluggable_database_id", source_pluggable_database_id)
        if dblink_user_password is not None:
            pulumi.set(__self__, "dblink_user_password", dblink_user_password)
        if dblink_username is not None:
            pulumi.set(__self__, "dblink_username", dblink_username)
        if is_thin_clone is not None:
            pulumi.set(__self__, "is_thin_clone", is_thin_clone)
        if refreshable_clone_details is not None:
            pulumi.set(__self__, "refreshable_clone_details", refreshable_clone_details)
        if source_container_database_admin_password is not None:
            pulumi.set(__self__, "source_container_database_admin_password", source_container_database_admin_password)

    @property
    @pulumi.getter(name="creationType")
    def creation_type(self) -> pulumi.Input[str]:
        """
        The Pluggable Database creation type.
        """
        return pulumi.get(self, "creation_type")

    @creation_type.setter
    def creation_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "creation_type", value)

    @property
    @pulumi.getter(name="sourcePluggableDatabaseId")
    def source_pluggable_database_id(self) -> pulumi.Input[str]:
        """
        The OCID of the Source Pluggable Database.
        """
        return pulumi.get(self, "source_pluggable_database_id")

    @source_pluggable_database_id.setter
    def source_pluggable_database_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_pluggable_database_id", value)

    @property
    @pulumi.getter(name="dblinkUserPassword")
    def dblink_user_password(self) -> Optional[pulumi.Input[str]]:
        """
        The DB link user password.
        """
        return pulumi.get(self, "dblink_user_password")

    @dblink_user_password.setter
    def dblink_user_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dblink_user_password", value)

    @property
    @pulumi.getter(name="dblinkUsername")
    def dblink_username(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the DB link user.
        """
        return pulumi.get(self, "dblink_username")

    @dblink_username.setter
    def dblink_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dblink_username", value)

    @property
    @pulumi.getter(name="isThinClone")
    def is_thin_clone(self) -> Optional[pulumi.Input[bool]]:
        """
        True if Pluggable Database needs to be thin cloned and false if Pluggable Database needs to be thick cloned.
        """
        return pulumi.get(self, "is_thin_clone")

    @is_thin_clone.setter
    def is_thin_clone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_thin_clone", value)

    @property
    @pulumi.getter(name="refreshableCloneDetails")
    def refreshable_clone_details(self) -> Optional[pulumi.Input['PluggableDatabasePdbCreationTypeDetailsRefreshableCloneDetailsArgs']]:
        """
        Parameters for creating Pluggable Database Refreshable Clone. **Warning:** Oracle recommends that you avoid using any confidential information when you supply string values using the API.
        """
        return pulumi.get(self, "refreshable_clone_details")

    @refreshable_clone_details.setter
    def refreshable_clone_details(self, value: Optional[pulumi.Input['PluggableDatabasePdbCreationTypeDetailsRefreshableCloneDetailsArgs']]):
        pulumi.set(self, "refreshable_clone_details", value)

    @property
    @pulumi.getter(name="sourceContainerDatabaseAdminPassword")
    def source_container_database_admin_password(self) -> Optional[pulumi.Input[str]]:
        """
        The DB system administrator password of the source Container Database.
        """
        return pulumi.get(self, "source_container_database_admin_password")

    @source_container_database_admin_password.setter
    def source_container_database_admin_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_container_database_admin_password", value)


if not MYPY:
    class PluggableDatabasePdbCreationTypeDetailsRefreshableCloneDetailsArgsDict(TypedDict):
        is_refreshable_clone: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether Pluggable Database is a refreshable clone.
        """
elif False:
    PluggableDatabasePdbCreationTypeDetailsRefreshableCloneDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PluggableDatabasePdbCreationTypeDetailsRefreshableCloneDetailsArgs:
    def __init__(__self__, *,
                 is_refreshable_clone: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_refreshable_clone: Indicates whether Pluggable Database is a refreshable clone.
        """
        if is_refreshable_clone is not None:
            pulumi.set(__self__, "is_refreshable_clone", is_refreshable_clone)

    @property
    @pulumi.getter(name="isRefreshableClone")
    def is_refreshable_clone(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether Pluggable Database is a refreshable clone.
        """
        return pulumi.get(self, "is_refreshable_clone")

    @is_refreshable_clone.setter
    def is_refreshable_clone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_refreshable_clone", value)


if not MYPY:
    class PluggableDatabasePdbNodeLevelDetailArgsDict(TypedDict):
        node_name: NotRequired[pulumi.Input[str]]
        """
        The Node name of the Database Instance.
        """
        open_mode: NotRequired[pulumi.Input[str]]
        """
        The mode that pluggable database is in. Open mode can only be changed to READ_ONLY or MIGRATE directly from the backend (within the Oracle Database software).
        """
elif False:
    PluggableDatabasePdbNodeLevelDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PluggableDatabasePdbNodeLevelDetailArgs:
    def __init__(__self__, *,
                 node_name: Optional[pulumi.Input[str]] = None,
                 open_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] node_name: The Node name of the Database Instance.
        :param pulumi.Input[str] open_mode: The mode that pluggable database is in. Open mode can only be changed to READ_ONLY or MIGRATE directly from the backend (within the Oracle Database software).
        """
        if node_name is not None:
            pulumi.set(__self__, "node_name", node_name)
        if open_mode is not None:
            pulumi.set(__self__, "open_mode", open_mode)

    @property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> Optional[pulumi.Input[str]]:
        """
        The Node name of the Database Instance.
        """
        return pulumi.get(self, "node_name")

    @node_name.setter
    def node_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_name", value)

    @property
    @pulumi.getter(name="openMode")
    def open_mode(self) -> Optional[pulumi.Input[str]]:
        """
        The mode that pluggable database is in. Open mode can only be changed to READ_ONLY or MIGRATE directly from the backend (within the Oracle Database software).
        """
        return pulumi.get(self, "open_mode")

    @open_mode.setter
    def open_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "open_mode", value)


if not MYPY:
    class PluggableDatabasePluggableDatabaseManagementConfigArgsDict(TypedDict):
        management_status: NotRequired[pulumi.Input[str]]
        """
        The status of the Pluggable Database Management service.
        """
elif False:
    PluggableDatabasePluggableDatabaseManagementConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PluggableDatabasePluggableDatabaseManagementConfigArgs:
    def __init__(__self__, *,
                 management_status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] management_status: The status of the Pluggable Database Management service.
        """
        if management_status is not None:
            pulumi.set(__self__, "management_status", management_status)

    @property
    @pulumi.getter(name="managementStatus")
    def management_status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the Pluggable Database Management service.
        """
        return pulumi.get(self, "management_status")

    @management_status.setter
    def management_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "management_status", value)


if not MYPY:
    class PluggableDatabaseRefreshableCloneConfigArgsDict(TypedDict):
        is_refreshable_clone: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether the Pluggable Database is a refreshable clone.
        """
elif False:
    PluggableDatabaseRefreshableCloneConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PluggableDatabaseRefreshableCloneConfigArgs:
    def __init__(__self__, *,
                 is_refreshable_clone: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_refreshable_clone: Indicates whether the Pluggable Database is a refreshable clone.
        """
        if is_refreshable_clone is not None:
            pulumi.set(__self__, "is_refreshable_clone", is_refreshable_clone)

    @property
    @pulumi.getter(name="isRefreshableClone")
    def is_refreshable_clone(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the Pluggable Database is a refreshable clone.
        """
        return pulumi.get(self, "is_refreshable_clone")

    @is_refreshable_clone.setter
    def is_refreshable_clone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_refreshable_clone", value)


if not MYPY:
    class PluggableDatabasesLocalCloneConnectionStringArgsDict(TypedDict):
        all_connection_strings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        All connection strings to use to connect to the pluggable database.
        """
        pdb_default: NotRequired[pulumi.Input[str]]
        """
        A host name-based PDB connection string.
        """
        pdb_ip_default: NotRequired[pulumi.Input[str]]
        """
        An IP-based PDB connection string.
        """
elif False:
    PluggableDatabasesLocalCloneConnectionStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PluggableDatabasesLocalCloneConnectionStringArgs:
    def __init__(__self__, *,
                 all_connection_strings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 pdb_default: Optional[pulumi.Input[str]] = None,
                 pdb_ip_default: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] all_connection_strings: All connection strings to use to connect to the pluggable database.
        :param pulumi.Input[str] pdb_default: A host name-based PDB connection string.
        :param pulumi.Input[str] pdb_ip_default: An IP-based PDB connection string.
        """
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if pdb_default is not None:
            pulumi.set(__self__, "pdb_default", pdb_default)
        if pdb_ip_default is not None:
            pulumi.set(__self__, "pdb_ip_default", pdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        All connection strings to use to connect to the pluggable database.
        """
        return pulumi.get(self, "all_connection_strings")

    @all_connection_strings.setter
    def all_connection_strings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "all_connection_strings", value)

    @property
    @pulumi.getter(name="pdbDefault")
    def pdb_default(self) -> Optional[pulumi.Input[str]]:
        """
        A host name-based PDB connection string.
        """
        return pulumi.get(self, "pdb_default")

    @pdb_default.setter
    def pdb_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pdb_default", value)

    @property
    @pulumi.getter(name="pdbIpDefault")
    def pdb_ip_default(self) -> Optional[pulumi.Input[str]]:
        """
        An IP-based PDB connection string.
        """
        return pulumi.get(self, "pdb_ip_default")

    @pdb_ip_default.setter
    def pdb_ip_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pdb_ip_default", value)


if not MYPY:
    class PluggableDatabasesLocalClonePdbNodeLevelDetailArgsDict(TypedDict):
        node_name: NotRequired[pulumi.Input[str]]
        """
        The Node name of the Database Instance.
        """
        open_mode: NotRequired[pulumi.Input[str]]
        """
        The mode that pluggable database is in. Open mode can only be changed to READ_ONLY or MIGRATE directly from the backend (within the Oracle Database software).
        """
elif False:
    PluggableDatabasesLocalClonePdbNodeLevelDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PluggableDatabasesLocalClonePdbNodeLevelDetailArgs:
    def __init__(__self__, *,
                 node_name: Optional[pulumi.Input[str]] = None,
                 open_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] node_name: The Node name of the Database Instance.
        :param pulumi.Input[str] open_mode: The mode that pluggable database is in. Open mode can only be changed to READ_ONLY or MIGRATE directly from the backend (within the Oracle Database software).
        """
        if node_name is not None:
            pulumi.set(__self__, "node_name", node_name)
        if open_mode is not None:
            pulumi.set(__self__, "open_mode", open_mode)

    @property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> Optional[pulumi.Input[str]]:
        """
        The Node name of the Database Instance.
        """
        return pulumi.get(self, "node_name")

    @node_name.setter
    def node_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_name", value)

    @property
    @pulumi.getter(name="openMode")
    def open_mode(self) -> Optional[pulumi.Input[str]]:
        """
        The mode that pluggable database is in. Open mode can only be changed to READ_ONLY or MIGRATE directly from the backend (within the Oracle Database software).
        """
        return pulumi.get(self, "open_mode")

    @open_mode.setter
    def open_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "open_mode", value)


if not MYPY:
    class PluggableDatabasesLocalClonePluggableDatabaseManagementConfigArgsDict(TypedDict):
        management_status: NotRequired[pulumi.Input[str]]
        """
        The status of the Pluggable Database Management service.
        """
elif False:
    PluggableDatabasesLocalClonePluggableDatabaseManagementConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PluggableDatabasesLocalClonePluggableDatabaseManagementConfigArgs:
    def __init__(__self__, *,
                 management_status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] management_status: The status of the Pluggable Database Management service.
        """
        if management_status is not None:
            pulumi.set(__self__, "management_status", management_status)

    @property
    @pulumi.getter(name="managementStatus")
    def management_status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the Pluggable Database Management service.
        """
        return pulumi.get(self, "management_status")

    @management_status.setter
    def management_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "management_status", value)


if not MYPY:
    class PluggableDatabasesLocalCloneRefreshableCloneConfigArgsDict(TypedDict):
        is_refreshable_clone: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether the Pluggable Database is a refreshable clone.
        """
elif False:
    PluggableDatabasesLocalCloneRefreshableCloneConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PluggableDatabasesLocalCloneRefreshableCloneConfigArgs:
    def __init__(__self__, *,
                 is_refreshable_clone: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_refreshable_clone: Indicates whether the Pluggable Database is a refreshable clone.
        """
        if is_refreshable_clone is not None:
            pulumi.set(__self__, "is_refreshable_clone", is_refreshable_clone)

    @property
    @pulumi.getter(name="isRefreshableClone")
    def is_refreshable_clone(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the Pluggable Database is a refreshable clone.
        """
        return pulumi.get(self, "is_refreshable_clone")

    @is_refreshable_clone.setter
    def is_refreshable_clone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_refreshable_clone", value)


if not MYPY:
    class PluggableDatabasesRemoteCloneConnectionStringArgsDict(TypedDict):
        all_connection_strings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        All connection strings to use to connect to the pluggable database.
        """
        pdb_default: NotRequired[pulumi.Input[str]]
        """
        A host name-based PDB connection string.
        """
        pdb_ip_default: NotRequired[pulumi.Input[str]]
        """
        An IP-based PDB connection string.
        """
elif False:
    PluggableDatabasesRemoteCloneConnectionStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PluggableDatabasesRemoteCloneConnectionStringArgs:
    def __init__(__self__, *,
                 all_connection_strings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 pdb_default: Optional[pulumi.Input[str]] = None,
                 pdb_ip_default: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] all_connection_strings: All connection strings to use to connect to the pluggable database.
        :param pulumi.Input[str] pdb_default: A host name-based PDB connection string.
        :param pulumi.Input[str] pdb_ip_default: An IP-based PDB connection string.
        """
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if pdb_default is not None:
            pulumi.set(__self__, "pdb_default", pdb_default)
        if pdb_ip_default is not None:
            pulumi.set(__self__, "pdb_ip_default", pdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        All connection strings to use to connect to the pluggable database.
        """
        return pulumi.get(self, "all_connection_strings")

    @all_connection_strings.setter
    def all_connection_strings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "all_connection_strings", value)

    @property
    @pulumi.getter(name="pdbDefault")
    def pdb_default(self) -> Optional[pulumi.Input[str]]:
        """
        A host name-based PDB connection string.
        """
        return pulumi.get(self, "pdb_default")

    @pdb_default.setter
    def pdb_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pdb_default", value)

    @property
    @pulumi.getter(name="pdbIpDefault")
    def pdb_ip_default(self) -> Optional[pulumi.Input[str]]:
        """
        An IP-based PDB connection string.
        """
        return pulumi.get(self, "pdb_ip_default")

    @pdb_ip_default.setter
    def pdb_ip_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pdb_ip_default", value)


if not MYPY:
    class PluggableDatabasesRemoteClonePdbNodeLevelDetailArgsDict(TypedDict):
        node_name: NotRequired[pulumi.Input[str]]
        """
        The Node name of the Database Instance.
        """
        open_mode: NotRequired[pulumi.Input[str]]
        """
        The mode that pluggable database is in. Open mode can only be changed to READ_ONLY or MIGRATE directly from the backend (within the Oracle Database software).
        """
elif False:
    PluggableDatabasesRemoteClonePdbNodeLevelDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PluggableDatabasesRemoteClonePdbNodeLevelDetailArgs:
    def __init__(__self__, *,
                 node_name: Optional[pulumi.Input[str]] = None,
                 open_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] node_name: The Node name of the Database Instance.
        :param pulumi.Input[str] open_mode: The mode that pluggable database is in. Open mode can only be changed to READ_ONLY or MIGRATE directly from the backend (within the Oracle Database software).
        """
        if node_name is not None:
            pulumi.set(__self__, "node_name", node_name)
        if open_mode is not None:
            pulumi.set(__self__, "open_mode", open_mode)

    @property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> Optional[pulumi.Input[str]]:
        """
        The Node name of the Database Instance.
        """
        return pulumi.get(self, "node_name")

    @node_name.setter
    def node_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_name", value)

    @property
    @pulumi.getter(name="openMode")
    def open_mode(self) -> Optional[pulumi.Input[str]]:
        """
        The mode that pluggable database is in. Open mode can only be changed to READ_ONLY or MIGRATE directly from the backend (within the Oracle Database software).
        """
        return pulumi.get(self, "open_mode")

    @open_mode.setter
    def open_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "open_mode", value)


if not MYPY:
    class PluggableDatabasesRemoteClonePluggableDatabaseManagementConfigArgsDict(TypedDict):
        management_status: NotRequired[pulumi.Input[str]]
        """
        The status of the Pluggable Database Management service.
        """
elif False:
    PluggableDatabasesRemoteClonePluggableDatabaseManagementConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PluggableDatabasesRemoteClonePluggableDatabaseManagementConfigArgs:
    def __init__(__self__, *,
                 management_status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] management_status: The status of the Pluggable Database Management service.
        """
        if management_status is not None:
            pulumi.set(__self__, "management_status", management_status)

    @property
    @pulumi.getter(name="managementStatus")
    def management_status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the Pluggable Database Management service.
        """
        return pulumi.get(self, "management_status")

    @management_status.setter
    def management_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "management_status", value)


if not MYPY:
    class PluggableDatabasesRemoteCloneRefreshableCloneConfigArgsDict(TypedDict):
        is_refreshable_clone: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether the Pluggable Database is a refreshable clone.
        """
elif False:
    PluggableDatabasesRemoteCloneRefreshableCloneConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PluggableDatabasesRemoteCloneRefreshableCloneConfigArgs:
    def __init__(__self__, *,
                 is_refreshable_clone: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_refreshable_clone: Indicates whether the Pluggable Database is a refreshable clone.
        """
        if is_refreshable_clone is not None:
            pulumi.set(__self__, "is_refreshable_clone", is_refreshable_clone)

    @property
    @pulumi.getter(name="isRefreshableClone")
    def is_refreshable_clone(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the Pluggable Database is a refreshable clone.
        """
        return pulumi.get(self, "is_refreshable_clone")

    @is_refreshable_clone.setter
    def is_refreshable_clone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_refreshable_clone", value)


if not MYPY:
    class VmClusterAddVirtualNetworkCloudAutomationUpdateDetailArgsDict(TypedDict):
        apply_update_time_preferences: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmClusterAddVirtualNetworkCloudAutomationUpdateDetailApplyUpdateTimePreferenceArgsDict']]]]
        """
        Configure the time slot for applying VM cloud automation software updates to the cluster. When nothing is selected, the default time slot is 12 AM to 2 AM UTC. Any 2-hour slot is available starting at 12 AM.
        """
        freeze_periods: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmClusterAddVirtualNetworkCloudAutomationUpdateDetailFreezePeriodArgsDict']]]]
        """
        Enables a freeze period for the VM cluster prohibiting the VMs from getting cloud automation software updates during critical business cycles. Freeze period start date. Starts at 12:00 AM UTC on the selected date and ends at 11:59:59 PM UTC on the selected date. Validates to ensure the freeze period does not exceed 45 days.
        """
        is_early_adoption_enabled: NotRequired[pulumi.Input[bool]]
        """
        Annotates whether the cluster should be part of early access to apply VM cloud automation software updates. Those clusters annotated as early access will download the software bits for cloud automation in the first week after the update is available, while other clusters will have to wait until the following week.
        """
        is_freeze_period_enabled: NotRequired[pulumi.Input[bool]]
        """
        Specifies if the freeze period is enabled for the VM cluster to prevent the VMs from receiving cloud automation software updates during critical business cycles. Freeze period starts at 12:00 AM UTC and ends at 11:59:59 PM UTC on the selected date. Ensure that the freezing period does not exceed 45 days.
        """
elif False:
    VmClusterAddVirtualNetworkCloudAutomationUpdateDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmClusterAddVirtualNetworkCloudAutomationUpdateDetailArgs:
    def __init__(__self__, *,
                 apply_update_time_preferences: Optional[pulumi.Input[Sequence[pulumi.Input['VmClusterAddVirtualNetworkCloudAutomationUpdateDetailApplyUpdateTimePreferenceArgs']]]] = None,
                 freeze_periods: Optional[pulumi.Input[Sequence[pulumi.Input['VmClusterAddVirtualNetworkCloudAutomationUpdateDetailFreezePeriodArgs']]]] = None,
                 is_early_adoption_enabled: Optional[pulumi.Input[bool]] = None,
                 is_freeze_period_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VmClusterAddVirtualNetworkCloudAutomationUpdateDetailApplyUpdateTimePreferenceArgs']]] apply_update_time_preferences: Configure the time slot for applying VM cloud automation software updates to the cluster. When nothing is selected, the default time slot is 12 AM to 2 AM UTC. Any 2-hour slot is available starting at 12 AM.
        :param pulumi.Input[Sequence[pulumi.Input['VmClusterAddVirtualNetworkCloudAutomationUpdateDetailFreezePeriodArgs']]] freeze_periods: Enables a freeze period for the VM cluster prohibiting the VMs from getting cloud automation software updates during critical business cycles. Freeze period start date. Starts at 12:00 AM UTC on the selected date and ends at 11:59:59 PM UTC on the selected date. Validates to ensure the freeze period does not exceed 45 days.
        :param pulumi.Input[bool] is_early_adoption_enabled: Annotates whether the cluster should be part of early access to apply VM cloud automation software updates. Those clusters annotated as early access will download the software bits for cloud automation in the first week after the update is available, while other clusters will have to wait until the following week.
        :param pulumi.Input[bool] is_freeze_period_enabled: Specifies if the freeze period is enabled for the VM cluster to prevent the VMs from receiving cloud automation software updates during critical business cycles. Freeze period starts at 12:00 AM UTC and ends at 11:59:59 PM UTC on the selected date. Ensure that the freezing period does not exceed 45 days.
        """
        if apply_update_time_preferences is not None:
            pulumi.set(__self__, "apply_update_time_preferences", apply_update_time_preferences)
        if freeze_periods is not None:
            pulumi.set(__self__, "freeze_periods", freeze_periods)
        if is_early_adoption_enabled is not None:
            pulumi.set(__self__, "is_early_adoption_enabled", is_early_adoption_enabled)
        if is_freeze_period_enabled is not None:
            pulumi.set(__self__, "is_freeze_period_enabled", is_freeze_period_enabled)

    @property
    @pulumi.getter(name="applyUpdateTimePreferences")
    def apply_update_time_preferences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmClusterAddVirtualNetworkCloudAutomationUpdateDetailApplyUpdateTimePreferenceArgs']]]]:
        """
        Configure the time slot for applying VM cloud automation software updates to the cluster. When nothing is selected, the default time slot is 12 AM to 2 AM UTC. Any 2-hour slot is available starting at 12 AM.
        """
        return pulumi.get(self, "apply_update_time_preferences")

    @apply_update_time_preferences.setter
    def apply_update_time_preferences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmClusterAddVirtualNetworkCloudAutomationUpdateDetailApplyUpdateTimePreferenceArgs']]]]):
        pulumi.set(self, "apply_update_time_preferences", value)

    @property
    @pulumi.getter(name="freezePeriods")
    def freeze_periods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmClusterAddVirtualNetworkCloudAutomationUpdateDetailFreezePeriodArgs']]]]:
        """
        Enables a freeze period for the VM cluster prohibiting the VMs from getting cloud automation software updates during critical business cycles. Freeze period start date. Starts at 12:00 AM UTC on the selected date and ends at 11:59:59 PM UTC on the selected date. Validates to ensure the freeze period does not exceed 45 days.
        """
        return pulumi.get(self, "freeze_periods")

    @freeze_periods.setter
    def freeze_periods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmClusterAddVirtualNetworkCloudAutomationUpdateDetailFreezePeriodArgs']]]]):
        pulumi.set(self, "freeze_periods", value)

    @property
    @pulumi.getter(name="isEarlyAdoptionEnabled")
    def is_early_adoption_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Annotates whether the cluster should be part of early access to apply VM cloud automation software updates. Those clusters annotated as early access will download the software bits for cloud automation in the first week after the update is available, while other clusters will have to wait until the following week.
        """
        return pulumi.get(self, "is_early_adoption_enabled")

    @is_early_adoption_enabled.setter
    def is_early_adoption_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_early_adoption_enabled", value)

    @property
    @pulumi.getter(name="isFreezePeriodEnabled")
    def is_freeze_period_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies if the freeze period is enabled for the VM cluster to prevent the VMs from receiving cloud automation software updates during critical business cycles. Freeze period starts at 12:00 AM UTC and ends at 11:59:59 PM UTC on the selected date. Ensure that the freezing period does not exceed 45 days.
        """
        return pulumi.get(self, "is_freeze_period_enabled")

    @is_freeze_period_enabled.setter
    def is_freeze_period_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_freeze_period_enabled", value)


if not MYPY:
    class VmClusterAddVirtualNetworkCloudAutomationUpdateDetailApplyUpdateTimePreferenceArgsDict(TypedDict):
        apply_update_preferred_end_time: NotRequired[pulumi.Input[str]]
        """
        End time for polling VM cloud automation software updates for the cluster. If the endTime is not specified, 2 AM UTC is used by default.
        """
        apply_update_preferred_start_time: NotRequired[pulumi.Input[str]]
        """
        Start time for polling VM cloud automation software updates for the cluster. If the startTime is not specified, 12 AM UTC is used by default.
        """
elif False:
    VmClusterAddVirtualNetworkCloudAutomationUpdateDetailApplyUpdateTimePreferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmClusterAddVirtualNetworkCloudAutomationUpdateDetailApplyUpdateTimePreferenceArgs:
    def __init__(__self__, *,
                 apply_update_preferred_end_time: Optional[pulumi.Input[str]] = None,
                 apply_update_preferred_start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] apply_update_preferred_end_time: End time for polling VM cloud automation software updates for the cluster. If the endTime is not specified, 2 AM UTC is used by default.
        :param pulumi.Input[str] apply_update_preferred_start_time: Start time for polling VM cloud automation software updates for the cluster. If the startTime is not specified, 12 AM UTC is used by default.
        """
        if apply_update_preferred_end_time is not None:
            pulumi.set(__self__, "apply_update_preferred_end_time", apply_update_preferred_end_time)
        if apply_update_preferred_start_time is not None:
            pulumi.set(__self__, "apply_update_preferred_start_time", apply_update_preferred_start_time)

    @property
    @pulumi.getter(name="applyUpdatePreferredEndTime")
    def apply_update_preferred_end_time(self) -> Optional[pulumi.Input[str]]:
        """
        End time for polling VM cloud automation software updates for the cluster. If the endTime is not specified, 2 AM UTC is used by default.
        """
        return pulumi.get(self, "apply_update_preferred_end_time")

    @apply_update_preferred_end_time.setter
    def apply_update_preferred_end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "apply_update_preferred_end_time", value)

    @property
    @pulumi.getter(name="applyUpdatePreferredStartTime")
    def apply_update_preferred_start_time(self) -> Optional[pulumi.Input[str]]:
        """
        Start time for polling VM cloud automation software updates for the cluster. If the startTime is not specified, 12 AM UTC is used by default.
        """
        return pulumi.get(self, "apply_update_preferred_start_time")

    @apply_update_preferred_start_time.setter
    def apply_update_preferred_start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "apply_update_preferred_start_time", value)


if not MYPY:
    class VmClusterAddVirtualNetworkCloudAutomationUpdateDetailFreezePeriodArgsDict(TypedDict):
        freeze_period_end_time: NotRequired[pulumi.Input[str]]
        """
        End time of the freeze period cycle.
        """
        freeze_period_start_time: NotRequired[pulumi.Input[str]]
        """
        Start time of the freeze period cycle.
        """
elif False:
    VmClusterAddVirtualNetworkCloudAutomationUpdateDetailFreezePeriodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmClusterAddVirtualNetworkCloudAutomationUpdateDetailFreezePeriodArgs:
    def __init__(__self__, *,
                 freeze_period_end_time: Optional[pulumi.Input[str]] = None,
                 freeze_period_start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] freeze_period_end_time: End time of the freeze period cycle.
        :param pulumi.Input[str] freeze_period_start_time: Start time of the freeze period cycle.
        """
        if freeze_period_end_time is not None:
            pulumi.set(__self__, "freeze_period_end_time", freeze_period_end_time)
        if freeze_period_start_time is not None:
            pulumi.set(__self__, "freeze_period_start_time", freeze_period_start_time)

    @property
    @pulumi.getter(name="freezePeriodEndTime")
    def freeze_period_end_time(self) -> Optional[pulumi.Input[str]]:
        """
        End time of the freeze period cycle.
        """
        return pulumi.get(self, "freeze_period_end_time")

    @freeze_period_end_time.setter
    def freeze_period_end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "freeze_period_end_time", value)

    @property
    @pulumi.getter(name="freezePeriodStartTime")
    def freeze_period_start_time(self) -> Optional[pulumi.Input[str]]:
        """
        Start time of the freeze period cycle.
        """
        return pulumi.get(self, "freeze_period_start_time")

    @freeze_period_start_time.setter
    def freeze_period_start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "freeze_period_start_time", value)


if not MYPY:
    class VmClusterAddVirtualNetworkDataCollectionOptionArgsDict(TypedDict):
        is_diagnostics_events_enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        is_health_monitoring_enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        is_incident_logs_enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
elif False:
    VmClusterAddVirtualNetworkDataCollectionOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmClusterAddVirtualNetworkDataCollectionOptionArgs:
    def __init__(__self__, *,
                 is_diagnostics_events_enabled: Optional[pulumi.Input[bool]] = None,
                 is_health_monitoring_enabled: Optional[pulumi.Input[bool]] = None,
                 is_incident_logs_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_diagnostics_events_enabled: Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param pulumi.Input[bool] is_health_monitoring_enabled: Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param pulumi.Input[bool] is_incident_logs_enabled: Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        if is_diagnostics_events_enabled is not None:
            pulumi.set(__self__, "is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        if is_health_monitoring_enabled is not None:
            pulumi.set(__self__, "is_health_monitoring_enabled", is_health_monitoring_enabled)
        if is_incident_logs_enabled is not None:
            pulumi.set(__self__, "is_incident_logs_enabled", is_incident_logs_enabled)

    @property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @is_diagnostics_events_enabled.setter
    def is_diagnostics_events_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_diagnostics_events_enabled", value)

    @property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @is_health_monitoring_enabled.setter
    def is_health_monitoring_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_health_monitoring_enabled", value)

    @property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")

    @is_incident_logs_enabled.setter
    def is_incident_logs_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_incident_logs_enabled", value)


if not MYPY:
    class VmClusterAddVirtualNetworkDbServerArgsDict(TypedDict):
        db_server_id: pulumi.Input[str]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of Exacc Db server.
        """
elif False:
    VmClusterAddVirtualNetworkDbServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmClusterAddVirtualNetworkDbServerArgs:
    def __init__(__self__, *,
                 db_server_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] db_server_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of Exacc Db server.
        """
        pulumi.set(__self__, "db_server_id", db_server_id)

    @property
    @pulumi.getter(name="dbServerId")
    def db_server_id(self) -> pulumi.Input[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of Exacc Db server.
        """
        return pulumi.get(self, "db_server_id")

    @db_server_id.setter
    def db_server_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "db_server_id", value)


if not MYPY:
    class VmClusterAddVirtualNetworkFileSystemConfigurationDetailArgsDict(TypedDict):
        file_system_size_gb: NotRequired[pulumi.Input[int]]
        """
        The file system size to be allocated in GBs.
        """
        mount_point: NotRequired[pulumi.Input[str]]
        """
        The mount point of file system.
        """
elif False:
    VmClusterAddVirtualNetworkFileSystemConfigurationDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmClusterAddVirtualNetworkFileSystemConfigurationDetailArgs:
    def __init__(__self__, *,
                 file_system_size_gb: Optional[pulumi.Input[int]] = None,
                 mount_point: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] file_system_size_gb: The file system size to be allocated in GBs.
        :param pulumi.Input[str] mount_point: The mount point of file system.
        """
        if file_system_size_gb is not None:
            pulumi.set(__self__, "file_system_size_gb", file_system_size_gb)
        if mount_point is not None:
            pulumi.set(__self__, "mount_point", mount_point)

    @property
    @pulumi.getter(name="fileSystemSizeGb")
    def file_system_size_gb(self) -> Optional[pulumi.Input[int]]:
        """
        The file system size to be allocated in GBs.
        """
        return pulumi.get(self, "file_system_size_gb")

    @file_system_size_gb.setter
    def file_system_size_gb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "file_system_size_gb", value)

    @property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> Optional[pulumi.Input[str]]:
        """
        The mount point of file system.
        """
        return pulumi.get(self, "mount_point")

    @mount_point.setter
    def mount_point(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_point", value)


if not MYPY:
    class VmClusterCloudAutomationUpdateDetailsArgsDict(TypedDict):
        apply_update_time_preference: NotRequired[pulumi.Input['VmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreferenceArgsDict']]
        """
        (Updatable) Configure the time slot for applying VM cloud automation software updates to the cluster. When nothing is selected, the default time slot is 12 AM to 2 AM UTC. Any 2-hour slot is available starting at 12 AM.
        """
        freeze_period: NotRequired[pulumi.Input['VmClusterCloudAutomationUpdateDetailsFreezePeriodArgsDict']]
        """
        (Updatable) Enables a freeze period for the VM cluster prohibiting the VMs from getting cloud automation software updates during critical business cycles. Freeze period start date. Starts at 12:00 AM UTC on the selected date and ends at 11:59:59 PM UTC on the selected date. Validates to ensure the freeze period does not exceed 45 days.
        """
        is_early_adoption_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Annotates whether the cluster should be part of early access to apply VM cloud automation software updates. Those clusters annotated as early access will download the software bits for cloud automation in the first week after the update is available, while other clusters will have to wait until the following week.
        """
        is_freeze_period_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Specifies if the freeze period is enabled for the VM cluster to prevent the VMs from receiving cloud automation software updates during critical business cycles. Freeze period starts at 12:00 AM UTC and ends at 11:59:59 PM UTC on the selected date. Ensure that the freezing period does not exceed 45 days.
        """
elif False:
    VmClusterCloudAutomationUpdateDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmClusterCloudAutomationUpdateDetailsArgs:
    def __init__(__self__, *,
                 apply_update_time_preference: Optional[pulumi.Input['VmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreferenceArgs']] = None,
                 freeze_period: Optional[pulumi.Input['VmClusterCloudAutomationUpdateDetailsFreezePeriodArgs']] = None,
                 is_early_adoption_enabled: Optional[pulumi.Input[bool]] = None,
                 is_freeze_period_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['VmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreferenceArgs'] apply_update_time_preference: (Updatable) Configure the time slot for applying VM cloud automation software updates to the cluster. When nothing is selected, the default time slot is 12 AM to 2 AM UTC. Any 2-hour slot is available starting at 12 AM.
        :param pulumi.Input['VmClusterCloudAutomationUpdateDetailsFreezePeriodArgs'] freeze_period: (Updatable) Enables a freeze period for the VM cluster prohibiting the VMs from getting cloud automation software updates during critical business cycles. Freeze period start date. Starts at 12:00 AM UTC on the selected date and ends at 11:59:59 PM UTC on the selected date. Validates to ensure the freeze period does not exceed 45 days.
        :param pulumi.Input[bool] is_early_adoption_enabled: (Updatable) Annotates whether the cluster should be part of early access to apply VM cloud automation software updates. Those clusters annotated as early access will download the software bits for cloud automation in the first week after the update is available, while other clusters will have to wait until the following week.
        :param pulumi.Input[bool] is_freeze_period_enabled: (Updatable) Specifies if the freeze period is enabled for the VM cluster to prevent the VMs from receiving cloud automation software updates during critical business cycles. Freeze period starts at 12:00 AM UTC and ends at 11:59:59 PM UTC on the selected date. Ensure that the freezing period does not exceed 45 days.
        """
        if apply_update_time_preference is not None:
            pulumi.set(__self__, "apply_update_time_preference", apply_update_time_preference)
        if freeze_period is not None:
            pulumi.set(__self__, "freeze_period", freeze_period)
        if is_early_adoption_enabled is not None:
            pulumi.set(__self__, "is_early_adoption_enabled", is_early_adoption_enabled)
        if is_freeze_period_enabled is not None:
            pulumi.set(__self__, "is_freeze_period_enabled", is_freeze_period_enabled)

    @property
    @pulumi.getter(name="applyUpdateTimePreference")
    def apply_update_time_preference(self) -> Optional[pulumi.Input['VmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreferenceArgs']]:
        """
        (Updatable) Configure the time slot for applying VM cloud automation software updates to the cluster. When nothing is selected, the default time slot is 12 AM to 2 AM UTC. Any 2-hour slot is available starting at 12 AM.
        """
        return pulumi.get(self, "apply_update_time_preference")

    @apply_update_time_preference.setter
    def apply_update_time_preference(self, value: Optional[pulumi.Input['VmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreferenceArgs']]):
        pulumi.set(self, "apply_update_time_preference", value)

    @property
    @pulumi.getter(name="freezePeriod")
    def freeze_period(self) -> Optional[pulumi.Input['VmClusterCloudAutomationUpdateDetailsFreezePeriodArgs']]:
        """
        (Updatable) Enables a freeze period for the VM cluster prohibiting the VMs from getting cloud automation software updates during critical business cycles. Freeze period start date. Starts at 12:00 AM UTC on the selected date and ends at 11:59:59 PM UTC on the selected date. Validates to ensure the freeze period does not exceed 45 days.
        """
        return pulumi.get(self, "freeze_period")

    @freeze_period.setter
    def freeze_period(self, value: Optional[pulumi.Input['VmClusterCloudAutomationUpdateDetailsFreezePeriodArgs']]):
        pulumi.set(self, "freeze_period", value)

    @property
    @pulumi.getter(name="isEarlyAdoptionEnabled")
    def is_early_adoption_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Annotates whether the cluster should be part of early access to apply VM cloud automation software updates. Those clusters annotated as early access will download the software bits for cloud automation in the first week after the update is available, while other clusters will have to wait until the following week.
        """
        return pulumi.get(self, "is_early_adoption_enabled")

    @is_early_adoption_enabled.setter
    def is_early_adoption_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_early_adoption_enabled", value)

    @property
    @pulumi.getter(name="isFreezePeriodEnabled")
    def is_freeze_period_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Specifies if the freeze period is enabled for the VM cluster to prevent the VMs from receiving cloud automation software updates during critical business cycles. Freeze period starts at 12:00 AM UTC and ends at 11:59:59 PM UTC on the selected date. Ensure that the freezing period does not exceed 45 days.
        """
        return pulumi.get(self, "is_freeze_period_enabled")

    @is_freeze_period_enabled.setter
    def is_freeze_period_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_freeze_period_enabled", value)


if not MYPY:
    class VmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreferenceArgsDict(TypedDict):
        apply_update_preferred_end_time: NotRequired[pulumi.Input[str]]
        """
        (Updatable) End time for polling VM cloud automation software updates for the cluster. If the endTime is not specified, 2 AM UTC is used by default.
        """
        apply_update_preferred_start_time: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Start time for polling VM cloud automation software updates for the cluster. If the startTime is not specified, 12 AM UTC is used by default.
        """
elif False:
    VmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmClusterCloudAutomationUpdateDetailsApplyUpdateTimePreferenceArgs:
    def __init__(__self__, *,
                 apply_update_preferred_end_time: Optional[pulumi.Input[str]] = None,
                 apply_update_preferred_start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] apply_update_preferred_end_time: (Updatable) End time for polling VM cloud automation software updates for the cluster. If the endTime is not specified, 2 AM UTC is used by default.
        :param pulumi.Input[str] apply_update_preferred_start_time: (Updatable) Start time for polling VM cloud automation software updates for the cluster. If the startTime is not specified, 12 AM UTC is used by default.
        """
        if apply_update_preferred_end_time is not None:
            pulumi.set(__self__, "apply_update_preferred_end_time", apply_update_preferred_end_time)
        if apply_update_preferred_start_time is not None:
            pulumi.set(__self__, "apply_update_preferred_start_time", apply_update_preferred_start_time)

    @property
    @pulumi.getter(name="applyUpdatePreferredEndTime")
    def apply_update_preferred_end_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) End time for polling VM cloud automation software updates for the cluster. If the endTime is not specified, 2 AM UTC is used by default.
        """
        return pulumi.get(self, "apply_update_preferred_end_time")

    @apply_update_preferred_end_time.setter
    def apply_update_preferred_end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "apply_update_preferred_end_time", value)

    @property
    @pulumi.getter(name="applyUpdatePreferredStartTime")
    def apply_update_preferred_start_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Start time for polling VM cloud automation software updates for the cluster. If the startTime is not specified, 12 AM UTC is used by default.
        """
        return pulumi.get(self, "apply_update_preferred_start_time")

    @apply_update_preferred_start_time.setter
    def apply_update_preferred_start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "apply_update_preferred_start_time", value)


if not MYPY:
    class VmClusterCloudAutomationUpdateDetailsFreezePeriodArgsDict(TypedDict):
        freeze_period_end_time: NotRequired[pulumi.Input[str]]
        """
        (Updatable) End time of the freeze period cycle.
        """
        freeze_period_start_time: NotRequired[pulumi.Input[str]]
        """
        (Updatable) Start time of the freeze period cycle.
        """
elif False:
    VmClusterCloudAutomationUpdateDetailsFreezePeriodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmClusterCloudAutomationUpdateDetailsFreezePeriodArgs:
    def __init__(__self__, *,
                 freeze_period_end_time: Optional[pulumi.Input[str]] = None,
                 freeze_period_start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] freeze_period_end_time: (Updatable) End time of the freeze period cycle.
        :param pulumi.Input[str] freeze_period_start_time: (Updatable) Start time of the freeze period cycle.
        """
        if freeze_period_end_time is not None:
            pulumi.set(__self__, "freeze_period_end_time", freeze_period_end_time)
        if freeze_period_start_time is not None:
            pulumi.set(__self__, "freeze_period_start_time", freeze_period_start_time)

    @property
    @pulumi.getter(name="freezePeriodEndTime")
    def freeze_period_end_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) End time of the freeze period cycle.
        """
        return pulumi.get(self, "freeze_period_end_time")

    @freeze_period_end_time.setter
    def freeze_period_end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "freeze_period_end_time", value)

    @property
    @pulumi.getter(name="freezePeriodStartTime")
    def freeze_period_start_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Start time of the freeze period cycle.
        """
        return pulumi.get(self, "freeze_period_start_time")

    @freeze_period_start_time.setter
    def freeze_period_start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "freeze_period_start_time", value)


if not MYPY:
    class VmClusterDataCollectionOptionsArgsDict(TypedDict):
        is_diagnostics_events_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        is_health_monitoring_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        is_incident_logs_enabled: NotRequired[pulumi.Input[bool]]
        """
        (Updatable) Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
elif False:
    VmClusterDataCollectionOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmClusterDataCollectionOptionsArgs:
    def __init__(__self__, *,
                 is_diagnostics_events_enabled: Optional[pulumi.Input[bool]] = None,
                 is_health_monitoring_enabled: Optional[pulumi.Input[bool]] = None,
                 is_incident_logs_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_diagnostics_events_enabled: (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param pulumi.Input[bool] is_health_monitoring_enabled: (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param pulumi.Input[bool] is_incident_logs_enabled: (Updatable) Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        if is_diagnostics_events_enabled is not None:
            pulumi.set(__self__, "is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        if is_health_monitoring_enabled is not None:
            pulumi.set(__self__, "is_health_monitoring_enabled", is_health_monitoring_enabled)
        if is_incident_logs_enabled is not None:
            pulumi.set(__self__, "is_incident_logs_enabled", is_incident_logs_enabled)

    @property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @is_diagnostics_events_enabled.setter
    def is_diagnostics_events_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_diagnostics_events_enabled", value)

    @property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @is_health_monitoring_enabled.setter
    def is_health_monitoring_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_health_monitoring_enabled", value)

    @property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")

    @is_incident_logs_enabled.setter
    def is_incident_logs_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_incident_logs_enabled", value)


if not MYPY:
    class VmClusterFileSystemConfigurationDetailArgsDict(TypedDict):
        file_system_size_gb: NotRequired[pulumi.Input[int]]
        """
        (Updatable) The file system size to be allocated in GBs.
        """
        mount_point: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The mount point of file system.
        """
elif False:
    VmClusterFileSystemConfigurationDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmClusterFileSystemConfigurationDetailArgs:
    def __init__(__self__, *,
                 file_system_size_gb: Optional[pulumi.Input[int]] = None,
                 mount_point: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] file_system_size_gb: (Updatable) The file system size to be allocated in GBs.
        :param pulumi.Input[str] mount_point: (Updatable) The mount point of file system.
        """
        if file_system_size_gb is not None:
            pulumi.set(__self__, "file_system_size_gb", file_system_size_gb)
        if mount_point is not None:
            pulumi.set(__self__, "mount_point", mount_point)

    @property
    @pulumi.getter(name="fileSystemSizeGb")
    def file_system_size_gb(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The file system size to be allocated in GBs.
        """
        return pulumi.get(self, "file_system_size_gb")

    @file_system_size_gb.setter
    def file_system_size_gb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "file_system_size_gb", value)

    @property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The mount point of file system.
        """
        return pulumi.get(self, "mount_point")

    @mount_point.setter
    def mount_point(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_point", value)


if not MYPY:
    class VmClusterNetworkDrScanArgsDict(TypedDict):
        hostname: pulumi.Input[str]
        """
        (Updatable) The Disaster recovery SCAN hostname.
        """
        ips: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        (Updatable) The list of Disaster recovery SCAN IP addresses. Three addresses should be provided.
        """
        scan_listener_port_tcp: pulumi.Input[int]
        """
        (Updatable) The Disaster recovery SCAN TCPIP port. Default is 1521.
        """
elif False:
    VmClusterNetworkDrScanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmClusterNetworkDrScanArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[str],
                 ips: pulumi.Input[Sequence[pulumi.Input[str]]],
                 scan_listener_port_tcp: pulumi.Input[int]):
        """
        :param pulumi.Input[str] hostname: (Updatable) The Disaster recovery SCAN hostname.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: (Updatable) The list of Disaster recovery SCAN IP addresses. Three addresses should be provided.
        :param pulumi.Input[int] scan_listener_port_tcp: (Updatable) The Disaster recovery SCAN TCPIP port. Default is 1521.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "scan_listener_port_tcp", scan_listener_port_tcp)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[str]:
        """
        (Updatable) The Disaster recovery SCAN hostname.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def ips(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        (Updatable) The list of Disaster recovery SCAN IP addresses. Three addresses should be provided.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="scanListenerPortTcp")
    def scan_listener_port_tcp(self) -> pulumi.Input[int]:
        """
        (Updatable) The Disaster recovery SCAN TCPIP port. Default is 1521.
        """
        return pulumi.get(self, "scan_listener_port_tcp")

    @scan_listener_port_tcp.setter
    def scan_listener_port_tcp(self, value: pulumi.Input[int]):
        pulumi.set(self, "scan_listener_port_tcp", value)


if not MYPY:
    class VmClusterNetworkScanArgsDict(TypedDict):
        hostname: pulumi.Input[str]
        """
        (Updatable) The SCAN hostname.
        """
        ips: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        (Updatable) The list of SCAN IP addresses. Three addresses should be provided.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        (Updatable) **Deprecated.** This field is deprecated. You may use 'scanListenerPortTcp' to specify the port. The SCAN TCPIP port. Default is 1521.
        """
        scan_listener_port_tcp: NotRequired[pulumi.Input[int]]
        """
        (Updatable) The SCAN TCPIP port. Default is 1521.
        """
        scan_listener_port_tcp_ssl: NotRequired[pulumi.Input[int]]
        """
        (Updatable) The SCAN TCPIP SSL port. Default is 2484.
        """
elif False:
    VmClusterNetworkScanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmClusterNetworkScanArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[str],
                 ips: pulumi.Input[Sequence[pulumi.Input[str]]],
                 port: Optional[pulumi.Input[int]] = None,
                 scan_listener_port_tcp: Optional[pulumi.Input[int]] = None,
                 scan_listener_port_tcp_ssl: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] hostname: (Updatable) The SCAN hostname.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: (Updatable) The list of SCAN IP addresses. Three addresses should be provided.
        :param pulumi.Input[int] port: (Updatable) **Deprecated.** This field is deprecated. You may use 'scanListenerPortTcp' to specify the port. The SCAN TCPIP port. Default is 1521.
        :param pulumi.Input[int] scan_listener_port_tcp: (Updatable) The SCAN TCPIP port. Default is 1521.
        :param pulumi.Input[int] scan_listener_port_tcp_ssl: (Updatable) The SCAN TCPIP SSL port. Default is 2484.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "ips", ips)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scan_listener_port_tcp is not None:
            pulumi.set(__self__, "scan_listener_port_tcp", scan_listener_port_tcp)
        if scan_listener_port_tcp_ssl is not None:
            pulumi.set(__self__, "scan_listener_port_tcp_ssl", scan_listener_port_tcp_ssl)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[str]:
        """
        (Updatable) The SCAN hostname.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def ips(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        (Updatable) The list of SCAN IP addresses. Three addresses should be provided.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) **Deprecated.** This field is deprecated. You may use 'scanListenerPortTcp' to specify the port. The SCAN TCPIP port. Default is 1521.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="scanListenerPortTcp")
    def scan_listener_port_tcp(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The SCAN TCPIP port. Default is 1521.
        """
        return pulumi.get(self, "scan_listener_port_tcp")

    @scan_listener_port_tcp.setter
    def scan_listener_port_tcp(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "scan_listener_port_tcp", value)

    @property
    @pulumi.getter(name="scanListenerPortTcpSsl")
    def scan_listener_port_tcp_ssl(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The SCAN TCPIP SSL port. Default is 2484.
        """
        return pulumi.get(self, "scan_listener_port_tcp_ssl")

    @scan_listener_port_tcp_ssl.setter
    def scan_listener_port_tcp_ssl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "scan_listener_port_tcp_ssl", value)


if not MYPY:
    class VmClusterNetworkVmNetworkArgsDict(TypedDict):
        network_type: pulumi.Input[str]
        """
        (Updatable) The network type.
        """
        nodes: pulumi.Input[Sequence[pulumi.Input['VmClusterNetworkVmNetworkNodeArgsDict']]]
        """
        (Updatable) The list of node details.
        """
        domain_name: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The network domain name.
        """
        gateway: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The network gateway.
        """
        netmask: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The network netmask.
        """
        vlan_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The network VLAN ID.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
elif False:
    VmClusterNetworkVmNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmClusterNetworkVmNetworkArgs:
    def __init__(__self__, *,
                 network_type: pulumi.Input[str],
                 nodes: pulumi.Input[Sequence[pulumi.Input['VmClusterNetworkVmNetworkNodeArgs']]],
                 domain_name: Optional[pulumi.Input[str]] = None,
                 gateway: Optional[pulumi.Input[str]] = None,
                 netmask: Optional[pulumi.Input[str]] = None,
                 vlan_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] network_type: (Updatable) The network type.
        :param pulumi.Input[Sequence[pulumi.Input['VmClusterNetworkVmNetworkNodeArgs']]] nodes: (Updatable) The list of node details.
        :param pulumi.Input[str] domain_name: (Updatable) The network domain name.
        :param pulumi.Input[str] gateway: (Updatable) The network gateway.
        :param pulumi.Input[str] netmask: (Updatable) The network netmask.
        :param pulumi.Input[str] vlan_id: (Updatable) The network VLAN ID.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "network_type", network_type)
        pulumi.set(__self__, "nodes", nodes)
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> pulumi.Input[str]:
        """
        (Updatable) The network type.
        """
        return pulumi.get(self, "network_type")

    @network_type.setter
    def network_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_type", value)

    @property
    @pulumi.getter
    def nodes(self) -> pulumi.Input[Sequence[pulumi.Input['VmClusterNetworkVmNetworkNodeArgs']]]:
        """
        (Updatable) The list of node details.
        """
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: pulumi.Input[Sequence[pulumi.Input['VmClusterNetworkVmNetworkNodeArgs']]]):
        pulumi.set(self, "nodes", value)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The network domain name.
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_name", value)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The network gateway.
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter
    def netmask(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The network netmask.
        """
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "netmask", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The network VLAN ID.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vlan_id", value)


if not MYPY:
    class VmClusterNetworkVmNetworkNodeArgsDict(TypedDict):
        hostname: pulumi.Input[str]
        """
        (Updatable) The node host name.
        """
        ip: pulumi.Input[str]
        """
        (Updatable) The node IP address.
        """
        db_server_id: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The Db server associated with the node.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The current state of the VM cluster network nodes. CREATING - The resource is being created REQUIRES_VALIDATION - The resource is created and may not be usable until it is validated. VALIDATING - The resource is being validated and not available to use. VALIDATED - The resource is validated and is available for consumption by VM cluster. VALIDATION_FAILED - The resource validation has failed and might require user input to be corrected. UPDATING - The resource is being updated and not available to use. ALLOCATED - The resource is currently being used by VM cluster. TERMINATING - The resource is being deleted and not available to use. TERMINATED - The resource is deleted and unavailable. FAILED - The resource is in a failed state due to validation or other errors.
        """
        vip: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The node virtual IP (VIP) address.
        """
        vip_hostname: NotRequired[pulumi.Input[str]]
        """
        (Updatable) The node virtual IP (VIP) host name.
        """
elif False:
    VmClusterNetworkVmNetworkNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmClusterNetworkVmNetworkNodeArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[str],
                 ip: pulumi.Input[str],
                 db_server_id: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 vip: Optional[pulumi.Input[str]] = None,
                 vip_hostname: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] hostname: (Updatable) The node host name.
        :param pulumi.Input[str] ip: (Updatable) The node IP address.
        :param pulumi.Input[str] db_server_id: (Updatable) The Db server associated with the node.
        :param pulumi.Input[str] state: (Updatable) The current state of the VM cluster network nodes. CREATING - The resource is being created REQUIRES_VALIDATION - The resource is created and may not be usable until it is validated. VALIDATING - The resource is being validated and not available to use. VALIDATED - The resource is validated and is available for consumption by VM cluster. VALIDATION_FAILED - The resource validation has failed and might require user input to be corrected. UPDATING - The resource is being updated and not available to use. ALLOCATED - The resource is currently being used by VM cluster. TERMINATING - The resource is being deleted and not available to use. TERMINATED - The resource is deleted and unavailable. FAILED - The resource is in a failed state due to validation or other errors.
        :param pulumi.Input[str] vip: (Updatable) The node virtual IP (VIP) address.
        :param pulumi.Input[str] vip_hostname: (Updatable) The node virtual IP (VIP) host name.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "ip", ip)
        if db_server_id is not None:
            pulumi.set(__self__, "db_server_id", db_server_id)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if vip is not None:
            pulumi.set(__self__, "vip", vip)
        if vip_hostname is not None:
            pulumi.set(__self__, "vip_hostname", vip_hostname)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[str]:
        """
        (Updatable) The node host name.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        (Updatable) The node IP address.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="dbServerId")
    def db_server_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The Db server associated with the node.
        """
        return pulumi.get(self, "db_server_id")

    @db_server_id.setter
    def db_server_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_server_id", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The current state of the VM cluster network nodes. CREATING - The resource is being created REQUIRES_VALIDATION - The resource is created and may not be usable until it is validated. VALIDATING - The resource is being validated and not available to use. VALIDATED - The resource is validated and is available for consumption by VM cluster. VALIDATION_FAILED - The resource validation has failed and might require user input to be corrected. UPDATING - The resource is being updated and not available to use. ALLOCATED - The resource is currently being used by VM cluster. TERMINATING - The resource is being deleted and not available to use. TERMINATED - The resource is deleted and unavailable. FAILED - The resource is in a failed state due to validation or other errors.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def vip(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The node virtual IP (VIP) address.
        """
        return pulumi.get(self, "vip")

    @vip.setter
    def vip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vip", value)

    @property
    @pulumi.getter(name="vipHostname")
    def vip_hostname(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The node virtual IP (VIP) host name.
        """
        return pulumi.get(self, "vip_hostname")

    @vip_hostname.setter
    def vip_hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vip_hostname", value)


if not MYPY:
    class VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailArgsDict(TypedDict):
        apply_update_time_preferences: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailApplyUpdateTimePreferenceArgsDict']]]]
        """
        Configure the time slot for applying VM cloud automation software updates to the cluster. When nothing is selected, the default time slot is 12 AM to 2 AM UTC. Any 2-hour slot is available starting at 12 AM.
        """
        freeze_periods: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailFreezePeriodArgsDict']]]]
        """
        Enables a freeze period for the VM cluster prohibiting the VMs from getting cloud automation software updates during critical business cycles. Freeze period start date. Starts at 12:00 AM UTC on the selected date and ends at 11:59:59 PM UTC on the selected date. Validates to ensure the freeze period does not exceed 45 days.
        """
        is_early_adoption_enabled: NotRequired[pulumi.Input[bool]]
        """
        Annotates whether the cluster should be part of early access to apply VM cloud automation software updates. Those clusters annotated as early access will download the software bits for cloud automation in the first week after the update is available, while other clusters will have to wait until the following week.
        """
        is_freeze_period_enabled: NotRequired[pulumi.Input[bool]]
        """
        Specifies if the freeze period is enabled for the VM cluster to prevent the VMs from receiving cloud automation software updates during critical business cycles. Freeze period starts at 12:00 AM UTC and ends at 11:59:59 PM UTC on the selected date. Ensure that the freezing period does not exceed 45 days.
        """
elif False:
    VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailArgs:
    def __init__(__self__, *,
                 apply_update_time_preferences: Optional[pulumi.Input[Sequence[pulumi.Input['VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailApplyUpdateTimePreferenceArgs']]]] = None,
                 freeze_periods: Optional[pulumi.Input[Sequence[pulumi.Input['VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailFreezePeriodArgs']]]] = None,
                 is_early_adoption_enabled: Optional[pulumi.Input[bool]] = None,
                 is_freeze_period_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailApplyUpdateTimePreferenceArgs']]] apply_update_time_preferences: Configure the time slot for applying VM cloud automation software updates to the cluster. When nothing is selected, the default time slot is 12 AM to 2 AM UTC. Any 2-hour slot is available starting at 12 AM.
        :param pulumi.Input[Sequence[pulumi.Input['VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailFreezePeriodArgs']]] freeze_periods: Enables a freeze period for the VM cluster prohibiting the VMs from getting cloud automation software updates during critical business cycles. Freeze period start date. Starts at 12:00 AM UTC on the selected date and ends at 11:59:59 PM UTC on the selected date. Validates to ensure the freeze period does not exceed 45 days.
        :param pulumi.Input[bool] is_early_adoption_enabled: Annotates whether the cluster should be part of early access to apply VM cloud automation software updates. Those clusters annotated as early access will download the software bits for cloud automation in the first week after the update is available, while other clusters will have to wait until the following week.
        :param pulumi.Input[bool] is_freeze_period_enabled: Specifies if the freeze period is enabled for the VM cluster to prevent the VMs from receiving cloud automation software updates during critical business cycles. Freeze period starts at 12:00 AM UTC and ends at 11:59:59 PM UTC on the selected date. Ensure that the freezing period does not exceed 45 days.
        """
        if apply_update_time_preferences is not None:
            pulumi.set(__self__, "apply_update_time_preferences", apply_update_time_preferences)
        if freeze_periods is not None:
            pulumi.set(__self__, "freeze_periods", freeze_periods)
        if is_early_adoption_enabled is not None:
            pulumi.set(__self__, "is_early_adoption_enabled", is_early_adoption_enabled)
        if is_freeze_period_enabled is not None:
            pulumi.set(__self__, "is_freeze_period_enabled", is_freeze_period_enabled)

    @property
    @pulumi.getter(name="applyUpdateTimePreferences")
    def apply_update_time_preferences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailApplyUpdateTimePreferenceArgs']]]]:
        """
        Configure the time slot for applying VM cloud automation software updates to the cluster. When nothing is selected, the default time slot is 12 AM to 2 AM UTC. Any 2-hour slot is available starting at 12 AM.
        """
        return pulumi.get(self, "apply_update_time_preferences")

    @apply_update_time_preferences.setter
    def apply_update_time_preferences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailApplyUpdateTimePreferenceArgs']]]]):
        pulumi.set(self, "apply_update_time_preferences", value)

    @property
    @pulumi.getter(name="freezePeriods")
    def freeze_periods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailFreezePeriodArgs']]]]:
        """
        Enables a freeze period for the VM cluster prohibiting the VMs from getting cloud automation software updates during critical business cycles. Freeze period start date. Starts at 12:00 AM UTC on the selected date and ends at 11:59:59 PM UTC on the selected date. Validates to ensure the freeze period does not exceed 45 days.
        """
        return pulumi.get(self, "freeze_periods")

    @freeze_periods.setter
    def freeze_periods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailFreezePeriodArgs']]]]):
        pulumi.set(self, "freeze_periods", value)

    @property
    @pulumi.getter(name="isEarlyAdoptionEnabled")
    def is_early_adoption_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Annotates whether the cluster should be part of early access to apply VM cloud automation software updates. Those clusters annotated as early access will download the software bits for cloud automation in the first week after the update is available, while other clusters will have to wait until the following week.
        """
        return pulumi.get(self, "is_early_adoption_enabled")

    @is_early_adoption_enabled.setter
    def is_early_adoption_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_early_adoption_enabled", value)

    @property
    @pulumi.getter(name="isFreezePeriodEnabled")
    def is_freeze_period_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies if the freeze period is enabled for the VM cluster to prevent the VMs from receiving cloud automation software updates during critical business cycles. Freeze period starts at 12:00 AM UTC and ends at 11:59:59 PM UTC on the selected date. Ensure that the freezing period does not exceed 45 days.
        """
        return pulumi.get(self, "is_freeze_period_enabled")

    @is_freeze_period_enabled.setter
    def is_freeze_period_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_freeze_period_enabled", value)


if not MYPY:
    class VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailApplyUpdateTimePreferenceArgsDict(TypedDict):
        apply_update_preferred_end_time: NotRequired[pulumi.Input[str]]
        """
        End time for polling VM cloud automation software updates for the cluster. If the endTime is not specified, 2 AM UTC is used by default.
        """
        apply_update_preferred_start_time: NotRequired[pulumi.Input[str]]
        """
        Start time for polling VM cloud automation software updates for the cluster. If the startTime is not specified, 12 AM UTC is used by default.
        """
elif False:
    VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailApplyUpdateTimePreferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailApplyUpdateTimePreferenceArgs:
    def __init__(__self__, *,
                 apply_update_preferred_end_time: Optional[pulumi.Input[str]] = None,
                 apply_update_preferred_start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] apply_update_preferred_end_time: End time for polling VM cloud automation software updates for the cluster. If the endTime is not specified, 2 AM UTC is used by default.
        :param pulumi.Input[str] apply_update_preferred_start_time: Start time for polling VM cloud automation software updates for the cluster. If the startTime is not specified, 12 AM UTC is used by default.
        """
        if apply_update_preferred_end_time is not None:
            pulumi.set(__self__, "apply_update_preferred_end_time", apply_update_preferred_end_time)
        if apply_update_preferred_start_time is not None:
            pulumi.set(__self__, "apply_update_preferred_start_time", apply_update_preferred_start_time)

    @property
    @pulumi.getter(name="applyUpdatePreferredEndTime")
    def apply_update_preferred_end_time(self) -> Optional[pulumi.Input[str]]:
        """
        End time for polling VM cloud automation software updates for the cluster. If the endTime is not specified, 2 AM UTC is used by default.
        """
        return pulumi.get(self, "apply_update_preferred_end_time")

    @apply_update_preferred_end_time.setter
    def apply_update_preferred_end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "apply_update_preferred_end_time", value)

    @property
    @pulumi.getter(name="applyUpdatePreferredStartTime")
    def apply_update_preferred_start_time(self) -> Optional[pulumi.Input[str]]:
        """
        Start time for polling VM cloud automation software updates for the cluster. If the startTime is not specified, 12 AM UTC is used by default.
        """
        return pulumi.get(self, "apply_update_preferred_start_time")

    @apply_update_preferred_start_time.setter
    def apply_update_preferred_start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "apply_update_preferred_start_time", value)


if not MYPY:
    class VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailFreezePeriodArgsDict(TypedDict):
        freeze_period_end_time: NotRequired[pulumi.Input[str]]
        """
        End time of the freeze period cycle.
        """
        freeze_period_start_time: NotRequired[pulumi.Input[str]]
        """
        Start time of the freeze period cycle.
        """
elif False:
    VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailFreezePeriodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmClusterRemoveVirtualMachineCloudAutomationUpdateDetailFreezePeriodArgs:
    def __init__(__self__, *,
                 freeze_period_end_time: Optional[pulumi.Input[str]] = None,
                 freeze_period_start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] freeze_period_end_time: End time of the freeze period cycle.
        :param pulumi.Input[str] freeze_period_start_time: Start time of the freeze period cycle.
        """
        if freeze_period_end_time is not None:
            pulumi.set(__self__, "freeze_period_end_time", freeze_period_end_time)
        if freeze_period_start_time is not None:
            pulumi.set(__self__, "freeze_period_start_time", freeze_period_start_time)

    @property
    @pulumi.getter(name="freezePeriodEndTime")
    def freeze_period_end_time(self) -> Optional[pulumi.Input[str]]:
        """
        End time of the freeze period cycle.
        """
        return pulumi.get(self, "freeze_period_end_time")

    @freeze_period_end_time.setter
    def freeze_period_end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "freeze_period_end_time", value)

    @property
    @pulumi.getter(name="freezePeriodStartTime")
    def freeze_period_start_time(self) -> Optional[pulumi.Input[str]]:
        """
        Start time of the freeze period cycle.
        """
        return pulumi.get(self, "freeze_period_start_time")

    @freeze_period_start_time.setter
    def freeze_period_start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "freeze_period_start_time", value)


if not MYPY:
    class VmClusterRemoveVirtualMachineDataCollectionOptionArgsDict(TypedDict):
        is_diagnostics_events_enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        is_health_monitoring_enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        is_incident_logs_enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
elif False:
    VmClusterRemoveVirtualMachineDataCollectionOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmClusterRemoveVirtualMachineDataCollectionOptionArgs:
    def __init__(__self__, *,
                 is_diagnostics_events_enabled: Optional[pulumi.Input[bool]] = None,
                 is_health_monitoring_enabled: Optional[pulumi.Input[bool]] = None,
                 is_incident_logs_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_diagnostics_events_enabled: Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param pulumi.Input[bool] is_health_monitoring_enabled: Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param pulumi.Input[bool] is_incident_logs_enabled: Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        if is_diagnostics_events_enabled is not None:
            pulumi.set(__self__, "is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        if is_health_monitoring_enabled is not None:
            pulumi.set(__self__, "is_health_monitoring_enabled", is_health_monitoring_enabled)
        if is_incident_logs_enabled is not None:
            pulumi.set(__self__, "is_incident_logs_enabled", is_incident_logs_enabled)

    @property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @is_diagnostics_events_enabled.setter
    def is_diagnostics_events_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_diagnostics_events_enabled", value)

    @property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @is_health_monitoring_enabled.setter
    def is_health_monitoring_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_health_monitoring_enabled", value)

    @property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")

    @is_incident_logs_enabled.setter
    def is_incident_logs_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_incident_logs_enabled", value)


if not MYPY:
    class VmClusterRemoveVirtualMachineDbServerArgsDict(TypedDict):
        db_server_id: pulumi.Input[str]
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of Exacc Db server.
        """
elif False:
    VmClusterRemoveVirtualMachineDbServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmClusterRemoveVirtualMachineDbServerArgs:
    def __init__(__self__, *,
                 db_server_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] db_server_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of Exacc Db server.
        """
        pulumi.set(__self__, "db_server_id", db_server_id)

    @property
    @pulumi.getter(name="dbServerId")
    def db_server_id(self) -> pulumi.Input[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of Exacc Db server.
        """
        return pulumi.get(self, "db_server_id")

    @db_server_id.setter
    def db_server_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "db_server_id", value)


if not MYPY:
    class VmClusterRemoveVirtualMachineFileSystemConfigurationDetailArgsDict(TypedDict):
        file_system_size_gb: NotRequired[pulumi.Input[int]]
        """
        The file system size to be allocated in GBs.
        """
        mount_point: NotRequired[pulumi.Input[str]]
        """
        The mount point of file system.
        """
elif False:
    VmClusterRemoveVirtualMachineFileSystemConfigurationDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmClusterRemoveVirtualMachineFileSystemConfigurationDetailArgs:
    def __init__(__self__, *,
                 file_system_size_gb: Optional[pulumi.Input[int]] = None,
                 mount_point: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] file_system_size_gb: The file system size to be allocated in GBs.
        :param pulumi.Input[str] mount_point: The mount point of file system.
        """
        if file_system_size_gb is not None:
            pulumi.set(__self__, "file_system_size_gb", file_system_size_gb)
        if mount_point is not None:
            pulumi.set(__self__, "mount_point", mount_point)

    @property
    @pulumi.getter(name="fileSystemSizeGb")
    def file_system_size_gb(self) -> Optional[pulumi.Input[int]]:
        """
        The file system size to be allocated in GBs.
        """
        return pulumi.get(self, "file_system_size_gb")

    @file_system_size_gb.setter
    def file_system_size_gb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "file_system_size_gb", value)

    @property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> Optional[pulumi.Input[str]]:
        """
        The mount point of file system.
        """
        return pulumi.get(self, "mount_point")

    @mount_point.setter
    def mount_point(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_point", value)


if not MYPY:
    class GetApplicationVipsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetApplicationVipsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApplicationVipsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAutonomousCharacterSetsFilterArgsDict(TypedDict):
        name: str
        """
        A valid Oracle character set.
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetAutonomousCharacterSetsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAutonomousCharacterSetsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A valid Oracle character set.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A valid Oracle character set.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAutonomousContainerDatabaseDataguardAssociationsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetAutonomousContainerDatabaseDataguardAssociationsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAutonomousContainerDatabaseDataguardAssociationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAutonomousContainerDatabaseVersionsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetAutonomousContainerDatabaseVersionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAutonomousContainerDatabaseVersionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAutonomousContainerDatabasesFilterArgsDict(TypedDict):
        name: str
        """
        Name of the month of the year.
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetAutonomousContainerDatabasesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAutonomousContainerDatabasesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAutonomousContainerPatchesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetAutonomousContainerPatchesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAutonomousContainerPatchesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAutonomousDatabaseBackupsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetAutonomousDatabaseBackupsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAutonomousDatabaseBackupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAutonomousDatabaseDataguardAssociationsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetAutonomousDatabaseDataguardAssociationsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAutonomousDatabaseDataguardAssociationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAutonomousDatabasePeersFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetAutonomousDatabasePeersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAutonomousDatabasePeersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAutonomousDatabaseRefreshableClonesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetAutonomousDatabaseRefreshableClonesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAutonomousDatabaseRefreshableClonesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAutonomousDatabaseSoftwareImagesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetAutonomousDatabaseSoftwareImagesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAutonomousDatabaseSoftwareImagesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAutonomousDatabasesClonesFilterArgsDict(TypedDict):
        name: str
        """
        Name of the day of the week.
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetAutonomousDatabasesClonesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAutonomousDatabasesClonesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the day of the week.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the day of the week.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAutonomousDatabasesFilterArgsDict(TypedDict):
        name: str
        """
        Name of the day of the week.
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetAutonomousDatabasesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAutonomousDatabasesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the day of the week.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the day of the week.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAutonomousDbPreviewVersionsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetAutonomousDbPreviewVersionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAutonomousDbPreviewVersionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAutonomousDbVersionsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetAutonomousDbVersionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAutonomousDbVersionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAutonomousExadataInfrastructureShapesFilterArgsDict(TypedDict):
        name: str
        """
        The name of the shape used for the Autonomous Exadata Infrastructure.
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetAutonomousExadataInfrastructureShapesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAutonomousExadataInfrastructureShapesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the shape used for the Autonomous Exadata Infrastructure.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the shape used for the Autonomous Exadata Infrastructure.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAutonomousExadataInfrastructuresFilterArgsDict(TypedDict):
        name: str
        """
        Name of the month of the year.
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetAutonomousExadataInfrastructuresFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAutonomousExadataInfrastructuresFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAutonomousVirtualMachinesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetAutonomousVirtualMachinesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAutonomousVirtualMachinesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAutonomousVmClusterAcdResourceUsagesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetAutonomousVmClusterAcdResourceUsagesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAutonomousVmClusterAcdResourceUsagesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetAutonomousVmClustersFilterArgsDict(TypedDict):
        name: str
        """
        Name of the month of the year.
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetAutonomousVmClustersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAutonomousVmClustersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetBackupDestinationsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetBackupDestinationsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetBackupDestinationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetBackupsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetBackupsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetBackupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetCloudAutonomousVmClusterAcdResourceUsagesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetCloudAutonomousVmClusterAcdResourceUsagesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudAutonomousVmClusterAcdResourceUsagesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetCloudAutonomousVmClustersFilterArgsDict(TypedDict):
        name: str
        """
        Name of the month of the year.
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetCloudAutonomousVmClustersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudAutonomousVmClustersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetCloudExadataInfrastructuresFilterArgsDict(TypedDict):
        name: str
        """
        Name of the month of the year.
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetCloudExadataInfrastructuresFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudExadataInfrastructuresFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetCloudVmClustersFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetCloudVmClustersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudVmClustersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDataGuardAssociationsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDataGuardAssociationsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDataGuardAssociationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDatabaseMaintenanceRunHistoriesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDatabaseMaintenanceRunHistoriesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDatabaseMaintenanceRunHistoriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDatabasePdbConversionHistoryEntriesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDatabasePdbConversionHistoryEntriesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDatabasePdbConversionHistoryEntriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDatabaseSoftwareImagesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDatabaseSoftwareImagesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDatabaseSoftwareImagesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDatabaseUpgradeHistoryEntriesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDatabaseUpgradeHistoryEntriesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDatabaseUpgradeHistoryEntriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDatabasesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDatabasesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDatabasesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbHomePatchHistoryEntriesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDbHomePatchHistoryEntriesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbHomePatchHistoryEntriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbHomePatchesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDbHomePatchesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbHomePatchesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbHomesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDbHomesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbHomesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbNodeConsoleConnectionsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDbNodeConsoleConnectionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbNodeConsoleConnectionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbNodeConsoleHistoriesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDbNodeConsoleHistoriesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbNodeConsoleHistoriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbNodesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDbNodesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbNodesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbServersFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDbServersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbServersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbSystemComputePerformancesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDbSystemComputePerformancesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbSystemComputePerformancesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbSystemHistoryEntriesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDbSystemHistoryEntriesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbSystemHistoryEntriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbSystemPatchesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDbSystemPatchesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbSystemPatchesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbSystemShapesFilterArgsDict(TypedDict):
        name: str
        """
        The name of the shape used for the DB system.
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDbSystemShapesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbSystemShapesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the shape used for the DB system.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the shape used for the DB system.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbSystemStoragePerformancesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDbSystemStoragePerformancesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbSystemStoragePerformancesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbSystemsFilterArgsDict(TypedDict):
        name: str
        """
        Name of the month of the year.
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDbSystemsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbSystemsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbSystemsUpgradeHistoryEntriesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDbSystemsUpgradeHistoryEntriesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbSystemsUpgradeHistoryEntriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetDbVersionsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetDbVersionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbVersionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetExadataInfrastructuresFilterArgsDict(TypedDict):
        name: str
        """
        Name of the month of the year.
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetExadataInfrastructuresFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetExadataInfrastructuresFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetExadbVmClusterUpdateHistoryEntriesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetExadbVmClusterUpdateHistoryEntriesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetExadbVmClusterUpdateHistoryEntriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetExadbVmClusterUpdatesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetExadbVmClusterUpdatesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetExadbVmClusterUpdatesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetExadbVmClustersFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetExadbVmClustersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetExadbVmClustersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetExascaleDbStorageVaultsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetExascaleDbStorageVaultsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetExascaleDbStorageVaultsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetExternalContainerDatabasesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetExternalContainerDatabasesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetExternalContainerDatabasesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetExternalDatabaseConnectorsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetExternalDatabaseConnectorsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetExternalDatabaseConnectorsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetExternalNonContainerDatabasesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetExternalNonContainerDatabasesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetExternalNonContainerDatabasesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetExternalPluggableDatabasesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetExternalPluggableDatabasesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetExternalPluggableDatabasesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetFlexComponentsFilterArgsDict(TypedDict):
        name: str
        """
        A filter to return only resources that match the entire name given. The match is not case sensitive.
        """
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetFlexComponentsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFlexComponentsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to return only resources that match the entire name given. The match is not case sensitive.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to return only resources that match the entire name given. The match is not case sensitive.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetGiVersionMinorVersionsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetGiVersionMinorVersionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGiVersionMinorVersionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetGiVersionsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetGiVersionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGiVersionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetKeyStoresFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetKeyStoresFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetKeyStoresFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetMaintenanceRunsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetMaintenanceRunsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMaintenanceRunsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetManagedPreferredCredentialsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetManagedPreferredCredentialsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetManagedPreferredCredentialsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetOneoffPatchesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetOneoffPatchesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOneoffPatchesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetPluggableDatabasesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetPluggableDatabasesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPluggableDatabasesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetSystemVersionsFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetSystemVersionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSystemVersionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetVmClusterNetworksFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetVmClusterNetworksFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVmClusterNetworksFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetVmClusterPatchHistoryEntriesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetVmClusterPatchHistoryEntriesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVmClusterPatchHistoryEntriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetVmClusterPatchesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetVmClusterPatchesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVmClusterPatchesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetVmClusterRecommendedNetworkNetworkArgsDict(TypedDict):
        cidr: str
        """
        The cidr for the network.
        """
        domain: str
        """
        The network domain name.
        """
        gateway: str
        """
        The network gateway.
        """
        netmask: str
        """
        The network netmask.
        """
        network_type: str
        """
        The network type.
        """
        prefix: str
        """
        The network domain name.
        """
        vlan_id: str
        """
        The network VLAN ID.
        """
elif False:
    GetVmClusterRecommendedNetworkNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVmClusterRecommendedNetworkNetworkArgs:
    def __init__(__self__, *,
                 cidr: str,
                 domain: str,
                 gateway: str,
                 netmask: str,
                 network_type: str,
                 prefix: str,
                 vlan_id: str):
        """
        :param str cidr: The cidr for the network.
        :param str domain: The network domain name.
        :param str gateway: The network gateway.
        :param str netmask: The network netmask.
        :param str network_type: The network type.
        :param str prefix: The network domain name.
        :param str vlan_id: The network VLAN ID.
        """
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "netmask", netmask)
        pulumi.set(__self__, "network_type", network_type)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "vlan_id", vlan_id)

    @property
    @pulumi.getter
    def cidr(self) -> str:
        """
        The cidr for the network.
        """
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: str):
        pulumi.set(self, "cidr", value)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The network domain name.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: str):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        The network gateway.
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: str):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter
    def netmask(self) -> str:
        """
        The network netmask.
        """
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: str):
        pulumi.set(self, "netmask", value)

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> str:
        """
        The network type.
        """
        return pulumi.get(self, "network_type")

    @network_type.setter
    def network_type(self, value: str):
        pulumi.set(self, "network_type", value)

    @property
    @pulumi.getter
    def prefix(self) -> str:
        """
        The network domain name.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: str):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> str:
        """
        The network VLAN ID.
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: str):
        pulumi.set(self, "vlan_id", value)


if not MYPY:
    class GetVmClusterUpdateHistoryEntriesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetVmClusterUpdateHistoryEntriesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVmClusterUpdateHistoryEntriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetVmClusterUpdatesFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetVmClusterUpdatesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVmClusterUpdatesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class GetVmClustersFilterArgsDict(TypedDict):
        name: str
        values: Sequence[str]
        regex: NotRequired[bool]
elif False:
    GetVmClustersFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVmClustersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


