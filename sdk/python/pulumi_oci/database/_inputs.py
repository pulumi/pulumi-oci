# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'AutonomousContainerDatabaseBackupConfigArgs',
    'AutonomousContainerDatabaseBackupConfigBackupDestinationDetailsArgs',
    'AutonomousContainerDatabaseKeyHistoryEntryArgs',
    'AutonomousContainerDatabaseMaintenanceWindowArgs',
    'AutonomousContainerDatabaseMaintenanceWindowDaysOfWeekArgs',
    'AutonomousContainerDatabaseMaintenanceWindowDetailsArgs',
    'AutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeekArgs',
    'AutonomousContainerDatabaseMaintenanceWindowDetailsMonthArgs',
    'AutonomousContainerDatabaseMaintenanceWindowMonthArgs',
    'AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigArgs',
    'AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs',
    'AutonomousDatabaseApexDetailArgs',
    'AutonomousDatabaseBackupBackupDestinationDetailsArgs',
    'AutonomousDatabaseBackupConfigArgs',
    'AutonomousDatabaseConnectionStringArgs',
    'AutonomousDatabaseConnectionStringProfileArgs',
    'AutonomousDatabaseConnectionUrlArgs',
    'AutonomousDatabaseCustomerContactArgs',
    'AutonomousDatabaseKeyHistoryEntryArgs',
    'AutonomousDatabaseLocalStandbyDbArgs',
    'AutonomousDatabaseLongTermBackupScheduleArgs',
    'AutonomousDatabaseRemoteDisasterRecoveryConfigurationArgs',
    'AutonomousDatabaseResourcePoolSummaryArgs',
    'AutonomousDatabaseScheduledOperationArgs',
    'AutonomousDatabaseScheduledOperationDayOfWeekArgs',
    'AutonomousDatabaseStandbyDbArgs',
    'AutonomousExadataInfrastructureMaintenanceWindowArgs',
    'AutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekArgs',
    'AutonomousExadataInfrastructureMaintenanceWindowDetailsArgs',
    'AutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeekArgs',
    'AutonomousExadataInfrastructureMaintenanceWindowDetailsMonthArgs',
    'AutonomousExadataInfrastructureMaintenanceWindowMonthArgs',
    'AutonomousVmClusterMaintenanceWindowArgs',
    'AutonomousVmClusterMaintenanceWindowDaysOfWeekArgs',
    'AutonomousVmClusterMaintenanceWindowDetailArgs',
    'AutonomousVmClusterMaintenanceWindowDetailDaysOfWeekArgs',
    'AutonomousVmClusterMaintenanceWindowDetailMonthArgs',
    'AutonomousVmClusterMaintenanceWindowMonthArgs',
    'BackupDestinationAssociatedDatabaseArgs',
    'BackupDestinationMountTypeDetailsArgs',
    'CloudAutonomousVmClusterMaintenanceWindowArgs',
    'CloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgs',
    'CloudAutonomousVmClusterMaintenanceWindowDetailsArgs',
    'CloudAutonomousVmClusterMaintenanceWindowDetailsDaysOfWeekArgs',
    'CloudAutonomousVmClusterMaintenanceWindowDetailsMonthArgs',
    'CloudAutonomousVmClusterMaintenanceWindowMonthArgs',
    'CloudDatabaseManagementCredentialdetailsArgs',
    'CloudExadataInfrastructureCustomerContactArgs',
    'CloudExadataInfrastructureMaintenanceWindowArgs',
    'CloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgs',
    'CloudExadataInfrastructureMaintenanceWindowMonthArgs',
    'CloudVmClusterDataCollectionOptionsArgs',
    'CloudVmClusterIormConfigCachArgs',
    'CloudVmClusterIormConfigCachDbPlanArgs',
    'CloudVmClusterIormConfigDbPlanArgs',
    'DataGuardAssociationDataCollectionOptionsArgs',
    'DatabaseConnectionStringArgs',
    'DatabaseDatabaseArgs',
    'DatabaseDatabaseDbBackupConfigArgs',
    'DatabaseDatabaseDbBackupConfigBackupDestinationDetailArgs',
    'DatabaseDatabaseManagementConfigArgs',
    'DatabaseDbBackupConfigArgs',
    'DatabaseDbBackupConfigBackupDestinationDetailArgs',
    'DatabaseUpgradeConnectionStringArgs',
    'DatabaseUpgradeDatabaseUpgradeSourceDetailsArgs',
    'DatabaseUpgradeDbBackupConfigArgs',
    'DatabaseUpgradeDbBackupConfigBackupDestinationDetailArgs',
    'DbHomeDatabaseArgs',
    'DbHomeDatabaseConnectionStringArgs',
    'DbHomeDatabaseDbBackupConfigArgs',
    'DbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs',
    'DbSystemDataCollectionOptionsArgs',
    'DbSystemDbHomeArgs',
    'DbSystemDbHomeDatabaseArgs',
    'DbSystemDbHomeDatabaseConnectionStringArgs',
    'DbSystemDbHomeDatabaseDbBackupConfigArgs',
    'DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs',
    'DbSystemDbSystemOptionsArgs',
    'DbSystemIormConfigCachArgs',
    'DbSystemIormConfigCachDbPlanArgs',
    'DbSystemMaintenanceWindowArgs',
    'DbSystemMaintenanceWindowDaysOfWeekArgs',
    'DbSystemMaintenanceWindowDetailsArgs',
    'DbSystemMaintenanceWindowDetailsDaysOfWeekArgs',
    'DbSystemMaintenanceWindowDetailsMonthArgs',
    'DbSystemMaintenanceWindowMonthArgs',
    'DbSystemsUpgradeDbSystemOptionArgs',
    'DbSystemsUpgradeIormConfigCachArgs',
    'DbSystemsUpgradeIormConfigCachDbPlanArgs',
    'DbSystemsUpgradeMaintenanceWindowArgs',
    'DbSystemsUpgradeMaintenanceWindowDaysOfWeekArgs',
    'DbSystemsUpgradeMaintenanceWindowMonthArgs',
    'ExadataInfrastructureComputeContactArgs',
    'ExadataInfrastructureComputeMaintenanceWindowArgs',
    'ExadataInfrastructureComputeMaintenanceWindowDaysOfWeekArgs',
    'ExadataInfrastructureComputeMaintenanceWindowMonthArgs',
    'ExadataInfrastructureContactArgs',
    'ExadataInfrastructureMaintenanceWindowArgs',
    'ExadataInfrastructureMaintenanceWindowDaysOfWeekArgs',
    'ExadataInfrastructureMaintenanceWindowMonthArgs',
    'ExadataInfrastructureNetworkBondingModeDetailsArgs',
    'ExadataInfrastructureStorageContactArgs',
    'ExadataInfrastructureStorageMaintenanceWindowArgs',
    'ExadataInfrastructureStorageMaintenanceWindowDaysOfWeekArgs',
    'ExadataInfrastructureStorageMaintenanceWindowMonthArgs',
    'ExadataIormConfigDbPlanArgs',
    'ExternalContainerDatabaseDatabaseManagementConfigArgs',
    'ExternalContainerDatabaseStackMonitoringConfigArgs',
    'ExternalDatabaseConnectorConnectionCredentialsArgs',
    'ExternalDatabaseConnectorConnectionStringArgs',
    'ExternalNonContainerDatabaseDatabaseManagementConfigArgs',
    'ExternalNonContainerDatabaseOperationsInsightsConfigArgs',
    'ExternalNonContainerDatabaseStackMonitoringConfigArgs',
    'ExternalPluggableDatabaseDatabaseManagementConfigArgs',
    'ExternalPluggableDatabaseOperationsInsightsConfigArgs',
    'ExternalPluggableDatabaseStackMonitoringConfigArgs',
    'KeyStoreAssociatedDatabaseArgs',
    'KeyStoreTypeDetailsArgs',
    'MaintenanceRunEstimatedPatchingTimeArgs',
    'PluggableDatabaseConnectionStringArgs',
    'PluggableDatabaseManagementsManagementConnectionStringArgs',
    'PluggableDatabaseManagementsManagementCredentialDetailsArgs',
    'PluggableDatabaseManagementsManagementPluggableDatabaseManagementConfigArgs',
    'PluggableDatabasePdbCreationTypeDetailsArgs',
    'PluggableDatabasePdbCreationTypeDetailsRefreshableCloneDetailsArgs',
    'PluggableDatabasePdbNodeLevelDetailArgs',
    'PluggableDatabasePluggableDatabaseManagementConfigArgs',
    'PluggableDatabaseRefreshableCloneConfigArgs',
    'PluggableDatabasesLocalCloneConnectionStringArgs',
    'PluggableDatabasesLocalClonePdbNodeLevelDetailArgs',
    'PluggableDatabasesLocalClonePluggableDatabaseManagementConfigArgs',
    'PluggableDatabasesLocalCloneRefreshableCloneConfigArgs',
    'PluggableDatabasesRemoteCloneConnectionStringArgs',
    'PluggableDatabasesRemoteClonePdbNodeLevelDetailArgs',
    'PluggableDatabasesRemoteClonePluggableDatabaseManagementConfigArgs',
    'PluggableDatabasesRemoteCloneRefreshableCloneConfigArgs',
    'VmClusterAddVirtualNetworkDataCollectionOptionArgs',
    'VmClusterAddVirtualNetworkDbServerArgs',
    'VmClusterDataCollectionOptionsArgs',
    'VmClusterNetworkDrScanArgs',
    'VmClusterNetworkScanArgs',
    'VmClusterNetworkVmNetworkArgs',
    'VmClusterNetworkVmNetworkNodeArgs',
    'VmClusterRemoveVirtualMachineDataCollectionOptionArgs',
    'VmClusterRemoveVirtualMachineDbServerArgs',
    'GetApplicationVipsFilterArgs',
    'GetAutonomousCharacterSetsFilterArgs',
    'GetAutonomousContainerDatabaseDataguardAssociationsFilterArgs',
    'GetAutonomousContainerDatabaseVersionsFilterArgs',
    'GetAutonomousContainerDatabasesFilterArgs',
    'GetAutonomousContainerPatchesFilterArgs',
    'GetAutonomousDatabaseBackupsFilterArgs',
    'GetAutonomousDatabaseDataguardAssociationsFilterArgs',
    'GetAutonomousDatabaseRefreshableClonesFilterArgs',
    'GetAutonomousDatabasesClonesFilterArgs',
    'GetAutonomousDatabasesFilterArgs',
    'GetAutonomousDbPreviewVersionsFilterArgs',
    'GetAutonomousDbVersionsFilterArgs',
    'GetAutonomousExadataInfrastructureShapesFilterArgs',
    'GetAutonomousExadataInfrastructuresFilterArgs',
    'GetAutonomousVirtualMachinesFilterArgs',
    'GetAutonomousVmClusterAcdResourceUsagesFilterArgs',
    'GetAutonomousVmClustersFilterArgs',
    'GetBackupDestinationsFilterArgs',
    'GetBackupsFilterArgs',
    'GetCloudAutonomousVmClusterAcdResourceUsagesFilterArgs',
    'GetCloudAutonomousVmClustersFilterArgs',
    'GetCloudExadataInfrastructuresFilterArgs',
    'GetCloudVmClustersFilterArgs',
    'GetDataGuardAssociationsFilterArgs',
    'GetDatabaseMaintenanceRunHistoriesFilterArgs',
    'GetDatabasePdbConversionHistoryEntriesFilterArgs',
    'GetDatabaseSoftwareImagesFilterArgs',
    'GetDatabaseUpgradeHistoryEntriesFilterArgs',
    'GetDatabasesFilterArgs',
    'GetDbHomePatchHistoryEntriesFilterArgs',
    'GetDbHomePatchesFilterArgs',
    'GetDbHomesFilterArgs',
    'GetDbNodeConsoleConnectionsFilterArgs',
    'GetDbNodesFilterArgs',
    'GetDbServersFilterArgs',
    'GetDbSystemComputePerformancesFilterArgs',
    'GetDbSystemHistoryEntriesFilterArgs',
    'GetDbSystemPatchesFilterArgs',
    'GetDbSystemShapesFilterArgs',
    'GetDbSystemStoragePerformancesFilterArgs',
    'GetDbSystemsFilterArgs',
    'GetDbSystemsUpgradeHistoryEntriesFilterArgs',
    'GetDbVersionsFilterArgs',
    'GetExadataInfrastructuresFilterArgs',
    'GetExternalContainerDatabasesFilterArgs',
    'GetExternalDatabaseConnectorsFilterArgs',
    'GetExternalNonContainerDatabasesFilterArgs',
    'GetExternalPluggableDatabasesFilterArgs',
    'GetFlexComponentsFilterArgs',
    'GetGiVersionsFilterArgs',
    'GetKeyStoresFilterArgs',
    'GetMaintenanceRunsFilterArgs',
    'GetManagedPreferredCredentialsFilterArgs',
    'GetOneoffPatchesFilterArgs',
    'GetPluggableDatabasesFilterArgs',
    'GetVmClusterNetworksFilterArgs',
    'GetVmClusterPatchHistoryEntriesFilterArgs',
    'GetVmClusterPatchesFilterArgs',
    'GetVmClusterRecommendedNetworkNetworkArgs',
    'GetVmClusterUpdateHistoryEntriesFilterArgs',
    'GetVmClusterUpdatesFilterArgs',
    'GetVmClustersFilterArgs',
]

@pulumi.input_type
class AutonomousContainerDatabaseBackupConfigArgs:
    def __init__(__self__, *,
                 backup_destination_details: Optional[pulumi.Input['AutonomousContainerDatabaseBackupConfigBackupDestinationDetailsArgs']] = None,
                 recovery_window_in_days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['AutonomousContainerDatabaseBackupConfigBackupDestinationDetailsArgs'] backup_destination_details: Backup destination details.
        :param pulumi.Input[int] recovery_window_in_days: Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[pulumi.Input['AutonomousContainerDatabaseBackupConfigBackupDestinationDetailsArgs']]:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @backup_destination_details.setter
    def backup_destination_details(self, value: Optional[pulumi.Input['AutonomousContainerDatabaseBackupConfigBackupDestinationDetailsArgs']]):
        pulumi.set(self, "backup_destination_details", value)

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @recovery_window_in_days.setter
    def recovery_window_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "recovery_window_in_days", value)


@pulumi.input_type
class AutonomousContainerDatabaseBackupConfigBackupDestinationDetailsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None,
                 internet_proxy: Optional[pulumi.Input[str]] = None,
                 vpc_password: Optional[pulumi.Input[str]] = None,
                 vpc_user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Type of the database backup destination.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param pulumi.Input[str] internet_proxy: Proxy URL to connect to object store.
        :param pulumi.Input[str] vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param pulumi.Input[str] vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if internet_proxy is not None:
            pulumi.set(__self__, "internet_proxy", internet_proxy)
        if vpc_password is not None:
            pulumi.set(__self__, "vpc_password", vpc_password)
        if vpc_user is not None:
            pulumi.set(__self__, "vpc_user", vpc_user)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @internet_proxy.setter
    def internet_proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "internet_proxy", value)

    @property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> Optional[pulumi.Input[str]]:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @vpc_password.setter
    def vpc_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_password", value)

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[pulumi.Input[str]]:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")

    @vpc_user.setter
    def vpc_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_user", value)


@pulumi.input_type
class AutonomousContainerDatabaseKeyHistoryEntryArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 kms_key_version_id: Optional[pulumi.Input[str]] = None,
                 time_activated: Optional[pulumi.Input[str]] = None,
                 vault_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param pulumi.Input[str] kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        :param pulumi.Input[str] time_activated: The date and time the kms key activated.
        :param pulumi.Input[str] vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if kms_key_version_id is not None:
            pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        if time_activated is not None:
            pulumi.set(__self__, "time_activated", time_activated)
        if vault_id is not None:
            pulumi.set(__self__, "vault_id", vault_id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        """
        return pulumi.get(self, "kms_key_version_id")

    @kms_key_version_id.setter
    def kms_key_version_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_version_id", value)

    @property
    @pulumi.getter(name="timeActivated")
    def time_activated(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the kms key activated.
        """
        return pulumi.get(self, "time_activated")

    @time_activated.setter
    def time_activated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_activated", value)

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")

    @vault_id.setter
    def vault_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vault_id", value)


@pulumi.input_type
class AutonomousContainerDatabaseMaintenanceWindowArgs:
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[pulumi.Input[int]] = None,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 is_custom_action_timeout_enabled: Optional[pulumi.Input[bool]] = None,
                 is_monthly_patching_enabled: Optional[pulumi.Input[bool]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowMonthArgs']]]] = None,
                 patching_mode: Optional[pulumi.Input[str]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[int] custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowDaysOfWeekArgs']]] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[bool] is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param pulumi.Input[bool] is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param pulumi.Input[int] lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowMonthArgs']]] months: (Updatable) Months during the year when maintenance should be performed.
        :param pulumi.Input[str] patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param pulumi.Input[str] preference: (Updatable) The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @custom_action_timeout_in_mins.setter
    def custom_action_timeout_in_mins(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_action_timeout_in_mins", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowDaysOfWeekArgs']]]]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @is_custom_action_timeout_enabled.setter
    def is_custom_action_timeout_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom_action_timeout_enabled", value)

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @is_monthly_patching_enabled.setter
    def is_monthly_patching_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monthly_patching_enabled", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowMonthArgs']]]]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @patching_mode.setter
    def patching_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patching_mode", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


@pulumi.input_type
class AutonomousContainerDatabaseMaintenanceWindowDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class AutonomousContainerDatabaseMaintenanceWindowDetailsArgs:
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[pulumi.Input[int]] = None,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 is_custom_action_timeout_enabled: Optional[pulumi.Input[bool]] = None,
                 is_monthly_patching_enabled: Optional[pulumi.Input[bool]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowDetailsMonthArgs']]]] = None,
                 patching_mode: Optional[pulumi.Input[str]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[int] custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeekArgs']]] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[bool] is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param pulumi.Input[bool] is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param pulumi.Input[int] lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowDetailsMonthArgs']]] months: (Updatable) Months during the year when maintenance should be performed.
        :param pulumi.Input[str] patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param pulumi.Input[str] preference: (Updatable) The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @custom_action_timeout_in_mins.setter
    def custom_action_timeout_in_mins(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_action_timeout_in_mins", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeekArgs']]]]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @is_custom_action_timeout_enabled.setter
    def is_custom_action_timeout_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom_action_timeout_enabled", value)

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @is_monthly_patching_enabled.setter
    def is_monthly_patching_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monthly_patching_enabled", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowDetailsMonthArgs']]]]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabaseMaintenanceWindowDetailsMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @patching_mode.setter
    def patching_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patching_mode", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


@pulumi.input_type
class AutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class AutonomousContainerDatabaseMaintenanceWindowDetailsMonthArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class AutonomousContainerDatabaseMaintenanceWindowMonthArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigArgs:
    def __init__(__self__, *,
                 backup_destination_details: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs']]]] = None,
                 recovery_window_in_days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs']]] backup_destination_details: Backup destination details.
        :param pulumi.Input[int] recovery_window_in_days: Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs']]]]:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @backup_destination_details.setter
    def backup_destination_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs']]]]):
        pulumi.set(self, "backup_destination_details", value)

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @recovery_window_in_days.setter
    def recovery_window_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "recovery_window_in_days", value)


@pulumi.input_type
class AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None,
                 internet_proxy: Optional[pulumi.Input[str]] = None,
                 vpc_password: Optional[pulumi.Input[str]] = None,
                 vpc_user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Type of the database backup destination.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param pulumi.Input[str] internet_proxy: Proxy URL to connect to object store.
        :param pulumi.Input[str] vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param pulumi.Input[str] vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if internet_proxy is not None:
            pulumi.set(__self__, "internet_proxy", internet_proxy)
        if vpc_password is not None:
            pulumi.set(__self__, "vpc_password", vpc_password)
        if vpc_user is not None:
            pulumi.set(__self__, "vpc_user", vpc_user)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @internet_proxy.setter
    def internet_proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "internet_proxy", value)

    @property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> Optional[pulumi.Input[str]]:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @vpc_password.setter
    def vpc_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_password", value)

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[pulumi.Input[str]]:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")

    @vpc_user.setter
    def vpc_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_user", value)


@pulumi.input_type
class AutonomousDatabaseApexDetailArgs:
    def __init__(__self__, *,
                 apex_version: Optional[pulumi.Input[str]] = None,
                 ords_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] apex_version: The Oracle APEX Application Development version.
        :param pulumi.Input[str] ords_version: The Oracle REST Data Services (ORDS) version.
        """
        if apex_version is not None:
            pulumi.set(__self__, "apex_version", apex_version)
        if ords_version is not None:
            pulumi.set(__self__, "ords_version", ords_version)

    @property
    @pulumi.getter(name="apexVersion")
    def apex_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Oracle APEX Application Development version.
        """
        return pulumi.get(self, "apex_version")

    @apex_version.setter
    def apex_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "apex_version", value)

    @property
    @pulumi.getter(name="ordsVersion")
    def ords_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Oracle REST Data Services (ORDS) version.
        """
        return pulumi.get(self, "ords_version")

    @ords_version.setter
    def ords_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ords_version", value)


@pulumi.input_type
class AutonomousDatabaseBackupBackupDestinationDetailsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None,
                 internet_proxy: Optional[pulumi.Input[str]] = None,
                 vpc_password: Optional[pulumi.Input[str]] = None,
                 vpc_user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of backup.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database backup.
        :param pulumi.Input[str] internet_proxy: Proxy URL to connect to object store.
        :param pulumi.Input[str] vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param pulumi.Input[str] vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if internet_proxy is not None:
            pulumi.set(__self__, "internet_proxy", internet_proxy)
        if vpc_password is not None:
            pulumi.set(__self__, "vpc_password", vpc_password)
        if vpc_user is not None:
            pulumi.set(__self__, "vpc_user", vpc_user)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of backup.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database backup.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @internet_proxy.setter
    def internet_proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "internet_proxy", value)

    @property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> Optional[pulumi.Input[str]]:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @vpc_password.setter
    def vpc_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_password", value)

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[pulumi.Input[str]]:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")

    @vpc_user.setter
    def vpc_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_user", value)


@pulumi.input_type
class AutonomousDatabaseBackupConfigArgs:
    def __init__(__self__, *,
                 manual_backup_bucket_name: Optional[pulumi.Input[str]] = None,
                 manual_backup_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] manual_backup_bucket_name: Name of [Object Storage](https://docs.cloud.oracle.com/iaas/Content/Object/Concepts/objectstorageoverview.htm) bucket to use for storing manual backups.
        :param pulumi.Input[str] manual_backup_type: The manual backup destination type.
        """
        if manual_backup_bucket_name is not None:
            pulumi.set(__self__, "manual_backup_bucket_name", manual_backup_bucket_name)
        if manual_backup_type is not None:
            pulumi.set(__self__, "manual_backup_type", manual_backup_type)

    @property
    @pulumi.getter(name="manualBackupBucketName")
    def manual_backup_bucket_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of [Object Storage](https://docs.cloud.oracle.com/iaas/Content/Object/Concepts/objectstorageoverview.htm) bucket to use for storing manual backups.
        """
        return pulumi.get(self, "manual_backup_bucket_name")

    @manual_backup_bucket_name.setter
    def manual_backup_bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "manual_backup_bucket_name", value)

    @property
    @pulumi.getter(name="manualBackupType")
    def manual_backup_type(self) -> Optional[pulumi.Input[str]]:
        """
        The manual backup destination type.
        """
        return pulumi.get(self, "manual_backup_type")

    @manual_backup_type.setter
    def manual_backup_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "manual_backup_type", value)


@pulumi.input_type
class AutonomousDatabaseConnectionStringArgs:
    def __init__(__self__, *,
                 all_connection_strings: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 dedicated: Optional[pulumi.Input[str]] = None,
                 high: Optional[pulumi.Input[str]] = None,
                 low: Optional[pulumi.Input[str]] = None,
                 medium: Optional[pulumi.Input[str]] = None,
                 profiles: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousDatabaseConnectionStringProfileArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, Any]] all_connection_strings: Returns all connection strings that can be used to connect to the Autonomous Database. For more information, please see [Predefined Database Service Names for Autonomous Transaction Processing](https://docs.oracle.com/en/cloud/paas/atp-cloud/atpug/connect-predefined.html#GUID-9747539B-FD46-44F1-8FF8-F5AC650F15BE)
        :param pulumi.Input[str] dedicated: The database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        :param pulumi.Input[str] high: The High database service provides the highest level of resources to each SQL statement resulting in the highest performance, but supports the fewest number of concurrent SQL statements.
        :param pulumi.Input[str] low: The Low database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        :param pulumi.Input[str] medium: The Medium database service provides a lower level of resources to each SQL statement potentially resulting a lower level of performance, but supports more concurrent SQL statements.
        :param pulumi.Input[Sequence[pulumi.Input['AutonomousDatabaseConnectionStringProfileArgs']]] profiles: A list of connection string profiles to allow clients to group, filter and select connection string values based on structured metadata.
        """
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if dedicated is not None:
            pulumi.set(__self__, "dedicated", dedicated)
        if high is not None:
            pulumi.set(__self__, "high", high)
        if low is not None:
            pulumi.set(__self__, "low", low)
        if medium is not None:
            pulumi.set(__self__, "medium", medium)
        if profiles is not None:
            pulumi.set(__self__, "profiles", profiles)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Returns all connection strings that can be used to connect to the Autonomous Database. For more information, please see [Predefined Database Service Names for Autonomous Transaction Processing](https://docs.oracle.com/en/cloud/paas/atp-cloud/atpug/connect-predefined.html#GUID-9747539B-FD46-44F1-8FF8-F5AC650F15BE)
        """
        return pulumi.get(self, "all_connection_strings")

    @all_connection_strings.setter
    def all_connection_strings(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "all_connection_strings", value)

    @property
    @pulumi.getter
    def dedicated(self) -> Optional[pulumi.Input[str]]:
        """
        The database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        """
        return pulumi.get(self, "dedicated")

    @dedicated.setter
    def dedicated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dedicated", value)

    @property
    @pulumi.getter
    def high(self) -> Optional[pulumi.Input[str]]:
        """
        The High database service provides the highest level of resources to each SQL statement resulting in the highest performance, but supports the fewest number of concurrent SQL statements.
        """
        return pulumi.get(self, "high")

    @high.setter
    def high(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "high", value)

    @property
    @pulumi.getter
    def low(self) -> Optional[pulumi.Input[str]]:
        """
        The Low database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        """
        return pulumi.get(self, "low")

    @low.setter
    def low(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "low", value)

    @property
    @pulumi.getter
    def medium(self) -> Optional[pulumi.Input[str]]:
        """
        The Medium database service provides a lower level of resources to each SQL statement potentially resulting a lower level of performance, but supports more concurrent SQL statements.
        """
        return pulumi.get(self, "medium")

    @medium.setter
    def medium(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "medium", value)

    @property
    @pulumi.getter
    def profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousDatabaseConnectionStringProfileArgs']]]]:
        """
        A list of connection string profiles to allow clients to group, filter and select connection string values based on structured metadata.
        """
        return pulumi.get(self, "profiles")

    @profiles.setter
    def profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousDatabaseConnectionStringProfileArgs']]]]):
        pulumi.set(self, "profiles", value)


@pulumi.input_type
class AutonomousDatabaseConnectionStringProfileArgs:
    def __init__(__self__, *,
                 consumer_group: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 host_format: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 session_mode: Optional[pulumi.Input[str]] = None,
                 syntax_format: Optional[pulumi.Input[str]] = None,
                 tls_authentication: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] consumer_group: Consumer group used by the connection.
        :param pulumi.Input[str] display_name: (Updatable) The user-friendly name for the Autonomous Database. The name does not have to be unique.
        :param pulumi.Input[str] host_format: Host format used in connection string.
        :param pulumi.Input[str] protocol: Protocol used by the connection.
        :param pulumi.Input[str] session_mode: Specifies whether the listener performs a direct hand-off of the session, or redirects the session. In RAC deployments where SCAN is used, sessions are redirected to a Node VIP. Use `DIRECT` for direct hand-offs. Use `REDIRECT` to redirect the session.
        :param pulumi.Input[str] syntax_format: Specifies whether the connection string is using the long (`LONG`), Easy Connect (`EZCONNECT`), or Easy Connect Plus (`EZCONNECTPLUS`) format. Autonomous Databases on shared Exadata infrastructure always use the long format.
        :param pulumi.Input[str] tls_authentication: Specifies whether the TLS handshake is using one-way (`SERVER`) or mutual (`MUTUAL`) authentication.
        :param pulumi.Input[str] value: Connection string value.
        """
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if host_format is not None:
            pulumi.set(__self__, "host_format", host_format)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if session_mode is not None:
            pulumi.set(__self__, "session_mode", session_mode)
        if syntax_format is not None:
            pulumi.set(__self__, "syntax_format", syntax_format)
        if tls_authentication is not None:
            pulumi.set(__self__, "tls_authentication", tls_authentication)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[pulumi.Input[str]]:
        """
        Consumer group used by the connection.
        """
        return pulumi.get(self, "consumer_group")

    @consumer_group.setter
    def consumer_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_group", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The user-friendly name for the Autonomous Database. The name does not have to be unique.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="hostFormat")
    def host_format(self) -> Optional[pulumi.Input[str]]:
        """
        Host format used in connection string.
        """
        return pulumi.get(self, "host_format")

    @host_format.setter
    def host_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_format", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Protocol used by the connection.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="sessionMode")
    def session_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether the listener performs a direct hand-off of the session, or redirects the session. In RAC deployments where SCAN is used, sessions are redirected to a Node VIP. Use `DIRECT` for direct hand-offs. Use `REDIRECT` to redirect the session.
        """
        return pulumi.get(self, "session_mode")

    @session_mode.setter
    def session_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "session_mode", value)

    @property
    @pulumi.getter(name="syntaxFormat")
    def syntax_format(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether the connection string is using the long (`LONG`), Easy Connect (`EZCONNECT`), or Easy Connect Plus (`EZCONNECTPLUS`) format. Autonomous Databases on shared Exadata infrastructure always use the long format.
        """
        return pulumi.get(self, "syntax_format")

    @syntax_format.setter
    def syntax_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "syntax_format", value)

    @property
    @pulumi.getter(name="tlsAuthentication")
    def tls_authentication(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether the TLS handshake is using one-way (`SERVER`) or mutual (`MUTUAL`) authentication.
        """
        return pulumi.get(self, "tls_authentication")

    @tls_authentication.setter
    def tls_authentication(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_authentication", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Connection string value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class AutonomousDatabaseConnectionUrlArgs:
    def __init__(__self__, *,
                 apex_url: Optional[pulumi.Input[str]] = None,
                 graph_studio_url: Optional[pulumi.Input[str]] = None,
                 machine_learning_user_management_url: Optional[pulumi.Input[str]] = None,
                 sql_dev_web_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] apex_url: Oracle Application Express (APEX) URL.
        :param pulumi.Input[str] graph_studio_url: The URL of the Graph Studio for the Autonomous Database.
        :param pulumi.Input[str] machine_learning_user_management_url: Oracle Machine Learning user management URL.
        :param pulumi.Input[str] sql_dev_web_url: Oracle SQL Developer Web URL.
        """
        if apex_url is not None:
            pulumi.set(__self__, "apex_url", apex_url)
        if graph_studio_url is not None:
            pulumi.set(__self__, "graph_studio_url", graph_studio_url)
        if machine_learning_user_management_url is not None:
            pulumi.set(__self__, "machine_learning_user_management_url", machine_learning_user_management_url)
        if sql_dev_web_url is not None:
            pulumi.set(__self__, "sql_dev_web_url", sql_dev_web_url)

    @property
    @pulumi.getter(name="apexUrl")
    def apex_url(self) -> Optional[pulumi.Input[str]]:
        """
        Oracle Application Express (APEX) URL.
        """
        return pulumi.get(self, "apex_url")

    @apex_url.setter
    def apex_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "apex_url", value)

    @property
    @pulumi.getter(name="graphStudioUrl")
    def graph_studio_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the Graph Studio for the Autonomous Database.
        """
        return pulumi.get(self, "graph_studio_url")

    @graph_studio_url.setter
    def graph_studio_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "graph_studio_url", value)

    @property
    @pulumi.getter(name="machineLearningUserManagementUrl")
    def machine_learning_user_management_url(self) -> Optional[pulumi.Input[str]]:
        """
        Oracle Machine Learning user management URL.
        """
        return pulumi.get(self, "machine_learning_user_management_url")

    @machine_learning_user_management_url.setter
    def machine_learning_user_management_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "machine_learning_user_management_url", value)

    @property
    @pulumi.getter(name="sqlDevWebUrl")
    def sql_dev_web_url(self) -> Optional[pulumi.Input[str]]:
        """
        Oracle SQL Developer Web URL.
        """
        return pulumi.get(self, "sql_dev_web_url")

    @sql_dev_web_url.setter
    def sql_dev_web_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sql_dev_web_url", value)


@pulumi.input_type
class AutonomousDatabaseCustomerContactArgs:
    def __init__(__self__, *,
                 email: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] email: (Updatable) The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        if email is not None:
            pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)


@pulumi.input_type
class AutonomousDatabaseKeyHistoryEntryArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 kms_key_version_id: Optional[pulumi.Input[str]] = None,
                 time_activated: Optional[pulumi.Input[str]] = None,
                 vault_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param pulumi.Input[str] kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        :param pulumi.Input[str] time_activated: The date and time the kms key activated.
        :param pulumi.Input[str] vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if kms_key_version_id is not None:
            pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        if time_activated is not None:
            pulumi.set(__self__, "time_activated", time_activated)
        if vault_id is not None:
            pulumi.set(__self__, "vault_id", vault_id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        """
        return pulumi.get(self, "kms_key_version_id")

    @kms_key_version_id.setter
    def kms_key_version_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_version_id", value)

    @property
    @pulumi.getter(name="timeActivated")
    def time_activated(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the kms key activated.
        """
        return pulumi.get(self, "time_activated")

    @time_activated.setter
    def time_activated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_activated", value)

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")

    @vault_id.setter
    def vault_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vault_id", value)


@pulumi.input_type
class AutonomousDatabaseLocalStandbyDbArgs:
    def __init__(__self__, *,
                 lag_time_in_seconds: Optional[pulumi.Input[int]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 time_data_guard_role_changed: Optional[pulumi.Input[str]] = None,
                 time_disaster_recovery_role_changed: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] lag_time_in_seconds: The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        :param pulumi.Input[str] lifecycle_details: Additional information about the current lifecycle state.
        :param pulumi.Input[str] state: The current state of the Autonomous Database.
        :param pulumi.Input[str] time_data_guard_role_changed: The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        :param pulumi.Input[str] time_disaster_recovery_role_changed: The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        if lag_time_in_seconds is not None:
            pulumi.set(__self__, "lag_time_in_seconds", lag_time_in_seconds)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_data_guard_role_changed is not None:
            pulumi.set(__self__, "time_data_guard_role_changed", time_data_guard_role_changed)
        if time_disaster_recovery_role_changed is not None:
            pulumi.set(__self__, "time_disaster_recovery_role_changed", time_disaster_recovery_role_changed)

    @property
    @pulumi.getter(name="lagTimeInSeconds")
    def lag_time_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        """
        return pulumi.get(self, "lag_time_in_seconds")

    @lag_time_in_seconds.setter
    def lag_time_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lag_time_in_seconds", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the Autonomous Database.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeDataGuardRoleChanged")
    def time_data_guard_role_changed(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        """
        return pulumi.get(self, "time_data_guard_role_changed")

    @time_data_guard_role_changed.setter
    def time_data_guard_role_changed(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_data_guard_role_changed", value)

    @property
    @pulumi.getter(name="timeDisasterRecoveryRoleChanged")
    def time_disaster_recovery_role_changed(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        return pulumi.get(self, "time_disaster_recovery_role_changed")

    @time_disaster_recovery_role_changed.setter
    def time_disaster_recovery_role_changed(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_disaster_recovery_role_changed", value)


@pulumi.input_type
class AutonomousDatabaseLongTermBackupScheduleArgs:
    def __init__(__self__, *,
                 is_disabled: Optional[pulumi.Input[bool]] = None,
                 repeat_cadence: Optional[pulumi.Input[str]] = None,
                 retention_period_in_days: Optional[pulumi.Input[int]] = None,
                 time_of_backup: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_disabled: Indicates if the long-term backup schedule should be deleted. The default value is `FALSE`.
        :param pulumi.Input[str] repeat_cadence: The frequency of the long-term backup schedule
        :param pulumi.Input[int] retention_period_in_days: Retention period, in days, for long-term backups
        :param pulumi.Input[str] time_of_backup: The timestamp for the long-term backup schedule. For a MONTHLY cadence, months having fewer days than the provided date will have the backup taken on the last day of that month.
        """
        if is_disabled is not None:
            pulumi.set(__self__, "is_disabled", is_disabled)
        if repeat_cadence is not None:
            pulumi.set(__self__, "repeat_cadence", repeat_cadence)
        if retention_period_in_days is not None:
            pulumi.set(__self__, "retention_period_in_days", retention_period_in_days)
        if time_of_backup is not None:
            pulumi.set(__self__, "time_of_backup", time_of_backup)

    @property
    @pulumi.getter(name="isDisabled")
    def is_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if the long-term backup schedule should be deleted. The default value is `FALSE`.
        """
        return pulumi.get(self, "is_disabled")

    @is_disabled.setter
    def is_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_disabled", value)

    @property
    @pulumi.getter(name="repeatCadence")
    def repeat_cadence(self) -> Optional[pulumi.Input[str]]:
        """
        The frequency of the long-term backup schedule
        """
        return pulumi.get(self, "repeat_cadence")

    @repeat_cadence.setter
    def repeat_cadence(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repeat_cadence", value)

    @property
    @pulumi.getter(name="retentionPeriodInDays")
    def retention_period_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        Retention period, in days, for long-term backups
        """
        return pulumi.get(self, "retention_period_in_days")

    @retention_period_in_days.setter
    def retention_period_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_period_in_days", value)

    @property
    @pulumi.getter(name="timeOfBackup")
    def time_of_backup(self) -> Optional[pulumi.Input[str]]:
        """
        The timestamp for the long-term backup schedule. For a MONTHLY cadence, months having fewer days than the provided date will have the backup taken on the last day of that month.
        """
        return pulumi.get(self, "time_of_backup")

    @time_of_backup.setter
    def time_of_backup(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_of_backup", value)


@pulumi.input_type
class AutonomousDatabaseRemoteDisasterRecoveryConfigurationArgs:
    def __init__(__self__, *,
                 disaster_recovery_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] disaster_recovery_type: Indicates the disaster recovery (DR) type of the Shared Autonomous Database. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
        """
        if disaster_recovery_type is not None:
            pulumi.set(__self__, "disaster_recovery_type", disaster_recovery_type)

    @property
    @pulumi.getter(name="disasterRecoveryType")
    def disaster_recovery_type(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates the disaster recovery (DR) type of the Shared Autonomous Database. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
        """
        return pulumi.get(self, "disaster_recovery_type")

    @disaster_recovery_type.setter
    def disaster_recovery_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disaster_recovery_type", value)


@pulumi.input_type
class AutonomousDatabaseResourcePoolSummaryArgs:
    def __init__(__self__, *,
                 is_disabled: Optional[pulumi.Input[bool]] = None,
                 pool_size: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] is_disabled: Indicates if the long-term backup schedule should be deleted. The default value is `FALSE`.
        """
        if is_disabled is not None:
            pulumi.set(__self__, "is_disabled", is_disabled)
        if pool_size is not None:
            pulumi.set(__self__, "pool_size", pool_size)

    @property
    @pulumi.getter(name="isDisabled")
    def is_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if the long-term backup schedule should be deleted. The default value is `FALSE`.
        """
        return pulumi.get(self, "is_disabled")

    @is_disabled.setter
    def is_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_disabled", value)

    @property
    @pulumi.getter(name="poolSize")
    def pool_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "pool_size")

    @pool_size.setter
    def pool_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pool_size", value)


@pulumi.input_type
class AutonomousDatabaseScheduledOperationArgs:
    def __init__(__self__, *,
                 day_of_week: pulumi.Input['AutonomousDatabaseScheduledOperationDayOfWeekArgs'],
                 scheduled_start_time: Optional[pulumi.Input[str]] = None,
                 scheduled_stop_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['AutonomousDatabaseScheduledOperationDayOfWeekArgs'] day_of_week: (Updatable) Day of the week.
        :param pulumi.Input[str] scheduled_start_time: (Updatable) auto start time. value must be of ISO-8601 format "HH:mm"
        :param pulumi.Input[str] scheduled_stop_time: (Updatable) auto stop time. value must be of ISO-8601 format "HH:mm"
        """
        pulumi.set(__self__, "day_of_week", day_of_week)
        if scheduled_start_time is not None:
            pulumi.set(__self__, "scheduled_start_time", scheduled_start_time)
        if scheduled_stop_time is not None:
            pulumi.set(__self__, "scheduled_stop_time", scheduled_stop_time)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> pulumi.Input['AutonomousDatabaseScheduledOperationDayOfWeekArgs']:
        """
        (Updatable) Day of the week.
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: pulumi.Input['AutonomousDatabaseScheduledOperationDayOfWeekArgs']):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter(name="scheduledStartTime")
    def scheduled_start_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) auto start time. value must be of ISO-8601 format "HH:mm"
        """
        return pulumi.get(self, "scheduled_start_time")

    @scheduled_start_time.setter
    def scheduled_start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheduled_start_time", value)

    @property
    @pulumi.getter(name="scheduledStopTime")
    def scheduled_stop_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) auto stop time. value must be of ISO-8601 format "HH:mm"
        """
        return pulumi.get(self, "scheduled_stop_time")

    @scheduled_stop_time.setter
    def scheduled_stop_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheduled_stop_time", value)


@pulumi.input_type
class AutonomousDatabaseScheduledOperationDayOfWeekArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the day of the week.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the day of the week.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class AutonomousDatabaseStandbyDbArgs:
    def __init__(__self__, *,
                 lag_time_in_seconds: Optional[pulumi.Input[int]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 time_data_guard_role_changed: Optional[pulumi.Input[str]] = None,
                 time_disaster_recovery_role_changed: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] lag_time_in_seconds: The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        :param pulumi.Input[str] lifecycle_details: Additional information about the current lifecycle state.
        :param pulumi.Input[str] state: The current state of the Autonomous Database.
        :param pulumi.Input[str] time_data_guard_role_changed: The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        :param pulumi.Input[str] time_disaster_recovery_role_changed: The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        if lag_time_in_seconds is not None:
            pulumi.set(__self__, "lag_time_in_seconds", lag_time_in_seconds)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_data_guard_role_changed is not None:
            pulumi.set(__self__, "time_data_guard_role_changed", time_data_guard_role_changed)
        if time_disaster_recovery_role_changed is not None:
            pulumi.set(__self__, "time_disaster_recovery_role_changed", time_disaster_recovery_role_changed)

    @property
    @pulumi.getter(name="lagTimeInSeconds")
    def lag_time_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        """
        return pulumi.get(self, "lag_time_in_seconds")

    @lag_time_in_seconds.setter
    def lag_time_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lag_time_in_seconds", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the Autonomous Database.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeDataGuardRoleChanged")
    def time_data_guard_role_changed(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        """
        return pulumi.get(self, "time_data_guard_role_changed")

    @time_data_guard_role_changed.setter
    def time_data_guard_role_changed(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_data_guard_role_changed", value)

    @property
    @pulumi.getter(name="timeDisasterRecoveryRoleChanged")
    def time_disaster_recovery_role_changed(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        return pulumi.get(self, "time_disaster_recovery_role_changed")

    @time_disaster_recovery_role_changed.setter
    def time_disaster_recovery_role_changed(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_disaster_recovery_role_changed", value)


@pulumi.input_type
class AutonomousExadataInfrastructureMaintenanceWindowArgs:
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[pulumi.Input[int]] = None,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 is_custom_action_timeout_enabled: Optional[pulumi.Input[bool]] = None,
                 is_monthly_patching_enabled: Optional[pulumi.Input[bool]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowMonthArgs']]]] = None,
                 patching_mode: Optional[pulumi.Input[str]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[int] custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[bool] is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param pulumi.Input[bool] is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param pulumi.Input[int] lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowMonthArgs']]] months: (Updatable) Months during the year when maintenance should be performed.
        :param pulumi.Input[str] patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param pulumi.Input[str] preference: (Updatable) The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @custom_action_timeout_in_mins.setter
    def custom_action_timeout_in_mins(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_action_timeout_in_mins", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]]]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @is_custom_action_timeout_enabled.setter
    def is_custom_action_timeout_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom_action_timeout_enabled", value)

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @is_monthly_patching_enabled.setter
    def is_monthly_patching_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monthly_patching_enabled", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowMonthArgs']]]]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @patching_mode.setter
    def patching_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patching_mode", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


@pulumi.input_type
class AutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class AutonomousExadataInfrastructureMaintenanceWindowDetailsArgs:
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[pulumi.Input[int]] = None,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 is_custom_action_timeout_enabled: Optional[pulumi.Input[bool]] = None,
                 is_monthly_patching_enabled: Optional[pulumi.Input[bool]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowDetailsMonthArgs']]]] = None,
                 patching_mode: Optional[pulumi.Input[str]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[int] custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeekArgs']]] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[bool] is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param pulumi.Input[bool] is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param pulumi.Input[int] lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowDetailsMonthArgs']]] months: (Updatable) Months during the year when maintenance should be performed.
        :param pulumi.Input[str] patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param pulumi.Input[str] preference: (Updatable) The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @custom_action_timeout_in_mins.setter
    def custom_action_timeout_in_mins(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_action_timeout_in_mins", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeekArgs']]]]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @is_custom_action_timeout_enabled.setter
    def is_custom_action_timeout_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom_action_timeout_enabled", value)

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @is_monthly_patching_enabled.setter
    def is_monthly_patching_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monthly_patching_enabled", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowDetailsMonthArgs']]]]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousExadataInfrastructureMaintenanceWindowDetailsMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @patching_mode.setter
    def patching_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patching_mode", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


@pulumi.input_type
class AutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class AutonomousExadataInfrastructureMaintenanceWindowDetailsMonthArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class AutonomousExadataInfrastructureMaintenanceWindowMonthArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class AutonomousVmClusterMaintenanceWindowArgs:
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[pulumi.Input[int]] = None,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 is_custom_action_timeout_enabled: Optional[pulumi.Input[bool]] = None,
                 is_monthly_patching_enabled: Optional[pulumi.Input[bool]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowMonthArgs']]]] = None,
                 patching_mode: Optional[pulumi.Input[str]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowDaysOfWeekArgs']]] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[int] lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowMonthArgs']]] months: (Updatable) Months during the year when maintenance should be performed.
        :param pulumi.Input[str] patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param pulumi.Input[str] preference: (Updatable) The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @custom_action_timeout_in_mins.setter
    def custom_action_timeout_in_mins(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_action_timeout_in_mins", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowDaysOfWeekArgs']]]]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @is_custom_action_timeout_enabled.setter
    def is_custom_action_timeout_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom_action_timeout_enabled", value)

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_monthly_patching_enabled")

    @is_monthly_patching_enabled.setter
    def is_monthly_patching_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monthly_patching_enabled", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowMonthArgs']]]]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @patching_mode.setter
    def patching_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patching_mode", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


@pulumi.input_type
class AutonomousVmClusterMaintenanceWindowDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class AutonomousVmClusterMaintenanceWindowDetailArgs:
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[pulumi.Input[int]] = None,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowDetailDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 is_custom_action_timeout_enabled: Optional[pulumi.Input[bool]] = None,
                 is_monthly_patching_enabled: Optional[pulumi.Input[bool]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowDetailMonthArgs']]]] = None,
                 patching_mode: Optional[pulumi.Input[str]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowDetailDaysOfWeekArgs']]] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[int] lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowDetailMonthArgs']]] months: (Updatable) Months during the year when maintenance should be performed.
        :param pulumi.Input[str] patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param pulumi.Input[str] preference: (Updatable) The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @custom_action_timeout_in_mins.setter
    def custom_action_timeout_in_mins(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_action_timeout_in_mins", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowDetailDaysOfWeekArgs']]]]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowDetailDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @is_custom_action_timeout_enabled.setter
    def is_custom_action_timeout_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom_action_timeout_enabled", value)

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_monthly_patching_enabled")

    @is_monthly_patching_enabled.setter
    def is_monthly_patching_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monthly_patching_enabled", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowDetailMonthArgs']]]]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutonomousVmClusterMaintenanceWindowDetailMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @patching_mode.setter
    def patching_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patching_mode", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


@pulumi.input_type
class AutonomousVmClusterMaintenanceWindowDetailDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class AutonomousVmClusterMaintenanceWindowDetailMonthArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class AutonomousVmClusterMaintenanceWindowMonthArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class BackupDestinationAssociatedDatabaseArgs:
    def __init__(__self__, *,
                 db_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] db_name: The display name of the database that is associated with the backup destination.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[pulumi.Input[str]]:
        """
        The display name of the database that is associated with the backup destination.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class BackupDestinationMountTypeDetailsArgs:
    def __init__(__self__, *,
                 mount_type: pulumi.Input[str],
                 local_mount_point_path: Optional[pulumi.Input[str]] = None,
                 nfs_server_export: Optional[pulumi.Input[str]] = None,
                 nfs_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] mount_type: Mount type for backup destination.
        :param pulumi.Input[str] local_mount_point_path: The local directory path on each VM cluster node where the NFS server location is mounted. The local directory path and the NFS server location must each be the same across all of the VM cluster nodes. Ensure that the NFS mount is maintained continuously on all of the VM cluster nodes.
        :param pulumi.Input[str] nfs_server_export: Specifies the directory on which to mount the file system
        :param pulumi.Input[Sequence[pulumi.Input[str]]] nfs_servers: IP addresses for NFS Auto mount.
        """
        pulumi.set(__self__, "mount_type", mount_type)
        if local_mount_point_path is not None:
            pulumi.set(__self__, "local_mount_point_path", local_mount_point_path)
        if nfs_server_export is not None:
            pulumi.set(__self__, "nfs_server_export", nfs_server_export)
        if nfs_servers is not None:
            pulumi.set(__self__, "nfs_servers", nfs_servers)

    @property
    @pulumi.getter(name="mountType")
    def mount_type(self) -> pulumi.Input[str]:
        """
        Mount type for backup destination.
        """
        return pulumi.get(self, "mount_type")

    @mount_type.setter
    def mount_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "mount_type", value)

    @property
    @pulumi.getter(name="localMountPointPath")
    def local_mount_point_path(self) -> Optional[pulumi.Input[str]]:
        """
        The local directory path on each VM cluster node where the NFS server location is mounted. The local directory path and the NFS server location must each be the same across all of the VM cluster nodes. Ensure that the NFS mount is maintained continuously on all of the VM cluster nodes.
        """
        return pulumi.get(self, "local_mount_point_path")

    @local_mount_point_path.setter
    def local_mount_point_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "local_mount_point_path", value)

    @property
    @pulumi.getter(name="nfsServerExport")
    def nfs_server_export(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the directory on which to mount the file system
        """
        return pulumi.get(self, "nfs_server_export")

    @nfs_server_export.setter
    def nfs_server_export(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nfs_server_export", value)

    @property
    @pulumi.getter(name="nfsServers")
    def nfs_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        IP addresses for NFS Auto mount.
        """
        return pulumi.get(self, "nfs_servers")

    @nfs_servers.setter
    def nfs_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "nfs_servers", value)


@pulumi.input_type
class CloudAutonomousVmClusterMaintenanceWindowArgs:
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[pulumi.Input[int]] = None,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 is_custom_action_timeout_enabled: Optional[pulumi.Input[bool]] = None,
                 is_monthly_patching_enabled: Optional[pulumi.Input[bool]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowMonthArgs']]]] = None,
                 patching_mode: Optional[pulumi.Input[str]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[int] custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgs']]] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[bool] is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param pulumi.Input[bool] is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param pulumi.Input[int] lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowMonthArgs']]] months: (Updatable) Months during the year when maintenance should be performed.
        :param pulumi.Input[str] patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param pulumi.Input[str] preference: (Updatable) The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @custom_action_timeout_in_mins.setter
    def custom_action_timeout_in_mins(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_action_timeout_in_mins", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgs']]]]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @is_custom_action_timeout_enabled.setter
    def is_custom_action_timeout_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom_action_timeout_enabled", value)

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @is_monthly_patching_enabled.setter
    def is_monthly_patching_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monthly_patching_enabled", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowMonthArgs']]]]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @patching_mode.setter
    def patching_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patching_mode", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


@pulumi.input_type
class CloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class CloudAutonomousVmClusterMaintenanceWindowDetailsArgs:
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[pulumi.Input[int]] = None,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDetailsDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 is_custom_action_timeout_enabled: Optional[pulumi.Input[bool]] = None,
                 is_monthly_patching_enabled: Optional[pulumi.Input[bool]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDetailsMonthArgs']]]] = None,
                 patching_mode: Optional[pulumi.Input[str]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[int] custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDetailsDaysOfWeekArgs']]] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[bool] is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param pulumi.Input[bool] is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param pulumi.Input[int] lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDetailsMonthArgs']]] months: (Updatable) Months during the year when maintenance should be performed.
        :param pulumi.Input[str] patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param pulumi.Input[str] preference: (Updatable) The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @custom_action_timeout_in_mins.setter
    def custom_action_timeout_in_mins(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_action_timeout_in_mins", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDetailsDaysOfWeekArgs']]]]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDetailsDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @is_custom_action_timeout_enabled.setter
    def is_custom_action_timeout_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom_action_timeout_enabled", value)

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @is_monthly_patching_enabled.setter
    def is_monthly_patching_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monthly_patching_enabled", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDetailsMonthArgs']]]]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudAutonomousVmClusterMaintenanceWindowDetailsMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @patching_mode.setter
    def patching_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patching_mode", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


@pulumi.input_type
class CloudAutonomousVmClusterMaintenanceWindowDetailsDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class CloudAutonomousVmClusterMaintenanceWindowDetailsMonthArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class CloudAutonomousVmClusterMaintenanceWindowMonthArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class CloudDatabaseManagementCredentialdetailsArgs:
    def __init__(__self__, *,
                 password_secret_id: pulumi.Input[str],
                 user_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password_secret_id: Specific database username's password [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input[str] user_name: Database username
        """
        pulumi.set(__self__, "password_secret_id", password_secret_id)
        pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="passwordSecretId")
    def password_secret_id(self) -> pulumi.Input[str]:
        """
        Specific database username's password [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "password_secret_id")

    @password_secret_id.setter
    def password_secret_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "password_secret_id", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> pulumi.Input[str]:
        """
        Database username
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class CloudExadataInfrastructureCustomerContactArgs:
    def __init__(__self__, *,
                 email: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] email: (Updatable) The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        if email is not None:
            pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)


@pulumi.input_type
class CloudExadataInfrastructureMaintenanceWindowArgs:
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[pulumi.Input[int]] = None,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['CloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 is_custom_action_timeout_enabled: Optional[pulumi.Input[bool]] = None,
                 is_monthly_patching_enabled: Optional[pulumi.Input[bool]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['CloudExadataInfrastructureMaintenanceWindowMonthArgs']]]] = None,
                 patching_mode: Optional[pulumi.Input[str]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[int] custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param pulumi.Input[Sequence[pulumi.Input['CloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[bool] is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param pulumi.Input[bool] is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param pulumi.Input[int] lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['CloudExadataInfrastructureMaintenanceWindowMonthArgs']]] months: (Updatable) Months during the year when maintenance should be performed.
        :param pulumi.Input[str] patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param pulumi.Input[str] preference: (Updatable) The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @custom_action_timeout_in_mins.setter
    def custom_action_timeout_in_mins(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_action_timeout_in_mins", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]]]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @is_custom_action_timeout_enabled.setter
    def is_custom_action_timeout_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom_action_timeout_enabled", value)

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @is_monthly_patching_enabled.setter
    def is_monthly_patching_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monthly_patching_enabled", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudExadataInfrastructureMaintenanceWindowMonthArgs']]]]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudExadataInfrastructureMaintenanceWindowMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @patching_mode.setter
    def patching_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patching_mode", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


@pulumi.input_type
class CloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class CloudExadataInfrastructureMaintenanceWindowMonthArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class CloudVmClusterDataCollectionOptionsArgs:
    def __init__(__self__, *,
                 is_diagnostics_events_enabled: Optional[pulumi.Input[bool]] = None,
                 is_health_monitoring_enabled: Optional[pulumi.Input[bool]] = None,
                 is_incident_logs_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_diagnostics_events_enabled: (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param pulumi.Input[bool] is_health_monitoring_enabled: (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param pulumi.Input[bool] is_incident_logs_enabled: (Updatable) Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        if is_diagnostics_events_enabled is not None:
            pulumi.set(__self__, "is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        if is_health_monitoring_enabled is not None:
            pulumi.set(__self__, "is_health_monitoring_enabled", is_health_monitoring_enabled)
        if is_incident_logs_enabled is not None:
            pulumi.set(__self__, "is_incident_logs_enabled", is_incident_logs_enabled)

    @property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @is_diagnostics_events_enabled.setter
    def is_diagnostics_events_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_diagnostics_events_enabled", value)

    @property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @is_health_monitoring_enabled.setter
    def is_health_monitoring_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_health_monitoring_enabled", value)

    @property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")

    @is_incident_logs_enabled.setter
    def is_incident_logs_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_incident_logs_enabled", value)


@pulumi.input_type
class CloudVmClusterIormConfigCachArgs:
    def __init__(__self__, *,
                 db_plans: Optional[pulumi.Input[Sequence[pulumi.Input['CloudVmClusterIormConfigCachDbPlanArgs']]]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 objective: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CloudVmClusterIormConfigCachDbPlanArgs']]] db_plans: An array of IORM settings for all the database in the Exadata DB system.
        :param pulumi.Input[str] lifecycle_details: Additional information about the current lifecycle state.
        :param pulumi.Input[str] objective: The current value for the IORM objective. The default is `AUTO`.
        :param pulumi.Input[str] state: The current state of the cloud VM cluster.
        """
        if db_plans is not None:
            pulumi.set(__self__, "db_plans", db_plans)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if objective is not None:
            pulumi.set(__self__, "objective", objective)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="dbPlans")
    def db_plans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudVmClusterIormConfigCachDbPlanArgs']]]]:
        """
        An array of IORM settings for all the database in the Exadata DB system.
        """
        return pulumi.get(self, "db_plans")

    @db_plans.setter
    def db_plans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudVmClusterIormConfigCachDbPlanArgs']]]]):
        pulumi.set(self, "db_plans", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter
    def objective(self) -> Optional[pulumi.Input[str]]:
        """
        The current value for the IORM objective. The default is `AUTO`.
        """
        return pulumi.get(self, "objective")

    @objective.setter
    def objective(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "objective", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the cloud VM cluster.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


@pulumi.input_type
class CloudVmClusterIormConfigCachDbPlanArgs:
    def __init__(__self__, *,
                 db_name: Optional[pulumi.Input[str]] = None,
                 flash_cache_limit: Optional[pulumi.Input[str]] = None,
                 share: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] db_name: The database name. For the default `DbPlan`, the `dbName` is `default`.
        :param pulumi.Input[str] flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        :param pulumi.Input[int] share: The relative priority of this database.
        """
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if flash_cache_limit is not None:
            pulumi.set(__self__, "flash_cache_limit", flash_cache_limit)
        if share is not None:
            pulumi.set(__self__, "share", share)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[pulumi.Input[str]]:
        """
        The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")

    @flash_cache_limit.setter
    def flash_cache_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flash_cache_limit", value)

    @property
    @pulumi.getter
    def share(self) -> Optional[pulumi.Input[int]]:
        """
        The relative priority of this database.
        """
        return pulumi.get(self, "share")

    @share.setter
    def share(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "share", value)


@pulumi.input_type
class CloudVmClusterIormConfigDbPlanArgs:
    def __init__(__self__, *,
                 db_name: pulumi.Input[str],
                 share: pulumi.Input[int],
                 flash_cache_limit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] db_name: (Updatable) The database name. For the default `DbPlan`, the `dbName` is `default`.
        :param pulumi.Input[int] share: (Updatable) The relative priority of this database.
        :param pulumi.Input[str] flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "share", share)
        if flash_cache_limit is not None:
            pulumi.set(__self__, "flash_cache_limit", flash_cache_limit)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> pulumi.Input[str]:
        """
        (Updatable) The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter
    def share(self) -> pulumi.Input[int]:
        """
        (Updatable) The relative priority of this database.
        """
        return pulumi.get(self, "share")

    @share.setter
    def share(self, value: pulumi.Input[int]):
        pulumi.set(self, "share", value)

    @property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")

    @flash_cache_limit.setter
    def flash_cache_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flash_cache_limit", value)


@pulumi.input_type
class DataGuardAssociationDataCollectionOptionsArgs:
    def __init__(__self__, *,
                 is_diagnostics_events_enabled: Optional[pulumi.Input[bool]] = None,
                 is_health_monitoring_enabled: Optional[pulumi.Input[bool]] = None,
                 is_incident_logs_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_diagnostics_events_enabled: Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param pulumi.Input[bool] is_health_monitoring_enabled: Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param pulumi.Input[bool] is_incident_logs_enabled: Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        if is_diagnostics_events_enabled is not None:
            pulumi.set(__self__, "is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        if is_health_monitoring_enabled is not None:
            pulumi.set(__self__, "is_health_monitoring_enabled", is_health_monitoring_enabled)
        if is_incident_logs_enabled is not None:
            pulumi.set(__self__, "is_incident_logs_enabled", is_incident_logs_enabled)

    @property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @is_diagnostics_events_enabled.setter
    def is_diagnostics_events_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_diagnostics_events_enabled", value)

    @property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @is_health_monitoring_enabled.setter
    def is_health_monitoring_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_health_monitoring_enabled", value)

    @property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")

    @is_incident_logs_enabled.setter
    def is_incident_logs_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_incident_logs_enabled", value)


@pulumi.input_type
class DatabaseConnectionStringArgs:
    def __init__(__self__, *,
                 all_connection_strings: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 cdb_default: Optional[pulumi.Input[str]] = None,
                 cdb_ip_default: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, Any]] all_connection_strings: All connection strings to use to connect to the Database.
        :param pulumi.Input[str] cdb_default: Host name based CDB Connection String.
        :param pulumi.Input[str] cdb_ip_default: IP based CDB Connection String.
        """
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if cdb_default is not None:
            pulumi.set(__self__, "cdb_default", cdb_default)
        if cdb_ip_default is not None:
            pulumi.set(__self__, "cdb_ip_default", cdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        All connection strings to use to connect to the Database.
        """
        return pulumi.get(self, "all_connection_strings")

    @all_connection_strings.setter
    def all_connection_strings(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "all_connection_strings", value)

    @property
    @pulumi.getter(name="cdbDefault")
    def cdb_default(self) -> Optional[pulumi.Input[str]]:
        """
        Host name based CDB Connection String.
        """
        return pulumi.get(self, "cdb_default")

    @cdb_default.setter
    def cdb_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cdb_default", value)

    @property
    @pulumi.getter(name="cdbIpDefault")
    def cdb_ip_default(self) -> Optional[pulumi.Input[str]]:
        """
        IP based CDB Connection String.
        """
        return pulumi.get(self, "cdb_ip_default")

    @cdb_ip_default.setter
    def cdb_ip_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cdb_ip_default", value)


@pulumi.input_type
class DatabaseDatabaseArgs:
    def __init__(__self__, *,
                 admin_password: pulumi.Input[str],
                 db_name: pulumi.Input[str],
                 backup_id: Optional[pulumi.Input[str]] = None,
                 backup_tde_password: Optional[pulumi.Input[str]] = None,
                 character_set: Optional[pulumi.Input[str]] = None,
                 database_software_image_id: Optional[pulumi.Input[str]] = None,
                 db_backup_config: Optional[pulumi.Input['DatabaseDatabaseDbBackupConfigArgs']] = None,
                 db_unique_name: Optional[pulumi.Input[str]] = None,
                 db_workload: Optional[pulumi.Input[str]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 kms_key_version_id: Optional[pulumi.Input[str]] = None,
                 ncharacter_set: Optional[pulumi.Input[str]] = None,
                 pdb_name: Optional[pulumi.Input[str]] = None,
                 pluggable_databases: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sid_prefix: Optional[pulumi.Input[str]] = None,
                 tde_wallet_password: Optional[pulumi.Input[str]] = None,
                 vault_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] admin_password: A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \\#, or -.
        :param pulumi.Input[str] db_name: The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        :param pulumi.Input[str] backup_id: The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input[str] backup_tde_password: The password to open the TDE wallet.
        :param pulumi.Input[str] character_set: The character set for the database.  The default is AL32UTF8. Allowed values are:
               
               AL32UTF8, AR8ADOS710, AR8ADOS720, AR8APTEC715, AR8ARABICMACS, AR8ASMO8X, AR8ISO8859P6, AR8MSWIN1256, AR8MUSSAD768, AR8NAFITHA711, AR8NAFITHA721, AR8SAKHR706, AR8SAKHR707, AZ8ISO8859P9E, BG8MSWIN, BG8PC437S, BLT8CP921, BLT8ISO8859P13, BLT8MSWIN1257, BLT8PC775, BN8BSCII, CDN8PC863, CEL8ISO8859P14, CL8ISO8859P5, CL8ISOIR111, CL8KOI8R, CL8KOI8U, CL8MACCYRILLICS, CL8MSWIN1251, EE8ISO8859P2, EE8MACCES, EE8MACCROATIANS, EE8MSWIN1250, EE8PC852, EL8DEC, EL8ISO8859P7, EL8MACGREEKS, EL8MSWIN1253, EL8PC437S, EL8PC851, EL8PC869, ET8MSWIN923, HU8ABMOD, HU8CWI2, IN8ISCII, IS8PC861, IW8ISO8859P8, IW8MACHEBREWS, IW8MSWIN1255, IW8PC1507, JA16EUC, JA16EUCTILDE, JA16SJIS, JA16SJISTILDE, JA16VMS, KO16KSC5601, KO16KSCCS, KO16MSWIN949, LA8ISO6937, LA8PASSPORT, LT8MSWIN921, LT8PC772, LT8PC774, LV8PC1117, LV8PC8LR, LV8RST104090, N8PC865, NE8ISO8859P10, NEE8ISO8859P4, RU8BESTA, RU8PC855, RU8PC866, SE8ISO8859P3, TH8MACTHAIS, TH8TISASCII, TR8DEC, TR8MACTURKISHS, TR8MSWIN1254, TR8PC857, US7ASCII, US8PC437, UTF8, VN8MSWIN1258, VN8VN3, WE8DEC, WE8DG, WE8ISO8859P1, WE8ISO8859P15, WE8ISO8859P9, WE8MACROMAN8S, WE8MSWIN1252, WE8NCR4970, WE8NEXTSTEP, WE8PC850, WE8PC858, WE8PC860, WE8ROMAN8, ZHS16CGB231280, ZHS16GBK, ZHT16BIG5, ZHT16CCDC, ZHT16DBT, ZHT16HKSCS, ZHT16MSWIN950, ZHT32EUC, ZHT32SOPS, ZHT32TRIS
        :param pulumi.Input[str] database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        :param pulumi.Input['DatabaseDatabaseDbBackupConfigArgs'] db_backup_config: (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        :param pulumi.Input[str] db_unique_name: The `DB_UNIQUE_NAME` of the Oracle Database being backed up.
        :param pulumi.Input[str] db_workload: **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.
               
               The database workload type.
        :param pulumi.Input[Mapping[str, Any]] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param pulumi.Input[Mapping[str, Any]] freeform_tags: (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param pulumi.Input[str] kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param pulumi.Input[str] kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        :param pulumi.Input[str] ncharacter_set: The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        :param pulumi.Input[str] pdb_name: The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pluggable_databases: The list of pluggable databases that needs to be restored into new database.
        :param pulumi.Input[str] sid_prefix: Specifies a prefix for the `Oracle SID` of the database to be created.
        :param pulumi.Input[str] tde_wallet_password: The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \\#, or -.
        :param pulumi.Input[str] vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        pulumi.set(__self__, "admin_password", admin_password)
        pulumi.set(__self__, "db_name", db_name)
        if backup_id is not None:
            pulumi.set(__self__, "backup_id", backup_id)
        if backup_tde_password is not None:
            pulumi.set(__self__, "backup_tde_password", backup_tde_password)
        if character_set is not None:
            pulumi.set(__self__, "character_set", character_set)
        if database_software_image_id is not None:
            pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        if db_backup_config is not None:
            pulumi.set(__self__, "db_backup_config", db_backup_config)
        if db_unique_name is not None:
            pulumi.set(__self__, "db_unique_name", db_unique_name)
        if db_workload is not None:
            pulumi.set(__self__, "db_workload", db_workload)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if kms_key_version_id is not None:
            pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        if ncharacter_set is not None:
            pulumi.set(__self__, "ncharacter_set", ncharacter_set)
        if pdb_name is not None:
            pulumi.set(__self__, "pdb_name", pdb_name)
        if pluggable_databases is not None:
            pulumi.set(__self__, "pluggable_databases", pluggable_databases)
        if sid_prefix is not None:
            pulumi.set(__self__, "sid_prefix", sid_prefix)
        if tde_wallet_password is not None:
            pulumi.set(__self__, "tde_wallet_password", tde_wallet_password)
        if vault_id is not None:
            pulumi.set(__self__, "vault_id", vault_id)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> pulumi.Input[str]:
        """
        A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \\#, or -.
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> pulumi.Input[str]:
        """
        The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> Optional[pulumi.Input[str]]:
        """
        The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "backup_id")

    @backup_id.setter
    def backup_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_id", value)

    @property
    @pulumi.getter(name="backupTdePassword")
    def backup_tde_password(self) -> Optional[pulumi.Input[str]]:
        """
        The password to open the TDE wallet.
        """
        return pulumi.get(self, "backup_tde_password")

    @backup_tde_password.setter
    def backup_tde_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_tde_password", value)

    @property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> Optional[pulumi.Input[str]]:
        """
        The character set for the database.  The default is AL32UTF8. Allowed values are:

        AL32UTF8, AR8ADOS710, AR8ADOS720, AR8APTEC715, AR8ARABICMACS, AR8ASMO8X, AR8ISO8859P6, AR8MSWIN1256, AR8MUSSAD768, AR8NAFITHA711, AR8NAFITHA721, AR8SAKHR706, AR8SAKHR707, AZ8ISO8859P9E, BG8MSWIN, BG8PC437S, BLT8CP921, BLT8ISO8859P13, BLT8MSWIN1257, BLT8PC775, BN8BSCII, CDN8PC863, CEL8ISO8859P14, CL8ISO8859P5, CL8ISOIR111, CL8KOI8R, CL8KOI8U, CL8MACCYRILLICS, CL8MSWIN1251, EE8ISO8859P2, EE8MACCES, EE8MACCROATIANS, EE8MSWIN1250, EE8PC852, EL8DEC, EL8ISO8859P7, EL8MACGREEKS, EL8MSWIN1253, EL8PC437S, EL8PC851, EL8PC869, ET8MSWIN923, HU8ABMOD, HU8CWI2, IN8ISCII, IS8PC861, IW8ISO8859P8, IW8MACHEBREWS, IW8MSWIN1255, IW8PC1507, JA16EUC, JA16EUCTILDE, JA16SJIS, JA16SJISTILDE, JA16VMS, KO16KSC5601, KO16KSCCS, KO16MSWIN949, LA8ISO6937, LA8PASSPORT, LT8MSWIN921, LT8PC772, LT8PC774, LV8PC1117, LV8PC8LR, LV8RST104090, N8PC865, NE8ISO8859P10, NEE8ISO8859P4, RU8BESTA, RU8PC855, RU8PC866, SE8ISO8859P3, TH8MACTHAIS, TH8TISASCII, TR8DEC, TR8MACTURKISHS, TR8MSWIN1254, TR8PC857, US7ASCII, US8PC437, UTF8, VN8MSWIN1258, VN8VN3, WE8DEC, WE8DG, WE8ISO8859P1, WE8ISO8859P15, WE8ISO8859P9, WE8MACROMAN8S, WE8MSWIN1252, WE8NCR4970, WE8NEXTSTEP, WE8PC850, WE8PC858, WE8PC860, WE8ROMAN8, ZHS16CGB231280, ZHS16GBK, ZHT16BIG5, ZHT16CCDC, ZHT16DBT, ZHT16HKSCS, ZHT16MSWIN950, ZHT32EUC, ZHT32SOPS, ZHT32TRIS
        """
        return pulumi.get(self, "character_set")

    @character_set.setter
    def character_set(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "character_set", value)

    @property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> Optional[pulumi.Input[str]]:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        return pulumi.get(self, "database_software_image_id")

    @database_software_image_id.setter
    def database_software_image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_software_image_id", value)

    @property
    @pulumi.getter(name="dbBackupConfig")
    def db_backup_config(self) -> Optional[pulumi.Input['DatabaseDatabaseDbBackupConfigArgs']]:
        """
        (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        """
        return pulumi.get(self, "db_backup_config")

    @db_backup_config.setter
    def db_backup_config(self, value: Optional[pulumi.Input['DatabaseDatabaseDbBackupConfigArgs']]):
        pulumi.set(self, "db_backup_config", value)

    @property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> Optional[pulumi.Input[str]]:
        """
        The `DB_UNIQUE_NAME` of the Oracle Database being backed up.
        """
        return pulumi.get(self, "db_unique_name")

    @db_unique_name.setter
    def db_unique_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_unique_name", value)

    @property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> Optional[pulumi.Input[str]]:
        """
        **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.

        The database workload type.
        """
        return pulumi.get(self, "db_workload")

    @db_workload.setter
    def db_workload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_workload", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        """
        return pulumi.get(self, "kms_key_version_id")

    @kms_key_version_id.setter
    def kms_key_version_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_version_id", value)

    @property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> Optional[pulumi.Input[str]]:
        """
        The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        """
        return pulumi.get(self, "ncharacter_set")

    @ncharacter_set.setter
    def ncharacter_set(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ncharacter_set", value)

    @property
    @pulumi.getter(name="pdbName")
    def pdb_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        """
        return pulumi.get(self, "pdb_name")

    @pdb_name.setter
    def pdb_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pdb_name", value)

    @property
    @pulumi.getter(name="pluggableDatabases")
    def pluggable_databases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of pluggable databases that needs to be restored into new database.
        """
        return pulumi.get(self, "pluggable_databases")

    @pluggable_databases.setter
    def pluggable_databases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "pluggable_databases", value)

    @property
    @pulumi.getter(name="sidPrefix")
    def sid_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a prefix for the `Oracle SID` of the database to be created.
        """
        return pulumi.get(self, "sid_prefix")

    @sid_prefix.setter
    def sid_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sid_prefix", value)

    @property
    @pulumi.getter(name="tdeWalletPassword")
    def tde_wallet_password(self) -> Optional[pulumi.Input[str]]:
        """
        The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \\#, or -.
        """
        return pulumi.get(self, "tde_wallet_password")

    @tde_wallet_password.setter
    def tde_wallet_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tde_wallet_password", value)

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")

    @vault_id.setter
    def vault_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vault_id", value)


@pulumi.input_type
class DatabaseDatabaseDbBackupConfigArgs:
    def __init__(__self__, *,
                 auto_backup_enabled: Optional[pulumi.Input[bool]] = None,
                 auto_backup_window: Optional[pulumi.Input[str]] = None,
                 auto_full_backup_day: Optional[pulumi.Input[str]] = None,
                 auto_full_backup_window: Optional[pulumi.Input[str]] = None,
                 backup_deletion_policy: Optional[pulumi.Input[str]] = None,
                 backup_destination_details: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDatabaseDbBackupConfigBackupDestinationDetailArgs']]]] = None,
                 recovery_window_in_days: Optional[pulumi.Input[int]] = None,
                 run_immediate_full_backup: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] auto_backup_enabled: (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param pulumi.Input[str] auto_backup_window: (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param pulumi.Input[str] auto_full_backup_day: Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        :param pulumi.Input[str] auto_full_backup_window: Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param pulumi.Input[str] backup_deletion_policy: This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseDatabaseDbBackupConfigBackupDestinationDetailArgs']]] backup_destination_details: Backup destination details.
        :param pulumi.Input[int] recovery_window_in_days: (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        :param pulumi.Input[bool] run_immediate_full_backup: If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        if auto_backup_enabled is not None:
            pulumi.set(__self__, "auto_backup_enabled", auto_backup_enabled)
        if auto_backup_window is not None:
            pulumi.set(__self__, "auto_backup_window", auto_backup_window)
        if auto_full_backup_day is not None:
            pulumi.set(__self__, "auto_full_backup_day", auto_full_backup_day)
        if auto_full_backup_window is not None:
            pulumi.set(__self__, "auto_full_backup_window", auto_full_backup_window)
        if backup_deletion_policy is not None:
            pulumi.set(__self__, "backup_deletion_policy", backup_deletion_policy)
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)
        if run_immediate_full_backup is not None:
            pulumi.set(__self__, "run_immediate_full_backup", run_immediate_full_backup)

    @property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @auto_backup_enabled.setter
    def auto_backup_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_backup_enabled", value)

    @property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @auto_backup_window.setter
    def auto_backup_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_backup_window", value)

    @property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> Optional[pulumi.Input[str]]:
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        return pulumi.get(self, "auto_full_backup_day")

    @auto_full_backup_day.setter
    def auto_full_backup_day(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_full_backup_day", value)

    @property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> Optional[pulumi.Input[str]]:
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_full_backup_window")

    @auto_full_backup_window.setter
    def auto_full_backup_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_full_backup_window", value)

    @property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> Optional[pulumi.Input[str]]:
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        return pulumi.get(self, "backup_deletion_policy")

    @backup_deletion_policy.setter
    def backup_deletion_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_deletion_policy", value)

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDatabaseDbBackupConfigBackupDestinationDetailArgs']]]]:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @backup_destination_details.setter
    def backup_destination_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDatabaseDbBackupConfigBackupDestinationDetailArgs']]]]):
        pulumi.set(self, "backup_destination_details", value)

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @recovery_window_in_days.setter
    def recovery_window_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "recovery_window_in_days", value)

    @property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        return pulumi.get(self, "run_immediate_full_backup")

    @run_immediate_full_backup.setter
    def run_immediate_full_backup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_immediate_full_backup", value)


@pulumi.input_type
class DatabaseDatabaseDbBackupConfigBackupDestinationDetailArgs:
    def __init__(__self__, *,
                 dbrs_policy_id: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 vpc_user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param pulumi.Input[str] type: Type of the database backup destination.
        """
        if dbrs_policy_id is not None:
            pulumi.set(__self__, "dbrs_policy_id", dbrs_policy_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vpc_user is not None:
            pulumi.set(__self__, "vpc_user", vpc_user)

    @property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @dbrs_policy_id.setter
    def dbrs_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dbrs_policy_id", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vpc_user")

    @vpc_user.setter
    def vpc_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_user", value)


@pulumi.input_type
class DatabaseDatabaseManagementConfigArgs:
    def __init__(__self__, *,
                 management_status: Optional[pulumi.Input[str]] = None,
                 management_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] management_status: The status of the Database Management service.
        :param pulumi.Input[str] management_type: The Database Management type.
        """
        if management_status is not None:
            pulumi.set(__self__, "management_status", management_status)
        if management_type is not None:
            pulumi.set(__self__, "management_type", management_type)

    @property
    @pulumi.getter(name="managementStatus")
    def management_status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "management_status")

    @management_status.setter
    def management_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "management_status", value)

    @property
    @pulumi.getter(name="managementType")
    def management_type(self) -> Optional[pulumi.Input[str]]:
        """
        The Database Management type.
        """
        return pulumi.get(self, "management_type")

    @management_type.setter
    def management_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "management_type", value)


@pulumi.input_type
class DatabaseDbBackupConfigArgs:
    def __init__(__self__, *,
                 auto_backup_enabled: Optional[pulumi.Input[bool]] = None,
                 auto_backup_window: Optional[pulumi.Input[str]] = None,
                 auto_full_backup_day: Optional[pulumi.Input[str]] = None,
                 auto_full_backup_window: Optional[pulumi.Input[str]] = None,
                 backup_deletion_policy: Optional[pulumi.Input[str]] = None,
                 backup_destination_details: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbBackupConfigBackupDestinationDetailArgs']]]] = None,
                 recovery_window_in_days: Optional[pulumi.Input[int]] = None,
                 run_immediate_full_backup: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] auto_backup_enabled: (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param pulumi.Input[str] auto_backup_window: (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param pulumi.Input[str] auto_full_backup_day: Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        :param pulumi.Input[str] auto_full_backup_window: Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param pulumi.Input[str] backup_deletion_policy: This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseDbBackupConfigBackupDestinationDetailArgs']]] backup_destination_details: Backup destination details.
        :param pulumi.Input[int] recovery_window_in_days: (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        :param pulumi.Input[bool] run_immediate_full_backup: If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        if auto_backup_enabled is not None:
            pulumi.set(__self__, "auto_backup_enabled", auto_backup_enabled)
        if auto_backup_window is not None:
            pulumi.set(__self__, "auto_backup_window", auto_backup_window)
        if auto_full_backup_day is not None:
            pulumi.set(__self__, "auto_full_backup_day", auto_full_backup_day)
        if auto_full_backup_window is not None:
            pulumi.set(__self__, "auto_full_backup_window", auto_full_backup_window)
        if backup_deletion_policy is not None:
            pulumi.set(__self__, "backup_deletion_policy", backup_deletion_policy)
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)
        if run_immediate_full_backup is not None:
            pulumi.set(__self__, "run_immediate_full_backup", run_immediate_full_backup)

    @property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @auto_backup_enabled.setter
    def auto_backup_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_backup_enabled", value)

    @property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @auto_backup_window.setter
    def auto_backup_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_backup_window", value)

    @property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> Optional[pulumi.Input[str]]:
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        return pulumi.get(self, "auto_full_backup_day")

    @auto_full_backup_day.setter
    def auto_full_backup_day(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_full_backup_day", value)

    @property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> Optional[pulumi.Input[str]]:
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_full_backup_window")

    @auto_full_backup_window.setter
    def auto_full_backup_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_full_backup_window", value)

    @property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> Optional[pulumi.Input[str]]:
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        return pulumi.get(self, "backup_deletion_policy")

    @backup_deletion_policy.setter
    def backup_deletion_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_deletion_policy", value)

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbBackupConfigBackupDestinationDetailArgs']]]]:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @backup_destination_details.setter
    def backup_destination_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbBackupConfigBackupDestinationDetailArgs']]]]):
        pulumi.set(self, "backup_destination_details", value)

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @recovery_window_in_days.setter
    def recovery_window_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "recovery_window_in_days", value)

    @property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        return pulumi.get(self, "run_immediate_full_backup")

    @run_immediate_full_backup.setter
    def run_immediate_full_backup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_immediate_full_backup", value)


@pulumi.input_type
class DatabaseDbBackupConfigBackupDestinationDetailArgs:
    def __init__(__self__, *,
                 dbrs_policy_id: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 vpc_user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param pulumi.Input[str] type: Type of the database backup destination.
        """
        if dbrs_policy_id is not None:
            pulumi.set(__self__, "dbrs_policy_id", dbrs_policy_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vpc_user is not None:
            pulumi.set(__self__, "vpc_user", vpc_user)

    @property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @dbrs_policy_id.setter
    def dbrs_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dbrs_policy_id", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vpc_user")

    @vpc_user.setter
    def vpc_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_user", value)


@pulumi.input_type
class DatabaseUpgradeConnectionStringArgs:
    def __init__(__self__, *,
                 all_connection_strings: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 cdb_default: Optional[pulumi.Input[str]] = None,
                 cdb_ip_default: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, Any]] all_connection_strings: All connection strings to use to connect to the Database.
        :param pulumi.Input[str] cdb_default: Host name based CDB Connection String.
        :param pulumi.Input[str] cdb_ip_default: IP based CDB Connection String.
        """
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if cdb_default is not None:
            pulumi.set(__self__, "cdb_default", cdb_default)
        if cdb_ip_default is not None:
            pulumi.set(__self__, "cdb_ip_default", cdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        All connection strings to use to connect to the Database.
        """
        return pulumi.get(self, "all_connection_strings")

    @all_connection_strings.setter
    def all_connection_strings(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "all_connection_strings", value)

    @property
    @pulumi.getter(name="cdbDefault")
    def cdb_default(self) -> Optional[pulumi.Input[str]]:
        """
        Host name based CDB Connection String.
        """
        return pulumi.get(self, "cdb_default")

    @cdb_default.setter
    def cdb_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cdb_default", value)

    @property
    @pulumi.getter(name="cdbIpDefault")
    def cdb_ip_default(self) -> Optional[pulumi.Input[str]]:
        """
        IP based CDB Connection String.
        """
        return pulumi.get(self, "cdb_ip_default")

    @cdb_ip_default.setter
    def cdb_ip_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cdb_ip_default", value)


@pulumi.input_type
class DatabaseUpgradeDatabaseUpgradeSourceDetailsArgs:
    def __init__(__self__, *,
                 database_software_image_id: Optional[pulumi.Input[str]] = None,
                 db_version: Optional[pulumi.Input[str]] = None,
                 options: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the image to be used to upgrade a database.
        :param pulumi.Input[str] db_version: A valid Oracle Database version. For a list of supported versions, use the ListDbVersions operation.
               
               This cannot be updated in parallel with any of the following: licenseModel, dbEdition, cpuCoreCount, computeCount, computeModel, adminPassword, whitelistedIps, isMTLSConnectionRequired, openMode, permissionLevel, dbWorkload, privateEndpointLabel, nsgIds, isRefreshable, dbName, scheduledOperations, dbToolsDetails, isLocalDataGuardEnabled, or isFreeTier.
        :param pulumi.Input[str] options: Additional upgrade options supported by DBUA(Database Upgrade Assistant). Example: "-upgradeTimezone false -keepEvents"
        :param pulumi.Input[str] source: The source of the Oracle Database software to be used for the upgrade.
               * Use `DB_VERSION` to specify a generally-available Oracle Database software version to upgrade the database.
               * Use `DB_SOFTWARE_IMAGE` to specify a [database software image](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/databasesoftwareimage.htm) to upgrade the database.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        if database_software_image_id is not None:
            pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        if db_version is not None:
            pulumi.set(__self__, "db_version", db_version)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> Optional[pulumi.Input[str]]:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the image to be used to upgrade a database.
        """
        return pulumi.get(self, "database_software_image_id")

    @database_software_image_id.setter
    def database_software_image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_software_image_id", value)

    @property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> Optional[pulumi.Input[str]]:
        """
        A valid Oracle Database version. For a list of supported versions, use the ListDbVersions operation.

        This cannot be updated in parallel with any of the following: licenseModel, dbEdition, cpuCoreCount, computeCount, computeModel, adminPassword, whitelistedIps, isMTLSConnectionRequired, openMode, permissionLevel, dbWorkload, privateEndpointLabel, nsgIds, isRefreshable, dbName, scheduledOperations, dbToolsDetails, isLocalDataGuardEnabled, or isFreeTier.
        """
        return pulumi.get(self, "db_version")

    @db_version.setter
    def db_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_version", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[str]]:
        """
        Additional upgrade options supported by DBUA(Database Upgrade Assistant). Example: "-upgradeTimezone false -keepEvents"
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The source of the Oracle Database software to be used for the upgrade.
        * Use `DB_VERSION` to specify a generally-available Oracle Database software version to upgrade the database.
        * Use `DB_SOFTWARE_IMAGE` to specify a [database software image](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/databasesoftwareimage.htm) to upgrade the database.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)


@pulumi.input_type
class DatabaseUpgradeDbBackupConfigArgs:
    def __init__(__self__, *,
                 auto_backup_enabled: Optional[pulumi.Input[bool]] = None,
                 auto_backup_window: Optional[pulumi.Input[str]] = None,
                 auto_full_backup_day: Optional[pulumi.Input[str]] = None,
                 auto_full_backup_window: Optional[pulumi.Input[str]] = None,
                 backup_deletion_policy: Optional[pulumi.Input[str]] = None,
                 backup_destination_details: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseUpgradeDbBackupConfigBackupDestinationDetailArgs']]]] = None,
                 recovery_window_in_days: Optional[pulumi.Input[int]] = None,
                 run_immediate_full_backup: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] auto_backup_enabled: If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param pulumi.Input[str] auto_backup_window: Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param pulumi.Input[str] auto_full_backup_day: Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        :param pulumi.Input[str] auto_full_backup_window: Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param pulumi.Input[str] backup_deletion_policy: This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseUpgradeDbBackupConfigBackupDestinationDetailArgs']]] backup_destination_details: Backup destination details.
        :param pulumi.Input[int] recovery_window_in_days: Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        :param pulumi.Input[bool] run_immediate_full_backup: If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        if auto_backup_enabled is not None:
            pulumi.set(__self__, "auto_backup_enabled", auto_backup_enabled)
        if auto_backup_window is not None:
            pulumi.set(__self__, "auto_backup_window", auto_backup_window)
        if auto_full_backup_day is not None:
            pulumi.set(__self__, "auto_full_backup_day", auto_full_backup_day)
        if auto_full_backup_window is not None:
            pulumi.set(__self__, "auto_full_backup_window", auto_full_backup_window)
        if backup_deletion_policy is not None:
            pulumi.set(__self__, "backup_deletion_policy", backup_deletion_policy)
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)
        if run_immediate_full_backup is not None:
            pulumi.set(__self__, "run_immediate_full_backup", run_immediate_full_backup)

    @property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @auto_backup_enabled.setter
    def auto_backup_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_backup_enabled", value)

    @property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> Optional[pulumi.Input[str]]:
        """
        Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @auto_backup_window.setter
    def auto_backup_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_backup_window", value)

    @property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> Optional[pulumi.Input[str]]:
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        return pulumi.get(self, "auto_full_backup_day")

    @auto_full_backup_day.setter
    def auto_full_backup_day(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_full_backup_day", value)

    @property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> Optional[pulumi.Input[str]]:
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_full_backup_window")

    @auto_full_backup_window.setter
    def auto_full_backup_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_full_backup_window", value)

    @property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> Optional[pulumi.Input[str]]:
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        return pulumi.get(self, "backup_deletion_policy")

    @backup_deletion_policy.setter
    def backup_deletion_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_deletion_policy", value)

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseUpgradeDbBackupConfigBackupDestinationDetailArgs']]]]:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @backup_destination_details.setter
    def backup_destination_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseUpgradeDbBackupConfigBackupDestinationDetailArgs']]]]):
        pulumi.set(self, "backup_destination_details", value)

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @recovery_window_in_days.setter
    def recovery_window_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "recovery_window_in_days", value)

    @property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        return pulumi.get(self, "run_immediate_full_backup")

    @run_immediate_full_backup.setter
    def run_immediate_full_backup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_immediate_full_backup", value)


@pulumi.input_type
class DatabaseUpgradeDbBackupConfigBackupDestinationDetailArgs:
    def __init__(__self__, *,
                 dbrs_policy_id: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 internet_proxy: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 vpc_password: Optional[pulumi.Input[str]] = None,
                 vpc_user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        :param pulumi.Input[str] internet_proxy: Proxy URL to connect to object store.
        :param pulumi.Input[str] type: Type of the database backup destination.
        :param pulumi.Input[str] vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param pulumi.Input[str] vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        if dbrs_policy_id is not None:
            pulumi.set(__self__, "dbrs_policy_id", dbrs_policy_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if internet_proxy is not None:
            pulumi.set(__self__, "internet_proxy", internet_proxy)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vpc_password is not None:
            pulumi.set(__self__, "vpc_password", vpc_password)
        if vpc_user is not None:
            pulumi.set(__self__, "vpc_user", vpc_user)

    @property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @dbrs_policy_id.setter
    def dbrs_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dbrs_policy_id", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @internet_proxy.setter
    def internet_proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "internet_proxy", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> Optional[pulumi.Input[str]]:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @vpc_password.setter
    def vpc_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_password", value)

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[pulumi.Input[str]]:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")

    @vpc_user.setter
    def vpc_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_user", value)


@pulumi.input_type
class DbHomeDatabaseArgs:
    def __init__(__self__, *,
                 admin_password: pulumi.Input[str],
                 backup_id: Optional[pulumi.Input[str]] = None,
                 backup_tde_password: Optional[pulumi.Input[str]] = None,
                 character_set: Optional[pulumi.Input[str]] = None,
                 connection_strings: Optional[pulumi.Input[Sequence[pulumi.Input['DbHomeDatabaseConnectionStringArgs']]]] = None,
                 database_id: Optional[pulumi.Input[str]] = None,
                 database_software_image_id: Optional[pulumi.Input[str]] = None,
                 db_backup_config: Optional[pulumi.Input['DbHomeDatabaseDbBackupConfigArgs']] = None,
                 db_name: Optional[pulumi.Input[str]] = None,
                 db_unique_name: Optional[pulumi.Input[str]] = None,
                 db_workload: Optional[pulumi.Input[str]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 kms_key_version_id: Optional[pulumi.Input[str]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 ncharacter_set: Optional[pulumi.Input[str]] = None,
                 one_off_patches: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 pdb_name: Optional[pulumi.Input[str]] = None,
                 pluggable_databases: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sid_prefix: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 tde_wallet_password: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_stamp_for_point_in_time_recovery: Optional[pulumi.Input[str]] = None,
                 vault_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] admin_password: A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \\#, or -.
        :param pulumi.Input[str] backup_id: The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input[str] backup_tde_password: The password to open the TDE wallet.
        :param pulumi.Input[str] character_set: The character set for the database.  The default is AL32UTF8. Allowed values are:
               
               AL32UTF8, AR8ADOS710, AR8ADOS720, AR8APTEC715, AR8ARABICMACS, AR8ASMO8X, AR8ISO8859P6, AR8MSWIN1256, AR8MUSSAD768, AR8NAFITHA711, AR8NAFITHA721, AR8SAKHR706, AR8SAKHR707, AZ8ISO8859P9E, BG8MSWIN, BG8PC437S, BLT8CP921, BLT8ISO8859P13, BLT8MSWIN1257, BLT8PC775, BN8BSCII, CDN8PC863, CEL8ISO8859P14, CL8ISO8859P5, CL8ISOIR111, CL8KOI8R, CL8KOI8U, CL8MACCYRILLICS, CL8MSWIN1251, EE8ISO8859P2, EE8MACCES, EE8MACCROATIANS, EE8MSWIN1250, EE8PC852, EL8DEC, EL8ISO8859P7, EL8MACGREEKS, EL8MSWIN1253, EL8PC437S, EL8PC851, EL8PC869, ET8MSWIN923, HU8ABMOD, HU8CWI2, IN8ISCII, IS8PC861, IW8ISO8859P8, IW8MACHEBREWS, IW8MSWIN1255, IW8PC1507, JA16EUC, JA16EUCTILDE, JA16SJIS, JA16SJISTILDE, JA16VMS, KO16KSC5601, KO16KSCCS, KO16MSWIN949, LA8ISO6937, LA8PASSPORT, LT8MSWIN921, LT8PC772, LT8PC774, LV8PC1117, LV8PC8LR, LV8RST104090, N8PC865, NE8ISO8859P10, NEE8ISO8859P4, RU8BESTA, RU8PC855, RU8PC866, SE8ISO8859P3, TH8MACTHAIS, TH8TISASCII, TR8DEC, TR8MACTURKISHS, TR8MSWIN1254, TR8PC857, US7ASCII, US8PC437, UTF8, VN8MSWIN1258, VN8VN3, WE8DEC, WE8DG, WE8ISO8859P1, WE8ISO8859P15, WE8ISO8859P9, WE8MACROMAN8S, WE8MSWIN1252, WE8NCR4970, WE8NEXTSTEP, WE8PC850, WE8PC858, WE8PC860, WE8ROMAN8, ZHS16CGB231280, ZHS16GBK, ZHT16BIG5, ZHT16CCDC, ZHT16DBT, ZHT16HKSCS, ZHT16MSWIN950, ZHT32EUC, ZHT32SOPS, ZHT32TRIS
        :param pulumi.Input[str] database_id: The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input[str] database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        :param pulumi.Input['DbHomeDatabaseDbBackupConfigArgs'] db_backup_config: (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        :param pulumi.Input[str] db_name: The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        :param pulumi.Input[str] db_workload: **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.
               
               The database workload type.
        :param pulumi.Input[Mapping[str, Any]] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param pulumi.Input[Mapping[str, Any]] freeform_tags: (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param pulumi.Input[str] kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param pulumi.Input[str] kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        :param pulumi.Input[str] lifecycle_details: Additional information about the current lifecycle state.
        :param pulumi.Input[str] ncharacter_set: The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] one_off_patches: List of one-off patches for Database Homes.
        :param pulumi.Input[str] pdb_name: The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pluggable_databases: The list of pluggable databases that needs to be restored into new database.
        :param pulumi.Input[str] sid_prefix: Specifies a prefix for the `Oracle SID` of the database to be created.
        :param pulumi.Input[str] state: The current state of the Database Home.
        :param pulumi.Input[str] tde_wallet_password: The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \\#, or -.
        :param pulumi.Input[str] time_created: The date and time the Database Home was created.
        :param pulumi.Input[str] time_stamp_for_point_in_time_recovery: The point in time of the original database from which the new database is created. If not specifed, the latest backup is used to create the database.
        :param pulumi.Input[str] vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        pulumi.set(__self__, "admin_password", admin_password)
        if backup_id is not None:
            pulumi.set(__self__, "backup_id", backup_id)
        if backup_tde_password is not None:
            pulumi.set(__self__, "backup_tde_password", backup_tde_password)
        if character_set is not None:
            pulumi.set(__self__, "character_set", character_set)
        if connection_strings is not None:
            pulumi.set(__self__, "connection_strings", connection_strings)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if database_software_image_id is not None:
            pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        if db_backup_config is not None:
            pulumi.set(__self__, "db_backup_config", db_backup_config)
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if db_unique_name is not None:
            pulumi.set(__self__, "db_unique_name", db_unique_name)
        if db_workload is not None:
            pulumi.set(__self__, "db_workload", db_workload)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if kms_key_version_id is not None:
            pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if ncharacter_set is not None:
            pulumi.set(__self__, "ncharacter_set", ncharacter_set)
        if one_off_patches is not None:
            pulumi.set(__self__, "one_off_patches", one_off_patches)
        if pdb_name is not None:
            pulumi.set(__self__, "pdb_name", pdb_name)
        if pluggable_databases is not None:
            pulumi.set(__self__, "pluggable_databases", pluggable_databases)
        if sid_prefix is not None:
            pulumi.set(__self__, "sid_prefix", sid_prefix)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if tde_wallet_password is not None:
            pulumi.set(__self__, "tde_wallet_password", tde_wallet_password)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_stamp_for_point_in_time_recovery is not None:
            pulumi.set(__self__, "time_stamp_for_point_in_time_recovery", time_stamp_for_point_in_time_recovery)
        if vault_id is not None:
            pulumi.set(__self__, "vault_id", vault_id)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> pulumi.Input[str]:
        """
        A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \\#, or -.
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> Optional[pulumi.Input[str]]:
        """
        The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "backup_id")

    @backup_id.setter
    def backup_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_id", value)

    @property
    @pulumi.getter(name="backupTdePassword")
    def backup_tde_password(self) -> Optional[pulumi.Input[str]]:
        """
        The password to open the TDE wallet.
        """
        return pulumi.get(self, "backup_tde_password")

    @backup_tde_password.setter
    def backup_tde_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_tde_password", value)

    @property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> Optional[pulumi.Input[str]]:
        """
        The character set for the database.  The default is AL32UTF8. Allowed values are:

        AL32UTF8, AR8ADOS710, AR8ADOS720, AR8APTEC715, AR8ARABICMACS, AR8ASMO8X, AR8ISO8859P6, AR8MSWIN1256, AR8MUSSAD768, AR8NAFITHA711, AR8NAFITHA721, AR8SAKHR706, AR8SAKHR707, AZ8ISO8859P9E, BG8MSWIN, BG8PC437S, BLT8CP921, BLT8ISO8859P13, BLT8MSWIN1257, BLT8PC775, BN8BSCII, CDN8PC863, CEL8ISO8859P14, CL8ISO8859P5, CL8ISOIR111, CL8KOI8R, CL8KOI8U, CL8MACCYRILLICS, CL8MSWIN1251, EE8ISO8859P2, EE8MACCES, EE8MACCROATIANS, EE8MSWIN1250, EE8PC852, EL8DEC, EL8ISO8859P7, EL8MACGREEKS, EL8MSWIN1253, EL8PC437S, EL8PC851, EL8PC869, ET8MSWIN923, HU8ABMOD, HU8CWI2, IN8ISCII, IS8PC861, IW8ISO8859P8, IW8MACHEBREWS, IW8MSWIN1255, IW8PC1507, JA16EUC, JA16EUCTILDE, JA16SJIS, JA16SJISTILDE, JA16VMS, KO16KSC5601, KO16KSCCS, KO16MSWIN949, LA8ISO6937, LA8PASSPORT, LT8MSWIN921, LT8PC772, LT8PC774, LV8PC1117, LV8PC8LR, LV8RST104090, N8PC865, NE8ISO8859P10, NEE8ISO8859P4, RU8BESTA, RU8PC855, RU8PC866, SE8ISO8859P3, TH8MACTHAIS, TH8TISASCII, TR8DEC, TR8MACTURKISHS, TR8MSWIN1254, TR8PC857, US7ASCII, US8PC437, UTF8, VN8MSWIN1258, VN8VN3, WE8DEC, WE8DG, WE8ISO8859P1, WE8ISO8859P15, WE8ISO8859P9, WE8MACROMAN8S, WE8MSWIN1252, WE8NCR4970, WE8NEXTSTEP, WE8PC850, WE8PC858, WE8PC860, WE8ROMAN8, ZHS16CGB231280, ZHS16GBK, ZHT16BIG5, ZHT16CCDC, ZHT16DBT, ZHT16HKSCS, ZHT16MSWIN950, ZHT32EUC, ZHT32SOPS, ZHT32TRIS
        """
        return pulumi.get(self, "character_set")

    @character_set.setter
    def character_set(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "character_set", value)

    @property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DbHomeDatabaseConnectionStringArgs']]]]:
        return pulumi.get(self, "connection_strings")

    @connection_strings.setter
    def connection_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DbHomeDatabaseConnectionStringArgs']]]]):
        pulumi.set(self, "connection_strings", value)

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[pulumi.Input[str]]:
        """
        The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "database_id")

    @database_id.setter
    def database_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_id", value)

    @property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> Optional[pulumi.Input[str]]:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        return pulumi.get(self, "database_software_image_id")

    @database_software_image_id.setter
    def database_software_image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_software_image_id", value)

    @property
    @pulumi.getter(name="dbBackupConfig")
    def db_backup_config(self) -> Optional[pulumi.Input['DbHomeDatabaseDbBackupConfigArgs']]:
        """
        (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        """
        return pulumi.get(self, "db_backup_config")

    @db_backup_config.setter
    def db_backup_config(self, value: Optional[pulumi.Input['DbHomeDatabaseDbBackupConfigArgs']]):
        pulumi.set(self, "db_backup_config", value)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[pulumi.Input[str]]:
        """
        The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "db_unique_name")

    @db_unique_name.setter
    def db_unique_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_unique_name", value)

    @property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> Optional[pulumi.Input[str]]:
        """
        **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.

        The database workload type.
        """
        return pulumi.get(self, "db_workload")

    @db_workload.setter
    def db_workload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_workload", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        """
        return pulumi.get(self, "kms_key_version_id")

    @kms_key_version_id.setter
    def kms_key_version_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_version_id", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> Optional[pulumi.Input[str]]:
        """
        The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        """
        return pulumi.get(self, "ncharacter_set")

    @ncharacter_set.setter
    def ncharacter_set(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ncharacter_set", value)

    @property
    @pulumi.getter(name="oneOffPatches")
    def one_off_patches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of one-off patches for Database Homes.
        """
        return pulumi.get(self, "one_off_patches")

    @one_off_patches.setter
    def one_off_patches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "one_off_patches", value)

    @property
    @pulumi.getter(name="pdbName")
    def pdb_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        """
        return pulumi.get(self, "pdb_name")

    @pdb_name.setter
    def pdb_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pdb_name", value)

    @property
    @pulumi.getter(name="pluggableDatabases")
    def pluggable_databases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of pluggable databases that needs to be restored into new database.
        """
        return pulumi.get(self, "pluggable_databases")

    @pluggable_databases.setter
    def pluggable_databases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "pluggable_databases", value)

    @property
    @pulumi.getter(name="sidPrefix")
    def sid_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a prefix for the `Oracle SID` of the database to be created.
        """
        return pulumi.get(self, "sid_prefix")

    @sid_prefix.setter
    def sid_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sid_prefix", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the Database Home.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="tdeWalletPassword")
    def tde_wallet_password(self) -> Optional[pulumi.Input[str]]:
        """
        The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \\#, or -.
        """
        return pulumi.get(self, "tde_wallet_password")

    @tde_wallet_password.setter
    def tde_wallet_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tde_wallet_password", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the Database Home was created.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeStampForPointInTimeRecovery")
    def time_stamp_for_point_in_time_recovery(self) -> Optional[pulumi.Input[str]]:
        """
        The point in time of the original database from which the new database is created. If not specifed, the latest backup is used to create the database.
        """
        return pulumi.get(self, "time_stamp_for_point_in_time_recovery")

    @time_stamp_for_point_in_time_recovery.setter
    def time_stamp_for_point_in_time_recovery(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_stamp_for_point_in_time_recovery", value)

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")

    @vault_id.setter
    def vault_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vault_id", value)


@pulumi.input_type
class DbHomeDatabaseConnectionStringArgs:
    def __init__(__self__, *,
                 all_connection_strings: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 cdb_default: Optional[pulumi.Input[str]] = None,
                 cdb_ip_default: Optional[pulumi.Input[str]] = None):
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if cdb_default is not None:
            pulumi.set(__self__, "cdb_default", cdb_default)
        if cdb_ip_default is not None:
            pulumi.set(__self__, "cdb_ip_default", cdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "all_connection_strings")

    @all_connection_strings.setter
    def all_connection_strings(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "all_connection_strings", value)

    @property
    @pulumi.getter(name="cdbDefault")
    def cdb_default(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cdb_default")

    @cdb_default.setter
    def cdb_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cdb_default", value)

    @property
    @pulumi.getter(name="cdbIpDefault")
    def cdb_ip_default(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cdb_ip_default")

    @cdb_ip_default.setter
    def cdb_ip_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cdb_ip_default", value)


@pulumi.input_type
class DbHomeDatabaseDbBackupConfigArgs:
    def __init__(__self__, *,
                 auto_backup_enabled: Optional[pulumi.Input[bool]] = None,
                 auto_backup_window: Optional[pulumi.Input[str]] = None,
                 auto_full_backup_day: Optional[pulumi.Input[str]] = None,
                 auto_full_backup_window: Optional[pulumi.Input[str]] = None,
                 backup_deletion_policy: Optional[pulumi.Input[str]] = None,
                 backup_destination_details: Optional[pulumi.Input[Sequence[pulumi.Input['DbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs']]]] = None,
                 recovery_window_in_days: Optional[pulumi.Input[int]] = None,
                 run_immediate_full_backup: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] auto_backup_enabled: (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param pulumi.Input[str] auto_backup_window: (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param pulumi.Input[str] auto_full_backup_day: Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        :param pulumi.Input[str] auto_full_backup_window: Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param pulumi.Input[str] backup_deletion_policy: This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        :param pulumi.Input[Sequence[pulumi.Input['DbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs']]] backup_destination_details: Backup destination details.
        :param pulumi.Input[int] recovery_window_in_days: (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        :param pulumi.Input[bool] run_immediate_full_backup: If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        if auto_backup_enabled is not None:
            pulumi.set(__self__, "auto_backup_enabled", auto_backup_enabled)
        if auto_backup_window is not None:
            pulumi.set(__self__, "auto_backup_window", auto_backup_window)
        if auto_full_backup_day is not None:
            pulumi.set(__self__, "auto_full_backup_day", auto_full_backup_day)
        if auto_full_backup_window is not None:
            pulumi.set(__self__, "auto_full_backup_window", auto_full_backup_window)
        if backup_deletion_policy is not None:
            pulumi.set(__self__, "backup_deletion_policy", backup_deletion_policy)
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)
        if run_immediate_full_backup is not None:
            pulumi.set(__self__, "run_immediate_full_backup", run_immediate_full_backup)

    @property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @auto_backup_enabled.setter
    def auto_backup_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_backup_enabled", value)

    @property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @auto_backup_window.setter
    def auto_backup_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_backup_window", value)

    @property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> Optional[pulumi.Input[str]]:
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        return pulumi.get(self, "auto_full_backup_day")

    @auto_full_backup_day.setter
    def auto_full_backup_day(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_full_backup_day", value)

    @property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> Optional[pulumi.Input[str]]:
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_full_backup_window")

    @auto_full_backup_window.setter
    def auto_full_backup_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_full_backup_window", value)

    @property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> Optional[pulumi.Input[str]]:
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        return pulumi.get(self, "backup_deletion_policy")

    @backup_deletion_policy.setter
    def backup_deletion_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_deletion_policy", value)

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs']]]]:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @backup_destination_details.setter
    def backup_destination_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs']]]]):
        pulumi.set(self, "backup_destination_details", value)

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @recovery_window_in_days.setter
    def recovery_window_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "recovery_window_in_days", value)

    @property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        return pulumi.get(self, "run_immediate_full_backup")

    @run_immediate_full_backup.setter
    def run_immediate_full_backup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_immediate_full_backup", value)


@pulumi.input_type
class DbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs:
    def __init__(__self__, *,
                 dbrs_policy_id: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param pulumi.Input[str] type: Type of the database backup destination. Supported values: `NFS`.
        """
        if dbrs_policy_id is not None:
            pulumi.set(__self__, "dbrs_policy_id", dbrs_policy_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @dbrs_policy_id.setter
    def dbrs_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dbrs_policy_id", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the database backup destination. Supported values: `NFS`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class DbSystemDataCollectionOptionsArgs:
    def __init__(__self__, *,
                 is_diagnostics_events_enabled: Optional[pulumi.Input[bool]] = None,
                 is_health_monitoring_enabled: Optional[pulumi.Input[bool]] = None,
                 is_incident_logs_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_diagnostics_events_enabled: (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param pulumi.Input[bool] is_health_monitoring_enabled: (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param pulumi.Input[bool] is_incident_logs_enabled: (Updatable) Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        if is_diagnostics_events_enabled is not None:
            pulumi.set(__self__, "is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        if is_health_monitoring_enabled is not None:
            pulumi.set(__self__, "is_health_monitoring_enabled", is_health_monitoring_enabled)
        if is_incident_logs_enabled is not None:
            pulumi.set(__self__, "is_incident_logs_enabled", is_incident_logs_enabled)

    @property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @is_diagnostics_events_enabled.setter
    def is_diagnostics_events_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_diagnostics_events_enabled", value)

    @property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @is_health_monitoring_enabled.setter
    def is_health_monitoring_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_health_monitoring_enabled", value)

    @property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")

    @is_incident_logs_enabled.setter
    def is_incident_logs_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_incident_logs_enabled", value)


@pulumi.input_type
class DbSystemDbHomeArgs:
    def __init__(__self__, *,
                 database: pulumi.Input['DbSystemDbHomeDatabaseArgs'],
                 create_async: Optional[pulumi.Input[bool]] = None,
                 database_software_image_id: Optional[pulumi.Input[str]] = None,
                 db_home_location: Optional[pulumi.Input[str]] = None,
                 db_version: Optional[pulumi.Input[str]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 last_patch_history_entry_id: Optional[pulumi.Input[str]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DbSystemDbHomeDatabaseArgs'] database: (Updatable) Details for creating a database by restoring from a source database system.
               
               **Warning:** Oracle recommends that you avoid using any confidential information when you supply string values using the API.
        :param pulumi.Input[str] database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the image to be used to restore a database.
        :param pulumi.Input[str] db_version: A valid Oracle Database version. For a list of supported versions, use the ListDbVersions operation.
               
               This cannot be updated in parallel with any of the following: licenseModel, dbEdition, cpuCoreCount, computeCount, computeModel, adminPassword, whitelistedIps, isMTLSConnectionRequired, openMode, permissionLevel, dbWorkload, privateEndpointLabel, nsgIds, isRefreshable, dbName, scheduledOperations, dbToolsDetails, isLocalDataGuardEnabled, or isFreeTier.
        :param pulumi.Input[Mapping[str, Any]] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param pulumi.Input[str] display_name: The user-friendly name for the DB system. The name does not have to be unique.
        :param pulumi.Input[Mapping[str, Any]] freeform_tags: (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param pulumi.Input[str] last_patch_history_entry_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last patch history. This value is updated as soon as a patch operation starts.
        :param pulumi.Input[str] lifecycle_details: Additional information about the current lifecycle state.
        :param pulumi.Input[str] state: The current state of the DB system.
        :param pulumi.Input[str] time_created: The date and time the DB system was created.
        """
        pulumi.set(__self__, "database", database)
        if create_async is not None:
            pulumi.set(__self__, "create_async", create_async)
        if database_software_image_id is not None:
            pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        if db_home_location is not None:
            pulumi.set(__self__, "db_home_location", db_home_location)
        if db_version is not None:
            pulumi.set(__self__, "db_version", db_version)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if last_patch_history_entry_id is not None:
            pulumi.set(__self__, "last_patch_history_entry_id", last_patch_history_entry_id)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input['DbSystemDbHomeDatabaseArgs']:
        """
        (Updatable) Details for creating a database by restoring from a source database system.

        **Warning:** Oracle recommends that you avoid using any confidential information when you supply string values using the API.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input['DbSystemDbHomeDatabaseArgs']):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="createAsync")
    def create_async(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "create_async")

    @create_async.setter
    def create_async(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "create_async", value)

    @property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> Optional[pulumi.Input[str]]:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the image to be used to restore a database.
        """
        return pulumi.get(self, "database_software_image_id")

    @database_software_image_id.setter
    def database_software_image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_software_image_id", value)

    @property
    @pulumi.getter(name="dbHomeLocation")
    def db_home_location(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "db_home_location")

    @db_home_location.setter
    def db_home_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_home_location", value)

    @property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> Optional[pulumi.Input[str]]:
        """
        A valid Oracle Database version. For a list of supported versions, use the ListDbVersions operation.

        This cannot be updated in parallel with any of the following: licenseModel, dbEdition, cpuCoreCount, computeCount, computeModel, adminPassword, whitelistedIps, isMTLSConnectionRequired, openMode, permissionLevel, dbWorkload, privateEndpointLabel, nsgIds, isRefreshable, dbName, scheduledOperations, dbToolsDetails, isLocalDataGuardEnabled, or isFreeTier.
        """
        return pulumi.get(self, "db_version")

    @db_version.setter
    def db_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_version", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        The user-friendly name for the DB system. The name does not have to be unique.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="lastPatchHistoryEntryId")
    def last_patch_history_entry_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last patch history. This value is updated as soon as a patch operation starts.
        """
        return pulumi.get(self, "last_patch_history_entry_id")

    @last_patch_history_entry_id.setter
    def last_patch_history_entry_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_patch_history_entry_id", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the DB system.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the DB system was created.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)


@pulumi.input_type
class DbSystemDbHomeDatabaseArgs:
    def __init__(__self__, *,
                 admin_password: pulumi.Input[str],
                 backup_id: Optional[pulumi.Input[str]] = None,
                 backup_tde_password: Optional[pulumi.Input[str]] = None,
                 character_set: Optional[pulumi.Input[str]] = None,
                 connection_strings: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemDbHomeDatabaseConnectionStringArgs']]]] = None,
                 database_id: Optional[pulumi.Input[str]] = None,
                 database_software_image_id: Optional[pulumi.Input[str]] = None,
                 db_backup_config: Optional[pulumi.Input['DbSystemDbHomeDatabaseDbBackupConfigArgs']] = None,
                 db_domain: Optional[pulumi.Input[str]] = None,
                 db_name: Optional[pulumi.Input[str]] = None,
                 db_unique_name: Optional[pulumi.Input[str]] = None,
                 db_workload: Optional[pulumi.Input[str]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 kms_key_version_id: Optional[pulumi.Input[str]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 ncharacter_set: Optional[pulumi.Input[str]] = None,
                 pdb_name: Optional[pulumi.Input[str]] = None,
                 pluggable_databases: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 tde_wallet_password: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_stamp_for_point_in_time_recovery: Optional[pulumi.Input[str]] = None,
                 vault_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] admin_password: A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \\#, or -.
        :param pulumi.Input[str] backup_id: The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input[str] backup_tde_password: The password to open the TDE wallet.
        :param pulumi.Input[str] character_set: The character set for the database.  The default is AL32UTF8. Allowed values are:
               
               AL32UTF8, AR8ADOS710, AR8ADOS720, AR8APTEC715, AR8ARABICMACS, AR8ASMO8X, AR8ISO8859P6, AR8MSWIN1256, AR8MUSSAD768, AR8NAFITHA711, AR8NAFITHA721, AR8SAKHR706, AR8SAKHR707, AZ8ISO8859P9E, BG8MSWIN, BG8PC437S, BLT8CP921, BLT8ISO8859P13, BLT8MSWIN1257, BLT8PC775, BN8BSCII, CDN8PC863, CEL8ISO8859P14, CL8ISO8859P5, CL8ISOIR111, CL8KOI8R, CL8KOI8U, CL8MACCYRILLICS, CL8MSWIN1251, EE8ISO8859P2, EE8MACCES, EE8MACCROATIANS, EE8MSWIN1250, EE8PC852, EL8DEC, EL8ISO8859P7, EL8MACGREEKS, EL8MSWIN1253, EL8PC437S, EL8PC851, EL8PC869, ET8MSWIN923, HU8ABMOD, HU8CWI2, IN8ISCII, IS8PC861, IW8ISO8859P8, IW8MACHEBREWS, IW8MSWIN1255, IW8PC1507, JA16EUC, JA16EUCTILDE, JA16SJIS, JA16SJISTILDE, JA16VMS, KO16KSC5601, KO16KSCCS, KO16MSWIN949, LA8ISO6937, LA8PASSPORT, LT8MSWIN921, LT8PC772, LT8PC774, LV8PC1117, LV8PC8LR, LV8RST104090, N8PC865, NE8ISO8859P10, NEE8ISO8859P4, RU8BESTA, RU8PC855, RU8PC866, SE8ISO8859P3, TH8MACTHAIS, TH8TISASCII, TR8DEC, TR8MACTURKISHS, TR8MSWIN1254, TR8PC857, US7ASCII, US8PC437, UTF8, VN8MSWIN1258, VN8VN3, WE8DEC, WE8DG, WE8ISO8859P1, WE8ISO8859P15, WE8ISO8859P9, WE8MACROMAN8S, WE8MSWIN1252, WE8NCR4970, WE8NEXTSTEP, WE8PC850, WE8PC858, WE8PC860, WE8ROMAN8, ZHS16CGB231280, ZHS16GBK, ZHT16BIG5, ZHT16CCDC, ZHT16DBT, ZHT16HKSCS, ZHT16MSWIN950, ZHT32EUC, ZHT32SOPS, ZHT32TRIS
        :param pulumi.Input[str] database_id: The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input[str] database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the image to be used to restore a database.
        :param pulumi.Input['DbSystemDbHomeDatabaseDbBackupConfigArgs'] db_backup_config: (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        :param pulumi.Input[str] db_domain: The database domain. In a distributed database system, DB_DOMAIN specifies the logical location of the database within the network structure.
        :param pulumi.Input[str] db_name: The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        :param pulumi.Input[str] db_workload: **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.
               
               The database workload type.
        :param pulumi.Input[Mapping[str, Any]] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param pulumi.Input[Mapping[str, Any]] freeform_tags: (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param pulumi.Input[str] kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param pulumi.Input[str] kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        :param pulumi.Input[str] lifecycle_details: Additional information about the current lifecycle state.
        :param pulumi.Input[str] ncharacter_set: The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        :param pulumi.Input[str] pdb_name: The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pluggable_databases: The list of pluggable databases that needs to be restored into new database.
        :param pulumi.Input[str] state: The current state of the DB system.
        :param pulumi.Input[str] tde_wallet_password: The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \\#, or -.
        :param pulumi.Input[str] time_created: The date and time the DB system was created.
        :param pulumi.Input[str] time_stamp_for_point_in_time_recovery: The point in time of the original database from which the new database is created. If not specifed, the latest backup is used to create the database.
        :param pulumi.Input[str] vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        pulumi.set(__self__, "admin_password", admin_password)
        if backup_id is not None:
            pulumi.set(__self__, "backup_id", backup_id)
        if backup_tde_password is not None:
            pulumi.set(__self__, "backup_tde_password", backup_tde_password)
        if character_set is not None:
            pulumi.set(__self__, "character_set", character_set)
        if connection_strings is not None:
            pulumi.set(__self__, "connection_strings", connection_strings)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if database_software_image_id is not None:
            pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        if db_backup_config is not None:
            pulumi.set(__self__, "db_backup_config", db_backup_config)
        if db_domain is not None:
            pulumi.set(__self__, "db_domain", db_domain)
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if db_unique_name is not None:
            pulumi.set(__self__, "db_unique_name", db_unique_name)
        if db_workload is not None:
            pulumi.set(__self__, "db_workload", db_workload)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if kms_key_version_id is not None:
            pulumi.set(__self__, "kms_key_version_id", kms_key_version_id)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if ncharacter_set is not None:
            pulumi.set(__self__, "ncharacter_set", ncharacter_set)
        if pdb_name is not None:
            pulumi.set(__self__, "pdb_name", pdb_name)
        if pluggable_databases is not None:
            pulumi.set(__self__, "pluggable_databases", pluggable_databases)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if tde_wallet_password is not None:
            pulumi.set(__self__, "tde_wallet_password", tde_wallet_password)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_stamp_for_point_in_time_recovery is not None:
            pulumi.set(__self__, "time_stamp_for_point_in_time_recovery", time_stamp_for_point_in_time_recovery)
        if vault_id is not None:
            pulumi.set(__self__, "vault_id", vault_id)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> pulumi.Input[str]:
        """
        A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \\#, or -.
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> Optional[pulumi.Input[str]]:
        """
        The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "backup_id")

    @backup_id.setter
    def backup_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_id", value)

    @property
    @pulumi.getter(name="backupTdePassword")
    def backup_tde_password(self) -> Optional[pulumi.Input[str]]:
        """
        The password to open the TDE wallet.
        """
        return pulumi.get(self, "backup_tde_password")

    @backup_tde_password.setter
    def backup_tde_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_tde_password", value)

    @property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> Optional[pulumi.Input[str]]:
        """
        The character set for the database.  The default is AL32UTF8. Allowed values are:

        AL32UTF8, AR8ADOS710, AR8ADOS720, AR8APTEC715, AR8ARABICMACS, AR8ASMO8X, AR8ISO8859P6, AR8MSWIN1256, AR8MUSSAD768, AR8NAFITHA711, AR8NAFITHA721, AR8SAKHR706, AR8SAKHR707, AZ8ISO8859P9E, BG8MSWIN, BG8PC437S, BLT8CP921, BLT8ISO8859P13, BLT8MSWIN1257, BLT8PC775, BN8BSCII, CDN8PC863, CEL8ISO8859P14, CL8ISO8859P5, CL8ISOIR111, CL8KOI8R, CL8KOI8U, CL8MACCYRILLICS, CL8MSWIN1251, EE8ISO8859P2, EE8MACCES, EE8MACCROATIANS, EE8MSWIN1250, EE8PC852, EL8DEC, EL8ISO8859P7, EL8MACGREEKS, EL8MSWIN1253, EL8PC437S, EL8PC851, EL8PC869, ET8MSWIN923, HU8ABMOD, HU8CWI2, IN8ISCII, IS8PC861, IW8ISO8859P8, IW8MACHEBREWS, IW8MSWIN1255, IW8PC1507, JA16EUC, JA16EUCTILDE, JA16SJIS, JA16SJISTILDE, JA16VMS, KO16KSC5601, KO16KSCCS, KO16MSWIN949, LA8ISO6937, LA8PASSPORT, LT8MSWIN921, LT8PC772, LT8PC774, LV8PC1117, LV8PC8LR, LV8RST104090, N8PC865, NE8ISO8859P10, NEE8ISO8859P4, RU8BESTA, RU8PC855, RU8PC866, SE8ISO8859P3, TH8MACTHAIS, TH8TISASCII, TR8DEC, TR8MACTURKISHS, TR8MSWIN1254, TR8PC857, US7ASCII, US8PC437, UTF8, VN8MSWIN1258, VN8VN3, WE8DEC, WE8DG, WE8ISO8859P1, WE8ISO8859P15, WE8ISO8859P9, WE8MACROMAN8S, WE8MSWIN1252, WE8NCR4970, WE8NEXTSTEP, WE8PC850, WE8PC858, WE8PC860, WE8ROMAN8, ZHS16CGB231280, ZHS16GBK, ZHT16BIG5, ZHT16CCDC, ZHT16DBT, ZHT16HKSCS, ZHT16MSWIN950, ZHT32EUC, ZHT32SOPS, ZHT32TRIS
        """
        return pulumi.get(self, "character_set")

    @character_set.setter
    def character_set(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "character_set", value)

    @property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemDbHomeDatabaseConnectionStringArgs']]]]:
        return pulumi.get(self, "connection_strings")

    @connection_strings.setter
    def connection_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemDbHomeDatabaseConnectionStringArgs']]]]):
        pulumi.set(self, "connection_strings", value)

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[pulumi.Input[str]]:
        """
        The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "database_id")

    @database_id.setter
    def database_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_id", value)

    @property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> Optional[pulumi.Input[str]]:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the image to be used to restore a database.
        """
        return pulumi.get(self, "database_software_image_id")

    @database_software_image_id.setter
    def database_software_image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_software_image_id", value)

    @property
    @pulumi.getter(name="dbBackupConfig")
    def db_backup_config(self) -> Optional[pulumi.Input['DbSystemDbHomeDatabaseDbBackupConfigArgs']]:
        """
        (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        """
        return pulumi.get(self, "db_backup_config")

    @db_backup_config.setter
    def db_backup_config(self, value: Optional[pulumi.Input['DbSystemDbHomeDatabaseDbBackupConfigArgs']]):
        pulumi.set(self, "db_backup_config", value)

    @property
    @pulumi.getter(name="dbDomain")
    def db_domain(self) -> Optional[pulumi.Input[str]]:
        """
        The database domain. In a distributed database system, DB_DOMAIN specifies the logical location of the database within the network structure.
        """
        return pulumi.get(self, "db_domain")

    @db_domain.setter
    def db_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_domain", value)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[pulumi.Input[str]]:
        """
        The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "db_unique_name")

    @db_unique_name.setter
    def db_unique_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_unique_name", value)

    @property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> Optional[pulumi.Input[str]]:
        """
        **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.

        The database workload type.
        """
        return pulumi.get(self, "db_workload")

    @db_workload.setter
    def db_workload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_workload", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        """
        return pulumi.get(self, "kms_key_version_id")

    @kms_key_version_id.setter
    def kms_key_version_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_version_id", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> Optional[pulumi.Input[str]]:
        """
        The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        """
        return pulumi.get(self, "ncharacter_set")

    @ncharacter_set.setter
    def ncharacter_set(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ncharacter_set", value)

    @property
    @pulumi.getter(name="pdbName")
    def pdb_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        """
        return pulumi.get(self, "pdb_name")

    @pdb_name.setter
    def pdb_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pdb_name", value)

    @property
    @pulumi.getter(name="pluggableDatabases")
    def pluggable_databases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of pluggable databases that needs to be restored into new database.
        """
        return pulumi.get(self, "pluggable_databases")

    @pluggable_databases.setter
    def pluggable_databases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "pluggable_databases", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the DB system.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="tdeWalletPassword")
    def tde_wallet_password(self) -> Optional[pulumi.Input[str]]:
        """
        The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \\#, or -.
        """
        return pulumi.get(self, "tde_wallet_password")

    @tde_wallet_password.setter
    def tde_wallet_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tde_wallet_password", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the DB system was created.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeStampForPointInTimeRecovery")
    def time_stamp_for_point_in_time_recovery(self) -> Optional[pulumi.Input[str]]:
        """
        The point in time of the original database from which the new database is created. If not specifed, the latest backup is used to create the database.
        """
        return pulumi.get(self, "time_stamp_for_point_in_time_recovery")

    @time_stamp_for_point_in_time_recovery.setter
    def time_stamp_for_point_in_time_recovery(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_stamp_for_point_in_time_recovery", value)

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")

    @vault_id.setter
    def vault_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vault_id", value)


@pulumi.input_type
class DbSystemDbHomeDatabaseConnectionStringArgs:
    def __init__(__self__, *,
                 all_connection_strings: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 cdb_default: Optional[pulumi.Input[str]] = None,
                 cdb_ip_default: Optional[pulumi.Input[str]] = None):
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if cdb_default is not None:
            pulumi.set(__self__, "cdb_default", cdb_default)
        if cdb_ip_default is not None:
            pulumi.set(__self__, "cdb_ip_default", cdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "all_connection_strings")

    @all_connection_strings.setter
    def all_connection_strings(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "all_connection_strings", value)

    @property
    @pulumi.getter(name="cdbDefault")
    def cdb_default(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cdb_default")

    @cdb_default.setter
    def cdb_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cdb_default", value)

    @property
    @pulumi.getter(name="cdbIpDefault")
    def cdb_ip_default(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cdb_ip_default")

    @cdb_ip_default.setter
    def cdb_ip_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cdb_ip_default", value)


@pulumi.input_type
class DbSystemDbHomeDatabaseDbBackupConfigArgs:
    def __init__(__self__, *,
                 auto_backup_enabled: Optional[pulumi.Input[bool]] = None,
                 auto_backup_window: Optional[pulumi.Input[str]] = None,
                 auto_full_backup_day: Optional[pulumi.Input[str]] = None,
                 auto_full_backup_window: Optional[pulumi.Input[str]] = None,
                 backup_deletion_policy: Optional[pulumi.Input[str]] = None,
                 backup_destination_details: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs']]]] = None,
                 recovery_window_in_days: Optional[pulumi.Input[int]] = None,
                 run_immediate_full_backup: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] auto_backup_enabled: (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param pulumi.Input[str] auto_backup_window: (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param pulumi.Input[str] auto_full_backup_day: Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        :param pulumi.Input[str] auto_full_backup_window: Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param pulumi.Input[str] backup_deletion_policy: This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        :param pulumi.Input[Sequence[pulumi.Input['DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs']]] backup_destination_details: (Updatable) Backup destination details.
        :param pulumi.Input[int] recovery_window_in_days: (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        :param pulumi.Input[bool] run_immediate_full_backup: If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        if auto_backup_enabled is not None:
            pulumi.set(__self__, "auto_backup_enabled", auto_backup_enabled)
        if auto_backup_window is not None:
            pulumi.set(__self__, "auto_backup_window", auto_backup_window)
        if auto_full_backup_day is not None:
            pulumi.set(__self__, "auto_full_backup_day", auto_full_backup_day)
        if auto_full_backup_window is not None:
            pulumi.set(__self__, "auto_full_backup_window", auto_full_backup_window)
        if backup_deletion_policy is not None:
            pulumi.set(__self__, "backup_deletion_policy", backup_deletion_policy)
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)
        if run_immediate_full_backup is not None:
            pulumi.set(__self__, "run_immediate_full_backup", run_immediate_full_backup)

    @property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @auto_backup_enabled.setter
    def auto_backup_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_backup_enabled", value)

    @property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @auto_backup_window.setter
    def auto_backup_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_backup_window", value)

    @property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> Optional[pulumi.Input[str]]:
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        return pulumi.get(self, "auto_full_backup_day")

    @auto_full_backup_day.setter
    def auto_full_backup_day(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_full_backup_day", value)

    @property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> Optional[pulumi.Input[str]]:
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_full_backup_window")

    @auto_full_backup_window.setter
    def auto_full_backup_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_full_backup_window", value)

    @property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> Optional[pulumi.Input[str]]:
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        return pulumi.get(self, "backup_deletion_policy")

    @backup_deletion_policy.setter
    def backup_deletion_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_deletion_policy", value)

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs']]]]:
        """
        (Updatable) Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @backup_destination_details.setter
    def backup_destination_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs']]]]):
        pulumi.set(self, "backup_destination_details", value)

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @recovery_window_in_days.setter
    def recovery_window_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "recovery_window_in_days", value)

    @property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        return pulumi.get(self, "run_immediate_full_backup")

    @run_immediate_full_backup.setter
    def run_immediate_full_backup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_immediate_full_backup", value)


@pulumi.input_type
class DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs:
    def __init__(__self__, *,
                 dbrs_policy_id: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param pulumi.Input[str] type: Type of the database backup destination.
        """
        if dbrs_policy_id is not None:
            pulumi.set(__self__, "dbrs_policy_id", dbrs_policy_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @dbrs_policy_id.setter
    def dbrs_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dbrs_policy_id", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class DbSystemDbSystemOptionsArgs:
    def __init__(__self__, *,
                 storage_management: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] storage_management: The storage option used in DB system. ASM - Automatic storage management LVM - Logical Volume management
        """
        if storage_management is not None:
            pulumi.set(__self__, "storage_management", storage_management)

    @property
    @pulumi.getter(name="storageManagement")
    def storage_management(self) -> Optional[pulumi.Input[str]]:
        """
        The storage option used in DB system. ASM - Automatic storage management LVM - Logical Volume management
        """
        return pulumi.get(self, "storage_management")

    @storage_management.setter
    def storage_management(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_management", value)


@pulumi.input_type
class DbSystemIormConfigCachArgs:
    def __init__(__self__, *,
                 db_plans: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemIormConfigCachDbPlanArgs']]]] = None,
                 db_system_id: Optional[pulumi.Input[str]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 objective: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DbSystemIormConfigCachDbPlanArgs']]] db_plans: An array of IORM settings for all the database in the Exadata DB system.
        :param pulumi.Input[str] lifecycle_details: Additional information about the current lifecycle state.
        :param pulumi.Input[str] objective: The current value for the IORM objective. The default is `AUTO`.
        :param pulumi.Input[str] state: The current state of the DB system.
        """
        if db_plans is not None:
            pulumi.set(__self__, "db_plans", db_plans)
        if db_system_id is not None:
            pulumi.set(__self__, "db_system_id", db_system_id)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if objective is not None:
            pulumi.set(__self__, "objective", objective)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="dbPlans")
    def db_plans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemIormConfigCachDbPlanArgs']]]]:
        """
        An array of IORM settings for all the database in the Exadata DB system.
        """
        return pulumi.get(self, "db_plans")

    @db_plans.setter
    def db_plans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemIormConfigCachDbPlanArgs']]]]):
        pulumi.set(self, "db_plans", value)

    @property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "db_system_id")

    @db_system_id.setter
    def db_system_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_system_id", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter
    def objective(self) -> Optional[pulumi.Input[str]]:
        """
        The current value for the IORM objective. The default is `AUTO`.
        """
        return pulumi.get(self, "objective")

    @objective.setter
    def objective(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "objective", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the DB system.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


@pulumi.input_type
class DbSystemIormConfigCachDbPlanArgs:
    def __init__(__self__, *,
                 db_name: Optional[pulumi.Input[str]] = None,
                 flash_cache_limit: Optional[pulumi.Input[str]] = None,
                 share: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] db_name: The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        :param pulumi.Input[str] flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        :param pulumi.Input[int] share: The relative priority of this database.
        """
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if flash_cache_limit is not None:
            pulumi.set(__self__, "flash_cache_limit", flash_cache_limit)
        if share is not None:
            pulumi.set(__self__, "share", share)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[pulumi.Input[str]]:
        """
        The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")

    @flash_cache_limit.setter
    def flash_cache_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flash_cache_limit", value)

    @property
    @pulumi.getter
    def share(self) -> Optional[pulumi.Input[int]]:
        """
        The relative priority of this database.
        """
        return pulumi.get(self, "share")

    @share.setter
    def share(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "share", value)


@pulumi.input_type
class DbSystemMaintenanceWindowArgs:
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[pulumi.Input[int]] = None,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 is_custom_action_timeout_enabled: Optional[pulumi.Input[bool]] = None,
                 is_monthly_patching_enabled: Optional[pulumi.Input[bool]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowMonthArgs']]]] = None,
                 patching_mode: Optional[pulumi.Input[str]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[int] custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowDaysOfWeekArgs']]] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[bool] is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param pulumi.Input[bool] is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param pulumi.Input[int] lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowMonthArgs']]] months: (Updatable) Months during the year when maintenance should be performed.
        :param pulumi.Input[str] patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param pulumi.Input[str] preference: (Updatable) The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @custom_action_timeout_in_mins.setter
    def custom_action_timeout_in_mins(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_action_timeout_in_mins", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowDaysOfWeekArgs']]]]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @is_custom_action_timeout_enabled.setter
    def is_custom_action_timeout_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom_action_timeout_enabled", value)

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @is_monthly_patching_enabled.setter
    def is_monthly_patching_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monthly_patching_enabled", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowMonthArgs']]]]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @patching_mode.setter
    def patching_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patching_mode", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


@pulumi.input_type
class DbSystemMaintenanceWindowDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class DbSystemMaintenanceWindowDetailsArgs:
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[pulumi.Input[int]] = None,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowDetailsDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 is_custom_action_timeout_enabled: Optional[pulumi.Input[bool]] = None,
                 is_monthly_patching_enabled: Optional[pulumi.Input[bool]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowDetailsMonthArgs']]]] = None,
                 patching_mode: Optional[pulumi.Input[str]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[int] custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowDetailsDaysOfWeekArgs']]] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[bool] is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param pulumi.Input[bool] is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param pulumi.Input[int] lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowDetailsMonthArgs']]] months: (Updatable) Months during the year when maintenance should be performed.
        :param pulumi.Input[str] patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param pulumi.Input[str] preference: (Updatable) The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @custom_action_timeout_in_mins.setter
    def custom_action_timeout_in_mins(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_action_timeout_in_mins", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowDetailsDaysOfWeekArgs']]]]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowDetailsDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @is_custom_action_timeout_enabled.setter
    def is_custom_action_timeout_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom_action_timeout_enabled", value)

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @is_monthly_patching_enabled.setter
    def is_monthly_patching_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monthly_patching_enabled", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowDetailsMonthArgs']]]]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemMaintenanceWindowDetailsMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @patching_mode.setter
    def patching_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patching_mode", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


@pulumi.input_type
class DbSystemMaintenanceWindowDetailsDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class DbSystemMaintenanceWindowDetailsMonthArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class DbSystemMaintenanceWindowMonthArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class DbSystemsUpgradeDbSystemOptionArgs:
    def __init__(__self__, *,
                 storage_management: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] storage_management: The storage option used in DB system. ASM - Automatic storage management LVM - Logical Volume management
        """
        if storage_management is not None:
            pulumi.set(__self__, "storage_management", storage_management)

    @property
    @pulumi.getter(name="storageManagement")
    def storage_management(self) -> Optional[pulumi.Input[str]]:
        """
        The storage option used in DB system. ASM - Automatic storage management LVM - Logical Volume management
        """
        return pulumi.get(self, "storage_management")

    @storage_management.setter
    def storage_management(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_management", value)


@pulumi.input_type
class DbSystemsUpgradeIormConfigCachArgs:
    def __init__(__self__, *,
                 db_plans: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemsUpgradeIormConfigCachDbPlanArgs']]]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 objective: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DbSystemsUpgradeIormConfigCachDbPlanArgs']]] db_plans: An array of IORM settings for all the database in the Exadata DB system.
        :param pulumi.Input[str] lifecycle_details: Additional information about the current lifecycle state.
        :param pulumi.Input[str] objective: The current value for the IORM objective. The default is `AUTO`.
        :param pulumi.Input[str] state: The current state of the DB system.
        """
        if db_plans is not None:
            pulumi.set(__self__, "db_plans", db_plans)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if objective is not None:
            pulumi.set(__self__, "objective", objective)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="dbPlans")
    def db_plans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemsUpgradeIormConfigCachDbPlanArgs']]]]:
        """
        An array of IORM settings for all the database in the Exadata DB system.
        """
        return pulumi.get(self, "db_plans")

    @db_plans.setter
    def db_plans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemsUpgradeIormConfigCachDbPlanArgs']]]]):
        pulumi.set(self, "db_plans", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter
    def objective(self) -> Optional[pulumi.Input[str]]:
        """
        The current value for the IORM objective. The default is `AUTO`.
        """
        return pulumi.get(self, "objective")

    @objective.setter
    def objective(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "objective", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the DB system.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


@pulumi.input_type
class DbSystemsUpgradeIormConfigCachDbPlanArgs:
    def __init__(__self__, *,
                 db_name: Optional[pulumi.Input[str]] = None,
                 flash_cache_limit: Optional[pulumi.Input[str]] = None,
                 share: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] db_name: The database name. For the default `DbPlan`, the `dbName` is `default`.
        :param pulumi.Input[str] flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        :param pulumi.Input[int] share: The relative priority of this database.
        """
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if flash_cache_limit is not None:
            pulumi.set(__self__, "flash_cache_limit", flash_cache_limit)
        if share is not None:
            pulumi.set(__self__, "share", share)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[pulumi.Input[str]]:
        """
        The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")

    @flash_cache_limit.setter
    def flash_cache_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flash_cache_limit", value)

    @property
    @pulumi.getter
    def share(self) -> Optional[pulumi.Input[int]]:
        """
        The relative priority of this database.
        """
        return pulumi.get(self, "share")

    @share.setter
    def share(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "share", value)


@pulumi.input_type
class DbSystemsUpgradeMaintenanceWindowArgs:
    def __init__(__self__, *,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemsUpgradeMaintenanceWindowDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemsUpgradeMaintenanceWindowMonthArgs']]]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DbSystemsUpgradeMaintenanceWindowDaysOfWeekArgs']]] days_of_weeks: Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[int] lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['DbSystemsUpgradeMaintenanceWindowMonthArgs']]] months: Months during the year when maintenance should be performed.
        :param pulumi.Input[str] preference: The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemsUpgradeMaintenanceWindowDaysOfWeekArgs']]]]:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemsUpgradeMaintenanceWindowDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemsUpgradeMaintenanceWindowMonthArgs']]]]:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DbSystemsUpgradeMaintenanceWindowMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


@pulumi.input_type
class DbSystemsUpgradeMaintenanceWindowDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class DbSystemsUpgradeMaintenanceWindowMonthArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class ExadataInfrastructureComputeContactArgs:
    def __init__(__self__, *,
                 email: Optional[pulumi.Input[str]] = None,
                 is_contact_mos_validated: Optional[pulumi.Input[bool]] = None,
                 is_primary: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 phone_number: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] email: The email for the Exadata Infrastructure contact.
        :param pulumi.Input[bool] is_contact_mos_validated: If `true`, this Exadata Infrastructure contact is a valid My Oracle Support (MOS) contact. If `false`, this Exadata Infrastructure contact is not a valid MOS contact.
        :param pulumi.Input[bool] is_primary: If `true`, this Exadata Infrastructure contact is a primary contact. If `false`, this Exadata Infrastructure is a secondary contact.
        :param pulumi.Input[str] name: Name of the month of the year.
        :param pulumi.Input[str] phone_number: The phone number for the Exadata Infrastructure contact.
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if is_contact_mos_validated is not None:
            pulumi.set(__self__, "is_contact_mos_validated", is_contact_mos_validated)
        if is_primary is not None:
            pulumi.set(__self__, "is_primary", is_primary)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if phone_number is not None:
            pulumi.set(__self__, "phone_number", phone_number)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        The email for the Exadata Infrastructure contact.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="isContactMosValidated")
    def is_contact_mos_validated(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true`, this Exadata Infrastructure contact is a valid My Oracle Support (MOS) contact. If `false`, this Exadata Infrastructure contact is not a valid MOS contact.
        """
        return pulumi.get(self, "is_contact_mos_validated")

    @is_contact_mos_validated.setter
    def is_contact_mos_validated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_contact_mos_validated", value)

    @property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true`, this Exadata Infrastructure contact is a primary contact. If `false`, this Exadata Infrastructure is a secondary contact.
        """
        return pulumi.get(self, "is_primary")

    @is_primary.setter
    def is_primary(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_primary", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[pulumi.Input[str]]:
        """
        The phone number for the Exadata Infrastructure contact.
        """
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phone_number", value)


@pulumi.input_type
class ExadataInfrastructureComputeMaintenanceWindowArgs:
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[pulumi.Input[int]] = None,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureComputeMaintenanceWindowDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 is_custom_action_timeout_enabled: Optional[pulumi.Input[bool]] = None,
                 is_monthly_patching_enabled: Optional[pulumi.Input[bool]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureComputeMaintenanceWindowMonthArgs']]]] = None,
                 patching_mode: Optional[pulumi.Input[str]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[int] custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureComputeMaintenanceWindowDaysOfWeekArgs']]] days_of_weeks: Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[bool] is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param pulumi.Input[bool] is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param pulumi.Input[int] lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureComputeMaintenanceWindowMonthArgs']]] months: Months during the year when maintenance should be performed.
        :param pulumi.Input[str] patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param pulumi.Input[str] preference: The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[pulumi.Input[int]]:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @custom_action_timeout_in_mins.setter
    def custom_action_timeout_in_mins(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_action_timeout_in_mins", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureComputeMaintenanceWindowDaysOfWeekArgs']]]]:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureComputeMaintenanceWindowDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @is_custom_action_timeout_enabled.setter
    def is_custom_action_timeout_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom_action_timeout_enabled", value)

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @is_monthly_patching_enabled.setter
    def is_monthly_patching_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monthly_patching_enabled", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureComputeMaintenanceWindowMonthArgs']]]]:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureComputeMaintenanceWindowMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @patching_mode.setter
    def patching_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patching_mode", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


@pulumi.input_type
class ExadataInfrastructureComputeMaintenanceWindowDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class ExadataInfrastructureComputeMaintenanceWindowMonthArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class ExadataInfrastructureContactArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[str],
                 is_primary: pulumi.Input[bool],
                 name: pulumi.Input[str],
                 is_contact_mos_validated: Optional[pulumi.Input[bool]] = None,
                 phone_number: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] email: (Updatable) The email for the Exadata Infrastructure contact.
        :param pulumi.Input[bool] is_primary: (Updatable) If `true`, this Exadata Infrastructure contact is a primary contact. If `false`, this Exadata Infrastructure is a secondary contact.
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        :param pulumi.Input[bool] is_contact_mos_validated: (Updatable) If `true`, this Exadata Infrastructure contact is a valid My Oracle Support (MOS) contact. If `false`, this Exadata Infrastructure contact is not a valid MOS contact.
        :param pulumi.Input[str] phone_number: (Updatable) The phone number for the Exadata Infrastructure contact.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "is_primary", is_primary)
        pulumi.set(__self__, "name", name)
        if is_contact_mos_validated is not None:
            pulumi.set(__self__, "is_contact_mos_validated", is_contact_mos_validated)
        if phone_number is not None:
            pulumi.set(__self__, "phone_number", phone_number)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        (Updatable) The email for the Exadata Infrastructure contact.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> pulumi.Input[bool]:
        """
        (Updatable) If `true`, this Exadata Infrastructure contact is a primary contact. If `false`, this Exadata Infrastructure is a secondary contact.
        """
        return pulumi.get(self, "is_primary")

    @is_primary.setter
    def is_primary(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_primary", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="isContactMosValidated")
    def is_contact_mos_validated(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If `true`, this Exadata Infrastructure contact is a valid My Oracle Support (MOS) contact. If `false`, this Exadata Infrastructure contact is not a valid MOS contact.
        """
        return pulumi.get(self, "is_contact_mos_validated")

    @is_contact_mos_validated.setter
    def is_contact_mos_validated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_contact_mos_validated", value)

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The phone number for the Exadata Infrastructure contact.
        """
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phone_number", value)


@pulumi.input_type
class ExadataInfrastructureMaintenanceWindowArgs:
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[pulumi.Input[int]] = None,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 is_custom_action_timeout_enabled: Optional[pulumi.Input[bool]] = None,
                 is_monthly_patching_enabled: Optional[pulumi.Input[bool]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureMaintenanceWindowMonthArgs']]]] = None,
                 patching_mode: Optional[pulumi.Input[str]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[int] custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[bool] is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param pulumi.Input[bool] is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param pulumi.Input[int] lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureMaintenanceWindowMonthArgs']]] months: (Updatable) Months during the year when maintenance should be performed.
        :param pulumi.Input[str] patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param pulumi.Input[str] preference: (Updatable) The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if custom_action_timeout_in_mins is not None:
            pulumi.set(__self__, "custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            pulumi.set(__self__, "is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            pulumi.set(__self__, "is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @custom_action_timeout_in_mins.setter
    def custom_action_timeout_in_mins(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_action_timeout_in_mins", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]]]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @is_custom_action_timeout_enabled.setter
    def is_custom_action_timeout_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom_action_timeout_enabled", value)

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @is_monthly_patching_enabled.setter
    def is_monthly_patching_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monthly_patching_enabled", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureMaintenanceWindowMonthArgs']]]]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureMaintenanceWindowMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @patching_mode.setter
    def patching_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patching_mode", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


@pulumi.input_type
class ExadataInfrastructureMaintenanceWindowDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class ExadataInfrastructureMaintenanceWindowMonthArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class ExadataInfrastructureNetworkBondingModeDetailsArgs:
    def __init__(__self__, *,
                 backup_network_bonding_mode: Optional[pulumi.Input[str]] = None,
                 client_network_bonding_mode: Optional[pulumi.Input[str]] = None,
                 dr_network_bonding_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] backup_network_bonding_mode: (Updatable) The network bonding mode for the Exadata infrastructure.
        :param pulumi.Input[str] client_network_bonding_mode: (Updatable) The network bonding mode for the Exadata infrastructure.
        :param pulumi.Input[str] dr_network_bonding_mode: (Updatable) The network bonding mode for the Exadata infrastructure.
        """
        if backup_network_bonding_mode is not None:
            pulumi.set(__self__, "backup_network_bonding_mode", backup_network_bonding_mode)
        if client_network_bonding_mode is not None:
            pulumi.set(__self__, "client_network_bonding_mode", client_network_bonding_mode)
        if dr_network_bonding_mode is not None:
            pulumi.set(__self__, "dr_network_bonding_mode", dr_network_bonding_mode)

    @property
    @pulumi.getter(name="backupNetworkBondingMode")
    def backup_network_bonding_mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The network bonding mode for the Exadata infrastructure.
        """
        return pulumi.get(self, "backup_network_bonding_mode")

    @backup_network_bonding_mode.setter
    def backup_network_bonding_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_network_bonding_mode", value)

    @property
    @pulumi.getter(name="clientNetworkBondingMode")
    def client_network_bonding_mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The network bonding mode for the Exadata infrastructure.
        """
        return pulumi.get(self, "client_network_bonding_mode")

    @client_network_bonding_mode.setter
    def client_network_bonding_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_network_bonding_mode", value)

    @property
    @pulumi.getter(name="drNetworkBondingMode")
    def dr_network_bonding_mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The network bonding mode for the Exadata infrastructure.
        """
        return pulumi.get(self, "dr_network_bonding_mode")

    @dr_network_bonding_mode.setter
    def dr_network_bonding_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dr_network_bonding_mode", value)


@pulumi.input_type
class ExadataInfrastructureStorageContactArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[str],
                 is_primary: pulumi.Input[bool],
                 name: pulumi.Input[str],
                 is_contact_mos_validated: Optional[pulumi.Input[bool]] = None,
                 phone_number: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "is_primary", is_primary)
        pulumi.set(__self__, "name", name)
        if is_contact_mos_validated is not None:
            pulumi.set(__self__, "is_contact_mos_validated", is_contact_mos_validated)
        if phone_number is not None:
            pulumi.set(__self__, "phone_number", phone_number)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "is_primary")

    @is_primary.setter
    def is_primary(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_primary", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="isContactMosValidated")
    def is_contact_mos_validated(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_contact_mos_validated")

    @is_contact_mos_validated.setter
    def is_contact_mos_validated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_contact_mos_validated", value)

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phone_number", value)


@pulumi.input_type
class ExadataInfrastructureStorageMaintenanceWindowArgs:
    def __init__(__self__, *,
                 preference: pulumi.Input[str],
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureStorageMaintenanceWindowDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureStorageMaintenanceWindowMonthArgs']]]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        pulumi.set(__self__, "preference", preference)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter
    def preference(self) -> pulumi.Input[str]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: pulumi.Input[str]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureStorageMaintenanceWindowDaysOfWeekArgs']]]]:
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureStorageMaintenanceWindowDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureStorageMaintenanceWindowMonthArgs']]]]:
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExadataInfrastructureStorageMaintenanceWindowMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


@pulumi.input_type
class ExadataInfrastructureStorageMaintenanceWindowDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class ExadataInfrastructureStorageMaintenanceWindowMonthArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class ExadataIormConfigDbPlanArgs:
    def __init__(__self__, *,
                 db_name: pulumi.Input[str],
                 share: pulumi.Input[int],
                 flash_cache_limit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] db_name: (Updatable) The database name. For the default `DbPlan`, the `dbName` is `default`.
        :param pulumi.Input[int] share: (Updatable) The relative priority of this database.
        :param pulumi.Input[str] flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "share", share)
        if flash_cache_limit is not None:
            pulumi.set(__self__, "flash_cache_limit", flash_cache_limit)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> pulumi.Input[str]:
        """
        (Updatable) The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter
    def share(self) -> pulumi.Input[int]:
        """
        (Updatable) The relative priority of this database.
        """
        return pulumi.get(self, "share")

    @share.setter
    def share(self, value: pulumi.Input[int]):
        pulumi.set(self, "share", value)

    @property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")

    @flash_cache_limit.setter
    def flash_cache_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flash_cache_limit", value)


@pulumi.input_type
class ExternalContainerDatabaseDatabaseManagementConfigArgs:
    def __init__(__self__, *,
                 database_management_connection_id: Optional[pulumi.Input[str]] = None,
                 database_management_status: Optional[pulumi.Input[str]] = None,
                 license_model: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database_management_connection_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param pulumi.Input[str] database_management_status: The status of the Database Management service.
        :param pulumi.Input[str] license_model: The Oracle license model that applies to the external database.
        """
        if database_management_connection_id is not None:
            pulumi.set(__self__, "database_management_connection_id", database_management_connection_id)
        if database_management_status is not None:
            pulumi.set(__self__, "database_management_status", database_management_status)
        if license_model is not None:
            pulumi.set(__self__, "license_model", license_model)

    @property
    @pulumi.getter(name="databaseManagementConnectionId")
    def database_management_connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "database_management_connection_id")

    @database_management_connection_id.setter
    def database_management_connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_management_connection_id", value)

    @property
    @pulumi.getter(name="databaseManagementStatus")
    def database_management_status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "database_management_status")

    @database_management_status.setter
    def database_management_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_management_status", value)

    @property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> Optional[pulumi.Input[str]]:
        """
        The Oracle license model that applies to the external database.
        """
        return pulumi.get(self, "license_model")

    @license_model.setter
    def license_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "license_model", value)


@pulumi.input_type
class ExternalContainerDatabaseStackMonitoringConfigArgs:
    def __init__(__self__, *,
                 stack_monitoring_connector_id: Optional[pulumi.Input[str]] = None,
                 stack_monitoring_status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] stack_monitoring_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param pulumi.Input[str] stack_monitoring_status: The status of Stack Monitoring.
        """
        if stack_monitoring_connector_id is not None:
            pulumi.set(__self__, "stack_monitoring_connector_id", stack_monitoring_connector_id)
        if stack_monitoring_status is not None:
            pulumi.set(__self__, "stack_monitoring_status", stack_monitoring_status)

    @property
    @pulumi.getter(name="stackMonitoringConnectorId")
    def stack_monitoring_connector_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "stack_monitoring_connector_id")

    @stack_monitoring_connector_id.setter
    def stack_monitoring_connector_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stack_monitoring_connector_id", value)

    @property
    @pulumi.getter(name="stackMonitoringStatus")
    def stack_monitoring_status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of Stack Monitoring.
        """
        return pulumi.get(self, "stack_monitoring_status")

    @stack_monitoring_status.setter
    def stack_monitoring_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stack_monitoring_status", value)


@pulumi.input_type
class ExternalDatabaseConnectorConnectionCredentialsArgs:
    def __init__(__self__, *,
                 credential_name: Optional[pulumi.Input[str]] = None,
                 credential_type: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 ssl_secret_id: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] credential_name: (Updatable) The name of the credential information that used to connect to the database. The name should be in "x.y" format, where the length of "x" has a maximum of 64 characters, and length of "y" has a maximum of 199 characters. The name strings can contain letters, numbers and the underscore character only. Other characters are not valid, except for the "." character that separates the "x" and "y" portions of the name. *IMPORTANT* - The name must be unique within the Oracle Cloud Infrastructure region the credential is being created in. If you specify a name that duplicates the name of another credential within the same Oracle Cloud Infrastructure region, you may overwrite or corrupt the credential that is already using the name.
               
               For example: inventorydb.abc112233445566778899
        :param pulumi.Input[str] credential_type: (Updatable) The type of credential used to connect to the database.
        :param pulumi.Input[str] password: (Updatable) The password that will be used to connect to the database.
        :param pulumi.Input[str] role: (Updatable) The role of the user that will be connecting to the database.
        :param pulumi.Input[str] ssl_secret_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        :param pulumi.Input[str] username: (Updatable) The username that will be used to connect to the database.
        """
        if credential_name is not None:
            pulumi.set(__self__, "credential_name", credential_name)
        if credential_type is not None:
            pulumi.set(__self__, "credential_type", credential_type)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if ssl_secret_id is not None:
            pulumi.set(__self__, "ssl_secret_id", ssl_secret_id)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="credentialName")
    def credential_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The name of the credential information that used to connect to the database. The name should be in "x.y" format, where the length of "x" has a maximum of 64 characters, and length of "y" has a maximum of 199 characters. The name strings can contain letters, numbers and the underscore character only. Other characters are not valid, except for the "." character that separates the "x" and "y" portions of the name. *IMPORTANT* - The name must be unique within the Oracle Cloud Infrastructure region the credential is being created in. If you specify a name that duplicates the name of another credential within the same Oracle Cloud Infrastructure region, you may overwrite or corrupt the credential that is already using the name.

        For example: inventorydb.abc112233445566778899
        """
        return pulumi.get(self, "credential_name")

    @credential_name.setter
    def credential_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credential_name", value)

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The type of credential used to connect to the database.
        """
        return pulumi.get(self, "credential_type")

    @credential_type.setter
    def credential_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credential_type", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The password that will be used to connect to the database.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The role of the user that will be connecting to the database.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter(name="sslSecretId")
    def ssl_secret_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "ssl_secret_id")

    @ssl_secret_id.setter
    def ssl_secret_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssl_secret_id", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The username that will be used to connect to the database.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ExternalDatabaseConnectorConnectionStringArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[str],
                 port: pulumi.Input[int],
                 protocol: pulumi.Input[str],
                 service: pulumi.Input[str]):
        """
        :param pulumi.Input[str] hostname: (Updatable) The host name of the database.
        :param pulumi.Input[int] port: (Updatable) The port used to connect to the database.
        :param pulumi.Input[str] protocol: (Updatable) The protocol used to connect to the database.
        :param pulumi.Input[str] service: (Updatable) The name of the service alias used to connect to the database.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[str]:
        """
        (Updatable) The host name of the database.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        (Updatable) The port used to connect to the database.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        (Updatable) The protocol used to connect to the database.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        (Updatable) The name of the service alias used to connect to the database.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)


@pulumi.input_type
class ExternalNonContainerDatabaseDatabaseManagementConfigArgs:
    def __init__(__self__, *,
                 database_management_connection_id: Optional[pulumi.Input[str]] = None,
                 database_management_status: Optional[pulumi.Input[str]] = None,
                 license_model: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database_management_connection_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param pulumi.Input[str] database_management_status: The status of the Database Management service.
        :param pulumi.Input[str] license_model: The Oracle license model that applies to the external database.
        """
        if database_management_connection_id is not None:
            pulumi.set(__self__, "database_management_connection_id", database_management_connection_id)
        if database_management_status is not None:
            pulumi.set(__self__, "database_management_status", database_management_status)
        if license_model is not None:
            pulumi.set(__self__, "license_model", license_model)

    @property
    @pulumi.getter(name="databaseManagementConnectionId")
    def database_management_connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "database_management_connection_id")

    @database_management_connection_id.setter
    def database_management_connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_management_connection_id", value)

    @property
    @pulumi.getter(name="databaseManagementStatus")
    def database_management_status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "database_management_status")

    @database_management_status.setter
    def database_management_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_management_status", value)

    @property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> Optional[pulumi.Input[str]]:
        """
        The Oracle license model that applies to the external database.
        """
        return pulumi.get(self, "license_model")

    @license_model.setter
    def license_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "license_model", value)


@pulumi.input_type
class ExternalNonContainerDatabaseOperationsInsightsConfigArgs:
    def __init__(__self__, *,
                 operations_insights_connector_id: Optional[pulumi.Input[str]] = None,
                 operations_insights_status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] operations_insights_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param pulumi.Input[str] operations_insights_status: The status of Operations Insights
        """
        if operations_insights_connector_id is not None:
            pulumi.set(__self__, "operations_insights_connector_id", operations_insights_connector_id)
        if operations_insights_status is not None:
            pulumi.set(__self__, "operations_insights_status", operations_insights_status)

    @property
    @pulumi.getter(name="operationsInsightsConnectorId")
    def operations_insights_connector_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "operations_insights_connector_id")

    @operations_insights_connector_id.setter
    def operations_insights_connector_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operations_insights_connector_id", value)

    @property
    @pulumi.getter(name="operationsInsightsStatus")
    def operations_insights_status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of Operations Insights
        """
        return pulumi.get(self, "operations_insights_status")

    @operations_insights_status.setter
    def operations_insights_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operations_insights_status", value)


@pulumi.input_type
class ExternalNonContainerDatabaseStackMonitoringConfigArgs:
    def __init__(__self__, *,
                 stack_monitoring_connector_id: Optional[pulumi.Input[str]] = None,
                 stack_monitoring_status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] stack_monitoring_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param pulumi.Input[str] stack_monitoring_status: The status of Stack Monitoring.
        """
        if stack_monitoring_connector_id is not None:
            pulumi.set(__self__, "stack_monitoring_connector_id", stack_monitoring_connector_id)
        if stack_monitoring_status is not None:
            pulumi.set(__self__, "stack_monitoring_status", stack_monitoring_status)

    @property
    @pulumi.getter(name="stackMonitoringConnectorId")
    def stack_monitoring_connector_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "stack_monitoring_connector_id")

    @stack_monitoring_connector_id.setter
    def stack_monitoring_connector_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stack_monitoring_connector_id", value)

    @property
    @pulumi.getter(name="stackMonitoringStatus")
    def stack_monitoring_status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of Stack Monitoring.
        """
        return pulumi.get(self, "stack_monitoring_status")

    @stack_monitoring_status.setter
    def stack_monitoring_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stack_monitoring_status", value)


@pulumi.input_type
class ExternalPluggableDatabaseDatabaseManagementConfigArgs:
    def __init__(__self__, *,
                 database_management_connection_id: Optional[pulumi.Input[str]] = None,
                 database_management_status: Optional[pulumi.Input[str]] = None,
                 license_model: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database_management_connection_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param pulumi.Input[str] database_management_status: The status of the Database Management service.
        :param pulumi.Input[str] license_model: The Oracle license model that applies to the external database.
        """
        if database_management_connection_id is not None:
            pulumi.set(__self__, "database_management_connection_id", database_management_connection_id)
        if database_management_status is not None:
            pulumi.set(__self__, "database_management_status", database_management_status)
        if license_model is not None:
            pulumi.set(__self__, "license_model", license_model)

    @property
    @pulumi.getter(name="databaseManagementConnectionId")
    def database_management_connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "database_management_connection_id")

    @database_management_connection_id.setter
    def database_management_connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_management_connection_id", value)

    @property
    @pulumi.getter(name="databaseManagementStatus")
    def database_management_status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "database_management_status")

    @database_management_status.setter
    def database_management_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_management_status", value)

    @property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> Optional[pulumi.Input[str]]:
        """
        The Oracle license model that applies to the external database.
        """
        return pulumi.get(self, "license_model")

    @license_model.setter
    def license_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "license_model", value)


@pulumi.input_type
class ExternalPluggableDatabaseOperationsInsightsConfigArgs:
    def __init__(__self__, *,
                 operations_insights_connector_id: Optional[pulumi.Input[str]] = None,
                 operations_insights_status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] operations_insights_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param pulumi.Input[str] operations_insights_status: The status of Operations Insights
        """
        if operations_insights_connector_id is not None:
            pulumi.set(__self__, "operations_insights_connector_id", operations_insights_connector_id)
        if operations_insights_status is not None:
            pulumi.set(__self__, "operations_insights_status", operations_insights_status)

    @property
    @pulumi.getter(name="operationsInsightsConnectorId")
    def operations_insights_connector_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "operations_insights_connector_id")

    @operations_insights_connector_id.setter
    def operations_insights_connector_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operations_insights_connector_id", value)

    @property
    @pulumi.getter(name="operationsInsightsStatus")
    def operations_insights_status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of Operations Insights
        """
        return pulumi.get(self, "operations_insights_status")

    @operations_insights_status.setter
    def operations_insights_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operations_insights_status", value)


@pulumi.input_type
class ExternalPluggableDatabaseStackMonitoringConfigArgs:
    def __init__(__self__, *,
                 stack_monitoring_connector_id: Optional[pulumi.Input[str]] = None,
                 stack_monitoring_status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] stack_monitoring_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param pulumi.Input[str] stack_monitoring_status: The status of Stack Monitoring.
        """
        if stack_monitoring_connector_id is not None:
            pulumi.set(__self__, "stack_monitoring_connector_id", stack_monitoring_connector_id)
        if stack_monitoring_status is not None:
            pulumi.set(__self__, "stack_monitoring_status", stack_monitoring_status)

    @property
    @pulumi.getter(name="stackMonitoringConnectorId")
    def stack_monitoring_connector_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "stack_monitoring_connector_id")

    @stack_monitoring_connector_id.setter
    def stack_monitoring_connector_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stack_monitoring_connector_id", value)

    @property
    @pulumi.getter(name="stackMonitoringStatus")
    def stack_monitoring_status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of Stack Monitoring.
        """
        return pulumi.get(self, "stack_monitoring_status")

    @stack_monitoring_status.setter
    def stack_monitoring_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stack_monitoring_status", value)


@pulumi.input_type
class KeyStoreAssociatedDatabaseArgs:
    def __init__(__self__, *,
                 db_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] db_name: The name of the database that is associated with the key store.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        """
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the database that is associated with the key store.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class KeyStoreTypeDetailsArgs:
    def __init__(__self__, *,
                 admin_username: pulumi.Input[str],
                 connection_ips: pulumi.Input[Sequence[pulumi.Input[str]]],
                 secret_id: pulumi.Input[str],
                 type: pulumi.Input[str],
                 vault_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] admin_username: (Updatable) The administrator username to connect to Oracle Key Vault
        :param pulumi.Input[Sequence[pulumi.Input[str]]] connection_ips: (Updatable) The list of Oracle Key Vault connection IP addresses.
        :param pulumi.Input[str] secret_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        :param pulumi.Input[str] type: (Updatable) The type of key store.
        :param pulumi.Input[str] vault_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "admin_username", admin_username)
        pulumi.set(__self__, "connection_ips", connection_ips)
        pulumi.set(__self__, "secret_id", secret_id)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vault_id", vault_id)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> pulumi.Input[str]:
        """
        (Updatable) The administrator username to connect to Oracle Key Vault
        """
        return pulumi.get(self, "admin_username")

    @admin_username.setter
    def admin_username(self, value: pulumi.Input[str]):
        pulumi.set(self, "admin_username", value)

    @property
    @pulumi.getter(name="connectionIps")
    def connection_ips(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        (Updatable) The list of Oracle Key Vault connection IP addresses.
        """
        return pulumi.get(self, "connection_ips")

    @connection_ips.setter
    def connection_ips(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "connection_ips", value)

    @property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "secret_id")

    @secret_id.setter
    def secret_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) The type of key store.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "vault_id")

    @vault_id.setter
    def vault_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "vault_id", value)


@pulumi.input_type
class MaintenanceRunEstimatedPatchingTimeArgs:
    def __init__(__self__, *,
                 estimated_db_server_patching_time: Optional[pulumi.Input[int]] = None,
                 estimated_network_switches_patching_time: Optional[pulumi.Input[int]] = None,
                 estimated_storage_server_patching_time: Optional[pulumi.Input[int]] = None,
                 total_estimated_patching_time: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] estimated_db_server_patching_time: The estimated time required in minutes for database server patching.
        :param pulumi.Input[int] estimated_network_switches_patching_time: The estimated time required in minutes for network switch patching.
        :param pulumi.Input[int] estimated_storage_server_patching_time: The estimated time required in minutes for storage server patching.
        :param pulumi.Input[int] total_estimated_patching_time: The estimated total time required in minutes for all patching operations.
        """
        if estimated_db_server_patching_time is not None:
            pulumi.set(__self__, "estimated_db_server_patching_time", estimated_db_server_patching_time)
        if estimated_network_switches_patching_time is not None:
            pulumi.set(__self__, "estimated_network_switches_patching_time", estimated_network_switches_patching_time)
        if estimated_storage_server_patching_time is not None:
            pulumi.set(__self__, "estimated_storage_server_patching_time", estimated_storage_server_patching_time)
        if total_estimated_patching_time is not None:
            pulumi.set(__self__, "total_estimated_patching_time", total_estimated_patching_time)

    @property
    @pulumi.getter(name="estimatedDbServerPatchingTime")
    def estimated_db_server_patching_time(self) -> Optional[pulumi.Input[int]]:
        """
        The estimated time required in minutes for database server patching.
        """
        return pulumi.get(self, "estimated_db_server_patching_time")

    @estimated_db_server_patching_time.setter
    def estimated_db_server_patching_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "estimated_db_server_patching_time", value)

    @property
    @pulumi.getter(name="estimatedNetworkSwitchesPatchingTime")
    def estimated_network_switches_patching_time(self) -> Optional[pulumi.Input[int]]:
        """
        The estimated time required in minutes for network switch patching.
        """
        return pulumi.get(self, "estimated_network_switches_patching_time")

    @estimated_network_switches_patching_time.setter
    def estimated_network_switches_patching_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "estimated_network_switches_patching_time", value)

    @property
    @pulumi.getter(name="estimatedStorageServerPatchingTime")
    def estimated_storage_server_patching_time(self) -> Optional[pulumi.Input[int]]:
        """
        The estimated time required in minutes for storage server patching.
        """
        return pulumi.get(self, "estimated_storage_server_patching_time")

    @estimated_storage_server_patching_time.setter
    def estimated_storage_server_patching_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "estimated_storage_server_patching_time", value)

    @property
    @pulumi.getter(name="totalEstimatedPatchingTime")
    def total_estimated_patching_time(self) -> Optional[pulumi.Input[int]]:
        """
        The estimated total time required in minutes for all patching operations.
        """
        return pulumi.get(self, "total_estimated_patching_time")

    @total_estimated_patching_time.setter
    def total_estimated_patching_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "total_estimated_patching_time", value)


@pulumi.input_type
class PluggableDatabaseConnectionStringArgs:
    def __init__(__self__, *,
                 all_connection_strings: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 pdb_default: Optional[pulumi.Input[str]] = None,
                 pdb_ip_default: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, Any]] all_connection_strings: All connection strings to use to connect to the pluggable database.
        :param pulumi.Input[str] pdb_default: A host name-based PDB connection string.
        :param pulumi.Input[str] pdb_ip_default: An IP-based PDB connection string.
        """
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if pdb_default is not None:
            pulumi.set(__self__, "pdb_default", pdb_default)
        if pdb_ip_default is not None:
            pulumi.set(__self__, "pdb_ip_default", pdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        All connection strings to use to connect to the pluggable database.
        """
        return pulumi.get(self, "all_connection_strings")

    @all_connection_strings.setter
    def all_connection_strings(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "all_connection_strings", value)

    @property
    @pulumi.getter(name="pdbDefault")
    def pdb_default(self) -> Optional[pulumi.Input[str]]:
        """
        A host name-based PDB connection string.
        """
        return pulumi.get(self, "pdb_default")

    @pdb_default.setter
    def pdb_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pdb_default", value)

    @property
    @pulumi.getter(name="pdbIpDefault")
    def pdb_ip_default(self) -> Optional[pulumi.Input[str]]:
        """
        An IP-based PDB connection string.
        """
        return pulumi.get(self, "pdb_ip_default")

    @pdb_ip_default.setter
    def pdb_ip_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pdb_ip_default", value)


@pulumi.input_type
class PluggableDatabaseManagementsManagementConnectionStringArgs:
    def __init__(__self__, *,
                 enable_pluggabledatabasemanagement: pulumi.Input[bool],
                 all_connection_strings: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 pdb_default: Optional[pulumi.Input[str]] = None,
                 pdb_ip_default: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enable_pluggabledatabasemanagement: (Updatable) A required field when set to `true` calls enable action and when set to `false` calls disable action.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param pulumi.Input[Mapping[str, Any]] all_connection_strings: All connection strings to use to connect to the pluggable database.
        :param pulumi.Input[str] pdb_default: A host name-based PDB connection string.
        :param pulumi.Input[str] pdb_ip_default: An IP-based PDB connection string.
        """
        pulumi.set(__self__, "enable_pluggabledatabasemanagement", enable_pluggabledatabasemanagement)
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if pdb_default is not None:
            pulumi.set(__self__, "pdb_default", pdb_default)
        if pdb_ip_default is not None:
            pulumi.set(__self__, "pdb_ip_default", pdb_ip_default)

    @property
    @pulumi.getter(name="enablePluggabledatabasemanagement")
    def enable_pluggabledatabasemanagement(self) -> pulumi.Input[bool]:
        """
        (Updatable) A required field when set to `true` calls enable action and when set to `false` calls disable action.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "enable_pluggabledatabasemanagement")

    @enable_pluggabledatabasemanagement.setter
    def enable_pluggabledatabasemanagement(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enable_pluggabledatabasemanagement", value)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        All connection strings to use to connect to the pluggable database.
        """
        return pulumi.get(self, "all_connection_strings")

    @all_connection_strings.setter
    def all_connection_strings(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "all_connection_strings", value)

    @property
    @pulumi.getter(name="pdbDefault")
    def pdb_default(self) -> Optional[pulumi.Input[str]]:
        """
        A host name-based PDB connection string.
        """
        return pulumi.get(self, "pdb_default")

    @pdb_default.setter
    def pdb_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pdb_default", value)

    @property
    @pulumi.getter(name="pdbIpDefault")
    def pdb_ip_default(self) -> Optional[pulumi.Input[str]]:
        """
        An IP-based PDB connection string.
        """
        return pulumi.get(self, "pdb_ip_default")

    @pdb_ip_default.setter
    def pdb_ip_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pdb_ip_default", value)


@pulumi.input_type
class PluggableDatabaseManagementsManagementCredentialDetailsArgs:
    def __init__(__self__, *,
                 password_secret_id: pulumi.Input[str],
                 user_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password_secret_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        :param pulumi.Input[str] user_name: The name of the Oracle Database user that will be used to connect to the database.
        """
        pulumi.set(__self__, "password_secret_id", password_secret_id)
        pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="passwordSecretId")
    def password_secret_id(self) -> pulumi.Input[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "password_secret_id")

    @password_secret_id.setter
    def password_secret_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "password_secret_id", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> pulumi.Input[str]:
        """
        The name of the Oracle Database user that will be used to connect to the database.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class PluggableDatabaseManagementsManagementPluggableDatabaseManagementConfigArgs:
    def __init__(__self__, *,
                 enable_pluggabledatabasemanagement: pulumi.Input[bool],
                 management_status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enable_pluggabledatabasemanagement: (Updatable) A required field when set to `true` calls enable action and when set to `false` calls disable action.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param pulumi.Input[str] management_status: The status of the Pluggable Database Management service.
        """
        pulumi.set(__self__, "enable_pluggabledatabasemanagement", enable_pluggabledatabasemanagement)
        if management_status is not None:
            pulumi.set(__self__, "management_status", management_status)

    @property
    @pulumi.getter(name="enablePluggabledatabasemanagement")
    def enable_pluggabledatabasemanagement(self) -> pulumi.Input[bool]:
        """
        (Updatable) A required field when set to `true` calls enable action and when set to `false` calls disable action.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "enable_pluggabledatabasemanagement")

    @enable_pluggabledatabasemanagement.setter
    def enable_pluggabledatabasemanagement(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enable_pluggabledatabasemanagement", value)

    @property
    @pulumi.getter(name="managementStatus")
    def management_status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the Pluggable Database Management service.
        """
        return pulumi.get(self, "management_status")

    @management_status.setter
    def management_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "management_status", value)


@pulumi.input_type
class PluggableDatabasePdbCreationTypeDetailsArgs:
    def __init__(__self__, *,
                 creation_type: pulumi.Input[str],
                 source_pluggable_database_id: pulumi.Input[str],
                 dblink_user_password: Optional[pulumi.Input[str]] = None,
                 dblink_username: Optional[pulumi.Input[str]] = None,
                 refreshable_clone_details: Optional[pulumi.Input['PluggableDatabasePdbCreationTypeDetailsRefreshableCloneDetailsArgs']] = None,
                 source_container_database_admin_password: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] creation_type: The Pluggable Database creation type.
        :param pulumi.Input[str] source_pluggable_database_id: The OCID of the Source Pluggable Database.
        :param pulumi.Input[str] dblink_user_password: The DB link user password.
        :param pulumi.Input[str] dblink_username: The name of the DB link user.
        :param pulumi.Input['PluggableDatabasePdbCreationTypeDetailsRefreshableCloneDetailsArgs'] refreshable_clone_details: Parameters for creating Pluggable Database Refreshable Clone. **Warning:** Oracle recommends that you avoid using any confidential information when you supply string values using the API.
        :param pulumi.Input[str] source_container_database_admin_password: The DB system administrator password of the source Container Database.
        """
        pulumi.set(__self__, "creation_type", creation_type)
        pulumi.set(__self__, "source_pluggable_database_id", source_pluggable_database_id)
        if dblink_user_password is not None:
            pulumi.set(__self__, "dblink_user_password", dblink_user_password)
        if dblink_username is not None:
            pulumi.set(__self__, "dblink_username", dblink_username)
        if refreshable_clone_details is not None:
            pulumi.set(__self__, "refreshable_clone_details", refreshable_clone_details)
        if source_container_database_admin_password is not None:
            pulumi.set(__self__, "source_container_database_admin_password", source_container_database_admin_password)

    @property
    @pulumi.getter(name="creationType")
    def creation_type(self) -> pulumi.Input[str]:
        """
        The Pluggable Database creation type.
        """
        return pulumi.get(self, "creation_type")

    @creation_type.setter
    def creation_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "creation_type", value)

    @property
    @pulumi.getter(name="sourcePluggableDatabaseId")
    def source_pluggable_database_id(self) -> pulumi.Input[str]:
        """
        The OCID of the Source Pluggable Database.
        """
        return pulumi.get(self, "source_pluggable_database_id")

    @source_pluggable_database_id.setter
    def source_pluggable_database_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_pluggable_database_id", value)

    @property
    @pulumi.getter(name="dblinkUserPassword")
    def dblink_user_password(self) -> Optional[pulumi.Input[str]]:
        """
        The DB link user password.
        """
        return pulumi.get(self, "dblink_user_password")

    @dblink_user_password.setter
    def dblink_user_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dblink_user_password", value)

    @property
    @pulumi.getter(name="dblinkUsername")
    def dblink_username(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the DB link user.
        """
        return pulumi.get(self, "dblink_username")

    @dblink_username.setter
    def dblink_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dblink_username", value)

    @property
    @pulumi.getter(name="refreshableCloneDetails")
    def refreshable_clone_details(self) -> Optional[pulumi.Input['PluggableDatabasePdbCreationTypeDetailsRefreshableCloneDetailsArgs']]:
        """
        Parameters for creating Pluggable Database Refreshable Clone. **Warning:** Oracle recommends that you avoid using any confidential information when you supply string values using the API.
        """
        return pulumi.get(self, "refreshable_clone_details")

    @refreshable_clone_details.setter
    def refreshable_clone_details(self, value: Optional[pulumi.Input['PluggableDatabasePdbCreationTypeDetailsRefreshableCloneDetailsArgs']]):
        pulumi.set(self, "refreshable_clone_details", value)

    @property
    @pulumi.getter(name="sourceContainerDatabaseAdminPassword")
    def source_container_database_admin_password(self) -> Optional[pulumi.Input[str]]:
        """
        The DB system administrator password of the source Container Database.
        """
        return pulumi.get(self, "source_container_database_admin_password")

    @source_container_database_admin_password.setter
    def source_container_database_admin_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_container_database_admin_password", value)


@pulumi.input_type
class PluggableDatabasePdbCreationTypeDetailsRefreshableCloneDetailsArgs:
    def __init__(__self__, *,
                 is_refreshable_clone: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_refreshable_clone: Indicates whether Pluggable Database is a refreshable clone.
        """
        if is_refreshable_clone is not None:
            pulumi.set(__self__, "is_refreshable_clone", is_refreshable_clone)

    @property
    @pulumi.getter(name="isRefreshableClone")
    def is_refreshable_clone(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether Pluggable Database is a refreshable clone.
        """
        return pulumi.get(self, "is_refreshable_clone")

    @is_refreshable_clone.setter
    def is_refreshable_clone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_refreshable_clone", value)


@pulumi.input_type
class PluggableDatabasePdbNodeLevelDetailArgs:
    def __init__(__self__, *,
                 node_name: Optional[pulumi.Input[str]] = None,
                 open_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] node_name: The Node name of the Database Instance.
        :param pulumi.Input[str] open_mode: The mode that pluggable database is in. Open mode can only be changed to READ_ONLY or MIGRATE directly from the backend (within the Oracle Database software).
        """
        if node_name is not None:
            pulumi.set(__self__, "node_name", node_name)
        if open_mode is not None:
            pulumi.set(__self__, "open_mode", open_mode)

    @property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> Optional[pulumi.Input[str]]:
        """
        The Node name of the Database Instance.
        """
        return pulumi.get(self, "node_name")

    @node_name.setter
    def node_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_name", value)

    @property
    @pulumi.getter(name="openMode")
    def open_mode(self) -> Optional[pulumi.Input[str]]:
        """
        The mode that pluggable database is in. Open mode can only be changed to READ_ONLY or MIGRATE directly from the backend (within the Oracle Database software).
        """
        return pulumi.get(self, "open_mode")

    @open_mode.setter
    def open_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "open_mode", value)


@pulumi.input_type
class PluggableDatabasePluggableDatabaseManagementConfigArgs:
    def __init__(__self__, *,
                 management_status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] management_status: The status of the Pluggable Database Management service.
        """
        if management_status is not None:
            pulumi.set(__self__, "management_status", management_status)

    @property
    @pulumi.getter(name="managementStatus")
    def management_status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the Pluggable Database Management service.
        """
        return pulumi.get(self, "management_status")

    @management_status.setter
    def management_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "management_status", value)


@pulumi.input_type
class PluggableDatabaseRefreshableCloneConfigArgs:
    def __init__(__self__, *,
                 is_refreshable_clone: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_refreshable_clone: Indicates whether Pluggable Database is a refreshable clone.
        """
        if is_refreshable_clone is not None:
            pulumi.set(__self__, "is_refreshable_clone", is_refreshable_clone)

    @property
    @pulumi.getter(name="isRefreshableClone")
    def is_refreshable_clone(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether Pluggable Database is a refreshable clone.
        """
        return pulumi.get(self, "is_refreshable_clone")

    @is_refreshable_clone.setter
    def is_refreshable_clone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_refreshable_clone", value)


@pulumi.input_type
class PluggableDatabasesLocalCloneConnectionStringArgs:
    def __init__(__self__, *,
                 all_connection_strings: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 pdb_default: Optional[pulumi.Input[str]] = None,
                 pdb_ip_default: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, Any]] all_connection_strings: All connection strings to use to connect to the pluggable database.
        :param pulumi.Input[str] pdb_default: A host name-based PDB connection string.
        :param pulumi.Input[str] pdb_ip_default: An IP-based PDB connection string.
        """
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if pdb_default is not None:
            pulumi.set(__self__, "pdb_default", pdb_default)
        if pdb_ip_default is not None:
            pulumi.set(__self__, "pdb_ip_default", pdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        All connection strings to use to connect to the pluggable database.
        """
        return pulumi.get(self, "all_connection_strings")

    @all_connection_strings.setter
    def all_connection_strings(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "all_connection_strings", value)

    @property
    @pulumi.getter(name="pdbDefault")
    def pdb_default(self) -> Optional[pulumi.Input[str]]:
        """
        A host name-based PDB connection string.
        """
        return pulumi.get(self, "pdb_default")

    @pdb_default.setter
    def pdb_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pdb_default", value)

    @property
    @pulumi.getter(name="pdbIpDefault")
    def pdb_ip_default(self) -> Optional[pulumi.Input[str]]:
        """
        An IP-based PDB connection string.
        """
        return pulumi.get(self, "pdb_ip_default")

    @pdb_ip_default.setter
    def pdb_ip_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pdb_ip_default", value)


@pulumi.input_type
class PluggableDatabasesLocalClonePdbNodeLevelDetailArgs:
    def __init__(__self__, *,
                 node_name: Optional[pulumi.Input[str]] = None,
                 open_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] node_name: The Node name of the Database Instance.
        :param pulumi.Input[str] open_mode: The mode that pluggable database is in. Open mode can only be changed to READ_ONLY or MIGRATE directly from the backend (within the Oracle Database software).
        """
        if node_name is not None:
            pulumi.set(__self__, "node_name", node_name)
        if open_mode is not None:
            pulumi.set(__self__, "open_mode", open_mode)

    @property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> Optional[pulumi.Input[str]]:
        """
        The Node name of the Database Instance.
        """
        return pulumi.get(self, "node_name")

    @node_name.setter
    def node_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_name", value)

    @property
    @pulumi.getter(name="openMode")
    def open_mode(self) -> Optional[pulumi.Input[str]]:
        """
        The mode that pluggable database is in. Open mode can only be changed to READ_ONLY or MIGRATE directly from the backend (within the Oracle Database software).
        """
        return pulumi.get(self, "open_mode")

    @open_mode.setter
    def open_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "open_mode", value)


@pulumi.input_type
class PluggableDatabasesLocalClonePluggableDatabaseManagementConfigArgs:
    def __init__(__self__, *,
                 management_status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] management_status: The status of the Pluggable Database Management service.
        """
        if management_status is not None:
            pulumi.set(__self__, "management_status", management_status)

    @property
    @pulumi.getter(name="managementStatus")
    def management_status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the Pluggable Database Management service.
        """
        return pulumi.get(self, "management_status")

    @management_status.setter
    def management_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "management_status", value)


@pulumi.input_type
class PluggableDatabasesLocalCloneRefreshableCloneConfigArgs:
    def __init__(__self__, *,
                 is_refreshable_clone: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_refreshable_clone: Indicates whether the Pluggable Database is a refreshable clone.
        """
        if is_refreshable_clone is not None:
            pulumi.set(__self__, "is_refreshable_clone", is_refreshable_clone)

    @property
    @pulumi.getter(name="isRefreshableClone")
    def is_refreshable_clone(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the Pluggable Database is a refreshable clone.
        """
        return pulumi.get(self, "is_refreshable_clone")

    @is_refreshable_clone.setter
    def is_refreshable_clone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_refreshable_clone", value)


@pulumi.input_type
class PluggableDatabasesRemoteCloneConnectionStringArgs:
    def __init__(__self__, *,
                 all_connection_strings: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 pdb_default: Optional[pulumi.Input[str]] = None,
                 pdb_ip_default: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, Any]] all_connection_strings: All connection strings to use to connect to the pluggable database.
        :param pulumi.Input[str] pdb_default: A host name-based PDB connection string.
        :param pulumi.Input[str] pdb_ip_default: An IP-based PDB connection string.
        """
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if pdb_default is not None:
            pulumi.set(__self__, "pdb_default", pdb_default)
        if pdb_ip_default is not None:
            pulumi.set(__self__, "pdb_ip_default", pdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        All connection strings to use to connect to the pluggable database.
        """
        return pulumi.get(self, "all_connection_strings")

    @all_connection_strings.setter
    def all_connection_strings(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "all_connection_strings", value)

    @property
    @pulumi.getter(name="pdbDefault")
    def pdb_default(self) -> Optional[pulumi.Input[str]]:
        """
        A host name-based PDB connection string.
        """
        return pulumi.get(self, "pdb_default")

    @pdb_default.setter
    def pdb_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pdb_default", value)

    @property
    @pulumi.getter(name="pdbIpDefault")
    def pdb_ip_default(self) -> Optional[pulumi.Input[str]]:
        """
        An IP-based PDB connection string.
        """
        return pulumi.get(self, "pdb_ip_default")

    @pdb_ip_default.setter
    def pdb_ip_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pdb_ip_default", value)


@pulumi.input_type
class PluggableDatabasesRemoteClonePdbNodeLevelDetailArgs:
    def __init__(__self__, *,
                 node_name: Optional[pulumi.Input[str]] = None,
                 open_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] node_name: The Node name of the Database Instance.
        :param pulumi.Input[str] open_mode: The mode that pluggable database is in. Open mode can only be changed to READ_ONLY or MIGRATE directly from the backend (within the Oracle Database software).
        """
        if node_name is not None:
            pulumi.set(__self__, "node_name", node_name)
        if open_mode is not None:
            pulumi.set(__self__, "open_mode", open_mode)

    @property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> Optional[pulumi.Input[str]]:
        """
        The Node name of the Database Instance.
        """
        return pulumi.get(self, "node_name")

    @node_name.setter
    def node_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_name", value)

    @property
    @pulumi.getter(name="openMode")
    def open_mode(self) -> Optional[pulumi.Input[str]]:
        """
        The mode that pluggable database is in. Open mode can only be changed to READ_ONLY or MIGRATE directly from the backend (within the Oracle Database software).
        """
        return pulumi.get(self, "open_mode")

    @open_mode.setter
    def open_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "open_mode", value)


@pulumi.input_type
class PluggableDatabasesRemoteClonePluggableDatabaseManagementConfigArgs:
    def __init__(__self__, *,
                 management_status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] management_status: The status of the Pluggable Database Management service.
        """
        if management_status is not None:
            pulumi.set(__self__, "management_status", management_status)

    @property
    @pulumi.getter(name="managementStatus")
    def management_status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the Pluggable Database Management service.
        """
        return pulumi.get(self, "management_status")

    @management_status.setter
    def management_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "management_status", value)


@pulumi.input_type
class PluggableDatabasesRemoteCloneRefreshableCloneConfigArgs:
    def __init__(__self__, *,
                 is_refreshable_clone: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_refreshable_clone: Indicates whether the Pluggable Database is a refreshable clone.
        """
        if is_refreshable_clone is not None:
            pulumi.set(__self__, "is_refreshable_clone", is_refreshable_clone)

    @property
    @pulumi.getter(name="isRefreshableClone")
    def is_refreshable_clone(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the Pluggable Database is a refreshable clone.
        """
        return pulumi.get(self, "is_refreshable_clone")

    @is_refreshable_clone.setter
    def is_refreshable_clone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_refreshable_clone", value)


@pulumi.input_type
class VmClusterAddVirtualNetworkDataCollectionOptionArgs:
    def __init__(__self__, *,
                 is_diagnostics_events_enabled: Optional[pulumi.Input[bool]] = None,
                 is_health_monitoring_enabled: Optional[pulumi.Input[bool]] = None,
                 is_incident_logs_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_diagnostics_events_enabled: Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param pulumi.Input[bool] is_health_monitoring_enabled: Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param pulumi.Input[bool] is_incident_logs_enabled: Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        if is_diagnostics_events_enabled is not None:
            pulumi.set(__self__, "is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        if is_health_monitoring_enabled is not None:
            pulumi.set(__self__, "is_health_monitoring_enabled", is_health_monitoring_enabled)
        if is_incident_logs_enabled is not None:
            pulumi.set(__self__, "is_incident_logs_enabled", is_incident_logs_enabled)

    @property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @is_diagnostics_events_enabled.setter
    def is_diagnostics_events_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_diagnostics_events_enabled", value)

    @property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @is_health_monitoring_enabled.setter
    def is_health_monitoring_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_health_monitoring_enabled", value)

    @property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")

    @is_incident_logs_enabled.setter
    def is_incident_logs_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_incident_logs_enabled", value)


@pulumi.input_type
class VmClusterAddVirtualNetworkDbServerArgs:
    def __init__(__self__, *,
                 db_server_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] db_server_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of Exacc Db server.
        """
        pulumi.set(__self__, "db_server_id", db_server_id)

    @property
    @pulumi.getter(name="dbServerId")
    def db_server_id(self) -> pulumi.Input[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of Exacc Db server.
        """
        return pulumi.get(self, "db_server_id")

    @db_server_id.setter
    def db_server_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "db_server_id", value)


@pulumi.input_type
class VmClusterDataCollectionOptionsArgs:
    def __init__(__self__, *,
                 is_diagnostics_events_enabled: Optional[pulumi.Input[bool]] = None,
                 is_health_monitoring_enabled: Optional[pulumi.Input[bool]] = None,
                 is_incident_logs_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_diagnostics_events_enabled: (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param pulumi.Input[bool] is_health_monitoring_enabled: (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param pulumi.Input[bool] is_incident_logs_enabled: (Updatable) Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        if is_diagnostics_events_enabled is not None:
            pulumi.set(__self__, "is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        if is_health_monitoring_enabled is not None:
            pulumi.set(__self__, "is_health_monitoring_enabled", is_health_monitoring_enabled)
        if is_incident_logs_enabled is not None:
            pulumi.set(__self__, "is_incident_logs_enabled", is_incident_logs_enabled)

    @property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @is_diagnostics_events_enabled.setter
    def is_diagnostics_events_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_diagnostics_events_enabled", value)

    @property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @is_health_monitoring_enabled.setter
    def is_health_monitoring_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_health_monitoring_enabled", value)

    @property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")

    @is_incident_logs_enabled.setter
    def is_incident_logs_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_incident_logs_enabled", value)


@pulumi.input_type
class VmClusterNetworkDrScanArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[str],
                 ips: pulumi.Input[Sequence[pulumi.Input[str]]],
                 scan_listener_port_tcp: pulumi.Input[int]):
        """
        :param pulumi.Input[str] hostname: (Updatable) The node host name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: (Updatable) The list of SCAN IP addresses. Three addresses should be provided.
        :param pulumi.Input[int] scan_listener_port_tcp: (Updatable) The SCAN TCPIP port. Default is 1521.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "scan_listener_port_tcp", scan_listener_port_tcp)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[str]:
        """
        (Updatable) The node host name.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def ips(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        (Updatable) The list of SCAN IP addresses. Three addresses should be provided.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="scanListenerPortTcp")
    def scan_listener_port_tcp(self) -> pulumi.Input[int]:
        """
        (Updatable) The SCAN TCPIP port. Default is 1521.
        """
        return pulumi.get(self, "scan_listener_port_tcp")

    @scan_listener_port_tcp.setter
    def scan_listener_port_tcp(self, value: pulumi.Input[int]):
        pulumi.set(self, "scan_listener_port_tcp", value)


@pulumi.input_type
class VmClusterNetworkScanArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[str],
                 ips: pulumi.Input[Sequence[pulumi.Input[str]]],
                 port: Optional[pulumi.Input[int]] = None,
                 scan_listener_port_tcp: Optional[pulumi.Input[int]] = None,
                 scan_listener_port_tcp_ssl: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] hostname: (Updatable) The node host name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: (Updatable) The list of SCAN IP addresses. Three addresses should be provided.
        :param pulumi.Input[int] port: (Updatable) **Deprecated.** This field is deprecated. You may use 'scanListenerPortTcp' to specify the port. The SCAN TCPIP port. Default is 1521.
        :param pulumi.Input[int] scan_listener_port_tcp: (Updatable) The SCAN TCPIP port. Default is 1521.
        :param pulumi.Input[int] scan_listener_port_tcp_ssl: (Updatable) The SCAN TCPIP SSL port. Default is 2484.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "ips", ips)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scan_listener_port_tcp is not None:
            pulumi.set(__self__, "scan_listener_port_tcp", scan_listener_port_tcp)
        if scan_listener_port_tcp_ssl is not None:
            pulumi.set(__self__, "scan_listener_port_tcp_ssl", scan_listener_port_tcp_ssl)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[str]:
        """
        (Updatable) The node host name.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def ips(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        (Updatable) The list of SCAN IP addresses. Three addresses should be provided.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) **Deprecated.** This field is deprecated. You may use 'scanListenerPortTcp' to specify the port. The SCAN TCPIP port. Default is 1521.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="scanListenerPortTcp")
    def scan_listener_port_tcp(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The SCAN TCPIP port. Default is 1521.
        """
        return pulumi.get(self, "scan_listener_port_tcp")

    @scan_listener_port_tcp.setter
    def scan_listener_port_tcp(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "scan_listener_port_tcp", value)

    @property
    @pulumi.getter(name="scanListenerPortTcpSsl")
    def scan_listener_port_tcp_ssl(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The SCAN TCPIP SSL port. Default is 2484.
        """
        return pulumi.get(self, "scan_listener_port_tcp_ssl")

    @scan_listener_port_tcp_ssl.setter
    def scan_listener_port_tcp_ssl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "scan_listener_port_tcp_ssl", value)


@pulumi.input_type
class VmClusterNetworkVmNetworkArgs:
    def __init__(__self__, *,
                 network_type: pulumi.Input[str],
                 nodes: pulumi.Input[Sequence[pulumi.Input['VmClusterNetworkVmNetworkNodeArgs']]],
                 domain_name: Optional[pulumi.Input[str]] = None,
                 gateway: Optional[pulumi.Input[str]] = None,
                 netmask: Optional[pulumi.Input[str]] = None,
                 vlan_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] network_type: (Updatable) The network type.
        :param pulumi.Input[Sequence[pulumi.Input['VmClusterNetworkVmNetworkNodeArgs']]] nodes: (Updatable) The list of node details.
        :param pulumi.Input[str] domain_name: (Updatable) The network domain name.
        :param pulumi.Input[str] gateway: (Updatable) The network gateway.
        :param pulumi.Input[str] netmask: (Updatable) The network netmask.
        :param pulumi.Input[str] vlan_id: (Updatable) The network VLAN ID.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        pulumi.set(__self__, "network_type", network_type)
        pulumi.set(__self__, "nodes", nodes)
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> pulumi.Input[str]:
        """
        (Updatable) The network type.
        """
        return pulumi.get(self, "network_type")

    @network_type.setter
    def network_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_type", value)

    @property
    @pulumi.getter
    def nodes(self) -> pulumi.Input[Sequence[pulumi.Input['VmClusterNetworkVmNetworkNodeArgs']]]:
        """
        (Updatable) The list of node details.
        """
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: pulumi.Input[Sequence[pulumi.Input['VmClusterNetworkVmNetworkNodeArgs']]]):
        pulumi.set(self, "nodes", value)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The network domain name.
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_name", value)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The network gateway.
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter
    def netmask(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The network netmask.
        """
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "netmask", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The network VLAN ID.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vlan_id", value)


@pulumi.input_type
class VmClusterNetworkVmNetworkNodeArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[str],
                 ip: pulumi.Input[str],
                 db_server_id: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 vip: Optional[pulumi.Input[str]] = None,
                 vip_hostname: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] hostname: (Updatable) The node host name.
        :param pulumi.Input[str] ip: (Updatable) The node IP address.
        :param pulumi.Input[str] db_server_id: (Updatable) The Db server associated with the node.
        :param pulumi.Input[str] state: (Updatable) The current state of the VM cluster network nodes. CREATING - The resource is being created REQUIRES_VALIDATION - The resource is created and may not be usable until it is validated. VALIDATING - The resource is being validated and not available to use. VALIDATED - The resource is validated and is available for consumption by VM cluster. VALIDATION_FAILED - The resource validation has failed and might require user input to be corrected. UPDATING - The resource is being updated and not available to use. ALLOCATED - The resource is currently being used by VM cluster. TERMINATING - The resource is being deleted and not available to use. TERMINATED - The resource is deleted and unavailable. FAILED - The resource is in a failed state due to validation or other errors.
        :param pulumi.Input[str] vip: (Updatable) The node virtual IP (VIP) address.
        :param pulumi.Input[str] vip_hostname: (Updatable) The node virtual IP (VIP) host name.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "ip", ip)
        if db_server_id is not None:
            pulumi.set(__self__, "db_server_id", db_server_id)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if vip is not None:
            pulumi.set(__self__, "vip", vip)
        if vip_hostname is not None:
            pulumi.set(__self__, "vip_hostname", vip_hostname)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[str]:
        """
        (Updatable) The node host name.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        (Updatable) The node IP address.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="dbServerId")
    def db_server_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The Db server associated with the node.
        """
        return pulumi.get(self, "db_server_id")

    @db_server_id.setter
    def db_server_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_server_id", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The current state of the VM cluster network nodes. CREATING - The resource is being created REQUIRES_VALIDATION - The resource is created and may not be usable until it is validated. VALIDATING - The resource is being validated and not available to use. VALIDATED - The resource is validated and is available for consumption by VM cluster. VALIDATION_FAILED - The resource validation has failed and might require user input to be corrected. UPDATING - The resource is being updated and not available to use. ALLOCATED - The resource is currently being used by VM cluster. TERMINATING - The resource is being deleted and not available to use. TERMINATED - The resource is deleted and unavailable. FAILED - The resource is in a failed state due to validation or other errors.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def vip(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The node virtual IP (VIP) address.
        """
        return pulumi.get(self, "vip")

    @vip.setter
    def vip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vip", value)

    @property
    @pulumi.getter(name="vipHostname")
    def vip_hostname(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The node virtual IP (VIP) host name.
        """
        return pulumi.get(self, "vip_hostname")

    @vip_hostname.setter
    def vip_hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vip_hostname", value)


@pulumi.input_type
class VmClusterRemoveVirtualMachineDataCollectionOptionArgs:
    def __init__(__self__, *,
                 is_diagnostics_events_enabled: Optional[pulumi.Input[bool]] = None,
                 is_health_monitoring_enabled: Optional[pulumi.Input[bool]] = None,
                 is_incident_logs_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_diagnostics_events_enabled: Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param pulumi.Input[bool] is_health_monitoring_enabled: Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param pulumi.Input[bool] is_incident_logs_enabled: Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        if is_diagnostics_events_enabled is not None:
            pulumi.set(__self__, "is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        if is_health_monitoring_enabled is not None:
            pulumi.set(__self__, "is_health_monitoring_enabled", is_health_monitoring_enabled)
        if is_incident_logs_enabled is not None:
            pulumi.set(__self__, "is_incident_logs_enabled", is_incident_logs_enabled)

    @property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @is_diagnostics_events_enabled.setter
    def is_diagnostics_events_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_diagnostics_events_enabled", value)

    @property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @is_health_monitoring_enabled.setter
    def is_health_monitoring_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_health_monitoring_enabled", value)

    @property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")

    @is_incident_logs_enabled.setter
    def is_incident_logs_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_incident_logs_enabled", value)


@pulumi.input_type
class VmClusterRemoveVirtualMachineDbServerArgs:
    def __init__(__self__, *,
                 db_server_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] db_server_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of Exacc Db server.
        """
        pulumi.set(__self__, "db_server_id", db_server_id)

    @property
    @pulumi.getter(name="dbServerId")
    def db_server_id(self) -> pulumi.Input[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of Exacc Db server.
        """
        return pulumi.get(self, "db_server_id")

    @db_server_id.setter
    def db_server_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "db_server_id", value)


@pulumi.input_type
class GetApplicationVipsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetAutonomousCharacterSetsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A valid Oracle character set.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A valid Oracle character set.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetAutonomousContainerDatabaseDataguardAssociationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetAutonomousContainerDatabaseVersionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetAutonomousContainerDatabasesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetAutonomousContainerPatchesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetAutonomousDatabaseBackupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetAutonomousDatabaseDataguardAssociationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetAutonomousDatabaseRefreshableClonesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetAutonomousDatabasesClonesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the day of the week.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the day of the week.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetAutonomousDatabasesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the day of the week.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the day of the week.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetAutonomousDbPreviewVersionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetAutonomousDbVersionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetAutonomousExadataInfrastructureShapesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the shape used for the Autonomous Exadata Infrastructure.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the shape used for the Autonomous Exadata Infrastructure.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetAutonomousExadataInfrastructuresFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetAutonomousVirtualMachinesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetAutonomousVmClusterAcdResourceUsagesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetAutonomousVmClustersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetBackupDestinationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetBackupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCloudAutonomousVmClusterAcdResourceUsagesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCloudAutonomousVmClustersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCloudExadataInfrastructuresFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCloudVmClustersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDataGuardAssociationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseMaintenanceRunHistoriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabasePdbConversionHistoryEntriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseSoftwareImagesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseUpgradeHistoryEntriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabasesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDbHomePatchHistoryEntriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDbHomePatchesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDbHomesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDbNodeConsoleConnectionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDbNodesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDbServersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDbSystemComputePerformancesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDbSystemHistoryEntriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDbSystemPatchesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDbSystemShapesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the shape used for the DB system.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the shape used for the DB system.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDbSystemStoragePerformancesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDbSystemsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDbSystemsUpgradeHistoryEntriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDbVersionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetExadataInfrastructuresFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetExternalContainerDatabasesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetExternalDatabaseConnectorsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetExternalNonContainerDatabasesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetExternalPluggableDatabasesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetFlexComponentsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to return only resources that match the entire name given. The match is not case sensitive.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to return only resources that match the entire name given. The match is not case sensitive.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetGiVersionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetKeyStoresFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetMaintenanceRunsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetManagedPreferredCredentialsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetOneoffPatchesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetPluggableDatabasesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetVmClusterNetworksFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetVmClusterPatchHistoryEntriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetVmClusterPatchesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetVmClusterRecommendedNetworkNetworkArgs:
    def __init__(__self__, *,
                 cidr: str,
                 domain: str,
                 gateway: str,
                 netmask: str,
                 network_type: str,
                 prefix: str,
                 vlan_id: str):
        """
        :param str cidr: The cidr for the network.
        :param str domain: The network domain name.
        :param str gateway: The network gateway.
        :param str netmask: The network netmask.
        :param str network_type: The network type.
        :param str prefix: The network domain name.
        :param str vlan_id: The network VLAN ID.
        """
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "netmask", netmask)
        pulumi.set(__self__, "network_type", network_type)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "vlan_id", vlan_id)

    @property
    @pulumi.getter
    def cidr(self) -> str:
        """
        The cidr for the network.
        """
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: str):
        pulumi.set(self, "cidr", value)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The network domain name.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: str):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        The network gateway.
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: str):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter
    def netmask(self) -> str:
        """
        The network netmask.
        """
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: str):
        pulumi.set(self, "netmask", value)

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> str:
        """
        The network type.
        """
        return pulumi.get(self, "network_type")

    @network_type.setter
    def network_type(self, value: str):
        pulumi.set(self, "network_type", value)

    @property
    @pulumi.getter
    def prefix(self) -> str:
        """
        The network domain name.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: str):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> str:
        """
        The network VLAN ID.
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: str):
        pulumi.set(self, "vlan_id", value)


@pulumi.input_type
class GetVmClusterUpdateHistoryEntriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetVmClusterUpdatesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetVmClustersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


