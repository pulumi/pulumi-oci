# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'AutonomousContainerDatabaseBackupConfig',
    'AutonomousContainerDatabaseBackupConfigBackupDestinationDetails',
    'AutonomousContainerDatabaseKeyHistoryEntry',
    'AutonomousContainerDatabaseMaintenanceWindow',
    'AutonomousContainerDatabaseMaintenanceWindowDaysOfWeek',
    'AutonomousContainerDatabaseMaintenanceWindowDetails',
    'AutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeek',
    'AutonomousContainerDatabaseMaintenanceWindowDetailsMonth',
    'AutonomousContainerDatabaseMaintenanceWindowMonth',
    'AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfig',
    'AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetail',
    'AutonomousDatabaseApexDetail',
    'AutonomousDatabaseBackupBackupDestinationDetails',
    'AutonomousDatabaseBackupConfig',
    'AutonomousDatabaseConnectionString',
    'AutonomousDatabaseConnectionStringProfile',
    'AutonomousDatabaseConnectionUrl',
    'AutonomousDatabaseCustomerContact',
    'AutonomousDatabaseKeyHistoryEntry',
    'AutonomousDatabaseLocalStandbyDb',
    'AutonomousDatabaseLongTermBackupSchedule',
    'AutonomousDatabaseRemoteDisasterRecoveryConfiguration',
    'AutonomousDatabaseResourcePoolSummary',
    'AutonomousDatabaseScheduledOperation',
    'AutonomousDatabaseScheduledOperationDayOfWeek',
    'AutonomousDatabaseStandbyDb',
    'AutonomousExadataInfrastructureMaintenanceWindow',
    'AutonomousExadataInfrastructureMaintenanceWindowDaysOfWeek',
    'AutonomousExadataInfrastructureMaintenanceWindowDetails',
    'AutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeek',
    'AutonomousExadataInfrastructureMaintenanceWindowDetailsMonth',
    'AutonomousExadataInfrastructureMaintenanceWindowMonth',
    'AutonomousVmClusterMaintenanceWindow',
    'AutonomousVmClusterMaintenanceWindowDaysOfWeek',
    'AutonomousVmClusterMaintenanceWindowDetail',
    'AutonomousVmClusterMaintenanceWindowDetailDaysOfWeek',
    'AutonomousVmClusterMaintenanceWindowDetailMonth',
    'AutonomousVmClusterMaintenanceWindowMonth',
    'BackupDestinationAssociatedDatabase',
    'BackupDestinationMountTypeDetails',
    'CloudAutonomousVmClusterMaintenanceWindow',
    'CloudAutonomousVmClusterMaintenanceWindowDaysOfWeek',
    'CloudAutonomousVmClusterMaintenanceWindowDetails',
    'CloudAutonomousVmClusterMaintenanceWindowDetailsDaysOfWeek',
    'CloudAutonomousVmClusterMaintenanceWindowDetailsMonth',
    'CloudAutonomousVmClusterMaintenanceWindowMonth',
    'CloudDatabaseManagementCredentialdetails',
    'CloudExadataInfrastructureCustomerContact',
    'CloudExadataInfrastructureMaintenanceWindow',
    'CloudExadataInfrastructureMaintenanceWindowDaysOfWeek',
    'CloudExadataInfrastructureMaintenanceWindowMonth',
    'CloudVmClusterDataCollectionOptions',
    'CloudVmClusterIormConfigCach',
    'CloudVmClusterIormConfigCachDbPlan',
    'CloudVmClusterIormConfigDbPlan',
    'DataGuardAssociationDataCollectionOptions',
    'DatabaseConnectionString',
    'DatabaseDatabase',
    'DatabaseDatabaseDbBackupConfig',
    'DatabaseDatabaseDbBackupConfigBackupDestinationDetail',
    'DatabaseDatabaseManagementConfig',
    'DatabaseDbBackupConfig',
    'DatabaseDbBackupConfigBackupDestinationDetail',
    'DatabaseUpgradeConnectionString',
    'DatabaseUpgradeDatabaseUpgradeSourceDetails',
    'DatabaseUpgradeDbBackupConfig',
    'DatabaseUpgradeDbBackupConfigBackupDestinationDetail',
    'DbHomeDatabase',
    'DbHomeDatabaseConnectionString',
    'DbHomeDatabaseDbBackupConfig',
    'DbHomeDatabaseDbBackupConfigBackupDestinationDetail',
    'DbSystemDataCollectionOptions',
    'DbSystemDbHome',
    'DbSystemDbHomeDatabase',
    'DbSystemDbHomeDatabaseConnectionString',
    'DbSystemDbHomeDatabaseDbBackupConfig',
    'DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetail',
    'DbSystemDbSystemOptions',
    'DbSystemIormConfigCach',
    'DbSystemIormConfigCachDbPlan',
    'DbSystemMaintenanceWindow',
    'DbSystemMaintenanceWindowDaysOfWeek',
    'DbSystemMaintenanceWindowDetails',
    'DbSystemMaintenanceWindowDetailsDaysOfWeek',
    'DbSystemMaintenanceWindowDetailsMonth',
    'DbSystemMaintenanceWindowMonth',
    'DbSystemsUpgradeDbSystemOption',
    'DbSystemsUpgradeIormConfigCach',
    'DbSystemsUpgradeIormConfigCachDbPlan',
    'DbSystemsUpgradeMaintenanceWindow',
    'DbSystemsUpgradeMaintenanceWindowDaysOfWeek',
    'DbSystemsUpgradeMaintenanceWindowMonth',
    'ExadataInfrastructureComputeContact',
    'ExadataInfrastructureComputeMaintenanceWindow',
    'ExadataInfrastructureComputeMaintenanceWindowDaysOfWeek',
    'ExadataInfrastructureComputeMaintenanceWindowMonth',
    'ExadataInfrastructureContact',
    'ExadataInfrastructureMaintenanceWindow',
    'ExadataInfrastructureMaintenanceWindowDaysOfWeek',
    'ExadataInfrastructureMaintenanceWindowMonth',
    'ExadataInfrastructureNetworkBondingModeDetails',
    'ExadataInfrastructureStorageContact',
    'ExadataInfrastructureStorageMaintenanceWindow',
    'ExadataInfrastructureStorageMaintenanceWindowDaysOfWeek',
    'ExadataInfrastructureStorageMaintenanceWindowMonth',
    'ExadataIormConfigDbPlan',
    'ExternalContainerDatabaseDatabaseManagementConfig',
    'ExternalContainerDatabaseStackMonitoringConfig',
    'ExternalDatabaseConnectorConnectionCredentials',
    'ExternalDatabaseConnectorConnectionString',
    'ExternalNonContainerDatabaseDatabaseManagementConfig',
    'ExternalNonContainerDatabaseOperationsInsightsConfig',
    'ExternalNonContainerDatabaseStackMonitoringConfig',
    'ExternalPluggableDatabaseDatabaseManagementConfig',
    'ExternalPluggableDatabaseOperationsInsightsConfig',
    'ExternalPluggableDatabaseStackMonitoringConfig',
    'KeyStoreAssociatedDatabase',
    'KeyStoreTypeDetails',
    'MaintenanceRunEstimatedPatchingTime',
    'PluggableDatabaseConnectionString',
    'PluggableDatabaseManagementsManagementConnectionString',
    'PluggableDatabaseManagementsManagementCredentialDetails',
    'PluggableDatabaseManagementsManagementPluggableDatabaseManagementConfig',
    'PluggableDatabasePluggableDatabaseManagementConfig',
    'PluggableDatabasesLocalCloneConnectionString',
    'PluggableDatabasesLocalClonePluggableDatabaseManagementConfig',
    'PluggableDatabasesRemoteCloneConnectionString',
    'PluggableDatabasesRemoteClonePluggableDatabaseManagementConfig',
    'VmClusterAddVirtualNetworkDataCollectionOption',
    'VmClusterAddVirtualNetworkDbServer',
    'VmClusterDataCollectionOptions',
    'VmClusterNetworkDrScan',
    'VmClusterNetworkScan',
    'VmClusterNetworkVmNetwork',
    'VmClusterNetworkVmNetworkNode',
    'VmClusterRemoveVirtualMachineDataCollectionOption',
    'VmClusterRemoveVirtualMachineDbServer',
    'GetApplicationVipsApplicationVipResult',
    'GetApplicationVipsFilterResult',
    'GetAutonomousCharacterSetsAutonomousDatabaseCharacterSetResult',
    'GetAutonomousCharacterSetsFilterResult',
    'GetAutonomousContainerDatabaseBackupConfigResult',
    'GetAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult',
    'GetAutonomousContainerDatabaseDataguardAssociationsAutonomousContainerDatabaseDataguardAssociationResult',
    'GetAutonomousContainerDatabaseDataguardAssociationsFilterResult',
    'GetAutonomousContainerDatabaseKeyHistoryEntryResult',
    'GetAutonomousContainerDatabaseMaintenanceWindowResult',
    'GetAutonomousContainerDatabaseMaintenanceWindowDaysOfWeekResult',
    'GetAutonomousContainerDatabaseMaintenanceWindowDetailResult',
    'GetAutonomousContainerDatabaseMaintenanceWindowDetailDaysOfWeekResult',
    'GetAutonomousContainerDatabaseMaintenanceWindowDetailMonthResult',
    'GetAutonomousContainerDatabaseMaintenanceWindowMonthResult',
    'GetAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigResult',
    'GetAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult',
    'GetAutonomousContainerDatabaseResourceUsageAutonomousContainerDatabaseVmUsageResult',
    'GetAutonomousContainerDatabaseVersionsAutonomousContainerDatabaseVersionResult',
    'GetAutonomousContainerDatabaseVersionsAutonomousContainerDatabaseVersionSupportedAppResult',
    'GetAutonomousContainerDatabaseVersionsFilterResult',
    'GetAutonomousContainerDatabasesAutonomousContainerDatabaseResult',
    'GetAutonomousContainerDatabasesAutonomousContainerDatabaseBackupConfigResult',
    'GetAutonomousContainerDatabasesAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult',
    'GetAutonomousContainerDatabasesAutonomousContainerDatabaseKeyHistoryEntryResult',
    'GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowResult',
    'GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDaysOfWeekResult',
    'GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailResult',
    'GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailDaysOfWeekResult',
    'GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailMonthResult',
    'GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowMonthResult',
    'GetAutonomousContainerDatabasesAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigResult',
    'GetAutonomousContainerDatabasesAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult',
    'GetAutonomousContainerDatabasesFilterResult',
    'GetAutonomousContainerPatchesAutonomousPatchResult',
    'GetAutonomousContainerPatchesFilterResult',
    'GetAutonomousDatabaseApexDetailResult',
    'GetAutonomousDatabaseBackupBackupDestinationDetailResult',
    'GetAutonomousDatabaseBackupConfigResult',
    'GetAutonomousDatabaseBackupsAutonomousDatabaseBackupResult',
    'GetAutonomousDatabaseBackupsAutonomousDatabaseBackupBackupDestinationDetailResult',
    'GetAutonomousDatabaseBackupsFilterResult',
    'GetAutonomousDatabaseConnectionStringResult',
    'GetAutonomousDatabaseConnectionStringProfileResult',
    'GetAutonomousDatabaseConnectionUrlResult',
    'GetAutonomousDatabaseCustomerContactResult',
    'GetAutonomousDatabaseDataguardAssociationsAutonomousDatabaseDataguardAssociationResult',
    'GetAutonomousDatabaseDataguardAssociationsFilterResult',
    'GetAutonomousDatabaseKeyHistoryEntryResult',
    'GetAutonomousDatabaseLocalStandbyDbResult',
    'GetAutonomousDatabaseLongTermBackupScheduleResult',
    'GetAutonomousDatabaseRefreshableClonesFilterResult',
    'GetAutonomousDatabaseRefreshableClonesRefreshableCloneCollectionResult',
    'GetAutonomousDatabaseRefreshableClonesRefreshableCloneCollectionItemResult',
    'GetAutonomousDatabaseRemoteDisasterRecoveryConfigurationResult',
    'GetAutonomousDatabaseResourcePoolSummaryResult',
    'GetAutonomousDatabaseScheduledOperationResult',
    'GetAutonomousDatabaseScheduledOperationDayOfWeekResult',
    'GetAutonomousDatabaseStandbyDbResult',
    'GetAutonomousDatabasesAutonomousDatabaseResult',
    'GetAutonomousDatabasesAutonomousDatabaseApexDetailResult',
    'GetAutonomousDatabasesAutonomousDatabaseBackupConfigResult',
    'GetAutonomousDatabasesAutonomousDatabaseConnectionStringResult',
    'GetAutonomousDatabasesAutonomousDatabaseConnectionStringProfileResult',
    'GetAutonomousDatabasesAutonomousDatabaseConnectionUrlResult',
    'GetAutonomousDatabasesAutonomousDatabaseCustomerContactResult',
    'GetAutonomousDatabasesAutonomousDatabaseKeyHistoryEntryResult',
    'GetAutonomousDatabasesAutonomousDatabaseLocalStandbyDbResult',
    'GetAutonomousDatabasesAutonomousDatabaseLongTermBackupScheduleResult',
    'GetAutonomousDatabasesAutonomousDatabaseRemoteDisasterRecoveryConfigurationResult',
    'GetAutonomousDatabasesAutonomousDatabaseResourcePoolSummaryResult',
    'GetAutonomousDatabasesAutonomousDatabaseScheduledOperationResult',
    'GetAutonomousDatabasesAutonomousDatabaseScheduledOperationDayOfWeekResult',
    'GetAutonomousDatabasesAutonomousDatabaseStandbyDbResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseApexDetailResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseBackupConfigResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseConnectionStringResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseConnectionStringProfileResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseConnectionUrlResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseCustomerContactResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseKeyHistoryEntryResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseLocalStandbyDbResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseLongTermBackupScheduleResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseRemoteDisasterRecoveryConfigurationResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseResourcePoolSummaryResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseScheduledOperationResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseScheduledOperationDayOfWeekResult',
    'GetAutonomousDatabasesClonesAutonomousDatabaseStandbyDbResult',
    'GetAutonomousDatabasesClonesFilterResult',
    'GetAutonomousDatabasesFilterResult',
    'GetAutonomousDbPreviewVersionsAutonomousDbPreviewVersionResult',
    'GetAutonomousDbPreviewVersionsFilterResult',
    'GetAutonomousDbVersionsAutonomousDbVersionResult',
    'GetAutonomousDbVersionsFilterResult',
    'GetAutonomousExadataInfrastructureMaintenanceWindowResult',
    'GetAutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekResult',
    'GetAutonomousExadataInfrastructureMaintenanceWindowDetailResult',
    'GetAutonomousExadataInfrastructureMaintenanceWindowDetailDaysOfWeekResult',
    'GetAutonomousExadataInfrastructureMaintenanceWindowDetailMonthResult',
    'GetAutonomousExadataInfrastructureMaintenanceWindowMonthResult',
    'GetAutonomousExadataInfrastructureOcpuByWorkloadTypeResult',
    'GetAutonomousExadataInfrastructureShapesAutonomousExadataInfrastructureShapeResult',
    'GetAutonomousExadataInfrastructureShapesFilterResult',
    'GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureResult',
    'GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowResult',
    'GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekResult',
    'GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailResult',
    'GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailDaysOfWeekResult',
    'GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailMonthResult',
    'GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowMonthResult',
    'GetAutonomousExadataInfrastructuresFilterResult',
    'GetAutonomousVirtualMachinesAutonomousVirtualMachineResult',
    'GetAutonomousVirtualMachinesFilterResult',
    'GetAutonomousVmClusterMaintenanceWindowResult',
    'GetAutonomousVmClusterMaintenanceWindowDaysOfWeekResult',
    'GetAutonomousVmClusterMaintenanceWindowDetailResult',
    'GetAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult',
    'GetAutonomousVmClusterMaintenanceWindowDetailMonthResult',
    'GetAutonomousVmClusterMaintenanceWindowMonthResult',
    'GetAutonomousVmClustersAutonomousVmClusterResult',
    'GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowResult',
    'GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDaysOfWeekResult',
    'GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailResult',
    'GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult',
    'GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailMonthResult',
    'GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowMonthResult',
    'GetAutonomousVmClustersFilterResult',
    'GetBackupDestinationAssociatedDatabaseResult',
    'GetBackupDestinationMountTypeDetailResult',
    'GetBackupDestinationsBackupDestinationResult',
    'GetBackupDestinationsBackupDestinationAssociatedDatabaseResult',
    'GetBackupDestinationsBackupDestinationMountTypeDetailResult',
    'GetBackupDestinationsFilterResult',
    'GetBackupsBackupResult',
    'GetBackupsFilterResult',
    'GetCloudAutonomousVmClusterAcdResourceUsagesAutonomousContainerDatabaseResourceUsageResult',
    'GetCloudAutonomousVmClusterAcdResourceUsagesAutonomousContainerDatabaseResourceUsageAutonomousContainerDatabaseVmUsageResult',
    'GetCloudAutonomousVmClusterAcdResourceUsagesFilterResult',
    'GetCloudAutonomousVmClusterMaintenanceWindowResult',
    'GetCloudAutonomousVmClusterMaintenanceWindowDaysOfWeekResult',
    'GetCloudAutonomousVmClusterMaintenanceWindowDetailResult',
    'GetCloudAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult',
    'GetCloudAutonomousVmClusterMaintenanceWindowDetailMonthResult',
    'GetCloudAutonomousVmClusterMaintenanceWindowMonthResult',
    'GetCloudAutonomousVmClusterResourceUsageAutonomousVmResourceUsageResult',
    'GetCloudAutonomousVmClusterResourceUsageAutonomousVmResourceUsageAutonomousContainerDatabaseUsageResult',
    'GetCloudAutonomousVmClustersCloudAutonomousVmClusterResult',
    'GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowResult',
    'GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDaysOfWeekResult',
    'GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailResult',
    'GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult',
    'GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailMonthResult',
    'GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowMonthResult',
    'GetCloudAutonomousVmClustersFilterResult',
    'GetCloudExadataInfrastructureCustomerContactResult',
    'GetCloudExadataInfrastructureMaintenanceWindowResult',
    'GetCloudExadataInfrastructureMaintenanceWindowDaysOfWeekResult',
    'GetCloudExadataInfrastructureMaintenanceWindowMonthResult',
    'GetCloudExadataInfrastructureUnAllocatedResourceCloudAutonomousVmClusterResult',
    'GetCloudExadataInfrastructuresCloudExadataInfrastructureResult',
    'GetCloudExadataInfrastructuresCloudExadataInfrastructureCustomerContactResult',
    'GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowResult',
    'GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowDaysOfWeekResult',
    'GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowMonthResult',
    'GetCloudExadataInfrastructuresFilterResult',
    'GetCloudVmClusterDataCollectionOptionResult',
    'GetCloudVmClusterIormConfigCachResult',
    'GetCloudVmClusterIormConfigCachDbPlanResult',
    'GetCloudVmClusterIormConfigDbPlanResult',
    'GetCloudVmClustersCloudVmClusterResult',
    'GetCloudVmClustersCloudVmClusterDataCollectionOptionResult',
    'GetCloudVmClustersCloudVmClusterIormConfigCachResult',
    'GetCloudVmClustersCloudVmClusterIormConfigCachDbPlanResult',
    'GetCloudVmClustersFilterResult',
    'GetDataGuardAssociationDataCollectionOptionResult',
    'GetDataGuardAssociationsDataGuardAssociationResult',
    'GetDataGuardAssociationsDataGuardAssociationDataCollectionOptionResult',
    'GetDataGuardAssociationsFilterResult',
    'GetDatabaseConnectionStringResult',
    'GetDatabaseDatabaseResult',
    'GetDatabaseDatabaseDbBackupConfigResult',
    'GetDatabaseDatabaseDbBackupConfigBackupDestinationDetailResult',
    'GetDatabaseDatabaseManagementConfigResult',
    'GetDatabaseDbBackupConfigResult',
    'GetDatabaseDbBackupConfigBackupDestinationDetailResult',
    'GetDatabaseMaintenanceRunHistoriesFilterResult',
    'GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryResult',
    'GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryDbServersHistoryDetailResult',
    'GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryDbServersHistoryDetailDbServerPatchingDetailResult',
    'GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryMaintenanceRunDetailResult',
    'GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryMaintenanceRunDetailEstimatedPatchingTimeResult',
    'GetDatabaseMaintenanceRunHistoryDbServersHistoryDetailResult',
    'GetDatabaseMaintenanceRunHistoryDbServersHistoryDetailDbServerPatchingDetailResult',
    'GetDatabaseMaintenanceRunHistoryMaintenanceRunDetailResult',
    'GetDatabaseMaintenanceRunHistoryMaintenanceRunDetailEstimatedPatchingTimeResult',
    'GetDatabasePdbConversionHistoryEntriesFilterResult',
    'GetDatabasePdbConversionHistoryEntriesPdbConversionHistoryEntryResult',
    'GetDatabaseSoftwareImagesDatabaseSoftwareImageResult',
    'GetDatabaseSoftwareImagesFilterResult',
    'GetDatabaseUpgradeHistoryEntriesDatabaseUpgradeHistoryEntryResult',
    'GetDatabaseUpgradeHistoryEntriesFilterResult',
    'GetDatabasesDatabaseResult',
    'GetDatabasesDatabaseConnectionStringResult',
    'GetDatabasesDatabaseDatabaseResult',
    'GetDatabasesDatabaseDatabaseDbBackupConfigResult',
    'GetDatabasesDatabaseDatabaseDbBackupConfigBackupDestinationDetailResult',
    'GetDatabasesDatabaseDatabaseManagementConfigResult',
    'GetDatabasesDatabaseDbBackupConfigResult',
    'GetDatabasesDatabaseDbBackupConfigBackupDestinationDetailResult',
    'GetDatabasesFilterResult',
    'GetDbHomeDatabaseResult',
    'GetDbHomeDatabaseConnectionStringResult',
    'GetDbHomeDatabaseDbBackupConfigResult',
    'GetDbHomeDatabaseDbBackupConfigBackupDestinationDetailResult',
    'GetDbHomePatchHistoryEntriesFilterResult',
    'GetDbHomePatchHistoryEntriesPatchHistoryEntryResult',
    'GetDbHomePatchesFilterResult',
    'GetDbHomePatchesPatchResult',
    'GetDbHomesDbHomeResult',
    'GetDbHomesDbHomeDatabaseResult',
    'GetDbHomesDbHomeDatabaseConnectionStringResult',
    'GetDbHomesDbHomeDatabaseDbBackupConfigResult',
    'GetDbHomesDbHomeDatabaseDbBackupConfigBackupDestinationDetailResult',
    'GetDbHomesFilterResult',
    'GetDbNodeConsoleConnectionsConsoleConnectionResult',
    'GetDbNodeConsoleConnectionsFilterResult',
    'GetDbNodesDbNodeResult',
    'GetDbNodesFilterResult',
    'GetDbServerDbServerPatchingDetailResult',
    'GetDbServersDbServerResult',
    'GetDbServersDbServerDbServerPatchingDetailResult',
    'GetDbServersFilterResult',
    'GetDbSystemComputePerformancesDbSystemComputePerformanceResult',
    'GetDbSystemComputePerformancesDbSystemComputePerformanceComputePerformanceListResult',
    'GetDbSystemComputePerformancesFilterResult',
    'GetDbSystemHistoryEntriesFilterResult',
    'GetDbSystemHistoryEntriesPatchHistoryEntryResult',
    'GetDbSystemPatchesFilterResult',
    'GetDbSystemPatchesPatchResult',
    'GetDbSystemShapesDbSystemShapeResult',
    'GetDbSystemShapesFilterResult',
    'GetDbSystemStoragePerformancesDbSystemStoragePerformanceResult',
    'GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListResult',
    'GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListBalancedDiskPerformanceResult',
    'GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListHighDiskPerformanceResult',
    'GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListResult',
    'GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListBalancedDiskPerformanceResult',
    'GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListHighDiskPerformanceResult',
    'GetDbSystemStoragePerformancesFilterResult',
    'GetDbSystemsDbSystemResult',
    'GetDbSystemsDbSystemDataCollectionOptionResult',
    'GetDbSystemsDbSystemDbHomeResult',
    'GetDbSystemsDbSystemDbHomeDatabaseResult',
    'GetDbSystemsDbSystemDbHomeDatabaseConnectionStringResult',
    'GetDbSystemsDbSystemDbHomeDatabaseDbBackupConfigResult',
    'GetDbSystemsDbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailResult',
    'GetDbSystemsDbSystemDbSystemOptionResult',
    'GetDbSystemsDbSystemIormConfigCachResult',
    'GetDbSystemsDbSystemIormConfigCachDbPlanResult',
    'GetDbSystemsDbSystemMaintenanceWindowResult',
    'GetDbSystemsDbSystemMaintenanceWindowDaysOfWeekResult',
    'GetDbSystemsDbSystemMaintenanceWindowDetailResult',
    'GetDbSystemsDbSystemMaintenanceWindowDetailDaysOfWeekResult',
    'GetDbSystemsDbSystemMaintenanceWindowDetailMonthResult',
    'GetDbSystemsDbSystemMaintenanceWindowMonthResult',
    'GetDbSystemsFilterResult',
    'GetDbSystemsUpgradeHistoryEntriesDbSystemUpgradeHistoryEntryResult',
    'GetDbSystemsUpgradeHistoryEntriesFilterResult',
    'GetDbVersionsDbVersionResult',
    'GetDbVersionsFilterResult',
    'GetExadataInfrastructureContactResult',
    'GetExadataInfrastructureMaintenanceWindowResult',
    'GetExadataInfrastructureMaintenanceWindowDaysOfWeekResult',
    'GetExadataInfrastructureMaintenanceWindowMonthResult',
    'GetExadataInfrastructureNetworkBondingModeDetailResult',
    'GetExadataInfrastructureUnAllocatedResourceAutonomousVmClusterResult',
    'GetExadataInfrastructuresExadataInfrastructureResult',
    'GetExadataInfrastructuresExadataInfrastructureContactResult',
    'GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowResult',
    'GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowDaysOfWeekResult',
    'GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowMonthResult',
    'GetExadataInfrastructuresExadataInfrastructureNetworkBondingModeDetailResult',
    'GetExadataInfrastructuresFilterResult',
    'GetExadataIormConfigDbPlanResult',
    'GetExternalContainerDatabaseDatabaseManagementConfigResult',
    'GetExternalContainerDatabaseStackMonitoringConfigResult',
    'GetExternalContainerDatabasesExternalContainerDatabaseResult',
    'GetExternalContainerDatabasesExternalContainerDatabaseDatabaseManagementConfigResult',
    'GetExternalContainerDatabasesExternalContainerDatabaseStackMonitoringConfigResult',
    'GetExternalContainerDatabasesFilterResult',
    'GetExternalDatabaseConnectorConnectionCredentialResult',
    'GetExternalDatabaseConnectorConnectionStringResult',
    'GetExternalDatabaseConnectorsExternalDatabaseConnectorResult',
    'GetExternalDatabaseConnectorsExternalDatabaseConnectorConnectionCredentialResult',
    'GetExternalDatabaseConnectorsExternalDatabaseConnectorConnectionStringResult',
    'GetExternalDatabaseConnectorsFilterResult',
    'GetExternalNonContainerDatabaseDatabaseManagementConfigResult',
    'GetExternalNonContainerDatabaseOperationsInsightsConfigResult',
    'GetExternalNonContainerDatabaseStackMonitoringConfigResult',
    'GetExternalNonContainerDatabasesExternalNonContainerDatabaseResult',
    'GetExternalNonContainerDatabasesExternalNonContainerDatabaseDatabaseManagementConfigResult',
    'GetExternalNonContainerDatabasesExternalNonContainerDatabaseOperationsInsightsConfigResult',
    'GetExternalNonContainerDatabasesExternalNonContainerDatabaseStackMonitoringConfigResult',
    'GetExternalNonContainerDatabasesFilterResult',
    'GetExternalPluggableDatabaseDatabaseManagementConfigResult',
    'GetExternalPluggableDatabaseOperationsInsightsConfigResult',
    'GetExternalPluggableDatabaseStackMonitoringConfigResult',
    'GetExternalPluggableDatabasesExternalPluggableDatabaseResult',
    'GetExternalPluggableDatabasesExternalPluggableDatabaseDatabaseManagementConfigResult',
    'GetExternalPluggableDatabasesExternalPluggableDatabaseOperationsInsightsConfigResult',
    'GetExternalPluggableDatabasesExternalPluggableDatabaseStackMonitoringConfigResult',
    'GetExternalPluggableDatabasesFilterResult',
    'GetFlexComponentsFilterResult',
    'GetFlexComponentsFlexComponentCollectionResult',
    'GetFlexComponentsFlexComponentCollectionItemResult',
    'GetGiVersionsFilterResult',
    'GetGiVersionsGiVersionResult',
    'GetKeyStoreAssociatedDatabaseResult',
    'GetKeyStoreTypeDetailResult',
    'GetKeyStoresFilterResult',
    'GetKeyStoresKeyStoreResult',
    'GetKeyStoresKeyStoreAssociatedDatabaseResult',
    'GetKeyStoresKeyStoreTypeDetailResult',
    'GetMaintenanceRunEstimatedPatchingTimeResult',
    'GetMaintenanceRunsFilterResult',
    'GetMaintenanceRunsMaintenanceRunResult',
    'GetMaintenanceRunsMaintenanceRunEstimatedPatchingTimeResult',
    'GetManagedPreferredCredentialsFilterResult',
    'GetManagedPreferredCredentialsPreferredCredentialCollectionResult',
    'GetManagedPreferredCredentialsPreferredCredentialCollectionItemResult',
    'GetOneoffPatchesFilterResult',
    'GetOneoffPatchesOneoffPatchResult',
    'GetPluggableDatabaseConnectionStringResult',
    'GetPluggableDatabasePluggableDatabaseManagementConfigResult',
    'GetPluggableDatabasesFilterResult',
    'GetPluggableDatabasesPluggableDatabaseResult',
    'GetPluggableDatabasesPluggableDatabaseConnectionStringResult',
    'GetPluggableDatabasesPluggableDatabasePluggableDatabaseManagementConfigResult',
    'GetVmClusterDataCollectionOptionResult',
    'GetVmClusterNetworkDrScanResult',
    'GetVmClusterNetworkScanResult',
    'GetVmClusterNetworkVmNetworkResult',
    'GetVmClusterNetworkVmNetworkNodeResult',
    'GetVmClusterNetworksFilterResult',
    'GetVmClusterNetworksVmClusterNetworkResult',
    'GetVmClusterNetworksVmClusterNetworkDrScanResult',
    'GetVmClusterNetworksVmClusterNetworkScanResult',
    'GetVmClusterNetworksVmClusterNetworkVmNetworkResult',
    'GetVmClusterNetworksVmClusterNetworkVmNetworkNodeResult',
    'GetVmClusterPatchHistoryEntriesFilterResult',
    'GetVmClusterPatchHistoryEntriesPatchHistoryEntryResult',
    'GetVmClusterPatchesFilterResult',
    'GetVmClusterPatchesPatchResult',
    'GetVmClusterRecommendedNetworkDrScanResult',
    'GetVmClusterRecommendedNetworkNetworkResult',
    'GetVmClusterRecommendedNetworkScanResult',
    'GetVmClusterRecommendedNetworkVmNetworkResult',
    'GetVmClusterRecommendedNetworkVmNetworkNodeResult',
    'GetVmClusterUpdateHistoryEntriesFilterResult',
    'GetVmClusterUpdateHistoryEntriesVmClusterUpdateHistoryEntryResult',
    'GetVmClusterUpdatesFilterResult',
    'GetVmClusterUpdatesVmClusterUpdateResult',
    'GetVmClustersFilterResult',
    'GetVmClustersVmClusterResult',
    'GetVmClustersVmClusterDataCollectionOptionResult',
]

@pulumi.output_type
class AutonomousContainerDatabaseBackupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupDestinationDetails":
            suggest = "backup_destination_details"
        elif key == "recoveryWindowInDays":
            suggest = "recovery_window_in_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousContainerDatabaseBackupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousContainerDatabaseBackupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousContainerDatabaseBackupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_destination_details: Optional['outputs.AutonomousContainerDatabaseBackupConfigBackupDestinationDetails'] = None,
                 recovery_window_in_days: Optional[int] = None):
        """
        :param 'AutonomousContainerDatabaseBackupConfigBackupDestinationDetailsArgs' backup_destination_details: Backup destination details.
        :param int recovery_window_in_days: Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        AutonomousContainerDatabaseBackupConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backup_destination_details=backup_destination_details,
            recovery_window_in_days=recovery_window_in_days,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backup_destination_details: Optional['outputs.AutonomousContainerDatabaseBackupConfigBackupDestinationDetails'] = None,
             recovery_window_in_days: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if backup_destination_details is not None:
            _setter("backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            _setter("recovery_window_in_days", recovery_window_in_days)

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional['outputs.AutonomousContainerDatabaseBackupConfigBackupDestinationDetails']:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[int]:
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")


@pulumi.output_type
class AutonomousContainerDatabaseBackupConfigBackupDestinationDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internetProxy":
            suggest = "internet_proxy"
        elif key == "vpcPassword":
            suggest = "vpc_password"
        elif key == "vpcUser":
            suggest = "vpc_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousContainerDatabaseBackupConfigBackupDestinationDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousContainerDatabaseBackupConfigBackupDestinationDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousContainerDatabaseBackupConfigBackupDestinationDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 id: Optional[str] = None,
                 internet_proxy: Optional[str] = None,
                 vpc_password: Optional[str] = None,
                 vpc_user: Optional[str] = None):
        """
        :param str type: Type of the database backup destination.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param str internet_proxy: Proxy URL to connect to object store.
        :param str vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param str vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        AutonomousContainerDatabaseBackupConfigBackupDestinationDetails._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            id=id,
            internet_proxy=internet_proxy,
            vpc_password=vpc_password,
            vpc_user=vpc_user,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             id: Optional[str] = None,
             internet_proxy: Optional[str] = None,
             vpc_password: Optional[str] = None,
             vpc_user: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if id is not None:
            _setter("id", id)
        if internet_proxy is not None:
            _setter("internet_proxy", internet_proxy)
        if vpc_password is not None:
            _setter("vpc_password", vpc_password)
        if vpc_user is not None:
            _setter("vpc_user", vpc_user)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> Optional[str]:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> Optional[str]:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[str]:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class AutonomousContainerDatabaseKeyHistoryEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyVersionId":
            suggest = "kms_key_version_id"
        elif key == "timeActivated":
            suggest = "time_activated"
        elif key == "vaultId":
            suggest = "vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousContainerDatabaseKeyHistoryEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousContainerDatabaseKeyHistoryEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousContainerDatabaseKeyHistoryEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[str] = None,
                 kms_key_version_id: Optional[str] = None,
                 time_activated: Optional[str] = None,
                 vault_id: Optional[str] = None):
        """
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        :param str time_activated: The date and time the kms key activated.
        :param str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        AutonomousContainerDatabaseKeyHistoryEntry._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            kms_key_version_id=kms_key_version_id,
            time_activated=time_activated,
            vault_id=vault_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             kms_key_version_id: Optional[str] = None,
             time_activated: Optional[str] = None,
             vault_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if id is not None:
            _setter("id", id)
        if kms_key_version_id is not None:
            _setter("kms_key_version_id", kms_key_version_id)
        if time_activated is not None:
            _setter("time_activated", time_activated)
        if vault_id is not None:
            _setter("vault_id", vault_id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> Optional[str]:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        """
        return pulumi.get(self, "kms_key_version_id")

    @property
    @pulumi.getter(name="timeActivated")
    def time_activated(self) -> Optional[str]:
        """
        The date and time the kms key activated.
        """
        return pulumi.get(self, "time_activated")

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class AutonomousContainerDatabaseMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionTimeoutInMins":
            suggest = "custom_action_timeout_in_mins"
        elif key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "isCustomActionTimeoutEnabled":
            suggest = "is_custom_action_timeout_enabled"
        elif key == "isMonthlyPatchingEnabled":
            suggest = "is_monthly_patching_enabled"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "patchingMode":
            suggest = "patching_mode"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousContainerDatabaseMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousContainerDatabaseMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousContainerDatabaseMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[int] = None,
                 days_of_weeks: Optional[Sequence['outputs.AutonomousContainerDatabaseMaintenanceWindowDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[int]] = None,
                 is_custom_action_timeout_enabled: Optional[bool] = None,
                 is_monthly_patching_enabled: Optional[bool] = None,
                 lead_time_in_weeks: Optional[int] = None,
                 months: Optional[Sequence['outputs.AutonomousContainerDatabaseMaintenanceWindowMonth']] = None,
                 patching_mode: Optional[str] = None,
                 preference: Optional[str] = None,
                 weeks_of_months: Optional[Sequence[int]] = None):
        """
        :param int custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['AutonomousContainerDatabaseMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param bool is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param bool is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param int lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['AutonomousContainerDatabaseMaintenanceWindowMonthArgs'] months: (Updatable) Months during the year when maintenance should be performed.
        :param str patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param str preference: (Updatable) The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        AutonomousContainerDatabaseMaintenanceWindow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: Optional[int] = None,
             days_of_weeks: Optional[Sequence['outputs.AutonomousContainerDatabaseMaintenanceWindowDaysOfWeek']] = None,
             hours_of_days: Optional[Sequence[int]] = None,
             is_custom_action_timeout_enabled: Optional[bool] = None,
             is_monthly_patching_enabled: Optional[bool] = None,
             lead_time_in_weeks: Optional[int] = None,
             months: Optional[Sequence['outputs.AutonomousContainerDatabaseMaintenanceWindowMonth']] = None,
             patching_mode: Optional[str] = None,
             preference: Optional[str] = None,
             weeks_of_months: Optional[Sequence[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_action_timeout_in_mins is not None:
            _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            _setter("days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            _setter("hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            _setter("lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            _setter("months", months)
        if patching_mode is not None:
            _setter("patching_mode", patching_mode)
        if preference is not None:
            _setter("preference", preference)
        if weeks_of_months is not None:
            _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[int]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.AutonomousContainerDatabaseMaintenanceWindowDaysOfWeek']]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[int]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[bool]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[bool]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[int]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.AutonomousContainerDatabaseMaintenanceWindowMonth']]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[str]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> Optional[str]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[int]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class AutonomousContainerDatabaseMaintenanceWindowDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: (Updatable) Name of the month of the year.
        """
        AutonomousContainerDatabaseMaintenanceWindowDaysOfWeek._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AutonomousContainerDatabaseMaintenanceWindowDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionTimeoutInMins":
            suggest = "custom_action_timeout_in_mins"
        elif key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "isCustomActionTimeoutEnabled":
            suggest = "is_custom_action_timeout_enabled"
        elif key == "isMonthlyPatchingEnabled":
            suggest = "is_monthly_patching_enabled"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "patchingMode":
            suggest = "patching_mode"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousContainerDatabaseMaintenanceWindowDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousContainerDatabaseMaintenanceWindowDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousContainerDatabaseMaintenanceWindowDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[int] = None,
                 days_of_weeks: Optional[Sequence['outputs.AutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[int]] = None,
                 is_custom_action_timeout_enabled: Optional[bool] = None,
                 is_monthly_patching_enabled: Optional[bool] = None,
                 lead_time_in_weeks: Optional[int] = None,
                 months: Optional[Sequence['outputs.AutonomousContainerDatabaseMaintenanceWindowDetailsMonth']] = None,
                 patching_mode: Optional[str] = None,
                 preference: Optional[str] = None,
                 weeks_of_months: Optional[Sequence[int]] = None):
        """
        :param int custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['AutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeekArgs'] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param bool is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param bool is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param int lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['AutonomousContainerDatabaseMaintenanceWindowDetailsMonthArgs'] months: (Updatable) Months during the year when maintenance should be performed.
        :param str patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param str preference: (Updatable) The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        AutonomousContainerDatabaseMaintenanceWindowDetails._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: Optional[int] = None,
             days_of_weeks: Optional[Sequence['outputs.AutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeek']] = None,
             hours_of_days: Optional[Sequence[int]] = None,
             is_custom_action_timeout_enabled: Optional[bool] = None,
             is_monthly_patching_enabled: Optional[bool] = None,
             lead_time_in_weeks: Optional[int] = None,
             months: Optional[Sequence['outputs.AutonomousContainerDatabaseMaintenanceWindowDetailsMonth']] = None,
             patching_mode: Optional[str] = None,
             preference: Optional[str] = None,
             weeks_of_months: Optional[Sequence[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_action_timeout_in_mins is not None:
            _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            _setter("days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            _setter("hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            _setter("lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            _setter("months", months)
        if patching_mode is not None:
            _setter("patching_mode", patching_mode)
        if preference is not None:
            _setter("preference", preference)
        if weeks_of_months is not None:
            _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[int]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.AutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeek']]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[int]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[bool]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[bool]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[int]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.AutonomousContainerDatabaseMaintenanceWindowDetailsMonth']]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[str]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> Optional[str]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[int]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class AutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: (Updatable) Name of the month of the year.
        """
        AutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeek._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AutonomousContainerDatabaseMaintenanceWindowDetailsMonth(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: (Updatable) Name of the month of the year.
        """
        AutonomousContainerDatabaseMaintenanceWindowDetailsMonth._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AutonomousContainerDatabaseMaintenanceWindowMonth(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: (Updatable) Name of the month of the year.
        """
        AutonomousContainerDatabaseMaintenanceWindowMonth._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupDestinationDetails":
            suggest = "backup_destination_details"
        elif key == "recoveryWindowInDays":
            suggest = "recovery_window_in_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_destination_details: Optional[Sequence['outputs.AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetail']] = None,
                 recovery_window_in_days: Optional[int] = None):
        """
        :param Sequence['AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs'] backup_destination_details: Backup destination details.
        :param int recovery_window_in_days: Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backup_destination_details=backup_destination_details,
            recovery_window_in_days=recovery_window_in_days,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backup_destination_details: Optional[Sequence['outputs.AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetail']] = None,
             recovery_window_in_days: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if backup_destination_details is not None:
            _setter("backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            _setter("recovery_window_in_days", recovery_window_in_days)

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[Sequence['outputs.AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetail']]:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[int]:
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")


@pulumi.output_type
class AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internetProxy":
            suggest = "internet_proxy"
        elif key == "vpcPassword":
            suggest = "vpc_password"
        elif key == "vpcUser":
            suggest = "vpc_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 id: Optional[str] = None,
                 internet_proxy: Optional[str] = None,
                 vpc_password: Optional[str] = None,
                 vpc_user: Optional[str] = None):
        """
        :param str type: Type of the database backup destination.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param str internet_proxy: Proxy URL to connect to object store.
        :param str vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param str vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        AutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetail._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            id=id,
            internet_proxy=internet_proxy,
            vpc_password=vpc_password,
            vpc_user=vpc_user,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             id: Optional[str] = None,
             internet_proxy: Optional[str] = None,
             vpc_password: Optional[str] = None,
             vpc_user: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if id is not None:
            _setter("id", id)
        if internet_proxy is not None:
            _setter("internet_proxy", internet_proxy)
        if vpc_password is not None:
            _setter("vpc_password", vpc_password)
        if vpc_user is not None:
            _setter("vpc_user", vpc_user)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> Optional[str]:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> Optional[str]:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[str]:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class AutonomousDatabaseApexDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apexVersion":
            suggest = "apex_version"
        elif key == "ordsVersion":
            suggest = "ords_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousDatabaseApexDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousDatabaseApexDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousDatabaseApexDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apex_version: Optional[str] = None,
                 ords_version: Optional[str] = None):
        """
        :param str apex_version: The Oracle APEX Application Development version.
        :param str ords_version: The Oracle REST Data Services (ORDS) version.
        """
        AutonomousDatabaseApexDetail._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apex_version=apex_version,
            ords_version=ords_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apex_version: Optional[str] = None,
             ords_version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apex_version is not None:
            _setter("apex_version", apex_version)
        if ords_version is not None:
            _setter("ords_version", ords_version)

    @property
    @pulumi.getter(name="apexVersion")
    def apex_version(self) -> Optional[str]:
        """
        The Oracle APEX Application Development version.
        """
        return pulumi.get(self, "apex_version")

    @property
    @pulumi.getter(name="ordsVersion")
    def ords_version(self) -> Optional[str]:
        """
        The Oracle REST Data Services (ORDS) version.
        """
        return pulumi.get(self, "ords_version")


@pulumi.output_type
class AutonomousDatabaseBackupBackupDestinationDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internetProxy":
            suggest = "internet_proxy"
        elif key == "vpcPassword":
            suggest = "vpc_password"
        elif key == "vpcUser":
            suggest = "vpc_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousDatabaseBackupBackupDestinationDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousDatabaseBackupBackupDestinationDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousDatabaseBackupBackupDestinationDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 id: Optional[str] = None,
                 internet_proxy: Optional[str] = None,
                 vpc_password: Optional[str] = None,
                 vpc_user: Optional[str] = None):
        """
        :param str type: The type of backup.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database backup.
        :param str internet_proxy: Proxy URL to connect to object store.
        :param str vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param str vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        AutonomousDatabaseBackupBackupDestinationDetails._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            id=id,
            internet_proxy=internet_proxy,
            vpc_password=vpc_password,
            vpc_user=vpc_user,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             id: Optional[str] = None,
             internet_proxy: Optional[str] = None,
             vpc_password: Optional[str] = None,
             vpc_user: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if id is not None:
            _setter("id", id)
        if internet_proxy is not None:
            _setter("internet_proxy", internet_proxy)
        if vpc_password is not None:
            _setter("vpc_password", vpc_password)
        if vpc_user is not None:
            _setter("vpc_user", vpc_user)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of backup.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database backup.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> Optional[str]:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> Optional[str]:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[str]:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class AutonomousDatabaseBackupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "manualBackupBucketName":
            suggest = "manual_backup_bucket_name"
        elif key == "manualBackupType":
            suggest = "manual_backup_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousDatabaseBackupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousDatabaseBackupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousDatabaseBackupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 manual_backup_bucket_name: Optional[str] = None,
                 manual_backup_type: Optional[str] = None):
        """
        :param str manual_backup_bucket_name: Name of [Object Storage](https://docs.cloud.oracle.com/iaas/Content/Object/Concepts/objectstorageoverview.htm) bucket to use for storing manual backups.
        :param str manual_backup_type: The manual backup destination type.
        """
        AutonomousDatabaseBackupConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            manual_backup_bucket_name=manual_backup_bucket_name,
            manual_backup_type=manual_backup_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             manual_backup_bucket_name: Optional[str] = None,
             manual_backup_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if manual_backup_bucket_name is not None:
            _setter("manual_backup_bucket_name", manual_backup_bucket_name)
        if manual_backup_type is not None:
            _setter("manual_backup_type", manual_backup_type)

    @property
    @pulumi.getter(name="manualBackupBucketName")
    def manual_backup_bucket_name(self) -> Optional[str]:
        """
        Name of [Object Storage](https://docs.cloud.oracle.com/iaas/Content/Object/Concepts/objectstorageoverview.htm) bucket to use for storing manual backups.
        """
        return pulumi.get(self, "manual_backup_bucket_name")

    @property
    @pulumi.getter(name="manualBackupType")
    def manual_backup_type(self) -> Optional[str]:
        """
        The manual backup destination type.
        """
        return pulumi.get(self, "manual_backup_type")


@pulumi.output_type
class AutonomousDatabaseConnectionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allConnectionStrings":
            suggest = "all_connection_strings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousDatabaseConnectionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousDatabaseConnectionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousDatabaseConnectionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_connection_strings: Optional[Mapping[str, Any]] = None,
                 dedicated: Optional[str] = None,
                 high: Optional[str] = None,
                 low: Optional[str] = None,
                 medium: Optional[str] = None,
                 profiles: Optional[Sequence['outputs.AutonomousDatabaseConnectionStringProfile']] = None):
        """
        :param Mapping[str, Any] all_connection_strings: Returns all connection strings that can be used to connect to the Autonomous Database. For more information, please see [Predefined Database Service Names for Autonomous Transaction Processing](https://docs.oracle.com/en/cloud/paas/atp-cloud/atpug/connect-predefined.html#GUID-9747539B-FD46-44F1-8FF8-F5AC650F15BE)
        :param str dedicated: The database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        :param str high: The High database service provides the highest level of resources to each SQL statement resulting in the highest performance, but supports the fewest number of concurrent SQL statements.
        :param str low: The Low database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        :param str medium: The Medium database service provides a lower level of resources to each SQL statement potentially resulting a lower level of performance, but supports more concurrent SQL statements.
        :param Sequence['AutonomousDatabaseConnectionStringProfileArgs'] profiles: A list of connection string profiles to allow clients to group, filter and select connection string values based on structured metadata.
        """
        AutonomousDatabaseConnectionString._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_connection_strings=all_connection_strings,
            dedicated=dedicated,
            high=high,
            low=low,
            medium=medium,
            profiles=profiles,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_connection_strings: Optional[Mapping[str, Any]] = None,
             dedicated: Optional[str] = None,
             high: Optional[str] = None,
             low: Optional[str] = None,
             medium: Optional[str] = None,
             profiles: Optional[Sequence['outputs.AutonomousDatabaseConnectionStringProfile']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if all_connection_strings is not None:
            _setter("all_connection_strings", all_connection_strings)
        if dedicated is not None:
            _setter("dedicated", dedicated)
        if high is not None:
            _setter("high", high)
        if low is not None:
            _setter("low", low)
        if medium is not None:
            _setter("medium", medium)
        if profiles is not None:
            _setter("profiles", profiles)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[Mapping[str, Any]]:
        """
        Returns all connection strings that can be used to connect to the Autonomous Database. For more information, please see [Predefined Database Service Names for Autonomous Transaction Processing](https://docs.oracle.com/en/cloud/paas/atp-cloud/atpug/connect-predefined.html#GUID-9747539B-FD46-44F1-8FF8-F5AC650F15BE)
        """
        return pulumi.get(self, "all_connection_strings")

    @property
    @pulumi.getter
    def dedicated(self) -> Optional[str]:
        """
        The database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        """
        return pulumi.get(self, "dedicated")

    @property
    @pulumi.getter
    def high(self) -> Optional[str]:
        """
        The High database service provides the highest level of resources to each SQL statement resulting in the highest performance, but supports the fewest number of concurrent SQL statements.
        """
        return pulumi.get(self, "high")

    @property
    @pulumi.getter
    def low(self) -> Optional[str]:
        """
        The Low database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        """
        return pulumi.get(self, "low")

    @property
    @pulumi.getter
    def medium(self) -> Optional[str]:
        """
        The Medium database service provides a lower level of resources to each SQL statement potentially resulting a lower level of performance, but supports more concurrent SQL statements.
        """
        return pulumi.get(self, "medium")

    @property
    @pulumi.getter
    def profiles(self) -> Optional[Sequence['outputs.AutonomousDatabaseConnectionStringProfile']]:
        """
        A list of connection string profiles to allow clients to group, filter and select connection string values based on structured metadata.
        """
        return pulumi.get(self, "profiles")


@pulumi.output_type
class AutonomousDatabaseConnectionStringProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerGroup":
            suggest = "consumer_group"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "hostFormat":
            suggest = "host_format"
        elif key == "sessionMode":
            suggest = "session_mode"
        elif key == "syntaxFormat":
            suggest = "syntax_format"
        elif key == "tlsAuthentication":
            suggest = "tls_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousDatabaseConnectionStringProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousDatabaseConnectionStringProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousDatabaseConnectionStringProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_group: Optional[str] = None,
                 display_name: Optional[str] = None,
                 host_format: Optional[str] = None,
                 protocol: Optional[str] = None,
                 session_mode: Optional[str] = None,
                 syntax_format: Optional[str] = None,
                 tls_authentication: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str consumer_group: Consumer group used by the connection.
        :param str display_name: (Updatable) The user-friendly name for the Autonomous Database. The name does not have to be unique.
        :param str host_format: Host format used in connection string.
        :param str protocol: Protocol used by the connection.
        :param str session_mode: Specifies whether the listener performs a direct hand-off of the session, or redirects the session. In RAC deployments where SCAN is used, sessions are redirected to a Node VIP. Use `DIRECT` for direct hand-offs. Use `REDIRECT` to redirect the session.
        :param str syntax_format: Specifies whether the connection string is using the long (`LONG`), Easy Connect (`EZCONNECT`), or Easy Connect Plus (`EZCONNECTPLUS`) format. Autonomous Databases on shared Exadata infrastructure always use the long format.
        :param str tls_authentication: Specifies whether the TLS handshake is using one-way (`SERVER`) or mutual (`MUTUAL`) authentication.
        :param str value: Connection string value.
        """
        AutonomousDatabaseConnectionStringProfile._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            consumer_group=consumer_group,
            display_name=display_name,
            host_format=host_format,
            protocol=protocol,
            session_mode=session_mode,
            syntax_format=syntax_format,
            tls_authentication=tls_authentication,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             consumer_group: Optional[str] = None,
             display_name: Optional[str] = None,
             host_format: Optional[str] = None,
             protocol: Optional[str] = None,
             session_mode: Optional[str] = None,
             syntax_format: Optional[str] = None,
             tls_authentication: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if consumer_group is not None:
            _setter("consumer_group", consumer_group)
        if display_name is not None:
            _setter("display_name", display_name)
        if host_format is not None:
            _setter("host_format", host_format)
        if protocol is not None:
            _setter("protocol", protocol)
        if session_mode is not None:
            _setter("session_mode", session_mode)
        if syntax_format is not None:
            _setter("syntax_format", syntax_format)
        if tls_authentication is not None:
            _setter("tls_authentication", tls_authentication)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[str]:
        """
        Consumer group used by the connection.
        """
        return pulumi.get(self, "consumer_group")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        (Updatable) The user-friendly name for the Autonomous Database. The name does not have to be unique.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="hostFormat")
    def host_format(self) -> Optional[str]:
        """
        Host format used in connection string.
        """
        return pulumi.get(self, "host_format")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol used by the connection.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sessionMode")
    def session_mode(self) -> Optional[str]:
        """
        Specifies whether the listener performs a direct hand-off of the session, or redirects the session. In RAC deployments where SCAN is used, sessions are redirected to a Node VIP. Use `DIRECT` for direct hand-offs. Use `REDIRECT` to redirect the session.
        """
        return pulumi.get(self, "session_mode")

    @property
    @pulumi.getter(name="syntaxFormat")
    def syntax_format(self) -> Optional[str]:
        """
        Specifies whether the connection string is using the long (`LONG`), Easy Connect (`EZCONNECT`), or Easy Connect Plus (`EZCONNECTPLUS`) format. Autonomous Databases on shared Exadata infrastructure always use the long format.
        """
        return pulumi.get(self, "syntax_format")

    @property
    @pulumi.getter(name="tlsAuthentication")
    def tls_authentication(self) -> Optional[str]:
        """
        Specifies whether the TLS handshake is using one-way (`SERVER`) or mutual (`MUTUAL`) authentication.
        """
        return pulumi.get(self, "tls_authentication")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Connection string value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutonomousDatabaseConnectionUrl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apexUrl":
            suggest = "apex_url"
        elif key == "graphStudioUrl":
            suggest = "graph_studio_url"
        elif key == "machineLearningUserManagementUrl":
            suggest = "machine_learning_user_management_url"
        elif key == "sqlDevWebUrl":
            suggest = "sql_dev_web_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousDatabaseConnectionUrl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousDatabaseConnectionUrl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousDatabaseConnectionUrl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apex_url: Optional[str] = None,
                 graph_studio_url: Optional[str] = None,
                 machine_learning_user_management_url: Optional[str] = None,
                 sql_dev_web_url: Optional[str] = None):
        """
        :param str apex_url: Oracle Application Express (APEX) URL.
        :param str graph_studio_url: The URL of the Graph Studio for the Autonomous Database.
        :param str machine_learning_user_management_url: Oracle Machine Learning user management URL.
        :param str sql_dev_web_url: Oracle SQL Developer Web URL.
        """
        AutonomousDatabaseConnectionUrl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apex_url=apex_url,
            graph_studio_url=graph_studio_url,
            machine_learning_user_management_url=machine_learning_user_management_url,
            sql_dev_web_url=sql_dev_web_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apex_url: Optional[str] = None,
             graph_studio_url: Optional[str] = None,
             machine_learning_user_management_url: Optional[str] = None,
             sql_dev_web_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apex_url is not None:
            _setter("apex_url", apex_url)
        if graph_studio_url is not None:
            _setter("graph_studio_url", graph_studio_url)
        if machine_learning_user_management_url is not None:
            _setter("machine_learning_user_management_url", machine_learning_user_management_url)
        if sql_dev_web_url is not None:
            _setter("sql_dev_web_url", sql_dev_web_url)

    @property
    @pulumi.getter(name="apexUrl")
    def apex_url(self) -> Optional[str]:
        """
        Oracle Application Express (APEX) URL.
        """
        return pulumi.get(self, "apex_url")

    @property
    @pulumi.getter(name="graphStudioUrl")
    def graph_studio_url(self) -> Optional[str]:
        """
        The URL of the Graph Studio for the Autonomous Database.
        """
        return pulumi.get(self, "graph_studio_url")

    @property
    @pulumi.getter(name="machineLearningUserManagementUrl")
    def machine_learning_user_management_url(self) -> Optional[str]:
        """
        Oracle Machine Learning user management URL.
        """
        return pulumi.get(self, "machine_learning_user_management_url")

    @property
    @pulumi.getter(name="sqlDevWebUrl")
    def sql_dev_web_url(self) -> Optional[str]:
        """
        Oracle SQL Developer Web URL.
        """
        return pulumi.get(self, "sql_dev_web_url")


@pulumi.output_type
class AutonomousDatabaseCustomerContact(dict):
    def __init__(__self__, *,
                 email: Optional[str] = None):
        """
        :param str email: (Updatable) The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        AutonomousDatabaseCustomerContact._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            email=email,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             email: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if email is not None:
            _setter("email", email)

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        (Updatable) The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class AutonomousDatabaseKeyHistoryEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyVersionId":
            suggest = "kms_key_version_id"
        elif key == "timeActivated":
            suggest = "time_activated"
        elif key == "vaultId":
            suggest = "vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousDatabaseKeyHistoryEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousDatabaseKeyHistoryEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousDatabaseKeyHistoryEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[str] = None,
                 kms_key_version_id: Optional[str] = None,
                 time_activated: Optional[str] = None,
                 vault_id: Optional[str] = None):
        """
        :param str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        :param str time_activated: The date and time the kms key activated.
        :param str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        AutonomousDatabaseKeyHistoryEntry._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            kms_key_version_id=kms_key_version_id,
            time_activated=time_activated,
            vault_id=vault_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             kms_key_version_id: Optional[str] = None,
             time_activated: Optional[str] = None,
             vault_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if id is not None:
            _setter("id", id)
        if kms_key_version_id is not None:
            _setter("kms_key_version_id", kms_key_version_id)
        if time_activated is not None:
            _setter("time_activated", time_activated)
        if vault_id is not None:
            _setter("vault_id", vault_id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> Optional[str]:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        """
        return pulumi.get(self, "kms_key_version_id")

    @property
    @pulumi.getter(name="timeActivated")
    def time_activated(self) -> Optional[str]:
        """
        The date and time the kms key activated.
        """
        return pulumi.get(self, "time_activated")

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class AutonomousDatabaseLocalStandbyDb(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lagTimeInSeconds":
            suggest = "lag_time_in_seconds"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"
        elif key == "timeDataGuardRoleChanged":
            suggest = "time_data_guard_role_changed"
        elif key == "timeDisasterRecoveryRoleChanged":
            suggest = "time_disaster_recovery_role_changed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousDatabaseLocalStandbyDb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousDatabaseLocalStandbyDb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousDatabaseLocalStandbyDb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lag_time_in_seconds: Optional[int] = None,
                 lifecycle_details: Optional[str] = None,
                 state: Optional[str] = None,
                 time_data_guard_role_changed: Optional[str] = None,
                 time_disaster_recovery_role_changed: Optional[str] = None):
        """
        :param int lag_time_in_seconds: The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str state: The current state of the Autonomous Database.
        :param str time_data_guard_role_changed: The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        :param str time_disaster_recovery_role_changed: The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        AutonomousDatabaseLocalStandbyDb._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lag_time_in_seconds=lag_time_in_seconds,
            lifecycle_details=lifecycle_details,
            state=state,
            time_data_guard_role_changed=time_data_guard_role_changed,
            time_disaster_recovery_role_changed=time_disaster_recovery_role_changed,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lag_time_in_seconds: Optional[int] = None,
             lifecycle_details: Optional[str] = None,
             state: Optional[str] = None,
             time_data_guard_role_changed: Optional[str] = None,
             time_disaster_recovery_role_changed: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if lag_time_in_seconds is not None:
            _setter("lag_time_in_seconds", lag_time_in_seconds)
        if lifecycle_details is not None:
            _setter("lifecycle_details", lifecycle_details)
        if state is not None:
            _setter("state", state)
        if time_data_guard_role_changed is not None:
            _setter("time_data_guard_role_changed", time_data_guard_role_changed)
        if time_disaster_recovery_role_changed is not None:
            _setter("time_disaster_recovery_role_changed", time_disaster_recovery_role_changed)

    @property
    @pulumi.getter(name="lagTimeInSeconds")
    def lag_time_in_seconds(self) -> Optional[int]:
        """
        The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        """
        return pulumi.get(self, "lag_time_in_seconds")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[str]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        The current state of the Autonomous Database.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeDataGuardRoleChanged")
    def time_data_guard_role_changed(self) -> Optional[str]:
        """
        The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        """
        return pulumi.get(self, "time_data_guard_role_changed")

    @property
    @pulumi.getter(name="timeDisasterRecoveryRoleChanged")
    def time_disaster_recovery_role_changed(self) -> Optional[str]:
        """
        The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        return pulumi.get(self, "time_disaster_recovery_role_changed")


@pulumi.output_type
class AutonomousDatabaseLongTermBackupSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isDisabled":
            suggest = "is_disabled"
        elif key == "repeatCadence":
            suggest = "repeat_cadence"
        elif key == "retentionPeriodInDays":
            suggest = "retention_period_in_days"
        elif key == "timeOfBackup":
            suggest = "time_of_backup"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousDatabaseLongTermBackupSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousDatabaseLongTermBackupSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousDatabaseLongTermBackupSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_disabled: Optional[bool] = None,
                 repeat_cadence: Optional[str] = None,
                 retention_period_in_days: Optional[int] = None,
                 time_of_backup: Optional[str] = None):
        """
        :param bool is_disabled: Indicates if the long-term backup schedule should be deleted. The default value is `FALSE`.
        :param str repeat_cadence: The frequency of the long-term backup schedule
        :param int retention_period_in_days: Retention period, in days, for long-term backups
        :param str time_of_backup: The timestamp for the long-term backup schedule. For a MONTHLY cadence, months having fewer days than the provided date will have the backup taken on the last day of that month.
        """
        AutonomousDatabaseLongTermBackupSchedule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_disabled=is_disabled,
            repeat_cadence=repeat_cadence,
            retention_period_in_days=retention_period_in_days,
            time_of_backup=time_of_backup,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_disabled: Optional[bool] = None,
             repeat_cadence: Optional[str] = None,
             retention_period_in_days: Optional[int] = None,
             time_of_backup: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_disabled is not None:
            _setter("is_disabled", is_disabled)
        if repeat_cadence is not None:
            _setter("repeat_cadence", repeat_cadence)
        if retention_period_in_days is not None:
            _setter("retention_period_in_days", retention_period_in_days)
        if time_of_backup is not None:
            _setter("time_of_backup", time_of_backup)

    @property
    @pulumi.getter(name="isDisabled")
    def is_disabled(self) -> Optional[bool]:
        """
        Indicates if the long-term backup schedule should be deleted. The default value is `FALSE`.
        """
        return pulumi.get(self, "is_disabled")

    @property
    @pulumi.getter(name="repeatCadence")
    def repeat_cadence(self) -> Optional[str]:
        """
        The frequency of the long-term backup schedule
        """
        return pulumi.get(self, "repeat_cadence")

    @property
    @pulumi.getter(name="retentionPeriodInDays")
    def retention_period_in_days(self) -> Optional[int]:
        """
        Retention period, in days, for long-term backups
        """
        return pulumi.get(self, "retention_period_in_days")

    @property
    @pulumi.getter(name="timeOfBackup")
    def time_of_backup(self) -> Optional[str]:
        """
        The timestamp for the long-term backup schedule. For a MONTHLY cadence, months having fewer days than the provided date will have the backup taken on the last day of that month.
        """
        return pulumi.get(self, "time_of_backup")


@pulumi.output_type
class AutonomousDatabaseRemoteDisasterRecoveryConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disasterRecoveryType":
            suggest = "disaster_recovery_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousDatabaseRemoteDisasterRecoveryConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousDatabaseRemoteDisasterRecoveryConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousDatabaseRemoteDisasterRecoveryConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disaster_recovery_type: Optional[str] = None):
        """
        :param str disaster_recovery_type: Indicates the disaster recovery (DR) type of the Autonomous Database Serverless instance. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
        """
        AutonomousDatabaseRemoteDisasterRecoveryConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disaster_recovery_type=disaster_recovery_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disaster_recovery_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if disaster_recovery_type is not None:
            _setter("disaster_recovery_type", disaster_recovery_type)

    @property
    @pulumi.getter(name="disasterRecoveryType")
    def disaster_recovery_type(self) -> Optional[str]:
        """
        Indicates the disaster recovery (DR) type of the Autonomous Database Serverless instance. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
        """
        return pulumi.get(self, "disaster_recovery_type")


@pulumi.output_type
class AutonomousDatabaseResourcePoolSummary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isDisabled":
            suggest = "is_disabled"
        elif key == "poolSize":
            suggest = "pool_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousDatabaseResourcePoolSummary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousDatabaseResourcePoolSummary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousDatabaseResourcePoolSummary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_disabled: Optional[bool] = None,
                 pool_size: Optional[int] = None):
        """
        :param bool is_disabled: Indicates if the long-term backup schedule should be deleted. The default value is `FALSE`.
        """
        AutonomousDatabaseResourcePoolSummary._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_disabled=is_disabled,
            pool_size=pool_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_disabled: Optional[bool] = None,
             pool_size: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_disabled is not None:
            _setter("is_disabled", is_disabled)
        if pool_size is not None:
            _setter("pool_size", pool_size)

    @property
    @pulumi.getter(name="isDisabled")
    def is_disabled(self) -> Optional[bool]:
        """
        Indicates if the long-term backup schedule should be deleted. The default value is `FALSE`.
        """
        return pulumi.get(self, "is_disabled")

    @property
    @pulumi.getter(name="poolSize")
    def pool_size(self) -> Optional[int]:
        return pulumi.get(self, "pool_size")


@pulumi.output_type
class AutonomousDatabaseScheduledOperation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfWeek":
            suggest = "day_of_week"
        elif key == "scheduledStartTime":
            suggest = "scheduled_start_time"
        elif key == "scheduledStopTime":
            suggest = "scheduled_stop_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousDatabaseScheduledOperation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousDatabaseScheduledOperation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousDatabaseScheduledOperation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day_of_week: 'outputs.AutonomousDatabaseScheduledOperationDayOfWeek',
                 scheduled_start_time: Optional[str] = None,
                 scheduled_stop_time: Optional[str] = None):
        """
        :param 'AutonomousDatabaseScheduledOperationDayOfWeekArgs' day_of_week: (Updatable) Day of the week.
        :param str scheduled_start_time: (Updatable) auto start time. value must be of ISO-8601 format "HH:mm"
        :param str scheduled_stop_time: (Updatable) auto stop time. value must be of ISO-8601 format "HH:mm"
        """
        AutonomousDatabaseScheduledOperation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            day_of_week=day_of_week,
            scheduled_start_time=scheduled_start_time,
            scheduled_stop_time=scheduled_stop_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             day_of_week: 'outputs.AutonomousDatabaseScheduledOperationDayOfWeek',
             scheduled_start_time: Optional[str] = None,
             scheduled_stop_time: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("day_of_week", day_of_week)
        if scheduled_start_time is not None:
            _setter("scheduled_start_time", scheduled_start_time)
        if scheduled_stop_time is not None:
            _setter("scheduled_stop_time", scheduled_stop_time)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> 'outputs.AutonomousDatabaseScheduledOperationDayOfWeek':
        """
        (Updatable) Day of the week.
        """
        return pulumi.get(self, "day_of_week")

    @property
    @pulumi.getter(name="scheduledStartTime")
    def scheduled_start_time(self) -> Optional[str]:
        """
        (Updatable) auto start time. value must be of ISO-8601 format "HH:mm"
        """
        return pulumi.get(self, "scheduled_start_time")

    @property
    @pulumi.getter(name="scheduledStopTime")
    def scheduled_stop_time(self) -> Optional[str]:
        """
        (Updatable) auto stop time. value must be of ISO-8601 format "HH:mm"
        """
        return pulumi.get(self, "scheduled_stop_time")


@pulumi.output_type
class AutonomousDatabaseScheduledOperationDayOfWeek(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: (Updatable) Name of the day of the week.
        """
        AutonomousDatabaseScheduledOperationDayOfWeek._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        (Updatable) Name of the day of the week.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AutonomousDatabaseStandbyDb(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lagTimeInSeconds":
            suggest = "lag_time_in_seconds"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"
        elif key == "timeDataGuardRoleChanged":
            suggest = "time_data_guard_role_changed"
        elif key == "timeDisasterRecoveryRoleChanged":
            suggest = "time_disaster_recovery_role_changed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousDatabaseStandbyDb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousDatabaseStandbyDb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousDatabaseStandbyDb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lag_time_in_seconds: Optional[int] = None,
                 lifecycle_details: Optional[str] = None,
                 state: Optional[str] = None,
                 time_data_guard_role_changed: Optional[str] = None,
                 time_disaster_recovery_role_changed: Optional[str] = None):
        """
        :param int lag_time_in_seconds: The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str state: The current state of the Autonomous Database.
        :param str time_data_guard_role_changed: The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        :param str time_disaster_recovery_role_changed: The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        AutonomousDatabaseStandbyDb._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lag_time_in_seconds=lag_time_in_seconds,
            lifecycle_details=lifecycle_details,
            state=state,
            time_data_guard_role_changed=time_data_guard_role_changed,
            time_disaster_recovery_role_changed=time_disaster_recovery_role_changed,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lag_time_in_seconds: Optional[int] = None,
             lifecycle_details: Optional[str] = None,
             state: Optional[str] = None,
             time_data_guard_role_changed: Optional[str] = None,
             time_disaster_recovery_role_changed: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if lag_time_in_seconds is not None:
            _setter("lag_time_in_seconds", lag_time_in_seconds)
        if lifecycle_details is not None:
            _setter("lifecycle_details", lifecycle_details)
        if state is not None:
            _setter("state", state)
        if time_data_guard_role_changed is not None:
            _setter("time_data_guard_role_changed", time_data_guard_role_changed)
        if time_disaster_recovery_role_changed is not None:
            _setter("time_disaster_recovery_role_changed", time_disaster_recovery_role_changed)

    @property
    @pulumi.getter(name="lagTimeInSeconds")
    def lag_time_in_seconds(self) -> Optional[int]:
        """
        The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        """
        return pulumi.get(self, "lag_time_in_seconds")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[str]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        The current state of the Autonomous Database.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeDataGuardRoleChanged")
    def time_data_guard_role_changed(self) -> Optional[str]:
        """
        The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        """
        return pulumi.get(self, "time_data_guard_role_changed")

    @property
    @pulumi.getter(name="timeDisasterRecoveryRoleChanged")
    def time_disaster_recovery_role_changed(self) -> Optional[str]:
        """
        The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        return pulumi.get(self, "time_disaster_recovery_role_changed")


@pulumi.output_type
class AutonomousExadataInfrastructureMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionTimeoutInMins":
            suggest = "custom_action_timeout_in_mins"
        elif key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "isCustomActionTimeoutEnabled":
            suggest = "is_custom_action_timeout_enabled"
        elif key == "isMonthlyPatchingEnabled":
            suggest = "is_monthly_patching_enabled"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "patchingMode":
            suggest = "patching_mode"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousExadataInfrastructureMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousExadataInfrastructureMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousExadataInfrastructureMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[int] = None,
                 days_of_weeks: Optional[Sequence['outputs.AutonomousExadataInfrastructureMaintenanceWindowDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[int]] = None,
                 is_custom_action_timeout_enabled: Optional[bool] = None,
                 is_monthly_patching_enabled: Optional[bool] = None,
                 lead_time_in_weeks: Optional[int] = None,
                 months: Optional[Sequence['outputs.AutonomousExadataInfrastructureMaintenanceWindowMonth']] = None,
                 patching_mode: Optional[str] = None,
                 preference: Optional[str] = None,
                 weeks_of_months: Optional[Sequence[int]] = None):
        """
        :param int custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['AutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param bool is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param bool is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param int lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['AutonomousExadataInfrastructureMaintenanceWindowMonthArgs'] months: (Updatable) Months during the year when maintenance should be performed.
        :param str patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param str preference: (Updatable) The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        AutonomousExadataInfrastructureMaintenanceWindow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: Optional[int] = None,
             days_of_weeks: Optional[Sequence['outputs.AutonomousExadataInfrastructureMaintenanceWindowDaysOfWeek']] = None,
             hours_of_days: Optional[Sequence[int]] = None,
             is_custom_action_timeout_enabled: Optional[bool] = None,
             is_monthly_patching_enabled: Optional[bool] = None,
             lead_time_in_weeks: Optional[int] = None,
             months: Optional[Sequence['outputs.AutonomousExadataInfrastructureMaintenanceWindowMonth']] = None,
             patching_mode: Optional[str] = None,
             preference: Optional[str] = None,
             weeks_of_months: Optional[Sequence[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_action_timeout_in_mins is not None:
            _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            _setter("days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            _setter("hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            _setter("lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            _setter("months", months)
        if patching_mode is not None:
            _setter("patching_mode", patching_mode)
        if preference is not None:
            _setter("preference", preference)
        if weeks_of_months is not None:
            _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[int]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.AutonomousExadataInfrastructureMaintenanceWindowDaysOfWeek']]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[int]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[bool]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[bool]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[int]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.AutonomousExadataInfrastructureMaintenanceWindowMonth']]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[str]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> Optional[str]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[int]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class AutonomousExadataInfrastructureMaintenanceWindowDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: (Updatable) Name of the month of the year.
        """
        AutonomousExadataInfrastructureMaintenanceWindowDaysOfWeek._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AutonomousExadataInfrastructureMaintenanceWindowDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionTimeoutInMins":
            suggest = "custom_action_timeout_in_mins"
        elif key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "isCustomActionTimeoutEnabled":
            suggest = "is_custom_action_timeout_enabled"
        elif key == "isMonthlyPatchingEnabled":
            suggest = "is_monthly_patching_enabled"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "patchingMode":
            suggest = "patching_mode"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousExadataInfrastructureMaintenanceWindowDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousExadataInfrastructureMaintenanceWindowDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousExadataInfrastructureMaintenanceWindowDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[int] = None,
                 days_of_weeks: Optional[Sequence['outputs.AutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[int]] = None,
                 is_custom_action_timeout_enabled: Optional[bool] = None,
                 is_monthly_patching_enabled: Optional[bool] = None,
                 lead_time_in_weeks: Optional[int] = None,
                 months: Optional[Sequence['outputs.AutonomousExadataInfrastructureMaintenanceWindowDetailsMonth']] = None,
                 patching_mode: Optional[str] = None,
                 preference: Optional[str] = None,
                 weeks_of_months: Optional[Sequence[int]] = None):
        """
        :param int custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['AutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeekArgs'] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param bool is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param bool is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param int lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['AutonomousExadataInfrastructureMaintenanceWindowDetailsMonthArgs'] months: (Updatable) Months during the year when maintenance should be performed.
        :param str patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param str preference: (Updatable) The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        AutonomousExadataInfrastructureMaintenanceWindowDetails._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: Optional[int] = None,
             days_of_weeks: Optional[Sequence['outputs.AutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeek']] = None,
             hours_of_days: Optional[Sequence[int]] = None,
             is_custom_action_timeout_enabled: Optional[bool] = None,
             is_monthly_patching_enabled: Optional[bool] = None,
             lead_time_in_weeks: Optional[int] = None,
             months: Optional[Sequence['outputs.AutonomousExadataInfrastructureMaintenanceWindowDetailsMonth']] = None,
             patching_mode: Optional[str] = None,
             preference: Optional[str] = None,
             weeks_of_months: Optional[Sequence[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_action_timeout_in_mins is not None:
            _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            _setter("days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            _setter("hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            _setter("lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            _setter("months", months)
        if patching_mode is not None:
            _setter("patching_mode", patching_mode)
        if preference is not None:
            _setter("preference", preference)
        if weeks_of_months is not None:
            _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[int]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.AutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeek']]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[int]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[bool]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[bool]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[int]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.AutonomousExadataInfrastructureMaintenanceWindowDetailsMonth']]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[str]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> Optional[str]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[int]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class AutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: (Updatable) Name of the month of the year.
        """
        AutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeek._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AutonomousExadataInfrastructureMaintenanceWindowDetailsMonth(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: (Updatable) Name of the month of the year.
        """
        AutonomousExadataInfrastructureMaintenanceWindowDetailsMonth._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AutonomousExadataInfrastructureMaintenanceWindowMonth(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: (Updatable) Name of the month of the year.
        """
        AutonomousExadataInfrastructureMaintenanceWindowMonth._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AutonomousVmClusterMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionTimeoutInMins":
            suggest = "custom_action_timeout_in_mins"
        elif key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "isCustomActionTimeoutEnabled":
            suggest = "is_custom_action_timeout_enabled"
        elif key == "isMonthlyPatchingEnabled":
            suggest = "is_monthly_patching_enabled"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "patchingMode":
            suggest = "patching_mode"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousVmClusterMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousVmClusterMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousVmClusterMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[int] = None,
                 days_of_weeks: Optional[Sequence['outputs.AutonomousVmClusterMaintenanceWindowDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[int]] = None,
                 is_custom_action_timeout_enabled: Optional[bool] = None,
                 is_monthly_patching_enabled: Optional[bool] = None,
                 lead_time_in_weeks: Optional[int] = None,
                 months: Optional[Sequence['outputs.AutonomousVmClusterMaintenanceWindowMonth']] = None,
                 patching_mode: Optional[str] = None,
                 preference: Optional[str] = None,
                 weeks_of_months: Optional[Sequence[int]] = None):
        """
        :param Sequence['AutonomousVmClusterMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param int lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['AutonomousVmClusterMaintenanceWindowMonthArgs'] months: (Updatable) Months during the year when maintenance should be performed.
        :param str patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param str preference: (Updatable) The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        AutonomousVmClusterMaintenanceWindow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: Optional[int] = None,
             days_of_weeks: Optional[Sequence['outputs.AutonomousVmClusterMaintenanceWindowDaysOfWeek']] = None,
             hours_of_days: Optional[Sequence[int]] = None,
             is_custom_action_timeout_enabled: Optional[bool] = None,
             is_monthly_patching_enabled: Optional[bool] = None,
             lead_time_in_weeks: Optional[int] = None,
             months: Optional[Sequence['outputs.AutonomousVmClusterMaintenanceWindowMonth']] = None,
             patching_mode: Optional[str] = None,
             preference: Optional[str] = None,
             weeks_of_months: Optional[Sequence[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_action_timeout_in_mins is not None:
            _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            _setter("days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            _setter("hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            _setter("lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            _setter("months", months)
        if patching_mode is not None:
            _setter("patching_mode", patching_mode)
        if preference is not None:
            _setter("preference", preference)
        if weeks_of_months is not None:
            _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[int]:
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.AutonomousVmClusterMaintenanceWindowDaysOfWeek']]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[int]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[int]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.AutonomousVmClusterMaintenanceWindowMonth']]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[str]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> Optional[str]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[int]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class AutonomousVmClusterMaintenanceWindowDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: (Updatable) Name of the month of the year.
        """
        AutonomousVmClusterMaintenanceWindowDaysOfWeek._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AutonomousVmClusterMaintenanceWindowDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionTimeoutInMins":
            suggest = "custom_action_timeout_in_mins"
        elif key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "isCustomActionTimeoutEnabled":
            suggest = "is_custom_action_timeout_enabled"
        elif key == "isMonthlyPatchingEnabled":
            suggest = "is_monthly_patching_enabled"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "patchingMode":
            suggest = "patching_mode"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutonomousVmClusterMaintenanceWindowDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutonomousVmClusterMaintenanceWindowDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutonomousVmClusterMaintenanceWindowDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[int] = None,
                 days_of_weeks: Optional[Sequence['outputs.AutonomousVmClusterMaintenanceWindowDetailDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[int]] = None,
                 is_custom_action_timeout_enabled: Optional[bool] = None,
                 is_monthly_patching_enabled: Optional[bool] = None,
                 lead_time_in_weeks: Optional[int] = None,
                 months: Optional[Sequence['outputs.AutonomousVmClusterMaintenanceWindowDetailMonth']] = None,
                 patching_mode: Optional[str] = None,
                 preference: Optional[str] = None,
                 weeks_of_months: Optional[Sequence[int]] = None):
        """
        :param Sequence['AutonomousVmClusterMaintenanceWindowDetailDaysOfWeekArgs'] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param int lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['AutonomousVmClusterMaintenanceWindowDetailMonthArgs'] months: (Updatable) Months during the year when maintenance should be performed.
        :param str patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param str preference: (Updatable) The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        AutonomousVmClusterMaintenanceWindowDetail._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: Optional[int] = None,
             days_of_weeks: Optional[Sequence['outputs.AutonomousVmClusterMaintenanceWindowDetailDaysOfWeek']] = None,
             hours_of_days: Optional[Sequence[int]] = None,
             is_custom_action_timeout_enabled: Optional[bool] = None,
             is_monthly_patching_enabled: Optional[bool] = None,
             lead_time_in_weeks: Optional[int] = None,
             months: Optional[Sequence['outputs.AutonomousVmClusterMaintenanceWindowDetailMonth']] = None,
             patching_mode: Optional[str] = None,
             preference: Optional[str] = None,
             weeks_of_months: Optional[Sequence[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_action_timeout_in_mins is not None:
            _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            _setter("days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            _setter("hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            _setter("lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            _setter("months", months)
        if patching_mode is not None:
            _setter("patching_mode", patching_mode)
        if preference is not None:
            _setter("preference", preference)
        if weeks_of_months is not None:
            _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[int]:
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.AutonomousVmClusterMaintenanceWindowDetailDaysOfWeek']]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[int]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[int]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.AutonomousVmClusterMaintenanceWindowDetailMonth']]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[str]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> Optional[str]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[int]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class AutonomousVmClusterMaintenanceWindowDetailDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: (Updatable) Name of the month of the year.
        """
        AutonomousVmClusterMaintenanceWindowDetailDaysOfWeek._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AutonomousVmClusterMaintenanceWindowDetailMonth(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: (Updatable) Name of the month of the year.
        """
        AutonomousVmClusterMaintenanceWindowDetailMonth._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AutonomousVmClusterMaintenanceWindowMonth(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: (Updatable) Name of the month of the year.
        """
        AutonomousVmClusterMaintenanceWindowMonth._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class BackupDestinationAssociatedDatabase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbName":
            suggest = "db_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupDestinationAssociatedDatabase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupDestinationAssociatedDatabase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupDestinationAssociatedDatabase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_name: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param str db_name: The display name of the database that is associated with the backup destination.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        BackupDestinationAssociatedDatabase._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_name=db_name,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_name: Optional[str] = None,
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if db_name is not None:
            _setter("db_name", db_name)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[str]:
        """
        The display name of the database that is associated with the backup destination.
        """
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class BackupDestinationMountTypeDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mountType":
            suggest = "mount_type"
        elif key == "localMountPointPath":
            suggest = "local_mount_point_path"
        elif key == "nfsServerExport":
            suggest = "nfs_server_export"
        elif key == "nfsServers":
            suggest = "nfs_servers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupDestinationMountTypeDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupDestinationMountTypeDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupDestinationMountTypeDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mount_type: str,
                 local_mount_point_path: Optional[str] = None,
                 nfs_server_export: Optional[str] = None,
                 nfs_servers: Optional[Sequence[str]] = None):
        """
        :param str mount_type: Mount type for backup destination.
        :param str local_mount_point_path: The local directory path on each VM cluster node where the NFS server location is mounted. The local directory path and the NFS server location must each be the same across all of the VM cluster nodes. Ensure that the NFS mount is maintained continuously on all of the VM cluster nodes.
        :param str nfs_server_export: Specifies the directory on which to mount the file system
        :param Sequence[str] nfs_servers: IP addresses for NFS Auto mount.
        """
        BackupDestinationMountTypeDetails._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mount_type=mount_type,
            local_mount_point_path=local_mount_point_path,
            nfs_server_export=nfs_server_export,
            nfs_servers=nfs_servers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mount_type: str,
             local_mount_point_path: Optional[str] = None,
             nfs_server_export: Optional[str] = None,
             nfs_servers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("mount_type", mount_type)
        if local_mount_point_path is not None:
            _setter("local_mount_point_path", local_mount_point_path)
        if nfs_server_export is not None:
            _setter("nfs_server_export", nfs_server_export)
        if nfs_servers is not None:
            _setter("nfs_servers", nfs_servers)

    @property
    @pulumi.getter(name="mountType")
    def mount_type(self) -> str:
        """
        Mount type for backup destination.
        """
        return pulumi.get(self, "mount_type")

    @property
    @pulumi.getter(name="localMountPointPath")
    def local_mount_point_path(self) -> Optional[str]:
        """
        The local directory path on each VM cluster node where the NFS server location is mounted. The local directory path and the NFS server location must each be the same across all of the VM cluster nodes. Ensure that the NFS mount is maintained continuously on all of the VM cluster nodes.
        """
        return pulumi.get(self, "local_mount_point_path")

    @property
    @pulumi.getter(name="nfsServerExport")
    def nfs_server_export(self) -> Optional[str]:
        """
        Specifies the directory on which to mount the file system
        """
        return pulumi.get(self, "nfs_server_export")

    @property
    @pulumi.getter(name="nfsServers")
    def nfs_servers(self) -> Optional[Sequence[str]]:
        """
        IP addresses for NFS Auto mount.
        """
        return pulumi.get(self, "nfs_servers")


@pulumi.output_type
class CloudAutonomousVmClusterMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionTimeoutInMins":
            suggest = "custom_action_timeout_in_mins"
        elif key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "isCustomActionTimeoutEnabled":
            suggest = "is_custom_action_timeout_enabled"
        elif key == "isMonthlyPatchingEnabled":
            suggest = "is_monthly_patching_enabled"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "patchingMode":
            suggest = "patching_mode"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudAutonomousVmClusterMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudAutonomousVmClusterMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudAutonomousVmClusterMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[int] = None,
                 days_of_weeks: Optional[Sequence['outputs.CloudAutonomousVmClusterMaintenanceWindowDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[int]] = None,
                 is_custom_action_timeout_enabled: Optional[bool] = None,
                 is_monthly_patching_enabled: Optional[bool] = None,
                 lead_time_in_weeks: Optional[int] = None,
                 months: Optional[Sequence['outputs.CloudAutonomousVmClusterMaintenanceWindowMonth']] = None,
                 patching_mode: Optional[str] = None,
                 preference: Optional[str] = None,
                 weeks_of_months: Optional[Sequence[int]] = None):
        """
        :param int custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['CloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param bool is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param bool is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param int lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['CloudAutonomousVmClusterMaintenanceWindowMonthArgs'] months: (Updatable) Months during the year when maintenance should be performed.
        :param str patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param str preference: (Updatable) The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        CloudAutonomousVmClusterMaintenanceWindow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: Optional[int] = None,
             days_of_weeks: Optional[Sequence['outputs.CloudAutonomousVmClusterMaintenanceWindowDaysOfWeek']] = None,
             hours_of_days: Optional[Sequence[int]] = None,
             is_custom_action_timeout_enabled: Optional[bool] = None,
             is_monthly_patching_enabled: Optional[bool] = None,
             lead_time_in_weeks: Optional[int] = None,
             months: Optional[Sequence['outputs.CloudAutonomousVmClusterMaintenanceWindowMonth']] = None,
             patching_mode: Optional[str] = None,
             preference: Optional[str] = None,
             weeks_of_months: Optional[Sequence[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_action_timeout_in_mins is not None:
            _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            _setter("days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            _setter("hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            _setter("lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            _setter("months", months)
        if patching_mode is not None:
            _setter("patching_mode", patching_mode)
        if preference is not None:
            _setter("preference", preference)
        if weeks_of_months is not None:
            _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[int]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.CloudAutonomousVmClusterMaintenanceWindowDaysOfWeek']]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[int]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[bool]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[bool]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[int]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.CloudAutonomousVmClusterMaintenanceWindowMonth']]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[str]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> Optional[str]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[int]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class CloudAutonomousVmClusterMaintenanceWindowDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: (Updatable) Name of the month of the year.
        """
        CloudAutonomousVmClusterMaintenanceWindowDaysOfWeek._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CloudAutonomousVmClusterMaintenanceWindowDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionTimeoutInMins":
            suggest = "custom_action_timeout_in_mins"
        elif key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "isCustomActionTimeoutEnabled":
            suggest = "is_custom_action_timeout_enabled"
        elif key == "isMonthlyPatchingEnabled":
            suggest = "is_monthly_patching_enabled"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "patchingMode":
            suggest = "patching_mode"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudAutonomousVmClusterMaintenanceWindowDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudAutonomousVmClusterMaintenanceWindowDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudAutonomousVmClusterMaintenanceWindowDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[int] = None,
                 days_of_weeks: Optional[Sequence['outputs.CloudAutonomousVmClusterMaintenanceWindowDetailsDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[int]] = None,
                 is_custom_action_timeout_enabled: Optional[bool] = None,
                 is_monthly_patching_enabled: Optional[bool] = None,
                 lead_time_in_weeks: Optional[int] = None,
                 months: Optional[Sequence['outputs.CloudAutonomousVmClusterMaintenanceWindowDetailsMonth']] = None,
                 patching_mode: Optional[str] = None,
                 preference: Optional[str] = None,
                 weeks_of_months: Optional[Sequence[int]] = None):
        """
        :param int custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['CloudAutonomousVmClusterMaintenanceWindowDetailsDaysOfWeekArgs'] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param bool is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param bool is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param int lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['CloudAutonomousVmClusterMaintenanceWindowDetailsMonthArgs'] months: (Updatable) Months during the year when maintenance should be performed.
        :param str patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param str preference: (Updatable) The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        CloudAutonomousVmClusterMaintenanceWindowDetails._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: Optional[int] = None,
             days_of_weeks: Optional[Sequence['outputs.CloudAutonomousVmClusterMaintenanceWindowDetailsDaysOfWeek']] = None,
             hours_of_days: Optional[Sequence[int]] = None,
             is_custom_action_timeout_enabled: Optional[bool] = None,
             is_monthly_patching_enabled: Optional[bool] = None,
             lead_time_in_weeks: Optional[int] = None,
             months: Optional[Sequence['outputs.CloudAutonomousVmClusterMaintenanceWindowDetailsMonth']] = None,
             patching_mode: Optional[str] = None,
             preference: Optional[str] = None,
             weeks_of_months: Optional[Sequence[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_action_timeout_in_mins is not None:
            _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            _setter("days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            _setter("hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            _setter("lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            _setter("months", months)
        if patching_mode is not None:
            _setter("patching_mode", patching_mode)
        if preference is not None:
            _setter("preference", preference)
        if weeks_of_months is not None:
            _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[int]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.CloudAutonomousVmClusterMaintenanceWindowDetailsDaysOfWeek']]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[int]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[bool]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[bool]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[int]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.CloudAutonomousVmClusterMaintenanceWindowDetailsMonth']]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[str]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> Optional[str]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[int]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class CloudAutonomousVmClusterMaintenanceWindowDetailsDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: (Updatable) Name of the month of the year.
        """
        CloudAutonomousVmClusterMaintenanceWindowDetailsDaysOfWeek._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CloudAutonomousVmClusterMaintenanceWindowDetailsMonth(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: (Updatable) Name of the month of the year.
        """
        CloudAutonomousVmClusterMaintenanceWindowDetailsMonth._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CloudAutonomousVmClusterMaintenanceWindowMonth(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: (Updatable) Name of the month of the year.
        """
        CloudAutonomousVmClusterMaintenanceWindowMonth._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CloudDatabaseManagementCredentialdetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordSecretId":
            suggest = "password_secret_id"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudDatabaseManagementCredentialdetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudDatabaseManagementCredentialdetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudDatabaseManagementCredentialdetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_secret_id: str,
                 user_name: str):
        """
        :param str password_secret_id: Specific database username's password [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param str user_name: Database username
        """
        CloudDatabaseManagementCredentialdetails._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password_secret_id=password_secret_id,
            user_name=user_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password_secret_id: str,
             user_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("password_secret_id", password_secret_id)
        _setter("user_name", user_name)

    @property
    @pulumi.getter(name="passwordSecretId")
    def password_secret_id(self) -> str:
        """
        Specific database username's password [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "password_secret_id")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> str:
        """
        Database username
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class CloudExadataInfrastructureCustomerContact(dict):
    def __init__(__self__, *,
                 email: Optional[str] = None):
        """
        :param str email: (Updatable) The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        CloudExadataInfrastructureCustomerContact._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            email=email,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             email: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if email is not None:
            _setter("email", email)

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        (Updatable) The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class CloudExadataInfrastructureMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionTimeoutInMins":
            suggest = "custom_action_timeout_in_mins"
        elif key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "isCustomActionTimeoutEnabled":
            suggest = "is_custom_action_timeout_enabled"
        elif key == "isMonthlyPatchingEnabled":
            suggest = "is_monthly_patching_enabled"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "patchingMode":
            suggest = "patching_mode"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudExadataInfrastructureMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudExadataInfrastructureMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudExadataInfrastructureMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[int] = None,
                 days_of_weeks: Optional[Sequence['outputs.CloudExadataInfrastructureMaintenanceWindowDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[int]] = None,
                 is_custom_action_timeout_enabled: Optional[bool] = None,
                 is_monthly_patching_enabled: Optional[bool] = None,
                 lead_time_in_weeks: Optional[int] = None,
                 months: Optional[Sequence['outputs.CloudExadataInfrastructureMaintenanceWindowMonth']] = None,
                 patching_mode: Optional[str] = None,
                 preference: Optional[str] = None,
                 weeks_of_months: Optional[Sequence[int]] = None):
        """
        :param int custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['CloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param bool is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param bool is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param int lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['CloudExadataInfrastructureMaintenanceWindowMonthArgs'] months: (Updatable) Months during the year when maintenance should be performed.
        :param str patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param str preference: (Updatable) The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        CloudExadataInfrastructureMaintenanceWindow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: Optional[int] = None,
             days_of_weeks: Optional[Sequence['outputs.CloudExadataInfrastructureMaintenanceWindowDaysOfWeek']] = None,
             hours_of_days: Optional[Sequence[int]] = None,
             is_custom_action_timeout_enabled: Optional[bool] = None,
             is_monthly_patching_enabled: Optional[bool] = None,
             lead_time_in_weeks: Optional[int] = None,
             months: Optional[Sequence['outputs.CloudExadataInfrastructureMaintenanceWindowMonth']] = None,
             patching_mode: Optional[str] = None,
             preference: Optional[str] = None,
             weeks_of_months: Optional[Sequence[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_action_timeout_in_mins is not None:
            _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            _setter("days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            _setter("hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            _setter("lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            _setter("months", months)
        if patching_mode is not None:
            _setter("patching_mode", patching_mode)
        if preference is not None:
            _setter("preference", preference)
        if weeks_of_months is not None:
            _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[int]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.CloudExadataInfrastructureMaintenanceWindowDaysOfWeek']]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[int]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[bool]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[bool]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[int]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.CloudExadataInfrastructureMaintenanceWindowMonth']]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[str]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> Optional[str]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[int]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class CloudExadataInfrastructureMaintenanceWindowDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: (Updatable) Name of the month of the year.
        """
        CloudExadataInfrastructureMaintenanceWindowDaysOfWeek._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CloudExadataInfrastructureMaintenanceWindowMonth(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: (Updatable) Name of the month of the year.
        """
        CloudExadataInfrastructureMaintenanceWindowMonth._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CloudVmClusterDataCollectionOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isDiagnosticsEventsEnabled":
            suggest = "is_diagnostics_events_enabled"
        elif key == "isHealthMonitoringEnabled":
            suggest = "is_health_monitoring_enabled"
        elif key == "isIncidentLogsEnabled":
            suggest = "is_incident_logs_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudVmClusterDataCollectionOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudVmClusterDataCollectionOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudVmClusterDataCollectionOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_diagnostics_events_enabled: Optional[bool] = None,
                 is_health_monitoring_enabled: Optional[bool] = None,
                 is_incident_logs_enabled: Optional[bool] = None):
        """
        :param bool is_diagnostics_events_enabled: (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param bool is_health_monitoring_enabled: (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param bool is_incident_logs_enabled: (Updatable) Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        CloudVmClusterDataCollectionOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_diagnostics_events_enabled=is_diagnostics_events_enabled,
            is_health_monitoring_enabled=is_health_monitoring_enabled,
            is_incident_logs_enabled=is_incident_logs_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_diagnostics_events_enabled: Optional[bool] = None,
             is_health_monitoring_enabled: Optional[bool] = None,
             is_incident_logs_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_diagnostics_events_enabled is not None:
            _setter("is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        if is_health_monitoring_enabled is not None:
            _setter("is_health_monitoring_enabled", is_health_monitoring_enabled)
        if is_incident_logs_enabled is not None:
            _setter("is_incident_logs_enabled", is_incident_logs_enabled)

    @property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> Optional[bool]:
        """
        (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> Optional[bool]:
        """
        (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> Optional[bool]:
        """
        (Updatable) Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")


@pulumi.output_type
class CloudVmClusterIormConfigCach(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbPlans":
            suggest = "db_plans"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudVmClusterIormConfigCach. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudVmClusterIormConfigCach.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudVmClusterIormConfigCach.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_plans: Optional[Sequence['outputs.CloudVmClusterIormConfigCachDbPlan']] = None,
                 lifecycle_details: Optional[str] = None,
                 objective: Optional[str] = None,
                 state: Optional[str] = None):
        """
        :param Sequence['CloudVmClusterIormConfigCachDbPlanArgs'] db_plans: An array of IORM settings for all the database in the Exadata DB system.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str objective: The current value for the IORM objective. The default is `AUTO`.
        :param str state: The current state of the cloud VM cluster.
        """
        CloudVmClusterIormConfigCach._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_plans=db_plans,
            lifecycle_details=lifecycle_details,
            objective=objective,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_plans: Optional[Sequence['outputs.CloudVmClusterIormConfigCachDbPlan']] = None,
             lifecycle_details: Optional[str] = None,
             objective: Optional[str] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if db_plans is not None:
            _setter("db_plans", db_plans)
        if lifecycle_details is not None:
            _setter("lifecycle_details", lifecycle_details)
        if objective is not None:
            _setter("objective", objective)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter(name="dbPlans")
    def db_plans(self) -> Optional[Sequence['outputs.CloudVmClusterIormConfigCachDbPlan']]:
        """
        An array of IORM settings for all the database in the Exadata DB system.
        """
        return pulumi.get(self, "db_plans")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[str]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def objective(self) -> Optional[str]:
        """
        The current value for the IORM objective. The default is `AUTO`.
        """
        return pulumi.get(self, "objective")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        The current state of the cloud VM cluster.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class CloudVmClusterIormConfigCachDbPlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbName":
            suggest = "db_name"
        elif key == "flashCacheLimit":
            suggest = "flash_cache_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudVmClusterIormConfigCachDbPlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudVmClusterIormConfigCachDbPlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudVmClusterIormConfigCachDbPlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_name: Optional[str] = None,
                 flash_cache_limit: Optional[str] = None,
                 share: Optional[int] = None):
        """
        :param str db_name: The database name. For the default `DbPlan`, the `dbName` is `default`.
        :param str flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        :param int share: The relative priority of this database.
        """
        CloudVmClusterIormConfigCachDbPlan._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_name=db_name,
            flash_cache_limit=flash_cache_limit,
            share=share,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_name: Optional[str] = None,
             flash_cache_limit: Optional[str] = None,
             share: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if db_name is not None:
            _setter("db_name", db_name)
        if flash_cache_limit is not None:
            _setter("flash_cache_limit", flash_cache_limit)
        if share is not None:
            _setter("share", share)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[str]:
        """
        The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> Optional[str]:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")

    @property
    @pulumi.getter
    def share(self) -> Optional[int]:
        """
        The relative priority of this database.
        """
        return pulumi.get(self, "share")


@pulumi.output_type
class CloudVmClusterIormConfigDbPlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbName":
            suggest = "db_name"
        elif key == "flashCacheLimit":
            suggest = "flash_cache_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudVmClusterIormConfigDbPlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudVmClusterIormConfigDbPlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudVmClusterIormConfigDbPlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_name: str,
                 share: int,
                 flash_cache_limit: Optional[str] = None):
        """
        :param str db_name: (Updatable) The database name. For the default `DbPlan`, the `dbName` is `default`.
        :param int share: (Updatable) The relative priority of this database.
        :param str flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        CloudVmClusterIormConfigDbPlan._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_name=db_name,
            share=share,
            flash_cache_limit=flash_cache_limit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_name: str,
             share: int,
             flash_cache_limit: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("db_name", db_name)
        _setter("share", share)
        if flash_cache_limit is not None:
            _setter("flash_cache_limit", flash_cache_limit)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> str:
        """
        (Updatable) The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter
    def share(self) -> int:
        """
        (Updatable) The relative priority of this database.
        """
        return pulumi.get(self, "share")

    @property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> Optional[str]:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")


@pulumi.output_type
class DataGuardAssociationDataCollectionOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isDiagnosticsEventsEnabled":
            suggest = "is_diagnostics_events_enabled"
        elif key == "isHealthMonitoringEnabled":
            suggest = "is_health_monitoring_enabled"
        elif key == "isIncidentLogsEnabled":
            suggest = "is_incident_logs_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataGuardAssociationDataCollectionOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataGuardAssociationDataCollectionOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataGuardAssociationDataCollectionOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_diagnostics_events_enabled: Optional[bool] = None,
                 is_health_monitoring_enabled: Optional[bool] = None,
                 is_incident_logs_enabled: Optional[bool] = None):
        """
        :param bool is_diagnostics_events_enabled: Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param bool is_health_monitoring_enabled: Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param bool is_incident_logs_enabled: Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        DataGuardAssociationDataCollectionOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_diagnostics_events_enabled=is_diagnostics_events_enabled,
            is_health_monitoring_enabled=is_health_monitoring_enabled,
            is_incident_logs_enabled=is_incident_logs_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_diagnostics_events_enabled: Optional[bool] = None,
             is_health_monitoring_enabled: Optional[bool] = None,
             is_incident_logs_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_diagnostics_events_enabled is not None:
            _setter("is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        if is_health_monitoring_enabled is not None:
            _setter("is_health_monitoring_enabled", is_health_monitoring_enabled)
        if is_incident_logs_enabled is not None:
            _setter("is_incident_logs_enabled", is_incident_logs_enabled)

    @property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> Optional[bool]:
        """
        Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> Optional[bool]:
        """
        Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> Optional[bool]:
        """
        Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")


@pulumi.output_type
class DatabaseConnectionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allConnectionStrings":
            suggest = "all_connection_strings"
        elif key == "cdbDefault":
            suggest = "cdb_default"
        elif key == "cdbIpDefault":
            suggest = "cdb_ip_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseConnectionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseConnectionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseConnectionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_connection_strings: Optional[Mapping[str, Any]] = None,
                 cdb_default: Optional[str] = None,
                 cdb_ip_default: Optional[str] = None):
        """
        :param Mapping[str, Any] all_connection_strings: All connection strings to use to connect to the Database.
        :param str cdb_default: Host name based CDB Connection String.
        :param str cdb_ip_default: IP based CDB Connection String.
        """
        DatabaseConnectionString._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_connection_strings=all_connection_strings,
            cdb_default=cdb_default,
            cdb_ip_default=cdb_ip_default,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_connection_strings: Optional[Mapping[str, Any]] = None,
             cdb_default: Optional[str] = None,
             cdb_ip_default: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if all_connection_strings is not None:
            _setter("all_connection_strings", all_connection_strings)
        if cdb_default is not None:
            _setter("cdb_default", cdb_default)
        if cdb_ip_default is not None:
            _setter("cdb_ip_default", cdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[Mapping[str, Any]]:
        """
        All connection strings to use to connect to the Database.
        """
        return pulumi.get(self, "all_connection_strings")

    @property
    @pulumi.getter(name="cdbDefault")
    def cdb_default(self) -> Optional[str]:
        """
        Host name based CDB Connection String.
        """
        return pulumi.get(self, "cdb_default")

    @property
    @pulumi.getter(name="cdbIpDefault")
    def cdb_ip_default(self) -> Optional[str]:
        """
        IP based CDB Connection String.
        """
        return pulumi.get(self, "cdb_ip_default")


@pulumi.output_type
class DatabaseDatabase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPassword":
            suggest = "admin_password"
        elif key == "dbName":
            suggest = "db_name"
        elif key == "backupId":
            suggest = "backup_id"
        elif key == "backupTdePassword":
            suggest = "backup_tde_password"
        elif key == "characterSet":
            suggest = "character_set"
        elif key == "databaseSoftwareImageId":
            suggest = "database_software_image_id"
        elif key == "dbBackupConfig":
            suggest = "db_backup_config"
        elif key == "dbUniqueName":
            suggest = "db_unique_name"
        elif key == "dbWorkload":
            suggest = "db_workload"
        elif key == "definedTags":
            suggest = "defined_tags"
        elif key == "freeformTags":
            suggest = "freeform_tags"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "kmsKeyVersionId":
            suggest = "kms_key_version_id"
        elif key == "ncharacterSet":
            suggest = "ncharacter_set"
        elif key == "pdbName":
            suggest = "pdb_name"
        elif key == "sidPrefix":
            suggest = "sid_prefix"
        elif key == "tdeWalletPassword":
            suggest = "tde_wallet_password"
        elif key == "vaultId":
            suggest = "vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseDatabase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseDatabase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseDatabase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_password: str,
                 db_name: str,
                 backup_id: Optional[str] = None,
                 backup_tde_password: Optional[str] = None,
                 character_set: Optional[str] = None,
                 database_software_image_id: Optional[str] = None,
                 db_backup_config: Optional['outputs.DatabaseDatabaseDbBackupConfig'] = None,
                 db_unique_name: Optional[str] = None,
                 db_workload: Optional[str] = None,
                 defined_tags: Optional[Mapping[str, Any]] = None,
                 freeform_tags: Optional[Mapping[str, Any]] = None,
                 kms_key_id: Optional[str] = None,
                 kms_key_version_id: Optional[str] = None,
                 ncharacter_set: Optional[str] = None,
                 pdb_name: Optional[str] = None,
                 sid_prefix: Optional[str] = None,
                 tde_wallet_password: Optional[str] = None,
                 vault_id: Optional[str] = None):
        """
        :param str admin_password: A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \\#, or -.
        :param str db_name: The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        :param str backup_id: The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param str backup_tde_password: The password to open the TDE wallet.
        :param str character_set: The character set for the database.  The default is AL32UTF8. Allowed values are:
               
               AL32UTF8, AR8ADOS710, AR8ADOS720, AR8APTEC715, AR8ARABICMACS, AR8ASMO8X, AR8ISO8859P6, AR8MSWIN1256, AR8MUSSAD768, AR8NAFITHA711, AR8NAFITHA721, AR8SAKHR706, AR8SAKHR707, AZ8ISO8859P9E, BG8MSWIN, BG8PC437S, BLT8CP921, BLT8ISO8859P13, BLT8MSWIN1257, BLT8PC775, BN8BSCII, CDN8PC863, CEL8ISO8859P14, CL8ISO8859P5, CL8ISOIR111, CL8KOI8R, CL8KOI8U, CL8MACCYRILLICS, CL8MSWIN1251, EE8ISO8859P2, EE8MACCES, EE8MACCROATIANS, EE8MSWIN1250, EE8PC852, EL8DEC, EL8ISO8859P7, EL8MACGREEKS, EL8MSWIN1253, EL8PC437S, EL8PC851, EL8PC869, ET8MSWIN923, HU8ABMOD, HU8CWI2, IN8ISCII, IS8PC861, IW8ISO8859P8, IW8MACHEBREWS, IW8MSWIN1255, IW8PC1507, JA16EUC, JA16EUCTILDE, JA16SJIS, JA16SJISTILDE, JA16VMS, KO16KSC5601, KO16KSCCS, KO16MSWIN949, LA8ISO6937, LA8PASSPORT, LT8MSWIN921, LT8PC772, LT8PC774, LV8PC1117, LV8PC8LR, LV8RST104090, N8PC865, NE8ISO8859P10, NEE8ISO8859P4, RU8BESTA, RU8PC855, RU8PC866, SE8ISO8859P3, TH8MACTHAIS, TH8TISASCII, TR8DEC, TR8MACTURKISHS, TR8MSWIN1254, TR8PC857, US7ASCII, US8PC437, UTF8, VN8MSWIN1258, VN8VN3, WE8DEC, WE8DG, WE8ISO8859P1, WE8ISO8859P15, WE8ISO8859P9, WE8MACROMAN8S, WE8MSWIN1252, WE8NCR4970, WE8NEXTSTEP, WE8PC850, WE8PC858, WE8PC860, WE8ROMAN8, ZHS16CGB231280, ZHS16GBK, ZHT16BIG5, ZHT16CCDC, ZHT16DBT, ZHT16HKSCS, ZHT16MSWIN950, ZHT32EUC, ZHT32SOPS, ZHT32TRIS
        :param str database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        :param 'DatabaseDatabaseDbBackupConfigArgs' db_backup_config: (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        :param str db_unique_name: The `DB_UNIQUE_NAME` of the Oracle Database being backed up.
        :param str db_workload: **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.
               
               The database workload type.
        :param Mapping[str, Any] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param Mapping[str, Any] freeform_tags: (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        :param str ncharacter_set: The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        :param str pdb_name: The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        :param str sid_prefix: Specifies a prefix for the `Oracle SID` of the database to be created.
        :param str tde_wallet_password: The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \\#, or -.
        :param str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        DatabaseDatabase._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            admin_password=admin_password,
            db_name=db_name,
            backup_id=backup_id,
            backup_tde_password=backup_tde_password,
            character_set=character_set,
            database_software_image_id=database_software_image_id,
            db_backup_config=db_backup_config,
            db_unique_name=db_unique_name,
            db_workload=db_workload,
            defined_tags=defined_tags,
            freeform_tags=freeform_tags,
            kms_key_id=kms_key_id,
            kms_key_version_id=kms_key_version_id,
            ncharacter_set=ncharacter_set,
            pdb_name=pdb_name,
            sid_prefix=sid_prefix,
            tde_wallet_password=tde_wallet_password,
            vault_id=vault_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             admin_password: str,
             db_name: str,
             backup_id: Optional[str] = None,
             backup_tde_password: Optional[str] = None,
             character_set: Optional[str] = None,
             database_software_image_id: Optional[str] = None,
             db_backup_config: Optional['outputs.DatabaseDatabaseDbBackupConfig'] = None,
             db_unique_name: Optional[str] = None,
             db_workload: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             kms_key_id: Optional[str] = None,
             kms_key_version_id: Optional[str] = None,
             ncharacter_set: Optional[str] = None,
             pdb_name: Optional[str] = None,
             sid_prefix: Optional[str] = None,
             tde_wallet_password: Optional[str] = None,
             vault_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("admin_password", admin_password)
        _setter("db_name", db_name)
        if backup_id is not None:
            _setter("backup_id", backup_id)
        if backup_tde_password is not None:
            _setter("backup_tde_password", backup_tde_password)
        if character_set is not None:
            _setter("character_set", character_set)
        if database_software_image_id is not None:
            _setter("database_software_image_id", database_software_image_id)
        if db_backup_config is not None:
            _setter("db_backup_config", db_backup_config)
        if db_unique_name is not None:
            _setter("db_unique_name", db_unique_name)
        if db_workload is not None:
            _setter("db_workload", db_workload)
        if defined_tags is not None:
            _setter("defined_tags", defined_tags)
        if freeform_tags is not None:
            _setter("freeform_tags", freeform_tags)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)
        if kms_key_version_id is not None:
            _setter("kms_key_version_id", kms_key_version_id)
        if ncharacter_set is not None:
            _setter("ncharacter_set", ncharacter_set)
        if pdb_name is not None:
            _setter("pdb_name", pdb_name)
        if sid_prefix is not None:
            _setter("sid_prefix", sid_prefix)
        if tde_wallet_password is not None:
            _setter("tde_wallet_password", tde_wallet_password)
        if vault_id is not None:
            _setter("vault_id", vault_id)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> str:
        """
        A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \\#, or -.
        """
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> str:
        """
        The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        """
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> Optional[str]:
        """
        The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "backup_id")

    @property
    @pulumi.getter(name="backupTdePassword")
    def backup_tde_password(self) -> Optional[str]:
        """
        The password to open the TDE wallet.
        """
        return pulumi.get(self, "backup_tde_password")

    @property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> Optional[str]:
        """
        The character set for the database.  The default is AL32UTF8. Allowed values are:

        AL32UTF8, AR8ADOS710, AR8ADOS720, AR8APTEC715, AR8ARABICMACS, AR8ASMO8X, AR8ISO8859P6, AR8MSWIN1256, AR8MUSSAD768, AR8NAFITHA711, AR8NAFITHA721, AR8SAKHR706, AR8SAKHR707, AZ8ISO8859P9E, BG8MSWIN, BG8PC437S, BLT8CP921, BLT8ISO8859P13, BLT8MSWIN1257, BLT8PC775, BN8BSCII, CDN8PC863, CEL8ISO8859P14, CL8ISO8859P5, CL8ISOIR111, CL8KOI8R, CL8KOI8U, CL8MACCYRILLICS, CL8MSWIN1251, EE8ISO8859P2, EE8MACCES, EE8MACCROATIANS, EE8MSWIN1250, EE8PC852, EL8DEC, EL8ISO8859P7, EL8MACGREEKS, EL8MSWIN1253, EL8PC437S, EL8PC851, EL8PC869, ET8MSWIN923, HU8ABMOD, HU8CWI2, IN8ISCII, IS8PC861, IW8ISO8859P8, IW8MACHEBREWS, IW8MSWIN1255, IW8PC1507, JA16EUC, JA16EUCTILDE, JA16SJIS, JA16SJISTILDE, JA16VMS, KO16KSC5601, KO16KSCCS, KO16MSWIN949, LA8ISO6937, LA8PASSPORT, LT8MSWIN921, LT8PC772, LT8PC774, LV8PC1117, LV8PC8LR, LV8RST104090, N8PC865, NE8ISO8859P10, NEE8ISO8859P4, RU8BESTA, RU8PC855, RU8PC866, SE8ISO8859P3, TH8MACTHAIS, TH8TISASCII, TR8DEC, TR8MACTURKISHS, TR8MSWIN1254, TR8PC857, US7ASCII, US8PC437, UTF8, VN8MSWIN1258, VN8VN3, WE8DEC, WE8DG, WE8ISO8859P1, WE8ISO8859P15, WE8ISO8859P9, WE8MACROMAN8S, WE8MSWIN1252, WE8NCR4970, WE8NEXTSTEP, WE8PC850, WE8PC858, WE8PC860, WE8ROMAN8, ZHS16CGB231280, ZHS16GBK, ZHT16BIG5, ZHT16CCDC, ZHT16DBT, ZHT16HKSCS, ZHT16MSWIN950, ZHT32EUC, ZHT32SOPS, ZHT32TRIS
        """
        return pulumi.get(self, "character_set")

    @property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> Optional[str]:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        return pulumi.get(self, "database_software_image_id")

    @property
    @pulumi.getter(name="dbBackupConfig")
    def db_backup_config(self) -> Optional['outputs.DatabaseDatabaseDbBackupConfig']:
        """
        (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        """
        return pulumi.get(self, "db_backup_config")

    @property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> Optional[str]:
        """
        The `DB_UNIQUE_NAME` of the Oracle Database being backed up.
        """
        return pulumi.get(self, "db_unique_name")

    @property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> Optional[str]:
        """
        **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.

        The database workload type.
        """
        return pulumi.get(self, "db_workload")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[Mapping[str, Any]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[Mapping[str, Any]]:
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> Optional[str]:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        """
        return pulumi.get(self, "kms_key_version_id")

    @property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> Optional[str]:
        """
        The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        """
        return pulumi.get(self, "ncharacter_set")

    @property
    @pulumi.getter(name="pdbName")
    def pdb_name(self) -> Optional[str]:
        """
        The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        """
        return pulumi.get(self, "pdb_name")

    @property
    @pulumi.getter(name="sidPrefix")
    def sid_prefix(self) -> Optional[str]:
        """
        Specifies a prefix for the `Oracle SID` of the database to be created.
        """
        return pulumi.get(self, "sid_prefix")

    @property
    @pulumi.getter(name="tdeWalletPassword")
    def tde_wallet_password(self) -> Optional[str]:
        """
        The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \\#, or -.
        """
        return pulumi.get(self, "tde_wallet_password")

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class DatabaseDatabaseDbBackupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoBackupEnabled":
            suggest = "auto_backup_enabled"
        elif key == "autoBackupWindow":
            suggest = "auto_backup_window"
        elif key == "autoFullBackupDay":
            suggest = "auto_full_backup_day"
        elif key == "autoFullBackupWindow":
            suggest = "auto_full_backup_window"
        elif key == "backupDeletionPolicy":
            suggest = "backup_deletion_policy"
        elif key == "backupDestinationDetails":
            suggest = "backup_destination_details"
        elif key == "recoveryWindowInDays":
            suggest = "recovery_window_in_days"
        elif key == "runImmediateFullBackup":
            suggest = "run_immediate_full_backup"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseDatabaseDbBackupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseDatabaseDbBackupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseDatabaseDbBackupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_backup_enabled: Optional[bool] = None,
                 auto_backup_window: Optional[str] = None,
                 auto_full_backup_day: Optional[str] = None,
                 auto_full_backup_window: Optional[str] = None,
                 backup_deletion_policy: Optional[str] = None,
                 backup_destination_details: Optional[Sequence['outputs.DatabaseDatabaseDbBackupConfigBackupDestinationDetail']] = None,
                 recovery_window_in_days: Optional[int] = None,
                 run_immediate_full_backup: Optional[bool] = None):
        """
        :param bool auto_backup_enabled: (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param str auto_backup_window: (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param str auto_full_backup_day: Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        :param str auto_full_backup_window: Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param str backup_deletion_policy: This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        :param Sequence['DatabaseDatabaseDbBackupConfigBackupDestinationDetailArgs'] backup_destination_details: Backup destination details.
        :param int recovery_window_in_days: (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        :param bool run_immediate_full_backup: If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        DatabaseDatabaseDbBackupConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_backup_enabled=auto_backup_enabled,
            auto_backup_window=auto_backup_window,
            auto_full_backup_day=auto_full_backup_day,
            auto_full_backup_window=auto_full_backup_window,
            backup_deletion_policy=backup_deletion_policy,
            backup_destination_details=backup_destination_details,
            recovery_window_in_days=recovery_window_in_days,
            run_immediate_full_backup=run_immediate_full_backup,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_backup_enabled: Optional[bool] = None,
             auto_backup_window: Optional[str] = None,
             auto_full_backup_day: Optional[str] = None,
             auto_full_backup_window: Optional[str] = None,
             backup_deletion_policy: Optional[str] = None,
             backup_destination_details: Optional[Sequence['outputs.DatabaseDatabaseDbBackupConfigBackupDestinationDetail']] = None,
             recovery_window_in_days: Optional[int] = None,
             run_immediate_full_backup: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if auto_backup_enabled is not None:
            _setter("auto_backup_enabled", auto_backup_enabled)
        if auto_backup_window is not None:
            _setter("auto_backup_window", auto_backup_window)
        if auto_full_backup_day is not None:
            _setter("auto_full_backup_day", auto_full_backup_day)
        if auto_full_backup_window is not None:
            _setter("auto_full_backup_window", auto_full_backup_window)
        if backup_deletion_policy is not None:
            _setter("backup_deletion_policy", backup_deletion_policy)
        if backup_destination_details is not None:
            _setter("backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            _setter("recovery_window_in_days", recovery_window_in_days)
        if run_immediate_full_backup is not None:
            _setter("run_immediate_full_backup", run_immediate_full_backup)

    @property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> Optional[bool]:
        """
        (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> Optional[str]:
        """
        (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> Optional[str]:
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        return pulumi.get(self, "auto_full_backup_day")

    @property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> Optional[str]:
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_full_backup_window")

    @property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> Optional[str]:
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        return pulumi.get(self, "backup_deletion_policy")

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[Sequence['outputs.DatabaseDatabaseDbBackupConfigBackupDestinationDetail']]:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[int]:
        """
        (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> Optional[bool]:
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        return pulumi.get(self, "run_immediate_full_backup")


@pulumi.output_type
class DatabaseDatabaseDbBackupConfigBackupDestinationDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbrsPolicyId":
            suggest = "dbrs_policy_id"
        elif key == "vpcUser":
            suggest = "vpc_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseDatabaseDbBackupConfigBackupDestinationDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseDatabaseDbBackupConfigBackupDestinationDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseDatabaseDbBackupConfigBackupDestinationDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbrs_policy_id: Optional[str] = None,
                 id: Optional[str] = None,
                 type: Optional[str] = None,
                 vpc_user: Optional[str] = None):
        """
        :param str dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param str type: Type of the database backup destination.
        """
        DatabaseDatabaseDbBackupConfigBackupDestinationDetail._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dbrs_policy_id=dbrs_policy_id,
            id=id,
            type=type,
            vpc_user=vpc_user,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dbrs_policy_id: Optional[str] = None,
             id: Optional[str] = None,
             type: Optional[str] = None,
             vpc_user: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dbrs_policy_id is not None:
            _setter("dbrs_policy_id", dbrs_policy_id)
        if id is not None:
            _setter("id", id)
        if type is not None:
            _setter("type", type)
        if vpc_user is not None:
            _setter("vpc_user", vpc_user)

    @property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[str]:
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class DatabaseDatabaseManagementConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementStatus":
            suggest = "management_status"
        elif key == "managementType":
            suggest = "management_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseDatabaseManagementConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseDatabaseManagementConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseDatabaseManagementConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_status: Optional[str] = None,
                 management_type: Optional[str] = None):
        """
        :param str management_status: The status of the Database Management service.
        :param str management_type: The Database Management type.
        """
        DatabaseDatabaseManagementConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            management_status=management_status,
            management_type=management_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             management_status: Optional[str] = None,
             management_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if management_status is not None:
            _setter("management_status", management_status)
        if management_type is not None:
            _setter("management_type", management_type)

    @property
    @pulumi.getter(name="managementStatus")
    def management_status(self) -> Optional[str]:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "management_status")

    @property
    @pulumi.getter(name="managementType")
    def management_type(self) -> Optional[str]:
        """
        The Database Management type.
        """
        return pulumi.get(self, "management_type")


@pulumi.output_type
class DatabaseDbBackupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoBackupEnabled":
            suggest = "auto_backup_enabled"
        elif key == "autoBackupWindow":
            suggest = "auto_backup_window"
        elif key == "autoFullBackupDay":
            suggest = "auto_full_backup_day"
        elif key == "autoFullBackupWindow":
            suggest = "auto_full_backup_window"
        elif key == "backupDeletionPolicy":
            suggest = "backup_deletion_policy"
        elif key == "backupDestinationDetails":
            suggest = "backup_destination_details"
        elif key == "recoveryWindowInDays":
            suggest = "recovery_window_in_days"
        elif key == "runImmediateFullBackup":
            suggest = "run_immediate_full_backup"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseDbBackupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseDbBackupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseDbBackupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_backup_enabled: Optional[bool] = None,
                 auto_backup_window: Optional[str] = None,
                 auto_full_backup_day: Optional[str] = None,
                 auto_full_backup_window: Optional[str] = None,
                 backup_deletion_policy: Optional[str] = None,
                 backup_destination_details: Optional[Sequence['outputs.DatabaseDbBackupConfigBackupDestinationDetail']] = None,
                 recovery_window_in_days: Optional[int] = None,
                 run_immediate_full_backup: Optional[bool] = None):
        """
        :param bool auto_backup_enabled: (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param str auto_backup_window: (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param str auto_full_backup_day: Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        :param str auto_full_backup_window: Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param str backup_deletion_policy: This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        :param Sequence['DatabaseDbBackupConfigBackupDestinationDetailArgs'] backup_destination_details: Backup destination details.
        :param int recovery_window_in_days: (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        :param bool run_immediate_full_backup: If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        DatabaseDbBackupConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_backup_enabled=auto_backup_enabled,
            auto_backup_window=auto_backup_window,
            auto_full_backup_day=auto_full_backup_day,
            auto_full_backup_window=auto_full_backup_window,
            backup_deletion_policy=backup_deletion_policy,
            backup_destination_details=backup_destination_details,
            recovery_window_in_days=recovery_window_in_days,
            run_immediate_full_backup=run_immediate_full_backup,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_backup_enabled: Optional[bool] = None,
             auto_backup_window: Optional[str] = None,
             auto_full_backup_day: Optional[str] = None,
             auto_full_backup_window: Optional[str] = None,
             backup_deletion_policy: Optional[str] = None,
             backup_destination_details: Optional[Sequence['outputs.DatabaseDbBackupConfigBackupDestinationDetail']] = None,
             recovery_window_in_days: Optional[int] = None,
             run_immediate_full_backup: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if auto_backup_enabled is not None:
            _setter("auto_backup_enabled", auto_backup_enabled)
        if auto_backup_window is not None:
            _setter("auto_backup_window", auto_backup_window)
        if auto_full_backup_day is not None:
            _setter("auto_full_backup_day", auto_full_backup_day)
        if auto_full_backup_window is not None:
            _setter("auto_full_backup_window", auto_full_backup_window)
        if backup_deletion_policy is not None:
            _setter("backup_deletion_policy", backup_deletion_policy)
        if backup_destination_details is not None:
            _setter("backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            _setter("recovery_window_in_days", recovery_window_in_days)
        if run_immediate_full_backup is not None:
            _setter("run_immediate_full_backup", run_immediate_full_backup)

    @property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> Optional[bool]:
        """
        (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> Optional[str]:
        """
        (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> Optional[str]:
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        return pulumi.get(self, "auto_full_backup_day")

    @property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> Optional[str]:
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_full_backup_window")

    @property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> Optional[str]:
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        return pulumi.get(self, "backup_deletion_policy")

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[Sequence['outputs.DatabaseDbBackupConfigBackupDestinationDetail']]:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[int]:
        """
        (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> Optional[bool]:
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        return pulumi.get(self, "run_immediate_full_backup")


@pulumi.output_type
class DatabaseDbBackupConfigBackupDestinationDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbrsPolicyId":
            suggest = "dbrs_policy_id"
        elif key == "vpcUser":
            suggest = "vpc_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseDbBackupConfigBackupDestinationDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseDbBackupConfigBackupDestinationDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseDbBackupConfigBackupDestinationDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbrs_policy_id: Optional[str] = None,
                 id: Optional[str] = None,
                 type: Optional[str] = None,
                 vpc_user: Optional[str] = None):
        """
        :param str dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param str type: Type of the database backup destination.
        """
        DatabaseDbBackupConfigBackupDestinationDetail._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dbrs_policy_id=dbrs_policy_id,
            id=id,
            type=type,
            vpc_user=vpc_user,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dbrs_policy_id: Optional[str] = None,
             id: Optional[str] = None,
             type: Optional[str] = None,
             vpc_user: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dbrs_policy_id is not None:
            _setter("dbrs_policy_id", dbrs_policy_id)
        if id is not None:
            _setter("id", id)
        if type is not None:
            _setter("type", type)
        if vpc_user is not None:
            _setter("vpc_user", vpc_user)

    @property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[str]:
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class DatabaseUpgradeConnectionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allConnectionStrings":
            suggest = "all_connection_strings"
        elif key == "cdbDefault":
            suggest = "cdb_default"
        elif key == "cdbIpDefault":
            suggest = "cdb_ip_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseUpgradeConnectionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseUpgradeConnectionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseUpgradeConnectionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_connection_strings: Optional[Mapping[str, Any]] = None,
                 cdb_default: Optional[str] = None,
                 cdb_ip_default: Optional[str] = None):
        """
        :param Mapping[str, Any] all_connection_strings: All connection strings to use to connect to the Database.
        :param str cdb_default: Host name based CDB Connection String.
        :param str cdb_ip_default: IP based CDB Connection String.
        """
        DatabaseUpgradeConnectionString._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_connection_strings=all_connection_strings,
            cdb_default=cdb_default,
            cdb_ip_default=cdb_ip_default,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_connection_strings: Optional[Mapping[str, Any]] = None,
             cdb_default: Optional[str] = None,
             cdb_ip_default: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if all_connection_strings is not None:
            _setter("all_connection_strings", all_connection_strings)
        if cdb_default is not None:
            _setter("cdb_default", cdb_default)
        if cdb_ip_default is not None:
            _setter("cdb_ip_default", cdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[Mapping[str, Any]]:
        """
        All connection strings to use to connect to the Database.
        """
        return pulumi.get(self, "all_connection_strings")

    @property
    @pulumi.getter(name="cdbDefault")
    def cdb_default(self) -> Optional[str]:
        """
        Host name based CDB Connection String.
        """
        return pulumi.get(self, "cdb_default")

    @property
    @pulumi.getter(name="cdbIpDefault")
    def cdb_ip_default(self) -> Optional[str]:
        """
        IP based CDB Connection String.
        """
        return pulumi.get(self, "cdb_ip_default")


@pulumi.output_type
class DatabaseUpgradeDatabaseUpgradeSourceDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseSoftwareImageId":
            suggest = "database_software_image_id"
        elif key == "dbVersion":
            suggest = "db_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseUpgradeDatabaseUpgradeSourceDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseUpgradeDatabaseUpgradeSourceDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseUpgradeDatabaseUpgradeSourceDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_software_image_id: Optional[str] = None,
                 db_version: Optional[str] = None,
                 options: Optional[str] = None,
                 source: Optional[str] = None):
        """
        :param str database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the image to be used to upgrade a database.
        :param str db_version: A valid Oracle Database version. For a list of supported versions, use the ListDbVersions operation.
               
               This cannot be updated in parallel with any of the following: licenseModel, dbEdition, cpuCoreCount, computeCount, computeModel, adminPassword, whitelistedIps, isMTLSConnectionRequired, openMode, permissionLevel, dbWorkload, privateEndpointLabel, nsgIds, isRefreshable, dbName, scheduledOperations, dbToolsDetails, isLocalDataGuardEnabled, or isFreeTier.
        :param str options: Additional upgrade options supported by DBUA(Database Upgrade Assistant). Example: "-upgradeTimezone false -keepEvents"
        :param str source: The source of the Oracle Database software to be used for the upgrade.
               * Use `DB_VERSION` to specify a generally-available Oracle Database software version to upgrade the database.
               * Use `DB_SOFTWARE_IMAGE` to specify a [database software image](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/databasesoftwareimage.htm) to upgrade the database.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        DatabaseUpgradeDatabaseUpgradeSourceDetails._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_software_image_id=database_software_image_id,
            db_version=db_version,
            options=options,
            source=source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_software_image_id: Optional[str] = None,
             db_version: Optional[str] = None,
             options: Optional[str] = None,
             source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if database_software_image_id is not None:
            _setter("database_software_image_id", database_software_image_id)
        if db_version is not None:
            _setter("db_version", db_version)
        if options is not None:
            _setter("options", options)
        if source is not None:
            _setter("source", source)

    @property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> Optional[str]:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the image to be used to upgrade a database.
        """
        return pulumi.get(self, "database_software_image_id")

    @property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> Optional[str]:
        """
        A valid Oracle Database version. For a list of supported versions, use the ListDbVersions operation.

        This cannot be updated in parallel with any of the following: licenseModel, dbEdition, cpuCoreCount, computeCount, computeModel, adminPassword, whitelistedIps, isMTLSConnectionRequired, openMode, permissionLevel, dbWorkload, privateEndpointLabel, nsgIds, isRefreshable, dbName, scheduledOperations, dbToolsDetails, isLocalDataGuardEnabled, or isFreeTier.
        """
        return pulumi.get(self, "db_version")

    @property
    @pulumi.getter
    def options(self) -> Optional[str]:
        """
        Additional upgrade options supported by DBUA(Database Upgrade Assistant). Example: "-upgradeTimezone false -keepEvents"
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        The source of the Oracle Database software to be used for the upgrade.
        * Use `DB_VERSION` to specify a generally-available Oracle Database software version to upgrade the database.
        * Use `DB_SOFTWARE_IMAGE` to specify a [database software image](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/databasesoftwareimage.htm) to upgrade the database.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class DatabaseUpgradeDbBackupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoBackupEnabled":
            suggest = "auto_backup_enabled"
        elif key == "autoBackupWindow":
            suggest = "auto_backup_window"
        elif key == "autoFullBackupDay":
            suggest = "auto_full_backup_day"
        elif key == "autoFullBackupWindow":
            suggest = "auto_full_backup_window"
        elif key == "backupDeletionPolicy":
            suggest = "backup_deletion_policy"
        elif key == "backupDestinationDetails":
            suggest = "backup_destination_details"
        elif key == "recoveryWindowInDays":
            suggest = "recovery_window_in_days"
        elif key == "runImmediateFullBackup":
            suggest = "run_immediate_full_backup"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseUpgradeDbBackupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseUpgradeDbBackupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseUpgradeDbBackupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_backup_enabled: Optional[bool] = None,
                 auto_backup_window: Optional[str] = None,
                 auto_full_backup_day: Optional[str] = None,
                 auto_full_backup_window: Optional[str] = None,
                 backup_deletion_policy: Optional[str] = None,
                 backup_destination_details: Optional[Sequence['outputs.DatabaseUpgradeDbBackupConfigBackupDestinationDetail']] = None,
                 recovery_window_in_days: Optional[int] = None,
                 run_immediate_full_backup: Optional[bool] = None):
        """
        :param bool auto_backup_enabled: If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param str auto_backup_window: Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param str auto_full_backup_day: Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        :param str auto_full_backup_window: Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param str backup_deletion_policy: This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        :param Sequence['DatabaseUpgradeDbBackupConfigBackupDestinationDetailArgs'] backup_destination_details: Backup destination details.
        :param int recovery_window_in_days: Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        :param bool run_immediate_full_backup: If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        DatabaseUpgradeDbBackupConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_backup_enabled=auto_backup_enabled,
            auto_backup_window=auto_backup_window,
            auto_full_backup_day=auto_full_backup_day,
            auto_full_backup_window=auto_full_backup_window,
            backup_deletion_policy=backup_deletion_policy,
            backup_destination_details=backup_destination_details,
            recovery_window_in_days=recovery_window_in_days,
            run_immediate_full_backup=run_immediate_full_backup,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_backup_enabled: Optional[bool] = None,
             auto_backup_window: Optional[str] = None,
             auto_full_backup_day: Optional[str] = None,
             auto_full_backup_window: Optional[str] = None,
             backup_deletion_policy: Optional[str] = None,
             backup_destination_details: Optional[Sequence['outputs.DatabaseUpgradeDbBackupConfigBackupDestinationDetail']] = None,
             recovery_window_in_days: Optional[int] = None,
             run_immediate_full_backup: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if auto_backup_enabled is not None:
            _setter("auto_backup_enabled", auto_backup_enabled)
        if auto_backup_window is not None:
            _setter("auto_backup_window", auto_backup_window)
        if auto_full_backup_day is not None:
            _setter("auto_full_backup_day", auto_full_backup_day)
        if auto_full_backup_window is not None:
            _setter("auto_full_backup_window", auto_full_backup_window)
        if backup_deletion_policy is not None:
            _setter("backup_deletion_policy", backup_deletion_policy)
        if backup_destination_details is not None:
            _setter("backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            _setter("recovery_window_in_days", recovery_window_in_days)
        if run_immediate_full_backup is not None:
            _setter("run_immediate_full_backup", run_immediate_full_backup)

    @property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> Optional[bool]:
        """
        If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> Optional[str]:
        """
        Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> Optional[str]:
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        return pulumi.get(self, "auto_full_backup_day")

    @property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> Optional[str]:
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_full_backup_window")

    @property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> Optional[str]:
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        return pulumi.get(self, "backup_deletion_policy")

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[Sequence['outputs.DatabaseUpgradeDbBackupConfigBackupDestinationDetail']]:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[int]:
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> Optional[bool]:
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        return pulumi.get(self, "run_immediate_full_backup")


@pulumi.output_type
class DatabaseUpgradeDbBackupConfigBackupDestinationDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbrsPolicyId":
            suggest = "dbrs_policy_id"
        elif key == "internetProxy":
            suggest = "internet_proxy"
        elif key == "vpcPassword":
            suggest = "vpc_password"
        elif key == "vpcUser":
            suggest = "vpc_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseUpgradeDbBackupConfigBackupDestinationDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseUpgradeDbBackupConfigBackupDestinationDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseUpgradeDbBackupConfigBackupDestinationDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbrs_policy_id: Optional[str] = None,
                 id: Optional[str] = None,
                 internet_proxy: Optional[str] = None,
                 type: Optional[str] = None,
                 vpc_password: Optional[str] = None,
                 vpc_user: Optional[str] = None):
        """
        :param str dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        :param str internet_proxy: Proxy URL to connect to object store.
        :param str type: Type of the database backup destination.
        :param str vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param str vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        DatabaseUpgradeDbBackupConfigBackupDestinationDetail._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dbrs_policy_id=dbrs_policy_id,
            id=id,
            internet_proxy=internet_proxy,
            type=type,
            vpc_password=vpc_password,
            vpc_user=vpc_user,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dbrs_policy_id: Optional[str] = None,
             id: Optional[str] = None,
             internet_proxy: Optional[str] = None,
             type: Optional[str] = None,
             vpc_password: Optional[str] = None,
             vpc_user: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dbrs_policy_id is not None:
            _setter("dbrs_policy_id", dbrs_policy_id)
        if id is not None:
            _setter("id", id)
        if internet_proxy is not None:
            _setter("internet_proxy", internet_proxy)
        if type is not None:
            _setter("type", type)
        if vpc_password is not None:
            _setter("vpc_password", vpc_password)
        if vpc_user is not None:
            _setter("vpc_user", vpc_user)

    @property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> Optional[str]:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> Optional[str]:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[str]:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class DbHomeDatabase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPassword":
            suggest = "admin_password"
        elif key == "backupId":
            suggest = "backup_id"
        elif key == "backupTdePassword":
            suggest = "backup_tde_password"
        elif key == "characterSet":
            suggest = "character_set"
        elif key == "connectionStrings":
            suggest = "connection_strings"
        elif key == "databaseId":
            suggest = "database_id"
        elif key == "databaseSoftwareImageId":
            suggest = "database_software_image_id"
        elif key == "dbBackupConfig":
            suggest = "db_backup_config"
        elif key == "dbName":
            suggest = "db_name"
        elif key == "dbUniqueName":
            suggest = "db_unique_name"
        elif key == "dbWorkload":
            suggest = "db_workload"
        elif key == "definedTags":
            suggest = "defined_tags"
        elif key == "freeformTags":
            suggest = "freeform_tags"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "kmsKeyVersionId":
            suggest = "kms_key_version_id"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"
        elif key == "ncharacterSet":
            suggest = "ncharacter_set"
        elif key == "oneOffPatches":
            suggest = "one_off_patches"
        elif key == "pdbName":
            suggest = "pdb_name"
        elif key == "sidPrefix":
            suggest = "sid_prefix"
        elif key == "tdeWalletPassword":
            suggest = "tde_wallet_password"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeStampForPointInTimeRecovery":
            suggest = "time_stamp_for_point_in_time_recovery"
        elif key == "vaultId":
            suggest = "vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbHomeDatabase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbHomeDatabase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbHomeDatabase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_password: str,
                 backup_id: Optional[str] = None,
                 backup_tde_password: Optional[str] = None,
                 character_set: Optional[str] = None,
                 connection_strings: Optional[Sequence['outputs.DbHomeDatabaseConnectionString']] = None,
                 database_id: Optional[str] = None,
                 database_software_image_id: Optional[str] = None,
                 db_backup_config: Optional['outputs.DbHomeDatabaseDbBackupConfig'] = None,
                 db_name: Optional[str] = None,
                 db_unique_name: Optional[str] = None,
                 db_workload: Optional[str] = None,
                 defined_tags: Optional[Mapping[str, Any]] = None,
                 freeform_tags: Optional[Mapping[str, Any]] = None,
                 id: Optional[str] = None,
                 kms_key_id: Optional[str] = None,
                 kms_key_version_id: Optional[str] = None,
                 lifecycle_details: Optional[str] = None,
                 ncharacter_set: Optional[str] = None,
                 one_off_patches: Optional[Sequence[str]] = None,
                 pdb_name: Optional[str] = None,
                 sid_prefix: Optional[str] = None,
                 state: Optional[str] = None,
                 tde_wallet_password: Optional[str] = None,
                 time_created: Optional[str] = None,
                 time_stamp_for_point_in_time_recovery: Optional[str] = None,
                 vault_id: Optional[str] = None):
        """
        :param str admin_password: A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \\#, or -.
        :param str backup_id: The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param str backup_tde_password: The password to open the TDE wallet.
        :param str character_set: The character set for the database.  The default is AL32UTF8. Allowed values are:
               
               AL32UTF8, AR8ADOS710, AR8ADOS720, AR8APTEC715, AR8ARABICMACS, AR8ASMO8X, AR8ISO8859P6, AR8MSWIN1256, AR8MUSSAD768, AR8NAFITHA711, AR8NAFITHA721, AR8SAKHR706, AR8SAKHR707, AZ8ISO8859P9E, BG8MSWIN, BG8PC437S, BLT8CP921, BLT8ISO8859P13, BLT8MSWIN1257, BLT8PC775, BN8BSCII, CDN8PC863, CEL8ISO8859P14, CL8ISO8859P5, CL8ISOIR111, CL8KOI8R, CL8KOI8U, CL8MACCYRILLICS, CL8MSWIN1251, EE8ISO8859P2, EE8MACCES, EE8MACCROATIANS, EE8MSWIN1250, EE8PC852, EL8DEC, EL8ISO8859P7, EL8MACGREEKS, EL8MSWIN1253, EL8PC437S, EL8PC851, EL8PC869, ET8MSWIN923, HU8ABMOD, HU8CWI2, IN8ISCII, IS8PC861, IW8ISO8859P8, IW8MACHEBREWS, IW8MSWIN1255, IW8PC1507, JA16EUC, JA16EUCTILDE, JA16SJIS, JA16SJISTILDE, JA16VMS, KO16KSC5601, KO16KSCCS, KO16MSWIN949, LA8ISO6937, LA8PASSPORT, LT8MSWIN921, LT8PC772, LT8PC774, LV8PC1117, LV8PC8LR, LV8RST104090, N8PC865, NE8ISO8859P10, NEE8ISO8859P4, RU8BESTA, RU8PC855, RU8PC866, SE8ISO8859P3, TH8MACTHAIS, TH8TISASCII, TR8DEC, TR8MACTURKISHS, TR8MSWIN1254, TR8PC857, US7ASCII, US8PC437, UTF8, VN8MSWIN1258, VN8VN3, WE8DEC, WE8DG, WE8ISO8859P1, WE8ISO8859P15, WE8ISO8859P9, WE8MACROMAN8S, WE8MSWIN1252, WE8NCR4970, WE8NEXTSTEP, WE8PC850, WE8PC858, WE8PC860, WE8ROMAN8, ZHS16CGB231280, ZHS16GBK, ZHT16BIG5, ZHT16CCDC, ZHT16DBT, ZHT16HKSCS, ZHT16MSWIN950, ZHT32EUC, ZHT32SOPS, ZHT32TRIS
        :param str database_id: The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param str database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        :param 'DbHomeDatabaseDbBackupConfigArgs' db_backup_config: (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        :param str db_name: The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        :param str db_workload: **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.
               
               The database workload type.
        :param Mapping[str, Any] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param Mapping[str, Any] freeform_tags: (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str ncharacter_set: The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        :param Sequence[str] one_off_patches: List of one-off patches for Database Homes.
        :param str pdb_name: The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        :param str sid_prefix: Specifies a prefix for the `Oracle SID` of the database to be created.
        :param str state: The current state of the Database Home.
        :param str tde_wallet_password: The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \\#, or -.
        :param str time_created: The date and time the Database Home was created.
        :param str time_stamp_for_point_in_time_recovery: The point in time of the original database from which the new database is created. If not specifed, the latest backup is used to create the database.
        :param str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        DbHomeDatabase._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            admin_password=admin_password,
            backup_id=backup_id,
            backup_tde_password=backup_tde_password,
            character_set=character_set,
            connection_strings=connection_strings,
            database_id=database_id,
            database_software_image_id=database_software_image_id,
            db_backup_config=db_backup_config,
            db_name=db_name,
            db_unique_name=db_unique_name,
            db_workload=db_workload,
            defined_tags=defined_tags,
            freeform_tags=freeform_tags,
            id=id,
            kms_key_id=kms_key_id,
            kms_key_version_id=kms_key_version_id,
            lifecycle_details=lifecycle_details,
            ncharacter_set=ncharacter_set,
            one_off_patches=one_off_patches,
            pdb_name=pdb_name,
            sid_prefix=sid_prefix,
            state=state,
            tde_wallet_password=tde_wallet_password,
            time_created=time_created,
            time_stamp_for_point_in_time_recovery=time_stamp_for_point_in_time_recovery,
            vault_id=vault_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             admin_password: str,
             backup_id: Optional[str] = None,
             backup_tde_password: Optional[str] = None,
             character_set: Optional[str] = None,
             connection_strings: Optional[Sequence['outputs.DbHomeDatabaseConnectionString']] = None,
             database_id: Optional[str] = None,
             database_software_image_id: Optional[str] = None,
             db_backup_config: Optional['outputs.DbHomeDatabaseDbBackupConfig'] = None,
             db_name: Optional[str] = None,
             db_unique_name: Optional[str] = None,
             db_workload: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             kms_key_id: Optional[str] = None,
             kms_key_version_id: Optional[str] = None,
             lifecycle_details: Optional[str] = None,
             ncharacter_set: Optional[str] = None,
             one_off_patches: Optional[Sequence[str]] = None,
             pdb_name: Optional[str] = None,
             sid_prefix: Optional[str] = None,
             state: Optional[str] = None,
             tde_wallet_password: Optional[str] = None,
             time_created: Optional[str] = None,
             time_stamp_for_point_in_time_recovery: Optional[str] = None,
             vault_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("admin_password", admin_password)
        if backup_id is not None:
            _setter("backup_id", backup_id)
        if backup_tde_password is not None:
            _setter("backup_tde_password", backup_tde_password)
        if character_set is not None:
            _setter("character_set", character_set)
        if connection_strings is not None:
            _setter("connection_strings", connection_strings)
        if database_id is not None:
            _setter("database_id", database_id)
        if database_software_image_id is not None:
            _setter("database_software_image_id", database_software_image_id)
        if db_backup_config is not None:
            _setter("db_backup_config", db_backup_config)
        if db_name is not None:
            _setter("db_name", db_name)
        if db_unique_name is not None:
            _setter("db_unique_name", db_unique_name)
        if db_workload is not None:
            _setter("db_workload", db_workload)
        if defined_tags is not None:
            _setter("defined_tags", defined_tags)
        if freeform_tags is not None:
            _setter("freeform_tags", freeform_tags)
        if id is not None:
            _setter("id", id)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)
        if kms_key_version_id is not None:
            _setter("kms_key_version_id", kms_key_version_id)
        if lifecycle_details is not None:
            _setter("lifecycle_details", lifecycle_details)
        if ncharacter_set is not None:
            _setter("ncharacter_set", ncharacter_set)
        if one_off_patches is not None:
            _setter("one_off_patches", one_off_patches)
        if pdb_name is not None:
            _setter("pdb_name", pdb_name)
        if sid_prefix is not None:
            _setter("sid_prefix", sid_prefix)
        if state is not None:
            _setter("state", state)
        if tde_wallet_password is not None:
            _setter("tde_wallet_password", tde_wallet_password)
        if time_created is not None:
            _setter("time_created", time_created)
        if time_stamp_for_point_in_time_recovery is not None:
            _setter("time_stamp_for_point_in_time_recovery", time_stamp_for_point_in_time_recovery)
        if vault_id is not None:
            _setter("vault_id", vault_id)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> str:
        """
        A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \\#, or -.
        """
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> Optional[str]:
        """
        The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "backup_id")

    @property
    @pulumi.getter(name="backupTdePassword")
    def backup_tde_password(self) -> Optional[str]:
        """
        The password to open the TDE wallet.
        """
        return pulumi.get(self, "backup_tde_password")

    @property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> Optional[str]:
        """
        The character set for the database.  The default is AL32UTF8. Allowed values are:

        AL32UTF8, AR8ADOS710, AR8ADOS720, AR8APTEC715, AR8ARABICMACS, AR8ASMO8X, AR8ISO8859P6, AR8MSWIN1256, AR8MUSSAD768, AR8NAFITHA711, AR8NAFITHA721, AR8SAKHR706, AR8SAKHR707, AZ8ISO8859P9E, BG8MSWIN, BG8PC437S, BLT8CP921, BLT8ISO8859P13, BLT8MSWIN1257, BLT8PC775, BN8BSCII, CDN8PC863, CEL8ISO8859P14, CL8ISO8859P5, CL8ISOIR111, CL8KOI8R, CL8KOI8U, CL8MACCYRILLICS, CL8MSWIN1251, EE8ISO8859P2, EE8MACCES, EE8MACCROATIANS, EE8MSWIN1250, EE8PC852, EL8DEC, EL8ISO8859P7, EL8MACGREEKS, EL8MSWIN1253, EL8PC437S, EL8PC851, EL8PC869, ET8MSWIN923, HU8ABMOD, HU8CWI2, IN8ISCII, IS8PC861, IW8ISO8859P8, IW8MACHEBREWS, IW8MSWIN1255, IW8PC1507, JA16EUC, JA16EUCTILDE, JA16SJIS, JA16SJISTILDE, JA16VMS, KO16KSC5601, KO16KSCCS, KO16MSWIN949, LA8ISO6937, LA8PASSPORT, LT8MSWIN921, LT8PC772, LT8PC774, LV8PC1117, LV8PC8LR, LV8RST104090, N8PC865, NE8ISO8859P10, NEE8ISO8859P4, RU8BESTA, RU8PC855, RU8PC866, SE8ISO8859P3, TH8MACTHAIS, TH8TISASCII, TR8DEC, TR8MACTURKISHS, TR8MSWIN1254, TR8PC857, US7ASCII, US8PC437, UTF8, VN8MSWIN1258, VN8VN3, WE8DEC, WE8DG, WE8ISO8859P1, WE8ISO8859P15, WE8ISO8859P9, WE8MACROMAN8S, WE8MSWIN1252, WE8NCR4970, WE8NEXTSTEP, WE8PC850, WE8PC858, WE8PC860, WE8ROMAN8, ZHS16CGB231280, ZHS16GBK, ZHT16BIG5, ZHT16CCDC, ZHT16DBT, ZHT16HKSCS, ZHT16MSWIN950, ZHT32EUC, ZHT32SOPS, ZHT32TRIS
        """
        return pulumi.get(self, "character_set")

    @property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Optional[Sequence['outputs.DbHomeDatabaseConnectionString']]:
        return pulumi.get(self, "connection_strings")

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[str]:
        """
        The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "database_id")

    @property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> Optional[str]:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        return pulumi.get(self, "database_software_image_id")

    @property
    @pulumi.getter(name="dbBackupConfig")
    def db_backup_config(self) -> Optional['outputs.DbHomeDatabaseDbBackupConfig']:
        """
        (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        """
        return pulumi.get(self, "db_backup_config")

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[str]:
        """
        The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        """
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> Optional[str]:
        return pulumi.get(self, "db_unique_name")

    @property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> Optional[str]:
        """
        **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.

        The database workload type.
        """
        return pulumi.get(self, "db_workload")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[Mapping[str, Any]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[Mapping[str, Any]]:
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> Optional[str]:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        """
        return pulumi.get(self, "kms_key_version_id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[str]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> Optional[str]:
        """
        The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        """
        return pulumi.get(self, "ncharacter_set")

    @property
    @pulumi.getter(name="oneOffPatches")
    def one_off_patches(self) -> Optional[Sequence[str]]:
        """
        List of one-off patches for Database Homes.
        """
        return pulumi.get(self, "one_off_patches")

    @property
    @pulumi.getter(name="pdbName")
    def pdb_name(self) -> Optional[str]:
        """
        The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        """
        return pulumi.get(self, "pdb_name")

    @property
    @pulumi.getter(name="sidPrefix")
    def sid_prefix(self) -> Optional[str]:
        """
        Specifies a prefix for the `Oracle SID` of the database to be created.
        """
        return pulumi.get(self, "sid_prefix")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        The current state of the Database Home.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="tdeWalletPassword")
    def tde_wallet_password(self) -> Optional[str]:
        """
        The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \\#, or -.
        """
        return pulumi.get(self, "tde_wallet_password")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[str]:
        """
        The date and time the Database Home was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeStampForPointInTimeRecovery")
    def time_stamp_for_point_in_time_recovery(self) -> Optional[str]:
        """
        The point in time of the original database from which the new database is created. If not specifed, the latest backup is used to create the database.
        """
        return pulumi.get(self, "time_stamp_for_point_in_time_recovery")

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class DbHomeDatabaseConnectionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allConnectionStrings":
            suggest = "all_connection_strings"
        elif key == "cdbDefault":
            suggest = "cdb_default"
        elif key == "cdbIpDefault":
            suggest = "cdb_ip_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbHomeDatabaseConnectionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbHomeDatabaseConnectionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbHomeDatabaseConnectionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_connection_strings: Optional[Mapping[str, Any]] = None,
                 cdb_default: Optional[str] = None,
                 cdb_ip_default: Optional[str] = None):
        DbHomeDatabaseConnectionString._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_connection_strings=all_connection_strings,
            cdb_default=cdb_default,
            cdb_ip_default=cdb_ip_default,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_connection_strings: Optional[Mapping[str, Any]] = None,
             cdb_default: Optional[str] = None,
             cdb_ip_default: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if all_connection_strings is not None:
            _setter("all_connection_strings", all_connection_strings)
        if cdb_default is not None:
            _setter("cdb_default", cdb_default)
        if cdb_ip_default is not None:
            _setter("cdb_ip_default", cdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "all_connection_strings")

    @property
    @pulumi.getter(name="cdbDefault")
    def cdb_default(self) -> Optional[str]:
        return pulumi.get(self, "cdb_default")

    @property
    @pulumi.getter(name="cdbIpDefault")
    def cdb_ip_default(self) -> Optional[str]:
        return pulumi.get(self, "cdb_ip_default")


@pulumi.output_type
class DbHomeDatabaseDbBackupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoBackupEnabled":
            suggest = "auto_backup_enabled"
        elif key == "autoBackupWindow":
            suggest = "auto_backup_window"
        elif key == "autoFullBackupDay":
            suggest = "auto_full_backup_day"
        elif key == "autoFullBackupWindow":
            suggest = "auto_full_backup_window"
        elif key == "backupDeletionPolicy":
            suggest = "backup_deletion_policy"
        elif key == "backupDestinationDetails":
            suggest = "backup_destination_details"
        elif key == "recoveryWindowInDays":
            suggest = "recovery_window_in_days"
        elif key == "runImmediateFullBackup":
            suggest = "run_immediate_full_backup"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbHomeDatabaseDbBackupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbHomeDatabaseDbBackupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbHomeDatabaseDbBackupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_backup_enabled: Optional[bool] = None,
                 auto_backup_window: Optional[str] = None,
                 auto_full_backup_day: Optional[str] = None,
                 auto_full_backup_window: Optional[str] = None,
                 backup_deletion_policy: Optional[str] = None,
                 backup_destination_details: Optional[Sequence['outputs.DbHomeDatabaseDbBackupConfigBackupDestinationDetail']] = None,
                 recovery_window_in_days: Optional[int] = None,
                 run_immediate_full_backup: Optional[bool] = None):
        """
        :param bool auto_backup_enabled: (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param str auto_backup_window: (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param str auto_full_backup_day: Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        :param str auto_full_backup_window: Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param str backup_deletion_policy: This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        :param Sequence['DbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs'] backup_destination_details: Backup destination details.
        :param int recovery_window_in_days: (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        :param bool run_immediate_full_backup: If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        DbHomeDatabaseDbBackupConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_backup_enabled=auto_backup_enabled,
            auto_backup_window=auto_backup_window,
            auto_full_backup_day=auto_full_backup_day,
            auto_full_backup_window=auto_full_backup_window,
            backup_deletion_policy=backup_deletion_policy,
            backup_destination_details=backup_destination_details,
            recovery_window_in_days=recovery_window_in_days,
            run_immediate_full_backup=run_immediate_full_backup,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_backup_enabled: Optional[bool] = None,
             auto_backup_window: Optional[str] = None,
             auto_full_backup_day: Optional[str] = None,
             auto_full_backup_window: Optional[str] = None,
             backup_deletion_policy: Optional[str] = None,
             backup_destination_details: Optional[Sequence['outputs.DbHomeDatabaseDbBackupConfigBackupDestinationDetail']] = None,
             recovery_window_in_days: Optional[int] = None,
             run_immediate_full_backup: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if auto_backup_enabled is not None:
            _setter("auto_backup_enabled", auto_backup_enabled)
        if auto_backup_window is not None:
            _setter("auto_backup_window", auto_backup_window)
        if auto_full_backup_day is not None:
            _setter("auto_full_backup_day", auto_full_backup_day)
        if auto_full_backup_window is not None:
            _setter("auto_full_backup_window", auto_full_backup_window)
        if backup_deletion_policy is not None:
            _setter("backup_deletion_policy", backup_deletion_policy)
        if backup_destination_details is not None:
            _setter("backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            _setter("recovery_window_in_days", recovery_window_in_days)
        if run_immediate_full_backup is not None:
            _setter("run_immediate_full_backup", run_immediate_full_backup)

    @property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> Optional[bool]:
        """
        (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> Optional[str]:
        """
        (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> Optional[str]:
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        return pulumi.get(self, "auto_full_backup_day")

    @property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> Optional[str]:
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_full_backup_window")

    @property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> Optional[str]:
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        return pulumi.get(self, "backup_deletion_policy")

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[Sequence['outputs.DbHomeDatabaseDbBackupConfigBackupDestinationDetail']]:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[int]:
        """
        (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> Optional[bool]:
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        return pulumi.get(self, "run_immediate_full_backup")


@pulumi.output_type
class DbHomeDatabaseDbBackupConfigBackupDestinationDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbrsPolicyId":
            suggest = "dbrs_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbHomeDatabaseDbBackupConfigBackupDestinationDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbHomeDatabaseDbBackupConfigBackupDestinationDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbHomeDatabaseDbBackupConfigBackupDestinationDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbrs_policy_id: Optional[str] = None,
                 id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param str type: Type of the database backup destination. Supported values: `NFS`.
        """
        DbHomeDatabaseDbBackupConfigBackupDestinationDetail._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dbrs_policy_id=dbrs_policy_id,
            id=id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dbrs_policy_id: Optional[str] = None,
             id: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dbrs_policy_id is not None:
            _setter("dbrs_policy_id", dbrs_policy_id)
        if id is not None:
            _setter("id", id)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the database backup destination. Supported values: `NFS`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DbSystemDataCollectionOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isDiagnosticsEventsEnabled":
            suggest = "is_diagnostics_events_enabled"
        elif key == "isHealthMonitoringEnabled":
            suggest = "is_health_monitoring_enabled"
        elif key == "isIncidentLogsEnabled":
            suggest = "is_incident_logs_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbSystemDataCollectionOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbSystemDataCollectionOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbSystemDataCollectionOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_diagnostics_events_enabled: Optional[bool] = None,
                 is_health_monitoring_enabled: Optional[bool] = None,
                 is_incident_logs_enabled: Optional[bool] = None):
        """
        :param bool is_diagnostics_events_enabled: (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param bool is_health_monitoring_enabled: (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param bool is_incident_logs_enabled: (Updatable) Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        DbSystemDataCollectionOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_diagnostics_events_enabled=is_diagnostics_events_enabled,
            is_health_monitoring_enabled=is_health_monitoring_enabled,
            is_incident_logs_enabled=is_incident_logs_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_diagnostics_events_enabled: Optional[bool] = None,
             is_health_monitoring_enabled: Optional[bool] = None,
             is_incident_logs_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_diagnostics_events_enabled is not None:
            _setter("is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        if is_health_monitoring_enabled is not None:
            _setter("is_health_monitoring_enabled", is_health_monitoring_enabled)
        if is_incident_logs_enabled is not None:
            _setter("is_incident_logs_enabled", is_incident_logs_enabled)

    @property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> Optional[bool]:
        """
        (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> Optional[bool]:
        """
        (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> Optional[bool]:
        """
        (Updatable) Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")


@pulumi.output_type
class DbSystemDbHome(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createAsync":
            suggest = "create_async"
        elif key == "databaseSoftwareImageId":
            suggest = "database_software_image_id"
        elif key == "dbHomeLocation":
            suggest = "db_home_location"
        elif key == "dbVersion":
            suggest = "db_version"
        elif key == "definedTags":
            suggest = "defined_tags"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "freeformTags":
            suggest = "freeform_tags"
        elif key == "lastPatchHistoryEntryId":
            suggest = "last_patch_history_entry_id"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"
        elif key == "timeCreated":
            suggest = "time_created"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbSystemDbHome. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbSystemDbHome.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbSystemDbHome.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: 'outputs.DbSystemDbHomeDatabase',
                 create_async: Optional[bool] = None,
                 database_software_image_id: Optional[str] = None,
                 db_home_location: Optional[str] = None,
                 db_version: Optional[str] = None,
                 defined_tags: Optional[Mapping[str, Any]] = None,
                 display_name: Optional[str] = None,
                 freeform_tags: Optional[Mapping[str, Any]] = None,
                 id: Optional[str] = None,
                 last_patch_history_entry_id: Optional[str] = None,
                 lifecycle_details: Optional[str] = None,
                 state: Optional[str] = None,
                 time_created: Optional[str] = None):
        """
        :param 'DbSystemDbHomeDatabaseArgs' database: (Updatable) Details for creating a database by restoring from a source database system.
               
               **Warning:** Oracle recommends that you avoid using any confidential information when you supply string values using the API.
        :param str database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the image to be used to restore a database.
        :param str db_version: A valid Oracle Database version. For a list of supported versions, use the ListDbVersions operation.
               
               This cannot be updated in parallel with any of the following: licenseModel, dbEdition, cpuCoreCount, computeCount, computeModel, adminPassword, whitelistedIps, isMTLSConnectionRequired, openMode, permissionLevel, dbWorkload, privateEndpointLabel, nsgIds, isRefreshable, dbName, scheduledOperations, dbToolsDetails, isLocalDataGuardEnabled, or isFreeTier.
        :param Mapping[str, Any] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str display_name: The user-friendly name for the DB system. The name does not have to be unique.
        :param Mapping[str, Any] freeform_tags: (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param str last_patch_history_entry_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last patch history. This value is updated as soon as a patch operation starts.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str state: The current state of the DB system.
        :param str time_created: The date and time the DB system was created.
        """
        DbSystemDbHome._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database=database,
            create_async=create_async,
            database_software_image_id=database_software_image_id,
            db_home_location=db_home_location,
            db_version=db_version,
            defined_tags=defined_tags,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            last_patch_history_entry_id=last_patch_history_entry_id,
            lifecycle_details=lifecycle_details,
            state=state,
            time_created=time_created,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database: 'outputs.DbSystemDbHomeDatabase',
             create_async: Optional[bool] = None,
             database_software_image_id: Optional[str] = None,
             db_home_location: Optional[str] = None,
             db_version: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             display_name: Optional[str] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             last_patch_history_entry_id: Optional[str] = None,
             lifecycle_details: Optional[str] = None,
             state: Optional[str] = None,
             time_created: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database", database)
        if create_async is not None:
            _setter("create_async", create_async)
        if database_software_image_id is not None:
            _setter("database_software_image_id", database_software_image_id)
        if db_home_location is not None:
            _setter("db_home_location", db_home_location)
        if db_version is not None:
            _setter("db_version", db_version)
        if defined_tags is not None:
            _setter("defined_tags", defined_tags)
        if display_name is not None:
            _setter("display_name", display_name)
        if freeform_tags is not None:
            _setter("freeform_tags", freeform_tags)
        if id is not None:
            _setter("id", id)
        if last_patch_history_entry_id is not None:
            _setter("last_patch_history_entry_id", last_patch_history_entry_id)
        if lifecycle_details is not None:
            _setter("lifecycle_details", lifecycle_details)
        if state is not None:
            _setter("state", state)
        if time_created is not None:
            _setter("time_created", time_created)

    @property
    @pulumi.getter
    def database(self) -> 'outputs.DbSystemDbHomeDatabase':
        """
        (Updatable) Details for creating a database by restoring from a source database system.

        **Warning:** Oracle recommends that you avoid using any confidential information when you supply string values using the API.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="createAsync")
    def create_async(self) -> Optional[bool]:
        return pulumi.get(self, "create_async")

    @property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> Optional[str]:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the image to be used to restore a database.
        """
        return pulumi.get(self, "database_software_image_id")

    @property
    @pulumi.getter(name="dbHomeLocation")
    def db_home_location(self) -> Optional[str]:
        return pulumi.get(self, "db_home_location")

    @property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> Optional[str]:
        """
        A valid Oracle Database version. For a list of supported versions, use the ListDbVersions operation.

        This cannot be updated in parallel with any of the following: licenseModel, dbEdition, cpuCoreCount, computeCount, computeModel, adminPassword, whitelistedIps, isMTLSConnectionRequired, openMode, permissionLevel, dbWorkload, privateEndpointLabel, nsgIds, isRefreshable, dbName, scheduledOperations, dbToolsDetails, isLocalDataGuardEnabled, or isFreeTier.
        """
        return pulumi.get(self, "db_version")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[Mapping[str, Any]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        The user-friendly name for the DB system. The name does not have to be unique.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[Mapping[str, Any]]:
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastPatchHistoryEntryId")
    def last_patch_history_entry_id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last patch history. This value is updated as soon as a patch operation starts.
        """
        return pulumi.get(self, "last_patch_history_entry_id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[str]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        The current state of the DB system.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[str]:
        """
        The date and time the DB system was created.
        """
        return pulumi.get(self, "time_created")


@pulumi.output_type
class DbSystemDbHomeDatabase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPassword":
            suggest = "admin_password"
        elif key == "backupId":
            suggest = "backup_id"
        elif key == "backupTdePassword":
            suggest = "backup_tde_password"
        elif key == "characterSet":
            suggest = "character_set"
        elif key == "connectionStrings":
            suggest = "connection_strings"
        elif key == "databaseId":
            suggest = "database_id"
        elif key == "databaseSoftwareImageId":
            suggest = "database_software_image_id"
        elif key == "dbBackupConfig":
            suggest = "db_backup_config"
        elif key == "dbDomain":
            suggest = "db_domain"
        elif key == "dbName":
            suggest = "db_name"
        elif key == "dbUniqueName":
            suggest = "db_unique_name"
        elif key == "dbWorkload":
            suggest = "db_workload"
        elif key == "definedTags":
            suggest = "defined_tags"
        elif key == "freeformTags":
            suggest = "freeform_tags"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "kmsKeyVersionId":
            suggest = "kms_key_version_id"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"
        elif key == "ncharacterSet":
            suggest = "ncharacter_set"
        elif key == "pdbName":
            suggest = "pdb_name"
        elif key == "tdeWalletPassword":
            suggest = "tde_wallet_password"
        elif key == "timeCreated":
            suggest = "time_created"
        elif key == "timeStampForPointInTimeRecovery":
            suggest = "time_stamp_for_point_in_time_recovery"
        elif key == "vaultId":
            suggest = "vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbSystemDbHomeDatabase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbSystemDbHomeDatabase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbSystemDbHomeDatabase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_password: str,
                 backup_id: Optional[str] = None,
                 backup_tde_password: Optional[str] = None,
                 character_set: Optional[str] = None,
                 connection_strings: Optional[Sequence['outputs.DbSystemDbHomeDatabaseConnectionString']] = None,
                 database_id: Optional[str] = None,
                 database_software_image_id: Optional[str] = None,
                 db_backup_config: Optional['outputs.DbSystemDbHomeDatabaseDbBackupConfig'] = None,
                 db_domain: Optional[str] = None,
                 db_name: Optional[str] = None,
                 db_unique_name: Optional[str] = None,
                 db_workload: Optional[str] = None,
                 defined_tags: Optional[Mapping[str, Any]] = None,
                 freeform_tags: Optional[Mapping[str, Any]] = None,
                 id: Optional[str] = None,
                 kms_key_id: Optional[str] = None,
                 kms_key_version_id: Optional[str] = None,
                 lifecycle_details: Optional[str] = None,
                 ncharacter_set: Optional[str] = None,
                 pdb_name: Optional[str] = None,
                 state: Optional[str] = None,
                 tde_wallet_password: Optional[str] = None,
                 time_created: Optional[str] = None,
                 time_stamp_for_point_in_time_recovery: Optional[str] = None,
                 vault_id: Optional[str] = None):
        """
        :param str admin_password: A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \\#, or -.
        :param str backup_id: The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param str backup_tde_password: The password to open the TDE wallet.
        :param str character_set: The character set for the database.  The default is AL32UTF8. Allowed values are:
               
               AL32UTF8, AR8ADOS710, AR8ADOS720, AR8APTEC715, AR8ARABICMACS, AR8ASMO8X, AR8ISO8859P6, AR8MSWIN1256, AR8MUSSAD768, AR8NAFITHA711, AR8NAFITHA721, AR8SAKHR706, AR8SAKHR707, AZ8ISO8859P9E, BG8MSWIN, BG8PC437S, BLT8CP921, BLT8ISO8859P13, BLT8MSWIN1257, BLT8PC775, BN8BSCII, CDN8PC863, CEL8ISO8859P14, CL8ISO8859P5, CL8ISOIR111, CL8KOI8R, CL8KOI8U, CL8MACCYRILLICS, CL8MSWIN1251, EE8ISO8859P2, EE8MACCES, EE8MACCROATIANS, EE8MSWIN1250, EE8PC852, EL8DEC, EL8ISO8859P7, EL8MACGREEKS, EL8MSWIN1253, EL8PC437S, EL8PC851, EL8PC869, ET8MSWIN923, HU8ABMOD, HU8CWI2, IN8ISCII, IS8PC861, IW8ISO8859P8, IW8MACHEBREWS, IW8MSWIN1255, IW8PC1507, JA16EUC, JA16EUCTILDE, JA16SJIS, JA16SJISTILDE, JA16VMS, KO16KSC5601, KO16KSCCS, KO16MSWIN949, LA8ISO6937, LA8PASSPORT, LT8MSWIN921, LT8PC772, LT8PC774, LV8PC1117, LV8PC8LR, LV8RST104090, N8PC865, NE8ISO8859P10, NEE8ISO8859P4, RU8BESTA, RU8PC855, RU8PC866, SE8ISO8859P3, TH8MACTHAIS, TH8TISASCII, TR8DEC, TR8MACTURKISHS, TR8MSWIN1254, TR8PC857, US7ASCII, US8PC437, UTF8, VN8MSWIN1258, VN8VN3, WE8DEC, WE8DG, WE8ISO8859P1, WE8ISO8859P15, WE8ISO8859P9, WE8MACROMAN8S, WE8MSWIN1252, WE8NCR4970, WE8NEXTSTEP, WE8PC850, WE8PC858, WE8PC860, WE8ROMAN8, ZHS16CGB231280, ZHS16GBK, ZHT16BIG5, ZHT16CCDC, ZHT16DBT, ZHT16HKSCS, ZHT16MSWIN950, ZHT32EUC, ZHT32SOPS, ZHT32TRIS
        :param str database_id: The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param str database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the image to be used to restore a database.
        :param 'DbSystemDbHomeDatabaseDbBackupConfigArgs' db_backup_config: (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        :param str db_domain: The database domain. In a distributed database system, DB_DOMAIN specifies the logical location of the database within the network structure.
        :param str db_name: The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        :param str db_workload: **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.
               
               The database workload type.
        :param Mapping[str, Any] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param Mapping[str, Any] freeform_tags: (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str ncharacter_set: The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        :param str pdb_name: The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        :param str state: The current state of the DB system.
        :param str tde_wallet_password: The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \\#, or -.
        :param str time_created: The date and time the DB system was created.
        :param str time_stamp_for_point_in_time_recovery: The point in time of the original database from which the new database is created. If not specifed, the latest backup is used to create the database.
        :param str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        DbSystemDbHomeDatabase._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            admin_password=admin_password,
            backup_id=backup_id,
            backup_tde_password=backup_tde_password,
            character_set=character_set,
            connection_strings=connection_strings,
            database_id=database_id,
            database_software_image_id=database_software_image_id,
            db_backup_config=db_backup_config,
            db_domain=db_domain,
            db_name=db_name,
            db_unique_name=db_unique_name,
            db_workload=db_workload,
            defined_tags=defined_tags,
            freeform_tags=freeform_tags,
            id=id,
            kms_key_id=kms_key_id,
            kms_key_version_id=kms_key_version_id,
            lifecycle_details=lifecycle_details,
            ncharacter_set=ncharacter_set,
            pdb_name=pdb_name,
            state=state,
            tde_wallet_password=tde_wallet_password,
            time_created=time_created,
            time_stamp_for_point_in_time_recovery=time_stamp_for_point_in_time_recovery,
            vault_id=vault_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             admin_password: str,
             backup_id: Optional[str] = None,
             backup_tde_password: Optional[str] = None,
             character_set: Optional[str] = None,
             connection_strings: Optional[Sequence['outputs.DbSystemDbHomeDatabaseConnectionString']] = None,
             database_id: Optional[str] = None,
             database_software_image_id: Optional[str] = None,
             db_backup_config: Optional['outputs.DbSystemDbHomeDatabaseDbBackupConfig'] = None,
             db_domain: Optional[str] = None,
             db_name: Optional[str] = None,
             db_unique_name: Optional[str] = None,
             db_workload: Optional[str] = None,
             defined_tags: Optional[Mapping[str, Any]] = None,
             freeform_tags: Optional[Mapping[str, Any]] = None,
             id: Optional[str] = None,
             kms_key_id: Optional[str] = None,
             kms_key_version_id: Optional[str] = None,
             lifecycle_details: Optional[str] = None,
             ncharacter_set: Optional[str] = None,
             pdb_name: Optional[str] = None,
             state: Optional[str] = None,
             tde_wallet_password: Optional[str] = None,
             time_created: Optional[str] = None,
             time_stamp_for_point_in_time_recovery: Optional[str] = None,
             vault_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("admin_password", admin_password)
        if backup_id is not None:
            _setter("backup_id", backup_id)
        if backup_tde_password is not None:
            _setter("backup_tde_password", backup_tde_password)
        if character_set is not None:
            _setter("character_set", character_set)
        if connection_strings is not None:
            _setter("connection_strings", connection_strings)
        if database_id is not None:
            _setter("database_id", database_id)
        if database_software_image_id is not None:
            _setter("database_software_image_id", database_software_image_id)
        if db_backup_config is not None:
            _setter("db_backup_config", db_backup_config)
        if db_domain is not None:
            _setter("db_domain", db_domain)
        if db_name is not None:
            _setter("db_name", db_name)
        if db_unique_name is not None:
            _setter("db_unique_name", db_unique_name)
        if db_workload is not None:
            _setter("db_workload", db_workload)
        if defined_tags is not None:
            _setter("defined_tags", defined_tags)
        if freeform_tags is not None:
            _setter("freeform_tags", freeform_tags)
        if id is not None:
            _setter("id", id)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)
        if kms_key_version_id is not None:
            _setter("kms_key_version_id", kms_key_version_id)
        if lifecycle_details is not None:
            _setter("lifecycle_details", lifecycle_details)
        if ncharacter_set is not None:
            _setter("ncharacter_set", ncharacter_set)
        if pdb_name is not None:
            _setter("pdb_name", pdb_name)
        if state is not None:
            _setter("state", state)
        if tde_wallet_password is not None:
            _setter("tde_wallet_password", tde_wallet_password)
        if time_created is not None:
            _setter("time_created", time_created)
        if time_stamp_for_point_in_time_recovery is not None:
            _setter("time_stamp_for_point_in_time_recovery", time_stamp_for_point_in_time_recovery)
        if vault_id is not None:
            _setter("vault_id", vault_id)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> str:
        """
        A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \\#, or -.
        """
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> Optional[str]:
        """
        The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "backup_id")

    @property
    @pulumi.getter(name="backupTdePassword")
    def backup_tde_password(self) -> Optional[str]:
        """
        The password to open the TDE wallet.
        """
        return pulumi.get(self, "backup_tde_password")

    @property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> Optional[str]:
        """
        The character set for the database.  The default is AL32UTF8. Allowed values are:

        AL32UTF8, AR8ADOS710, AR8ADOS720, AR8APTEC715, AR8ARABICMACS, AR8ASMO8X, AR8ISO8859P6, AR8MSWIN1256, AR8MUSSAD768, AR8NAFITHA711, AR8NAFITHA721, AR8SAKHR706, AR8SAKHR707, AZ8ISO8859P9E, BG8MSWIN, BG8PC437S, BLT8CP921, BLT8ISO8859P13, BLT8MSWIN1257, BLT8PC775, BN8BSCII, CDN8PC863, CEL8ISO8859P14, CL8ISO8859P5, CL8ISOIR111, CL8KOI8R, CL8KOI8U, CL8MACCYRILLICS, CL8MSWIN1251, EE8ISO8859P2, EE8MACCES, EE8MACCROATIANS, EE8MSWIN1250, EE8PC852, EL8DEC, EL8ISO8859P7, EL8MACGREEKS, EL8MSWIN1253, EL8PC437S, EL8PC851, EL8PC869, ET8MSWIN923, HU8ABMOD, HU8CWI2, IN8ISCII, IS8PC861, IW8ISO8859P8, IW8MACHEBREWS, IW8MSWIN1255, IW8PC1507, JA16EUC, JA16EUCTILDE, JA16SJIS, JA16SJISTILDE, JA16VMS, KO16KSC5601, KO16KSCCS, KO16MSWIN949, LA8ISO6937, LA8PASSPORT, LT8MSWIN921, LT8PC772, LT8PC774, LV8PC1117, LV8PC8LR, LV8RST104090, N8PC865, NE8ISO8859P10, NEE8ISO8859P4, RU8BESTA, RU8PC855, RU8PC866, SE8ISO8859P3, TH8MACTHAIS, TH8TISASCII, TR8DEC, TR8MACTURKISHS, TR8MSWIN1254, TR8PC857, US7ASCII, US8PC437, UTF8, VN8MSWIN1258, VN8VN3, WE8DEC, WE8DG, WE8ISO8859P1, WE8ISO8859P15, WE8ISO8859P9, WE8MACROMAN8S, WE8MSWIN1252, WE8NCR4970, WE8NEXTSTEP, WE8PC850, WE8PC858, WE8PC860, WE8ROMAN8, ZHS16CGB231280, ZHS16GBK, ZHT16BIG5, ZHT16CCDC, ZHT16DBT, ZHT16HKSCS, ZHT16MSWIN950, ZHT32EUC, ZHT32SOPS, ZHT32TRIS
        """
        return pulumi.get(self, "character_set")

    @property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Optional[Sequence['outputs.DbSystemDbHomeDatabaseConnectionString']]:
        return pulumi.get(self, "connection_strings")

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[str]:
        """
        The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "database_id")

    @property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> Optional[str]:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the image to be used to restore a database.
        """
        return pulumi.get(self, "database_software_image_id")

    @property
    @pulumi.getter(name="dbBackupConfig")
    def db_backup_config(self) -> Optional['outputs.DbSystemDbHomeDatabaseDbBackupConfig']:
        """
        (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        """
        return pulumi.get(self, "db_backup_config")

    @property
    @pulumi.getter(name="dbDomain")
    def db_domain(self) -> Optional[str]:
        """
        The database domain. In a distributed database system, DB_DOMAIN specifies the logical location of the database within the network structure.
        """
        return pulumi.get(self, "db_domain")

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[str]:
        """
        The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        """
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> Optional[str]:
        return pulumi.get(self, "db_unique_name")

    @property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> Optional[str]:
        """
        **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.

        The database workload type.
        """
        return pulumi.get(self, "db_workload")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[Mapping[str, Any]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[Mapping[str, Any]]:
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> Optional[str]:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        """
        return pulumi.get(self, "kms_key_version_id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[str]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> Optional[str]:
        """
        The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        """
        return pulumi.get(self, "ncharacter_set")

    @property
    @pulumi.getter(name="pdbName")
    def pdb_name(self) -> Optional[str]:
        """
        The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        """
        return pulumi.get(self, "pdb_name")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        The current state of the DB system.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="tdeWalletPassword")
    def tde_wallet_password(self) -> Optional[str]:
        """
        The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \\#, or -.
        """
        return pulumi.get(self, "tde_wallet_password")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[str]:
        """
        The date and time the DB system was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeStampForPointInTimeRecovery")
    def time_stamp_for_point_in_time_recovery(self) -> Optional[str]:
        """
        The point in time of the original database from which the new database is created. If not specifed, the latest backup is used to create the database.
        """
        return pulumi.get(self, "time_stamp_for_point_in_time_recovery")

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class DbSystemDbHomeDatabaseConnectionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allConnectionStrings":
            suggest = "all_connection_strings"
        elif key == "cdbDefault":
            suggest = "cdb_default"
        elif key == "cdbIpDefault":
            suggest = "cdb_ip_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbSystemDbHomeDatabaseConnectionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbSystemDbHomeDatabaseConnectionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbSystemDbHomeDatabaseConnectionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_connection_strings: Optional[Mapping[str, Any]] = None,
                 cdb_default: Optional[str] = None,
                 cdb_ip_default: Optional[str] = None):
        DbSystemDbHomeDatabaseConnectionString._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_connection_strings=all_connection_strings,
            cdb_default=cdb_default,
            cdb_ip_default=cdb_ip_default,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_connection_strings: Optional[Mapping[str, Any]] = None,
             cdb_default: Optional[str] = None,
             cdb_ip_default: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if all_connection_strings is not None:
            _setter("all_connection_strings", all_connection_strings)
        if cdb_default is not None:
            _setter("cdb_default", cdb_default)
        if cdb_ip_default is not None:
            _setter("cdb_ip_default", cdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "all_connection_strings")

    @property
    @pulumi.getter(name="cdbDefault")
    def cdb_default(self) -> Optional[str]:
        return pulumi.get(self, "cdb_default")

    @property
    @pulumi.getter(name="cdbIpDefault")
    def cdb_ip_default(self) -> Optional[str]:
        return pulumi.get(self, "cdb_ip_default")


@pulumi.output_type
class DbSystemDbHomeDatabaseDbBackupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoBackupEnabled":
            suggest = "auto_backup_enabled"
        elif key == "autoBackupWindow":
            suggest = "auto_backup_window"
        elif key == "autoFullBackupDay":
            suggest = "auto_full_backup_day"
        elif key == "autoFullBackupWindow":
            suggest = "auto_full_backup_window"
        elif key == "backupDeletionPolicy":
            suggest = "backup_deletion_policy"
        elif key == "backupDestinationDetails":
            suggest = "backup_destination_details"
        elif key == "recoveryWindowInDays":
            suggest = "recovery_window_in_days"
        elif key == "runImmediateFullBackup":
            suggest = "run_immediate_full_backup"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbSystemDbHomeDatabaseDbBackupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbSystemDbHomeDatabaseDbBackupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbSystemDbHomeDatabaseDbBackupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_backup_enabled: Optional[bool] = None,
                 auto_backup_window: Optional[str] = None,
                 auto_full_backup_day: Optional[str] = None,
                 auto_full_backup_window: Optional[str] = None,
                 backup_deletion_policy: Optional[str] = None,
                 backup_destination_details: Optional[Sequence['outputs.DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetail']] = None,
                 recovery_window_in_days: Optional[int] = None,
                 run_immediate_full_backup: Optional[bool] = None):
        """
        :param bool auto_backup_enabled: (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param str auto_backup_window: (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param str auto_full_backup_day: Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        :param str auto_full_backup_window: Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param str backup_deletion_policy: This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        :param Sequence['DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs'] backup_destination_details: (Updatable) Backup destination details.
        :param int recovery_window_in_days: (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        :param bool run_immediate_full_backup: If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        DbSystemDbHomeDatabaseDbBackupConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_backup_enabled=auto_backup_enabled,
            auto_backup_window=auto_backup_window,
            auto_full_backup_day=auto_full_backup_day,
            auto_full_backup_window=auto_full_backup_window,
            backup_deletion_policy=backup_deletion_policy,
            backup_destination_details=backup_destination_details,
            recovery_window_in_days=recovery_window_in_days,
            run_immediate_full_backup=run_immediate_full_backup,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_backup_enabled: Optional[bool] = None,
             auto_backup_window: Optional[str] = None,
             auto_full_backup_day: Optional[str] = None,
             auto_full_backup_window: Optional[str] = None,
             backup_deletion_policy: Optional[str] = None,
             backup_destination_details: Optional[Sequence['outputs.DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetail']] = None,
             recovery_window_in_days: Optional[int] = None,
             run_immediate_full_backup: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if auto_backup_enabled is not None:
            _setter("auto_backup_enabled", auto_backup_enabled)
        if auto_backup_window is not None:
            _setter("auto_backup_window", auto_backup_window)
        if auto_full_backup_day is not None:
            _setter("auto_full_backup_day", auto_full_backup_day)
        if auto_full_backup_window is not None:
            _setter("auto_full_backup_window", auto_full_backup_window)
        if backup_deletion_policy is not None:
            _setter("backup_deletion_policy", backup_deletion_policy)
        if backup_destination_details is not None:
            _setter("backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            _setter("recovery_window_in_days", recovery_window_in_days)
        if run_immediate_full_backup is not None:
            _setter("run_immediate_full_backup", run_immediate_full_backup)

    @property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> Optional[bool]:
        """
        (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> Optional[str]:
        """
        (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> Optional[str]:
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        return pulumi.get(self, "auto_full_backup_day")

    @property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> Optional[str]:
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_full_backup_window")

    @property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> Optional[str]:
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        return pulumi.get(self, "backup_deletion_policy")

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[Sequence['outputs.DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetail']]:
        """
        (Updatable) Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[int]:
        """
        (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> Optional[bool]:
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        return pulumi.get(self, "run_immediate_full_backup")


@pulumi.output_type
class DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbrsPolicyId":
            suggest = "dbrs_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbrs_policy_id: Optional[str] = None,
                 id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param str type: Type of the database backup destination.
        """
        DbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetail._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dbrs_policy_id=dbrs_policy_id,
            id=id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dbrs_policy_id: Optional[str] = None,
             id: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dbrs_policy_id is not None:
            _setter("dbrs_policy_id", dbrs_policy_id)
        if id is not None:
            _setter("id", id)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DbSystemDbSystemOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageManagement":
            suggest = "storage_management"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbSystemDbSystemOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbSystemDbSystemOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbSystemDbSystemOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_management: Optional[str] = None):
        """
        :param str storage_management: The storage option used in DB system. ASM - Automatic storage management LVM - Logical Volume management
        """
        DbSystemDbSystemOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            storage_management=storage_management,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             storage_management: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if storage_management is not None:
            _setter("storage_management", storage_management)

    @property
    @pulumi.getter(name="storageManagement")
    def storage_management(self) -> Optional[str]:
        """
        The storage option used in DB system. ASM - Automatic storage management LVM - Logical Volume management
        """
        return pulumi.get(self, "storage_management")


@pulumi.output_type
class DbSystemIormConfigCach(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbPlans":
            suggest = "db_plans"
        elif key == "dbSystemId":
            suggest = "db_system_id"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbSystemIormConfigCach. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbSystemIormConfigCach.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbSystemIormConfigCach.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_plans: Optional[Sequence['outputs.DbSystemIormConfigCachDbPlan']] = None,
                 db_system_id: Optional[str] = None,
                 lifecycle_details: Optional[str] = None,
                 objective: Optional[str] = None,
                 state: Optional[str] = None):
        """
        :param Sequence['DbSystemIormConfigCachDbPlanArgs'] db_plans: An array of IORM settings for all the database in the Exadata DB system.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str objective: The current value for the IORM objective. The default is `AUTO`.
        :param str state: The current state of the DB system.
        """
        DbSystemIormConfigCach._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_plans=db_plans,
            db_system_id=db_system_id,
            lifecycle_details=lifecycle_details,
            objective=objective,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_plans: Optional[Sequence['outputs.DbSystemIormConfigCachDbPlan']] = None,
             db_system_id: Optional[str] = None,
             lifecycle_details: Optional[str] = None,
             objective: Optional[str] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if db_plans is not None:
            _setter("db_plans", db_plans)
        if db_system_id is not None:
            _setter("db_system_id", db_system_id)
        if lifecycle_details is not None:
            _setter("lifecycle_details", lifecycle_details)
        if objective is not None:
            _setter("objective", objective)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter(name="dbPlans")
    def db_plans(self) -> Optional[Sequence['outputs.DbSystemIormConfigCachDbPlan']]:
        """
        An array of IORM settings for all the database in the Exadata DB system.
        """
        return pulumi.get(self, "db_plans")

    @property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> Optional[str]:
        return pulumi.get(self, "db_system_id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[str]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def objective(self) -> Optional[str]:
        """
        The current value for the IORM objective. The default is `AUTO`.
        """
        return pulumi.get(self, "objective")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        The current state of the DB system.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DbSystemIormConfigCachDbPlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbName":
            suggest = "db_name"
        elif key == "flashCacheLimit":
            suggest = "flash_cache_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbSystemIormConfigCachDbPlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbSystemIormConfigCachDbPlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbSystemIormConfigCachDbPlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_name: Optional[str] = None,
                 flash_cache_limit: Optional[str] = None,
                 share: Optional[int] = None):
        """
        :param str db_name: The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        :param str flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        :param int share: The relative priority of this database.
        """
        DbSystemIormConfigCachDbPlan._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_name=db_name,
            flash_cache_limit=flash_cache_limit,
            share=share,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_name: Optional[str] = None,
             flash_cache_limit: Optional[str] = None,
             share: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if db_name is not None:
            _setter("db_name", db_name)
        if flash_cache_limit is not None:
            _setter("flash_cache_limit", flash_cache_limit)
        if share is not None:
            _setter("share", share)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[str]:
        """
        The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        """
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> Optional[str]:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")

    @property
    @pulumi.getter
    def share(self) -> Optional[int]:
        """
        The relative priority of this database.
        """
        return pulumi.get(self, "share")


@pulumi.output_type
class DbSystemMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionTimeoutInMins":
            suggest = "custom_action_timeout_in_mins"
        elif key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "isCustomActionTimeoutEnabled":
            suggest = "is_custom_action_timeout_enabled"
        elif key == "isMonthlyPatchingEnabled":
            suggest = "is_monthly_patching_enabled"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "patchingMode":
            suggest = "patching_mode"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbSystemMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbSystemMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbSystemMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[int] = None,
                 days_of_weeks: Optional[Sequence['outputs.DbSystemMaintenanceWindowDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[int]] = None,
                 is_custom_action_timeout_enabled: Optional[bool] = None,
                 is_monthly_patching_enabled: Optional[bool] = None,
                 lead_time_in_weeks: Optional[int] = None,
                 months: Optional[Sequence['outputs.DbSystemMaintenanceWindowMonth']] = None,
                 patching_mode: Optional[str] = None,
                 preference: Optional[str] = None,
                 weeks_of_months: Optional[Sequence[int]] = None):
        """
        :param int custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['DbSystemMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param bool is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param bool is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param int lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['DbSystemMaintenanceWindowMonthArgs'] months: (Updatable) Months during the year when maintenance should be performed.
        :param str patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param str preference: (Updatable) The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        DbSystemMaintenanceWindow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: Optional[int] = None,
             days_of_weeks: Optional[Sequence['outputs.DbSystemMaintenanceWindowDaysOfWeek']] = None,
             hours_of_days: Optional[Sequence[int]] = None,
             is_custom_action_timeout_enabled: Optional[bool] = None,
             is_monthly_patching_enabled: Optional[bool] = None,
             lead_time_in_weeks: Optional[int] = None,
             months: Optional[Sequence['outputs.DbSystemMaintenanceWindowMonth']] = None,
             patching_mode: Optional[str] = None,
             preference: Optional[str] = None,
             weeks_of_months: Optional[Sequence[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_action_timeout_in_mins is not None:
            _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            _setter("days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            _setter("hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            _setter("lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            _setter("months", months)
        if patching_mode is not None:
            _setter("patching_mode", patching_mode)
        if preference is not None:
            _setter("preference", preference)
        if weeks_of_months is not None:
            _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[int]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.DbSystemMaintenanceWindowDaysOfWeek']]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[int]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[bool]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[bool]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[int]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.DbSystemMaintenanceWindowMonth']]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[str]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> Optional[str]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[int]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class DbSystemMaintenanceWindowDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: (Updatable) Name of the month of the year.
        """
        DbSystemMaintenanceWindowDaysOfWeek._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DbSystemMaintenanceWindowDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionTimeoutInMins":
            suggest = "custom_action_timeout_in_mins"
        elif key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "isCustomActionTimeoutEnabled":
            suggest = "is_custom_action_timeout_enabled"
        elif key == "isMonthlyPatchingEnabled":
            suggest = "is_monthly_patching_enabled"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "patchingMode":
            suggest = "patching_mode"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbSystemMaintenanceWindowDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbSystemMaintenanceWindowDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbSystemMaintenanceWindowDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[int] = None,
                 days_of_weeks: Optional[Sequence['outputs.DbSystemMaintenanceWindowDetailsDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[int]] = None,
                 is_custom_action_timeout_enabled: Optional[bool] = None,
                 is_monthly_patching_enabled: Optional[bool] = None,
                 lead_time_in_weeks: Optional[int] = None,
                 months: Optional[Sequence['outputs.DbSystemMaintenanceWindowDetailsMonth']] = None,
                 patching_mode: Optional[str] = None,
                 preference: Optional[str] = None,
                 weeks_of_months: Optional[Sequence[int]] = None):
        """
        :param int custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['DbSystemMaintenanceWindowDetailsDaysOfWeekArgs'] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param bool is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param bool is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param int lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['DbSystemMaintenanceWindowDetailsMonthArgs'] months: (Updatable) Months during the year when maintenance should be performed.
        :param str patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param str preference: (Updatable) The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        DbSystemMaintenanceWindowDetails._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: Optional[int] = None,
             days_of_weeks: Optional[Sequence['outputs.DbSystemMaintenanceWindowDetailsDaysOfWeek']] = None,
             hours_of_days: Optional[Sequence[int]] = None,
             is_custom_action_timeout_enabled: Optional[bool] = None,
             is_monthly_patching_enabled: Optional[bool] = None,
             lead_time_in_weeks: Optional[int] = None,
             months: Optional[Sequence['outputs.DbSystemMaintenanceWindowDetailsMonth']] = None,
             patching_mode: Optional[str] = None,
             preference: Optional[str] = None,
             weeks_of_months: Optional[Sequence[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_action_timeout_in_mins is not None:
            _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            _setter("days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            _setter("hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            _setter("lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            _setter("months", months)
        if patching_mode is not None:
            _setter("patching_mode", patching_mode)
        if preference is not None:
            _setter("preference", preference)
        if weeks_of_months is not None:
            _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[int]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.DbSystemMaintenanceWindowDetailsDaysOfWeek']]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[int]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[bool]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[bool]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[int]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.DbSystemMaintenanceWindowDetailsMonth']]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[str]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> Optional[str]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[int]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class DbSystemMaintenanceWindowDetailsDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: (Updatable) Name of the month of the year.
        """
        DbSystemMaintenanceWindowDetailsDaysOfWeek._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DbSystemMaintenanceWindowDetailsMonth(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: (Updatable) Name of the month of the year.
        """
        DbSystemMaintenanceWindowDetailsMonth._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DbSystemMaintenanceWindowMonth(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: (Updatable) Name of the month of the year.
        """
        DbSystemMaintenanceWindowMonth._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DbSystemsUpgradeDbSystemOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageManagement":
            suggest = "storage_management"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbSystemsUpgradeDbSystemOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbSystemsUpgradeDbSystemOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbSystemsUpgradeDbSystemOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_management: Optional[str] = None):
        """
        :param str storage_management: The storage option used in DB system. ASM - Automatic storage management LVM - Logical Volume management
        """
        DbSystemsUpgradeDbSystemOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            storage_management=storage_management,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             storage_management: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if storage_management is not None:
            _setter("storage_management", storage_management)

    @property
    @pulumi.getter(name="storageManagement")
    def storage_management(self) -> Optional[str]:
        """
        The storage option used in DB system. ASM - Automatic storage management LVM - Logical Volume management
        """
        return pulumi.get(self, "storage_management")


@pulumi.output_type
class DbSystemsUpgradeIormConfigCach(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbPlans":
            suggest = "db_plans"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbSystemsUpgradeIormConfigCach. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbSystemsUpgradeIormConfigCach.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbSystemsUpgradeIormConfigCach.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_plans: Optional[Sequence['outputs.DbSystemsUpgradeIormConfigCachDbPlan']] = None,
                 lifecycle_details: Optional[str] = None,
                 objective: Optional[str] = None,
                 state: Optional[str] = None):
        """
        :param Sequence['DbSystemsUpgradeIormConfigCachDbPlanArgs'] db_plans: An array of IORM settings for all the database in the Exadata DB system.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str objective: The current value for the IORM objective. The default is `AUTO`.
        :param str state: The current state of the DB system.
        """
        DbSystemsUpgradeIormConfigCach._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_plans=db_plans,
            lifecycle_details=lifecycle_details,
            objective=objective,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_plans: Optional[Sequence['outputs.DbSystemsUpgradeIormConfigCachDbPlan']] = None,
             lifecycle_details: Optional[str] = None,
             objective: Optional[str] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if db_plans is not None:
            _setter("db_plans", db_plans)
        if lifecycle_details is not None:
            _setter("lifecycle_details", lifecycle_details)
        if objective is not None:
            _setter("objective", objective)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter(name="dbPlans")
    def db_plans(self) -> Optional[Sequence['outputs.DbSystemsUpgradeIormConfigCachDbPlan']]:
        """
        An array of IORM settings for all the database in the Exadata DB system.
        """
        return pulumi.get(self, "db_plans")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[str]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def objective(self) -> Optional[str]:
        """
        The current value for the IORM objective. The default is `AUTO`.
        """
        return pulumi.get(self, "objective")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        The current state of the DB system.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DbSystemsUpgradeIormConfigCachDbPlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbName":
            suggest = "db_name"
        elif key == "flashCacheLimit":
            suggest = "flash_cache_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbSystemsUpgradeIormConfigCachDbPlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbSystemsUpgradeIormConfigCachDbPlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbSystemsUpgradeIormConfigCachDbPlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_name: Optional[str] = None,
                 flash_cache_limit: Optional[str] = None,
                 share: Optional[int] = None):
        """
        :param str db_name: The database name. For the default `DbPlan`, the `dbName` is `default`.
        :param str flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        :param int share: The relative priority of this database.
        """
        DbSystemsUpgradeIormConfigCachDbPlan._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_name=db_name,
            flash_cache_limit=flash_cache_limit,
            share=share,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_name: Optional[str] = None,
             flash_cache_limit: Optional[str] = None,
             share: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if db_name is not None:
            _setter("db_name", db_name)
        if flash_cache_limit is not None:
            _setter("flash_cache_limit", flash_cache_limit)
        if share is not None:
            _setter("share", share)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[str]:
        """
        The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> Optional[str]:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")

    @property
    @pulumi.getter
    def share(self) -> Optional[int]:
        """
        The relative priority of this database.
        """
        return pulumi.get(self, "share")


@pulumi.output_type
class DbSystemsUpgradeMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbSystemsUpgradeMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbSystemsUpgradeMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbSystemsUpgradeMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_of_weeks: Optional[Sequence['outputs.DbSystemsUpgradeMaintenanceWindowDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[int]] = None,
                 lead_time_in_weeks: Optional[int] = None,
                 months: Optional[Sequence['outputs.DbSystemsUpgradeMaintenanceWindowMonth']] = None,
                 preference: Optional[str] = None,
                 weeks_of_months: Optional[Sequence[int]] = None):
        """
        :param Sequence['DbSystemsUpgradeMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['DbSystemsUpgradeMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param str preference: The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        DbSystemsUpgradeMaintenanceWindow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             days_of_weeks: Optional[Sequence['outputs.DbSystemsUpgradeMaintenanceWindowDaysOfWeek']] = None,
             hours_of_days: Optional[Sequence[int]] = None,
             lead_time_in_weeks: Optional[int] = None,
             months: Optional[Sequence['outputs.DbSystemsUpgradeMaintenanceWindowMonth']] = None,
             preference: Optional[str] = None,
             weeks_of_months: Optional[Sequence[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if days_of_weeks is not None:
            _setter("days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            _setter("hours_of_days", hours_of_days)
        if lead_time_in_weeks is not None:
            _setter("lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            _setter("months", months)
        if preference is not None:
            _setter("preference", preference)
        if weeks_of_months is not None:
            _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.DbSystemsUpgradeMaintenanceWindowDaysOfWeek']]:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[int]]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[int]:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.DbSystemsUpgradeMaintenanceWindowMonth']]:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter
    def preference(self) -> Optional[str]:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[int]]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class DbSystemsUpgradeMaintenanceWindowDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Name of the month of the year.
        """
        DbSystemsUpgradeMaintenanceWindowDaysOfWeek._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DbSystemsUpgradeMaintenanceWindowMonth(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Name of the month of the year.
        """
        DbSystemsUpgradeMaintenanceWindowMonth._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ExadataInfrastructureComputeContact(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isContactMosValidated":
            suggest = "is_contact_mos_validated"
        elif key == "isPrimary":
            suggest = "is_primary"
        elif key == "phoneNumber":
            suggest = "phone_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExadataInfrastructureComputeContact. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExadataInfrastructureComputeContact.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExadataInfrastructureComputeContact.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: Optional[str] = None,
                 is_contact_mos_validated: Optional[bool] = None,
                 is_primary: Optional[bool] = None,
                 name: Optional[str] = None,
                 phone_number: Optional[str] = None):
        """
        :param str email: The email for the Exadata Infrastructure contact.
        :param bool is_contact_mos_validated: If `true`, this Exadata Infrastructure contact is a valid My Oracle Support (MOS) contact. If `false`, this Exadata Infrastructure contact is not a valid MOS contact.
        :param bool is_primary: If `true`, this Exadata Infrastructure contact is a primary contact. If `false`, this Exadata Infrastructure is a secondary contact.
        :param str name: Name of the month of the year.
        :param str phone_number: The phone number for the Exadata Infrastructure contact.
        """
        ExadataInfrastructureComputeContact._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            email=email,
            is_contact_mos_validated=is_contact_mos_validated,
            is_primary=is_primary,
            name=name,
            phone_number=phone_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             email: Optional[str] = None,
             is_contact_mos_validated: Optional[bool] = None,
             is_primary: Optional[bool] = None,
             name: Optional[str] = None,
             phone_number: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if email is not None:
            _setter("email", email)
        if is_contact_mos_validated is not None:
            _setter("is_contact_mos_validated", is_contact_mos_validated)
        if is_primary is not None:
            _setter("is_primary", is_primary)
        if name is not None:
            _setter("name", name)
        if phone_number is not None:
            _setter("phone_number", phone_number)

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        The email for the Exadata Infrastructure contact.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="isContactMosValidated")
    def is_contact_mos_validated(self) -> Optional[bool]:
        """
        If `true`, this Exadata Infrastructure contact is a valid My Oracle Support (MOS) contact. If `false`, this Exadata Infrastructure contact is not a valid MOS contact.
        """
        return pulumi.get(self, "is_contact_mos_validated")

    @property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> Optional[bool]:
        """
        If `true`, this Exadata Infrastructure contact is a primary contact. If `false`, this Exadata Infrastructure is a secondary contact.
        """
        return pulumi.get(self, "is_primary")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[str]:
        """
        The phone number for the Exadata Infrastructure contact.
        """
        return pulumi.get(self, "phone_number")


@pulumi.output_type
class ExadataInfrastructureComputeMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionTimeoutInMins":
            suggest = "custom_action_timeout_in_mins"
        elif key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "isCustomActionTimeoutEnabled":
            suggest = "is_custom_action_timeout_enabled"
        elif key == "isMonthlyPatchingEnabled":
            suggest = "is_monthly_patching_enabled"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "patchingMode":
            suggest = "patching_mode"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExadataInfrastructureComputeMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExadataInfrastructureComputeMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExadataInfrastructureComputeMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[int] = None,
                 days_of_weeks: Optional[Sequence['outputs.ExadataInfrastructureComputeMaintenanceWindowDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[int]] = None,
                 is_custom_action_timeout_enabled: Optional[bool] = None,
                 is_monthly_patching_enabled: Optional[bool] = None,
                 lead_time_in_weeks: Optional[int] = None,
                 months: Optional[Sequence['outputs.ExadataInfrastructureComputeMaintenanceWindowMonth']] = None,
                 patching_mode: Optional[str] = None,
                 preference: Optional[str] = None,
                 weeks_of_months: Optional[Sequence[int]] = None):
        """
        :param int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['ExadataInfrastructureComputeMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['ExadataInfrastructureComputeMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param str preference: The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        ExadataInfrastructureComputeMaintenanceWindow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: Optional[int] = None,
             days_of_weeks: Optional[Sequence['outputs.ExadataInfrastructureComputeMaintenanceWindowDaysOfWeek']] = None,
             hours_of_days: Optional[Sequence[int]] = None,
             is_custom_action_timeout_enabled: Optional[bool] = None,
             is_monthly_patching_enabled: Optional[bool] = None,
             lead_time_in_weeks: Optional[int] = None,
             months: Optional[Sequence['outputs.ExadataInfrastructureComputeMaintenanceWindowMonth']] = None,
             patching_mode: Optional[str] = None,
             preference: Optional[str] = None,
             weeks_of_months: Optional[Sequence[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_action_timeout_in_mins is not None:
            _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            _setter("days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            _setter("hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            _setter("lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            _setter("months", months)
        if patching_mode is not None:
            _setter("patching_mode", patching_mode)
        if preference is not None:
            _setter("preference", preference)
        if weeks_of_months is not None:
            _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[int]:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.ExadataInfrastructureComputeMaintenanceWindowDaysOfWeek']]:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[int]]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[bool]:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[bool]:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[int]:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.ExadataInfrastructureComputeMaintenanceWindowMonth']]:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[str]:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> Optional[str]:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[int]]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class ExadataInfrastructureComputeMaintenanceWindowDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Name of the month of the year.
        """
        ExadataInfrastructureComputeMaintenanceWindowDaysOfWeek._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ExadataInfrastructureComputeMaintenanceWindowMonth(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Name of the month of the year.
        """
        ExadataInfrastructureComputeMaintenanceWindowMonth._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ExadataInfrastructureContact(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isPrimary":
            suggest = "is_primary"
        elif key == "isContactMosValidated":
            suggest = "is_contact_mos_validated"
        elif key == "phoneNumber":
            suggest = "phone_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExadataInfrastructureContact. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExadataInfrastructureContact.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExadataInfrastructureContact.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: str,
                 is_primary: bool,
                 name: str,
                 is_contact_mos_validated: Optional[bool] = None,
                 phone_number: Optional[str] = None):
        """
        :param str email: (Updatable) The email for the Exadata Infrastructure contact.
        :param bool is_primary: (Updatable) If `true`, this Exadata Infrastructure contact is a primary contact. If `false`, this Exadata Infrastructure is a secondary contact.
        :param str name: (Updatable) Name of the month of the year.
        :param bool is_contact_mos_validated: (Updatable) If `true`, this Exadata Infrastructure contact is a valid My Oracle Support (MOS) contact. If `false`, this Exadata Infrastructure contact is not a valid MOS contact.
        :param str phone_number: (Updatable) The phone number for the Exadata Infrastructure contact.
        """
        ExadataInfrastructureContact._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            email=email,
            is_primary=is_primary,
            name=name,
            is_contact_mos_validated=is_contact_mos_validated,
            phone_number=phone_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             email: str,
             is_primary: bool,
             name: str,
             is_contact_mos_validated: Optional[bool] = None,
             phone_number: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("email", email)
        _setter("is_primary", is_primary)
        _setter("name", name)
        if is_contact_mos_validated is not None:
            _setter("is_contact_mos_validated", is_contact_mos_validated)
        if phone_number is not None:
            _setter("phone_number", phone_number)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        (Updatable) The email for the Exadata Infrastructure contact.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> bool:
        """
        (Updatable) If `true`, this Exadata Infrastructure contact is a primary contact. If `false`, this Exadata Infrastructure is a secondary contact.
        """
        return pulumi.get(self, "is_primary")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="isContactMosValidated")
    def is_contact_mos_validated(self) -> Optional[bool]:
        """
        (Updatable) If `true`, this Exadata Infrastructure contact is a valid My Oracle Support (MOS) contact. If `false`, this Exadata Infrastructure contact is not a valid MOS contact.
        """
        return pulumi.get(self, "is_contact_mos_validated")

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[str]:
        """
        (Updatable) The phone number for the Exadata Infrastructure contact.
        """
        return pulumi.get(self, "phone_number")


@pulumi.output_type
class ExadataInfrastructureMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActionTimeoutInMins":
            suggest = "custom_action_timeout_in_mins"
        elif key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "isCustomActionTimeoutEnabled":
            suggest = "is_custom_action_timeout_enabled"
        elif key == "isMonthlyPatchingEnabled":
            suggest = "is_monthly_patching_enabled"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "patchingMode":
            suggest = "patching_mode"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExadataInfrastructureMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExadataInfrastructureMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExadataInfrastructureMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_action_timeout_in_mins: Optional[int] = None,
                 days_of_weeks: Optional[Sequence['outputs.ExadataInfrastructureMaintenanceWindowDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[int]] = None,
                 is_custom_action_timeout_enabled: Optional[bool] = None,
                 is_monthly_patching_enabled: Optional[bool] = None,
                 lead_time_in_weeks: Optional[int] = None,
                 months: Optional[Sequence['outputs.ExadataInfrastructureMaintenanceWindowMonth']] = None,
                 patching_mode: Optional[str] = None,
                 preference: Optional[str] = None,
                 weeks_of_months: Optional[Sequence[int]] = None):
        """
        :param int custom_action_timeout_in_mins: (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['ExadataInfrastructureMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param bool is_custom_action_timeout_enabled: (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param bool is_monthly_patching_enabled: (Updatable) If true, enables the monthly patching option.
        :param int lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['ExadataInfrastructureMaintenanceWindowMonthArgs'] months: (Updatable) Months during the year when maintenance should be performed.
        :param str patching_mode: (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
               
               *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        :param str preference: (Updatable) The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        ExadataInfrastructureMaintenanceWindow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: Optional[int] = None,
             days_of_weeks: Optional[Sequence['outputs.ExadataInfrastructureMaintenanceWindowDaysOfWeek']] = None,
             hours_of_days: Optional[Sequence[int]] = None,
             is_custom_action_timeout_enabled: Optional[bool] = None,
             is_monthly_patching_enabled: Optional[bool] = None,
             lead_time_in_weeks: Optional[int] = None,
             months: Optional[Sequence['outputs.ExadataInfrastructureMaintenanceWindowMonth']] = None,
             patching_mode: Optional[str] = None,
             preference: Optional[str] = None,
             weeks_of_months: Optional[Sequence[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_action_timeout_in_mins is not None:
            _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        if days_of_weeks is not None:
            _setter("days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            _setter("hours_of_days", hours_of_days)
        if is_custom_action_timeout_enabled is not None:
            _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        if is_monthly_patching_enabled is not None:
            _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        if lead_time_in_weeks is not None:
            _setter("lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            _setter("months", months)
        if patching_mode is not None:
            _setter("patching_mode", patching_mode)
        if preference is not None:
            _setter("preference", preference)
        if weeks_of_months is not None:
            _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> Optional[int]:
        """
        (Updatable) Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.ExadataInfrastructureMaintenanceWindowDaysOfWeek']]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[int]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> Optional[bool]:
        """
        (Updatable) If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> Optional[bool]:
        """
        (Updatable) If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[int]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.ExadataInfrastructureMaintenanceWindowMonth']]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[str]:
        """
        (Updatable) Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.

        *IMPORTANT*: Non-rolling infrastructure patching involves system down time. See [Oracle-Managed Infrastructure Maintenance Updates](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/examaintenance.htm#Oracle) for more information.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> Optional[str]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[int]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class ExadataInfrastructureMaintenanceWindowDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: (Updatable) Name of the month of the year.
        """
        ExadataInfrastructureMaintenanceWindowDaysOfWeek._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ExadataInfrastructureMaintenanceWindowMonth(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: (Updatable) Name of the month of the year.
        """
        ExadataInfrastructureMaintenanceWindowMonth._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ExadataInfrastructureNetworkBondingModeDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupNetworkBondingMode":
            suggest = "backup_network_bonding_mode"
        elif key == "clientNetworkBondingMode":
            suggest = "client_network_bonding_mode"
        elif key == "drNetworkBondingMode":
            suggest = "dr_network_bonding_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExadataInfrastructureNetworkBondingModeDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExadataInfrastructureNetworkBondingModeDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExadataInfrastructureNetworkBondingModeDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_network_bonding_mode: Optional[str] = None,
                 client_network_bonding_mode: Optional[str] = None,
                 dr_network_bonding_mode: Optional[str] = None):
        """
        :param str backup_network_bonding_mode: (Updatable) The network bonding mode for the Exadata infrastructure.
        :param str client_network_bonding_mode: (Updatable) The network bonding mode for the Exadata infrastructure.
        :param str dr_network_bonding_mode: (Updatable) The network bonding mode for the Exadata infrastructure.
        """
        ExadataInfrastructureNetworkBondingModeDetails._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backup_network_bonding_mode=backup_network_bonding_mode,
            client_network_bonding_mode=client_network_bonding_mode,
            dr_network_bonding_mode=dr_network_bonding_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backup_network_bonding_mode: Optional[str] = None,
             client_network_bonding_mode: Optional[str] = None,
             dr_network_bonding_mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if backup_network_bonding_mode is not None:
            _setter("backup_network_bonding_mode", backup_network_bonding_mode)
        if client_network_bonding_mode is not None:
            _setter("client_network_bonding_mode", client_network_bonding_mode)
        if dr_network_bonding_mode is not None:
            _setter("dr_network_bonding_mode", dr_network_bonding_mode)

    @property
    @pulumi.getter(name="backupNetworkBondingMode")
    def backup_network_bonding_mode(self) -> Optional[str]:
        """
        (Updatable) The network bonding mode for the Exadata infrastructure.
        """
        return pulumi.get(self, "backup_network_bonding_mode")

    @property
    @pulumi.getter(name="clientNetworkBondingMode")
    def client_network_bonding_mode(self) -> Optional[str]:
        """
        (Updatable) The network bonding mode for the Exadata infrastructure.
        """
        return pulumi.get(self, "client_network_bonding_mode")

    @property
    @pulumi.getter(name="drNetworkBondingMode")
    def dr_network_bonding_mode(self) -> Optional[str]:
        """
        (Updatable) The network bonding mode for the Exadata infrastructure.
        """
        return pulumi.get(self, "dr_network_bonding_mode")


@pulumi.output_type
class ExadataInfrastructureStorageContact(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isPrimary":
            suggest = "is_primary"
        elif key == "isContactMosValidated":
            suggest = "is_contact_mos_validated"
        elif key == "phoneNumber":
            suggest = "phone_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExadataInfrastructureStorageContact. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExadataInfrastructureStorageContact.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExadataInfrastructureStorageContact.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: str,
                 is_primary: bool,
                 name: str,
                 is_contact_mos_validated: Optional[bool] = None,
                 phone_number: Optional[str] = None):
        ExadataInfrastructureStorageContact._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            email=email,
            is_primary=is_primary,
            name=name,
            is_contact_mos_validated=is_contact_mos_validated,
            phone_number=phone_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             email: str,
             is_primary: bool,
             name: str,
             is_contact_mos_validated: Optional[bool] = None,
             phone_number: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("email", email)
        _setter("is_primary", is_primary)
        _setter("name", name)
        if is_contact_mos_validated is not None:
            _setter("is_contact_mos_validated", is_contact_mos_validated)
        if phone_number is not None:
            _setter("phone_number", phone_number)

    @property
    @pulumi.getter
    def email(self) -> str:
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> bool:
        return pulumi.get(self, "is_primary")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="isContactMosValidated")
    def is_contact_mos_validated(self) -> Optional[bool]:
        return pulumi.get(self, "is_contact_mos_validated")

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[str]:
        return pulumi.get(self, "phone_number")


@pulumi.output_type
class ExadataInfrastructureStorageMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "hoursOfDays":
            suggest = "hours_of_days"
        elif key == "leadTimeInWeeks":
            suggest = "lead_time_in_weeks"
        elif key == "weeksOfMonths":
            suggest = "weeks_of_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExadataInfrastructureStorageMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExadataInfrastructureStorageMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExadataInfrastructureStorageMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 preference: str,
                 days_of_weeks: Optional[Sequence['outputs.ExadataInfrastructureStorageMaintenanceWindowDaysOfWeek']] = None,
                 hours_of_days: Optional[Sequence[int]] = None,
                 lead_time_in_weeks: Optional[int] = None,
                 months: Optional[Sequence['outputs.ExadataInfrastructureStorageMaintenanceWindowMonth']] = None,
                 weeks_of_months: Optional[Sequence[int]] = None):
        ExadataInfrastructureStorageMaintenanceWindow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            preference=preference,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             preference: str,
             days_of_weeks: Optional[Sequence['outputs.ExadataInfrastructureStorageMaintenanceWindowDaysOfWeek']] = None,
             hours_of_days: Optional[Sequence[int]] = None,
             lead_time_in_weeks: Optional[int] = None,
             months: Optional[Sequence['outputs.ExadataInfrastructureStorageMaintenanceWindowMonth']] = None,
             weeks_of_months: Optional[Sequence[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("preference", preference)
        if days_of_weeks is not None:
            _setter("days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            _setter("hours_of_days", hours_of_days)
        if lead_time_in_weeks is not None:
            _setter("lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            _setter("months", months)
        if weeks_of_months is not None:
            _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter
    def preference(self) -> str:
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence['outputs.ExadataInfrastructureStorageMaintenanceWindowDaysOfWeek']]:
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[Sequence[int]]:
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[int]:
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Optional[Sequence['outputs.ExadataInfrastructureStorageMaintenanceWindowMonth']]:
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[Sequence[int]]:
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class ExadataInfrastructureStorageMaintenanceWindowDaysOfWeek(dict):
    def __init__(__self__, *,
                 name: str):
        ExadataInfrastructureStorageMaintenanceWindowDaysOfWeek._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class ExadataInfrastructureStorageMaintenanceWindowMonth(dict):
    def __init__(__self__, *,
                 name: str):
        ExadataInfrastructureStorageMaintenanceWindowMonth._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class ExadataIormConfigDbPlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbName":
            suggest = "db_name"
        elif key == "flashCacheLimit":
            suggest = "flash_cache_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExadataIormConfigDbPlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExadataIormConfigDbPlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExadataIormConfigDbPlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_name: str,
                 share: int,
                 flash_cache_limit: Optional[str] = None):
        """
        :param str db_name: (Updatable) The database name. For the default `DbPlan`, the `dbName` is `default`.
        :param int share: (Updatable) The relative priority of this database.
        :param str flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        ExadataIormConfigDbPlan._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_name=db_name,
            share=share,
            flash_cache_limit=flash_cache_limit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_name: str,
             share: int,
             flash_cache_limit: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("db_name", db_name)
        _setter("share", share)
        if flash_cache_limit is not None:
            _setter("flash_cache_limit", flash_cache_limit)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> str:
        """
        (Updatable) The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter
    def share(self) -> int:
        """
        (Updatable) The relative priority of this database.
        """
        return pulumi.get(self, "share")

    @property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> Optional[str]:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")


@pulumi.output_type
class ExternalContainerDatabaseDatabaseManagementConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseManagementConnectionId":
            suggest = "database_management_connection_id"
        elif key == "databaseManagementStatus":
            suggest = "database_management_status"
        elif key == "licenseModel":
            suggest = "license_model"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalContainerDatabaseDatabaseManagementConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalContainerDatabaseDatabaseManagementConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalContainerDatabaseDatabaseManagementConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_management_connection_id: Optional[str] = None,
                 database_management_status: Optional[str] = None,
                 license_model: Optional[str] = None):
        """
        :param str database_management_connection_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param str database_management_status: The status of the Database Management service.
        :param str license_model: The Oracle license model that applies to the external database.
        """
        ExternalContainerDatabaseDatabaseManagementConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_management_connection_id=database_management_connection_id,
            database_management_status=database_management_status,
            license_model=license_model,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_management_connection_id: Optional[str] = None,
             database_management_status: Optional[str] = None,
             license_model: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if database_management_connection_id is not None:
            _setter("database_management_connection_id", database_management_connection_id)
        if database_management_status is not None:
            _setter("database_management_status", database_management_status)
        if license_model is not None:
            _setter("license_model", license_model)

    @property
    @pulumi.getter(name="databaseManagementConnectionId")
    def database_management_connection_id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "database_management_connection_id")

    @property
    @pulumi.getter(name="databaseManagementStatus")
    def database_management_status(self) -> Optional[str]:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "database_management_status")

    @property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> Optional[str]:
        """
        The Oracle license model that applies to the external database.
        """
        return pulumi.get(self, "license_model")


@pulumi.output_type
class ExternalContainerDatabaseStackMonitoringConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stackMonitoringConnectorId":
            suggest = "stack_monitoring_connector_id"
        elif key == "stackMonitoringStatus":
            suggest = "stack_monitoring_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalContainerDatabaseStackMonitoringConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalContainerDatabaseStackMonitoringConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalContainerDatabaseStackMonitoringConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 stack_monitoring_connector_id: Optional[str] = None,
                 stack_monitoring_status: Optional[str] = None):
        """
        :param str stack_monitoring_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param str stack_monitoring_status: The status of Stack Monitoring.
        """
        ExternalContainerDatabaseStackMonitoringConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            stack_monitoring_connector_id=stack_monitoring_connector_id,
            stack_monitoring_status=stack_monitoring_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             stack_monitoring_connector_id: Optional[str] = None,
             stack_monitoring_status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if stack_monitoring_connector_id is not None:
            _setter("stack_monitoring_connector_id", stack_monitoring_connector_id)
        if stack_monitoring_status is not None:
            _setter("stack_monitoring_status", stack_monitoring_status)

    @property
    @pulumi.getter(name="stackMonitoringConnectorId")
    def stack_monitoring_connector_id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "stack_monitoring_connector_id")

    @property
    @pulumi.getter(name="stackMonitoringStatus")
    def stack_monitoring_status(self) -> Optional[str]:
        """
        The status of Stack Monitoring.
        """
        return pulumi.get(self, "stack_monitoring_status")


@pulumi.output_type
class ExternalDatabaseConnectorConnectionCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialName":
            suggest = "credential_name"
        elif key == "credentialType":
            suggest = "credential_type"
        elif key == "sslSecretId":
            suggest = "ssl_secret_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalDatabaseConnectorConnectionCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalDatabaseConnectorConnectionCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalDatabaseConnectorConnectionCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credential_name: Optional[str] = None,
                 credential_type: Optional[str] = None,
                 password: Optional[str] = None,
                 role: Optional[str] = None,
                 ssl_secret_id: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str credential_name: (Updatable) The name of the credential information that used to connect to the database. The name should be in "x.y" format, where the length of "x" has a maximum of 64 characters, and length of "y" has a maximum of 199 characters. The name strings can contain letters, numbers and the underscore character only. Other characters are not valid, except for the "." character that separates the "x" and "y" portions of the name. *IMPORTANT* - The name must be unique within the Oracle Cloud Infrastructure region the credential is being created in. If you specify a name that duplicates the name of another credential within the same Oracle Cloud Infrastructure region, you may overwrite or corrupt the credential that is already using the name.
               
               For example: inventorydb.abc112233445566778899
        :param str credential_type: (Updatable) The type of credential used to connect to the database.
        :param str password: (Updatable) The password that will be used to connect to the database.
        :param str role: (Updatable) The role of the user that will be connecting to the database.
        :param str ssl_secret_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        :param str username: (Updatable) The username that will be used to connect to the database.
        """
        ExternalDatabaseConnectorConnectionCredentials._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credential_name=credential_name,
            credential_type=credential_type,
            password=password,
            role=role,
            ssl_secret_id=ssl_secret_id,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credential_name: Optional[str] = None,
             credential_type: Optional[str] = None,
             password: Optional[str] = None,
             role: Optional[str] = None,
             ssl_secret_id: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if credential_name is not None:
            _setter("credential_name", credential_name)
        if credential_type is not None:
            _setter("credential_type", credential_type)
        if password is not None:
            _setter("password", password)
        if role is not None:
            _setter("role", role)
        if ssl_secret_id is not None:
            _setter("ssl_secret_id", ssl_secret_id)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter(name="credentialName")
    def credential_name(self) -> Optional[str]:
        """
        (Updatable) The name of the credential information that used to connect to the database. The name should be in "x.y" format, where the length of "x" has a maximum of 64 characters, and length of "y" has a maximum of 199 characters. The name strings can contain letters, numbers and the underscore character only. Other characters are not valid, except for the "." character that separates the "x" and "y" portions of the name. *IMPORTANT* - The name must be unique within the Oracle Cloud Infrastructure region the credential is being created in. If you specify a name that duplicates the name of another credential within the same Oracle Cloud Infrastructure region, you may overwrite or corrupt the credential that is already using the name.

        For example: inventorydb.abc112233445566778899
        """
        return pulumi.get(self, "credential_name")

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> Optional[str]:
        """
        (Updatable) The type of credential used to connect to the database.
        """
        return pulumi.get(self, "credential_type")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        (Updatable) The password that will be used to connect to the database.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        (Updatable) The role of the user that will be connecting to the database.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter(name="sslSecretId")
    def ssl_secret_id(self) -> Optional[str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "ssl_secret_id")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        (Updatable) The username that will be used to connect to the database.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ExternalDatabaseConnectorConnectionString(dict):
    def __init__(__self__, *,
                 hostname: str,
                 port: int,
                 protocol: str,
                 service: str):
        """
        :param str hostname: (Updatable) The host name of the database.
        :param int port: (Updatable) The port used to connect to the database.
        :param str protocol: (Updatable) The protocol used to connect to the database.
        :param str service: (Updatable) The name of the service alias used to connect to the database.
        """
        ExternalDatabaseConnectorConnectionString._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hostname=hostname,
            port=port,
            protocol=protocol,
            service=service,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hostname: str,
             port: int,
             protocol: str,
             service: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("hostname", hostname)
        _setter("port", port)
        _setter("protocol", protocol)
        _setter("service", service)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        (Updatable) The host name of the database.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        (Updatable) The port used to connect to the database.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        (Updatable) The protocol used to connect to the database.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        (Updatable) The name of the service alias used to connect to the database.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class ExternalNonContainerDatabaseDatabaseManagementConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseManagementConnectionId":
            suggest = "database_management_connection_id"
        elif key == "databaseManagementStatus":
            suggest = "database_management_status"
        elif key == "licenseModel":
            suggest = "license_model"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalNonContainerDatabaseDatabaseManagementConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalNonContainerDatabaseDatabaseManagementConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalNonContainerDatabaseDatabaseManagementConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_management_connection_id: Optional[str] = None,
                 database_management_status: Optional[str] = None,
                 license_model: Optional[str] = None):
        """
        :param str database_management_connection_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param str database_management_status: The status of the Database Management service.
        :param str license_model: The Oracle license model that applies to the external database.
        """
        ExternalNonContainerDatabaseDatabaseManagementConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_management_connection_id=database_management_connection_id,
            database_management_status=database_management_status,
            license_model=license_model,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_management_connection_id: Optional[str] = None,
             database_management_status: Optional[str] = None,
             license_model: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if database_management_connection_id is not None:
            _setter("database_management_connection_id", database_management_connection_id)
        if database_management_status is not None:
            _setter("database_management_status", database_management_status)
        if license_model is not None:
            _setter("license_model", license_model)

    @property
    @pulumi.getter(name="databaseManagementConnectionId")
    def database_management_connection_id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "database_management_connection_id")

    @property
    @pulumi.getter(name="databaseManagementStatus")
    def database_management_status(self) -> Optional[str]:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "database_management_status")

    @property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> Optional[str]:
        """
        The Oracle license model that applies to the external database.
        """
        return pulumi.get(self, "license_model")


@pulumi.output_type
class ExternalNonContainerDatabaseOperationsInsightsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operationsInsightsConnectorId":
            suggest = "operations_insights_connector_id"
        elif key == "operationsInsightsStatus":
            suggest = "operations_insights_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalNonContainerDatabaseOperationsInsightsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalNonContainerDatabaseOperationsInsightsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalNonContainerDatabaseOperationsInsightsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operations_insights_connector_id: Optional[str] = None,
                 operations_insights_status: Optional[str] = None):
        """
        :param str operations_insights_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param str operations_insights_status: The status of Operations Insights
        """
        ExternalNonContainerDatabaseOperationsInsightsConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operations_insights_connector_id=operations_insights_connector_id,
            operations_insights_status=operations_insights_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operations_insights_connector_id: Optional[str] = None,
             operations_insights_status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if operations_insights_connector_id is not None:
            _setter("operations_insights_connector_id", operations_insights_connector_id)
        if operations_insights_status is not None:
            _setter("operations_insights_status", operations_insights_status)

    @property
    @pulumi.getter(name="operationsInsightsConnectorId")
    def operations_insights_connector_id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "operations_insights_connector_id")

    @property
    @pulumi.getter(name="operationsInsightsStatus")
    def operations_insights_status(self) -> Optional[str]:
        """
        The status of Operations Insights
        """
        return pulumi.get(self, "operations_insights_status")


@pulumi.output_type
class ExternalNonContainerDatabaseStackMonitoringConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stackMonitoringConnectorId":
            suggest = "stack_monitoring_connector_id"
        elif key == "stackMonitoringStatus":
            suggest = "stack_monitoring_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalNonContainerDatabaseStackMonitoringConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalNonContainerDatabaseStackMonitoringConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalNonContainerDatabaseStackMonitoringConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 stack_monitoring_connector_id: Optional[str] = None,
                 stack_monitoring_status: Optional[str] = None):
        """
        :param str stack_monitoring_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param str stack_monitoring_status: The status of Stack Monitoring.
        """
        ExternalNonContainerDatabaseStackMonitoringConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            stack_monitoring_connector_id=stack_monitoring_connector_id,
            stack_monitoring_status=stack_monitoring_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             stack_monitoring_connector_id: Optional[str] = None,
             stack_monitoring_status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if stack_monitoring_connector_id is not None:
            _setter("stack_monitoring_connector_id", stack_monitoring_connector_id)
        if stack_monitoring_status is not None:
            _setter("stack_monitoring_status", stack_monitoring_status)

    @property
    @pulumi.getter(name="stackMonitoringConnectorId")
    def stack_monitoring_connector_id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "stack_monitoring_connector_id")

    @property
    @pulumi.getter(name="stackMonitoringStatus")
    def stack_monitoring_status(self) -> Optional[str]:
        """
        The status of Stack Monitoring.
        """
        return pulumi.get(self, "stack_monitoring_status")


@pulumi.output_type
class ExternalPluggableDatabaseDatabaseManagementConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseManagementConnectionId":
            suggest = "database_management_connection_id"
        elif key == "databaseManagementStatus":
            suggest = "database_management_status"
        elif key == "licenseModel":
            suggest = "license_model"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalPluggableDatabaseDatabaseManagementConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalPluggableDatabaseDatabaseManagementConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalPluggableDatabaseDatabaseManagementConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_management_connection_id: Optional[str] = None,
                 database_management_status: Optional[str] = None,
                 license_model: Optional[str] = None):
        """
        :param str database_management_connection_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param str database_management_status: The status of the Database Management service.
        :param str license_model: The Oracle license model that applies to the external database.
        """
        ExternalPluggableDatabaseDatabaseManagementConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_management_connection_id=database_management_connection_id,
            database_management_status=database_management_status,
            license_model=license_model,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_management_connection_id: Optional[str] = None,
             database_management_status: Optional[str] = None,
             license_model: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if database_management_connection_id is not None:
            _setter("database_management_connection_id", database_management_connection_id)
        if database_management_status is not None:
            _setter("database_management_status", database_management_status)
        if license_model is not None:
            _setter("license_model", license_model)

    @property
    @pulumi.getter(name="databaseManagementConnectionId")
    def database_management_connection_id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "database_management_connection_id")

    @property
    @pulumi.getter(name="databaseManagementStatus")
    def database_management_status(self) -> Optional[str]:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "database_management_status")

    @property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> Optional[str]:
        """
        The Oracle license model that applies to the external database.
        """
        return pulumi.get(self, "license_model")


@pulumi.output_type
class ExternalPluggableDatabaseOperationsInsightsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operationsInsightsConnectorId":
            suggest = "operations_insights_connector_id"
        elif key == "operationsInsightsStatus":
            suggest = "operations_insights_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalPluggableDatabaseOperationsInsightsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalPluggableDatabaseOperationsInsightsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalPluggableDatabaseOperationsInsightsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operations_insights_connector_id: Optional[str] = None,
                 operations_insights_status: Optional[str] = None):
        """
        :param str operations_insights_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param str operations_insights_status: The status of Operations Insights
        """
        ExternalPluggableDatabaseOperationsInsightsConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operations_insights_connector_id=operations_insights_connector_id,
            operations_insights_status=operations_insights_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operations_insights_connector_id: Optional[str] = None,
             operations_insights_status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if operations_insights_connector_id is not None:
            _setter("operations_insights_connector_id", operations_insights_connector_id)
        if operations_insights_status is not None:
            _setter("operations_insights_status", operations_insights_status)

    @property
    @pulumi.getter(name="operationsInsightsConnectorId")
    def operations_insights_connector_id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "operations_insights_connector_id")

    @property
    @pulumi.getter(name="operationsInsightsStatus")
    def operations_insights_status(self) -> Optional[str]:
        """
        The status of Operations Insights
        """
        return pulumi.get(self, "operations_insights_status")


@pulumi.output_type
class ExternalPluggableDatabaseStackMonitoringConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stackMonitoringConnectorId":
            suggest = "stack_monitoring_connector_id"
        elif key == "stackMonitoringStatus":
            suggest = "stack_monitoring_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalPluggableDatabaseStackMonitoringConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalPluggableDatabaseStackMonitoringConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalPluggableDatabaseStackMonitoringConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 stack_monitoring_connector_id: Optional[str] = None,
                 stack_monitoring_status: Optional[str] = None):
        """
        :param str stack_monitoring_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param str stack_monitoring_status: The status of Stack Monitoring.
        """
        ExternalPluggableDatabaseStackMonitoringConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            stack_monitoring_connector_id=stack_monitoring_connector_id,
            stack_monitoring_status=stack_monitoring_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             stack_monitoring_connector_id: Optional[str] = None,
             stack_monitoring_status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if stack_monitoring_connector_id is not None:
            _setter("stack_monitoring_connector_id", stack_monitoring_connector_id)
        if stack_monitoring_status is not None:
            _setter("stack_monitoring_status", stack_monitoring_status)

    @property
    @pulumi.getter(name="stackMonitoringConnectorId")
    def stack_monitoring_connector_id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "stack_monitoring_connector_id")

    @property
    @pulumi.getter(name="stackMonitoringStatus")
    def stack_monitoring_status(self) -> Optional[str]:
        """
        The status of Stack Monitoring.
        """
        return pulumi.get(self, "stack_monitoring_status")


@pulumi.output_type
class KeyStoreAssociatedDatabase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbName":
            suggest = "db_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeyStoreAssociatedDatabase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeyStoreAssociatedDatabase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeyStoreAssociatedDatabase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_name: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param str db_name: The name of the database that is associated with the key store.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        """
        KeyStoreAssociatedDatabase._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_name=db_name,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_name: Optional[str] = None,
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if db_name is not None:
            _setter("db_name", db_name)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[str]:
        """
        The name of the database that is associated with the key store.
        """
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class KeyStoreTypeDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminUsername":
            suggest = "admin_username"
        elif key == "connectionIps":
            suggest = "connection_ips"
        elif key == "secretId":
            suggest = "secret_id"
        elif key == "vaultId":
            suggest = "vault_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeyStoreTypeDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeyStoreTypeDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeyStoreTypeDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_username: str,
                 connection_ips: Sequence[str],
                 secret_id: str,
                 type: str,
                 vault_id: str):
        """
        :param str admin_username: (Updatable) The administrator username to connect to Oracle Key Vault
        :param Sequence[str] connection_ips: (Updatable) The list of Oracle Key Vault connection IP addresses.
        :param str secret_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        :param str type: (Updatable) The type of key store.
        :param str vault_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        KeyStoreTypeDetails._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            admin_username=admin_username,
            connection_ips=connection_ips,
            secret_id=secret_id,
            type=type,
            vault_id=vault_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             admin_username: str,
             connection_ips: Sequence[str],
             secret_id: str,
             type: str,
             vault_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("admin_username", admin_username)
        _setter("connection_ips", connection_ips)
        _setter("secret_id", secret_id)
        _setter("type", type)
        _setter("vault_id", vault_id)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> str:
        """
        (Updatable) The administrator username to connect to Oracle Key Vault
        """
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="connectionIps")
    def connection_ips(self) -> Sequence[str]:
        """
        (Updatable) The list of Oracle Key Vault connection IP addresses.
        """
        return pulumi.get(self, "connection_ips")

    @property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> str:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "secret_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        (Updatable) The type of key store.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> str:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class MaintenanceRunEstimatedPatchingTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "estimatedDbServerPatchingTime":
            suggest = "estimated_db_server_patching_time"
        elif key == "estimatedNetworkSwitchesPatchingTime":
            suggest = "estimated_network_switches_patching_time"
        elif key == "estimatedStorageServerPatchingTime":
            suggest = "estimated_storage_server_patching_time"
        elif key == "totalEstimatedPatchingTime":
            suggest = "total_estimated_patching_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceRunEstimatedPatchingTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceRunEstimatedPatchingTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceRunEstimatedPatchingTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 estimated_db_server_patching_time: Optional[int] = None,
                 estimated_network_switches_patching_time: Optional[int] = None,
                 estimated_storage_server_patching_time: Optional[int] = None,
                 total_estimated_patching_time: Optional[int] = None):
        """
        :param int estimated_db_server_patching_time: The estimated time required in minutes for database server patching.
        :param int estimated_network_switches_patching_time: The estimated time required in minutes for network switch patching.
        :param int estimated_storage_server_patching_time: The estimated time required in minutes for storage server patching.
        :param int total_estimated_patching_time: The estimated total time required in minutes for all patching operations.
        """
        MaintenanceRunEstimatedPatchingTime._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            estimated_db_server_patching_time=estimated_db_server_patching_time,
            estimated_network_switches_patching_time=estimated_network_switches_patching_time,
            estimated_storage_server_patching_time=estimated_storage_server_patching_time,
            total_estimated_patching_time=total_estimated_patching_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             estimated_db_server_patching_time: Optional[int] = None,
             estimated_network_switches_patching_time: Optional[int] = None,
             estimated_storage_server_patching_time: Optional[int] = None,
             total_estimated_patching_time: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if estimated_db_server_patching_time is not None:
            _setter("estimated_db_server_patching_time", estimated_db_server_patching_time)
        if estimated_network_switches_patching_time is not None:
            _setter("estimated_network_switches_patching_time", estimated_network_switches_patching_time)
        if estimated_storage_server_patching_time is not None:
            _setter("estimated_storage_server_patching_time", estimated_storage_server_patching_time)
        if total_estimated_patching_time is not None:
            _setter("total_estimated_patching_time", total_estimated_patching_time)

    @property
    @pulumi.getter(name="estimatedDbServerPatchingTime")
    def estimated_db_server_patching_time(self) -> Optional[int]:
        """
        The estimated time required in minutes for database server patching.
        """
        return pulumi.get(self, "estimated_db_server_patching_time")

    @property
    @pulumi.getter(name="estimatedNetworkSwitchesPatchingTime")
    def estimated_network_switches_patching_time(self) -> Optional[int]:
        """
        The estimated time required in minutes for network switch patching.
        """
        return pulumi.get(self, "estimated_network_switches_patching_time")

    @property
    @pulumi.getter(name="estimatedStorageServerPatchingTime")
    def estimated_storage_server_patching_time(self) -> Optional[int]:
        """
        The estimated time required in minutes for storage server patching.
        """
        return pulumi.get(self, "estimated_storage_server_patching_time")

    @property
    @pulumi.getter(name="totalEstimatedPatchingTime")
    def total_estimated_patching_time(self) -> Optional[int]:
        """
        The estimated total time required in minutes for all patching operations.
        """
        return pulumi.get(self, "total_estimated_patching_time")


@pulumi.output_type
class PluggableDatabaseConnectionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allConnectionStrings":
            suggest = "all_connection_strings"
        elif key == "pdbDefault":
            suggest = "pdb_default"
        elif key == "pdbIpDefault":
            suggest = "pdb_ip_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PluggableDatabaseConnectionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PluggableDatabaseConnectionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PluggableDatabaseConnectionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_connection_strings: Optional[Mapping[str, Any]] = None,
                 pdb_default: Optional[str] = None,
                 pdb_ip_default: Optional[str] = None):
        """
        :param Mapping[str, Any] all_connection_strings: All connection strings to use to connect to the pluggable database.
        :param str pdb_default: A host name-based PDB connection string.
        :param str pdb_ip_default: An IP-based PDB connection string.
        """
        PluggableDatabaseConnectionString._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_connection_strings=all_connection_strings,
            pdb_default=pdb_default,
            pdb_ip_default=pdb_ip_default,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_connection_strings: Optional[Mapping[str, Any]] = None,
             pdb_default: Optional[str] = None,
             pdb_ip_default: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if all_connection_strings is not None:
            _setter("all_connection_strings", all_connection_strings)
        if pdb_default is not None:
            _setter("pdb_default", pdb_default)
        if pdb_ip_default is not None:
            _setter("pdb_ip_default", pdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[Mapping[str, Any]]:
        """
        All connection strings to use to connect to the pluggable database.
        """
        return pulumi.get(self, "all_connection_strings")

    @property
    @pulumi.getter(name="pdbDefault")
    def pdb_default(self) -> Optional[str]:
        """
        A host name-based PDB connection string.
        """
        return pulumi.get(self, "pdb_default")

    @property
    @pulumi.getter(name="pdbIpDefault")
    def pdb_ip_default(self) -> Optional[str]:
        """
        An IP-based PDB connection string.
        """
        return pulumi.get(self, "pdb_ip_default")


@pulumi.output_type
class PluggableDatabaseManagementsManagementConnectionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enablePluggabledatabasemanagement":
            suggest = "enable_pluggabledatabasemanagement"
        elif key == "allConnectionStrings":
            suggest = "all_connection_strings"
        elif key == "pdbDefault":
            suggest = "pdb_default"
        elif key == "pdbIpDefault":
            suggest = "pdb_ip_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PluggableDatabaseManagementsManagementConnectionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PluggableDatabaseManagementsManagementConnectionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PluggableDatabaseManagementsManagementConnectionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_pluggabledatabasemanagement: bool,
                 all_connection_strings: Optional[Mapping[str, Any]] = None,
                 pdb_default: Optional[str] = None,
                 pdb_ip_default: Optional[str] = None):
        """
        :param bool enable_pluggabledatabasemanagement: (Updatable) A required field when set to `true` calls enable action and when set to `false` calls disable action.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param Mapping[str, Any] all_connection_strings: All connection strings to use to connect to the pluggable database.
        :param str pdb_default: A host name-based PDB connection string.
        :param str pdb_ip_default: An IP-based PDB connection string.
        """
        PluggableDatabaseManagementsManagementConnectionString._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enable_pluggabledatabasemanagement=enable_pluggabledatabasemanagement,
            all_connection_strings=all_connection_strings,
            pdb_default=pdb_default,
            pdb_ip_default=pdb_ip_default,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enable_pluggabledatabasemanagement: bool,
             all_connection_strings: Optional[Mapping[str, Any]] = None,
             pdb_default: Optional[str] = None,
             pdb_ip_default: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("enable_pluggabledatabasemanagement", enable_pluggabledatabasemanagement)
        if all_connection_strings is not None:
            _setter("all_connection_strings", all_connection_strings)
        if pdb_default is not None:
            _setter("pdb_default", pdb_default)
        if pdb_ip_default is not None:
            _setter("pdb_ip_default", pdb_ip_default)

    @property
    @pulumi.getter(name="enablePluggabledatabasemanagement")
    def enable_pluggabledatabasemanagement(self) -> bool:
        """
        (Updatable) A required field when set to `true` calls enable action and when set to `false` calls disable action.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "enable_pluggabledatabasemanagement")

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[Mapping[str, Any]]:
        """
        All connection strings to use to connect to the pluggable database.
        """
        return pulumi.get(self, "all_connection_strings")

    @property
    @pulumi.getter(name="pdbDefault")
    def pdb_default(self) -> Optional[str]:
        """
        A host name-based PDB connection string.
        """
        return pulumi.get(self, "pdb_default")

    @property
    @pulumi.getter(name="pdbIpDefault")
    def pdb_ip_default(self) -> Optional[str]:
        """
        An IP-based PDB connection string.
        """
        return pulumi.get(self, "pdb_ip_default")


@pulumi.output_type
class PluggableDatabaseManagementsManagementCredentialDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordSecretId":
            suggest = "password_secret_id"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PluggableDatabaseManagementsManagementCredentialDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PluggableDatabaseManagementsManagementCredentialDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PluggableDatabaseManagementsManagementCredentialDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_secret_id: str,
                 user_name: str):
        """
        :param str password_secret_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        :param str user_name: The name of the Oracle Database user that will be used to connect to the database.
        """
        PluggableDatabaseManagementsManagementCredentialDetails._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password_secret_id=password_secret_id,
            user_name=user_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password_secret_id: str,
             user_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("password_secret_id", password_secret_id)
        _setter("user_name", user_name)

    @property
    @pulumi.getter(name="passwordSecretId")
    def password_secret_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "password_secret_id")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> str:
        """
        The name of the Oracle Database user that will be used to connect to the database.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class PluggableDatabaseManagementsManagementPluggableDatabaseManagementConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enablePluggabledatabasemanagement":
            suggest = "enable_pluggabledatabasemanagement"
        elif key == "managementStatus":
            suggest = "management_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PluggableDatabaseManagementsManagementPluggableDatabaseManagementConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PluggableDatabaseManagementsManagementPluggableDatabaseManagementConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PluggableDatabaseManagementsManagementPluggableDatabaseManagementConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_pluggabledatabasemanagement: bool,
                 management_status: Optional[str] = None):
        """
        :param bool enable_pluggabledatabasemanagement: (Updatable) A required field when set to `true` calls enable action and when set to `false` calls disable action.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        :param str management_status: The status of the Pluggable Database Management service.
        """
        PluggableDatabaseManagementsManagementPluggableDatabaseManagementConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enable_pluggabledatabasemanagement=enable_pluggabledatabasemanagement,
            management_status=management_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enable_pluggabledatabasemanagement: bool,
             management_status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("enable_pluggabledatabasemanagement", enable_pluggabledatabasemanagement)
        if management_status is not None:
            _setter("management_status", management_status)

    @property
    @pulumi.getter(name="enablePluggabledatabasemanagement")
    def enable_pluggabledatabasemanagement(self) -> bool:
        """
        (Updatable) A required field when set to `true` calls enable action and when set to `false` calls disable action.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "enable_pluggabledatabasemanagement")

    @property
    @pulumi.getter(name="managementStatus")
    def management_status(self) -> Optional[str]:
        """
        The status of the Pluggable Database Management service.
        """
        return pulumi.get(self, "management_status")


@pulumi.output_type
class PluggableDatabasePluggableDatabaseManagementConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementStatus":
            suggest = "management_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PluggableDatabasePluggableDatabaseManagementConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PluggableDatabasePluggableDatabaseManagementConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PluggableDatabasePluggableDatabaseManagementConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_status: Optional[str] = None):
        """
        :param str management_status: The status of the Pluggable Database Management service.
        """
        PluggableDatabasePluggableDatabaseManagementConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            management_status=management_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             management_status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if management_status is not None:
            _setter("management_status", management_status)

    @property
    @pulumi.getter(name="managementStatus")
    def management_status(self) -> Optional[str]:
        """
        The status of the Pluggable Database Management service.
        """
        return pulumi.get(self, "management_status")


@pulumi.output_type
class PluggableDatabasesLocalCloneConnectionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allConnectionStrings":
            suggest = "all_connection_strings"
        elif key == "pdbDefault":
            suggest = "pdb_default"
        elif key == "pdbIpDefault":
            suggest = "pdb_ip_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PluggableDatabasesLocalCloneConnectionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PluggableDatabasesLocalCloneConnectionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PluggableDatabasesLocalCloneConnectionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_connection_strings: Optional[Mapping[str, Any]] = None,
                 pdb_default: Optional[str] = None,
                 pdb_ip_default: Optional[str] = None):
        """
        :param Mapping[str, Any] all_connection_strings: All connection strings to use to connect to the pluggable database.
        :param str pdb_default: A host name-based PDB connection string.
        :param str pdb_ip_default: An IP-based PDB connection string.
        """
        PluggableDatabasesLocalCloneConnectionString._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_connection_strings=all_connection_strings,
            pdb_default=pdb_default,
            pdb_ip_default=pdb_ip_default,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_connection_strings: Optional[Mapping[str, Any]] = None,
             pdb_default: Optional[str] = None,
             pdb_ip_default: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if all_connection_strings is not None:
            _setter("all_connection_strings", all_connection_strings)
        if pdb_default is not None:
            _setter("pdb_default", pdb_default)
        if pdb_ip_default is not None:
            _setter("pdb_ip_default", pdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[Mapping[str, Any]]:
        """
        All connection strings to use to connect to the pluggable database.
        """
        return pulumi.get(self, "all_connection_strings")

    @property
    @pulumi.getter(name="pdbDefault")
    def pdb_default(self) -> Optional[str]:
        """
        A host name-based PDB connection string.
        """
        return pulumi.get(self, "pdb_default")

    @property
    @pulumi.getter(name="pdbIpDefault")
    def pdb_ip_default(self) -> Optional[str]:
        """
        An IP-based PDB connection string.
        """
        return pulumi.get(self, "pdb_ip_default")


@pulumi.output_type
class PluggableDatabasesLocalClonePluggableDatabaseManagementConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementStatus":
            suggest = "management_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PluggableDatabasesLocalClonePluggableDatabaseManagementConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PluggableDatabasesLocalClonePluggableDatabaseManagementConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PluggableDatabasesLocalClonePluggableDatabaseManagementConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_status: Optional[str] = None):
        """
        :param str management_status: The status of the Pluggable Database Management service.
        """
        PluggableDatabasesLocalClonePluggableDatabaseManagementConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            management_status=management_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             management_status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if management_status is not None:
            _setter("management_status", management_status)

    @property
    @pulumi.getter(name="managementStatus")
    def management_status(self) -> Optional[str]:
        """
        The status of the Pluggable Database Management service.
        """
        return pulumi.get(self, "management_status")


@pulumi.output_type
class PluggableDatabasesRemoteCloneConnectionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allConnectionStrings":
            suggest = "all_connection_strings"
        elif key == "pdbDefault":
            suggest = "pdb_default"
        elif key == "pdbIpDefault":
            suggest = "pdb_ip_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PluggableDatabasesRemoteCloneConnectionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PluggableDatabasesRemoteCloneConnectionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PluggableDatabasesRemoteCloneConnectionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_connection_strings: Optional[Mapping[str, Any]] = None,
                 pdb_default: Optional[str] = None,
                 pdb_ip_default: Optional[str] = None):
        """
        :param Mapping[str, Any] all_connection_strings: All connection strings to use to connect to the pluggable database.
        :param str pdb_default: A host name-based PDB connection string.
        :param str pdb_ip_default: An IP-based PDB connection string.
        """
        PluggableDatabasesRemoteCloneConnectionString._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_connection_strings=all_connection_strings,
            pdb_default=pdb_default,
            pdb_ip_default=pdb_ip_default,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_connection_strings: Optional[Mapping[str, Any]] = None,
             pdb_default: Optional[str] = None,
             pdb_ip_default: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if all_connection_strings is not None:
            _setter("all_connection_strings", all_connection_strings)
        if pdb_default is not None:
            _setter("pdb_default", pdb_default)
        if pdb_ip_default is not None:
            _setter("pdb_ip_default", pdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[Mapping[str, Any]]:
        """
        All connection strings to use to connect to the pluggable database.
        """
        return pulumi.get(self, "all_connection_strings")

    @property
    @pulumi.getter(name="pdbDefault")
    def pdb_default(self) -> Optional[str]:
        """
        A host name-based PDB connection string.
        """
        return pulumi.get(self, "pdb_default")

    @property
    @pulumi.getter(name="pdbIpDefault")
    def pdb_ip_default(self) -> Optional[str]:
        """
        An IP-based PDB connection string.
        """
        return pulumi.get(self, "pdb_ip_default")


@pulumi.output_type
class PluggableDatabasesRemoteClonePluggableDatabaseManagementConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementStatus":
            suggest = "management_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PluggableDatabasesRemoteClonePluggableDatabaseManagementConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PluggableDatabasesRemoteClonePluggableDatabaseManagementConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PluggableDatabasesRemoteClonePluggableDatabaseManagementConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_status: Optional[str] = None):
        """
        :param str management_status: The status of the Pluggable Database Management service.
        """
        PluggableDatabasesRemoteClonePluggableDatabaseManagementConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            management_status=management_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             management_status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if management_status is not None:
            _setter("management_status", management_status)

    @property
    @pulumi.getter(name="managementStatus")
    def management_status(self) -> Optional[str]:
        """
        The status of the Pluggable Database Management service.
        """
        return pulumi.get(self, "management_status")


@pulumi.output_type
class VmClusterAddVirtualNetworkDataCollectionOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isDiagnosticsEventsEnabled":
            suggest = "is_diagnostics_events_enabled"
        elif key == "isHealthMonitoringEnabled":
            suggest = "is_health_monitoring_enabled"
        elif key == "isIncidentLogsEnabled":
            suggest = "is_incident_logs_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmClusterAddVirtualNetworkDataCollectionOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmClusterAddVirtualNetworkDataCollectionOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmClusterAddVirtualNetworkDataCollectionOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_diagnostics_events_enabled: Optional[bool] = None,
                 is_health_monitoring_enabled: Optional[bool] = None,
                 is_incident_logs_enabled: Optional[bool] = None):
        """
        :param bool is_diagnostics_events_enabled: Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param bool is_health_monitoring_enabled: Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param bool is_incident_logs_enabled: Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        VmClusterAddVirtualNetworkDataCollectionOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_diagnostics_events_enabled=is_diagnostics_events_enabled,
            is_health_monitoring_enabled=is_health_monitoring_enabled,
            is_incident_logs_enabled=is_incident_logs_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_diagnostics_events_enabled: Optional[bool] = None,
             is_health_monitoring_enabled: Optional[bool] = None,
             is_incident_logs_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_diagnostics_events_enabled is not None:
            _setter("is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        if is_health_monitoring_enabled is not None:
            _setter("is_health_monitoring_enabled", is_health_monitoring_enabled)
        if is_incident_logs_enabled is not None:
            _setter("is_incident_logs_enabled", is_incident_logs_enabled)

    @property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> Optional[bool]:
        """
        Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> Optional[bool]:
        """
        Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> Optional[bool]:
        """
        Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")


@pulumi.output_type
class VmClusterAddVirtualNetworkDbServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbServerId":
            suggest = "db_server_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmClusterAddVirtualNetworkDbServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmClusterAddVirtualNetworkDbServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmClusterAddVirtualNetworkDbServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_server_id: str):
        """
        :param str db_server_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of Exacc Db server.
        """
        VmClusterAddVirtualNetworkDbServer._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_server_id=db_server_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_server_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("db_server_id", db_server_id)

    @property
    @pulumi.getter(name="dbServerId")
    def db_server_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of Exacc Db server.
        """
        return pulumi.get(self, "db_server_id")


@pulumi.output_type
class VmClusterDataCollectionOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isDiagnosticsEventsEnabled":
            suggest = "is_diagnostics_events_enabled"
        elif key == "isHealthMonitoringEnabled":
            suggest = "is_health_monitoring_enabled"
        elif key == "isIncidentLogsEnabled":
            suggest = "is_incident_logs_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmClusterDataCollectionOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmClusterDataCollectionOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmClusterDataCollectionOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_diagnostics_events_enabled: Optional[bool] = None,
                 is_health_monitoring_enabled: Optional[bool] = None,
                 is_incident_logs_enabled: Optional[bool] = None):
        """
        :param bool is_diagnostics_events_enabled: (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param bool is_health_monitoring_enabled: (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param bool is_incident_logs_enabled: (Updatable) Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        VmClusterDataCollectionOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_diagnostics_events_enabled=is_diagnostics_events_enabled,
            is_health_monitoring_enabled=is_health_monitoring_enabled,
            is_incident_logs_enabled=is_incident_logs_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_diagnostics_events_enabled: Optional[bool] = None,
             is_health_monitoring_enabled: Optional[bool] = None,
             is_incident_logs_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_diagnostics_events_enabled is not None:
            _setter("is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        if is_health_monitoring_enabled is not None:
            _setter("is_health_monitoring_enabled", is_health_monitoring_enabled)
        if is_incident_logs_enabled is not None:
            _setter("is_incident_logs_enabled", is_incident_logs_enabled)

    @property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> Optional[bool]:
        """
        (Updatable) Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> Optional[bool]:
        """
        (Updatable) Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> Optional[bool]:
        """
        (Updatable) Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")


@pulumi.output_type
class VmClusterNetworkDrScan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scanListenerPortTcp":
            suggest = "scan_listener_port_tcp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmClusterNetworkDrScan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmClusterNetworkDrScan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmClusterNetworkDrScan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 ips: Sequence[str],
                 scan_listener_port_tcp: int):
        """
        :param str hostname: (Updatable) The node host name.
        :param Sequence[str] ips: (Updatable) The list of SCAN IP addresses. Three addresses should be provided.
        :param int scan_listener_port_tcp: (Updatable) The SCAN TCPIP port. Default is 1521.
        """
        VmClusterNetworkDrScan._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hostname=hostname,
            ips=ips,
            scan_listener_port_tcp=scan_listener_port_tcp,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hostname: str,
             ips: Sequence[str],
             scan_listener_port_tcp: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("hostname", hostname)
        _setter("ips", ips)
        _setter("scan_listener_port_tcp", scan_listener_port_tcp)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        (Updatable) The node host name.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def ips(self) -> Sequence[str]:
        """
        (Updatable) The list of SCAN IP addresses. Three addresses should be provided.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="scanListenerPortTcp")
    def scan_listener_port_tcp(self) -> int:
        """
        (Updatable) The SCAN TCPIP port. Default is 1521.
        """
        return pulumi.get(self, "scan_listener_port_tcp")


@pulumi.output_type
class VmClusterNetworkScan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scanListenerPortTcp":
            suggest = "scan_listener_port_tcp"
        elif key == "scanListenerPortTcpSsl":
            suggest = "scan_listener_port_tcp_ssl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmClusterNetworkScan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmClusterNetworkScan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmClusterNetworkScan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 ips: Sequence[str],
                 port: Optional[int] = None,
                 scan_listener_port_tcp: Optional[int] = None,
                 scan_listener_port_tcp_ssl: Optional[int] = None):
        """
        :param str hostname: (Updatable) The node host name.
        :param Sequence[str] ips: (Updatable) The list of SCAN IP addresses. Three addresses should be provided.
        :param int port: (Updatable) **Deprecated.** This field is deprecated. You may use 'scanListenerPortTcp' to specify the port. The SCAN TCPIP port. Default is 1521.
        :param int scan_listener_port_tcp: (Updatable) The SCAN TCPIP port. Default is 1521.
        :param int scan_listener_port_tcp_ssl: (Updatable) The SCAN TCPIP SSL port. Default is 2484.
        """
        VmClusterNetworkScan._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hostname=hostname,
            ips=ips,
            port=port,
            scan_listener_port_tcp=scan_listener_port_tcp,
            scan_listener_port_tcp_ssl=scan_listener_port_tcp_ssl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hostname: str,
             ips: Sequence[str],
             port: Optional[int] = None,
             scan_listener_port_tcp: Optional[int] = None,
             scan_listener_port_tcp_ssl: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("hostname", hostname)
        _setter("ips", ips)
        if port is not None:
            _setter("port", port)
        if scan_listener_port_tcp is not None:
            _setter("scan_listener_port_tcp", scan_listener_port_tcp)
        if scan_listener_port_tcp_ssl is not None:
            _setter("scan_listener_port_tcp_ssl", scan_listener_port_tcp_ssl)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        (Updatable) The node host name.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def ips(self) -> Sequence[str]:
        """
        (Updatable) The list of SCAN IP addresses. Three addresses should be provided.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        (Updatable) **Deprecated.** This field is deprecated. You may use 'scanListenerPortTcp' to specify the port. The SCAN TCPIP port. Default is 1521.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="scanListenerPortTcp")
    def scan_listener_port_tcp(self) -> Optional[int]:
        """
        (Updatable) The SCAN TCPIP port. Default is 1521.
        """
        return pulumi.get(self, "scan_listener_port_tcp")

    @property
    @pulumi.getter(name="scanListenerPortTcpSsl")
    def scan_listener_port_tcp_ssl(self) -> Optional[int]:
        """
        (Updatable) The SCAN TCPIP SSL port. Default is 2484.
        """
        return pulumi.get(self, "scan_listener_port_tcp_ssl")


@pulumi.output_type
class VmClusterNetworkVmNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkType":
            suggest = "network_type"
        elif key == "domainName":
            suggest = "domain_name"
        elif key == "vlanId":
            suggest = "vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmClusterNetworkVmNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmClusterNetworkVmNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmClusterNetworkVmNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_type: str,
                 nodes: Sequence['outputs.VmClusterNetworkVmNetworkNode'],
                 domain_name: Optional[str] = None,
                 gateway: Optional[str] = None,
                 netmask: Optional[str] = None,
                 vlan_id: Optional[str] = None):
        """
        :param str network_type: (Updatable) The network type.
        :param Sequence['VmClusterNetworkVmNetworkNodeArgs'] nodes: (Updatable) The list of node details.
        :param str domain_name: (Updatable) The network domain name.
        :param str gateway: (Updatable) The network gateway.
        :param str netmask: (Updatable) The network netmask.
        :param str vlan_id: (Updatable) The network VLAN ID.
               
               
               ** IMPORTANT **
               Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        VmClusterNetworkVmNetwork._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            network_type=network_type,
            nodes=nodes,
            domain_name=domain_name,
            gateway=gateway,
            netmask=netmask,
            vlan_id=vlan_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             network_type: str,
             nodes: Sequence['outputs.VmClusterNetworkVmNetworkNode'],
             domain_name: Optional[str] = None,
             gateway: Optional[str] = None,
             netmask: Optional[str] = None,
             vlan_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("network_type", network_type)
        _setter("nodes", nodes)
        if domain_name is not None:
            _setter("domain_name", domain_name)
        if gateway is not None:
            _setter("gateway", gateway)
        if netmask is not None:
            _setter("netmask", netmask)
        if vlan_id is not None:
            _setter("vlan_id", vlan_id)

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> str:
        """
        (Updatable) The network type.
        """
        return pulumi.get(self, "network_type")

    @property
    @pulumi.getter
    def nodes(self) -> Sequence['outputs.VmClusterNetworkVmNetworkNode']:
        """
        (Updatable) The list of node details.
        """
        return pulumi.get(self, "nodes")

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[str]:
        """
        (Updatable) The network domain name.
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter
    def gateway(self) -> Optional[str]:
        """
        (Updatable) The network gateway.
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter
    def netmask(self) -> Optional[str]:
        """
        (Updatable) The network netmask.
        """
        return pulumi.get(self, "netmask")

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[str]:
        """
        (Updatable) The network VLAN ID.


        ** IMPORTANT **
        Any change to a property that does not support update will force the destruction and recreation of the resource with the new property values
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class VmClusterNetworkVmNetworkNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbServerId":
            suggest = "db_server_id"
        elif key == "vipHostname":
            suggest = "vip_hostname"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmClusterNetworkVmNetworkNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmClusterNetworkVmNetworkNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmClusterNetworkVmNetworkNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: str,
                 ip: str,
                 db_server_id: Optional[str] = None,
                 state: Optional[str] = None,
                 vip: Optional[str] = None,
                 vip_hostname: Optional[str] = None):
        """
        :param str hostname: (Updatable) The node host name.
        :param str ip: (Updatable) The node IP address.
        :param str db_server_id: (Updatable) The Db server associated with the node.
        :param str state: (Updatable) The current state of the VM cluster network nodes. CREATING - The resource is being created REQUIRES_VALIDATION - The resource is created and may not be usable until it is validated. VALIDATING - The resource is being validated and not available to use. VALIDATED - The resource is validated and is available for consumption by VM cluster. VALIDATION_FAILED - The resource validation has failed and might require user input to be corrected. UPDATING - The resource is being updated and not available to use. ALLOCATED - The resource is currently being used by VM cluster. TERMINATING - The resource is being deleted and not available to use. TERMINATED - The resource is deleted and unavailable. FAILED - The resource is in a failed state due to validation or other errors.
        :param str vip: (Updatable) The node virtual IP (VIP) address.
        :param str vip_hostname: (Updatable) The node virtual IP (VIP) host name.
        """
        VmClusterNetworkVmNetworkNode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hostname=hostname,
            ip=ip,
            db_server_id=db_server_id,
            state=state,
            vip=vip,
            vip_hostname=vip_hostname,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hostname: str,
             ip: str,
             db_server_id: Optional[str] = None,
             state: Optional[str] = None,
             vip: Optional[str] = None,
             vip_hostname: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("hostname", hostname)
        _setter("ip", ip)
        if db_server_id is not None:
            _setter("db_server_id", db_server_id)
        if state is not None:
            _setter("state", state)
        if vip is not None:
            _setter("vip", vip)
        if vip_hostname is not None:
            _setter("vip_hostname", vip_hostname)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        (Updatable) The node host name.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        (Updatable) The node IP address.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="dbServerId")
    def db_server_id(self) -> Optional[str]:
        """
        (Updatable) The Db server associated with the node.
        """
        return pulumi.get(self, "db_server_id")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        (Updatable) The current state of the VM cluster network nodes. CREATING - The resource is being created REQUIRES_VALIDATION - The resource is created and may not be usable until it is validated. VALIDATING - The resource is being validated and not available to use. VALIDATED - The resource is validated and is available for consumption by VM cluster. VALIDATION_FAILED - The resource validation has failed and might require user input to be corrected. UPDATING - The resource is being updated and not available to use. ALLOCATED - The resource is currently being used by VM cluster. TERMINATING - The resource is being deleted and not available to use. TERMINATED - The resource is deleted and unavailable. FAILED - The resource is in a failed state due to validation or other errors.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def vip(self) -> Optional[str]:
        """
        (Updatable) The node virtual IP (VIP) address.
        """
        return pulumi.get(self, "vip")

    @property
    @pulumi.getter(name="vipHostname")
    def vip_hostname(self) -> Optional[str]:
        """
        (Updatable) The node virtual IP (VIP) host name.
        """
        return pulumi.get(self, "vip_hostname")


@pulumi.output_type
class VmClusterRemoveVirtualMachineDataCollectionOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isDiagnosticsEventsEnabled":
            suggest = "is_diagnostics_events_enabled"
        elif key == "isHealthMonitoringEnabled":
            suggest = "is_health_monitoring_enabled"
        elif key == "isIncidentLogsEnabled":
            suggest = "is_incident_logs_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmClusterRemoveVirtualMachineDataCollectionOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmClusterRemoveVirtualMachineDataCollectionOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmClusterRemoveVirtualMachineDataCollectionOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_diagnostics_events_enabled: Optional[bool] = None,
                 is_health_monitoring_enabled: Optional[bool] = None,
                 is_incident_logs_enabled: Optional[bool] = None):
        """
        :param bool is_diagnostics_events_enabled: Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param bool is_health_monitoring_enabled: Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param bool is_incident_logs_enabled: Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        VmClusterRemoveVirtualMachineDataCollectionOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_diagnostics_events_enabled=is_diagnostics_events_enabled,
            is_health_monitoring_enabled=is_health_monitoring_enabled,
            is_incident_logs_enabled=is_incident_logs_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_diagnostics_events_enabled: Optional[bool] = None,
             is_health_monitoring_enabled: Optional[bool] = None,
             is_incident_logs_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_diagnostics_events_enabled is not None:
            _setter("is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        if is_health_monitoring_enabled is not None:
            _setter("is_health_monitoring_enabled", is_health_monitoring_enabled)
        if is_incident_logs_enabled is not None:
            _setter("is_incident_logs_enabled", is_incident_logs_enabled)

    @property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> Optional[bool]:
        """
        Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> Optional[bool]:
        """
        Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> Optional[bool]:
        """
        Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")


@pulumi.output_type
class VmClusterRemoveVirtualMachineDbServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbServerId":
            suggest = "db_server_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmClusterRemoveVirtualMachineDbServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmClusterRemoveVirtualMachineDbServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmClusterRemoveVirtualMachineDbServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_server_id: str):
        """
        :param str db_server_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of Exacc Db server.
        """
        VmClusterRemoveVirtualMachineDbServer._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_server_id=db_server_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_server_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("db_server_id", db_server_id)

    @property
    @pulumi.getter(name="dbServerId")
    def db_server_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of Exacc Db server.
        """
        return pulumi.get(self, "db_server_id")


@pulumi.output_type
class GetApplicationVipsApplicationVipResult(dict):
    def __init__(__self__, *,
                 cloud_vm_cluster_id: str,
                 compartment_id: str,
                 db_node_id: str,
                 defined_tags: Mapping[str, Any],
                 freeform_tags: Mapping[str, Any],
                 hostname_label: str,
                 id: str,
                 ip_address: str,
                 lifecycle_details: str,
                 state: str,
                 subnet_id: str,
                 time_assigned: str):
        """
        :param str cloud_vm_cluster_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the cloud VM cluster associated with the application virtual IP (VIP) address.
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str hostname_label: The hostname of the application virtual IP (VIP) address.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the application virtual IP (VIP) address.
        :param str ip_address: The application virtual IP (VIP) address.
        :param str lifecycle_details: Additional information about the current lifecycle state of the application virtual IP (VIP) address.
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        :param str subnet_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet associated with the application virtual IP (VIP) address.
        :param str time_assigned: The date and time when the create operation for the application virtual IP (VIP) address completed.
        """
        GetApplicationVipsApplicationVipResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_vm_cluster_id=cloud_vm_cluster_id,
            compartment_id=compartment_id,
            db_node_id=db_node_id,
            defined_tags=defined_tags,
            freeform_tags=freeform_tags,
            hostname_label=hostname_label,
            id=id,
            ip_address=ip_address,
            lifecycle_details=lifecycle_details,
            state=state,
            subnet_id=subnet_id,
            time_assigned=time_assigned,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_vm_cluster_id: str,
             compartment_id: str,
             db_node_id: str,
             defined_tags: Mapping[str, Any],
             freeform_tags: Mapping[str, Any],
             hostname_label: str,
             id: str,
             ip_address: str,
             lifecycle_details: str,
             state: str,
             subnet_id: str,
             time_assigned: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cloud_vm_cluster_id", cloud_vm_cluster_id)
        _setter("compartment_id", compartment_id)
        _setter("db_node_id", db_node_id)
        _setter("defined_tags", defined_tags)
        _setter("freeform_tags", freeform_tags)
        _setter("hostname_label", hostname_label)
        _setter("id", id)
        _setter("ip_address", ip_address)
        _setter("lifecycle_details", lifecycle_details)
        _setter("state", state)
        _setter("subnet_id", subnet_id)
        _setter("time_assigned", time_assigned)

    @property
    @pulumi.getter(name="cloudVmClusterId")
    def cloud_vm_cluster_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the cloud VM cluster associated with the application virtual IP (VIP) address.
        """
        return pulumi.get(self, "cloud_vm_cluster_id")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="dbNodeId")
    def db_node_id(self) -> str:
        return pulumi.get(self, "db_node_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter(name="hostnameLabel")
    def hostname_label(self) -> str:
        """
        The hostname of the application virtual IP (VIP) address.
        """
        return pulumi.get(self, "hostname_label")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the application virtual IP (VIP) address.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The application virtual IP (VIP) address.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state of the application virtual IP (VIP) address.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet associated with the application virtual IP (VIP) address.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="timeAssigned")
    def time_assigned(self) -> str:
        """
        The date and time when the create operation for the application virtual IP (VIP) address completed.
        """
        return pulumi.get(self, "time_assigned")


@pulumi.output_type
class GetApplicationVipsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetApplicationVipsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousCharacterSetsAutonomousDatabaseCharacterSetResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: A valid Oracle character set.
        """
        GetAutonomousCharacterSetsAutonomousDatabaseCharacterSetResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A valid Oracle character set.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousCharacterSetsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A valid Oracle character set.
        """
        GetAutonomousCharacterSetsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A valid Oracle character set.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousContainerDatabaseBackupConfigResult(dict):
    def __init__(__self__, *,
                 backup_destination_details: Sequence['outputs.GetAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult'],
                 recovery_window_in_days: int):
        """
        :param Sequence['GetAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs'] backup_destination_details: Backup destination details.
        :param int recovery_window_in_days: Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        GetAutonomousContainerDatabaseBackupConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backup_destination_details=backup_destination_details,
            recovery_window_in_days=recovery_window_in_days,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backup_destination_details: Sequence['outputs.GetAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult'],
             recovery_window_in_days: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("backup_destination_details", backup_destination_details)
        _setter("recovery_window_in_days", recovery_window_in_days)

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Sequence['outputs.GetAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult']:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> int:
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")


@pulumi.output_type
class GetAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult(dict):
    def __init__(__self__, *,
                 id: str,
                 internet_proxy: str,
                 type: str,
                 vpc_password: str,
                 vpc_user: str):
        """
        :param str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param str internet_proxy: Proxy URL to connect to object store.
        :param str type: Type of the database backup destination.
        :param str vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param str vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        GetAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            internet_proxy=internet_proxy,
            type=type,
            vpc_password=vpc_password,
            vpc_user=vpc_user,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             internet_proxy: str,
             type: str,
             vpc_password: str,
             vpc_user: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("internet_proxy", internet_proxy)
        _setter("type", type)
        _setter("vpc_password", vpc_password)
        _setter("vpc_user", vpc_user)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> str:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> str:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> str:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class GetAutonomousContainerDatabaseDataguardAssociationsAutonomousContainerDatabaseDataguardAssociationResult(dict):
    def __init__(__self__, *,
                 apply_lag: str,
                 apply_rate: str,
                 autonomous_container_database_dataguard_association_id: str,
                 autonomous_container_database_id: str,
                 fast_start_fail_over_lag_limit_in_seconds: int,
                 id: str,
                 is_automatic_failover_enabled: bool,
                 lifecycle_details: str,
                 peer_autonomous_container_database_dataguard_association_id: str,
                 peer_autonomous_container_database_id: str,
                 peer_lifecycle_state: str,
                 peer_role: str,
                 protection_mode: str,
                 role: str,
                 state: str,
                 time_created: str,
                 time_last_role_changed: str,
                 time_last_synced: str,
                 transport_lag: str):
        """
        :param str apply_lag: The lag time between updates to the primary Autonomous Container Database and application of the redo data on the standby Autonomous Container Database, as computed by the reporting database.  Example: `9 seconds`
        :param str apply_rate: The rate at which redo logs are synchronized between the associated Autonomous Container Databases.  Example: `180 Mb per second`
        :param str autonomous_container_database_id: The Autonomous Container Database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param int fast_start_fail_over_lag_limit_in_seconds: The lag time for my preference based on data loss tolerance in seconds.
        :param str id: The OCID of the Autonomous Data Guard created for a given Autonomous Container Database.
        :param bool is_automatic_failover_enabled: Indicates whether Automatic Failover is enabled for Autonomous Container Database Dataguard Association. Output DataType: boolean. Example : is_automatic_failover_enabled = true.
        :param str lifecycle_details: Additional information about the current lifecycleState, if available.
        :param str peer_autonomous_container_database_dataguard_association_id: The OCID of the peer Autonomous Container Database-Autonomous Data Guard association.
        :param str peer_autonomous_container_database_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the peer Autonomous Container Database.
        :param str peer_lifecycle_state: The current state of Autonomous Data Guard.
        :param str peer_role: The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        :param str protection_mode: The protection mode of this Autonomous Data Guard association. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        :param str role: The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        :param str state: The current state of Autonomous Data Guard.
        :param str time_created: The date and time the Autonomous DataGuard association was created.
        :param str time_last_role_changed: The date and time when the last role change action happened.
        :param str time_last_synced: The date and time of the last update to the apply lag, apply rate, and transport lag values.
        :param str transport_lag: The approximate number of seconds of redo data not yet available on the standby Autonomous Container Database, as computed by the reporting database.  Example: `7 seconds`
        """
        GetAutonomousContainerDatabaseDataguardAssociationsAutonomousContainerDatabaseDataguardAssociationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apply_lag=apply_lag,
            apply_rate=apply_rate,
            autonomous_container_database_dataguard_association_id=autonomous_container_database_dataguard_association_id,
            autonomous_container_database_id=autonomous_container_database_id,
            fast_start_fail_over_lag_limit_in_seconds=fast_start_fail_over_lag_limit_in_seconds,
            id=id,
            is_automatic_failover_enabled=is_automatic_failover_enabled,
            lifecycle_details=lifecycle_details,
            peer_autonomous_container_database_dataguard_association_id=peer_autonomous_container_database_dataguard_association_id,
            peer_autonomous_container_database_id=peer_autonomous_container_database_id,
            peer_lifecycle_state=peer_lifecycle_state,
            peer_role=peer_role,
            protection_mode=protection_mode,
            role=role,
            state=state,
            time_created=time_created,
            time_last_role_changed=time_last_role_changed,
            time_last_synced=time_last_synced,
            transport_lag=transport_lag,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apply_lag: str,
             apply_rate: str,
             autonomous_container_database_dataguard_association_id: str,
             autonomous_container_database_id: str,
             fast_start_fail_over_lag_limit_in_seconds: int,
             id: str,
             is_automatic_failover_enabled: bool,
             lifecycle_details: str,
             peer_autonomous_container_database_dataguard_association_id: str,
             peer_autonomous_container_database_id: str,
             peer_lifecycle_state: str,
             peer_role: str,
             protection_mode: str,
             role: str,
             state: str,
             time_created: str,
             time_last_role_changed: str,
             time_last_synced: str,
             transport_lag: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("apply_lag", apply_lag)
        _setter("apply_rate", apply_rate)
        _setter("autonomous_container_database_dataguard_association_id", autonomous_container_database_dataguard_association_id)
        _setter("autonomous_container_database_id", autonomous_container_database_id)
        _setter("fast_start_fail_over_lag_limit_in_seconds", fast_start_fail_over_lag_limit_in_seconds)
        _setter("id", id)
        _setter("is_automatic_failover_enabled", is_automatic_failover_enabled)
        _setter("lifecycle_details", lifecycle_details)
        _setter("peer_autonomous_container_database_dataguard_association_id", peer_autonomous_container_database_dataguard_association_id)
        _setter("peer_autonomous_container_database_id", peer_autonomous_container_database_id)
        _setter("peer_lifecycle_state", peer_lifecycle_state)
        _setter("peer_role", peer_role)
        _setter("protection_mode", protection_mode)
        _setter("role", role)
        _setter("state", state)
        _setter("time_created", time_created)
        _setter("time_last_role_changed", time_last_role_changed)
        _setter("time_last_synced", time_last_synced)
        _setter("transport_lag", transport_lag)

    @property
    @pulumi.getter(name="applyLag")
    def apply_lag(self) -> str:
        """
        The lag time between updates to the primary Autonomous Container Database and application of the redo data on the standby Autonomous Container Database, as computed by the reporting database.  Example: `9 seconds`
        """
        return pulumi.get(self, "apply_lag")

    @property
    @pulumi.getter(name="applyRate")
    def apply_rate(self) -> str:
        """
        The rate at which redo logs are synchronized between the associated Autonomous Container Databases.  Example: `180 Mb per second`
        """
        return pulumi.get(self, "apply_rate")

    @property
    @pulumi.getter(name="autonomousContainerDatabaseDataguardAssociationId")
    def autonomous_container_database_dataguard_association_id(self) -> str:
        return pulumi.get(self, "autonomous_container_database_dataguard_association_id")

    @property
    @pulumi.getter(name="autonomousContainerDatabaseId")
    def autonomous_container_database_id(self) -> str:
        """
        The Autonomous Container Database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "autonomous_container_database_id")

    @property
    @pulumi.getter(name="fastStartFailOverLagLimitInSeconds")
    def fast_start_fail_over_lag_limit_in_seconds(self) -> int:
        """
        The lag time for my preference based on data loss tolerance in seconds.
        """
        return pulumi.get(self, "fast_start_fail_over_lag_limit_in_seconds")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the Autonomous Data Guard created for a given Autonomous Container Database.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isAutomaticFailoverEnabled")
    def is_automatic_failover_enabled(self) -> bool:
        """
        Indicates whether Automatic Failover is enabled for Autonomous Container Database Dataguard Association. Output DataType: boolean. Example : is_automatic_failover_enabled = true.
        """
        return pulumi.get(self, "is_automatic_failover_enabled")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycleState, if available.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="peerAutonomousContainerDatabaseDataguardAssociationId")
    def peer_autonomous_container_database_dataguard_association_id(self) -> str:
        """
        The OCID of the peer Autonomous Container Database-Autonomous Data Guard association.
        """
        return pulumi.get(self, "peer_autonomous_container_database_dataguard_association_id")

    @property
    @pulumi.getter(name="peerAutonomousContainerDatabaseId")
    def peer_autonomous_container_database_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the peer Autonomous Container Database.
        """
        return pulumi.get(self, "peer_autonomous_container_database_id")

    @property
    @pulumi.getter(name="peerLifecycleState")
    def peer_lifecycle_state(self) -> str:
        """
        The current state of Autonomous Data Guard.
        """
        return pulumi.get(self, "peer_lifecycle_state")

    @property
    @pulumi.getter(name="peerRole")
    def peer_role(self) -> str:
        """
        The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        """
        return pulumi.get(self, "peer_role")

    @property
    @pulumi.getter(name="protectionMode")
    def protection_mode(self) -> str:
        """
        The protection mode of this Autonomous Data Guard association. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        """
        return pulumi.get(self, "protection_mode")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of Autonomous Data Guard.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the Autonomous DataGuard association was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeLastRoleChanged")
    def time_last_role_changed(self) -> str:
        """
        The date and time when the last role change action happened.
        """
        return pulumi.get(self, "time_last_role_changed")

    @property
    @pulumi.getter(name="timeLastSynced")
    def time_last_synced(self) -> str:
        """
        The date and time of the last update to the apply lag, apply rate, and transport lag values.
        """
        return pulumi.get(self, "time_last_synced")

    @property
    @pulumi.getter(name="transportLag")
    def transport_lag(self) -> str:
        """
        The approximate number of seconds of redo data not yet available on the standby Autonomous Container Database, as computed by the reporting database.  Example: `7 seconds`
        """
        return pulumi.get(self, "transport_lag")


@pulumi.output_type
class GetAutonomousContainerDatabaseDataguardAssociationsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetAutonomousContainerDatabaseDataguardAssociationsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousContainerDatabaseKeyHistoryEntryResult(dict):
    def __init__(__self__, *,
                 id: str,
                 kms_key_version_id: str,
                 time_activated: str,
                 vault_id: str):
        """
        :param str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        :param str time_activated: The date and time the kms key activated.
        :param str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        GetAutonomousContainerDatabaseKeyHistoryEntryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            kms_key_version_id=kms_key_version_id,
            time_activated=time_activated,
            vault_id=vault_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             kms_key_version_id: str,
             time_activated: str,
             vault_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("kms_key_version_id", kms_key_version_id)
        _setter("time_activated", time_activated)
        _setter("vault_id", vault_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> str:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        """
        return pulumi.get(self, "kms_key_version_id")

    @property
    @pulumi.getter(name="timeActivated")
    def time_activated(self) -> str:
        """
        The date and time the kms key activated.
        """
        return pulumi.get(self, "time_activated")

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class GetAutonomousContainerDatabaseMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: int,
                 days_of_weeks: Sequence['outputs.GetAutonomousContainerDatabaseMaintenanceWindowDaysOfWeekResult'],
                 hours_of_days: Sequence[int],
                 is_custom_action_timeout_enabled: bool,
                 is_monthly_patching_enabled: bool,
                 lead_time_in_weeks: int,
                 months: Sequence['outputs.GetAutonomousContainerDatabaseMaintenanceWindowMonthResult'],
                 patching_mode: str,
                 preference: str,
                 weeks_of_months: Sequence[int]):
        """
        :param int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetAutonomousContainerDatabaseMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetAutonomousContainerDatabaseMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param str preference: The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        GetAutonomousContainerDatabaseMaintenanceWindowResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: int,
             days_of_weeks: Sequence['outputs.GetAutonomousContainerDatabaseMaintenanceWindowDaysOfWeekResult'],
             hours_of_days: Sequence[int],
             is_custom_action_timeout_enabled: bool,
             is_monthly_patching_enabled: bool,
             lead_time_in_weeks: int,
             months: Sequence['outputs.GetAutonomousContainerDatabaseMaintenanceWindowMonthResult'],
             patching_mode: str,
             preference: str,
             weeks_of_months: Sequence[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        _setter("days_of_weeks", days_of_weeks)
        _setter("hours_of_days", hours_of_days)
        _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        _setter("lead_time_in_weeks", lead_time_in_weeks)
        _setter("months", months)
        _setter("patching_mode", patching_mode)
        _setter("preference", preference)
        _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetAutonomousContainerDatabaseMaintenanceWindowDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetAutonomousContainerDatabaseMaintenanceWindowMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetAutonomousContainerDatabaseMaintenanceWindowDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetAutonomousContainerDatabaseMaintenanceWindowDaysOfWeekResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousContainerDatabaseMaintenanceWindowDetailResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: int,
                 days_of_weeks: Sequence['outputs.GetAutonomousContainerDatabaseMaintenanceWindowDetailDaysOfWeekResult'],
                 hours_of_days: Sequence[int],
                 is_custom_action_timeout_enabled: bool,
                 is_monthly_patching_enabled: bool,
                 lead_time_in_weeks: int,
                 months: Sequence['outputs.GetAutonomousContainerDatabaseMaintenanceWindowDetailMonthResult'],
                 patching_mode: str,
                 preference: str,
                 weeks_of_months: Sequence[int]):
        """
        :param int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetAutonomousContainerDatabaseMaintenanceWindowDetailDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetAutonomousContainerDatabaseMaintenanceWindowDetailMonthArgs'] months: Months during the year when maintenance should be performed.
        :param str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param str preference: The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        GetAutonomousContainerDatabaseMaintenanceWindowDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: int,
             days_of_weeks: Sequence['outputs.GetAutonomousContainerDatabaseMaintenanceWindowDetailDaysOfWeekResult'],
             hours_of_days: Sequence[int],
             is_custom_action_timeout_enabled: bool,
             is_monthly_patching_enabled: bool,
             lead_time_in_weeks: int,
             months: Sequence['outputs.GetAutonomousContainerDatabaseMaintenanceWindowDetailMonthResult'],
             patching_mode: str,
             preference: str,
             weeks_of_months: Sequence[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        _setter("days_of_weeks", days_of_weeks)
        _setter("hours_of_days", hours_of_days)
        _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        _setter("lead_time_in_weeks", lead_time_in_weeks)
        _setter("months", months)
        _setter("patching_mode", patching_mode)
        _setter("preference", preference)
        _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetAutonomousContainerDatabaseMaintenanceWindowDetailDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetAutonomousContainerDatabaseMaintenanceWindowDetailMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetAutonomousContainerDatabaseMaintenanceWindowDetailDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetAutonomousContainerDatabaseMaintenanceWindowDetailDaysOfWeekResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousContainerDatabaseMaintenanceWindowDetailMonthResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetAutonomousContainerDatabaseMaintenanceWindowDetailMonthResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousContainerDatabaseMaintenanceWindowMonthResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetAutonomousContainerDatabaseMaintenanceWindowMonthResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigResult(dict):
    def __init__(__self__, *,
                 backup_destination_details: Sequence['outputs.GetAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult'],
                 recovery_window_in_days: int):
        """
        :param Sequence['GetAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs'] backup_destination_details: Backup destination details.
        :param int recovery_window_in_days: Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        GetAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backup_destination_details=backup_destination_details,
            recovery_window_in_days=recovery_window_in_days,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backup_destination_details: Sequence['outputs.GetAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult'],
             recovery_window_in_days: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("backup_destination_details", backup_destination_details)
        _setter("recovery_window_in_days", recovery_window_in_days)

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Sequence['outputs.GetAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult']:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> int:
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")


@pulumi.output_type
class GetAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult(dict):
    def __init__(__self__, *,
                 id: str,
                 internet_proxy: str,
                 type: str,
                 vpc_password: str,
                 vpc_user: str):
        """
        :param str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param str internet_proxy: Proxy URL to connect to object store.
        :param str type: Type of the database backup destination.
        :param str vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param str vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        GetAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            internet_proxy=internet_proxy,
            type=type,
            vpc_password=vpc_password,
            vpc_user=vpc_user,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             internet_proxy: str,
             type: str,
             vpc_password: str,
             vpc_user: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("internet_proxy", internet_proxy)
        _setter("type", type)
        _setter("vpc_password", vpc_password)
        _setter("vpc_user", vpc_user)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> str:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> str:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> str:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class GetAutonomousContainerDatabaseResourceUsageAutonomousContainerDatabaseVmUsageResult(dict):
    def __init__(__self__, *,
                 display_name: str,
                 id: str,
                 provisioned_cpus: float,
                 reclaimable_cpus: float,
                 reserved_cpus: float,
                 used_cpus: float):
        """
        :param str display_name: The user-friendly name for the Autonomous Container Database. The name does not need to be unique.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Container Database.
        :param float provisioned_cpus: CPUs / cores assigned to ADBs in the Autonomous Container Database.
        :param float reclaimable_cpus: CPUs / cores reclaimable or released to cluster on Autonomous Container Database restart.
        :param float reserved_cpus: CPUs / cores reserved for scalability, resilliency and other overheads. This includes failover, autoscaling and idle instance overhead.
        :param float used_cpus: CPUs / cores assigned to the Autonomous Container Database. Sum of provisioned, reserved and reclaimable CPUs/ cores.
        """
        GetAutonomousContainerDatabaseResourceUsageAutonomousContainerDatabaseVmUsageResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            id=id,
            provisioned_cpus=provisioned_cpus,
            reclaimable_cpus=reclaimable_cpus,
            reserved_cpus=reserved_cpus,
            used_cpus=used_cpus,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: str,
             id: str,
             provisioned_cpus: float,
             reclaimable_cpus: float,
             reserved_cpus: float,
             used_cpus: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("display_name", display_name)
        _setter("id", id)
        _setter("provisioned_cpus", provisioned_cpus)
        _setter("reclaimable_cpus", reclaimable_cpus)
        _setter("reserved_cpus", reserved_cpus)
        _setter("used_cpus", used_cpus)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The user-friendly name for the Autonomous Container Database. The name does not need to be unique.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Container Database.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="provisionedCpus")
    def provisioned_cpus(self) -> float:
        """
        CPUs / cores assigned to ADBs in the Autonomous Container Database.
        """
        return pulumi.get(self, "provisioned_cpus")

    @property
    @pulumi.getter(name="reclaimableCpus")
    def reclaimable_cpus(self) -> float:
        """
        CPUs / cores reclaimable or released to cluster on Autonomous Container Database restart.
        """
        return pulumi.get(self, "reclaimable_cpus")

    @property
    @pulumi.getter(name="reservedCpus")
    def reserved_cpus(self) -> float:
        """
        CPUs / cores reserved for scalability, resilliency and other overheads. This includes failover, autoscaling and idle instance overhead.
        """
        return pulumi.get(self, "reserved_cpus")

    @property
    @pulumi.getter(name="usedCpus")
    def used_cpus(self) -> float:
        """
        CPUs / cores assigned to the Autonomous Container Database. Sum of provisioned, reserved and reclaimable CPUs/ cores.
        """
        return pulumi.get(self, "used_cpus")


@pulumi.output_type
class GetAutonomousContainerDatabaseVersionsAutonomousContainerDatabaseVersionResult(dict):
    def __init__(__self__, *,
                 details: str,
                 supported_apps: Sequence['outputs.GetAutonomousContainerDatabaseVersionsAutonomousContainerDatabaseVersionSupportedAppResult'],
                 version: str):
        """
        :param str details: A URL that points to a detailed description of the Autonomous Container Database version.
        :param Sequence['GetAutonomousContainerDatabaseVersionsAutonomousContainerDatabaseVersionSupportedAppArgs'] supported_apps: The list of applications supported for the given version.
        :param str version: A valid Oracle Database version for provisioning an Autonomous Container Database.
        """
        GetAutonomousContainerDatabaseVersionsAutonomousContainerDatabaseVersionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            details=details,
            supported_apps=supported_apps,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             details: str,
             supported_apps: Sequence['outputs.GetAutonomousContainerDatabaseVersionsAutonomousContainerDatabaseVersionSupportedAppResult'],
             version: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("details", details)
        _setter("supported_apps", supported_apps)
        _setter("version", version)

    @property
    @pulumi.getter
    def details(self) -> str:
        """
        A URL that points to a detailed description of the Autonomous Container Database version.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter(name="supportedApps")
    def supported_apps(self) -> Sequence['outputs.GetAutonomousContainerDatabaseVersionsAutonomousContainerDatabaseVersionSupportedAppResult']:
        """
        The list of applications supported for the given version.
        """
        return pulumi.get(self, "supported_apps")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        A valid Oracle Database version for provisioning an Autonomous Container Database.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetAutonomousContainerDatabaseVersionsAutonomousContainerDatabaseVersionSupportedAppResult(dict):
    def __init__(__self__, *,
                 end_of_support: str,
                 is_certified: bool,
                 release_date: str,
                 supported_app_name: str):
        """
        :param str end_of_support: The Autonomous Container Database version end of support date.
        :param bool is_certified: Indicates if the image is certified.
        :param str release_date: The Autonomous Container Database version release date.
        :param str supported_app_name: The name of the supported application.
        """
        GetAutonomousContainerDatabaseVersionsAutonomousContainerDatabaseVersionSupportedAppResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end_of_support=end_of_support,
            is_certified=is_certified,
            release_date=release_date,
            supported_app_name=supported_app_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end_of_support: str,
             is_certified: bool,
             release_date: str,
             supported_app_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("end_of_support", end_of_support)
        _setter("is_certified", is_certified)
        _setter("release_date", release_date)
        _setter("supported_app_name", supported_app_name)

    @property
    @pulumi.getter(name="endOfSupport")
    def end_of_support(self) -> str:
        """
        The Autonomous Container Database version end of support date.
        """
        return pulumi.get(self, "end_of_support")

    @property
    @pulumi.getter(name="isCertified")
    def is_certified(self) -> bool:
        """
        Indicates if the image is certified.
        """
        return pulumi.get(self, "is_certified")

    @property
    @pulumi.getter(name="releaseDate")
    def release_date(self) -> str:
        """
        The Autonomous Container Database version release date.
        """
        return pulumi.get(self, "release_date")

    @property
    @pulumi.getter(name="supportedAppName")
    def supported_app_name(self) -> str:
        """
        The name of the supported application.
        """
        return pulumi.get(self, "supported_app_name")


@pulumi.output_type
class GetAutonomousContainerDatabaseVersionsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetAutonomousContainerDatabaseVersionsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousContainerDatabasesAutonomousContainerDatabaseResult(dict):
    def __init__(__self__, *,
                 autonomous_exadata_infrastructure_id: str,
                 autonomous_vm_cluster_id: str,
                 availability_domain: str,
                 available_cpus: float,
                 backup_configs: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseBackupConfigResult'],
                 cloud_autonomous_vm_cluster_id: str,
                 compartment_id: str,
                 compute_model: str,
                 db_name: str,
                 db_unique_name: str,
                 db_version: str,
                 defined_tags: Mapping[str, Any],
                 display_name: str,
                 fast_start_fail_over_lag_limit_in_seconds: int,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 infrastructure_type: str,
                 is_automatic_failover_enabled: bool,
                 key_history_entries: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseKeyHistoryEntryResult'],
                 key_store_id: str,
                 key_store_wallet_name: str,
                 kms_key_id: str,
                 largest_provisionable_autonomous_database_in_cpus: float,
                 last_maintenance_run_id: str,
                 lifecycle_details: str,
                 maintenance_window_details: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailResult'],
                 maintenance_windows: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowResult'],
                 memory_per_oracle_compute_unit_in_gbs: int,
                 next_maintenance_run_id: str,
                 patch_id: str,
                 patch_model: str,
                 peer_autonomous_container_database_backup_configs: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigResult'],
                 peer_autonomous_container_database_compartment_id: str,
                 peer_autonomous_container_database_display_name: str,
                 peer_autonomous_exadata_infrastructure_id: str,
                 peer_autonomous_vm_cluster_id: str,
                 peer_cloud_autonomous_vm_cluster_id: str,
                 peer_db_unique_name: str,
                 protection_mode: str,
                 provisionable_cpuses: Sequence[float],
                 provisioned_cpus: float,
                 reclaimable_cpus: float,
                 reserved_cpus: float,
                 role: str,
                 rotate_key_trigger: bool,
                 service_level_agreement_type: str,
                 standby_maintenance_buffer_in_days: int,
                 state: str,
                 time_created: str,
                 time_snapshot_standby_revert: str,
                 total_cpus: int,
                 vault_id: str,
                 version_preference: str):
        """
        :param str autonomous_exadata_infrastructure_id: The Autonomous Exadata Infrastructure [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param str autonomous_vm_cluster_id: The Autonomous VM Cluster [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param str availability_domain: A filter to return only resources that match the given availability domain exactly.
        :param float available_cpus: Sum of CPUs available on the Autonomous VM Cluster + Sum of reclaimable CPUs available in the Autonomous Container Database.<br> For Autonomous Databases on Dedicated Exadata Infrastructure, the CPU type (OCPUs or ECPUs) is determined by the parent Autonomous Exadata VM Cluster's compute model. See [Compute Models in Autonomous Database on Dedicated Exadata Infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/dedicated/adbak) for more details.
        :param Sequence['GetAutonomousContainerDatabasesAutonomousContainerDatabaseBackupConfigArgs'] backup_configs: Backup options for the Autonomous Container Database.
        :param str cloud_autonomous_vm_cluster_id: The cloud Autonomous VM Cluster [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param str compute_model: The compute model of the Autonomous VM Cluster.
        :param str db_name: The Database name for the Autonomous Container Database. The name must be unique within the Cloud Autonomous VM Cluster, starting with an alphabetic character, followed by 1 to 7 alphanumeric characters.
        :param str db_version: Oracle Database version of the Autonomous Container Database.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param str infrastructure_type: A filter to return only resources that match the given Infrastructure Type.
        :param Sequence['GetAutonomousContainerDatabasesAutonomousContainerDatabaseKeyHistoryEntryArgs'] key_history_entries: Key History Entry.
        :param str key_store_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        :param str key_store_wallet_name: The wallet name for Oracle Key Vault.
        :param str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param float largest_provisionable_autonomous_database_in_cpus: The largest Autonomous Database (CPU) that can be created in a new Autonomous Container Database.
        :param str last_maintenance_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance run.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param Sequence['GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowArgs'] maintenance_windows: The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        :param int memory_per_oracle_compute_unit_in_gbs: The amount of memory (in GBs) enabled per OCPU or ECPU in the Autonomous VM Cluster.
        :param str next_maintenance_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the next maintenance run.
        :param str patch_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last patch applied on the system.
        :param str patch_model: Database patch model preference.
        :param Sequence[float] provisionable_cpuses: An array of CPU values that can be used to successfully provision a single Autonomous Database.\\ For Autonomous Database on Dedicated Exadata Infrastructure, the CPU type (OCPUs or ECPUs) is determined by the parent Autonomous Exadata VM Cluster's compute model.
        :param float provisioned_cpus: The number of CPUs provisioned in an Autonomous Container Database.
        :param float reclaimable_cpus: For Autonomous Databases on Dedicated Exadata Infrastructure:
               * These are the CPUs that continue to be included in the count of CPUs available to the Autonomous Container Database even after one of its Autonomous Database is terminated or scaled down. You can release them to the available CPUs at its parent Autonomous VM Cluster level by restarting the Autonomous Container Database.
               * The CPU type (OCPUs or ECPUs) is determined by the parent Autonomous Exadata VM Cluster's compute model.
        :param float reserved_cpus: The number of CPUs reserved in an Autonomous Container Database.
        :param str role: The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        :param str service_level_agreement_type: A filter to return only resources that match the given service level agreement type exactly.
        :param int standby_maintenance_buffer_in_days: The scheduling detail for the quarterly maintenance window of the standby Autonomous Container Database. This value represents the number of days before scheduled maintenance of the primary database.
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        :param str time_created: The date and time the Autonomous Container Database was created.
        :param str time_snapshot_standby_revert: The date and time the Autonomous Container Database will be reverted to Standby from Snapshot Standby.
        :param int total_cpus: The number of CPUs allocated to the Autonomous VM cluster.<br> For Autonomous Databases on Dedicated Exadata Infrastructure, the CPU type (OCPUs or ECPUs) is determined by the parent Autonomous Exadata VM Cluster's compute model.
        :param str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        :param str version_preference: The next maintenance version preference.
        """
        GetAutonomousContainerDatabasesAutonomousContainerDatabaseResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autonomous_exadata_infrastructure_id=autonomous_exadata_infrastructure_id,
            autonomous_vm_cluster_id=autonomous_vm_cluster_id,
            availability_domain=availability_domain,
            available_cpus=available_cpus,
            backup_configs=backup_configs,
            cloud_autonomous_vm_cluster_id=cloud_autonomous_vm_cluster_id,
            compartment_id=compartment_id,
            compute_model=compute_model,
            db_name=db_name,
            db_unique_name=db_unique_name,
            db_version=db_version,
            defined_tags=defined_tags,
            display_name=display_name,
            fast_start_fail_over_lag_limit_in_seconds=fast_start_fail_over_lag_limit_in_seconds,
            freeform_tags=freeform_tags,
            id=id,
            infrastructure_type=infrastructure_type,
            is_automatic_failover_enabled=is_automatic_failover_enabled,
            key_history_entries=key_history_entries,
            key_store_id=key_store_id,
            key_store_wallet_name=key_store_wallet_name,
            kms_key_id=kms_key_id,
            largest_provisionable_autonomous_database_in_cpus=largest_provisionable_autonomous_database_in_cpus,
            last_maintenance_run_id=last_maintenance_run_id,
            lifecycle_details=lifecycle_details,
            maintenance_window_details=maintenance_window_details,
            maintenance_windows=maintenance_windows,
            memory_per_oracle_compute_unit_in_gbs=memory_per_oracle_compute_unit_in_gbs,
            next_maintenance_run_id=next_maintenance_run_id,
            patch_id=patch_id,
            patch_model=patch_model,
            peer_autonomous_container_database_backup_configs=peer_autonomous_container_database_backup_configs,
            peer_autonomous_container_database_compartment_id=peer_autonomous_container_database_compartment_id,
            peer_autonomous_container_database_display_name=peer_autonomous_container_database_display_name,
            peer_autonomous_exadata_infrastructure_id=peer_autonomous_exadata_infrastructure_id,
            peer_autonomous_vm_cluster_id=peer_autonomous_vm_cluster_id,
            peer_cloud_autonomous_vm_cluster_id=peer_cloud_autonomous_vm_cluster_id,
            peer_db_unique_name=peer_db_unique_name,
            protection_mode=protection_mode,
            provisionable_cpuses=provisionable_cpuses,
            provisioned_cpus=provisioned_cpus,
            reclaimable_cpus=reclaimable_cpus,
            reserved_cpus=reserved_cpus,
            role=role,
            rotate_key_trigger=rotate_key_trigger,
            service_level_agreement_type=service_level_agreement_type,
            standby_maintenance_buffer_in_days=standby_maintenance_buffer_in_days,
            state=state,
            time_created=time_created,
            time_snapshot_standby_revert=time_snapshot_standby_revert,
            total_cpus=total_cpus,
            vault_id=vault_id,
            version_preference=version_preference,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autonomous_exadata_infrastructure_id: str,
             autonomous_vm_cluster_id: str,
             availability_domain: str,
             available_cpus: float,
             backup_configs: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseBackupConfigResult'],
             cloud_autonomous_vm_cluster_id: str,
             compartment_id: str,
             compute_model: str,
             db_name: str,
             db_unique_name: str,
             db_version: str,
             defined_tags: Mapping[str, Any],
             display_name: str,
             fast_start_fail_over_lag_limit_in_seconds: int,
             freeform_tags: Mapping[str, Any],
             id: str,
             infrastructure_type: str,
             is_automatic_failover_enabled: bool,
             key_history_entries: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseKeyHistoryEntryResult'],
             key_store_id: str,
             key_store_wallet_name: str,
             kms_key_id: str,
             largest_provisionable_autonomous_database_in_cpus: float,
             last_maintenance_run_id: str,
             lifecycle_details: str,
             maintenance_window_details: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailResult'],
             maintenance_windows: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowResult'],
             memory_per_oracle_compute_unit_in_gbs: int,
             next_maintenance_run_id: str,
             patch_id: str,
             patch_model: str,
             peer_autonomous_container_database_backup_configs: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigResult'],
             peer_autonomous_container_database_compartment_id: str,
             peer_autonomous_container_database_display_name: str,
             peer_autonomous_exadata_infrastructure_id: str,
             peer_autonomous_vm_cluster_id: str,
             peer_cloud_autonomous_vm_cluster_id: str,
             peer_db_unique_name: str,
             protection_mode: str,
             provisionable_cpuses: Sequence[float],
             provisioned_cpus: float,
             reclaimable_cpus: float,
             reserved_cpus: float,
             role: str,
             rotate_key_trigger: bool,
             service_level_agreement_type: str,
             standby_maintenance_buffer_in_days: int,
             state: str,
             time_created: str,
             time_snapshot_standby_revert: str,
             total_cpus: int,
             vault_id: str,
             version_preference: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("autonomous_exadata_infrastructure_id", autonomous_exadata_infrastructure_id)
        _setter("autonomous_vm_cluster_id", autonomous_vm_cluster_id)
        _setter("availability_domain", availability_domain)
        _setter("available_cpus", available_cpus)
        _setter("backup_configs", backup_configs)
        _setter("cloud_autonomous_vm_cluster_id", cloud_autonomous_vm_cluster_id)
        _setter("compartment_id", compartment_id)
        _setter("compute_model", compute_model)
        _setter("db_name", db_name)
        _setter("db_unique_name", db_unique_name)
        _setter("db_version", db_version)
        _setter("defined_tags", defined_tags)
        _setter("display_name", display_name)
        _setter("fast_start_fail_over_lag_limit_in_seconds", fast_start_fail_over_lag_limit_in_seconds)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("infrastructure_type", infrastructure_type)
        _setter("is_automatic_failover_enabled", is_automatic_failover_enabled)
        _setter("key_history_entries", key_history_entries)
        _setter("key_store_id", key_store_id)
        _setter("key_store_wallet_name", key_store_wallet_name)
        _setter("kms_key_id", kms_key_id)
        _setter("largest_provisionable_autonomous_database_in_cpus", largest_provisionable_autonomous_database_in_cpus)
        _setter("last_maintenance_run_id", last_maintenance_run_id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("maintenance_window_details", maintenance_window_details)
        _setter("maintenance_windows", maintenance_windows)
        _setter("memory_per_oracle_compute_unit_in_gbs", memory_per_oracle_compute_unit_in_gbs)
        _setter("next_maintenance_run_id", next_maintenance_run_id)
        _setter("patch_id", patch_id)
        _setter("patch_model", patch_model)
        _setter("peer_autonomous_container_database_backup_configs", peer_autonomous_container_database_backup_configs)
        _setter("peer_autonomous_container_database_compartment_id", peer_autonomous_container_database_compartment_id)
        _setter("peer_autonomous_container_database_display_name", peer_autonomous_container_database_display_name)
        _setter("peer_autonomous_exadata_infrastructure_id", peer_autonomous_exadata_infrastructure_id)
        _setter("peer_autonomous_vm_cluster_id", peer_autonomous_vm_cluster_id)
        _setter("peer_cloud_autonomous_vm_cluster_id", peer_cloud_autonomous_vm_cluster_id)
        _setter("peer_db_unique_name", peer_db_unique_name)
        _setter("protection_mode", protection_mode)
        _setter("provisionable_cpuses", provisionable_cpuses)
        _setter("provisioned_cpus", provisioned_cpus)
        _setter("reclaimable_cpus", reclaimable_cpus)
        _setter("reserved_cpus", reserved_cpus)
        _setter("role", role)
        _setter("rotate_key_trigger", rotate_key_trigger)
        _setter("service_level_agreement_type", service_level_agreement_type)
        _setter("standby_maintenance_buffer_in_days", standby_maintenance_buffer_in_days)
        _setter("state", state)
        _setter("time_created", time_created)
        _setter("time_snapshot_standby_revert", time_snapshot_standby_revert)
        _setter("total_cpus", total_cpus)
        _setter("vault_id", vault_id)
        _setter("version_preference", version_preference)

    @property
    @pulumi.getter(name="autonomousExadataInfrastructureId")
    def autonomous_exadata_infrastructure_id(self) -> str:
        """
        The Autonomous Exadata Infrastructure [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "autonomous_exadata_infrastructure_id")

    @property
    @pulumi.getter(name="autonomousVmClusterId")
    def autonomous_vm_cluster_id(self) -> str:
        """
        The Autonomous VM Cluster [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "autonomous_vm_cluster_id")

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> str:
        """
        A filter to return only resources that match the given availability domain exactly.
        """
        return pulumi.get(self, "availability_domain")

    @property
    @pulumi.getter(name="availableCpus")
    def available_cpus(self) -> float:
        """
        Sum of CPUs available on the Autonomous VM Cluster + Sum of reclaimable CPUs available in the Autonomous Container Database.<br> For Autonomous Databases on Dedicated Exadata Infrastructure, the CPU type (OCPUs or ECPUs) is determined by the parent Autonomous Exadata VM Cluster's compute model. See [Compute Models in Autonomous Database on Dedicated Exadata Infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/dedicated/adbak) for more details.
        """
        return pulumi.get(self, "available_cpus")

    @property
    @pulumi.getter(name="backupConfigs")
    def backup_configs(self) -> Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseBackupConfigResult']:
        """
        Backup options for the Autonomous Container Database.
        """
        return pulumi.get(self, "backup_configs")

    @property
    @pulumi.getter(name="cloudAutonomousVmClusterId")
    def cloud_autonomous_vm_cluster_id(self) -> str:
        """
        The cloud Autonomous VM Cluster [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "cloud_autonomous_vm_cluster_id")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="computeModel")
    def compute_model(self) -> str:
        """
        The compute model of the Autonomous VM Cluster.
        """
        return pulumi.get(self, "compute_model")

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> str:
        """
        The Database name for the Autonomous Container Database. The name must be unique within the Cloud Autonomous VM Cluster, starting with an alphabetic character, followed by 1 to 7 alphanumeric characters.
        """
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> str:
        return pulumi.get(self, "db_unique_name")

    @property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> str:
        """
        Oracle Database version of the Autonomous Container Database.
        """
        return pulumi.get(self, "db_version")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="fastStartFailOverLagLimitInSeconds")
    def fast_start_fail_over_lag_limit_in_seconds(self) -> int:
        return pulumi.get(self, "fast_start_fail_over_lag_limit_in_seconds")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="infrastructureType")
    def infrastructure_type(self) -> str:
        """
        A filter to return only resources that match the given Infrastructure Type.
        """
        return pulumi.get(self, "infrastructure_type")

    @property
    @pulumi.getter(name="isAutomaticFailoverEnabled")
    def is_automatic_failover_enabled(self) -> bool:
        return pulumi.get(self, "is_automatic_failover_enabled")

    @property
    @pulumi.getter(name="keyHistoryEntries")
    def key_history_entries(self) -> Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseKeyHistoryEntryResult']:
        """
        Key History Entry.
        """
        return pulumi.get(self, "key_history_entries")

    @property
    @pulumi.getter(name="keyStoreId")
    def key_store_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        """
        return pulumi.get(self, "key_store_id")

    @property
    @pulumi.getter(name="keyStoreWalletName")
    def key_store_wallet_name(self) -> str:
        """
        The wallet name for Oracle Key Vault.
        """
        return pulumi.get(self, "key_store_wallet_name")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="largestProvisionableAutonomousDatabaseInCpus")
    def largest_provisionable_autonomous_database_in_cpus(self) -> float:
        """
        The largest Autonomous Database (CPU) that can be created in a new Autonomous Container Database.
        """
        return pulumi.get(self, "largest_provisionable_autonomous_database_in_cpus")

    @property
    @pulumi.getter(name="lastMaintenanceRunId")
    def last_maintenance_run_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance run.
        """
        return pulumi.get(self, "last_maintenance_run_id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="maintenanceWindowDetails")
    def maintenance_window_details(self) -> Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailResult']:
        return pulumi.get(self, "maintenance_window_details")

    @property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowResult']:
        """
        The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        """
        return pulumi.get(self, "maintenance_windows")

    @property
    @pulumi.getter(name="memoryPerOracleComputeUnitInGbs")
    def memory_per_oracle_compute_unit_in_gbs(self) -> int:
        """
        The amount of memory (in GBs) enabled per OCPU or ECPU in the Autonomous VM Cluster.
        """
        return pulumi.get(self, "memory_per_oracle_compute_unit_in_gbs")

    @property
    @pulumi.getter(name="nextMaintenanceRunId")
    def next_maintenance_run_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the next maintenance run.
        """
        return pulumi.get(self, "next_maintenance_run_id")

    @property
    @pulumi.getter(name="patchId")
    def patch_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last patch applied on the system.
        """
        return pulumi.get(self, "patch_id")

    @property
    @pulumi.getter(name="patchModel")
    def patch_model(self) -> str:
        """
        Database patch model preference.
        """
        return pulumi.get(self, "patch_model")

    @property
    @pulumi.getter(name="peerAutonomousContainerDatabaseBackupConfigs")
    def peer_autonomous_container_database_backup_configs(self) -> Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigResult']:
        return pulumi.get(self, "peer_autonomous_container_database_backup_configs")

    @property
    @pulumi.getter(name="peerAutonomousContainerDatabaseCompartmentId")
    def peer_autonomous_container_database_compartment_id(self) -> str:
        return pulumi.get(self, "peer_autonomous_container_database_compartment_id")

    @property
    @pulumi.getter(name="peerAutonomousContainerDatabaseDisplayName")
    def peer_autonomous_container_database_display_name(self) -> str:
        return pulumi.get(self, "peer_autonomous_container_database_display_name")

    @property
    @pulumi.getter(name="peerAutonomousExadataInfrastructureId")
    def peer_autonomous_exadata_infrastructure_id(self) -> str:
        return pulumi.get(self, "peer_autonomous_exadata_infrastructure_id")

    @property
    @pulumi.getter(name="peerAutonomousVmClusterId")
    def peer_autonomous_vm_cluster_id(self) -> str:
        return pulumi.get(self, "peer_autonomous_vm_cluster_id")

    @property
    @pulumi.getter(name="peerCloudAutonomousVmClusterId")
    def peer_cloud_autonomous_vm_cluster_id(self) -> str:
        return pulumi.get(self, "peer_cloud_autonomous_vm_cluster_id")

    @property
    @pulumi.getter(name="peerDbUniqueName")
    def peer_db_unique_name(self) -> str:
        return pulumi.get(self, "peer_db_unique_name")

    @property
    @pulumi.getter(name="protectionMode")
    def protection_mode(self) -> str:
        return pulumi.get(self, "protection_mode")

    @property
    @pulumi.getter(name="provisionableCpuses")
    def provisionable_cpuses(self) -> Sequence[float]:
        """
        An array of CPU values that can be used to successfully provision a single Autonomous Database.\\ For Autonomous Database on Dedicated Exadata Infrastructure, the CPU type (OCPUs or ECPUs) is determined by the parent Autonomous Exadata VM Cluster's compute model.
        """
        return pulumi.get(self, "provisionable_cpuses")

    @property
    @pulumi.getter(name="provisionedCpus")
    def provisioned_cpus(self) -> float:
        """
        The number of CPUs provisioned in an Autonomous Container Database.
        """
        return pulumi.get(self, "provisioned_cpus")

    @property
    @pulumi.getter(name="reclaimableCpus")
    def reclaimable_cpus(self) -> float:
        """
        For Autonomous Databases on Dedicated Exadata Infrastructure:
        * These are the CPUs that continue to be included in the count of CPUs available to the Autonomous Container Database even after one of its Autonomous Database is terminated or scaled down. You can release them to the available CPUs at its parent Autonomous VM Cluster level by restarting the Autonomous Container Database.
        * The CPU type (OCPUs or ECPUs) is determined by the parent Autonomous Exadata VM Cluster's compute model.
        """
        return pulumi.get(self, "reclaimable_cpus")

    @property
    @pulumi.getter(name="reservedCpus")
    def reserved_cpus(self) -> float:
        """
        The number of CPUs reserved in an Autonomous Container Database.
        """
        return pulumi.get(self, "reserved_cpus")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter(name="rotateKeyTrigger")
    def rotate_key_trigger(self) -> bool:
        return pulumi.get(self, "rotate_key_trigger")

    @property
    @pulumi.getter(name="serviceLevelAgreementType")
    def service_level_agreement_type(self) -> str:
        """
        A filter to return only resources that match the given service level agreement type exactly.
        """
        return pulumi.get(self, "service_level_agreement_type")

    @property
    @pulumi.getter(name="standbyMaintenanceBufferInDays")
    def standby_maintenance_buffer_in_days(self) -> int:
        """
        The scheduling detail for the quarterly maintenance window of the standby Autonomous Container Database. This value represents the number of days before scheduled maintenance of the primary database.
        """
        return pulumi.get(self, "standby_maintenance_buffer_in_days")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the Autonomous Container Database was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeSnapshotStandbyRevert")
    def time_snapshot_standby_revert(self) -> str:
        """
        The date and time the Autonomous Container Database will be reverted to Standby from Snapshot Standby.
        """
        return pulumi.get(self, "time_snapshot_standby_revert")

    @property
    @pulumi.getter(name="totalCpus")
    def total_cpus(self) -> int:
        """
        The number of CPUs allocated to the Autonomous VM cluster.<br> For Autonomous Databases on Dedicated Exadata Infrastructure, the CPU type (OCPUs or ECPUs) is determined by the parent Autonomous Exadata VM Cluster's compute model.
        """
        return pulumi.get(self, "total_cpus")

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")

    @property
    @pulumi.getter(name="versionPreference")
    def version_preference(self) -> str:
        """
        The next maintenance version preference.
        """
        return pulumi.get(self, "version_preference")


@pulumi.output_type
class GetAutonomousContainerDatabasesAutonomousContainerDatabaseBackupConfigResult(dict):
    def __init__(__self__, *,
                 backup_destination_details: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult'],
                 recovery_window_in_days: int):
        """
        :param Sequence['GetAutonomousContainerDatabasesAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs'] backup_destination_details: Backup destination details.
        :param int recovery_window_in_days: Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        GetAutonomousContainerDatabasesAutonomousContainerDatabaseBackupConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backup_destination_details=backup_destination_details,
            recovery_window_in_days=recovery_window_in_days,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backup_destination_details: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult'],
             recovery_window_in_days: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("backup_destination_details", backup_destination_details)
        _setter("recovery_window_in_days", recovery_window_in_days)

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult']:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> int:
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")


@pulumi.output_type
class GetAutonomousContainerDatabasesAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult(dict):
    def __init__(__self__, *,
                 id: str,
                 internet_proxy: str,
                 type: str,
                 vpc_password: str,
                 vpc_user: str):
        """
        :param str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param str internet_proxy: Proxy URL to connect to object store.
        :param str type: Type of the database backup destination.
        :param str vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param str vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        GetAutonomousContainerDatabasesAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            internet_proxy=internet_proxy,
            type=type,
            vpc_password=vpc_password,
            vpc_user=vpc_user,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             internet_proxy: str,
             type: str,
             vpc_password: str,
             vpc_user: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("internet_proxy", internet_proxy)
        _setter("type", type)
        _setter("vpc_password", vpc_password)
        _setter("vpc_user", vpc_user)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> str:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> str:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> str:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class GetAutonomousContainerDatabasesAutonomousContainerDatabaseKeyHistoryEntryResult(dict):
    def __init__(__self__, *,
                 id: str,
                 kms_key_version_id: str,
                 time_activated: str,
                 vault_id: str):
        """
        :param str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        :param str time_activated: The date and time the kms key activated.
        :param str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        GetAutonomousContainerDatabasesAutonomousContainerDatabaseKeyHistoryEntryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            kms_key_version_id=kms_key_version_id,
            time_activated=time_activated,
            vault_id=vault_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             kms_key_version_id: str,
             time_activated: str,
             vault_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("kms_key_version_id", kms_key_version_id)
        _setter("time_activated", time_activated)
        _setter("vault_id", vault_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> str:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        """
        return pulumi.get(self, "kms_key_version_id")

    @property
    @pulumi.getter(name="timeActivated")
    def time_activated(self) -> str:
        """
        The date and time the kms key activated.
        """
        return pulumi.get(self, "time_activated")

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: int,
                 days_of_weeks: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDaysOfWeekResult'],
                 hours_of_days: Sequence[int],
                 is_custom_action_timeout_enabled: bool,
                 is_monthly_patching_enabled: bool,
                 lead_time_in_weeks: int,
                 months: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowMonthResult'],
                 patching_mode: str,
                 preference: str,
                 weeks_of_months: Sequence[int]):
        """
        :param int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param str preference: The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: int,
             days_of_weeks: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDaysOfWeekResult'],
             hours_of_days: Sequence[int],
             is_custom_action_timeout_enabled: bool,
             is_monthly_patching_enabled: bool,
             lead_time_in_weeks: int,
             months: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowMonthResult'],
             patching_mode: str,
             preference: str,
             weeks_of_months: Sequence[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        _setter("days_of_weeks", days_of_weeks)
        _setter("hours_of_days", hours_of_days)
        _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        _setter("lead_time_in_weeks", lead_time_in_weeks)
        _setter("months", months)
        _setter("patching_mode", patching_mode)
        _setter("preference", preference)
        _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDaysOfWeekResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: int,
                 days_of_weeks: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailDaysOfWeekResult'],
                 hours_of_days: Sequence[int],
                 is_custom_action_timeout_enabled: bool,
                 is_monthly_patching_enabled: bool,
                 lead_time_in_weeks: int,
                 months: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailMonthResult'],
                 patching_mode: str,
                 preference: str,
                 weeks_of_months: Sequence[int]):
        """
        :param int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailMonthArgs'] months: Months during the year when maintenance should be performed.
        :param str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param str preference: The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: int,
             days_of_weeks: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailDaysOfWeekResult'],
             hours_of_days: Sequence[int],
             is_custom_action_timeout_enabled: bool,
             is_monthly_patching_enabled: bool,
             lead_time_in_weeks: int,
             months: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailMonthResult'],
             patching_mode: str,
             preference: str,
             weeks_of_months: Sequence[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        _setter("days_of_weeks", days_of_weeks)
        _setter("hours_of_days", hours_of_days)
        _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        _setter("lead_time_in_weeks", lead_time_in_weeks)
        _setter("months", months)
        _setter("patching_mode", patching_mode)
        _setter("preference", preference)
        _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailDaysOfWeekResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailMonthResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowDetailMonthResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowMonthResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetAutonomousContainerDatabasesAutonomousContainerDatabaseMaintenanceWindowMonthResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousContainerDatabasesAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigResult(dict):
    def __init__(__self__, *,
                 backup_destination_details: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult'],
                 recovery_window_in_days: int):
        """
        :param Sequence['GetAutonomousContainerDatabasesAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs'] backup_destination_details: Backup destination details.
        :param int recovery_window_in_days: Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        GetAutonomousContainerDatabasesAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backup_destination_details=backup_destination_details,
            recovery_window_in_days=recovery_window_in_days,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backup_destination_details: Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult'],
             recovery_window_in_days: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("backup_destination_details", backup_destination_details)
        _setter("recovery_window_in_days", recovery_window_in_days)

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Sequence['outputs.GetAutonomousContainerDatabasesAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult']:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> int:
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")


@pulumi.output_type
class GetAutonomousContainerDatabasesAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult(dict):
    def __init__(__self__, *,
                 id: str,
                 internet_proxy: str,
                 type: str,
                 vpc_password: str,
                 vpc_user: str):
        """
        :param str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param str internet_proxy: Proxy URL to connect to object store.
        :param str type: Type of the database backup destination.
        :param str vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param str vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        GetAutonomousContainerDatabasesAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            internet_proxy=internet_proxy,
            type=type,
            vpc_password=vpc_password,
            vpc_user=vpc_user,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             internet_proxy: str,
             type: str,
             vpc_password: str,
             vpc_user: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("internet_proxy", internet_proxy)
        _setter("type", type)
        _setter("vpc_password", vpc_password)
        _setter("vpc_user", vpc_user)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> str:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> str:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> str:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class GetAutonomousContainerDatabasesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the month of the year.
        """
        GetAutonomousContainerDatabasesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousContainerPatchesAutonomousPatchResult(dict):
    def __init__(__self__, *,
                 description: str,
                 id: str,
                 lifecycle_details: str,
                 patch_model: str,
                 quarter: str,
                 state: str,
                 time_released: str,
                 type: str,
                 version: str,
                 year: str):
        """
        :param str description: The text describing this patch package.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch.
        :param str lifecycle_details: A descriptive text associated with the lifecycleState. Typically can contain additional displayable text.
        :param str patch_model: Database patching model preference. See [My Oracle Support note 2285040.1](https://support.oracle.com/rs?type=doc&id=2285040.1) for information on the Release Update (RU) and Release Update Revision (RUR) patching models.
        :param str quarter: First month of the quarter in which the patch was released.
        :param str state: The current state of the patch as a result of lastAction.
        :param str time_released: The date and time that the patch was released.
        :param str type: The type of patch. BUNDLE is one example.
        :param str version: The version of this patch package.
        :param str year: Year in which the patch was released.
        """
        GetAutonomousContainerPatchesAutonomousPatchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            id=id,
            lifecycle_details=lifecycle_details,
            patch_model=patch_model,
            quarter=quarter,
            state=state,
            time_released=time_released,
            type=type,
            version=version,
            year=year,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: str,
             id: str,
             lifecycle_details: str,
             patch_model: str,
             quarter: str,
             state: str,
             time_released: str,
             type: str,
             version: str,
             year: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("description", description)
        _setter("id", id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("patch_model", patch_model)
        _setter("quarter", quarter)
        _setter("state", state)
        _setter("time_released", time_released)
        _setter("type", type)
        _setter("version", version)
        _setter("year", year)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The text describing this patch package.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A descriptive text associated with the lifecycleState. Typically can contain additional displayable text.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="patchModel")
    def patch_model(self) -> str:
        """
        Database patching model preference. See [My Oracle Support note 2285040.1](https://support.oracle.com/rs?type=doc&id=2285040.1) for information on the Release Update (RU) and Release Update Revision (RUR) patching models.
        """
        return pulumi.get(self, "patch_model")

    @property
    @pulumi.getter
    def quarter(self) -> str:
        """
        First month of the quarter in which the patch was released.
        """
        return pulumi.get(self, "quarter")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the patch as a result of lastAction.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeReleased")
    def time_released(self) -> str:
        """
        The date and time that the patch was released.
        """
        return pulumi.get(self, "time_released")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of patch. BUNDLE is one example.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The version of this patch package.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter
    def year(self) -> str:
        """
        Year in which the patch was released.
        """
        return pulumi.get(self, "year")


@pulumi.output_type
class GetAutonomousContainerPatchesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetAutonomousContainerPatchesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousDatabaseApexDetailResult(dict):
    def __init__(__self__, *,
                 apex_version: str,
                 ords_version: str):
        """
        :param str apex_version: The Oracle APEX Application Development version.
        :param str ords_version: The Oracle REST Data Services (ORDS) version.
        """
        GetAutonomousDatabaseApexDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apex_version=apex_version,
            ords_version=ords_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apex_version: str,
             ords_version: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("apex_version", apex_version)
        _setter("ords_version", ords_version)

    @property
    @pulumi.getter(name="apexVersion")
    def apex_version(self) -> str:
        """
        The Oracle APEX Application Development version.
        """
        return pulumi.get(self, "apex_version")

    @property
    @pulumi.getter(name="ordsVersion")
    def ords_version(self) -> str:
        """
        The Oracle REST Data Services (ORDS) version.
        """
        return pulumi.get(self, "ords_version")


@pulumi.output_type
class GetAutonomousDatabaseBackupBackupDestinationDetailResult(dict):
    def __init__(__self__, *,
                 id: str,
                 internet_proxy: str,
                 type: str,
                 vpc_password: str,
                 vpc_user: str):
        """
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database backup.
        :param str internet_proxy: Proxy URL to connect to object store.
        :param str type: The type of backup.
        :param str vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param str vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        GetAutonomousDatabaseBackupBackupDestinationDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            internet_proxy=internet_proxy,
            type=type,
            vpc_password=vpc_password,
            vpc_user=vpc_user,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             internet_proxy: str,
             type: str,
             vpc_password: str,
             vpc_user: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("internet_proxy", internet_proxy)
        _setter("type", type)
        _setter("vpc_password", vpc_password)
        _setter("vpc_user", vpc_user)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database backup.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> str:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of backup.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> str:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> str:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class GetAutonomousDatabaseBackupConfigResult(dict):
    def __init__(__self__, *,
                 manual_backup_bucket_name: str,
                 manual_backup_type: str):
        """
        :param str manual_backup_bucket_name: Name of [Object Storage](https://docs.cloud.oracle.com/iaas/Content/Object/Concepts/objectstorageoverview.htm) bucket to use for storing manual backups.
        :param str manual_backup_type: The manual backup destination type.
        """
        GetAutonomousDatabaseBackupConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            manual_backup_bucket_name=manual_backup_bucket_name,
            manual_backup_type=manual_backup_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             manual_backup_bucket_name: str,
             manual_backup_type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("manual_backup_bucket_name", manual_backup_bucket_name)
        _setter("manual_backup_type", manual_backup_type)

    @property
    @pulumi.getter(name="manualBackupBucketName")
    def manual_backup_bucket_name(self) -> str:
        """
        Name of [Object Storage](https://docs.cloud.oracle.com/iaas/Content/Object/Concepts/objectstorageoverview.htm) bucket to use for storing manual backups.
        """
        return pulumi.get(self, "manual_backup_bucket_name")

    @property
    @pulumi.getter(name="manualBackupType")
    def manual_backup_type(self) -> str:
        """
        The manual backup destination type.
        """
        return pulumi.get(self, "manual_backup_type")


@pulumi.output_type
class GetAutonomousDatabaseBackupsAutonomousDatabaseBackupResult(dict):
    def __init__(__self__, *,
                 autonomous_database_id: str,
                 backup_destination_details: Sequence['outputs.GetAutonomousDatabaseBackupsAutonomousDatabaseBackupBackupDestinationDetailResult'],
                 compartment_id: str,
                 database_size_in_tbs: float,
                 db_version: str,
                 display_name: str,
                 id: str,
                 is_automatic: bool,
                 is_long_term_backup: bool,
                 is_restorable: bool,
                 key_store_id: str,
                 key_store_wallet_name: str,
                 kms_key_id: str,
                 kms_key_version_id: str,
                 lifecycle_details: str,
                 retention_period_in_days: int,
                 size_in_tbs: float,
                 state: str,
                 time_available_till: str,
                 time_ended: str,
                 time_started: str,
                 type: str,
                 vault_id: str):
        """
        :param str autonomous_database_id: The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Sequence['GetAutonomousDatabaseBackupsAutonomousDatabaseBackupBackupDestinationDetailArgs'] backup_destination_details: Backup destination details
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param float database_size_in_tbs: The size of the database in terabytes at the time the backup was taken.
        :param str db_version: A valid Oracle Database version for Autonomous Database.
        :param str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database backup.
        :param bool is_automatic: Indicates whether the backup is user-initiated or automatic.
        :param bool is_restorable: Indicates whether the backup can be used to restore the associated Autonomous Database.
        :param str key_store_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        :param str key_store_wallet_name: The wallet name for Oracle Key Vault.
        :param str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param int retention_period_in_days: Retention period, in days, for long-term backups
        :param float size_in_tbs: The backup size in terrabytes (TB).
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        :param str time_available_till: Timestamp until when the backup will be available
        :param str time_ended: The date and time the backup completed.
        :param str time_started: The date and time the backup started.
        :param str type: A filter to return only backups that matches with the given type of Backup.
        :param str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        GetAutonomousDatabaseBackupsAutonomousDatabaseBackupResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autonomous_database_id=autonomous_database_id,
            backup_destination_details=backup_destination_details,
            compartment_id=compartment_id,
            database_size_in_tbs=database_size_in_tbs,
            db_version=db_version,
            display_name=display_name,
            id=id,
            is_automatic=is_automatic,
            is_long_term_backup=is_long_term_backup,
            is_restorable=is_restorable,
            key_store_id=key_store_id,
            key_store_wallet_name=key_store_wallet_name,
            kms_key_id=kms_key_id,
            kms_key_version_id=kms_key_version_id,
            lifecycle_details=lifecycle_details,
            retention_period_in_days=retention_period_in_days,
            size_in_tbs=size_in_tbs,
            state=state,
            time_available_till=time_available_till,
            time_ended=time_ended,
            time_started=time_started,
            type=type,
            vault_id=vault_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autonomous_database_id: str,
             backup_destination_details: Sequence['outputs.GetAutonomousDatabaseBackupsAutonomousDatabaseBackupBackupDestinationDetailResult'],
             compartment_id: str,
             database_size_in_tbs: float,
             db_version: str,
             display_name: str,
             id: str,
             is_automatic: bool,
             is_long_term_backup: bool,
             is_restorable: bool,
             key_store_id: str,
             key_store_wallet_name: str,
             kms_key_id: str,
             kms_key_version_id: str,
             lifecycle_details: str,
             retention_period_in_days: int,
             size_in_tbs: float,
             state: str,
             time_available_till: str,
             time_ended: str,
             time_started: str,
             type: str,
             vault_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("autonomous_database_id", autonomous_database_id)
        _setter("backup_destination_details", backup_destination_details)
        _setter("compartment_id", compartment_id)
        _setter("database_size_in_tbs", database_size_in_tbs)
        _setter("db_version", db_version)
        _setter("display_name", display_name)
        _setter("id", id)
        _setter("is_automatic", is_automatic)
        _setter("is_long_term_backup", is_long_term_backup)
        _setter("is_restorable", is_restorable)
        _setter("key_store_id", key_store_id)
        _setter("key_store_wallet_name", key_store_wallet_name)
        _setter("kms_key_id", kms_key_id)
        _setter("kms_key_version_id", kms_key_version_id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("retention_period_in_days", retention_period_in_days)
        _setter("size_in_tbs", size_in_tbs)
        _setter("state", state)
        _setter("time_available_till", time_available_till)
        _setter("time_ended", time_ended)
        _setter("time_started", time_started)
        _setter("type", type)
        _setter("vault_id", vault_id)

    @property
    @pulumi.getter(name="autonomousDatabaseId")
    def autonomous_database_id(self) -> str:
        """
        The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "autonomous_database_id")

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Sequence['outputs.GetAutonomousDatabaseBackupsAutonomousDatabaseBackupBackupDestinationDetailResult']:
        """
        Backup destination details
        """
        return pulumi.get(self, "backup_destination_details")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="databaseSizeInTbs")
    def database_size_in_tbs(self) -> float:
        """
        The size of the database in terabytes at the time the backup was taken.
        """
        return pulumi.get(self, "database_size_in_tbs")

    @property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> str:
        """
        A valid Oracle Database version for Autonomous Database.
        """
        return pulumi.get(self, "db_version")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database backup.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isAutomatic")
    def is_automatic(self) -> bool:
        """
        Indicates whether the backup is user-initiated or automatic.
        """
        return pulumi.get(self, "is_automatic")

    @property
    @pulumi.getter(name="isLongTermBackup")
    def is_long_term_backup(self) -> bool:
        return pulumi.get(self, "is_long_term_backup")

    @property
    @pulumi.getter(name="isRestorable")
    def is_restorable(self) -> bool:
        """
        Indicates whether the backup can be used to restore the associated Autonomous Database.
        """
        return pulumi.get(self, "is_restorable")

    @property
    @pulumi.getter(name="keyStoreId")
    def key_store_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        """
        return pulumi.get(self, "key_store_id")

    @property
    @pulumi.getter(name="keyStoreWalletName")
    def key_store_wallet_name(self) -> str:
        """
        The wallet name for Oracle Key Vault.
        """
        return pulumi.get(self, "key_store_wallet_name")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> str:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        """
        return pulumi.get(self, "kms_key_version_id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="retentionPeriodInDays")
    def retention_period_in_days(self) -> int:
        """
        Retention period, in days, for long-term backups
        """
        return pulumi.get(self, "retention_period_in_days")

    @property
    @pulumi.getter(name="sizeInTbs")
    def size_in_tbs(self) -> float:
        """
        The backup size in terrabytes (TB).
        """
        return pulumi.get(self, "size_in_tbs")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeAvailableTill")
    def time_available_till(self) -> str:
        """
        Timestamp until when the backup will be available
        """
        return pulumi.get(self, "time_available_till")

    @property
    @pulumi.getter(name="timeEnded")
    def time_ended(self) -> str:
        """
        The date and time the backup completed.
        """
        return pulumi.get(self, "time_ended")

    @property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> str:
        """
        The date and time the backup started.
        """
        return pulumi.get(self, "time_started")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        A filter to return only backups that matches with the given type of Backup.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class GetAutonomousDatabaseBackupsAutonomousDatabaseBackupBackupDestinationDetailResult(dict):
    def __init__(__self__, *,
                 id: str,
                 internet_proxy: str,
                 type: str,
                 vpc_password: str,
                 vpc_user: str):
        """
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database backup.
        :param str internet_proxy: Proxy URL to connect to object store.
        :param str type: A filter to return only backups that matches with the given type of Backup.
        :param str vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param str vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        GetAutonomousDatabaseBackupsAutonomousDatabaseBackupBackupDestinationDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            internet_proxy=internet_proxy,
            type=type,
            vpc_password=vpc_password,
            vpc_user=vpc_user,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             internet_proxy: str,
             type: str,
             vpc_password: str,
             vpc_user: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("internet_proxy", internet_proxy)
        _setter("type", type)
        _setter("vpc_password", vpc_password)
        _setter("vpc_user", vpc_user)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database backup.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> str:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        A filter to return only backups that matches with the given type of Backup.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> str:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> str:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class GetAutonomousDatabaseBackupsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetAutonomousDatabaseBackupsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousDatabaseConnectionStringResult(dict):
    def __init__(__self__, *,
                 all_connection_strings: Mapping[str, Any],
                 dedicated: str,
                 high: str,
                 low: str,
                 medium: str,
                 profiles: Sequence['outputs.GetAutonomousDatabaseConnectionStringProfileResult']):
        """
        :param Mapping[str, Any] all_connection_strings: Returns all connection strings that can be used to connect to the Autonomous Database. For more information, please see [Predefined Database Service Names for Autonomous Transaction Processing](https://docs.oracle.com/en/cloud/paas/atp-cloud/atpug/connect-predefined.html#GUID-9747539B-FD46-44F1-8FF8-F5AC650F15BE)
        :param str dedicated: The database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        :param str high: The High database service provides the highest level of resources to each SQL statement resulting in the highest performance, but supports the fewest number of concurrent SQL statements.
        :param str low: The Low database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        :param str medium: The Medium database service provides a lower level of resources to each SQL statement potentially resulting a lower level of performance, but supports more concurrent SQL statements.
        :param Sequence['GetAutonomousDatabaseConnectionStringProfileArgs'] profiles: A list of connection string profiles to allow clients to group, filter and select connection string values based on structured metadata.
        """
        GetAutonomousDatabaseConnectionStringResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_connection_strings=all_connection_strings,
            dedicated=dedicated,
            high=high,
            low=low,
            medium=medium,
            profiles=profiles,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_connection_strings: Mapping[str, Any],
             dedicated: str,
             high: str,
             low: str,
             medium: str,
             profiles: Sequence['outputs.GetAutonomousDatabaseConnectionStringProfileResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("all_connection_strings", all_connection_strings)
        _setter("dedicated", dedicated)
        _setter("high", high)
        _setter("low", low)
        _setter("medium", medium)
        _setter("profiles", profiles)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Mapping[str, Any]:
        """
        Returns all connection strings that can be used to connect to the Autonomous Database. For more information, please see [Predefined Database Service Names for Autonomous Transaction Processing](https://docs.oracle.com/en/cloud/paas/atp-cloud/atpug/connect-predefined.html#GUID-9747539B-FD46-44F1-8FF8-F5AC650F15BE)
        """
        return pulumi.get(self, "all_connection_strings")

    @property
    @pulumi.getter
    def dedicated(self) -> str:
        """
        The database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        """
        return pulumi.get(self, "dedicated")

    @property
    @pulumi.getter
    def high(self) -> str:
        """
        The High database service provides the highest level of resources to each SQL statement resulting in the highest performance, but supports the fewest number of concurrent SQL statements.
        """
        return pulumi.get(self, "high")

    @property
    @pulumi.getter
    def low(self) -> str:
        """
        The Low database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        """
        return pulumi.get(self, "low")

    @property
    @pulumi.getter
    def medium(self) -> str:
        """
        The Medium database service provides a lower level of resources to each SQL statement potentially resulting a lower level of performance, but supports more concurrent SQL statements.
        """
        return pulumi.get(self, "medium")

    @property
    @pulumi.getter
    def profiles(self) -> Sequence['outputs.GetAutonomousDatabaseConnectionStringProfileResult']:
        """
        A list of connection string profiles to allow clients to group, filter and select connection string values based on structured metadata.
        """
        return pulumi.get(self, "profiles")


@pulumi.output_type
class GetAutonomousDatabaseConnectionStringProfileResult(dict):
    def __init__(__self__, *,
                 consumer_group: str,
                 display_name: str,
                 host_format: str,
                 protocol: str,
                 session_mode: str,
                 syntax_format: str,
                 tls_authentication: str,
                 value: str):
        """
        :param str consumer_group: Consumer group used by the connection.
        :param str display_name: The user-friendly name for the Autonomous Database. The name does not have to be unique.
        :param str host_format: Host format used in connection string.
        :param str protocol: Protocol used by the connection.
        :param str session_mode: Specifies whether the listener performs a direct hand-off of the session, or redirects the session. In RAC deployments where SCAN is used, sessions are redirected to a Node VIP. Use `DIRECT` for direct hand-offs. Use `REDIRECT` to redirect the session.
        :param str syntax_format: Specifies whether the connection string is using the long (`LONG`), Easy Connect (`EZCONNECT`), or Easy Connect Plus (`EZCONNECTPLUS`) format. Autonomous Databases on shared Exadata infrastructure always use the long format.
        :param str tls_authentication: Specifies whether the TLS handshake is using one-way (`SERVER`) or mutual (`MUTUAL`) authentication.
        :param str value: Connection string value.
        """
        GetAutonomousDatabaseConnectionStringProfileResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            consumer_group=consumer_group,
            display_name=display_name,
            host_format=host_format,
            protocol=protocol,
            session_mode=session_mode,
            syntax_format=syntax_format,
            tls_authentication=tls_authentication,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             consumer_group: str,
             display_name: str,
             host_format: str,
             protocol: str,
             session_mode: str,
             syntax_format: str,
             tls_authentication: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("consumer_group", consumer_group)
        _setter("display_name", display_name)
        _setter("host_format", host_format)
        _setter("protocol", protocol)
        _setter("session_mode", session_mode)
        _setter("syntax_format", syntax_format)
        _setter("tls_authentication", tls_authentication)
        _setter("value", value)

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> str:
        """
        Consumer group used by the connection.
        """
        return pulumi.get(self, "consumer_group")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The user-friendly name for the Autonomous Database. The name does not have to be unique.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="hostFormat")
    def host_format(self) -> str:
        """
        Host format used in connection string.
        """
        return pulumi.get(self, "host_format")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Protocol used by the connection.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sessionMode")
    def session_mode(self) -> str:
        """
        Specifies whether the listener performs a direct hand-off of the session, or redirects the session. In RAC deployments where SCAN is used, sessions are redirected to a Node VIP. Use `DIRECT` for direct hand-offs. Use `REDIRECT` to redirect the session.
        """
        return pulumi.get(self, "session_mode")

    @property
    @pulumi.getter(name="syntaxFormat")
    def syntax_format(self) -> str:
        """
        Specifies whether the connection string is using the long (`LONG`), Easy Connect (`EZCONNECT`), or Easy Connect Plus (`EZCONNECTPLUS`) format. Autonomous Databases on shared Exadata infrastructure always use the long format.
        """
        return pulumi.get(self, "syntax_format")

    @property
    @pulumi.getter(name="tlsAuthentication")
    def tls_authentication(self) -> str:
        """
        Specifies whether the TLS handshake is using one-way (`SERVER`) or mutual (`MUTUAL`) authentication.
        """
        return pulumi.get(self, "tls_authentication")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Connection string value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAutonomousDatabaseConnectionUrlResult(dict):
    def __init__(__self__, *,
                 apex_url: str,
                 graph_studio_url: str,
                 machine_learning_user_management_url: str,
                 sql_dev_web_url: str):
        """
        :param str apex_url: Oracle Application Express (APEX) URL.
        :param str graph_studio_url: The URL of the Graph Studio for the Autonomous Database.
        :param str machine_learning_user_management_url: Oracle Machine Learning user management URL.
        :param str sql_dev_web_url: Oracle SQL Developer Web URL.
        """
        GetAutonomousDatabaseConnectionUrlResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apex_url=apex_url,
            graph_studio_url=graph_studio_url,
            machine_learning_user_management_url=machine_learning_user_management_url,
            sql_dev_web_url=sql_dev_web_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apex_url: str,
             graph_studio_url: str,
             machine_learning_user_management_url: str,
             sql_dev_web_url: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("apex_url", apex_url)
        _setter("graph_studio_url", graph_studio_url)
        _setter("machine_learning_user_management_url", machine_learning_user_management_url)
        _setter("sql_dev_web_url", sql_dev_web_url)

    @property
    @pulumi.getter(name="apexUrl")
    def apex_url(self) -> str:
        """
        Oracle Application Express (APEX) URL.
        """
        return pulumi.get(self, "apex_url")

    @property
    @pulumi.getter(name="graphStudioUrl")
    def graph_studio_url(self) -> str:
        """
        The URL of the Graph Studio for the Autonomous Database.
        """
        return pulumi.get(self, "graph_studio_url")

    @property
    @pulumi.getter(name="machineLearningUserManagementUrl")
    def machine_learning_user_management_url(self) -> str:
        """
        Oracle Machine Learning user management URL.
        """
        return pulumi.get(self, "machine_learning_user_management_url")

    @property
    @pulumi.getter(name="sqlDevWebUrl")
    def sql_dev_web_url(self) -> str:
        """
        Oracle SQL Developer Web URL.
        """
        return pulumi.get(self, "sql_dev_web_url")


@pulumi.output_type
class GetAutonomousDatabaseCustomerContactResult(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        GetAutonomousDatabaseCustomerContactResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            email=email,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             email: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetAutonomousDatabaseDataguardAssociationsAutonomousDatabaseDataguardAssociationResult(dict):
    def __init__(__self__, *,
                 apply_lag: str,
                 apply_rate: str,
                 autonomous_database_id: str,
                 id: str,
                 is_automatic_failover_enabled: bool,
                 lifecycle_details: str,
                 peer_autonomous_database_id: str,
                 peer_autonomous_database_life_cycle_state: str,
                 peer_role: str,
                 protection_mode: str,
                 role: str,
                 state: str,
                 time_created: str,
                 time_last_role_changed: str,
                 time_last_synced: str,
                 transport_lag: str):
        """
        :param str apply_lag: The lag time between updates to the primary database and application of the redo data on the standby database, as computed by the reporting database.  Example: `9 seconds`
        :param str apply_rate: The rate at which redo logs are synced between the associated databases.  Example: `180 Mb per second`
        :param str autonomous_database_id: The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param str id: The OCID of the Autonomous Dataguard created for Autonomous Container Database where given Autonomous Database resides in.
        :param bool is_automatic_failover_enabled: Indicates whether Automatic Failover is enabled for Autonomous Container Database Dataguard Association. Output DataType: boolean. Example : `is_automatic_failover_enabled = true`.
        :param str lifecycle_details: Additional information about the current lifecycleState, if available.
        :param str peer_autonomous_database_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the peer Autonomous Database.
        :param str peer_autonomous_database_life_cycle_state: The current state of Autonomous Data Guard.
        :param str peer_role: The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        :param str protection_mode: The protection mode of this Autonomous Data Guard association. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        :param str role: The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        :param str state: The current state of Autonomous Data Guard.
        :param str time_created: The date and time the Data Guard association was created.
        :param str time_last_role_changed: The date and time when the last role change action happened.
        :param str time_last_synced: The date and time of the last update to the apply lag, apply rate, and transport lag values.
        :param str transport_lag: The approximate number of seconds of redo data not yet available on the standby Autonomous Container Database, as computed by the reporting database.  Example: `7 seconds`
        """
        GetAutonomousDatabaseDataguardAssociationsAutonomousDatabaseDataguardAssociationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apply_lag=apply_lag,
            apply_rate=apply_rate,
            autonomous_database_id=autonomous_database_id,
            id=id,
            is_automatic_failover_enabled=is_automatic_failover_enabled,
            lifecycle_details=lifecycle_details,
            peer_autonomous_database_id=peer_autonomous_database_id,
            peer_autonomous_database_life_cycle_state=peer_autonomous_database_life_cycle_state,
            peer_role=peer_role,
            protection_mode=protection_mode,
            role=role,
            state=state,
            time_created=time_created,
            time_last_role_changed=time_last_role_changed,
            time_last_synced=time_last_synced,
            transport_lag=transport_lag,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apply_lag: str,
             apply_rate: str,
             autonomous_database_id: str,
             id: str,
             is_automatic_failover_enabled: bool,
             lifecycle_details: str,
             peer_autonomous_database_id: str,
             peer_autonomous_database_life_cycle_state: str,
             peer_role: str,
             protection_mode: str,
             role: str,
             state: str,
             time_created: str,
             time_last_role_changed: str,
             time_last_synced: str,
             transport_lag: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("apply_lag", apply_lag)
        _setter("apply_rate", apply_rate)
        _setter("autonomous_database_id", autonomous_database_id)
        _setter("id", id)
        _setter("is_automatic_failover_enabled", is_automatic_failover_enabled)
        _setter("lifecycle_details", lifecycle_details)
        _setter("peer_autonomous_database_id", peer_autonomous_database_id)
        _setter("peer_autonomous_database_life_cycle_state", peer_autonomous_database_life_cycle_state)
        _setter("peer_role", peer_role)
        _setter("protection_mode", protection_mode)
        _setter("role", role)
        _setter("state", state)
        _setter("time_created", time_created)
        _setter("time_last_role_changed", time_last_role_changed)
        _setter("time_last_synced", time_last_synced)
        _setter("transport_lag", transport_lag)

    @property
    @pulumi.getter(name="applyLag")
    def apply_lag(self) -> str:
        """
        The lag time between updates to the primary database and application of the redo data on the standby database, as computed by the reporting database.  Example: `9 seconds`
        """
        return pulumi.get(self, "apply_lag")

    @property
    @pulumi.getter(name="applyRate")
    def apply_rate(self) -> str:
        """
        The rate at which redo logs are synced between the associated databases.  Example: `180 Mb per second`
        """
        return pulumi.get(self, "apply_rate")

    @property
    @pulumi.getter(name="autonomousDatabaseId")
    def autonomous_database_id(self) -> str:
        """
        The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "autonomous_database_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the Autonomous Dataguard created for Autonomous Container Database where given Autonomous Database resides in.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isAutomaticFailoverEnabled")
    def is_automatic_failover_enabled(self) -> bool:
        """
        Indicates whether Automatic Failover is enabled for Autonomous Container Database Dataguard Association. Output DataType: boolean. Example : `is_automatic_failover_enabled = true`.
        """
        return pulumi.get(self, "is_automatic_failover_enabled")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycleState, if available.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="peerAutonomousDatabaseId")
    def peer_autonomous_database_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the peer Autonomous Database.
        """
        return pulumi.get(self, "peer_autonomous_database_id")

    @property
    @pulumi.getter(name="peerAutonomousDatabaseLifeCycleState")
    def peer_autonomous_database_life_cycle_state(self) -> str:
        """
        The current state of Autonomous Data Guard.
        """
        return pulumi.get(self, "peer_autonomous_database_life_cycle_state")

    @property
    @pulumi.getter(name="peerRole")
    def peer_role(self) -> str:
        """
        The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        """
        return pulumi.get(self, "peer_role")

    @property
    @pulumi.getter(name="protectionMode")
    def protection_mode(self) -> str:
        """
        The protection mode of this Autonomous Data Guard association. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        """
        return pulumi.get(self, "protection_mode")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of Autonomous Data Guard.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the Data Guard association was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeLastRoleChanged")
    def time_last_role_changed(self) -> str:
        """
        The date and time when the last role change action happened.
        """
        return pulumi.get(self, "time_last_role_changed")

    @property
    @pulumi.getter(name="timeLastSynced")
    def time_last_synced(self) -> str:
        """
        The date and time of the last update to the apply lag, apply rate, and transport lag values.
        """
        return pulumi.get(self, "time_last_synced")

    @property
    @pulumi.getter(name="transportLag")
    def transport_lag(self) -> str:
        """
        The approximate number of seconds of redo data not yet available on the standby Autonomous Container Database, as computed by the reporting database.  Example: `7 seconds`
        """
        return pulumi.get(self, "transport_lag")


@pulumi.output_type
class GetAutonomousDatabaseDataguardAssociationsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetAutonomousDatabaseDataguardAssociationsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousDatabaseKeyHistoryEntryResult(dict):
    def __init__(__self__, *,
                 id: str,
                 kms_key_version_id: str,
                 time_activated: str,
                 vault_id: str):
        """
        :param str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        :param str time_activated: The date and time the kms key activated.
        :param str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        GetAutonomousDatabaseKeyHistoryEntryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            kms_key_version_id=kms_key_version_id,
            time_activated=time_activated,
            vault_id=vault_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             kms_key_version_id: str,
             time_activated: str,
             vault_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("kms_key_version_id", kms_key_version_id)
        _setter("time_activated", time_activated)
        _setter("vault_id", vault_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> str:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        """
        return pulumi.get(self, "kms_key_version_id")

    @property
    @pulumi.getter(name="timeActivated")
    def time_activated(self) -> str:
        """
        The date and time the kms key activated.
        """
        return pulumi.get(self, "time_activated")

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class GetAutonomousDatabaseLocalStandbyDbResult(dict):
    def __init__(__self__, *,
                 lag_time_in_seconds: int,
                 lifecycle_details: str,
                 state: str,
                 time_data_guard_role_changed: str,
                 time_disaster_recovery_role_changed: str):
        """
        :param int lag_time_in_seconds: The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str state: The current state of the Autonomous Database.
        :param str time_data_guard_role_changed: The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        :param str time_disaster_recovery_role_changed: The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        GetAutonomousDatabaseLocalStandbyDbResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lag_time_in_seconds=lag_time_in_seconds,
            lifecycle_details=lifecycle_details,
            state=state,
            time_data_guard_role_changed=time_data_guard_role_changed,
            time_disaster_recovery_role_changed=time_disaster_recovery_role_changed,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lag_time_in_seconds: int,
             lifecycle_details: str,
             state: str,
             time_data_guard_role_changed: str,
             time_disaster_recovery_role_changed: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("lag_time_in_seconds", lag_time_in_seconds)
        _setter("lifecycle_details", lifecycle_details)
        _setter("state", state)
        _setter("time_data_guard_role_changed", time_data_guard_role_changed)
        _setter("time_disaster_recovery_role_changed", time_disaster_recovery_role_changed)

    @property
    @pulumi.getter(name="lagTimeInSeconds")
    def lag_time_in_seconds(self) -> int:
        """
        The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        """
        return pulumi.get(self, "lag_time_in_seconds")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the Autonomous Database.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeDataGuardRoleChanged")
    def time_data_guard_role_changed(self) -> str:
        """
        The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        """
        return pulumi.get(self, "time_data_guard_role_changed")

    @property
    @pulumi.getter(name="timeDisasterRecoveryRoleChanged")
    def time_disaster_recovery_role_changed(self) -> str:
        """
        The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        return pulumi.get(self, "time_disaster_recovery_role_changed")


@pulumi.output_type
class GetAutonomousDatabaseLongTermBackupScheduleResult(dict):
    def __init__(__self__, *,
                 is_disabled: bool,
                 repeat_cadence: str,
                 retention_period_in_days: int,
                 time_of_backup: str):
        """
        :param bool is_disabled: Indicates if the resource pool should be deleted for the Autonomous Database.
        :param str repeat_cadence: The frequency of the long-term backup schedule
        :param int retention_period_in_days: Retention period, in days, for long-term backups
        :param str time_of_backup: The timestamp for the long-term backup schedule. For a MONTHLY cadence, months having fewer days than the provided date will have the backup taken on the last day of that month.
        """
        GetAutonomousDatabaseLongTermBackupScheduleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_disabled=is_disabled,
            repeat_cadence=repeat_cadence,
            retention_period_in_days=retention_period_in_days,
            time_of_backup=time_of_backup,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_disabled: bool,
             repeat_cadence: str,
             retention_period_in_days: int,
             time_of_backup: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("is_disabled", is_disabled)
        _setter("repeat_cadence", repeat_cadence)
        _setter("retention_period_in_days", retention_period_in_days)
        _setter("time_of_backup", time_of_backup)

    @property
    @pulumi.getter(name="isDisabled")
    def is_disabled(self) -> bool:
        """
        Indicates if the resource pool should be deleted for the Autonomous Database.
        """
        return pulumi.get(self, "is_disabled")

    @property
    @pulumi.getter(name="repeatCadence")
    def repeat_cadence(self) -> str:
        """
        The frequency of the long-term backup schedule
        """
        return pulumi.get(self, "repeat_cadence")

    @property
    @pulumi.getter(name="retentionPeriodInDays")
    def retention_period_in_days(self) -> int:
        """
        Retention period, in days, for long-term backups
        """
        return pulumi.get(self, "retention_period_in_days")

    @property
    @pulumi.getter(name="timeOfBackup")
    def time_of_backup(self) -> str:
        """
        The timestamp for the long-term backup schedule. For a MONTHLY cadence, months having fewer days than the provided date will have the backup taken on the last day of that month.
        """
        return pulumi.get(self, "time_of_backup")


@pulumi.output_type
class GetAutonomousDatabaseRefreshableClonesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetAutonomousDatabaseRefreshableClonesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousDatabaseRefreshableClonesRefreshableCloneCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetAutonomousDatabaseRefreshableClonesRefreshableCloneCollectionItemResult']):
        GetAutonomousDatabaseRefreshableClonesRefreshableCloneCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Sequence['outputs.GetAutonomousDatabaseRefreshableClonesRefreshableCloneCollectionItemResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetAutonomousDatabaseRefreshableClonesRefreshableCloneCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetAutonomousDatabaseRefreshableClonesRefreshableCloneCollectionItemResult(dict):
    def __init__(__self__, *,
                 id: str,
                 region: str):
        """
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database.
        :param str region: The name of the region where the refreshable clone exists.
        """
        GetAutonomousDatabaseRefreshableClonesRefreshableCloneCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             region: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("region", region)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Database.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The name of the region where the refreshable clone exists.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetAutonomousDatabaseRemoteDisasterRecoveryConfigurationResult(dict):
    def __init__(__self__, *,
                 disaster_recovery_type: str):
        """
        :param str disaster_recovery_type: Indicates the disaster recovery (DR) type of the Shared Autonomous Database. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
        """
        GetAutonomousDatabaseRemoteDisasterRecoveryConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disaster_recovery_type=disaster_recovery_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disaster_recovery_type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("disaster_recovery_type", disaster_recovery_type)

    @property
    @pulumi.getter(name="disasterRecoveryType")
    def disaster_recovery_type(self) -> str:
        """
        Indicates the disaster recovery (DR) type of the Shared Autonomous Database. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
        """
        return pulumi.get(self, "disaster_recovery_type")


@pulumi.output_type
class GetAutonomousDatabaseResourcePoolSummaryResult(dict):
    def __init__(__self__, *,
                 is_disabled: bool,
                 pool_size: int):
        """
        :param bool is_disabled: Indicates if the resource pool should be deleted for the Autonomous Database.
        :param int pool_size: Resource pool size.
        """
        GetAutonomousDatabaseResourcePoolSummaryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_disabled=is_disabled,
            pool_size=pool_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_disabled: bool,
             pool_size: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("is_disabled", is_disabled)
        _setter("pool_size", pool_size)

    @property
    @pulumi.getter(name="isDisabled")
    def is_disabled(self) -> bool:
        """
        Indicates if the resource pool should be deleted for the Autonomous Database.
        """
        return pulumi.get(self, "is_disabled")

    @property
    @pulumi.getter(name="poolSize")
    def pool_size(self) -> int:
        """
        Resource pool size.
        """
        return pulumi.get(self, "pool_size")


@pulumi.output_type
class GetAutonomousDatabaseScheduledOperationResult(dict):
    def __init__(__self__, *,
                 day_of_weeks: Sequence['outputs.GetAutonomousDatabaseScheduledOperationDayOfWeekResult'],
                 scheduled_start_time: str,
                 scheduled_stop_time: str):
        """
        :param Sequence['GetAutonomousDatabaseScheduledOperationDayOfWeekArgs'] day_of_weeks: Day of the week.
        :param str scheduled_start_time: auto start time. value must be of ISO-8601 format "HH:mm"
        :param str scheduled_stop_time: auto stop time. value must be of ISO-8601 format "HH:mm"
        """
        GetAutonomousDatabaseScheduledOperationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            day_of_weeks=day_of_weeks,
            scheduled_start_time=scheduled_start_time,
            scheduled_stop_time=scheduled_stop_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             day_of_weeks: Sequence['outputs.GetAutonomousDatabaseScheduledOperationDayOfWeekResult'],
             scheduled_start_time: str,
             scheduled_stop_time: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("day_of_weeks", day_of_weeks)
        _setter("scheduled_start_time", scheduled_start_time)
        _setter("scheduled_stop_time", scheduled_stop_time)

    @property
    @pulumi.getter(name="dayOfWeeks")
    def day_of_weeks(self) -> Sequence['outputs.GetAutonomousDatabaseScheduledOperationDayOfWeekResult']:
        """
        Day of the week.
        """
        return pulumi.get(self, "day_of_weeks")

    @property
    @pulumi.getter(name="scheduledStartTime")
    def scheduled_start_time(self) -> str:
        """
        auto start time. value must be of ISO-8601 format "HH:mm"
        """
        return pulumi.get(self, "scheduled_start_time")

    @property
    @pulumi.getter(name="scheduledStopTime")
    def scheduled_stop_time(self) -> str:
        """
        auto stop time. value must be of ISO-8601 format "HH:mm"
        """
        return pulumi.get(self, "scheduled_stop_time")


@pulumi.output_type
class GetAutonomousDatabaseScheduledOperationDayOfWeekResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the day of the week.
        """
        GetAutonomousDatabaseScheduledOperationDayOfWeekResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the day of the week.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousDatabaseStandbyDbResult(dict):
    def __init__(__self__, *,
                 lag_time_in_seconds: int,
                 lifecycle_details: str,
                 state: str,
                 time_data_guard_role_changed: str,
                 time_disaster_recovery_role_changed: str):
        """
        :param int lag_time_in_seconds: The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str state: The current state of the Autonomous Database.
        :param str time_data_guard_role_changed: The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        :param str time_disaster_recovery_role_changed: The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        GetAutonomousDatabaseStandbyDbResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lag_time_in_seconds=lag_time_in_seconds,
            lifecycle_details=lifecycle_details,
            state=state,
            time_data_guard_role_changed=time_data_guard_role_changed,
            time_disaster_recovery_role_changed=time_disaster_recovery_role_changed,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lag_time_in_seconds: int,
             lifecycle_details: str,
             state: str,
             time_data_guard_role_changed: str,
             time_disaster_recovery_role_changed: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("lag_time_in_seconds", lag_time_in_seconds)
        _setter("lifecycle_details", lifecycle_details)
        _setter("state", state)
        _setter("time_data_guard_role_changed", time_data_guard_role_changed)
        _setter("time_disaster_recovery_role_changed", time_disaster_recovery_role_changed)

    @property
    @pulumi.getter(name="lagTimeInSeconds")
    def lag_time_in_seconds(self) -> int:
        """
        The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        """
        return pulumi.get(self, "lag_time_in_seconds")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the Autonomous Database.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeDataGuardRoleChanged")
    def time_data_guard_role_changed(self) -> str:
        """
        The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        """
        return pulumi.get(self, "time_data_guard_role_changed")

    @property
    @pulumi.getter(name="timeDisasterRecoveryRoleChanged")
    def time_disaster_recovery_role_changed(self) -> str:
        """
        The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        return pulumi.get(self, "time_disaster_recovery_role_changed")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseResult(dict):
    def __init__(__self__, *,
                 actual_used_data_storage_size_in_tbs: float,
                 admin_password: str,
                 allocated_storage_size_in_tbs: float,
                 apex_details: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseApexDetailResult'],
                 are_primary_whitelisted_ips_used: bool,
                 autonomous_container_database_id: str,
                 autonomous_database_backup_id: str,
                 autonomous_database_id: str,
                 autonomous_maintenance_schedule_type: str,
                 available_upgrade_versions: Sequence[str],
                 backup_configs: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseBackupConfigResult'],
                 backup_retention_period_in_days: int,
                 character_set: str,
                 clone_type: str,
                 compartment_id: str,
                 compute_count: float,
                 compute_model: str,
                 connection_strings: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseConnectionStringResult'],
                 connection_urls: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseConnectionUrlResult'],
                 cpu_core_count: int,
                 customer_contacts: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseCustomerContactResult'],
                 data_safe_status: str,
                 data_storage_size_in_gb: int,
                 data_storage_size_in_tbs: int,
                 database_edition: str,
                 database_management_status: str,
                 dataguard_region_type: str,
                 db_name: str,
                 db_version: str,
                 db_workload: str,
                 defined_tags: Mapping[str, Any],
                 disaster_recovery_region_type: str,
                 display_name: str,
                 failed_data_recovery_in_seconds: int,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 in_memory_area_in_gbs: int,
                 in_memory_percentage: int,
                 infrastructure_type: str,
                 is_access_control_enabled: bool,
                 is_auto_scaling_enabled: bool,
                 is_auto_scaling_for_storage_enabled: bool,
                 is_data_guard_enabled: bool,
                 is_dedicated: bool,
                 is_free_tier: bool,
                 is_local_data_guard_enabled: bool,
                 is_mtls_connection_required: bool,
                 is_preview: bool,
                 is_preview_version_with_service_terms_accepted: bool,
                 is_reconnect_clone_enabled: bool,
                 is_refreshable_clone: bool,
                 is_remote_data_guard_enabled: bool,
                 is_shrink_only: bool,
                 key_history_entries: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseKeyHistoryEntryResult'],
                 key_store_id: str,
                 key_store_wallet_name: str,
                 kms_key_id: str,
                 kms_key_lifecycle_details: str,
                 kms_key_version_id: str,
                 license_model: str,
                 lifecycle_details: str,
                 local_adg_auto_failover_max_data_loss_limit: int,
                 local_disaster_recovery_type: str,
                 local_standby_dbs: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseLocalStandbyDbResult'],
                 long_term_backup_schedules: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseLongTermBackupScheduleResult'],
                 max_cpu_core_count: int,
                 memory_per_oracle_compute_unit_in_gbs: int,
                 ncharacter_set: str,
                 next_long_term_backup_time_stamp: str,
                 nsg_ids: Sequence[str],
                 ocpu_count: float,
                 open_mode: str,
                 operations_insights_status: str,
                 peer_db_ids: Sequence[str],
                 permission_level: str,
                 private_endpoint: str,
                 private_endpoint_ip: str,
                 private_endpoint_label: str,
                 provisionable_cpuses: Sequence[float],
                 refreshable_mode: str,
                 refreshable_status: str,
                 remote_disaster_recovery_configurations: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseRemoteDisasterRecoveryConfigurationResult'],
                 remote_disaster_recovery_type: str,
                 resource_pool_leader_id: str,
                 resource_pool_summaries: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseResourcePoolSummaryResult'],
                 role: str,
                 rotate_key_trigger: bool,
                 scheduled_operations: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseScheduledOperationResult'],
                 secret_id: str,
                 secret_version_number: int,
                 service_console_url: str,
                 source: str,
                 source_id: str,
                 standby_dbs: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseStandbyDbResult'],
                 standby_whitelisted_ips: Sequence[str],
                 state: str,
                 subnet_id: str,
                 supported_regions_to_clone_tos: Sequence[str],
                 switchover_to: str,
                 switchover_to_remote_peer_id: str,
                 system_tags: Mapping[str, Any],
                 time_created: str,
                 time_data_guard_role_changed: str,
                 time_deletion_of_free_autonomous_database: str,
                 time_disaster_recovery_role_changed: str,
                 time_local_data_guard_enabled: str,
                 time_maintenance_begin: str,
                 time_maintenance_end: str,
                 time_of_joining_resource_pool: str,
                 time_of_last_failover: str,
                 time_of_last_refresh: str,
                 time_of_last_refresh_point: str,
                 time_of_last_switchover: str,
                 time_of_next_refresh: str,
                 time_reclamation_of_free_autonomous_database: str,
                 time_until_reconnect_clone_enabled: str,
                 timestamp: str,
                 total_backup_storage_size_in_gbs: float,
                 use_latest_available_backup_time_stamp: bool,
                 used_data_storage_size_in_gbs: int,
                 used_data_storage_size_in_tbs: int,
                 vault_id: str,
                 whitelisted_ips: Sequence[str]):
        """
        :param float actual_used_data_storage_size_in_tbs: The current amount of storage in use for user and system data, in terabytes (TB).
        :param float allocated_storage_size_in_tbs: The amount of storage currently allocated for the database tables and billed for, rounded up. When auto-scaling is not enabled, this value is equal to the `dataStorageSizeInTBs` value. You can compare this value to the `actualUsedDataStorageSizeInTBs` value to determine if a manual shrink operation is appropriate for your allocated storage.
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseApexDetailArgs'] apex_details: Information about Oracle APEX Application Development.
        :param bool are_primary_whitelisted_ips_used: This field will be null if the Autonomous Database is not Data Guard enabled or Access Control is disabled. It's value would be `TRUE` if Autonomous Database is Data Guard enabled and Access Control is enabled and if the Autonomous Database uses primary IP access control list (ACL) for standby. It's value would be `FALSE` if Autonomous Database is Data Guard enabled and Access Control is enabled and if the Autonomous Database uses different IP access control list (ACL) for standby compared to primary.
        :param str autonomous_container_database_id: The Autonomous Container Database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param str autonomous_maintenance_schedule_type: The maintenance schedule type of the Autonomous Database on shared Exadata infrastructure. The EARLY maintenance schedule of this Autonomous Database follows a schedule that applies patches prior to the REGULAR schedule.The REGULAR maintenance schedule of this Autonomous Database follows the normal cycle.
        :param Sequence[str] available_upgrade_versions: List of Oracle Database versions available for a database upgrade. If there are no version upgrades available, this list is empty.
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseBackupConfigArgs'] backup_configs: Autonomous Database configuration details for storing [manual backups](https://docs.oracle.com/en/cloud/paas/autonomous-database/adbsa/backup-restore.html#GUID-9035DFB8-4702-4CEB-8281-C2A303820809) in the [Object Storage](https://docs.cloud.oracle.com/iaas/Content/Object/Concepts/objectstorageoverview.htm) service.
        :param int backup_retention_period_in_days: Retention period, in days, for backups.
        :param str character_set: The character set for the autonomous database.  The default is AL32UTF8. Allowed values are:
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param float compute_count: The compute amount available to the database. Minimum and maximum values depend on the compute model and whether the database is on Shared or Dedicated infrastructure. For an Autonomous Database on Shared infrastructure, the 'ECPU' compute model requires values in multiples of two. Required when using the `computeModel` parameter. When using `cpuCoreCount` parameter, it is an error to specify computeCount to a non-null value.
        :param str compute_model: The compute model of the Autonomous Database. This is required if using the `computeCount` parameter. If using `cpuCoreCount` then it is an error to specify `computeModel` to a non-null value.
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseConnectionStringArgs'] connection_strings: The connection string used to connect to the Autonomous Database. The username for the Service Console is ADMIN. Use the password you entered when creating the Autonomous Database for the password value.
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseConnectionUrlArgs'] connection_urls: The URLs for accessing Oracle Application Express (APEX) and SQL Developer Web with a browser from a Compute instance within your VCN or that has a direct connection to your VCN. Note that these URLs are provided by the console only for databases on [dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html).  Example: `{"sqlDevWebUrl": "https://<hostname>/ords...", "apexUrl", "https://<hostname>/ords..."}`
        :param int cpu_core_count: The number of OCPU cores to be made available to the database. When the ECPU is selected, the value for cpuCoreCount is 0. For Autonomous Databases on dedicated Exadata infrastructure, the maximum number of cores is determined by the infrastructure shape. See [Characteristics of Infrastructure Shapes](https://www.oracle.com/pls/topic/lookup?ctx=en/cloud/paas/autonomous-database&id=ATPFG-GUID-B0F033C1-CC5A-42F0-B2E7-3CECFEDA1FD1) for shape details.
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseCustomerContactArgs'] customer_contacts: Customer Contacts.
        :param str data_safe_status: Status of the Data Safe registration for this Autonomous Database. Could be REGISTERED or NOT_REGISTERED.
        :param int data_storage_size_in_gb: The quantity of data in the database, in gigabytes.
        :param int data_storage_size_in_tbs: The quantity of data in the database, in terabytes.
        :param str database_edition: The Oracle Database Edition that applies to the Autonomous databases.
        :param str database_management_status: Status of Database Management for this Autonomous Database.
        :param str dataguard_region_type: The Autonomous Data Guard region type of the Autonomous Database. For Autonomous Databases on shared Exadata infrastructure, Data Guard associations have designated primary and standby regions, and these region types do not change when the database changes roles. The standby regions in Data Guard associations can be the same region designated as the primary region, or they can be remote regions. Certain database administrative operations may be available only in the primary region of the Data Guard association, and cannot be performed when the database using the "primary" role is operating in a remote Data Guard standby region.
        :param str db_name: The database name.
        :param str db_version: A filter to return only autonomous database resources that match the specified dbVersion.
        :param str db_workload: A filter to return only autonomous database resources that match the specified workload type.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str disaster_recovery_region_type: The disaster recovery (DR) region type of the Autonomous Database. For Shared Autonomous Databases, DR associations have designated primary and standby regions. These region types do not change when the database changes roles. The standby region in DR associations can be the same region as the primary region, or they can be in a remote regions. Some database administration operations may be available only in the primary region of the DR association, and cannot be performed when the database using the primary role is operating in a remote region.
        :param str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param int failed_data_recovery_in_seconds: Indicates the number of seconds of data loss for a Data Guard failover.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param int in_memory_area_in_gbs: The area assigned to In-Memory tables in Autonomous Database.
        :param int in_memory_percentage: The percentage of the System Global Area(SGA) assigned to In-Memory tables in Autonomous Database.
        :param str infrastructure_type: A filter to return only resources that match the given Infrastructure Type.
        :param bool is_access_control_enabled: Indicates if the database-level access control is enabled. If disabled, database access is defined by the network security rules. If enabled, database access is restricted to the IP addresses defined by the rules specified with the `whitelistedIps` property. While specifying `whitelistedIps` rules is optional, if database-level access control is enabled and no rules are specified, the database will become inaccessible. The rules can be added later using the `UpdateAutonomousDatabase` API operation or edit option in console. When creating a database clone, the desired access control setting should be specified. By default, database-level access control will be disabled for the clone.
        :param bool is_auto_scaling_enabled: Indicates if auto scaling is enabled for the Autonomous Database CPU core count.
        :param bool is_auto_scaling_for_storage_enabled: Indicates if auto scaling is enabled for the Autonomous Database storage. The default value is `FALSE`.
        :param bool is_data_guard_enabled: A filter to return only resources that have Data Guard enabled.
        :param bool is_dedicated: True if the database uses [dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html).
        :param bool is_free_tier: Filter on the value of the resource's 'isFreeTier' property. A value of `true` returns only Always Free resources. A value of `false` excludes Always Free resources from the returned results. Omitting this parameter returns both Always Free and paid resources.
        :param bool is_local_data_guard_enabled: Indicates whether the Autonomous Database has local (in-region) Data Guard enabled. Not applicable to cross-region Autonomous Data Guard associations, or to Autonomous Databases using dedicated Exadata infrastructure or Exadata Cloud@Customer infrastructure.
        :param bool is_mtls_connection_required: Specifies if the Autonomous Database requires mTLS connections.
        :param bool is_preview: Indicates if the Autonomous Database version is a preview version.
        :param bool is_reconnect_clone_enabled: Indicates if the refreshable clone can be reconnected to its source database.
        :param bool is_refreshable_clone: Filter on the value of the resource's 'isRefreshableClone' property. A value of `true` returns only refreshable clones. A value of `false` excludes refreshable clones from the returned results. Omitting this parameter returns both refreshable clones and databases that are not refreshable clones.
        :param bool is_remote_data_guard_enabled: Indicates whether the Autonomous Database has Cross Region Data Guard enabled. Not applicable to Autonomous Databases using dedicated Exadata infrastructure or Exadata Cloud@Customer infrastructure.
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseKeyHistoryEntryArgs'] key_history_entries: Key History Entry.
        :param str key_store_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        :param str key_store_wallet_name: The wallet name for Oracle Key Vault.
        :param str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param str kms_key_lifecycle_details: KMS key lifecycle details.
        :param str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        :param str license_model: The Oracle license model that applies to the Oracle Autonomous Database. Bring your own license (BYOL) allows you to apply your current on-premises Oracle software licenses to equivalent, highly automated Oracle PaaS and IaaS services in the cloud. License Included allows you to subscribe to new Oracle Database software licenses and the Database service. Note that when provisioning an Autonomous Database on [dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html), this attribute must be null because the attribute is already set at the Autonomous Exadata Infrastructure level. When using [shared Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html), if a value is not specified, the system will supply the value of `BRING_YOUR_OWN_LICENSE`.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param int local_adg_auto_failover_max_data_loss_limit: Parameter that allows users to select an acceptable maximum data loss limit in seconds, up to which Automatic Failover will be triggered when necessary for a Local Autonomous Data Guard
        :param str local_disaster_recovery_type: Indicates the local disaster recovery (DR) type of the Shared Autonomous Database. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseLocalStandbyDbArgs'] local_standby_dbs: Autonomous Data Guard standby database details.
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseLongTermBackupScheduleArgs'] long_term_backup_schedules: Details for the long-term backup schedule.
        :param int max_cpu_core_count: The number of Max OCPU cores to be made available to the autonomous database with auto scaling of cpu enabled.
        :param int memory_per_oracle_compute_unit_in_gbs: The amount of memory (in GBs) enabled per OCPU or ECPU.
        :param str ncharacter_set: The national character set for the autonomous database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        :param str next_long_term_backup_time_stamp: The date and time when the next long-term backup would be created.
        :param Sequence[str] nsg_ids: The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the network security groups (NSGs) to which this resource belongs. Setting this to an empty list removes all resources from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). **NsgIds restrictions:**
               * A network security group (NSG) is optional for Autonomous Databases with private access. The nsgIds list can be empty.
        :param float ocpu_count: The number of OCPU cores to be made available to the database.
        :param str open_mode: Indicates the Autonomous Database mode. The database can be opened in `READ_ONLY` or `READ_WRITE` mode.
        :param str operations_insights_status: Status of Operations Insights for this Autonomous Database.
        :param Sequence[str] peer_db_ids: The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of standby databases located in Autonomous Data Guard remote regions that are associated with the source database. Note that for shared Exadata infrastructure, standby databases located in the same region as the source primary database do not have OCIDs.
        :param str permission_level: The Autonomous Database permission level. Restricted mode allows access only by admin users.
        :param str private_endpoint: The private endpoint for the resource.
        :param str private_endpoint_ip: The private endpoint Ip address for the resource.
        :param str private_endpoint_label: The private endpoint label for the resource.
        :param Sequence[float] provisionable_cpuses: An array of CPU values that an Autonomous Database can be scaled to.
        :param str refreshable_mode: The refresh mode of the clone. AUTOMATIC indicates that the clone is automatically being refreshed with data from the source Autonomous Database.
        :param str refreshable_status: The refresh status of the clone. REFRESHING indicates that the clone is currently being refreshed with data from the source Autonomous Database.
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseRemoteDisasterRecoveryConfigurationArgs'] remote_disaster_recovery_configurations: Configurations of a Disaster Recovery.
        :param str resource_pool_leader_id: The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the resourcepool Leader Autonomous Database.
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseResourcePoolSummaryArgs'] resource_pool_summaries: The configuration details for resource pool
        :param str role: The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseScheduledOperationArgs'] scheduled_operations: The list of scheduled operations.
        :param str service_console_url: The URL of the Service Console for the Autonomous Database.
        :param str source_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the source Autonomous Database that was cloned to create the current Autonomous Database.
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseStandbyDbArgs'] standby_dbs: **Deprecated** Autonomous Data Guard standby database details.
        :param Sequence[str] standby_whitelisted_ips: The client IP access control list (ACL). This feature is available for autonomous databases on [shared Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html) and on Exadata Cloud@Customer. Only clients connecting from an IP address included in the ACL may access the Autonomous Database instance.
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        :param str subnet_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet the resource is associated with.
        :param Sequence[str] supported_regions_to_clone_tos: The list of regions that support the creation of an Autonomous Database clone or an Autonomous Data Guard standby database.
        :param Mapping[str, Any] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str time_created: The date and time the Autonomous Database was created.
        :param str time_data_guard_role_changed: The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        :param str time_deletion_of_free_autonomous_database: The date and time the Always Free database will be automatically deleted because of inactivity. If the database is in the STOPPED state and without activity until this time, it will be deleted.
        :param str time_disaster_recovery_role_changed: The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        :param str time_local_data_guard_enabled: The date and time that Autonomous Data Guard was enabled for an Autonomous Database where the standby was provisioned in the same region as the primary database.
        :param str time_maintenance_begin: The date and time when maintenance will begin.
        :param str time_maintenance_end: The date and time when maintenance will end.
        :param str time_of_joining_resource_pool: The time the member joined the resource pool.
        :param str time_of_last_failover: The timestamp of the last failover operation.
        :param str time_of_last_refresh: The date and time when last refresh happened.
        :param str time_of_last_refresh_point: The refresh point timestamp (UTC). The refresh point is the time to which the database was most recently refreshed. Data created after the refresh point is not included in the refresh.
        :param str time_of_last_switchover: The timestamp of the last switchover operation for the Autonomous Database.
        :param str time_of_next_refresh: The date and time of next refresh.
        :param str time_reclamation_of_free_autonomous_database: The date and time the Always Free database will be stopped because of inactivity. If this time is reached without any database activity, the database will automatically be put into the STOPPED state.
        :param str time_until_reconnect_clone_enabled: The time and date as an RFC3339 formatted string, e.g., 2022-01-01T12:00:00.000Z, to set the limit for a refreshable clone to be reconnected to its source database.
        :param float total_backup_storage_size_in_gbs: The backup storage to the database.
        :param int used_data_storage_size_in_gbs: The storage space consumed by Autonomous Database in GBs.
        :param int used_data_storage_size_in_tbs: The amount of storage that has been used, in terabytes.
        :param str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        :param Sequence[str] whitelisted_ips: The client IP access control list (ACL). This feature is available for [Autonomous Database Serverless] (https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html) and on Exadata Cloud@Customer. Only clients connecting from an IP address included in the ACL may access the Autonomous Database instance.
        """
        GetAutonomousDatabasesAutonomousDatabaseResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actual_used_data_storage_size_in_tbs=actual_used_data_storage_size_in_tbs,
            admin_password=admin_password,
            allocated_storage_size_in_tbs=allocated_storage_size_in_tbs,
            apex_details=apex_details,
            are_primary_whitelisted_ips_used=are_primary_whitelisted_ips_used,
            autonomous_container_database_id=autonomous_container_database_id,
            autonomous_database_backup_id=autonomous_database_backup_id,
            autonomous_database_id=autonomous_database_id,
            autonomous_maintenance_schedule_type=autonomous_maintenance_schedule_type,
            available_upgrade_versions=available_upgrade_versions,
            backup_configs=backup_configs,
            backup_retention_period_in_days=backup_retention_period_in_days,
            character_set=character_set,
            clone_type=clone_type,
            compartment_id=compartment_id,
            compute_count=compute_count,
            compute_model=compute_model,
            connection_strings=connection_strings,
            connection_urls=connection_urls,
            cpu_core_count=cpu_core_count,
            customer_contacts=customer_contacts,
            data_safe_status=data_safe_status,
            data_storage_size_in_gb=data_storage_size_in_gb,
            data_storage_size_in_tbs=data_storage_size_in_tbs,
            database_edition=database_edition,
            database_management_status=database_management_status,
            dataguard_region_type=dataguard_region_type,
            db_name=db_name,
            db_version=db_version,
            db_workload=db_workload,
            defined_tags=defined_tags,
            disaster_recovery_region_type=disaster_recovery_region_type,
            display_name=display_name,
            failed_data_recovery_in_seconds=failed_data_recovery_in_seconds,
            freeform_tags=freeform_tags,
            id=id,
            in_memory_area_in_gbs=in_memory_area_in_gbs,
            in_memory_percentage=in_memory_percentage,
            infrastructure_type=infrastructure_type,
            is_access_control_enabled=is_access_control_enabled,
            is_auto_scaling_enabled=is_auto_scaling_enabled,
            is_auto_scaling_for_storage_enabled=is_auto_scaling_for_storage_enabled,
            is_data_guard_enabled=is_data_guard_enabled,
            is_dedicated=is_dedicated,
            is_free_tier=is_free_tier,
            is_local_data_guard_enabled=is_local_data_guard_enabled,
            is_mtls_connection_required=is_mtls_connection_required,
            is_preview=is_preview,
            is_preview_version_with_service_terms_accepted=is_preview_version_with_service_terms_accepted,
            is_reconnect_clone_enabled=is_reconnect_clone_enabled,
            is_refreshable_clone=is_refreshable_clone,
            is_remote_data_guard_enabled=is_remote_data_guard_enabled,
            is_shrink_only=is_shrink_only,
            key_history_entries=key_history_entries,
            key_store_id=key_store_id,
            key_store_wallet_name=key_store_wallet_name,
            kms_key_id=kms_key_id,
            kms_key_lifecycle_details=kms_key_lifecycle_details,
            kms_key_version_id=kms_key_version_id,
            license_model=license_model,
            lifecycle_details=lifecycle_details,
            local_adg_auto_failover_max_data_loss_limit=local_adg_auto_failover_max_data_loss_limit,
            local_disaster_recovery_type=local_disaster_recovery_type,
            local_standby_dbs=local_standby_dbs,
            long_term_backup_schedules=long_term_backup_schedules,
            max_cpu_core_count=max_cpu_core_count,
            memory_per_oracle_compute_unit_in_gbs=memory_per_oracle_compute_unit_in_gbs,
            ncharacter_set=ncharacter_set,
            next_long_term_backup_time_stamp=next_long_term_backup_time_stamp,
            nsg_ids=nsg_ids,
            ocpu_count=ocpu_count,
            open_mode=open_mode,
            operations_insights_status=operations_insights_status,
            peer_db_ids=peer_db_ids,
            permission_level=permission_level,
            private_endpoint=private_endpoint,
            private_endpoint_ip=private_endpoint_ip,
            private_endpoint_label=private_endpoint_label,
            provisionable_cpuses=provisionable_cpuses,
            refreshable_mode=refreshable_mode,
            refreshable_status=refreshable_status,
            remote_disaster_recovery_configurations=remote_disaster_recovery_configurations,
            remote_disaster_recovery_type=remote_disaster_recovery_type,
            resource_pool_leader_id=resource_pool_leader_id,
            resource_pool_summaries=resource_pool_summaries,
            role=role,
            rotate_key_trigger=rotate_key_trigger,
            scheduled_operations=scheduled_operations,
            secret_id=secret_id,
            secret_version_number=secret_version_number,
            service_console_url=service_console_url,
            source=source,
            source_id=source_id,
            standby_dbs=standby_dbs,
            standby_whitelisted_ips=standby_whitelisted_ips,
            state=state,
            subnet_id=subnet_id,
            supported_regions_to_clone_tos=supported_regions_to_clone_tos,
            switchover_to=switchover_to,
            switchover_to_remote_peer_id=switchover_to_remote_peer_id,
            system_tags=system_tags,
            time_created=time_created,
            time_data_guard_role_changed=time_data_guard_role_changed,
            time_deletion_of_free_autonomous_database=time_deletion_of_free_autonomous_database,
            time_disaster_recovery_role_changed=time_disaster_recovery_role_changed,
            time_local_data_guard_enabled=time_local_data_guard_enabled,
            time_maintenance_begin=time_maintenance_begin,
            time_maintenance_end=time_maintenance_end,
            time_of_joining_resource_pool=time_of_joining_resource_pool,
            time_of_last_failover=time_of_last_failover,
            time_of_last_refresh=time_of_last_refresh,
            time_of_last_refresh_point=time_of_last_refresh_point,
            time_of_last_switchover=time_of_last_switchover,
            time_of_next_refresh=time_of_next_refresh,
            time_reclamation_of_free_autonomous_database=time_reclamation_of_free_autonomous_database,
            time_until_reconnect_clone_enabled=time_until_reconnect_clone_enabled,
            timestamp=timestamp,
            total_backup_storage_size_in_gbs=total_backup_storage_size_in_gbs,
            use_latest_available_backup_time_stamp=use_latest_available_backup_time_stamp,
            used_data_storage_size_in_gbs=used_data_storage_size_in_gbs,
            used_data_storage_size_in_tbs=used_data_storage_size_in_tbs,
            vault_id=vault_id,
            whitelisted_ips=whitelisted_ips,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actual_used_data_storage_size_in_tbs: float,
             admin_password: str,
             allocated_storage_size_in_tbs: float,
             apex_details: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseApexDetailResult'],
             are_primary_whitelisted_ips_used: bool,
             autonomous_container_database_id: str,
             autonomous_database_backup_id: str,
             autonomous_database_id: str,
             autonomous_maintenance_schedule_type: str,
             available_upgrade_versions: Sequence[str],
             backup_configs: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseBackupConfigResult'],
             backup_retention_period_in_days: int,
             character_set: str,
             clone_type: str,
             compartment_id: str,
             compute_count: float,
             compute_model: str,
             connection_strings: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseConnectionStringResult'],
             connection_urls: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseConnectionUrlResult'],
             cpu_core_count: int,
             customer_contacts: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseCustomerContactResult'],
             data_safe_status: str,
             data_storage_size_in_gb: int,
             data_storage_size_in_tbs: int,
             database_edition: str,
             database_management_status: str,
             dataguard_region_type: str,
             db_name: str,
             db_version: str,
             db_workload: str,
             defined_tags: Mapping[str, Any],
             disaster_recovery_region_type: str,
             display_name: str,
             failed_data_recovery_in_seconds: int,
             freeform_tags: Mapping[str, Any],
             id: str,
             in_memory_area_in_gbs: int,
             in_memory_percentage: int,
             infrastructure_type: str,
             is_access_control_enabled: bool,
             is_auto_scaling_enabled: bool,
             is_auto_scaling_for_storage_enabled: bool,
             is_data_guard_enabled: bool,
             is_dedicated: bool,
             is_free_tier: bool,
             is_local_data_guard_enabled: bool,
             is_mtls_connection_required: bool,
             is_preview: bool,
             is_preview_version_with_service_terms_accepted: bool,
             is_reconnect_clone_enabled: bool,
             is_refreshable_clone: bool,
             is_remote_data_guard_enabled: bool,
             is_shrink_only: bool,
             key_history_entries: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseKeyHistoryEntryResult'],
             key_store_id: str,
             key_store_wallet_name: str,
             kms_key_id: str,
             kms_key_lifecycle_details: str,
             kms_key_version_id: str,
             license_model: str,
             lifecycle_details: str,
             local_adg_auto_failover_max_data_loss_limit: int,
             local_disaster_recovery_type: str,
             local_standby_dbs: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseLocalStandbyDbResult'],
             long_term_backup_schedules: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseLongTermBackupScheduleResult'],
             max_cpu_core_count: int,
             memory_per_oracle_compute_unit_in_gbs: int,
             ncharacter_set: str,
             next_long_term_backup_time_stamp: str,
             nsg_ids: Sequence[str],
             ocpu_count: float,
             open_mode: str,
             operations_insights_status: str,
             peer_db_ids: Sequence[str],
             permission_level: str,
             private_endpoint: str,
             private_endpoint_ip: str,
             private_endpoint_label: str,
             provisionable_cpuses: Sequence[float],
             refreshable_mode: str,
             refreshable_status: str,
             remote_disaster_recovery_configurations: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseRemoteDisasterRecoveryConfigurationResult'],
             remote_disaster_recovery_type: str,
             resource_pool_leader_id: str,
             resource_pool_summaries: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseResourcePoolSummaryResult'],
             role: str,
             rotate_key_trigger: bool,
             scheduled_operations: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseScheduledOperationResult'],
             secret_id: str,
             secret_version_number: int,
             service_console_url: str,
             source: str,
             source_id: str,
             standby_dbs: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseStandbyDbResult'],
             standby_whitelisted_ips: Sequence[str],
             state: str,
             subnet_id: str,
             supported_regions_to_clone_tos: Sequence[str],
             switchover_to: str,
             switchover_to_remote_peer_id: str,
             system_tags: Mapping[str, Any],
             time_created: str,
             time_data_guard_role_changed: str,
             time_deletion_of_free_autonomous_database: str,
             time_disaster_recovery_role_changed: str,
             time_local_data_guard_enabled: str,
             time_maintenance_begin: str,
             time_maintenance_end: str,
             time_of_joining_resource_pool: str,
             time_of_last_failover: str,
             time_of_last_refresh: str,
             time_of_last_refresh_point: str,
             time_of_last_switchover: str,
             time_of_next_refresh: str,
             time_reclamation_of_free_autonomous_database: str,
             time_until_reconnect_clone_enabled: str,
             timestamp: str,
             total_backup_storage_size_in_gbs: float,
             use_latest_available_backup_time_stamp: bool,
             used_data_storage_size_in_gbs: int,
             used_data_storage_size_in_tbs: int,
             vault_id: str,
             whitelisted_ips: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("actual_used_data_storage_size_in_tbs", actual_used_data_storage_size_in_tbs)
        _setter("admin_password", admin_password)
        _setter("allocated_storage_size_in_tbs", allocated_storage_size_in_tbs)
        _setter("apex_details", apex_details)
        _setter("are_primary_whitelisted_ips_used", are_primary_whitelisted_ips_used)
        _setter("autonomous_container_database_id", autonomous_container_database_id)
        _setter("autonomous_database_backup_id", autonomous_database_backup_id)
        _setter("autonomous_database_id", autonomous_database_id)
        _setter("autonomous_maintenance_schedule_type", autonomous_maintenance_schedule_type)
        _setter("available_upgrade_versions", available_upgrade_versions)
        _setter("backup_configs", backup_configs)
        _setter("backup_retention_period_in_days", backup_retention_period_in_days)
        _setter("character_set", character_set)
        _setter("clone_type", clone_type)
        _setter("compartment_id", compartment_id)
        _setter("compute_count", compute_count)
        _setter("compute_model", compute_model)
        _setter("connection_strings", connection_strings)
        _setter("connection_urls", connection_urls)
        _setter("cpu_core_count", cpu_core_count)
        _setter("customer_contacts", customer_contacts)
        _setter("data_safe_status", data_safe_status)
        _setter("data_storage_size_in_gb", data_storage_size_in_gb)
        _setter("data_storage_size_in_tbs", data_storage_size_in_tbs)
        _setter("database_edition", database_edition)
        _setter("database_management_status", database_management_status)
        _setter("dataguard_region_type", dataguard_region_type)
        _setter("db_name", db_name)
        _setter("db_version", db_version)
        _setter("db_workload", db_workload)
        _setter("defined_tags", defined_tags)
        _setter("disaster_recovery_region_type", disaster_recovery_region_type)
        _setter("display_name", display_name)
        _setter("failed_data_recovery_in_seconds", failed_data_recovery_in_seconds)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("in_memory_area_in_gbs", in_memory_area_in_gbs)
        _setter("in_memory_percentage", in_memory_percentage)
        _setter("infrastructure_type", infrastructure_type)
        _setter("is_access_control_enabled", is_access_control_enabled)
        _setter("is_auto_scaling_enabled", is_auto_scaling_enabled)
        _setter("is_auto_scaling_for_storage_enabled", is_auto_scaling_for_storage_enabled)
        _setter("is_data_guard_enabled", is_data_guard_enabled)
        _setter("is_dedicated", is_dedicated)
        _setter("is_free_tier", is_free_tier)
        _setter("is_local_data_guard_enabled", is_local_data_guard_enabled)
        _setter("is_mtls_connection_required", is_mtls_connection_required)
        _setter("is_preview", is_preview)
        _setter("is_preview_version_with_service_terms_accepted", is_preview_version_with_service_terms_accepted)
        _setter("is_reconnect_clone_enabled", is_reconnect_clone_enabled)
        _setter("is_refreshable_clone", is_refreshable_clone)
        _setter("is_remote_data_guard_enabled", is_remote_data_guard_enabled)
        _setter("is_shrink_only", is_shrink_only)
        _setter("key_history_entries", key_history_entries)
        _setter("key_store_id", key_store_id)
        _setter("key_store_wallet_name", key_store_wallet_name)
        _setter("kms_key_id", kms_key_id)
        _setter("kms_key_lifecycle_details", kms_key_lifecycle_details)
        _setter("kms_key_version_id", kms_key_version_id)
        _setter("license_model", license_model)
        _setter("lifecycle_details", lifecycle_details)
        _setter("local_adg_auto_failover_max_data_loss_limit", local_adg_auto_failover_max_data_loss_limit)
        _setter("local_disaster_recovery_type", local_disaster_recovery_type)
        _setter("local_standby_dbs", local_standby_dbs)
        _setter("long_term_backup_schedules", long_term_backup_schedules)
        _setter("max_cpu_core_count", max_cpu_core_count)
        _setter("memory_per_oracle_compute_unit_in_gbs", memory_per_oracle_compute_unit_in_gbs)
        _setter("ncharacter_set", ncharacter_set)
        _setter("next_long_term_backup_time_stamp", next_long_term_backup_time_stamp)
        _setter("nsg_ids", nsg_ids)
        _setter("ocpu_count", ocpu_count)
        _setter("open_mode", open_mode)
        _setter("operations_insights_status", operations_insights_status)
        _setter("peer_db_ids", peer_db_ids)
        _setter("permission_level", permission_level)
        _setter("private_endpoint", private_endpoint)
        _setter("private_endpoint_ip", private_endpoint_ip)
        _setter("private_endpoint_label", private_endpoint_label)
        _setter("provisionable_cpuses", provisionable_cpuses)
        _setter("refreshable_mode", refreshable_mode)
        _setter("refreshable_status", refreshable_status)
        _setter("remote_disaster_recovery_configurations", remote_disaster_recovery_configurations)
        _setter("remote_disaster_recovery_type", remote_disaster_recovery_type)
        _setter("resource_pool_leader_id", resource_pool_leader_id)
        _setter("resource_pool_summaries", resource_pool_summaries)
        _setter("role", role)
        _setter("rotate_key_trigger", rotate_key_trigger)
        _setter("scheduled_operations", scheduled_operations)
        _setter("secret_id", secret_id)
        _setter("secret_version_number", secret_version_number)
        _setter("service_console_url", service_console_url)
        _setter("source", source)
        _setter("source_id", source_id)
        _setter("standby_dbs", standby_dbs)
        _setter("standby_whitelisted_ips", standby_whitelisted_ips)
        _setter("state", state)
        _setter("subnet_id", subnet_id)
        _setter("supported_regions_to_clone_tos", supported_regions_to_clone_tos)
        _setter("switchover_to", switchover_to)
        _setter("switchover_to_remote_peer_id", switchover_to_remote_peer_id)
        _setter("system_tags", system_tags)
        _setter("time_created", time_created)
        _setter("time_data_guard_role_changed", time_data_guard_role_changed)
        _setter("time_deletion_of_free_autonomous_database", time_deletion_of_free_autonomous_database)
        _setter("time_disaster_recovery_role_changed", time_disaster_recovery_role_changed)
        _setter("time_local_data_guard_enabled", time_local_data_guard_enabled)
        _setter("time_maintenance_begin", time_maintenance_begin)
        _setter("time_maintenance_end", time_maintenance_end)
        _setter("time_of_joining_resource_pool", time_of_joining_resource_pool)
        _setter("time_of_last_failover", time_of_last_failover)
        _setter("time_of_last_refresh", time_of_last_refresh)
        _setter("time_of_last_refresh_point", time_of_last_refresh_point)
        _setter("time_of_last_switchover", time_of_last_switchover)
        _setter("time_of_next_refresh", time_of_next_refresh)
        _setter("time_reclamation_of_free_autonomous_database", time_reclamation_of_free_autonomous_database)
        _setter("time_until_reconnect_clone_enabled", time_until_reconnect_clone_enabled)
        _setter("timestamp", timestamp)
        _setter("total_backup_storage_size_in_gbs", total_backup_storage_size_in_gbs)
        _setter("use_latest_available_backup_time_stamp", use_latest_available_backup_time_stamp)
        _setter("used_data_storage_size_in_gbs", used_data_storage_size_in_gbs)
        _setter("used_data_storage_size_in_tbs", used_data_storage_size_in_tbs)
        _setter("vault_id", vault_id)
        _setter("whitelisted_ips", whitelisted_ips)

    @property
    @pulumi.getter(name="actualUsedDataStorageSizeInTbs")
    def actual_used_data_storage_size_in_tbs(self) -> float:
        """
        The current amount of storage in use for user and system data, in terabytes (TB).
        """
        return pulumi.get(self, "actual_used_data_storage_size_in_tbs")

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> str:
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="allocatedStorageSizeInTbs")
    def allocated_storage_size_in_tbs(self) -> float:
        """
        The amount of storage currently allocated for the database tables and billed for, rounded up. When auto-scaling is not enabled, this value is equal to the `dataStorageSizeInTBs` value. You can compare this value to the `actualUsedDataStorageSizeInTBs` value to determine if a manual shrink operation is appropriate for your allocated storage.
        """
        return pulumi.get(self, "allocated_storage_size_in_tbs")

    @property
    @pulumi.getter(name="apexDetails")
    def apex_details(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseApexDetailResult']:
        """
        Information about Oracle APEX Application Development.
        """
        return pulumi.get(self, "apex_details")

    @property
    @pulumi.getter(name="arePrimaryWhitelistedIpsUsed")
    def are_primary_whitelisted_ips_used(self) -> bool:
        """
        This field will be null if the Autonomous Database is not Data Guard enabled or Access Control is disabled. It's value would be `TRUE` if Autonomous Database is Data Guard enabled and Access Control is enabled and if the Autonomous Database uses primary IP access control list (ACL) for standby. It's value would be `FALSE` if Autonomous Database is Data Guard enabled and Access Control is enabled and if the Autonomous Database uses different IP access control list (ACL) for standby compared to primary.
        """
        return pulumi.get(self, "are_primary_whitelisted_ips_used")

    @property
    @pulumi.getter(name="autonomousContainerDatabaseId")
    def autonomous_container_database_id(self) -> str:
        """
        The Autonomous Container Database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "autonomous_container_database_id")

    @property
    @pulumi.getter(name="autonomousDatabaseBackupId")
    def autonomous_database_backup_id(self) -> str:
        return pulumi.get(self, "autonomous_database_backup_id")

    @property
    @pulumi.getter(name="autonomousDatabaseId")
    def autonomous_database_id(self) -> str:
        return pulumi.get(self, "autonomous_database_id")

    @property
    @pulumi.getter(name="autonomousMaintenanceScheduleType")
    def autonomous_maintenance_schedule_type(self) -> str:
        """
        The maintenance schedule type of the Autonomous Database on shared Exadata infrastructure. The EARLY maintenance schedule of this Autonomous Database follows a schedule that applies patches prior to the REGULAR schedule.The REGULAR maintenance schedule of this Autonomous Database follows the normal cycle.
        """
        return pulumi.get(self, "autonomous_maintenance_schedule_type")

    @property
    @pulumi.getter(name="availableUpgradeVersions")
    def available_upgrade_versions(self) -> Sequence[str]:
        """
        List of Oracle Database versions available for a database upgrade. If there are no version upgrades available, this list is empty.
        """
        return pulumi.get(self, "available_upgrade_versions")

    @property
    @pulumi.getter(name="backupConfigs")
    def backup_configs(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseBackupConfigResult']:
        """
        Autonomous Database configuration details for storing [manual backups](https://docs.oracle.com/en/cloud/paas/autonomous-database/adbsa/backup-restore.html#GUID-9035DFB8-4702-4CEB-8281-C2A303820809) in the [Object Storage](https://docs.cloud.oracle.com/iaas/Content/Object/Concepts/objectstorageoverview.htm) service.
        """
        return pulumi.get(self, "backup_configs")

    @property
    @pulumi.getter(name="backupRetentionPeriodInDays")
    def backup_retention_period_in_days(self) -> int:
        """
        Retention period, in days, for backups.
        """
        return pulumi.get(self, "backup_retention_period_in_days")

    @property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> str:
        """
        The character set for the autonomous database.  The default is AL32UTF8. Allowed values are:
        """
        return pulumi.get(self, "character_set")

    @property
    @pulumi.getter(name="cloneType")
    def clone_type(self) -> str:
        return pulumi.get(self, "clone_type")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="computeCount")
    def compute_count(self) -> float:
        """
        The compute amount available to the database. Minimum and maximum values depend on the compute model and whether the database is on Shared or Dedicated infrastructure. For an Autonomous Database on Shared infrastructure, the 'ECPU' compute model requires values in multiples of two. Required when using the `computeModel` parameter. When using `cpuCoreCount` parameter, it is an error to specify computeCount to a non-null value.
        """
        return pulumi.get(self, "compute_count")

    @property
    @pulumi.getter(name="computeModel")
    def compute_model(self) -> str:
        """
        The compute model of the Autonomous Database. This is required if using the `computeCount` parameter. If using `cpuCoreCount` then it is an error to specify `computeModel` to a non-null value.
        """
        return pulumi.get(self, "compute_model")

    @property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseConnectionStringResult']:
        """
        The connection string used to connect to the Autonomous Database. The username for the Service Console is ADMIN. Use the password you entered when creating the Autonomous Database for the password value.
        """
        return pulumi.get(self, "connection_strings")

    @property
    @pulumi.getter(name="connectionUrls")
    def connection_urls(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseConnectionUrlResult']:
        """
        The URLs for accessing Oracle Application Express (APEX) and SQL Developer Web with a browser from a Compute instance within your VCN or that has a direct connection to your VCN. Note that these URLs are provided by the console only for databases on [dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html).  Example: `{"sqlDevWebUrl": "https://<hostname>/ords...", "apexUrl", "https://<hostname>/ords..."}`
        """
        return pulumi.get(self, "connection_urls")

    @property
    @pulumi.getter(name="cpuCoreCount")
    def cpu_core_count(self) -> int:
        """
        The number of OCPU cores to be made available to the database. When the ECPU is selected, the value for cpuCoreCount is 0. For Autonomous Databases on dedicated Exadata infrastructure, the maximum number of cores is determined by the infrastructure shape. See [Characteristics of Infrastructure Shapes](https://www.oracle.com/pls/topic/lookup?ctx=en/cloud/paas/autonomous-database&id=ATPFG-GUID-B0F033C1-CC5A-42F0-B2E7-3CECFEDA1FD1) for shape details.
        """
        return pulumi.get(self, "cpu_core_count")

    @property
    @pulumi.getter(name="customerContacts")
    def customer_contacts(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseCustomerContactResult']:
        """
        Customer Contacts.
        """
        return pulumi.get(self, "customer_contacts")

    @property
    @pulumi.getter(name="dataSafeStatus")
    def data_safe_status(self) -> str:
        """
        Status of the Data Safe registration for this Autonomous Database. Could be REGISTERED or NOT_REGISTERED.
        """
        return pulumi.get(self, "data_safe_status")

    @property
    @pulumi.getter(name="dataStorageSizeInGb")
    def data_storage_size_in_gb(self) -> int:
        """
        The quantity of data in the database, in gigabytes.
        """
        return pulumi.get(self, "data_storage_size_in_gb")

    @property
    @pulumi.getter(name="dataStorageSizeInTbs")
    def data_storage_size_in_tbs(self) -> int:
        """
        The quantity of data in the database, in terabytes.
        """
        return pulumi.get(self, "data_storage_size_in_tbs")

    @property
    @pulumi.getter(name="databaseEdition")
    def database_edition(self) -> str:
        """
        The Oracle Database Edition that applies to the Autonomous databases.
        """
        return pulumi.get(self, "database_edition")

    @property
    @pulumi.getter(name="databaseManagementStatus")
    def database_management_status(self) -> str:
        """
        Status of Database Management for this Autonomous Database.
        """
        return pulumi.get(self, "database_management_status")

    @property
    @pulumi.getter(name="dataguardRegionType")
    def dataguard_region_type(self) -> str:
        """
        The Autonomous Data Guard region type of the Autonomous Database. For Autonomous Databases on shared Exadata infrastructure, Data Guard associations have designated primary and standby regions, and these region types do not change when the database changes roles. The standby regions in Data Guard associations can be the same region designated as the primary region, or they can be remote regions. Certain database administrative operations may be available only in the primary region of the Data Guard association, and cannot be performed when the database using the "primary" role is operating in a remote Data Guard standby region.
        """
        return pulumi.get(self, "dataguard_region_type")

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> str:
        """
        The database name.
        """
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> str:
        """
        A filter to return only autonomous database resources that match the specified dbVersion.
        """
        return pulumi.get(self, "db_version")

    @property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> str:
        """
        A filter to return only autonomous database resources that match the specified workload type.
        """
        return pulumi.get(self, "db_workload")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="disasterRecoveryRegionType")
    def disaster_recovery_region_type(self) -> str:
        """
        The disaster recovery (DR) region type of the Autonomous Database. For Shared Autonomous Databases, DR associations have designated primary and standby regions. These region types do not change when the database changes roles. The standby region in DR associations can be the same region as the primary region, or they can be in a remote regions. Some database administration operations may be available only in the primary region of the DR association, and cannot be performed when the database using the primary role is operating in a remote region.
        """
        return pulumi.get(self, "disaster_recovery_region_type")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="failedDataRecoveryInSeconds")
    def failed_data_recovery_in_seconds(self) -> int:
        """
        Indicates the number of seconds of data loss for a Data Guard failover.
        """
        return pulumi.get(self, "failed_data_recovery_in_seconds")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="inMemoryAreaInGbs")
    def in_memory_area_in_gbs(self) -> int:
        """
        The area assigned to In-Memory tables in Autonomous Database.
        """
        return pulumi.get(self, "in_memory_area_in_gbs")

    @property
    @pulumi.getter(name="inMemoryPercentage")
    def in_memory_percentage(self) -> int:
        """
        The percentage of the System Global Area(SGA) assigned to In-Memory tables in Autonomous Database.
        """
        return pulumi.get(self, "in_memory_percentage")

    @property
    @pulumi.getter(name="infrastructureType")
    def infrastructure_type(self) -> str:
        """
        A filter to return only resources that match the given Infrastructure Type.
        """
        return pulumi.get(self, "infrastructure_type")

    @property
    @pulumi.getter(name="isAccessControlEnabled")
    def is_access_control_enabled(self) -> bool:
        """
        Indicates if the database-level access control is enabled. If disabled, database access is defined by the network security rules. If enabled, database access is restricted to the IP addresses defined by the rules specified with the `whitelistedIps` property. While specifying `whitelistedIps` rules is optional, if database-level access control is enabled and no rules are specified, the database will become inaccessible. The rules can be added later using the `UpdateAutonomousDatabase` API operation or edit option in console. When creating a database clone, the desired access control setting should be specified. By default, database-level access control will be disabled for the clone.
        """
        return pulumi.get(self, "is_access_control_enabled")

    @property
    @pulumi.getter(name="isAutoScalingEnabled")
    def is_auto_scaling_enabled(self) -> bool:
        """
        Indicates if auto scaling is enabled for the Autonomous Database CPU core count.
        """
        return pulumi.get(self, "is_auto_scaling_enabled")

    @property
    @pulumi.getter(name="isAutoScalingForStorageEnabled")
    def is_auto_scaling_for_storage_enabled(self) -> bool:
        """
        Indicates if auto scaling is enabled for the Autonomous Database storage. The default value is `FALSE`.
        """
        return pulumi.get(self, "is_auto_scaling_for_storage_enabled")

    @property
    @pulumi.getter(name="isDataGuardEnabled")
    def is_data_guard_enabled(self) -> bool:
        """
        A filter to return only resources that have Data Guard enabled.
        """
        return pulumi.get(self, "is_data_guard_enabled")

    @property
    @pulumi.getter(name="isDedicated")
    def is_dedicated(self) -> bool:
        """
        True if the database uses [dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html).
        """
        return pulumi.get(self, "is_dedicated")

    @property
    @pulumi.getter(name="isFreeTier")
    def is_free_tier(self) -> bool:
        """
        Filter on the value of the resource's 'isFreeTier' property. A value of `true` returns only Always Free resources. A value of `false` excludes Always Free resources from the returned results. Omitting this parameter returns both Always Free and paid resources.
        """
        return pulumi.get(self, "is_free_tier")

    @property
    @pulumi.getter(name="isLocalDataGuardEnabled")
    def is_local_data_guard_enabled(self) -> bool:
        """
        Indicates whether the Autonomous Database has local (in-region) Data Guard enabled. Not applicable to cross-region Autonomous Data Guard associations, or to Autonomous Databases using dedicated Exadata infrastructure or Exadata Cloud@Customer infrastructure.
        """
        return pulumi.get(self, "is_local_data_guard_enabled")

    @property
    @pulumi.getter(name="isMtlsConnectionRequired")
    def is_mtls_connection_required(self) -> bool:
        """
        Specifies if the Autonomous Database requires mTLS connections.
        """
        return pulumi.get(self, "is_mtls_connection_required")

    @property
    @pulumi.getter(name="isPreview")
    def is_preview(self) -> bool:
        """
        Indicates if the Autonomous Database version is a preview version.
        """
        return pulumi.get(self, "is_preview")

    @property
    @pulumi.getter(name="isPreviewVersionWithServiceTermsAccepted")
    def is_preview_version_with_service_terms_accepted(self) -> bool:
        return pulumi.get(self, "is_preview_version_with_service_terms_accepted")

    @property
    @pulumi.getter(name="isReconnectCloneEnabled")
    def is_reconnect_clone_enabled(self) -> bool:
        """
        Indicates if the refreshable clone can be reconnected to its source database.
        """
        return pulumi.get(self, "is_reconnect_clone_enabled")

    @property
    @pulumi.getter(name="isRefreshableClone")
    def is_refreshable_clone(self) -> bool:
        """
        Filter on the value of the resource's 'isRefreshableClone' property. A value of `true` returns only refreshable clones. A value of `false` excludes refreshable clones from the returned results. Omitting this parameter returns both refreshable clones and databases that are not refreshable clones.
        """
        return pulumi.get(self, "is_refreshable_clone")

    @property
    @pulumi.getter(name="isRemoteDataGuardEnabled")
    def is_remote_data_guard_enabled(self) -> bool:
        """
        Indicates whether the Autonomous Database has Cross Region Data Guard enabled. Not applicable to Autonomous Databases using dedicated Exadata infrastructure or Exadata Cloud@Customer infrastructure.
        """
        return pulumi.get(self, "is_remote_data_guard_enabled")

    @property
    @pulumi.getter(name="isShrinkOnly")
    def is_shrink_only(self) -> bool:
        return pulumi.get(self, "is_shrink_only")

    @property
    @pulumi.getter(name="keyHistoryEntries")
    def key_history_entries(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseKeyHistoryEntryResult']:
        """
        Key History Entry.
        """
        return pulumi.get(self, "key_history_entries")

    @property
    @pulumi.getter(name="keyStoreId")
    def key_store_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        """
        return pulumi.get(self, "key_store_id")

    @property
    @pulumi.getter(name="keyStoreWalletName")
    def key_store_wallet_name(self) -> str:
        """
        The wallet name for Oracle Key Vault.
        """
        return pulumi.get(self, "key_store_wallet_name")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="kmsKeyLifecycleDetails")
    def kms_key_lifecycle_details(self) -> str:
        """
        KMS key lifecycle details.
        """
        return pulumi.get(self, "kms_key_lifecycle_details")

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> str:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        """
        return pulumi.get(self, "kms_key_version_id")

    @property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> str:
        """
        The Oracle license model that applies to the Oracle Autonomous Database. Bring your own license (BYOL) allows you to apply your current on-premises Oracle software licenses to equivalent, highly automated Oracle PaaS and IaaS services in the cloud. License Included allows you to subscribe to new Oracle Database software licenses and the Database service. Note that when provisioning an Autonomous Database on [dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html), this attribute must be null because the attribute is already set at the Autonomous Exadata Infrastructure level. When using [shared Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html), if a value is not specified, the system will supply the value of `BRING_YOUR_OWN_LICENSE`.
        """
        return pulumi.get(self, "license_model")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="localAdgAutoFailoverMaxDataLossLimit")
    def local_adg_auto_failover_max_data_loss_limit(self) -> int:
        """
        Parameter that allows users to select an acceptable maximum data loss limit in seconds, up to which Automatic Failover will be triggered when necessary for a Local Autonomous Data Guard
        """
        return pulumi.get(self, "local_adg_auto_failover_max_data_loss_limit")

    @property
    @pulumi.getter(name="localDisasterRecoveryType")
    def local_disaster_recovery_type(self) -> str:
        """
        Indicates the local disaster recovery (DR) type of the Shared Autonomous Database. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
        """
        return pulumi.get(self, "local_disaster_recovery_type")

    @property
    @pulumi.getter(name="localStandbyDbs")
    def local_standby_dbs(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseLocalStandbyDbResult']:
        """
        Autonomous Data Guard standby database details.
        """
        return pulumi.get(self, "local_standby_dbs")

    @property
    @pulumi.getter(name="longTermBackupSchedules")
    def long_term_backup_schedules(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseLongTermBackupScheduleResult']:
        """
        Details for the long-term backup schedule.
        """
        return pulumi.get(self, "long_term_backup_schedules")

    @property
    @pulumi.getter(name="maxCpuCoreCount")
    def max_cpu_core_count(self) -> int:
        """
        The number of Max OCPU cores to be made available to the autonomous database with auto scaling of cpu enabled.
        """
        return pulumi.get(self, "max_cpu_core_count")

    @property
    @pulumi.getter(name="memoryPerOracleComputeUnitInGbs")
    def memory_per_oracle_compute_unit_in_gbs(self) -> int:
        """
        The amount of memory (in GBs) enabled per OCPU or ECPU.
        """
        return pulumi.get(self, "memory_per_oracle_compute_unit_in_gbs")

    @property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> str:
        """
        The national character set for the autonomous database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        """
        return pulumi.get(self, "ncharacter_set")

    @property
    @pulumi.getter(name="nextLongTermBackupTimeStamp")
    def next_long_term_backup_time_stamp(self) -> str:
        """
        The date and time when the next long-term backup would be created.
        """
        return pulumi.get(self, "next_long_term_backup_time_stamp")

    @property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Sequence[str]:
        """
        The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the network security groups (NSGs) to which this resource belongs. Setting this to an empty list removes all resources from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). **NsgIds restrictions:**
        * A network security group (NSG) is optional for Autonomous Databases with private access. The nsgIds list can be empty.
        """
        return pulumi.get(self, "nsg_ids")

    @property
    @pulumi.getter(name="ocpuCount")
    def ocpu_count(self) -> float:
        """
        The number of OCPU cores to be made available to the database.
        """
        return pulumi.get(self, "ocpu_count")

    @property
    @pulumi.getter(name="openMode")
    def open_mode(self) -> str:
        """
        Indicates the Autonomous Database mode. The database can be opened in `READ_ONLY` or `READ_WRITE` mode.
        """
        return pulumi.get(self, "open_mode")

    @property
    @pulumi.getter(name="operationsInsightsStatus")
    def operations_insights_status(self) -> str:
        """
        Status of Operations Insights for this Autonomous Database.
        """
        return pulumi.get(self, "operations_insights_status")

    @property
    @pulumi.getter(name="peerDbIds")
    def peer_db_ids(self) -> Sequence[str]:
        """
        The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of standby databases located in Autonomous Data Guard remote regions that are associated with the source database. Note that for shared Exadata infrastructure, standby databases located in the same region as the source primary database do not have OCIDs.
        """
        return pulumi.get(self, "peer_db_ids")

    @property
    @pulumi.getter(name="permissionLevel")
    def permission_level(self) -> str:
        """
        The Autonomous Database permission level. Restricted mode allows access only by admin users.
        """
        return pulumi.get(self, "permission_level")

    @property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> str:
        """
        The private endpoint for the resource.
        """
        return pulumi.get(self, "private_endpoint")

    @property
    @pulumi.getter(name="privateEndpointIp")
    def private_endpoint_ip(self) -> str:
        """
        The private endpoint Ip address for the resource.
        """
        return pulumi.get(self, "private_endpoint_ip")

    @property
    @pulumi.getter(name="privateEndpointLabel")
    def private_endpoint_label(self) -> str:
        """
        The private endpoint label for the resource.
        """
        return pulumi.get(self, "private_endpoint_label")

    @property
    @pulumi.getter(name="provisionableCpuses")
    def provisionable_cpuses(self) -> Sequence[float]:
        """
        An array of CPU values that an Autonomous Database can be scaled to.
        """
        return pulumi.get(self, "provisionable_cpuses")

    @property
    @pulumi.getter(name="refreshableMode")
    def refreshable_mode(self) -> str:
        """
        The refresh mode of the clone. AUTOMATIC indicates that the clone is automatically being refreshed with data from the source Autonomous Database.
        """
        return pulumi.get(self, "refreshable_mode")

    @property
    @pulumi.getter(name="refreshableStatus")
    def refreshable_status(self) -> str:
        """
        The refresh status of the clone. REFRESHING indicates that the clone is currently being refreshed with data from the source Autonomous Database.
        """
        return pulumi.get(self, "refreshable_status")

    @property
    @pulumi.getter(name="remoteDisasterRecoveryConfigurations")
    def remote_disaster_recovery_configurations(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseRemoteDisasterRecoveryConfigurationResult']:
        """
        Configurations of a Disaster Recovery.
        """
        return pulumi.get(self, "remote_disaster_recovery_configurations")

    @property
    @pulumi.getter(name="remoteDisasterRecoveryType")
    def remote_disaster_recovery_type(self) -> str:
        return pulumi.get(self, "remote_disaster_recovery_type")

    @property
    @pulumi.getter(name="resourcePoolLeaderId")
    def resource_pool_leader_id(self) -> str:
        """
        The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the resourcepool Leader Autonomous Database.
        """
        return pulumi.get(self, "resource_pool_leader_id")

    @property
    @pulumi.getter(name="resourcePoolSummaries")
    def resource_pool_summaries(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseResourcePoolSummaryResult']:
        """
        The configuration details for resource pool
        """
        return pulumi.get(self, "resource_pool_summaries")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter(name="rotateKeyTrigger")
    def rotate_key_trigger(self) -> bool:
        return pulumi.get(self, "rotate_key_trigger")

    @property
    @pulumi.getter(name="scheduledOperations")
    def scheduled_operations(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseScheduledOperationResult']:
        """
        The list of scheduled operations.
        """
        return pulumi.get(self, "scheduled_operations")

    @property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> str:
        return pulumi.get(self, "secret_id")

    @property
    @pulumi.getter(name="secretVersionNumber")
    def secret_version_number(self) -> int:
        return pulumi.get(self, "secret_version_number")

    @property
    @pulumi.getter(name="serviceConsoleUrl")
    def service_console_url(self) -> str:
        """
        The URL of the Service Console for the Autonomous Database.
        """
        return pulumi.get(self, "service_console_url")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the source Autonomous Database that was cloned to create the current Autonomous Database.
        """
        return pulumi.get(self, "source_id")

    @property
    @pulumi.getter(name="standbyDbs")
    def standby_dbs(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseStandbyDbResult']:
        """
        **Deprecated** Autonomous Data Guard standby database details.
        """
        return pulumi.get(self, "standby_dbs")

    @property
    @pulumi.getter(name="standbyWhitelistedIps")
    def standby_whitelisted_ips(self) -> Sequence[str]:
        """
        The client IP access control list (ACL). This feature is available for autonomous databases on [shared Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html) and on Exadata Cloud@Customer. Only clients connecting from an IP address included in the ACL may access the Autonomous Database instance.
        """
        return pulumi.get(self, "standby_whitelisted_ips")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet the resource is associated with.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="supportedRegionsToCloneTos")
    def supported_regions_to_clone_tos(self) -> Sequence[str]:
        """
        The list of regions that support the creation of an Autonomous Database clone or an Autonomous Data Guard standby database.
        """
        return pulumi.get(self, "supported_regions_to_clone_tos")

    @property
    @pulumi.getter(name="switchoverTo")
    def switchover_to(self) -> str:
        return pulumi.get(self, "switchover_to")

    @property
    @pulumi.getter(name="switchoverToRemotePeerId")
    def switchover_to_remote_peer_id(self) -> str:
        return pulumi.get(self, "switchover_to_remote_peer_id")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the Autonomous Database was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeDataGuardRoleChanged")
    def time_data_guard_role_changed(self) -> str:
        """
        The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        """
        return pulumi.get(self, "time_data_guard_role_changed")

    @property
    @pulumi.getter(name="timeDeletionOfFreeAutonomousDatabase")
    def time_deletion_of_free_autonomous_database(self) -> str:
        """
        The date and time the Always Free database will be automatically deleted because of inactivity. If the database is in the STOPPED state and without activity until this time, it will be deleted.
        """
        return pulumi.get(self, "time_deletion_of_free_autonomous_database")

    @property
    @pulumi.getter(name="timeDisasterRecoveryRoleChanged")
    def time_disaster_recovery_role_changed(self) -> str:
        """
        The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        return pulumi.get(self, "time_disaster_recovery_role_changed")

    @property
    @pulumi.getter(name="timeLocalDataGuardEnabled")
    def time_local_data_guard_enabled(self) -> str:
        """
        The date and time that Autonomous Data Guard was enabled for an Autonomous Database where the standby was provisioned in the same region as the primary database.
        """
        return pulumi.get(self, "time_local_data_guard_enabled")

    @property
    @pulumi.getter(name="timeMaintenanceBegin")
    def time_maintenance_begin(self) -> str:
        """
        The date and time when maintenance will begin.
        """
        return pulumi.get(self, "time_maintenance_begin")

    @property
    @pulumi.getter(name="timeMaintenanceEnd")
    def time_maintenance_end(self) -> str:
        """
        The date and time when maintenance will end.
        """
        return pulumi.get(self, "time_maintenance_end")

    @property
    @pulumi.getter(name="timeOfJoiningResourcePool")
    def time_of_joining_resource_pool(self) -> str:
        """
        The time the member joined the resource pool.
        """
        return pulumi.get(self, "time_of_joining_resource_pool")

    @property
    @pulumi.getter(name="timeOfLastFailover")
    def time_of_last_failover(self) -> str:
        """
        The timestamp of the last failover operation.
        """
        return pulumi.get(self, "time_of_last_failover")

    @property
    @pulumi.getter(name="timeOfLastRefresh")
    def time_of_last_refresh(self) -> str:
        """
        The date and time when last refresh happened.
        """
        return pulumi.get(self, "time_of_last_refresh")

    @property
    @pulumi.getter(name="timeOfLastRefreshPoint")
    def time_of_last_refresh_point(self) -> str:
        """
        The refresh point timestamp (UTC). The refresh point is the time to which the database was most recently refreshed. Data created after the refresh point is not included in the refresh.
        """
        return pulumi.get(self, "time_of_last_refresh_point")

    @property
    @pulumi.getter(name="timeOfLastSwitchover")
    def time_of_last_switchover(self) -> str:
        """
        The timestamp of the last switchover operation for the Autonomous Database.
        """
        return pulumi.get(self, "time_of_last_switchover")

    @property
    @pulumi.getter(name="timeOfNextRefresh")
    def time_of_next_refresh(self) -> str:
        """
        The date and time of next refresh.
        """
        return pulumi.get(self, "time_of_next_refresh")

    @property
    @pulumi.getter(name="timeReclamationOfFreeAutonomousDatabase")
    def time_reclamation_of_free_autonomous_database(self) -> str:
        """
        The date and time the Always Free database will be stopped because of inactivity. If this time is reached without any database activity, the database will automatically be put into the STOPPED state.
        """
        return pulumi.get(self, "time_reclamation_of_free_autonomous_database")

    @property
    @pulumi.getter(name="timeUntilReconnectCloneEnabled")
    def time_until_reconnect_clone_enabled(self) -> str:
        """
        The time and date as an RFC3339 formatted string, e.g., 2022-01-01T12:00:00.000Z, to set the limit for a refreshable clone to be reconnected to its source database.
        """
        return pulumi.get(self, "time_until_reconnect_clone_enabled")

    @property
    @pulumi.getter
    def timestamp(self) -> str:
        return pulumi.get(self, "timestamp")

    @property
    @pulumi.getter(name="totalBackupStorageSizeInGbs")
    def total_backup_storage_size_in_gbs(self) -> float:
        """
        The backup storage to the database.
        """
        return pulumi.get(self, "total_backup_storage_size_in_gbs")

    @property
    @pulumi.getter(name="useLatestAvailableBackupTimeStamp")
    def use_latest_available_backup_time_stamp(self) -> bool:
        return pulumi.get(self, "use_latest_available_backup_time_stamp")

    @property
    @pulumi.getter(name="usedDataStorageSizeInGbs")
    def used_data_storage_size_in_gbs(self) -> int:
        """
        The storage space consumed by Autonomous Database in GBs.
        """
        return pulumi.get(self, "used_data_storage_size_in_gbs")

    @property
    @pulumi.getter(name="usedDataStorageSizeInTbs")
    def used_data_storage_size_in_tbs(self) -> int:
        """
        The amount of storage that has been used, in terabytes.
        """
        return pulumi.get(self, "used_data_storage_size_in_tbs")

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")

    @property
    @pulumi.getter(name="whitelistedIps")
    def whitelisted_ips(self) -> Sequence[str]:
        """
        The client IP access control list (ACL). This feature is available for [Autonomous Database Serverless] (https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html) and on Exadata Cloud@Customer. Only clients connecting from an IP address included in the ACL may access the Autonomous Database instance.
        """
        return pulumi.get(self, "whitelisted_ips")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseApexDetailResult(dict):
    def __init__(__self__, *,
                 apex_version: str,
                 ords_version: str):
        """
        :param str apex_version: The Oracle APEX Application Development version.
        :param str ords_version: The Oracle REST Data Services (ORDS) version.
        """
        GetAutonomousDatabasesAutonomousDatabaseApexDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apex_version=apex_version,
            ords_version=ords_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apex_version: str,
             ords_version: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("apex_version", apex_version)
        _setter("ords_version", ords_version)

    @property
    @pulumi.getter(name="apexVersion")
    def apex_version(self) -> str:
        """
        The Oracle APEX Application Development version.
        """
        return pulumi.get(self, "apex_version")

    @property
    @pulumi.getter(name="ordsVersion")
    def ords_version(self) -> str:
        """
        The Oracle REST Data Services (ORDS) version.
        """
        return pulumi.get(self, "ords_version")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseBackupConfigResult(dict):
    def __init__(__self__, *,
                 manual_backup_bucket_name: str,
                 manual_backup_type: str):
        """
        :param str manual_backup_bucket_name: Name of [Object Storage](https://docs.cloud.oracle.com/iaas/Content/Object/Concepts/objectstorageoverview.htm) bucket to use for storing manual backups.
        :param str manual_backup_type: The manual backup destination type.
        """
        GetAutonomousDatabasesAutonomousDatabaseBackupConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            manual_backup_bucket_name=manual_backup_bucket_name,
            manual_backup_type=manual_backup_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             manual_backup_bucket_name: str,
             manual_backup_type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("manual_backup_bucket_name", manual_backup_bucket_name)
        _setter("manual_backup_type", manual_backup_type)

    @property
    @pulumi.getter(name="manualBackupBucketName")
    def manual_backup_bucket_name(self) -> str:
        """
        Name of [Object Storage](https://docs.cloud.oracle.com/iaas/Content/Object/Concepts/objectstorageoverview.htm) bucket to use for storing manual backups.
        """
        return pulumi.get(self, "manual_backup_bucket_name")

    @property
    @pulumi.getter(name="manualBackupType")
    def manual_backup_type(self) -> str:
        """
        The manual backup destination type.
        """
        return pulumi.get(self, "manual_backup_type")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseConnectionStringResult(dict):
    def __init__(__self__, *,
                 all_connection_strings: Mapping[str, Any],
                 dedicated: str,
                 high: str,
                 low: str,
                 medium: str,
                 profiles: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseConnectionStringProfileResult']):
        """
        :param Mapping[str, Any] all_connection_strings: Returns all connection strings that can be used to connect to the Autonomous Database. For more information, please see [Predefined Database Service Names for Autonomous Transaction Processing](https://docs.oracle.com/en/cloud/paas/atp-cloud/atpug/connect-predefined.html#GUID-9747539B-FD46-44F1-8FF8-F5AC650F15BE)
        :param str dedicated: The database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        :param str high: The High database service provides the highest level of resources to each SQL statement resulting in the highest performance, but supports the fewest number of concurrent SQL statements.
        :param str low: The Low database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        :param str medium: The Medium database service provides a lower level of resources to each SQL statement potentially resulting a lower level of performance, but supports more concurrent SQL statements.
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseConnectionStringProfileArgs'] profiles: A list of connection string profiles to allow clients to group, filter and select connection string values based on structured metadata.
        """
        GetAutonomousDatabasesAutonomousDatabaseConnectionStringResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_connection_strings=all_connection_strings,
            dedicated=dedicated,
            high=high,
            low=low,
            medium=medium,
            profiles=profiles,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_connection_strings: Mapping[str, Any],
             dedicated: str,
             high: str,
             low: str,
             medium: str,
             profiles: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseConnectionStringProfileResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("all_connection_strings", all_connection_strings)
        _setter("dedicated", dedicated)
        _setter("high", high)
        _setter("low", low)
        _setter("medium", medium)
        _setter("profiles", profiles)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Mapping[str, Any]:
        """
        Returns all connection strings that can be used to connect to the Autonomous Database. For more information, please see [Predefined Database Service Names for Autonomous Transaction Processing](https://docs.oracle.com/en/cloud/paas/atp-cloud/atpug/connect-predefined.html#GUID-9747539B-FD46-44F1-8FF8-F5AC650F15BE)
        """
        return pulumi.get(self, "all_connection_strings")

    @property
    @pulumi.getter
    def dedicated(self) -> str:
        """
        The database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        """
        return pulumi.get(self, "dedicated")

    @property
    @pulumi.getter
    def high(self) -> str:
        """
        The High database service provides the highest level of resources to each SQL statement resulting in the highest performance, but supports the fewest number of concurrent SQL statements.
        """
        return pulumi.get(self, "high")

    @property
    @pulumi.getter
    def low(self) -> str:
        """
        The Low database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        """
        return pulumi.get(self, "low")

    @property
    @pulumi.getter
    def medium(self) -> str:
        """
        The Medium database service provides a lower level of resources to each SQL statement potentially resulting a lower level of performance, but supports more concurrent SQL statements.
        """
        return pulumi.get(self, "medium")

    @property
    @pulumi.getter
    def profiles(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseConnectionStringProfileResult']:
        """
        A list of connection string profiles to allow clients to group, filter and select connection string values based on structured metadata.
        """
        return pulumi.get(self, "profiles")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseConnectionStringProfileResult(dict):
    def __init__(__self__, *,
                 consumer_group: str,
                 display_name: str,
                 host_format: str,
                 protocol: str,
                 session_mode: str,
                 syntax_format: str,
                 tls_authentication: str,
                 value: str):
        """
        :param str consumer_group: Consumer group used by the connection.
        :param str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param str host_format: Host format used in connection string.
        :param str protocol: Protocol used by the connection.
        :param str session_mode: Specifies whether the listener performs a direct hand-off of the session, or redirects the session. In RAC deployments where SCAN is used, sessions are redirected to a Node VIP. Use `DIRECT` for direct hand-offs. Use `REDIRECT` to redirect the session.
        :param str syntax_format: Specifies whether the connection string is using the long (`LONG`), Easy Connect (`EZCONNECT`), or Easy Connect Plus (`EZCONNECTPLUS`) format. Autonomous Databases on shared Exadata infrastructure always use the long format.
        :param str tls_authentication: Specifies whether the TLS handshake is using one-way (`SERVER`) or mutual (`MUTUAL`) authentication.
        :param str value: Connection string value.
        """
        GetAutonomousDatabasesAutonomousDatabaseConnectionStringProfileResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            consumer_group=consumer_group,
            display_name=display_name,
            host_format=host_format,
            protocol=protocol,
            session_mode=session_mode,
            syntax_format=syntax_format,
            tls_authentication=tls_authentication,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             consumer_group: str,
             display_name: str,
             host_format: str,
             protocol: str,
             session_mode: str,
             syntax_format: str,
             tls_authentication: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("consumer_group", consumer_group)
        _setter("display_name", display_name)
        _setter("host_format", host_format)
        _setter("protocol", protocol)
        _setter("session_mode", session_mode)
        _setter("syntax_format", syntax_format)
        _setter("tls_authentication", tls_authentication)
        _setter("value", value)

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> str:
        """
        Consumer group used by the connection.
        """
        return pulumi.get(self, "consumer_group")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="hostFormat")
    def host_format(self) -> str:
        """
        Host format used in connection string.
        """
        return pulumi.get(self, "host_format")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Protocol used by the connection.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sessionMode")
    def session_mode(self) -> str:
        """
        Specifies whether the listener performs a direct hand-off of the session, or redirects the session. In RAC deployments where SCAN is used, sessions are redirected to a Node VIP. Use `DIRECT` for direct hand-offs. Use `REDIRECT` to redirect the session.
        """
        return pulumi.get(self, "session_mode")

    @property
    @pulumi.getter(name="syntaxFormat")
    def syntax_format(self) -> str:
        """
        Specifies whether the connection string is using the long (`LONG`), Easy Connect (`EZCONNECT`), or Easy Connect Plus (`EZCONNECTPLUS`) format. Autonomous Databases on shared Exadata infrastructure always use the long format.
        """
        return pulumi.get(self, "syntax_format")

    @property
    @pulumi.getter(name="tlsAuthentication")
    def tls_authentication(self) -> str:
        """
        Specifies whether the TLS handshake is using one-way (`SERVER`) or mutual (`MUTUAL`) authentication.
        """
        return pulumi.get(self, "tls_authentication")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Connection string value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseConnectionUrlResult(dict):
    def __init__(__self__, *,
                 apex_url: str,
                 graph_studio_url: str,
                 machine_learning_user_management_url: str,
                 sql_dev_web_url: str):
        """
        :param str apex_url: Oracle Application Express (APEX) URL.
        :param str graph_studio_url: The URL of the Graph Studio for the Autonomous Database.
        :param str machine_learning_user_management_url: Oracle Machine Learning user management URL.
        :param str sql_dev_web_url: Oracle SQL Developer Web URL.
        """
        GetAutonomousDatabasesAutonomousDatabaseConnectionUrlResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apex_url=apex_url,
            graph_studio_url=graph_studio_url,
            machine_learning_user_management_url=machine_learning_user_management_url,
            sql_dev_web_url=sql_dev_web_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apex_url: str,
             graph_studio_url: str,
             machine_learning_user_management_url: str,
             sql_dev_web_url: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("apex_url", apex_url)
        _setter("graph_studio_url", graph_studio_url)
        _setter("machine_learning_user_management_url", machine_learning_user_management_url)
        _setter("sql_dev_web_url", sql_dev_web_url)

    @property
    @pulumi.getter(name="apexUrl")
    def apex_url(self) -> str:
        """
        Oracle Application Express (APEX) URL.
        """
        return pulumi.get(self, "apex_url")

    @property
    @pulumi.getter(name="graphStudioUrl")
    def graph_studio_url(self) -> str:
        """
        The URL of the Graph Studio for the Autonomous Database.
        """
        return pulumi.get(self, "graph_studio_url")

    @property
    @pulumi.getter(name="machineLearningUserManagementUrl")
    def machine_learning_user_management_url(self) -> str:
        """
        Oracle Machine Learning user management URL.
        """
        return pulumi.get(self, "machine_learning_user_management_url")

    @property
    @pulumi.getter(name="sqlDevWebUrl")
    def sql_dev_web_url(self) -> str:
        """
        Oracle SQL Developer Web URL.
        """
        return pulumi.get(self, "sql_dev_web_url")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseCustomerContactResult(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        GetAutonomousDatabasesAutonomousDatabaseCustomerContactResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            email=email,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             email: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseKeyHistoryEntryResult(dict):
    def __init__(__self__, *,
                 id: str,
                 kms_key_version_id: str,
                 time_activated: str,
                 vault_id: str):
        """
        :param str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        :param str time_activated: The date and time the kms key activated.
        :param str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        GetAutonomousDatabasesAutonomousDatabaseKeyHistoryEntryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            kms_key_version_id=kms_key_version_id,
            time_activated=time_activated,
            vault_id=vault_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             kms_key_version_id: str,
             time_activated: str,
             vault_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("kms_key_version_id", kms_key_version_id)
        _setter("time_activated", time_activated)
        _setter("vault_id", vault_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> str:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        """
        return pulumi.get(self, "kms_key_version_id")

    @property
    @pulumi.getter(name="timeActivated")
    def time_activated(self) -> str:
        """
        The date and time the kms key activated.
        """
        return pulumi.get(self, "time_activated")

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseLocalStandbyDbResult(dict):
    def __init__(__self__, *,
                 lag_time_in_seconds: int,
                 lifecycle_details: str,
                 state: str,
                 time_data_guard_role_changed: str,
                 time_disaster_recovery_role_changed: str):
        """
        :param int lag_time_in_seconds: The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        :param str time_data_guard_role_changed: The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        :param str time_disaster_recovery_role_changed: The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        GetAutonomousDatabasesAutonomousDatabaseLocalStandbyDbResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lag_time_in_seconds=lag_time_in_seconds,
            lifecycle_details=lifecycle_details,
            state=state,
            time_data_guard_role_changed=time_data_guard_role_changed,
            time_disaster_recovery_role_changed=time_disaster_recovery_role_changed,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lag_time_in_seconds: int,
             lifecycle_details: str,
             state: str,
             time_data_guard_role_changed: str,
             time_disaster_recovery_role_changed: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("lag_time_in_seconds", lag_time_in_seconds)
        _setter("lifecycle_details", lifecycle_details)
        _setter("state", state)
        _setter("time_data_guard_role_changed", time_data_guard_role_changed)
        _setter("time_disaster_recovery_role_changed", time_disaster_recovery_role_changed)

    @property
    @pulumi.getter(name="lagTimeInSeconds")
    def lag_time_in_seconds(self) -> int:
        """
        The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        """
        return pulumi.get(self, "lag_time_in_seconds")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeDataGuardRoleChanged")
    def time_data_guard_role_changed(self) -> str:
        """
        The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        """
        return pulumi.get(self, "time_data_guard_role_changed")

    @property
    @pulumi.getter(name="timeDisasterRecoveryRoleChanged")
    def time_disaster_recovery_role_changed(self) -> str:
        """
        The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        return pulumi.get(self, "time_disaster_recovery_role_changed")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseLongTermBackupScheduleResult(dict):
    def __init__(__self__, *,
                 is_disabled: bool,
                 repeat_cadence: str,
                 retention_period_in_days: int,
                 time_of_backup: str):
        """
        :param bool is_disabled: Indicates if the resource pool should be deleted for the Autonomous Database.
        :param str repeat_cadence: The frequency of the long-term backup schedule
        :param int retention_period_in_days: Retention period, in days, for long-term backups
        :param str time_of_backup: The timestamp for the long-term backup schedule. For a MONTHLY cadence, months having fewer days than the provided date will have the backup taken on the last day of that month.
        """
        GetAutonomousDatabasesAutonomousDatabaseLongTermBackupScheduleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_disabled=is_disabled,
            repeat_cadence=repeat_cadence,
            retention_period_in_days=retention_period_in_days,
            time_of_backup=time_of_backup,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_disabled: bool,
             repeat_cadence: str,
             retention_period_in_days: int,
             time_of_backup: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("is_disabled", is_disabled)
        _setter("repeat_cadence", repeat_cadence)
        _setter("retention_period_in_days", retention_period_in_days)
        _setter("time_of_backup", time_of_backup)

    @property
    @pulumi.getter(name="isDisabled")
    def is_disabled(self) -> bool:
        """
        Indicates if the resource pool should be deleted for the Autonomous Database.
        """
        return pulumi.get(self, "is_disabled")

    @property
    @pulumi.getter(name="repeatCadence")
    def repeat_cadence(self) -> str:
        """
        The frequency of the long-term backup schedule
        """
        return pulumi.get(self, "repeat_cadence")

    @property
    @pulumi.getter(name="retentionPeriodInDays")
    def retention_period_in_days(self) -> int:
        """
        Retention period, in days, for long-term backups
        """
        return pulumi.get(self, "retention_period_in_days")

    @property
    @pulumi.getter(name="timeOfBackup")
    def time_of_backup(self) -> str:
        """
        The timestamp for the long-term backup schedule. For a MONTHLY cadence, months having fewer days than the provided date will have the backup taken on the last day of that month.
        """
        return pulumi.get(self, "time_of_backup")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseRemoteDisasterRecoveryConfigurationResult(dict):
    def __init__(__self__, *,
                 disaster_recovery_type: str):
        """
        :param str disaster_recovery_type: Indicates the disaster recovery (DR) type of the Shared Autonomous Database. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
        """
        GetAutonomousDatabasesAutonomousDatabaseRemoteDisasterRecoveryConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disaster_recovery_type=disaster_recovery_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disaster_recovery_type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("disaster_recovery_type", disaster_recovery_type)

    @property
    @pulumi.getter(name="disasterRecoveryType")
    def disaster_recovery_type(self) -> str:
        """
        Indicates the disaster recovery (DR) type of the Shared Autonomous Database. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
        """
        return pulumi.get(self, "disaster_recovery_type")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseResourcePoolSummaryResult(dict):
    def __init__(__self__, *,
                 is_disabled: bool,
                 pool_size: int):
        """
        :param bool is_disabled: Indicates if the resource pool should be deleted for the Autonomous Database.
        :param int pool_size: Resource pool size.
        """
        GetAutonomousDatabasesAutonomousDatabaseResourcePoolSummaryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_disabled=is_disabled,
            pool_size=pool_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_disabled: bool,
             pool_size: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("is_disabled", is_disabled)
        _setter("pool_size", pool_size)

    @property
    @pulumi.getter(name="isDisabled")
    def is_disabled(self) -> bool:
        """
        Indicates if the resource pool should be deleted for the Autonomous Database.
        """
        return pulumi.get(self, "is_disabled")

    @property
    @pulumi.getter(name="poolSize")
    def pool_size(self) -> int:
        """
        Resource pool size.
        """
        return pulumi.get(self, "pool_size")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseScheduledOperationResult(dict):
    def __init__(__self__, *,
                 day_of_weeks: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseScheduledOperationDayOfWeekResult'],
                 scheduled_start_time: str,
                 scheduled_stop_time: str):
        """
        :param Sequence['GetAutonomousDatabasesAutonomousDatabaseScheduledOperationDayOfWeekArgs'] day_of_weeks: Day of the week.
        :param str scheduled_start_time: auto start time. value must be of ISO-8601 format "HH:mm"
        :param str scheduled_stop_time: auto stop time. value must be of ISO-8601 format "HH:mm"
        """
        GetAutonomousDatabasesAutonomousDatabaseScheduledOperationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            day_of_weeks=day_of_weeks,
            scheduled_start_time=scheduled_start_time,
            scheduled_stop_time=scheduled_stop_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             day_of_weeks: Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseScheduledOperationDayOfWeekResult'],
             scheduled_start_time: str,
             scheduled_stop_time: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("day_of_weeks", day_of_weeks)
        _setter("scheduled_start_time", scheduled_start_time)
        _setter("scheduled_stop_time", scheduled_stop_time)

    @property
    @pulumi.getter(name="dayOfWeeks")
    def day_of_weeks(self) -> Sequence['outputs.GetAutonomousDatabasesAutonomousDatabaseScheduledOperationDayOfWeekResult']:
        """
        Day of the week.
        """
        return pulumi.get(self, "day_of_weeks")

    @property
    @pulumi.getter(name="scheduledStartTime")
    def scheduled_start_time(self) -> str:
        """
        auto start time. value must be of ISO-8601 format "HH:mm"
        """
        return pulumi.get(self, "scheduled_start_time")

    @property
    @pulumi.getter(name="scheduledStopTime")
    def scheduled_stop_time(self) -> str:
        """
        auto stop time. value must be of ISO-8601 format "HH:mm"
        """
        return pulumi.get(self, "scheduled_stop_time")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseScheduledOperationDayOfWeekResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the day of the week.
        """
        GetAutonomousDatabasesAutonomousDatabaseScheduledOperationDayOfWeekResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the day of the week.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousDatabasesAutonomousDatabaseStandbyDbResult(dict):
    def __init__(__self__, *,
                 lag_time_in_seconds: int,
                 lifecycle_details: str,
                 state: str,
                 time_data_guard_role_changed: str,
                 time_disaster_recovery_role_changed: str):
        """
        :param int lag_time_in_seconds: The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        :param str time_data_guard_role_changed: The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        :param str time_disaster_recovery_role_changed: The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        GetAutonomousDatabasesAutonomousDatabaseStandbyDbResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lag_time_in_seconds=lag_time_in_seconds,
            lifecycle_details=lifecycle_details,
            state=state,
            time_data_guard_role_changed=time_data_guard_role_changed,
            time_disaster_recovery_role_changed=time_disaster_recovery_role_changed,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lag_time_in_seconds: int,
             lifecycle_details: str,
             state: str,
             time_data_guard_role_changed: str,
             time_disaster_recovery_role_changed: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("lag_time_in_seconds", lag_time_in_seconds)
        _setter("lifecycle_details", lifecycle_details)
        _setter("state", state)
        _setter("time_data_guard_role_changed", time_data_guard_role_changed)
        _setter("time_disaster_recovery_role_changed", time_disaster_recovery_role_changed)

    @property
    @pulumi.getter(name="lagTimeInSeconds")
    def lag_time_in_seconds(self) -> int:
        """
        The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        """
        return pulumi.get(self, "lag_time_in_seconds")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeDataGuardRoleChanged")
    def time_data_guard_role_changed(self) -> str:
        """
        The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        """
        return pulumi.get(self, "time_data_guard_role_changed")

    @property
    @pulumi.getter(name="timeDisasterRecoveryRoleChanged")
    def time_disaster_recovery_role_changed(self) -> str:
        """
        The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        return pulumi.get(self, "time_disaster_recovery_role_changed")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseResult(dict):
    def __init__(__self__, *,
                 actual_used_data_storage_size_in_tbs: float,
                 allocated_storage_size_in_tbs: float,
                 apex_details: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseApexDetailResult'],
                 are_primary_whitelisted_ips_used: bool,
                 autonomous_container_database_id: str,
                 autonomous_maintenance_schedule_type: str,
                 available_upgrade_versions: Sequence[str],
                 backup_configs: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseBackupConfigResult'],
                 backup_retention_period_in_days: int,
                 character_set: str,
                 compartment_id: str,
                 compute_count: float,
                 compute_model: str,
                 connection_strings: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseConnectionStringResult'],
                 connection_urls: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseConnectionUrlResult'],
                 cpu_core_count: int,
                 customer_contacts: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseCustomerContactResult'],
                 data_safe_status: str,
                 data_storage_size_in_gb: int,
                 data_storage_size_in_tbs: int,
                 database_edition: str,
                 database_management_status: str,
                 dataguard_region_type: str,
                 db_name: str,
                 db_version: str,
                 db_workload: str,
                 defined_tags: Mapping[str, Any],
                 disaster_recovery_region_type: str,
                 display_name: str,
                 failed_data_recovery_in_seconds: int,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 in_memory_area_in_gbs: int,
                 in_memory_percentage: int,
                 infrastructure_type: str,
                 is_access_control_enabled: bool,
                 is_auto_scaling_enabled: bool,
                 is_auto_scaling_for_storage_enabled: bool,
                 is_data_guard_enabled: bool,
                 is_dedicated: bool,
                 is_free_tier: bool,
                 is_local_data_guard_enabled: bool,
                 is_mtls_connection_required: bool,
                 is_preview: bool,
                 is_reconnect_clone_enabled: bool,
                 is_refreshable_clone: bool,
                 is_remote_data_guard_enabled: bool,
                 key_history_entries: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseKeyHistoryEntryResult'],
                 key_store_id: str,
                 key_store_wallet_name: str,
                 kms_key_id: str,
                 kms_key_lifecycle_details: str,
                 kms_key_version_id: str,
                 license_model: str,
                 lifecycle_details: str,
                 local_adg_auto_failover_max_data_loss_limit: int,
                 local_disaster_recovery_type: str,
                 local_standby_dbs: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseLocalStandbyDbResult'],
                 long_term_backup_schedules: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseLongTermBackupScheduleResult'],
                 max_cpu_core_count: int,
                 memory_per_oracle_compute_unit_in_gbs: int,
                 ncharacter_set: str,
                 next_long_term_backup_time_stamp: str,
                 nsg_ids: Sequence[str],
                 ocpu_count: float,
                 open_mode: str,
                 peer_db_ids: Sequence[str],
                 private_endpoint: str,
                 private_endpoint_ip: str,
                 private_endpoint_label: str,
                 provisionable_cpuses: Sequence[float],
                 refreshable_mode: str,
                 refreshable_status: str,
                 remote_disaster_recovery_configurations: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseRemoteDisasterRecoveryConfigurationResult'],
                 resource_pool_leader_id: str,
                 resource_pool_summaries: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseResourcePoolSummaryResult'],
                 role: str,
                 scheduled_operations: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseScheduledOperationResult'],
                 service_console_url: str,
                 source_id: str,
                 standby_dbs: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseStandbyDbResult'],
                 standby_whitelisted_ips: Sequence[str],
                 state: str,
                 subnet_id: str,
                 supported_regions_to_clone_tos: Sequence[str],
                 system_tags: Mapping[str, Any],
                 time_created: str,
                 time_data_guard_role_changed: str,
                 time_deletion_of_free_autonomous_database: str,
                 time_disaster_recovery_role_changed: str,
                 time_local_data_guard_enabled: str,
                 time_maintenance_begin: str,
                 time_maintenance_end: str,
                 time_of_joining_resource_pool: str,
                 time_of_last_failover: str,
                 time_of_last_refresh: str,
                 time_of_last_refresh_point: str,
                 time_of_last_switchover: str,
                 time_of_next_refresh: str,
                 time_reclamation_of_free_autonomous_database: str,
                 time_until_reconnect_clone_enabled: str,
                 total_backup_storage_size_in_gbs: float,
                 used_data_storage_size_in_gbs: int,
                 used_data_storage_size_in_tbs: int,
                 vault_id: str,
                 whitelisted_ips: Sequence[str]):
        """
        :param float actual_used_data_storage_size_in_tbs: The current amount of storage in use for user and system data, in terabytes (TB).
        :param float allocated_storage_size_in_tbs: The amount of storage currently allocated for the database tables and billed for, rounded up. When auto-scaling is not enabled, this value is equal to the `dataStorageSizeInTBs` value. You can compare this value to the `actualUsedDataStorageSizeInTBs` value to determine if a manual shrink operation is appropriate for your allocated storage.
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseApexDetailArgs'] apex_details: Information about Oracle APEX Application Development.
        :param bool are_primary_whitelisted_ips_used: This field will be null if the Autonomous Database is not Data Guard enabled or Access Control is disabled. It's value would be `TRUE` if Autonomous Database is Data Guard enabled and Access Control is enabled and if the Autonomous Database uses primary IP access control list (ACL) for standby. It's value would be `FALSE` if Autonomous Database is Data Guard enabled and Access Control is enabled and if the Autonomous Database uses different IP access control list (ACL) for standby compared to primary.
        :param str autonomous_container_database_id: The Autonomous Container Database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param str autonomous_maintenance_schedule_type: The maintenance schedule type of the Autonomous Database Serverless. An EARLY maintenance schedule follows a schedule applying patches prior to the REGULAR schedule. A REGULAR maintenance schedule follows the normal cycle
        :param Sequence[str] available_upgrade_versions: List of Oracle Database versions available for a database upgrade. If there are no version upgrades available, this list is empty.
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseBackupConfigArgs'] backup_configs: Autonomous Database configuration details for storing [manual backups](https://docs.oracle.com/en/cloud/paas/autonomous-database/adbsa/backup-restore.html#GUID-9035DFB8-4702-4CEB-8281-C2A303820809) in the [Object Storage](https://docs.cloud.oracle.com/iaas/Content/Object/Concepts/objectstorageoverview.htm) service.
        :param int backup_retention_period_in_days: Retention period, in days, for backups.
        :param str character_set: The character set for the autonomous database.  The default is AL32UTF8. Allowed values are:
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param float compute_count: The compute amount available to the database. Minimum and maximum values depend on the compute model and whether the database is an Autonomous Database Serverless instance or an Autonomous Database on Dedicated Exadata Infrastructure. For an Autonomous Database Serverless instance, the 'ECPU' compute model requires values in multiples of two. Required when using the `computeModel` parameter. When using `cpuCoreCount` parameter, it is an error to specify computeCount to a non-null value.
        :param str compute_model: The compute model of the Autonomous Database. This is required if using the `computeCount` parameter. If using `cpuCoreCount` then it is an error to specify `computeModel` to a non-null value.
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseConnectionStringArgs'] connection_strings: The connection string used to connect to the Autonomous Database. The username for the Service Console is ADMIN. Use the password you entered when creating the Autonomous Database for the password value.
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseConnectionUrlArgs'] connection_urls: The URLs for accessing Oracle Application Express (APEX) and SQL Developer Web with a browser from a Compute instance within your VCN or that has a direct connection to your VCN. Note that these URLs are provided by the console only for databases on [dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html).  Example: `{"sqlDevWebUrl": "https://<hostname>/ords...", "apexUrl", "https://<hostname>/ords..."}`
        :param int cpu_core_count: The number of OCPU cores to be made available to the database. When the ECPU is selected, the value for cpuCoreCount is 0. For Autonomous Databases on dedicated Exadata infrastructure, the maximum number of cores is determined by the infrastructure shape. See [Characteristics of Infrastructure Shapes](https://www.oracle.com/pls/topic/lookup?ctx=en/cloud/paas/autonomous-database&id=ATPFG-GUID-B0F033C1-CC5A-42F0-B2E7-3CECFEDA1FD1) for shape details.
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseCustomerContactArgs'] customer_contacts: Customer Contacts.
        :param str data_safe_status: Status of the Data Safe registration for this Autonomous Database.
        :param int data_storage_size_in_gb: The quantity of data in the database, in gigabytes.
        :param int data_storage_size_in_tbs: The quantity of data in the database, in terabytes.
        :param str database_edition: The Oracle Database Edition that applies to the Autonomous databases.
        :param str database_management_status: Status of Database Management for this Autonomous Database.
        :param str dataguard_region_type: The Autonomous Data Guard region type of the Autonomous Database. For Autonomous Database Serverless, Autonomous Data Guard associations have designated primary and standby regions, and these region types do not change when the database changes roles. The standby regions in Autonomous Data Guard associations can be the same region designated as the primary region, or they can be remote regions. Certain database administrative operations may be available only in the primary region of the Autonomous Data Guard association, and cannot be performed when the database using the primary role is operating in a remote Autonomous Data Guard standby region.
        :param str db_name: The database name.
        :param str db_version: A valid Oracle Database version for Autonomous Database.
        :param str db_workload: The Autonomous Database workload type. The following values are valid:
               * OLTP - indicates an Autonomous Transaction Processing database
               * DW - indicates an Autonomous Data Warehouse database
               * AJD - indicates an Autonomous JSON Database
               * APEX - indicates an Autonomous Database with the Oracle APEX Application Development workload type.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str disaster_recovery_region_type: The disaster recovery (DR) region type of the Autonomous Database. For Autonomous Database Serverless instances, DR associations have designated primary and standby regions. These region types do not change when the database changes roles. The standby region in DR associations can be the same region as the primary region, or they can be in a remote regions. Some database administration operations may be available only in the primary region of the DR association, and cannot be performed when the database using the primary role is operating in a remote region.
        :param str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param int failed_data_recovery_in_seconds: Indicates the number of seconds of data loss for a Data Guard failover.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param int in_memory_area_in_gbs: The area assigned to In-Memory tables in Autonomous Database.
        :param int in_memory_percentage: The percentage of the System Global Area(SGA) assigned to In-Memory tables in Autonomous Database.
        :param str infrastructure_type: The infrastructure type this resource belongs to.
        :param bool is_access_control_enabled: Indicates if the database-level access control is enabled. If disabled, database access is defined by the network security rules. If enabled, database access is restricted to the IP addresses defined by the rules specified with the `whitelistedIps` property. While specifying `whitelistedIps` rules is optional, if database-level access control is enabled and no rules are specified, the database will become inaccessible. The rules can be added later using the `UpdateAutonomousDatabase` API operation or edit option in console. When creating a database clone, the desired access control setting should be specified. By default, database-level access control will be disabled for the clone.
        :param bool is_auto_scaling_enabled: Indicates if auto scaling is enabled for the Autonomous Database CPU core count.
        :param bool is_auto_scaling_for_storage_enabled: Indicates if auto scaling is enabled for the Autonomous Database storage. The default value is `FALSE`.
        :param bool is_data_guard_enabled: **Deprecated.** Indicates whether the Autonomous Database has local (in-region) Data Guard enabled. Not applicable to cross-region Autonomous Data Guard associations, or to Autonomous Databases using dedicated Exadata infrastructure or Exadata Cloud@Customer infrastructure.
        :param bool is_dedicated: True if the database uses [dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html).
        :param bool is_free_tier: Indicates if this is an Always Free resource. The default value is false. Note that Always Free Autonomous Databases have 1 CPU and 20GB of memory. For Always Free databases, memory and CPU cannot be scaled.
        :param bool is_local_data_guard_enabled: Indicates whether the Autonomous Database has local (in-region) Data Guard enabled. Not applicable to cross-region Autonomous Data Guard associations, or to Autonomous Databases using dedicated Exadata infrastructure or Exadata Cloud@Customer infrastructure.
        :param bool is_mtls_connection_required: Specifies if the Autonomous Database requires mTLS connections.
        :param bool is_preview: Indicates if the Autonomous Database version is a preview version.
        :param bool is_reconnect_clone_enabled: Indicates if the refreshable clone can be reconnected to its source database.
        :param bool is_refreshable_clone: Indicates if the Autonomous Database is a refreshable clone.
        :param bool is_remote_data_guard_enabled: Indicates whether the Autonomous Database has Cross Region Data Guard enabled. Not applicable to Autonomous Databases using dedicated Exadata infrastructure or Exadata Cloud@Customer infrastructure.
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseKeyHistoryEntryArgs'] key_history_entries: Key History Entry.
        :param str key_store_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        :param str key_store_wallet_name: The wallet name for Oracle Key Vault.
        :param str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param str kms_key_lifecycle_details: KMS key lifecycle details.
        :param str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        :param str license_model: The Oracle license model that applies to the Oracle Autonomous Database. Bring your own license (BYOL) allows you to apply your current on-premises Oracle software licenses to equivalent, highly automated Oracle PaaS and IaaS services in the cloud. License Included allows you to subscribe to new Oracle Database software licenses and the Database service. Note that when provisioning an Autonomous Database on [dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html), this attribute must be null because the attribute is already set at the Autonomous Exadata Infrastructure level. When using [shared Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html), if a value is not specified, the system will supply the value of `BRING_YOUR_OWN_LICENSE`.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param int local_adg_auto_failover_max_data_loss_limit: Parameter that allows users to select an acceptable maximum data loss limit in seconds, up to which Automatic Failover will be triggered when necessary for a Local Autonomous Data Guard
        :param str local_disaster_recovery_type: Indicates the local disaster recovery (DR) type of the Autonomous Database Serverless instance. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseLocalStandbyDbArgs'] local_standby_dbs: Autonomous Data Guard standby database details.
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseLongTermBackupScheduleArgs'] long_term_backup_schedules: Details for the long-term backup schedule.
        :param int max_cpu_core_count: The number of Max OCPU cores to be made available to the autonomous database with auto scaling of cpu enabled.
        :param int memory_per_oracle_compute_unit_in_gbs: The amount of memory (in GBs) enabled per OCPU or ECPU. See [Compute Models in Autonomous Database on Dedicated Exadata Infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/dedicated/adbak) for more details.
        :param str ncharacter_set: The national character set for the autonomous database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        :param str next_long_term_backup_time_stamp: The date and time when the next long-term backup would be created.
        :param Sequence[str] nsg_ids: The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the network security groups (NSGs) to which this resource belongs. Setting this to an empty list removes all resources from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). **NsgIds restrictions:**
               * A network security group (NSG) is optional for Autonomous Databases with private access. The nsgIds list can be empty.
        :param float ocpu_count: The number of OCPU cores to be made available to the database.
        :param str open_mode: Indicates the Autonomous Database mode. The database can be opened in `READ_ONLY` or `READ_WRITE` mode.
        :param Sequence[str] peer_db_ids: The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of standby databases located in Autonomous Data Guard remote regions that are associated with the source database. Note that for shared Exadata infrastructure, standby databases located in the same region as the source primary database do not have OCIDs.
        :param str private_endpoint: The private endpoint for the resource.
        :param str private_endpoint_ip: The private endpoint Ip address for the resource.
        :param str private_endpoint_label: The resource's private endpoint label. Setting this to an empty string, after the creation of the private endpoint database, changes the private endpoint database to a public endpoint database.
        :param Sequence[float] provisionable_cpuses: An array of CPU values that an Autonomous Database can be scaled to.
        :param str refreshable_mode: The refresh mode of the clone. AUTOMATIC indicates that the clone is automatically being refreshed with data from the source Autonomous Database.
        :param str refreshable_status: The refresh status of the clone. REFRESHING indicates that the clone is currently being refreshed with data from the source Autonomous Database.
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseRemoteDisasterRecoveryConfigurationArgs'] remote_disaster_recovery_configurations: Configurations of a Disaster Recovery.
        :param str resource_pool_leader_id: The unique identifier for leader autonomous database OCID [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseResourcePoolSummaryArgs'] resource_pool_summaries: The configuration details for resource pool
        :param str role: The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseScheduledOperationArgs'] scheduled_operations: The list of scheduled operations.
        :param str service_console_url: The URL of the Service Console for the Autonomous Database.
        :param str source_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the source Autonomous Database that was cloned to create the current Autonomous Database.
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseStandbyDbArgs'] standby_dbs: **Deprecated** Autonomous Data Guard standby database details.
        :param Sequence[str] standby_whitelisted_ips: The client IP access control list (ACL). This feature is available for [Autonomous Database Serverless] (https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html) and on Exadata Cloud@Customer. Only clients connecting from an IP address included in the ACL may access the Autonomous Database instance.
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        :param str subnet_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet the resource is associated with.
        :param Sequence[str] supported_regions_to_clone_tos: The list of regions that support the creation of an Autonomous Database clone or an Autonomous Data Guard standby database.
        :param Mapping[str, Any] system_tags: System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str time_created: The date and time the Autonomous Database was created.
        :param str time_data_guard_role_changed: The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        :param str time_deletion_of_free_autonomous_database: The date and time the Always Free database will be automatically deleted because of inactivity. If the database is in the STOPPED state and without activity until this time, it will be deleted.
        :param str time_disaster_recovery_role_changed: The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        :param str time_local_data_guard_enabled: The date and time that Autonomous Data Guard was enabled for an Autonomous Database where the standby was provisioned in the same region as the primary database.
        :param str time_maintenance_begin: The date and time when maintenance will begin.
        :param str time_maintenance_end: The date and time when maintenance will end.
        :param str time_of_last_failover: The timestamp of the last failover operation.
        :param str time_of_last_refresh: The date and time when last refresh happened.
        :param str time_of_last_refresh_point: The refresh point timestamp (UTC). The refresh point is the time to which the database was most recently refreshed. Data created after the refresh point is not included in the refresh.
        :param str time_of_last_switchover: The timestamp of the last switchover operation for the Autonomous Database.
        :param str time_of_next_refresh: The date and time of next refresh.
        :param str time_reclamation_of_free_autonomous_database: The date and time the Always Free database will be stopped because of inactivity. If this time is reached without any database activity, the database will automatically be put into the STOPPED state.
        :param str time_until_reconnect_clone_enabled: The time and date as an RFC3339 formatted string, e.g., 2022-01-01T12:00:00.000Z, to set the limit for a refreshable clone to be reconnected to its source database.
        :param float total_backup_storage_size_in_gbs: The backup storage to the database.
        :param int used_data_storage_size_in_gbs: The storage space consumed by Autonomous Database in GBs.
        :param int used_data_storage_size_in_tbs: The amount of storage that has been used, in terabytes.
        :param str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        :param Sequence[str] whitelisted_ips: The client IP access control list (ACL). This feature is available for [Autonomous Database Serverless] (https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html) and on Exadata Cloud@Customer. Only clients connecting from an IP address included in the ACL may access the Autonomous Database instance.
        """
        GetAutonomousDatabasesClonesAutonomousDatabaseResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actual_used_data_storage_size_in_tbs=actual_used_data_storage_size_in_tbs,
            allocated_storage_size_in_tbs=allocated_storage_size_in_tbs,
            apex_details=apex_details,
            are_primary_whitelisted_ips_used=are_primary_whitelisted_ips_used,
            autonomous_container_database_id=autonomous_container_database_id,
            autonomous_maintenance_schedule_type=autonomous_maintenance_schedule_type,
            available_upgrade_versions=available_upgrade_versions,
            backup_configs=backup_configs,
            backup_retention_period_in_days=backup_retention_period_in_days,
            character_set=character_set,
            compartment_id=compartment_id,
            compute_count=compute_count,
            compute_model=compute_model,
            connection_strings=connection_strings,
            connection_urls=connection_urls,
            cpu_core_count=cpu_core_count,
            customer_contacts=customer_contacts,
            data_safe_status=data_safe_status,
            data_storage_size_in_gb=data_storage_size_in_gb,
            data_storage_size_in_tbs=data_storage_size_in_tbs,
            database_edition=database_edition,
            database_management_status=database_management_status,
            dataguard_region_type=dataguard_region_type,
            db_name=db_name,
            db_version=db_version,
            db_workload=db_workload,
            defined_tags=defined_tags,
            disaster_recovery_region_type=disaster_recovery_region_type,
            display_name=display_name,
            failed_data_recovery_in_seconds=failed_data_recovery_in_seconds,
            freeform_tags=freeform_tags,
            id=id,
            in_memory_area_in_gbs=in_memory_area_in_gbs,
            in_memory_percentage=in_memory_percentage,
            infrastructure_type=infrastructure_type,
            is_access_control_enabled=is_access_control_enabled,
            is_auto_scaling_enabled=is_auto_scaling_enabled,
            is_auto_scaling_for_storage_enabled=is_auto_scaling_for_storage_enabled,
            is_data_guard_enabled=is_data_guard_enabled,
            is_dedicated=is_dedicated,
            is_free_tier=is_free_tier,
            is_local_data_guard_enabled=is_local_data_guard_enabled,
            is_mtls_connection_required=is_mtls_connection_required,
            is_preview=is_preview,
            is_reconnect_clone_enabled=is_reconnect_clone_enabled,
            is_refreshable_clone=is_refreshable_clone,
            is_remote_data_guard_enabled=is_remote_data_guard_enabled,
            key_history_entries=key_history_entries,
            key_store_id=key_store_id,
            key_store_wallet_name=key_store_wallet_name,
            kms_key_id=kms_key_id,
            kms_key_lifecycle_details=kms_key_lifecycle_details,
            kms_key_version_id=kms_key_version_id,
            license_model=license_model,
            lifecycle_details=lifecycle_details,
            local_adg_auto_failover_max_data_loss_limit=local_adg_auto_failover_max_data_loss_limit,
            local_disaster_recovery_type=local_disaster_recovery_type,
            local_standby_dbs=local_standby_dbs,
            long_term_backup_schedules=long_term_backup_schedules,
            max_cpu_core_count=max_cpu_core_count,
            memory_per_oracle_compute_unit_in_gbs=memory_per_oracle_compute_unit_in_gbs,
            ncharacter_set=ncharacter_set,
            next_long_term_backup_time_stamp=next_long_term_backup_time_stamp,
            nsg_ids=nsg_ids,
            ocpu_count=ocpu_count,
            open_mode=open_mode,
            peer_db_ids=peer_db_ids,
            private_endpoint=private_endpoint,
            private_endpoint_ip=private_endpoint_ip,
            private_endpoint_label=private_endpoint_label,
            provisionable_cpuses=provisionable_cpuses,
            refreshable_mode=refreshable_mode,
            refreshable_status=refreshable_status,
            remote_disaster_recovery_configurations=remote_disaster_recovery_configurations,
            resource_pool_leader_id=resource_pool_leader_id,
            resource_pool_summaries=resource_pool_summaries,
            role=role,
            scheduled_operations=scheduled_operations,
            service_console_url=service_console_url,
            source_id=source_id,
            standby_dbs=standby_dbs,
            standby_whitelisted_ips=standby_whitelisted_ips,
            state=state,
            subnet_id=subnet_id,
            supported_regions_to_clone_tos=supported_regions_to_clone_tos,
            system_tags=system_tags,
            time_created=time_created,
            time_data_guard_role_changed=time_data_guard_role_changed,
            time_deletion_of_free_autonomous_database=time_deletion_of_free_autonomous_database,
            time_disaster_recovery_role_changed=time_disaster_recovery_role_changed,
            time_local_data_guard_enabled=time_local_data_guard_enabled,
            time_maintenance_begin=time_maintenance_begin,
            time_maintenance_end=time_maintenance_end,
            time_of_joining_resource_pool=time_of_joining_resource_pool,
            time_of_last_failover=time_of_last_failover,
            time_of_last_refresh=time_of_last_refresh,
            time_of_last_refresh_point=time_of_last_refresh_point,
            time_of_last_switchover=time_of_last_switchover,
            time_of_next_refresh=time_of_next_refresh,
            time_reclamation_of_free_autonomous_database=time_reclamation_of_free_autonomous_database,
            time_until_reconnect_clone_enabled=time_until_reconnect_clone_enabled,
            total_backup_storage_size_in_gbs=total_backup_storage_size_in_gbs,
            used_data_storage_size_in_gbs=used_data_storage_size_in_gbs,
            used_data_storage_size_in_tbs=used_data_storage_size_in_tbs,
            vault_id=vault_id,
            whitelisted_ips=whitelisted_ips,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actual_used_data_storage_size_in_tbs: float,
             allocated_storage_size_in_tbs: float,
             apex_details: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseApexDetailResult'],
             are_primary_whitelisted_ips_used: bool,
             autonomous_container_database_id: str,
             autonomous_maintenance_schedule_type: str,
             available_upgrade_versions: Sequence[str],
             backup_configs: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseBackupConfigResult'],
             backup_retention_period_in_days: int,
             character_set: str,
             compartment_id: str,
             compute_count: float,
             compute_model: str,
             connection_strings: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseConnectionStringResult'],
             connection_urls: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseConnectionUrlResult'],
             cpu_core_count: int,
             customer_contacts: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseCustomerContactResult'],
             data_safe_status: str,
             data_storage_size_in_gb: int,
             data_storage_size_in_tbs: int,
             database_edition: str,
             database_management_status: str,
             dataguard_region_type: str,
             db_name: str,
             db_version: str,
             db_workload: str,
             defined_tags: Mapping[str, Any],
             disaster_recovery_region_type: str,
             display_name: str,
             failed_data_recovery_in_seconds: int,
             freeform_tags: Mapping[str, Any],
             id: str,
             in_memory_area_in_gbs: int,
             in_memory_percentage: int,
             infrastructure_type: str,
             is_access_control_enabled: bool,
             is_auto_scaling_enabled: bool,
             is_auto_scaling_for_storage_enabled: bool,
             is_data_guard_enabled: bool,
             is_dedicated: bool,
             is_free_tier: bool,
             is_local_data_guard_enabled: bool,
             is_mtls_connection_required: bool,
             is_preview: bool,
             is_reconnect_clone_enabled: bool,
             is_refreshable_clone: bool,
             is_remote_data_guard_enabled: bool,
             key_history_entries: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseKeyHistoryEntryResult'],
             key_store_id: str,
             key_store_wallet_name: str,
             kms_key_id: str,
             kms_key_lifecycle_details: str,
             kms_key_version_id: str,
             license_model: str,
             lifecycle_details: str,
             local_adg_auto_failover_max_data_loss_limit: int,
             local_disaster_recovery_type: str,
             local_standby_dbs: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseLocalStandbyDbResult'],
             long_term_backup_schedules: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseLongTermBackupScheduleResult'],
             max_cpu_core_count: int,
             memory_per_oracle_compute_unit_in_gbs: int,
             ncharacter_set: str,
             next_long_term_backup_time_stamp: str,
             nsg_ids: Sequence[str],
             ocpu_count: float,
             open_mode: str,
             peer_db_ids: Sequence[str],
             private_endpoint: str,
             private_endpoint_ip: str,
             private_endpoint_label: str,
             provisionable_cpuses: Sequence[float],
             refreshable_mode: str,
             refreshable_status: str,
             remote_disaster_recovery_configurations: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseRemoteDisasterRecoveryConfigurationResult'],
             resource_pool_leader_id: str,
             resource_pool_summaries: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseResourcePoolSummaryResult'],
             role: str,
             scheduled_operations: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseScheduledOperationResult'],
             service_console_url: str,
             source_id: str,
             standby_dbs: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseStandbyDbResult'],
             standby_whitelisted_ips: Sequence[str],
             state: str,
             subnet_id: str,
             supported_regions_to_clone_tos: Sequence[str],
             system_tags: Mapping[str, Any],
             time_created: str,
             time_data_guard_role_changed: str,
             time_deletion_of_free_autonomous_database: str,
             time_disaster_recovery_role_changed: str,
             time_local_data_guard_enabled: str,
             time_maintenance_begin: str,
             time_maintenance_end: str,
             time_of_joining_resource_pool: str,
             time_of_last_failover: str,
             time_of_last_refresh: str,
             time_of_last_refresh_point: str,
             time_of_last_switchover: str,
             time_of_next_refresh: str,
             time_reclamation_of_free_autonomous_database: str,
             time_until_reconnect_clone_enabled: str,
             total_backup_storage_size_in_gbs: float,
             used_data_storage_size_in_gbs: int,
             used_data_storage_size_in_tbs: int,
             vault_id: str,
             whitelisted_ips: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("actual_used_data_storage_size_in_tbs", actual_used_data_storage_size_in_tbs)
        _setter("allocated_storage_size_in_tbs", allocated_storage_size_in_tbs)
        _setter("apex_details", apex_details)
        _setter("are_primary_whitelisted_ips_used", are_primary_whitelisted_ips_used)
        _setter("autonomous_container_database_id", autonomous_container_database_id)
        _setter("autonomous_maintenance_schedule_type", autonomous_maintenance_schedule_type)
        _setter("available_upgrade_versions", available_upgrade_versions)
        _setter("backup_configs", backup_configs)
        _setter("backup_retention_period_in_days", backup_retention_period_in_days)
        _setter("character_set", character_set)
        _setter("compartment_id", compartment_id)
        _setter("compute_count", compute_count)
        _setter("compute_model", compute_model)
        _setter("connection_strings", connection_strings)
        _setter("connection_urls", connection_urls)
        _setter("cpu_core_count", cpu_core_count)
        _setter("customer_contacts", customer_contacts)
        _setter("data_safe_status", data_safe_status)
        _setter("data_storage_size_in_gb", data_storage_size_in_gb)
        _setter("data_storage_size_in_tbs", data_storage_size_in_tbs)
        _setter("database_edition", database_edition)
        _setter("database_management_status", database_management_status)
        _setter("dataguard_region_type", dataguard_region_type)
        _setter("db_name", db_name)
        _setter("db_version", db_version)
        _setter("db_workload", db_workload)
        _setter("defined_tags", defined_tags)
        _setter("disaster_recovery_region_type", disaster_recovery_region_type)
        _setter("display_name", display_name)
        _setter("failed_data_recovery_in_seconds", failed_data_recovery_in_seconds)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("in_memory_area_in_gbs", in_memory_area_in_gbs)
        _setter("in_memory_percentage", in_memory_percentage)
        _setter("infrastructure_type", infrastructure_type)
        _setter("is_access_control_enabled", is_access_control_enabled)
        _setter("is_auto_scaling_enabled", is_auto_scaling_enabled)
        _setter("is_auto_scaling_for_storage_enabled", is_auto_scaling_for_storage_enabled)
        _setter("is_data_guard_enabled", is_data_guard_enabled)
        _setter("is_dedicated", is_dedicated)
        _setter("is_free_tier", is_free_tier)
        _setter("is_local_data_guard_enabled", is_local_data_guard_enabled)
        _setter("is_mtls_connection_required", is_mtls_connection_required)
        _setter("is_preview", is_preview)
        _setter("is_reconnect_clone_enabled", is_reconnect_clone_enabled)
        _setter("is_refreshable_clone", is_refreshable_clone)
        _setter("is_remote_data_guard_enabled", is_remote_data_guard_enabled)
        _setter("key_history_entries", key_history_entries)
        _setter("key_store_id", key_store_id)
        _setter("key_store_wallet_name", key_store_wallet_name)
        _setter("kms_key_id", kms_key_id)
        _setter("kms_key_lifecycle_details", kms_key_lifecycle_details)
        _setter("kms_key_version_id", kms_key_version_id)
        _setter("license_model", license_model)
        _setter("lifecycle_details", lifecycle_details)
        _setter("local_adg_auto_failover_max_data_loss_limit", local_adg_auto_failover_max_data_loss_limit)
        _setter("local_disaster_recovery_type", local_disaster_recovery_type)
        _setter("local_standby_dbs", local_standby_dbs)
        _setter("long_term_backup_schedules", long_term_backup_schedules)
        _setter("max_cpu_core_count", max_cpu_core_count)
        _setter("memory_per_oracle_compute_unit_in_gbs", memory_per_oracle_compute_unit_in_gbs)
        _setter("ncharacter_set", ncharacter_set)
        _setter("next_long_term_backup_time_stamp", next_long_term_backup_time_stamp)
        _setter("nsg_ids", nsg_ids)
        _setter("ocpu_count", ocpu_count)
        _setter("open_mode", open_mode)
        _setter("peer_db_ids", peer_db_ids)
        _setter("private_endpoint", private_endpoint)
        _setter("private_endpoint_ip", private_endpoint_ip)
        _setter("private_endpoint_label", private_endpoint_label)
        _setter("provisionable_cpuses", provisionable_cpuses)
        _setter("refreshable_mode", refreshable_mode)
        _setter("refreshable_status", refreshable_status)
        _setter("remote_disaster_recovery_configurations", remote_disaster_recovery_configurations)
        _setter("resource_pool_leader_id", resource_pool_leader_id)
        _setter("resource_pool_summaries", resource_pool_summaries)
        _setter("role", role)
        _setter("scheduled_operations", scheduled_operations)
        _setter("service_console_url", service_console_url)
        _setter("source_id", source_id)
        _setter("standby_dbs", standby_dbs)
        _setter("standby_whitelisted_ips", standby_whitelisted_ips)
        _setter("state", state)
        _setter("subnet_id", subnet_id)
        _setter("supported_regions_to_clone_tos", supported_regions_to_clone_tos)
        _setter("system_tags", system_tags)
        _setter("time_created", time_created)
        _setter("time_data_guard_role_changed", time_data_guard_role_changed)
        _setter("time_deletion_of_free_autonomous_database", time_deletion_of_free_autonomous_database)
        _setter("time_disaster_recovery_role_changed", time_disaster_recovery_role_changed)
        _setter("time_local_data_guard_enabled", time_local_data_guard_enabled)
        _setter("time_maintenance_begin", time_maintenance_begin)
        _setter("time_maintenance_end", time_maintenance_end)
        _setter("time_of_joining_resource_pool", time_of_joining_resource_pool)
        _setter("time_of_last_failover", time_of_last_failover)
        _setter("time_of_last_refresh", time_of_last_refresh)
        _setter("time_of_last_refresh_point", time_of_last_refresh_point)
        _setter("time_of_last_switchover", time_of_last_switchover)
        _setter("time_of_next_refresh", time_of_next_refresh)
        _setter("time_reclamation_of_free_autonomous_database", time_reclamation_of_free_autonomous_database)
        _setter("time_until_reconnect_clone_enabled", time_until_reconnect_clone_enabled)
        _setter("total_backup_storage_size_in_gbs", total_backup_storage_size_in_gbs)
        _setter("used_data_storage_size_in_gbs", used_data_storage_size_in_gbs)
        _setter("used_data_storage_size_in_tbs", used_data_storage_size_in_tbs)
        _setter("vault_id", vault_id)
        _setter("whitelisted_ips", whitelisted_ips)

    @property
    @pulumi.getter(name="actualUsedDataStorageSizeInTbs")
    def actual_used_data_storage_size_in_tbs(self) -> float:
        """
        The current amount of storage in use for user and system data, in terabytes (TB).
        """
        return pulumi.get(self, "actual_used_data_storage_size_in_tbs")

    @property
    @pulumi.getter(name="allocatedStorageSizeInTbs")
    def allocated_storage_size_in_tbs(self) -> float:
        """
        The amount of storage currently allocated for the database tables and billed for, rounded up. When auto-scaling is not enabled, this value is equal to the `dataStorageSizeInTBs` value. You can compare this value to the `actualUsedDataStorageSizeInTBs` value to determine if a manual shrink operation is appropriate for your allocated storage.
        """
        return pulumi.get(self, "allocated_storage_size_in_tbs")

    @property
    @pulumi.getter(name="apexDetails")
    def apex_details(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseApexDetailResult']:
        """
        Information about Oracle APEX Application Development.
        """
        return pulumi.get(self, "apex_details")

    @property
    @pulumi.getter(name="arePrimaryWhitelistedIpsUsed")
    def are_primary_whitelisted_ips_used(self) -> bool:
        """
        This field will be null if the Autonomous Database is not Data Guard enabled or Access Control is disabled. It's value would be `TRUE` if Autonomous Database is Data Guard enabled and Access Control is enabled and if the Autonomous Database uses primary IP access control list (ACL) for standby. It's value would be `FALSE` if Autonomous Database is Data Guard enabled and Access Control is enabled and if the Autonomous Database uses different IP access control list (ACL) for standby compared to primary.
        """
        return pulumi.get(self, "are_primary_whitelisted_ips_used")

    @property
    @pulumi.getter(name="autonomousContainerDatabaseId")
    def autonomous_container_database_id(self) -> str:
        """
        The Autonomous Container Database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "autonomous_container_database_id")

    @property
    @pulumi.getter(name="autonomousMaintenanceScheduleType")
    def autonomous_maintenance_schedule_type(self) -> str:
        """
        The maintenance schedule type of the Autonomous Database Serverless. An EARLY maintenance schedule follows a schedule applying patches prior to the REGULAR schedule. A REGULAR maintenance schedule follows the normal cycle
        """
        return pulumi.get(self, "autonomous_maintenance_schedule_type")

    @property
    @pulumi.getter(name="availableUpgradeVersions")
    def available_upgrade_versions(self) -> Sequence[str]:
        """
        List of Oracle Database versions available for a database upgrade. If there are no version upgrades available, this list is empty.
        """
        return pulumi.get(self, "available_upgrade_versions")

    @property
    @pulumi.getter(name="backupConfigs")
    def backup_configs(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseBackupConfigResult']:
        """
        Autonomous Database configuration details for storing [manual backups](https://docs.oracle.com/en/cloud/paas/autonomous-database/adbsa/backup-restore.html#GUID-9035DFB8-4702-4CEB-8281-C2A303820809) in the [Object Storage](https://docs.cloud.oracle.com/iaas/Content/Object/Concepts/objectstorageoverview.htm) service.
        """
        return pulumi.get(self, "backup_configs")

    @property
    @pulumi.getter(name="backupRetentionPeriodInDays")
    def backup_retention_period_in_days(self) -> int:
        """
        Retention period, in days, for backups.
        """
        return pulumi.get(self, "backup_retention_period_in_days")

    @property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> str:
        """
        The character set for the autonomous database.  The default is AL32UTF8. Allowed values are:
        """
        return pulumi.get(self, "character_set")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="computeCount")
    def compute_count(self) -> float:
        """
        The compute amount available to the database. Minimum and maximum values depend on the compute model and whether the database is an Autonomous Database Serverless instance or an Autonomous Database on Dedicated Exadata Infrastructure. For an Autonomous Database Serverless instance, the 'ECPU' compute model requires values in multiples of two. Required when using the `computeModel` parameter. When using `cpuCoreCount` parameter, it is an error to specify computeCount to a non-null value.
        """
        return pulumi.get(self, "compute_count")

    @property
    @pulumi.getter(name="computeModel")
    def compute_model(self) -> str:
        """
        The compute model of the Autonomous Database. This is required if using the `computeCount` parameter. If using `cpuCoreCount` then it is an error to specify `computeModel` to a non-null value.
        """
        return pulumi.get(self, "compute_model")

    @property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseConnectionStringResult']:
        """
        The connection string used to connect to the Autonomous Database. The username for the Service Console is ADMIN. Use the password you entered when creating the Autonomous Database for the password value.
        """
        return pulumi.get(self, "connection_strings")

    @property
    @pulumi.getter(name="connectionUrls")
    def connection_urls(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseConnectionUrlResult']:
        """
        The URLs for accessing Oracle Application Express (APEX) and SQL Developer Web with a browser from a Compute instance within your VCN or that has a direct connection to your VCN. Note that these URLs are provided by the console only for databases on [dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html).  Example: `{"sqlDevWebUrl": "https://<hostname>/ords...", "apexUrl", "https://<hostname>/ords..."}`
        """
        return pulumi.get(self, "connection_urls")

    @property
    @pulumi.getter(name="cpuCoreCount")
    def cpu_core_count(self) -> int:
        """
        The number of OCPU cores to be made available to the database. When the ECPU is selected, the value for cpuCoreCount is 0. For Autonomous Databases on dedicated Exadata infrastructure, the maximum number of cores is determined by the infrastructure shape. See [Characteristics of Infrastructure Shapes](https://www.oracle.com/pls/topic/lookup?ctx=en/cloud/paas/autonomous-database&id=ATPFG-GUID-B0F033C1-CC5A-42F0-B2E7-3CECFEDA1FD1) for shape details.
        """
        return pulumi.get(self, "cpu_core_count")

    @property
    @pulumi.getter(name="customerContacts")
    def customer_contacts(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseCustomerContactResult']:
        """
        Customer Contacts.
        """
        return pulumi.get(self, "customer_contacts")

    @property
    @pulumi.getter(name="dataSafeStatus")
    def data_safe_status(self) -> str:
        """
        Status of the Data Safe registration for this Autonomous Database.
        """
        return pulumi.get(self, "data_safe_status")

    @property
    @pulumi.getter(name="dataStorageSizeInGb")
    def data_storage_size_in_gb(self) -> int:
        """
        The quantity of data in the database, in gigabytes.
        """
        return pulumi.get(self, "data_storage_size_in_gb")

    @property
    @pulumi.getter(name="dataStorageSizeInTbs")
    def data_storage_size_in_tbs(self) -> int:
        """
        The quantity of data in the database, in terabytes.
        """
        return pulumi.get(self, "data_storage_size_in_tbs")

    @property
    @pulumi.getter(name="databaseEdition")
    def database_edition(self) -> str:
        """
        The Oracle Database Edition that applies to the Autonomous databases.
        """
        return pulumi.get(self, "database_edition")

    @property
    @pulumi.getter(name="databaseManagementStatus")
    def database_management_status(self) -> str:
        """
        Status of Database Management for this Autonomous Database.
        """
        return pulumi.get(self, "database_management_status")

    @property
    @pulumi.getter(name="dataguardRegionType")
    def dataguard_region_type(self) -> str:
        """
        The Autonomous Data Guard region type of the Autonomous Database. For Autonomous Database Serverless, Autonomous Data Guard associations have designated primary and standby regions, and these region types do not change when the database changes roles. The standby regions in Autonomous Data Guard associations can be the same region designated as the primary region, or they can be remote regions. Certain database administrative operations may be available only in the primary region of the Autonomous Data Guard association, and cannot be performed when the database using the primary role is operating in a remote Autonomous Data Guard standby region.
        """
        return pulumi.get(self, "dataguard_region_type")

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> str:
        """
        The database name.
        """
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> str:
        """
        A valid Oracle Database version for Autonomous Database.
        """
        return pulumi.get(self, "db_version")

    @property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> str:
        """
        The Autonomous Database workload type. The following values are valid:
        * OLTP - indicates an Autonomous Transaction Processing database
        * DW - indicates an Autonomous Data Warehouse database
        * AJD - indicates an Autonomous JSON Database
        * APEX - indicates an Autonomous Database with the Oracle APEX Application Development workload type.
        """
        return pulumi.get(self, "db_workload")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="disasterRecoveryRegionType")
    def disaster_recovery_region_type(self) -> str:
        """
        The disaster recovery (DR) region type of the Autonomous Database. For Autonomous Database Serverless instances, DR associations have designated primary and standby regions. These region types do not change when the database changes roles. The standby region in DR associations can be the same region as the primary region, or they can be in a remote regions. Some database administration operations may be available only in the primary region of the DR association, and cannot be performed when the database using the primary role is operating in a remote region.
        """
        return pulumi.get(self, "disaster_recovery_region_type")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="failedDataRecoveryInSeconds")
    def failed_data_recovery_in_seconds(self) -> int:
        """
        Indicates the number of seconds of data loss for a Data Guard failover.
        """
        return pulumi.get(self, "failed_data_recovery_in_seconds")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="inMemoryAreaInGbs")
    def in_memory_area_in_gbs(self) -> int:
        """
        The area assigned to In-Memory tables in Autonomous Database.
        """
        return pulumi.get(self, "in_memory_area_in_gbs")

    @property
    @pulumi.getter(name="inMemoryPercentage")
    def in_memory_percentage(self) -> int:
        """
        The percentage of the System Global Area(SGA) assigned to In-Memory tables in Autonomous Database.
        """
        return pulumi.get(self, "in_memory_percentage")

    @property
    @pulumi.getter(name="infrastructureType")
    def infrastructure_type(self) -> str:
        """
        The infrastructure type this resource belongs to.
        """
        return pulumi.get(self, "infrastructure_type")

    @property
    @pulumi.getter(name="isAccessControlEnabled")
    def is_access_control_enabled(self) -> bool:
        """
        Indicates if the database-level access control is enabled. If disabled, database access is defined by the network security rules. If enabled, database access is restricted to the IP addresses defined by the rules specified with the `whitelistedIps` property. While specifying `whitelistedIps` rules is optional, if database-level access control is enabled and no rules are specified, the database will become inaccessible. The rules can be added later using the `UpdateAutonomousDatabase` API operation or edit option in console. When creating a database clone, the desired access control setting should be specified. By default, database-level access control will be disabled for the clone.
        """
        return pulumi.get(self, "is_access_control_enabled")

    @property
    @pulumi.getter(name="isAutoScalingEnabled")
    def is_auto_scaling_enabled(self) -> bool:
        """
        Indicates if auto scaling is enabled for the Autonomous Database CPU core count.
        """
        return pulumi.get(self, "is_auto_scaling_enabled")

    @property
    @pulumi.getter(name="isAutoScalingForStorageEnabled")
    def is_auto_scaling_for_storage_enabled(self) -> bool:
        """
        Indicates if auto scaling is enabled for the Autonomous Database storage. The default value is `FALSE`.
        """
        return pulumi.get(self, "is_auto_scaling_for_storage_enabled")

    @property
    @pulumi.getter(name="isDataGuardEnabled")
    def is_data_guard_enabled(self) -> bool:
        """
        **Deprecated.** Indicates whether the Autonomous Database has local (in-region) Data Guard enabled. Not applicable to cross-region Autonomous Data Guard associations, or to Autonomous Databases using dedicated Exadata infrastructure or Exadata Cloud@Customer infrastructure.
        """
        return pulumi.get(self, "is_data_guard_enabled")

    @property
    @pulumi.getter(name="isDedicated")
    def is_dedicated(self) -> bool:
        """
        True if the database uses [dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html).
        """
        return pulumi.get(self, "is_dedicated")

    @property
    @pulumi.getter(name="isFreeTier")
    def is_free_tier(self) -> bool:
        """
        Indicates if this is an Always Free resource. The default value is false. Note that Always Free Autonomous Databases have 1 CPU and 20GB of memory. For Always Free databases, memory and CPU cannot be scaled.
        """
        return pulumi.get(self, "is_free_tier")

    @property
    @pulumi.getter(name="isLocalDataGuardEnabled")
    def is_local_data_guard_enabled(self) -> bool:
        """
        Indicates whether the Autonomous Database has local (in-region) Data Guard enabled. Not applicable to cross-region Autonomous Data Guard associations, or to Autonomous Databases using dedicated Exadata infrastructure or Exadata Cloud@Customer infrastructure.
        """
        return pulumi.get(self, "is_local_data_guard_enabled")

    @property
    @pulumi.getter(name="isMtlsConnectionRequired")
    def is_mtls_connection_required(self) -> bool:
        """
        Specifies if the Autonomous Database requires mTLS connections.
        """
        return pulumi.get(self, "is_mtls_connection_required")

    @property
    @pulumi.getter(name="isPreview")
    def is_preview(self) -> bool:
        """
        Indicates if the Autonomous Database version is a preview version.
        """
        return pulumi.get(self, "is_preview")

    @property
    @pulumi.getter(name="isReconnectCloneEnabled")
    def is_reconnect_clone_enabled(self) -> bool:
        """
        Indicates if the refreshable clone can be reconnected to its source database.
        """
        return pulumi.get(self, "is_reconnect_clone_enabled")

    @property
    @pulumi.getter(name="isRefreshableClone")
    def is_refreshable_clone(self) -> bool:
        """
        Indicates if the Autonomous Database is a refreshable clone.
        """
        return pulumi.get(self, "is_refreshable_clone")

    @property
    @pulumi.getter(name="isRemoteDataGuardEnabled")
    def is_remote_data_guard_enabled(self) -> bool:
        """
        Indicates whether the Autonomous Database has Cross Region Data Guard enabled. Not applicable to Autonomous Databases using dedicated Exadata infrastructure or Exadata Cloud@Customer infrastructure.
        """
        return pulumi.get(self, "is_remote_data_guard_enabled")

    @property
    @pulumi.getter(name="keyHistoryEntries")
    def key_history_entries(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseKeyHistoryEntryResult']:
        """
        Key History Entry.
        """
        return pulumi.get(self, "key_history_entries")

    @property
    @pulumi.getter(name="keyStoreId")
    def key_store_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        """
        return pulumi.get(self, "key_store_id")

    @property
    @pulumi.getter(name="keyStoreWalletName")
    def key_store_wallet_name(self) -> str:
        """
        The wallet name for Oracle Key Vault.
        """
        return pulumi.get(self, "key_store_wallet_name")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="kmsKeyLifecycleDetails")
    def kms_key_lifecycle_details(self) -> str:
        """
        KMS key lifecycle details.
        """
        return pulumi.get(self, "kms_key_lifecycle_details")

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> str:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        """
        return pulumi.get(self, "kms_key_version_id")

    @property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> str:
        """
        The Oracle license model that applies to the Oracle Autonomous Database. Bring your own license (BYOL) allows you to apply your current on-premises Oracle software licenses to equivalent, highly automated Oracle PaaS and IaaS services in the cloud. License Included allows you to subscribe to new Oracle Database software licenses and the Database service. Note that when provisioning an Autonomous Database on [dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html), this attribute must be null because the attribute is already set at the Autonomous Exadata Infrastructure level. When using [shared Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html), if a value is not specified, the system will supply the value of `BRING_YOUR_OWN_LICENSE`.
        """
        return pulumi.get(self, "license_model")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="localAdgAutoFailoverMaxDataLossLimit")
    def local_adg_auto_failover_max_data_loss_limit(self) -> int:
        """
        Parameter that allows users to select an acceptable maximum data loss limit in seconds, up to which Automatic Failover will be triggered when necessary for a Local Autonomous Data Guard
        """
        return pulumi.get(self, "local_adg_auto_failover_max_data_loss_limit")

    @property
    @pulumi.getter(name="localDisasterRecoveryType")
    def local_disaster_recovery_type(self) -> str:
        """
        Indicates the local disaster recovery (DR) type of the Autonomous Database Serverless instance. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
        """
        return pulumi.get(self, "local_disaster_recovery_type")

    @property
    @pulumi.getter(name="localStandbyDbs")
    def local_standby_dbs(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseLocalStandbyDbResult']:
        """
        Autonomous Data Guard standby database details.
        """
        return pulumi.get(self, "local_standby_dbs")

    @property
    @pulumi.getter(name="longTermBackupSchedules")
    def long_term_backup_schedules(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseLongTermBackupScheduleResult']:
        """
        Details for the long-term backup schedule.
        """
        return pulumi.get(self, "long_term_backup_schedules")

    @property
    @pulumi.getter(name="maxCpuCoreCount")
    def max_cpu_core_count(self) -> int:
        """
        The number of Max OCPU cores to be made available to the autonomous database with auto scaling of cpu enabled.
        """
        return pulumi.get(self, "max_cpu_core_count")

    @property
    @pulumi.getter(name="memoryPerOracleComputeUnitInGbs")
    def memory_per_oracle_compute_unit_in_gbs(self) -> int:
        """
        The amount of memory (in GBs) enabled per OCPU or ECPU. See [Compute Models in Autonomous Database on Dedicated Exadata Infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/dedicated/adbak) for more details.
        """
        return pulumi.get(self, "memory_per_oracle_compute_unit_in_gbs")

    @property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> str:
        """
        The national character set for the autonomous database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        """
        return pulumi.get(self, "ncharacter_set")

    @property
    @pulumi.getter(name="nextLongTermBackupTimeStamp")
    def next_long_term_backup_time_stamp(self) -> str:
        """
        The date and time when the next long-term backup would be created.
        """
        return pulumi.get(self, "next_long_term_backup_time_stamp")

    @property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Sequence[str]:
        """
        The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the network security groups (NSGs) to which this resource belongs. Setting this to an empty list removes all resources from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). **NsgIds restrictions:**
        * A network security group (NSG) is optional for Autonomous Databases with private access. The nsgIds list can be empty.
        """
        return pulumi.get(self, "nsg_ids")

    @property
    @pulumi.getter(name="ocpuCount")
    def ocpu_count(self) -> float:
        """
        The number of OCPU cores to be made available to the database.
        """
        return pulumi.get(self, "ocpu_count")

    @property
    @pulumi.getter(name="openMode")
    def open_mode(self) -> str:
        """
        Indicates the Autonomous Database mode. The database can be opened in `READ_ONLY` or `READ_WRITE` mode.
        """
        return pulumi.get(self, "open_mode")

    @property
    @pulumi.getter(name="peerDbIds")
    def peer_db_ids(self) -> Sequence[str]:
        """
        The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of standby databases located in Autonomous Data Guard remote regions that are associated with the source database. Note that for shared Exadata infrastructure, standby databases located in the same region as the source primary database do not have OCIDs.
        """
        return pulumi.get(self, "peer_db_ids")

    @property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> str:
        """
        The private endpoint for the resource.
        """
        return pulumi.get(self, "private_endpoint")

    @property
    @pulumi.getter(name="privateEndpointIp")
    def private_endpoint_ip(self) -> str:
        """
        The private endpoint Ip address for the resource.
        """
        return pulumi.get(self, "private_endpoint_ip")

    @property
    @pulumi.getter(name="privateEndpointLabel")
    def private_endpoint_label(self) -> str:
        """
        The resource's private endpoint label. Setting this to an empty string, after the creation of the private endpoint database, changes the private endpoint database to a public endpoint database.
        """
        return pulumi.get(self, "private_endpoint_label")

    @property
    @pulumi.getter(name="provisionableCpuses")
    def provisionable_cpuses(self) -> Sequence[float]:
        """
        An array of CPU values that an Autonomous Database can be scaled to.
        """
        return pulumi.get(self, "provisionable_cpuses")

    @property
    @pulumi.getter(name="refreshableMode")
    def refreshable_mode(self) -> str:
        """
        The refresh mode of the clone. AUTOMATIC indicates that the clone is automatically being refreshed with data from the source Autonomous Database.
        """
        return pulumi.get(self, "refreshable_mode")

    @property
    @pulumi.getter(name="refreshableStatus")
    def refreshable_status(self) -> str:
        """
        The refresh status of the clone. REFRESHING indicates that the clone is currently being refreshed with data from the source Autonomous Database.
        """
        return pulumi.get(self, "refreshable_status")

    @property
    @pulumi.getter(name="remoteDisasterRecoveryConfigurations")
    def remote_disaster_recovery_configurations(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseRemoteDisasterRecoveryConfigurationResult']:
        """
        Configurations of a Disaster Recovery.
        """
        return pulumi.get(self, "remote_disaster_recovery_configurations")

    @property
    @pulumi.getter(name="resourcePoolLeaderId")
    def resource_pool_leader_id(self) -> str:
        """
        The unique identifier for leader autonomous database OCID [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "resource_pool_leader_id")

    @property
    @pulumi.getter(name="resourcePoolSummaries")
    def resource_pool_summaries(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseResourcePoolSummaryResult']:
        """
        The configuration details for resource pool
        """
        return pulumi.get(self, "resource_pool_summaries")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter(name="scheduledOperations")
    def scheduled_operations(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseScheduledOperationResult']:
        """
        The list of scheduled operations.
        """
        return pulumi.get(self, "scheduled_operations")

    @property
    @pulumi.getter(name="serviceConsoleUrl")
    def service_console_url(self) -> str:
        """
        The URL of the Service Console for the Autonomous Database.
        """
        return pulumi.get(self, "service_console_url")

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the source Autonomous Database that was cloned to create the current Autonomous Database.
        """
        return pulumi.get(self, "source_id")

    @property
    @pulumi.getter(name="standbyDbs")
    def standby_dbs(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseStandbyDbResult']:
        """
        **Deprecated** Autonomous Data Guard standby database details.
        """
        return pulumi.get(self, "standby_dbs")

    @property
    @pulumi.getter(name="standbyWhitelistedIps")
    def standby_whitelisted_ips(self) -> Sequence[str]:
        """
        The client IP access control list (ACL). This feature is available for [Autonomous Database Serverless] (https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html) and on Exadata Cloud@Customer. Only clients connecting from an IP address included in the ACL may access the Autonomous Database instance.
        """
        return pulumi.get(self, "standby_whitelisted_ips")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet the resource is associated with.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="supportedRegionsToCloneTos")
    def supported_regions_to_clone_tos(self) -> Sequence[str]:
        """
        The list of regions that support the creation of an Autonomous Database clone or an Autonomous Data Guard standby database.
        """
        return pulumi.get(self, "supported_regions_to_clone_tos")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Mapping[str, Any]:
        """
        System tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "system_tags")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the Autonomous Database was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeDataGuardRoleChanged")
    def time_data_guard_role_changed(self) -> str:
        """
        The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        """
        return pulumi.get(self, "time_data_guard_role_changed")

    @property
    @pulumi.getter(name="timeDeletionOfFreeAutonomousDatabase")
    def time_deletion_of_free_autonomous_database(self) -> str:
        """
        The date and time the Always Free database will be automatically deleted because of inactivity. If the database is in the STOPPED state and without activity until this time, it will be deleted.
        """
        return pulumi.get(self, "time_deletion_of_free_autonomous_database")

    @property
    @pulumi.getter(name="timeDisasterRecoveryRoleChanged")
    def time_disaster_recovery_role_changed(self) -> str:
        """
        The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        return pulumi.get(self, "time_disaster_recovery_role_changed")

    @property
    @pulumi.getter(name="timeLocalDataGuardEnabled")
    def time_local_data_guard_enabled(self) -> str:
        """
        The date and time that Autonomous Data Guard was enabled for an Autonomous Database where the standby was provisioned in the same region as the primary database.
        """
        return pulumi.get(self, "time_local_data_guard_enabled")

    @property
    @pulumi.getter(name="timeMaintenanceBegin")
    def time_maintenance_begin(self) -> str:
        """
        The date and time when maintenance will begin.
        """
        return pulumi.get(self, "time_maintenance_begin")

    @property
    @pulumi.getter(name="timeMaintenanceEnd")
    def time_maintenance_end(self) -> str:
        """
        The date and time when maintenance will end.
        """
        return pulumi.get(self, "time_maintenance_end")

    @property
    @pulumi.getter(name="timeOfJoiningResourcePool")
    def time_of_joining_resource_pool(self) -> str:
        return pulumi.get(self, "time_of_joining_resource_pool")

    @property
    @pulumi.getter(name="timeOfLastFailover")
    def time_of_last_failover(self) -> str:
        """
        The timestamp of the last failover operation.
        """
        return pulumi.get(self, "time_of_last_failover")

    @property
    @pulumi.getter(name="timeOfLastRefresh")
    def time_of_last_refresh(self) -> str:
        """
        The date and time when last refresh happened.
        """
        return pulumi.get(self, "time_of_last_refresh")

    @property
    @pulumi.getter(name="timeOfLastRefreshPoint")
    def time_of_last_refresh_point(self) -> str:
        """
        The refresh point timestamp (UTC). The refresh point is the time to which the database was most recently refreshed. Data created after the refresh point is not included in the refresh.
        """
        return pulumi.get(self, "time_of_last_refresh_point")

    @property
    @pulumi.getter(name="timeOfLastSwitchover")
    def time_of_last_switchover(self) -> str:
        """
        The timestamp of the last switchover operation for the Autonomous Database.
        """
        return pulumi.get(self, "time_of_last_switchover")

    @property
    @pulumi.getter(name="timeOfNextRefresh")
    def time_of_next_refresh(self) -> str:
        """
        The date and time of next refresh.
        """
        return pulumi.get(self, "time_of_next_refresh")

    @property
    @pulumi.getter(name="timeReclamationOfFreeAutonomousDatabase")
    def time_reclamation_of_free_autonomous_database(self) -> str:
        """
        The date and time the Always Free database will be stopped because of inactivity. If this time is reached without any database activity, the database will automatically be put into the STOPPED state.
        """
        return pulumi.get(self, "time_reclamation_of_free_autonomous_database")

    @property
    @pulumi.getter(name="timeUntilReconnectCloneEnabled")
    def time_until_reconnect_clone_enabled(self) -> str:
        """
        The time and date as an RFC3339 formatted string, e.g., 2022-01-01T12:00:00.000Z, to set the limit for a refreshable clone to be reconnected to its source database.
        """
        return pulumi.get(self, "time_until_reconnect_clone_enabled")

    @property
    @pulumi.getter(name="totalBackupStorageSizeInGbs")
    def total_backup_storage_size_in_gbs(self) -> float:
        """
        The backup storage to the database.
        """
        return pulumi.get(self, "total_backup_storage_size_in_gbs")

    @property
    @pulumi.getter(name="usedDataStorageSizeInGbs")
    def used_data_storage_size_in_gbs(self) -> int:
        """
        The storage space consumed by Autonomous Database in GBs.
        """
        return pulumi.get(self, "used_data_storage_size_in_gbs")

    @property
    @pulumi.getter(name="usedDataStorageSizeInTbs")
    def used_data_storage_size_in_tbs(self) -> int:
        """
        The amount of storage that has been used, in terabytes.
        """
        return pulumi.get(self, "used_data_storage_size_in_tbs")

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")

    @property
    @pulumi.getter(name="whitelistedIps")
    def whitelisted_ips(self) -> Sequence[str]:
        """
        The client IP access control list (ACL). This feature is available for [Autonomous Database Serverless] (https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html) and on Exadata Cloud@Customer. Only clients connecting from an IP address included in the ACL may access the Autonomous Database instance.
        """
        return pulumi.get(self, "whitelisted_ips")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseApexDetailResult(dict):
    def __init__(__self__, *,
                 apex_version: str,
                 ords_version: str):
        """
        :param str apex_version: The Oracle APEX Application Development version.
        :param str ords_version: The Oracle REST Data Services (ORDS) version.
        """
        GetAutonomousDatabasesClonesAutonomousDatabaseApexDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apex_version=apex_version,
            ords_version=ords_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apex_version: str,
             ords_version: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("apex_version", apex_version)
        _setter("ords_version", ords_version)

    @property
    @pulumi.getter(name="apexVersion")
    def apex_version(self) -> str:
        """
        The Oracle APEX Application Development version.
        """
        return pulumi.get(self, "apex_version")

    @property
    @pulumi.getter(name="ordsVersion")
    def ords_version(self) -> str:
        """
        The Oracle REST Data Services (ORDS) version.
        """
        return pulumi.get(self, "ords_version")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseBackupConfigResult(dict):
    def __init__(__self__, *,
                 manual_backup_bucket_name: str,
                 manual_backup_type: str):
        """
        :param str manual_backup_bucket_name: Name of [Object Storage](https://docs.cloud.oracle.com/iaas/Content/Object/Concepts/objectstorageoverview.htm) bucket to use for storing manual backups.
        :param str manual_backup_type: The manual backup destination type.
        """
        GetAutonomousDatabasesClonesAutonomousDatabaseBackupConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            manual_backup_bucket_name=manual_backup_bucket_name,
            manual_backup_type=manual_backup_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             manual_backup_bucket_name: str,
             manual_backup_type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("manual_backup_bucket_name", manual_backup_bucket_name)
        _setter("manual_backup_type", manual_backup_type)

    @property
    @pulumi.getter(name="manualBackupBucketName")
    def manual_backup_bucket_name(self) -> str:
        """
        Name of [Object Storage](https://docs.cloud.oracle.com/iaas/Content/Object/Concepts/objectstorageoverview.htm) bucket to use for storing manual backups.
        """
        return pulumi.get(self, "manual_backup_bucket_name")

    @property
    @pulumi.getter(name="manualBackupType")
    def manual_backup_type(self) -> str:
        """
        The manual backup destination type.
        """
        return pulumi.get(self, "manual_backup_type")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseConnectionStringResult(dict):
    def __init__(__self__, *,
                 all_connection_strings: Mapping[str, Any],
                 dedicated: str,
                 high: str,
                 low: str,
                 medium: str,
                 profiles: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseConnectionStringProfileResult']):
        """
        :param Mapping[str, Any] all_connection_strings: Returns all connection strings that can be used to connect to the Autonomous Database. For more information, please see [Predefined Database Service Names for Autonomous Transaction Processing](https://docs.oracle.com/en/cloud/paas/atp-cloud/atpug/connect-predefined.html#GUID-9747539B-FD46-44F1-8FF8-F5AC650F15BE)
        :param str dedicated: The database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        :param str high: The High database service provides the highest level of resources to each SQL statement resulting in the highest performance, but supports the fewest number of concurrent SQL statements.
        :param str low: The Low database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        :param str medium: The Medium database service provides a lower level of resources to each SQL statement potentially resulting a lower level of performance, but supports more concurrent SQL statements.
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseConnectionStringProfileArgs'] profiles: A list of connection string profiles to allow clients to group, filter and select connection string values based on structured metadata.
        """
        GetAutonomousDatabasesClonesAutonomousDatabaseConnectionStringResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_connection_strings=all_connection_strings,
            dedicated=dedicated,
            high=high,
            low=low,
            medium=medium,
            profiles=profiles,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_connection_strings: Mapping[str, Any],
             dedicated: str,
             high: str,
             low: str,
             medium: str,
             profiles: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseConnectionStringProfileResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("all_connection_strings", all_connection_strings)
        _setter("dedicated", dedicated)
        _setter("high", high)
        _setter("low", low)
        _setter("medium", medium)
        _setter("profiles", profiles)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Mapping[str, Any]:
        """
        Returns all connection strings that can be used to connect to the Autonomous Database. For more information, please see [Predefined Database Service Names for Autonomous Transaction Processing](https://docs.oracle.com/en/cloud/paas/atp-cloud/atpug/connect-predefined.html#GUID-9747539B-FD46-44F1-8FF8-F5AC650F15BE)
        """
        return pulumi.get(self, "all_connection_strings")

    @property
    @pulumi.getter
    def dedicated(self) -> str:
        """
        The database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        """
        return pulumi.get(self, "dedicated")

    @property
    @pulumi.getter
    def high(self) -> str:
        """
        The High database service provides the highest level of resources to each SQL statement resulting in the highest performance, but supports the fewest number of concurrent SQL statements.
        """
        return pulumi.get(self, "high")

    @property
    @pulumi.getter
    def low(self) -> str:
        """
        The Low database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        """
        return pulumi.get(self, "low")

    @property
    @pulumi.getter
    def medium(self) -> str:
        """
        The Medium database service provides a lower level of resources to each SQL statement potentially resulting a lower level of performance, but supports more concurrent SQL statements.
        """
        return pulumi.get(self, "medium")

    @property
    @pulumi.getter
    def profiles(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseConnectionStringProfileResult']:
        """
        A list of connection string profiles to allow clients to group, filter and select connection string values based on structured metadata.
        """
        return pulumi.get(self, "profiles")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseConnectionStringProfileResult(dict):
    def __init__(__self__, *,
                 consumer_group: str,
                 display_name: str,
                 host_format: str,
                 protocol: str,
                 session_mode: str,
                 syntax_format: str,
                 tls_authentication: str,
                 value: str):
        """
        :param str consumer_group: Consumer group used by the connection.
        :param str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param str host_format: Host format used in connection string.
        :param str protocol: Protocol used by the connection.
        :param str session_mode: Specifies whether the listener performs a direct hand-off of the session, or redirects the session. In RAC deployments where SCAN is used, sessions are redirected to a Node VIP. Use `DIRECT` for direct hand-offs. Use `REDIRECT` to redirect the session.
        :param str syntax_format: Specifies whether the connection string is using the long (`LONG`), Easy Connect (`EZCONNECT`), or Easy Connect Plus (`EZCONNECTPLUS`) format. Autonomous Database Serverless instances always use the long format.
        :param str tls_authentication: Specifies whether the TLS handshake is using one-way (`SERVER`) or mutual (`MUTUAL`) authentication.
        :param str value: Connection string value.
        """
        GetAutonomousDatabasesClonesAutonomousDatabaseConnectionStringProfileResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            consumer_group=consumer_group,
            display_name=display_name,
            host_format=host_format,
            protocol=protocol,
            session_mode=session_mode,
            syntax_format=syntax_format,
            tls_authentication=tls_authentication,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             consumer_group: str,
             display_name: str,
             host_format: str,
             protocol: str,
             session_mode: str,
             syntax_format: str,
             tls_authentication: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("consumer_group", consumer_group)
        _setter("display_name", display_name)
        _setter("host_format", host_format)
        _setter("protocol", protocol)
        _setter("session_mode", session_mode)
        _setter("syntax_format", syntax_format)
        _setter("tls_authentication", tls_authentication)
        _setter("value", value)

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> str:
        """
        Consumer group used by the connection.
        """
        return pulumi.get(self, "consumer_group")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="hostFormat")
    def host_format(self) -> str:
        """
        Host format used in connection string.
        """
        return pulumi.get(self, "host_format")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Protocol used by the connection.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sessionMode")
    def session_mode(self) -> str:
        """
        Specifies whether the listener performs a direct hand-off of the session, or redirects the session. In RAC deployments where SCAN is used, sessions are redirected to a Node VIP. Use `DIRECT` for direct hand-offs. Use `REDIRECT` to redirect the session.
        """
        return pulumi.get(self, "session_mode")

    @property
    @pulumi.getter(name="syntaxFormat")
    def syntax_format(self) -> str:
        """
        Specifies whether the connection string is using the long (`LONG`), Easy Connect (`EZCONNECT`), or Easy Connect Plus (`EZCONNECTPLUS`) format. Autonomous Database Serverless instances always use the long format.
        """
        return pulumi.get(self, "syntax_format")

    @property
    @pulumi.getter(name="tlsAuthentication")
    def tls_authentication(self) -> str:
        """
        Specifies whether the TLS handshake is using one-way (`SERVER`) or mutual (`MUTUAL`) authentication.
        """
        return pulumi.get(self, "tls_authentication")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Connection string value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseConnectionUrlResult(dict):
    def __init__(__self__, *,
                 apex_url: str,
                 graph_studio_url: str,
                 machine_learning_user_management_url: str,
                 sql_dev_web_url: str):
        """
        :param str apex_url: Oracle Application Express (APEX) URL.
        :param str graph_studio_url: The URL of the Graph Studio for the Autonomous Database.
        :param str machine_learning_user_management_url: Oracle Machine Learning user management URL.
        :param str sql_dev_web_url: Oracle SQL Developer Web URL.
        """
        GetAutonomousDatabasesClonesAutonomousDatabaseConnectionUrlResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apex_url=apex_url,
            graph_studio_url=graph_studio_url,
            machine_learning_user_management_url=machine_learning_user_management_url,
            sql_dev_web_url=sql_dev_web_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apex_url: str,
             graph_studio_url: str,
             machine_learning_user_management_url: str,
             sql_dev_web_url: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("apex_url", apex_url)
        _setter("graph_studio_url", graph_studio_url)
        _setter("machine_learning_user_management_url", machine_learning_user_management_url)
        _setter("sql_dev_web_url", sql_dev_web_url)

    @property
    @pulumi.getter(name="apexUrl")
    def apex_url(self) -> str:
        """
        Oracle Application Express (APEX) URL.
        """
        return pulumi.get(self, "apex_url")

    @property
    @pulumi.getter(name="graphStudioUrl")
    def graph_studio_url(self) -> str:
        """
        The URL of the Graph Studio for the Autonomous Database.
        """
        return pulumi.get(self, "graph_studio_url")

    @property
    @pulumi.getter(name="machineLearningUserManagementUrl")
    def machine_learning_user_management_url(self) -> str:
        """
        Oracle Machine Learning user management URL.
        """
        return pulumi.get(self, "machine_learning_user_management_url")

    @property
    @pulumi.getter(name="sqlDevWebUrl")
    def sql_dev_web_url(self) -> str:
        """
        Oracle SQL Developer Web URL.
        """
        return pulumi.get(self, "sql_dev_web_url")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseCustomerContactResult(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        GetAutonomousDatabasesClonesAutonomousDatabaseCustomerContactResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            email=email,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             email: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseKeyHistoryEntryResult(dict):
    def __init__(__self__, *,
                 id: str,
                 kms_key_version_id: str,
                 time_activated: str,
                 vault_id: str):
        """
        :param str id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        :param str time_activated: The date and time the kms key activated.
        :param str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        GetAutonomousDatabasesClonesAutonomousDatabaseKeyHistoryEntryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            kms_key_version_id=kms_key_version_id,
            time_activated=time_activated,
            vault_id=vault_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             kms_key_version_id: str,
             time_activated: str,
             vault_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("kms_key_version_id", kms_key_version_id)
        _setter("time_activated", time_activated)
        _setter("vault_id", vault_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> str:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        """
        return pulumi.get(self, "kms_key_version_id")

    @property
    @pulumi.getter(name="timeActivated")
    def time_activated(self) -> str:
        """
        The date and time the kms key activated.
        """
        return pulumi.get(self, "time_activated")

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseLocalStandbyDbResult(dict):
    def __init__(__self__, *,
                 lag_time_in_seconds: int,
                 lifecycle_details: str,
                 state: str,
                 time_data_guard_role_changed: str,
                 time_disaster_recovery_role_changed: str):
        """
        :param int lag_time_in_seconds: The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        :param str time_data_guard_role_changed: The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        :param str time_disaster_recovery_role_changed: The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        GetAutonomousDatabasesClonesAutonomousDatabaseLocalStandbyDbResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lag_time_in_seconds=lag_time_in_seconds,
            lifecycle_details=lifecycle_details,
            state=state,
            time_data_guard_role_changed=time_data_guard_role_changed,
            time_disaster_recovery_role_changed=time_disaster_recovery_role_changed,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lag_time_in_seconds: int,
             lifecycle_details: str,
             state: str,
             time_data_guard_role_changed: str,
             time_disaster_recovery_role_changed: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("lag_time_in_seconds", lag_time_in_seconds)
        _setter("lifecycle_details", lifecycle_details)
        _setter("state", state)
        _setter("time_data_guard_role_changed", time_data_guard_role_changed)
        _setter("time_disaster_recovery_role_changed", time_disaster_recovery_role_changed)

    @property
    @pulumi.getter(name="lagTimeInSeconds")
    def lag_time_in_seconds(self) -> int:
        """
        The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        """
        return pulumi.get(self, "lag_time_in_seconds")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeDataGuardRoleChanged")
    def time_data_guard_role_changed(self) -> str:
        """
        The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        """
        return pulumi.get(self, "time_data_guard_role_changed")

    @property
    @pulumi.getter(name="timeDisasterRecoveryRoleChanged")
    def time_disaster_recovery_role_changed(self) -> str:
        """
        The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        return pulumi.get(self, "time_disaster_recovery_role_changed")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseLongTermBackupScheduleResult(dict):
    def __init__(__self__, *,
                 is_disabled: bool,
                 repeat_cadence: str,
                 retention_period_in_days: int,
                 time_of_backup: str):
        """
        :param bool is_disabled: Indicates if the resource pool should be deleted for the Autonomous Database.
        :param str repeat_cadence: The frequency of the long-term backup schedule
        :param int retention_period_in_days: Retention period, in days, for long-term backups
        :param str time_of_backup: The timestamp for the long-term backup schedule. For a MONTHLY cadence, months having fewer days than the provided date will have the backup taken on the last day of that month.
        """
        GetAutonomousDatabasesClonesAutonomousDatabaseLongTermBackupScheduleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_disabled=is_disabled,
            repeat_cadence=repeat_cadence,
            retention_period_in_days=retention_period_in_days,
            time_of_backup=time_of_backup,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_disabled: bool,
             repeat_cadence: str,
             retention_period_in_days: int,
             time_of_backup: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("is_disabled", is_disabled)
        _setter("repeat_cadence", repeat_cadence)
        _setter("retention_period_in_days", retention_period_in_days)
        _setter("time_of_backup", time_of_backup)

    @property
    @pulumi.getter(name="isDisabled")
    def is_disabled(self) -> bool:
        """
        Indicates if the resource pool should be deleted for the Autonomous Database.
        """
        return pulumi.get(self, "is_disabled")

    @property
    @pulumi.getter(name="repeatCadence")
    def repeat_cadence(self) -> str:
        """
        The frequency of the long-term backup schedule
        """
        return pulumi.get(self, "repeat_cadence")

    @property
    @pulumi.getter(name="retentionPeriodInDays")
    def retention_period_in_days(self) -> int:
        """
        Retention period, in days, for long-term backups
        """
        return pulumi.get(self, "retention_period_in_days")

    @property
    @pulumi.getter(name="timeOfBackup")
    def time_of_backup(self) -> str:
        """
        The timestamp for the long-term backup schedule. For a MONTHLY cadence, months having fewer days than the provided date will have the backup taken on the last day of that month.
        """
        return pulumi.get(self, "time_of_backup")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseRemoteDisasterRecoveryConfigurationResult(dict):
    def __init__(__self__, *,
                 disaster_recovery_type: str):
        """
        :param str disaster_recovery_type: Indicates the disaster recovery (DR) type of the Shared Autonomous Database. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
        """
        GetAutonomousDatabasesClonesAutonomousDatabaseRemoteDisasterRecoveryConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disaster_recovery_type=disaster_recovery_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disaster_recovery_type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("disaster_recovery_type", disaster_recovery_type)

    @property
    @pulumi.getter(name="disasterRecoveryType")
    def disaster_recovery_type(self) -> str:
        """
        Indicates the disaster recovery (DR) type of the Shared Autonomous Database. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
        """
        return pulumi.get(self, "disaster_recovery_type")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseResourcePoolSummaryResult(dict):
    def __init__(__self__, *,
                 is_disabled: bool,
                 pool_size: int):
        """
        :param bool is_disabled: Indicates if the resource pool should be deleted for the Autonomous Database.
        :param int pool_size: Resource pool size.
        """
        GetAutonomousDatabasesClonesAutonomousDatabaseResourcePoolSummaryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_disabled=is_disabled,
            pool_size=pool_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_disabled: bool,
             pool_size: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("is_disabled", is_disabled)
        _setter("pool_size", pool_size)

    @property
    @pulumi.getter(name="isDisabled")
    def is_disabled(self) -> bool:
        """
        Indicates if the resource pool should be deleted for the Autonomous Database.
        """
        return pulumi.get(self, "is_disabled")

    @property
    @pulumi.getter(name="poolSize")
    def pool_size(self) -> int:
        """
        Resource pool size.
        """
        return pulumi.get(self, "pool_size")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseScheduledOperationResult(dict):
    def __init__(__self__, *,
                 day_of_weeks: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseScheduledOperationDayOfWeekResult'],
                 scheduled_start_time: str,
                 scheduled_stop_time: str):
        """
        :param Sequence['GetAutonomousDatabasesClonesAutonomousDatabaseScheduledOperationDayOfWeekArgs'] day_of_weeks: Day of the week.
        :param str scheduled_start_time: auto start time. value must be of ISO-8601 format "HH:mm"
        :param str scheduled_stop_time: auto stop time. value must be of ISO-8601 format "HH:mm"
        """
        GetAutonomousDatabasesClonesAutonomousDatabaseScheduledOperationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            day_of_weeks=day_of_weeks,
            scheduled_start_time=scheduled_start_time,
            scheduled_stop_time=scheduled_stop_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             day_of_weeks: Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseScheduledOperationDayOfWeekResult'],
             scheduled_start_time: str,
             scheduled_stop_time: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("day_of_weeks", day_of_weeks)
        _setter("scheduled_start_time", scheduled_start_time)
        _setter("scheduled_stop_time", scheduled_stop_time)

    @property
    @pulumi.getter(name="dayOfWeeks")
    def day_of_weeks(self) -> Sequence['outputs.GetAutonomousDatabasesClonesAutonomousDatabaseScheduledOperationDayOfWeekResult']:
        """
        Day of the week.
        """
        return pulumi.get(self, "day_of_weeks")

    @property
    @pulumi.getter(name="scheduledStartTime")
    def scheduled_start_time(self) -> str:
        """
        auto start time. value must be of ISO-8601 format "HH:mm"
        """
        return pulumi.get(self, "scheduled_start_time")

    @property
    @pulumi.getter(name="scheduledStopTime")
    def scheduled_stop_time(self) -> str:
        """
        auto stop time. value must be of ISO-8601 format "HH:mm"
        """
        return pulumi.get(self, "scheduled_stop_time")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseScheduledOperationDayOfWeekResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the day of the week.
        """
        GetAutonomousDatabasesClonesAutonomousDatabaseScheduledOperationDayOfWeekResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the day of the week.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousDatabasesClonesAutonomousDatabaseStandbyDbResult(dict):
    def __init__(__self__, *,
                 lag_time_in_seconds: int,
                 lifecycle_details: str,
                 state: str,
                 time_data_guard_role_changed: str,
                 time_disaster_recovery_role_changed: str):
        """
        :param int lag_time_in_seconds: The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        :param str time_data_guard_role_changed: The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        :param str time_disaster_recovery_role_changed: The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        GetAutonomousDatabasesClonesAutonomousDatabaseStandbyDbResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lag_time_in_seconds=lag_time_in_seconds,
            lifecycle_details=lifecycle_details,
            state=state,
            time_data_guard_role_changed=time_data_guard_role_changed,
            time_disaster_recovery_role_changed=time_disaster_recovery_role_changed,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lag_time_in_seconds: int,
             lifecycle_details: str,
             state: str,
             time_data_guard_role_changed: str,
             time_disaster_recovery_role_changed: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("lag_time_in_seconds", lag_time_in_seconds)
        _setter("lifecycle_details", lifecycle_details)
        _setter("state", state)
        _setter("time_data_guard_role_changed", time_data_guard_role_changed)
        _setter("time_disaster_recovery_role_changed", time_disaster_recovery_role_changed)

    @property
    @pulumi.getter(name="lagTimeInSeconds")
    def lag_time_in_seconds(self) -> int:
        """
        The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        """
        return pulumi.get(self, "lag_time_in_seconds")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeDataGuardRoleChanged")
    def time_data_guard_role_changed(self) -> str:
        """
        The date and time the Autonomous Data Guard role was switched for the Autonomous Database. For databases that have standbys in both the primary Data Guard region and a remote Data Guard standby region, this is the latest timestamp of either the database using the "primary" role in the primary Data Guard region, or database located in the remote Data Guard standby region.
        """
        return pulumi.get(self, "time_data_guard_role_changed")

    @property
    @pulumi.getter(name="timeDisasterRecoveryRoleChanged")
    def time_disaster_recovery_role_changed(self) -> str:
        """
        The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
        """
        return pulumi.get(self, "time_disaster_recovery_role_changed")


@pulumi.output_type
class GetAutonomousDatabasesClonesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the day of the week.
        """
        GetAutonomousDatabasesClonesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the day of the week.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousDatabasesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the day of the week.
        """
        GetAutonomousDatabasesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the day of the week.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousDbPreviewVersionsAutonomousDbPreviewVersionResult(dict):
    def __init__(__self__, *,
                 db_workload: str,
                 details: str,
                 time_preview_begin: str,
                 time_preview_end: str,
                 version: str):
        """
        :param str db_workload: The Autonomous Database workload type. The following values are valid:
               * OLTP - indicates an Autonomous Transaction Processing database
               * DW - indicates an Autonomous Data Warehouse database
               * AJD - indicates an Autonomous JSON Database
               * APEX - indicates an Autonomous Database with the Oracle APEX Application Development workload type.
        :param str details: A URL that points to a detailed description of the preview version.
        :param str time_preview_begin: The date and time when the preview version availability begins.
        :param str time_preview_end: The date and time when the preview version availability ends.
        :param str version: A valid Autonomous Database preview version.
        """
        GetAutonomousDbPreviewVersionsAutonomousDbPreviewVersionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_workload=db_workload,
            details=details,
            time_preview_begin=time_preview_begin,
            time_preview_end=time_preview_end,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_workload: str,
             details: str,
             time_preview_begin: str,
             time_preview_end: str,
             version: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("db_workload", db_workload)
        _setter("details", details)
        _setter("time_preview_begin", time_preview_begin)
        _setter("time_preview_end", time_preview_end)
        _setter("version", version)

    @property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> str:
        """
        The Autonomous Database workload type. The following values are valid:
        * OLTP - indicates an Autonomous Transaction Processing database
        * DW - indicates an Autonomous Data Warehouse database
        * AJD - indicates an Autonomous JSON Database
        * APEX - indicates an Autonomous Database with the Oracle APEX Application Development workload type.
        """
        return pulumi.get(self, "db_workload")

    @property
    @pulumi.getter
    def details(self) -> str:
        """
        A URL that points to a detailed description of the preview version.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter(name="timePreviewBegin")
    def time_preview_begin(self) -> str:
        """
        The date and time when the preview version availability begins.
        """
        return pulumi.get(self, "time_preview_begin")

    @property
    @pulumi.getter(name="timePreviewEnd")
    def time_preview_end(self) -> str:
        """
        The date and time when the preview version availability ends.
        """
        return pulumi.get(self, "time_preview_end")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        A valid Autonomous Database preview version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetAutonomousDbPreviewVersionsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetAutonomousDbPreviewVersionsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousDbVersionsAutonomousDbVersionResult(dict):
    def __init__(__self__, *,
                 db_workload: str,
                 details: str,
                 is_dedicated: bool,
                 is_default_for_free: bool,
                 is_default_for_paid: bool,
                 is_free_tier_enabled: bool,
                 is_paid_enabled: bool,
                 version: str):
        """
        :param str db_workload: A filter to return only autonomous database resources that match the specified workload type.
        :param str details: A URL that points to a detailed description of the Autonomous Database version.
        :param bool is_dedicated: True if the database uses [dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html).
        :param bool is_default_for_free: True if this version of the Oracle Database software's default is free.
        :param bool is_default_for_paid: True if this version of the Oracle Database software's default is paid.
        :param bool is_free_tier_enabled: True if this version of the Oracle Database software can be used for Always-Free Autonomous Databases.
        :param bool is_paid_enabled: True if this version of the Oracle Database software has payments enabled.
        :param str version: A valid Oracle Database version for Autonomous Database.
        """
        GetAutonomousDbVersionsAutonomousDbVersionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_workload=db_workload,
            details=details,
            is_dedicated=is_dedicated,
            is_default_for_free=is_default_for_free,
            is_default_for_paid=is_default_for_paid,
            is_free_tier_enabled=is_free_tier_enabled,
            is_paid_enabled=is_paid_enabled,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_workload: str,
             details: str,
             is_dedicated: bool,
             is_default_for_free: bool,
             is_default_for_paid: bool,
             is_free_tier_enabled: bool,
             is_paid_enabled: bool,
             version: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("db_workload", db_workload)
        _setter("details", details)
        _setter("is_dedicated", is_dedicated)
        _setter("is_default_for_free", is_default_for_free)
        _setter("is_default_for_paid", is_default_for_paid)
        _setter("is_free_tier_enabled", is_free_tier_enabled)
        _setter("is_paid_enabled", is_paid_enabled)
        _setter("version", version)

    @property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> str:
        """
        A filter to return only autonomous database resources that match the specified workload type.
        """
        return pulumi.get(self, "db_workload")

    @property
    @pulumi.getter
    def details(self) -> str:
        """
        A URL that points to a detailed description of the Autonomous Database version.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter(name="isDedicated")
    def is_dedicated(self) -> bool:
        """
        True if the database uses [dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html).
        """
        return pulumi.get(self, "is_dedicated")

    @property
    @pulumi.getter(name="isDefaultForFree")
    def is_default_for_free(self) -> bool:
        """
        True if this version of the Oracle Database software's default is free.
        """
        return pulumi.get(self, "is_default_for_free")

    @property
    @pulumi.getter(name="isDefaultForPaid")
    def is_default_for_paid(self) -> bool:
        """
        True if this version of the Oracle Database software's default is paid.
        """
        return pulumi.get(self, "is_default_for_paid")

    @property
    @pulumi.getter(name="isFreeTierEnabled")
    def is_free_tier_enabled(self) -> bool:
        """
        True if this version of the Oracle Database software can be used for Always-Free Autonomous Databases.
        """
        return pulumi.get(self, "is_free_tier_enabled")

    @property
    @pulumi.getter(name="isPaidEnabled")
    def is_paid_enabled(self) -> bool:
        """
        True if this version of the Oracle Database software has payments enabled.
        """
        return pulumi.get(self, "is_paid_enabled")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        A valid Oracle Database version for Autonomous Database.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetAutonomousDbVersionsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetAutonomousDbVersionsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousExadataInfrastructureMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: int,
                 days_of_weeks: Sequence['outputs.GetAutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekResult'],
                 hours_of_days: Sequence[int],
                 is_custom_action_timeout_enabled: bool,
                 is_monthly_patching_enabled: bool,
                 lead_time_in_weeks: int,
                 months: Sequence['outputs.GetAutonomousExadataInfrastructureMaintenanceWindowMonthResult'],
                 patching_mode: str,
                 preference: str,
                 weeks_of_months: Sequence[int]):
        """
        :param int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetAutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetAutonomousExadataInfrastructureMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param str preference: The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        GetAutonomousExadataInfrastructureMaintenanceWindowResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: int,
             days_of_weeks: Sequence['outputs.GetAutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekResult'],
             hours_of_days: Sequence[int],
             is_custom_action_timeout_enabled: bool,
             is_monthly_patching_enabled: bool,
             lead_time_in_weeks: int,
             months: Sequence['outputs.GetAutonomousExadataInfrastructureMaintenanceWindowMonthResult'],
             patching_mode: str,
             preference: str,
             weeks_of_months: Sequence[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        _setter("days_of_weeks", days_of_weeks)
        _setter("hours_of_days", hours_of_days)
        _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        _setter("lead_time_in_weeks", lead_time_in_weeks)
        _setter("months", months)
        _setter("patching_mode", patching_mode)
        _setter("preference", preference)
        _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetAutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetAutonomousExadataInfrastructureMaintenanceWindowMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetAutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetAutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousExadataInfrastructureMaintenanceWindowDetailResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: int,
                 days_of_weeks: Sequence['outputs.GetAutonomousExadataInfrastructureMaintenanceWindowDetailDaysOfWeekResult'],
                 hours_of_days: Sequence[int],
                 is_custom_action_timeout_enabled: bool,
                 is_monthly_patching_enabled: bool,
                 lead_time_in_weeks: int,
                 months: Sequence['outputs.GetAutonomousExadataInfrastructureMaintenanceWindowDetailMonthResult'],
                 patching_mode: str,
                 preference: str,
                 weeks_of_months: Sequence[int]):
        """
        :param int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetAutonomousExadataInfrastructureMaintenanceWindowDetailDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetAutonomousExadataInfrastructureMaintenanceWindowDetailMonthArgs'] months: Months during the year when maintenance should be performed.
        :param str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param str preference: The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        GetAutonomousExadataInfrastructureMaintenanceWindowDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: int,
             days_of_weeks: Sequence['outputs.GetAutonomousExadataInfrastructureMaintenanceWindowDetailDaysOfWeekResult'],
             hours_of_days: Sequence[int],
             is_custom_action_timeout_enabled: bool,
             is_monthly_patching_enabled: bool,
             lead_time_in_weeks: int,
             months: Sequence['outputs.GetAutonomousExadataInfrastructureMaintenanceWindowDetailMonthResult'],
             patching_mode: str,
             preference: str,
             weeks_of_months: Sequence[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        _setter("days_of_weeks", days_of_weeks)
        _setter("hours_of_days", hours_of_days)
        _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        _setter("lead_time_in_weeks", lead_time_in_weeks)
        _setter("months", months)
        _setter("patching_mode", patching_mode)
        _setter("preference", preference)
        _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetAutonomousExadataInfrastructureMaintenanceWindowDetailDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetAutonomousExadataInfrastructureMaintenanceWindowDetailMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetAutonomousExadataInfrastructureMaintenanceWindowDetailDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetAutonomousExadataInfrastructureMaintenanceWindowDetailDaysOfWeekResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousExadataInfrastructureMaintenanceWindowDetailMonthResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetAutonomousExadataInfrastructureMaintenanceWindowDetailMonthResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousExadataInfrastructureMaintenanceWindowMonthResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetAutonomousExadataInfrastructureMaintenanceWindowMonthResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousExadataInfrastructureOcpuByWorkloadTypeResult(dict):
    def __init__(__self__, *,
                 adw: float,
                 atp: float):
        """
        :param float adw: The total number of OCPU cores in use for Autonomous Data Warehouse databases in the infrastructure instance.
        :param float atp: The total number of OCPU cores in use for Autonomous Transaction Processing databases in the infrastructure instance.
        """
        GetAutonomousExadataInfrastructureOcpuByWorkloadTypeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            adw=adw,
            atp=atp,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             adw: float,
             atp: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("adw", adw)
        _setter("atp", atp)

    @property
    @pulumi.getter
    def adw(self) -> float:
        """
        The total number of OCPU cores in use for Autonomous Data Warehouse databases in the infrastructure instance.
        """
        return pulumi.get(self, "adw")

    @property
    @pulumi.getter
    def atp(self) -> float:
        """
        The total number of OCPU cores in use for Autonomous Transaction Processing databases in the infrastructure instance.
        """
        return pulumi.get(self, "atp")


@pulumi.output_type
class GetAutonomousExadataInfrastructureShapesAutonomousExadataInfrastructureShapeResult(dict):
    def __init__(__self__, *,
                 available_core_count: int,
                 core_count_increment: int,
                 maximum_node_count: int,
                 minimum_core_count: int,
                 minimum_node_count: int,
                 name: str):
        """
        :param int available_core_count: The maximum number of CPU cores that can be enabled on the Autonomous Exadata Infrastructure.
        :param int core_count_increment: The increment in which core count can be increased or decreased.
        :param int maximum_node_count: The maximum number of nodes available for the shape.
        :param int minimum_core_count: The minimum number of CPU cores that can be enabled on the Autonomous Exadata Infrastructure.
        :param int minimum_node_count: The minimum number of nodes available for the shape.
        :param str name: The name of the shape used for the Autonomous Exadata Infrastructure.
        """
        GetAutonomousExadataInfrastructureShapesAutonomousExadataInfrastructureShapeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            available_core_count=available_core_count,
            core_count_increment=core_count_increment,
            maximum_node_count=maximum_node_count,
            minimum_core_count=minimum_core_count,
            minimum_node_count=minimum_node_count,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             available_core_count: int,
             core_count_increment: int,
             maximum_node_count: int,
             minimum_core_count: int,
             minimum_node_count: int,
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("available_core_count", available_core_count)
        _setter("core_count_increment", core_count_increment)
        _setter("maximum_node_count", maximum_node_count)
        _setter("minimum_core_count", minimum_core_count)
        _setter("minimum_node_count", minimum_node_count)
        _setter("name", name)

    @property
    @pulumi.getter(name="availableCoreCount")
    def available_core_count(self) -> int:
        """
        The maximum number of CPU cores that can be enabled on the Autonomous Exadata Infrastructure.
        """
        return pulumi.get(self, "available_core_count")

    @property
    @pulumi.getter(name="coreCountIncrement")
    def core_count_increment(self) -> int:
        """
        The increment in which core count can be increased or decreased.
        """
        return pulumi.get(self, "core_count_increment")

    @property
    @pulumi.getter(name="maximumNodeCount")
    def maximum_node_count(self) -> int:
        """
        The maximum number of nodes available for the shape.
        """
        return pulumi.get(self, "maximum_node_count")

    @property
    @pulumi.getter(name="minimumCoreCount")
    def minimum_core_count(self) -> int:
        """
        The minimum number of CPU cores that can be enabled on the Autonomous Exadata Infrastructure.
        """
        return pulumi.get(self, "minimum_core_count")

    @property
    @pulumi.getter(name="minimumNodeCount")
    def minimum_node_count(self) -> int:
        """
        The minimum number of nodes available for the shape.
        """
        return pulumi.get(self, "minimum_node_count")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the shape used for the Autonomous Exadata Infrastructure.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousExadataInfrastructureShapesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the shape used for the Autonomous Exadata Infrastructure.
        """
        GetAutonomousExadataInfrastructureShapesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the shape used for the Autonomous Exadata Infrastructure.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureResult(dict):
    def __init__(__self__, *,
                 availability_domain: str,
                 compartment_id: str,
                 create_async: bool,
                 defined_tags: Mapping[str, Any],
                 display_name: str,
                 domain: str,
                 freeform_tags: Mapping[str, Any],
                 hostname: str,
                 id: str,
                 last_maintenance_run_id: str,
                 license_model: str,
                 lifecycle_details: str,
                 maintenance_window_details: Sequence['outputs.GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailResult'],
                 maintenance_windows: Sequence['outputs.GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowResult'],
                 next_maintenance_run_id: str,
                 nsg_ids: Sequence[str],
                 scan_dns_name: str,
                 shape: str,
                 state: str,
                 subnet_id: str,
                 time_created: str,
                 zone_id: str):
        """
        :param str availability_domain: A filter to return only resources that match the given availability domain exactly.
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param str domain: The domain name for the Autonomous Exadata Infrastructure.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str hostname: The host name for the Autonomous Exadata Infrastructure node.
        :param str id: The OCID of the Autonomous Exadata Infrastructure.
        :param str last_maintenance_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance run.
        :param str license_model: The Oracle license model that applies to all databases in the Autonomous Exadata Infrastructure. The default is BRING_YOUR_OWN_LICENSE.
        :param str lifecycle_details: Additional information about the current lifecycle state of the Autonomous Exadata Infrastructure.
        :param Sequence['GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowArgs'] maintenance_windows: The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        :param str next_maintenance_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the next maintenance run.
        :param Sequence[str] nsg_ids: The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the network security groups (NSGs) to which this resource belongs. Setting this to an empty list removes all resources from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). **NsgIds restrictions:**
               * A network security group (NSG) is optional for Autonomous Databases with private access. The nsgIds list can be empty.
        :param str scan_dns_name: The FQDN of the DNS record for the SCAN IP addresses that are associated with the Autonomous Exadata Infrastructure.
        :param str shape: The shape of the Autonomous Exadata Infrastructure. The shape determines resources to allocate to the Autonomous Exadata Infrastructure (CPU cores, memory and storage).
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        :param str subnet_id: The OCID of the subnet the Autonomous Exadata Infrastructure is associated with.
        :param str time_created: The date and time the Autonomous Exadata Infrastructure was created.
        :param str zone_id: The OCID of the zone the Autonomous Exadata Infrastructure is associated with.
        """
        GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_domain=availability_domain,
            compartment_id=compartment_id,
            create_async=create_async,
            defined_tags=defined_tags,
            display_name=display_name,
            domain=domain,
            freeform_tags=freeform_tags,
            hostname=hostname,
            id=id,
            last_maintenance_run_id=last_maintenance_run_id,
            license_model=license_model,
            lifecycle_details=lifecycle_details,
            maintenance_window_details=maintenance_window_details,
            maintenance_windows=maintenance_windows,
            next_maintenance_run_id=next_maintenance_run_id,
            nsg_ids=nsg_ids,
            scan_dns_name=scan_dns_name,
            shape=shape,
            state=state,
            subnet_id=subnet_id,
            time_created=time_created,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_domain: str,
             compartment_id: str,
             create_async: bool,
             defined_tags: Mapping[str, Any],
             display_name: str,
             domain: str,
             freeform_tags: Mapping[str, Any],
             hostname: str,
             id: str,
             last_maintenance_run_id: str,
             license_model: str,
             lifecycle_details: str,
             maintenance_window_details: Sequence['outputs.GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailResult'],
             maintenance_windows: Sequence['outputs.GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowResult'],
             next_maintenance_run_id: str,
             nsg_ids: Sequence[str],
             scan_dns_name: str,
             shape: str,
             state: str,
             subnet_id: str,
             time_created: str,
             zone_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("availability_domain", availability_domain)
        _setter("compartment_id", compartment_id)
        _setter("create_async", create_async)
        _setter("defined_tags", defined_tags)
        _setter("display_name", display_name)
        _setter("domain", domain)
        _setter("freeform_tags", freeform_tags)
        _setter("hostname", hostname)
        _setter("id", id)
        _setter("last_maintenance_run_id", last_maintenance_run_id)
        _setter("license_model", license_model)
        _setter("lifecycle_details", lifecycle_details)
        _setter("maintenance_window_details", maintenance_window_details)
        _setter("maintenance_windows", maintenance_windows)
        _setter("next_maintenance_run_id", next_maintenance_run_id)
        _setter("nsg_ids", nsg_ids)
        _setter("scan_dns_name", scan_dns_name)
        _setter("shape", shape)
        _setter("state", state)
        _setter("subnet_id", subnet_id)
        _setter("time_created", time_created)
        _setter("zone_id", zone_id)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> str:
        """
        A filter to return only resources that match the given availability domain exactly.
        """
        warnings.warn("""Autonomous Exadata Infrastructure resource is now end-of-life.Please provision cloud autonomous vm cluster instead.""", DeprecationWarning)
        pulumi.log.warn("""availability_domain is deprecated: Autonomous Exadata Infrastructure resource is now end-of-life.Please provision cloud autonomous vm cluster instead.""")

        return pulumi.get(self, "availability_domain")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="createAsync")
    def create_async(self) -> bool:
        return pulumi.get(self, "create_async")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The domain name for the Autonomous Exadata Infrastructure.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host name for the Autonomous Exadata Infrastructure node.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the Autonomous Exadata Infrastructure.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastMaintenanceRunId")
    def last_maintenance_run_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance run.
        """
        return pulumi.get(self, "last_maintenance_run_id")

    @property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> str:
        """
        The Oracle license model that applies to all databases in the Autonomous Exadata Infrastructure. The default is BRING_YOUR_OWN_LICENSE.
        """
        return pulumi.get(self, "license_model")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state of the Autonomous Exadata Infrastructure.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="maintenanceWindowDetails")
    def maintenance_window_details(self) -> Sequence['outputs.GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailResult']:
        return pulumi.get(self, "maintenance_window_details")

    @property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Sequence['outputs.GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowResult']:
        """
        The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        """
        return pulumi.get(self, "maintenance_windows")

    @property
    @pulumi.getter(name="nextMaintenanceRunId")
    def next_maintenance_run_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the next maintenance run.
        """
        return pulumi.get(self, "next_maintenance_run_id")

    @property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Sequence[str]:
        """
        The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the network security groups (NSGs) to which this resource belongs. Setting this to an empty list removes all resources from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). **NsgIds restrictions:**
        * A network security group (NSG) is optional for Autonomous Databases with private access. The nsgIds list can be empty.
        """
        return pulumi.get(self, "nsg_ids")

    @property
    @pulumi.getter(name="scanDnsName")
    def scan_dns_name(self) -> str:
        """
        The FQDN of the DNS record for the SCAN IP addresses that are associated with the Autonomous Exadata Infrastructure.
        """
        return pulumi.get(self, "scan_dns_name")

    @property
    @pulumi.getter
    def shape(self) -> str:
        """
        The shape of the Autonomous Exadata Infrastructure. The shape determines resources to allocate to the Autonomous Exadata Infrastructure (CPU cores, memory and storage).
        """
        return pulumi.get(self, "shape")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The OCID of the subnet the Autonomous Exadata Infrastructure is associated with.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the Autonomous Exadata Infrastructure was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        The OCID of the zone the Autonomous Exadata Infrastructure is associated with.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: int,
                 days_of_weeks: Sequence['outputs.GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekResult'],
                 hours_of_days: Sequence[int],
                 is_custom_action_timeout_enabled: bool,
                 is_monthly_patching_enabled: bool,
                 lead_time_in_weeks: int,
                 months: Sequence['outputs.GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowMonthResult'],
                 patching_mode: str,
                 preference: str,
                 weeks_of_months: Sequence[int]):
        """
        :param int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param str preference: The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: int,
             days_of_weeks: Sequence['outputs.GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekResult'],
             hours_of_days: Sequence[int],
             is_custom_action_timeout_enabled: bool,
             is_monthly_patching_enabled: bool,
             lead_time_in_weeks: int,
             months: Sequence['outputs.GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowMonthResult'],
             patching_mode: str,
             preference: str,
             weeks_of_months: Sequence[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        _setter("days_of_weeks", days_of_weeks)
        _setter("hours_of_days", hours_of_days)
        _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        _setter("lead_time_in_weeks", lead_time_in_weeks)
        _setter("months", months)
        _setter("patching_mode", patching_mode)
        _setter("preference", preference)
        _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: int,
                 days_of_weeks: Sequence['outputs.GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailDaysOfWeekResult'],
                 hours_of_days: Sequence[int],
                 is_custom_action_timeout_enabled: bool,
                 is_monthly_patching_enabled: bool,
                 lead_time_in_weeks: int,
                 months: Sequence['outputs.GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailMonthResult'],
                 patching_mode: str,
                 preference: str,
                 weeks_of_months: Sequence[int]):
        """
        :param int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailMonthArgs'] months: Months during the year when maintenance should be performed.
        :param str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param str preference: The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: int,
             days_of_weeks: Sequence['outputs.GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailDaysOfWeekResult'],
             hours_of_days: Sequence[int],
             is_custom_action_timeout_enabled: bool,
             is_monthly_patching_enabled: bool,
             lead_time_in_weeks: int,
             months: Sequence['outputs.GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailMonthResult'],
             patching_mode: str,
             preference: str,
             weeks_of_months: Sequence[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        _setter("days_of_weeks", days_of_weeks)
        _setter("hours_of_days", hours_of_days)
        _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        _setter("lead_time_in_weeks", lead_time_in_weeks)
        _setter("months", months)
        _setter("patching_mode", patching_mode)
        _setter("preference", preference)
        _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailDaysOfWeekResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailMonthResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowDetailMonthResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowMonthResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetAutonomousExadataInfrastructuresAutonomousExadataInfrastructureMaintenanceWindowMonthResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousExadataInfrastructuresFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the month of the year.
        """
        GetAutonomousExadataInfrastructuresFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousVirtualMachinesAutonomousVirtualMachineResult(dict):
    def __init__(__self__, *,
                 autonomous_vm_cluster_id: str,
                 client_ip_address: str,
                 compartment_id: str,
                 cpu_core_count: int,
                 db_node_storage_size_in_gbs: int,
                 db_server_display_name: str,
                 db_server_id: str,
                 defined_tags: Mapping[str, Any],
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 memory_size_in_gbs: int,
                 state: str,
                 vm_name: str):
        """
        :param str autonomous_vm_cluster_id: The Autonomous Virtual machine [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param str client_ip_address: Client IP Address.
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param int cpu_core_count: The number of CPU cores enabled on the Autonomous Virtual Machine.
        :param int db_node_storage_size_in_gbs: The allocated local node storage in GBs on the Autonomous Virtual Machine.
        :param str db_server_display_name: The display name of the dbServer associated with the Autonomous Virtual Machine.
        :param str db_server_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Db server associated with the Autonomous Virtual Machine.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Virtual Machine.
        :param int memory_size_in_gbs: The allocated memory in GBs on the Autonomous Virtual Machine.
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        :param str vm_name: The name of the Autonomous Virtual Machine.
        """
        GetAutonomousVirtualMachinesAutonomousVirtualMachineResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autonomous_vm_cluster_id=autonomous_vm_cluster_id,
            client_ip_address=client_ip_address,
            compartment_id=compartment_id,
            cpu_core_count=cpu_core_count,
            db_node_storage_size_in_gbs=db_node_storage_size_in_gbs,
            db_server_display_name=db_server_display_name,
            db_server_id=db_server_id,
            defined_tags=defined_tags,
            freeform_tags=freeform_tags,
            id=id,
            memory_size_in_gbs=memory_size_in_gbs,
            state=state,
            vm_name=vm_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autonomous_vm_cluster_id: str,
             client_ip_address: str,
             compartment_id: str,
             cpu_core_count: int,
             db_node_storage_size_in_gbs: int,
             db_server_display_name: str,
             db_server_id: str,
             defined_tags: Mapping[str, Any],
             freeform_tags: Mapping[str, Any],
             id: str,
             memory_size_in_gbs: int,
             state: str,
             vm_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("autonomous_vm_cluster_id", autonomous_vm_cluster_id)
        _setter("client_ip_address", client_ip_address)
        _setter("compartment_id", compartment_id)
        _setter("cpu_core_count", cpu_core_count)
        _setter("db_node_storage_size_in_gbs", db_node_storage_size_in_gbs)
        _setter("db_server_display_name", db_server_display_name)
        _setter("db_server_id", db_server_id)
        _setter("defined_tags", defined_tags)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("memory_size_in_gbs", memory_size_in_gbs)
        _setter("state", state)
        _setter("vm_name", vm_name)

    @property
    @pulumi.getter(name="autonomousVmClusterId")
    def autonomous_vm_cluster_id(self) -> str:
        """
        The Autonomous Virtual machine [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "autonomous_vm_cluster_id")

    @property
    @pulumi.getter(name="clientIpAddress")
    def client_ip_address(self) -> str:
        """
        Client IP Address.
        """
        return pulumi.get(self, "client_ip_address")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="cpuCoreCount")
    def cpu_core_count(self) -> int:
        """
        The number of CPU cores enabled on the Autonomous Virtual Machine.
        """
        return pulumi.get(self, "cpu_core_count")

    @property
    @pulumi.getter(name="dbNodeStorageSizeInGbs")
    def db_node_storage_size_in_gbs(self) -> int:
        """
        The allocated local node storage in GBs on the Autonomous Virtual Machine.
        """
        return pulumi.get(self, "db_node_storage_size_in_gbs")

    @property
    @pulumi.getter(name="dbServerDisplayName")
    def db_server_display_name(self) -> str:
        """
        The display name of the dbServer associated with the Autonomous Virtual Machine.
        """
        return pulumi.get(self, "db_server_display_name")

    @property
    @pulumi.getter(name="dbServerId")
    def db_server_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Db server associated with the Autonomous Virtual Machine.
        """
        return pulumi.get(self, "db_server_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Virtual Machine.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="memorySizeInGbs")
    def memory_size_in_gbs(self) -> int:
        """
        The allocated memory in GBs on the Autonomous Virtual Machine.
        """
        return pulumi.get(self, "memory_size_in_gbs")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="vmName")
    def vm_name(self) -> str:
        """
        The name of the Autonomous Virtual Machine.
        """
        return pulumi.get(self, "vm_name")


@pulumi.output_type
class GetAutonomousVirtualMachinesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetAutonomousVirtualMachinesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAutonomousVmClusterMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: int,
                 days_of_weeks: Sequence['outputs.GetAutonomousVmClusterMaintenanceWindowDaysOfWeekResult'],
                 hours_of_days: Sequence[int],
                 is_custom_action_timeout_enabled: bool,
                 is_monthly_patching_enabled: bool,
                 lead_time_in_weeks: int,
                 months: Sequence['outputs.GetAutonomousVmClusterMaintenanceWindowMonthResult'],
                 patching_mode: str,
                 preference: str,
                 weeks_of_months: Sequence[int]):
        """
        :param Sequence['GetAutonomousVmClusterMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetAutonomousVmClusterMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param str preference: The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        GetAutonomousVmClusterMaintenanceWindowResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: int,
             days_of_weeks: Sequence['outputs.GetAutonomousVmClusterMaintenanceWindowDaysOfWeekResult'],
             hours_of_days: Sequence[int],
             is_custom_action_timeout_enabled: bool,
             is_monthly_patching_enabled: bool,
             lead_time_in_weeks: int,
             months: Sequence['outputs.GetAutonomousVmClusterMaintenanceWindowMonthResult'],
             patching_mode: str,
             preference: str,
             weeks_of_months: Sequence[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        _setter("days_of_weeks", days_of_weeks)
        _setter("hours_of_days", hours_of_days)
        _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        _setter("lead_time_in_weeks", lead_time_in_weeks)
        _setter("months", months)
        _setter("patching_mode", patching_mode)
        _setter("preference", preference)
        _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> int:
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetAutonomousVmClusterMaintenanceWindowDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> bool:
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> bool:
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetAutonomousVmClusterMaintenanceWindowMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> str:
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetAutonomousVmClusterMaintenanceWindowDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetAutonomousVmClusterMaintenanceWindowDaysOfWeekResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousVmClusterMaintenanceWindowDetailResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: int,
                 days_of_weeks: Sequence['outputs.GetAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult'],
                 hours_of_days: Sequence[int],
                 is_custom_action_timeout_enabled: bool,
                 is_monthly_patching_enabled: bool,
                 lead_time_in_weeks: int,
                 months: Sequence['outputs.GetAutonomousVmClusterMaintenanceWindowDetailMonthResult'],
                 patching_mode: str,
                 preference: str,
                 weeks_of_months: Sequence[int]):
        """
        :param Sequence['GetAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetAutonomousVmClusterMaintenanceWindowDetailMonthArgs'] months: Months during the year when maintenance should be performed.
        :param str preference: The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        GetAutonomousVmClusterMaintenanceWindowDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: int,
             days_of_weeks: Sequence['outputs.GetAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult'],
             hours_of_days: Sequence[int],
             is_custom_action_timeout_enabled: bool,
             is_monthly_patching_enabled: bool,
             lead_time_in_weeks: int,
             months: Sequence['outputs.GetAutonomousVmClusterMaintenanceWindowDetailMonthResult'],
             patching_mode: str,
             preference: str,
             weeks_of_months: Sequence[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        _setter("days_of_weeks", days_of_weeks)
        _setter("hours_of_days", hours_of_days)
        _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        _setter("lead_time_in_weeks", lead_time_in_weeks)
        _setter("months", months)
        _setter("patching_mode", patching_mode)
        _setter("preference", preference)
        _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> int:
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> bool:
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> bool:
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetAutonomousVmClusterMaintenanceWindowDetailMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> str:
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousVmClusterMaintenanceWindowDetailMonthResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetAutonomousVmClusterMaintenanceWindowDetailMonthResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousVmClusterMaintenanceWindowMonthResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetAutonomousVmClusterMaintenanceWindowMonthResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousVmClustersAutonomousVmClusterResult(dict):
    def __init__(__self__, *,
                 autonomous_data_storage_size_in_tbs: float,
                 available_autonomous_data_storage_size_in_tbs: float,
                 available_container_databases: int,
                 available_cpus: int,
                 available_data_storage_size_in_tbs: float,
                 compartment_id: str,
                 compute_model: str,
                 cpu_core_count_per_node: int,
                 cpus_enabled: int,
                 data_storage_size_in_gb: float,
                 data_storage_size_in_tbs: float,
                 db_node_storage_size_in_gbs: int,
                 db_servers: Sequence[str],
                 defined_tags: Mapping[str, Any],
                 display_name: str,
                 exadata_infrastructure_id: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 is_local_backup_enabled: bool,
                 is_mtls_enabled: bool,
                 last_maintenance_run_id: str,
                 license_model: str,
                 lifecycle_details: str,
                 maintenance_window_details: Sequence['outputs.GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailResult'],
                 maintenance_windows: Sequence['outputs.GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowResult'],
                 memory_per_oracle_compute_unit_in_gbs: int,
                 memory_size_in_gbs: int,
                 next_maintenance_run_id: str,
                 node_count: int,
                 ocpus_enabled: float,
                 reclaimable_cpus: int,
                 scan_listener_port_non_tls: int,
                 scan_listener_port_tls: int,
                 state: str,
                 time_created: str,
                 time_database_ssl_certificate_expires: str,
                 time_ords_certificate_expires: str,
                 time_zone: str,
                 total_container_databases: int,
                 vm_cluster_network_id: str):
        """
        :param float autonomous_data_storage_size_in_tbs: The data disk group size allocated for Autonomous Databases, in TBs.
        :param float available_autonomous_data_storage_size_in_tbs: The data disk group size available for Autonomous Databases, in TBs.
        :param int available_container_databases: The number of Autonomous Container Databases that can be created with the currently available local storage.
        :param int available_cpus: The numnber of CPU cores available.
        :param float available_data_storage_size_in_tbs: **Deprecated.** Use `availableAutonomousDataStorageSizeInTBs` for Autonomous Databases' data storage availability in TBs.
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param str compute_model: The compute model of the Autonomous VM Cluster.
        :param int cpu_core_count_per_node: The number of CPU cores enabled per VM cluster node.
        :param int cpus_enabled: The number of enabled CPU cores.
        :param float data_storage_size_in_gb: The total data storage allocated in GBs.
        :param float data_storage_size_in_tbs: The total data storage allocated in TBs
        :param int db_node_storage_size_in_gbs: The local node storage allocated in GBs.
        :param Sequence[str] db_servers: The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Db servers.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param str exadata_infrastructure_id: If provided, filters the results for the given Exadata Infrastructure.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous VM cluster.
        :param bool is_local_backup_enabled: If true, database backup on local Exadata storage is configured for the Autonomous VM cluster. If false, database backup on local Exadata storage is not available in the Autonomous VM cluster.
        :param bool is_mtls_enabled: Enable mutual TLS(mTLS) authentication for database while provisioning a VMCluster. Default is TLS.
        :param str last_maintenance_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance run.
        :param str license_model: The Oracle license model that applies to the Autonomous VM cluster. The default is LICENSE_INCLUDED.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param Sequence['GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowArgs'] maintenance_windows: The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        :param int memory_per_oracle_compute_unit_in_gbs: The amount of memory (in GBs) to be enabled per OCPU or ECPU.
        :param int memory_size_in_gbs: The memory allocated in GBs.
        :param str next_maintenance_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the next maintenance run.
        :param int node_count: The number of nodes in the Autonomous VM Cluster.
        :param float ocpus_enabled: The number of enabled OCPU cores.
        :param int reclaimable_cpus: For Autonomous Databases on Dedicated Exadata Infrastructure:
               * These are the CPUs that continue to be included in the count of CPUs available to the Autonomous Container Database even after one of its Autonomous Database is terminated or scaled down. You can release them to the available CPUs at its parent Autonomous VM Cluster level by restarting the Autonomous Container Database.
               * The CPU type (OCPUs or ECPUs) is determined by the parent Autonomous Exadata VM Cluster's compute model.
        :param int scan_listener_port_non_tls: The SCAN Listener Non TLS port number. Default value is 1521.
        :param int scan_listener_port_tls: The SCAN Listener TLS port number. Default value is 2484.
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        :param str time_created: The date and time that the Autonomous VM cluster was created.
        :param str time_database_ssl_certificate_expires: The date and time of Database SSL certificate expiration.
        :param str time_ords_certificate_expires: The date and time of ORDS certificate expiration.
        :param str time_zone: The time zone to use for the Autonomous VM cluster. For details, see [DB System Time Zones](https://docs.cloud.oracle.com/iaas/Content/Database/References/timezones.htm).
        :param int total_container_databases: The total number of Autonomous Container Databases that can be created.
        :param str vm_cluster_network_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VM cluster network.
        """
        GetAutonomousVmClustersAutonomousVmClusterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autonomous_data_storage_size_in_tbs=autonomous_data_storage_size_in_tbs,
            available_autonomous_data_storage_size_in_tbs=available_autonomous_data_storage_size_in_tbs,
            available_container_databases=available_container_databases,
            available_cpus=available_cpus,
            available_data_storage_size_in_tbs=available_data_storage_size_in_tbs,
            compartment_id=compartment_id,
            compute_model=compute_model,
            cpu_core_count_per_node=cpu_core_count_per_node,
            cpus_enabled=cpus_enabled,
            data_storage_size_in_gb=data_storage_size_in_gb,
            data_storage_size_in_tbs=data_storage_size_in_tbs,
            db_node_storage_size_in_gbs=db_node_storage_size_in_gbs,
            db_servers=db_servers,
            defined_tags=defined_tags,
            display_name=display_name,
            exadata_infrastructure_id=exadata_infrastructure_id,
            freeform_tags=freeform_tags,
            id=id,
            is_local_backup_enabled=is_local_backup_enabled,
            is_mtls_enabled=is_mtls_enabled,
            last_maintenance_run_id=last_maintenance_run_id,
            license_model=license_model,
            lifecycle_details=lifecycle_details,
            maintenance_window_details=maintenance_window_details,
            maintenance_windows=maintenance_windows,
            memory_per_oracle_compute_unit_in_gbs=memory_per_oracle_compute_unit_in_gbs,
            memory_size_in_gbs=memory_size_in_gbs,
            next_maintenance_run_id=next_maintenance_run_id,
            node_count=node_count,
            ocpus_enabled=ocpus_enabled,
            reclaimable_cpus=reclaimable_cpus,
            scan_listener_port_non_tls=scan_listener_port_non_tls,
            scan_listener_port_tls=scan_listener_port_tls,
            state=state,
            time_created=time_created,
            time_database_ssl_certificate_expires=time_database_ssl_certificate_expires,
            time_ords_certificate_expires=time_ords_certificate_expires,
            time_zone=time_zone,
            total_container_databases=total_container_databases,
            vm_cluster_network_id=vm_cluster_network_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autonomous_data_storage_size_in_tbs: float,
             available_autonomous_data_storage_size_in_tbs: float,
             available_container_databases: int,
             available_cpus: int,
             available_data_storage_size_in_tbs: float,
             compartment_id: str,
             compute_model: str,
             cpu_core_count_per_node: int,
             cpus_enabled: int,
             data_storage_size_in_gb: float,
             data_storage_size_in_tbs: float,
             db_node_storage_size_in_gbs: int,
             db_servers: Sequence[str],
             defined_tags: Mapping[str, Any],
             display_name: str,
             exadata_infrastructure_id: str,
             freeform_tags: Mapping[str, Any],
             id: str,
             is_local_backup_enabled: bool,
             is_mtls_enabled: bool,
             last_maintenance_run_id: str,
             license_model: str,
             lifecycle_details: str,
             maintenance_window_details: Sequence['outputs.GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailResult'],
             maintenance_windows: Sequence['outputs.GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowResult'],
             memory_per_oracle_compute_unit_in_gbs: int,
             memory_size_in_gbs: int,
             next_maintenance_run_id: str,
             node_count: int,
             ocpus_enabled: float,
             reclaimable_cpus: int,
             scan_listener_port_non_tls: int,
             scan_listener_port_tls: int,
             state: str,
             time_created: str,
             time_database_ssl_certificate_expires: str,
             time_ords_certificate_expires: str,
             time_zone: str,
             total_container_databases: int,
             vm_cluster_network_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("autonomous_data_storage_size_in_tbs", autonomous_data_storage_size_in_tbs)
        _setter("available_autonomous_data_storage_size_in_tbs", available_autonomous_data_storage_size_in_tbs)
        _setter("available_container_databases", available_container_databases)
        _setter("available_cpus", available_cpus)
        _setter("available_data_storage_size_in_tbs", available_data_storage_size_in_tbs)
        _setter("compartment_id", compartment_id)
        _setter("compute_model", compute_model)
        _setter("cpu_core_count_per_node", cpu_core_count_per_node)
        _setter("cpus_enabled", cpus_enabled)
        _setter("data_storage_size_in_gb", data_storage_size_in_gb)
        _setter("data_storage_size_in_tbs", data_storage_size_in_tbs)
        _setter("db_node_storage_size_in_gbs", db_node_storage_size_in_gbs)
        _setter("db_servers", db_servers)
        _setter("defined_tags", defined_tags)
        _setter("display_name", display_name)
        _setter("exadata_infrastructure_id", exadata_infrastructure_id)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("is_local_backup_enabled", is_local_backup_enabled)
        _setter("is_mtls_enabled", is_mtls_enabled)
        _setter("last_maintenance_run_id", last_maintenance_run_id)
        _setter("license_model", license_model)
        _setter("lifecycle_details", lifecycle_details)
        _setter("maintenance_window_details", maintenance_window_details)
        _setter("maintenance_windows", maintenance_windows)
        _setter("memory_per_oracle_compute_unit_in_gbs", memory_per_oracle_compute_unit_in_gbs)
        _setter("memory_size_in_gbs", memory_size_in_gbs)
        _setter("next_maintenance_run_id", next_maintenance_run_id)
        _setter("node_count", node_count)
        _setter("ocpus_enabled", ocpus_enabled)
        _setter("reclaimable_cpus", reclaimable_cpus)
        _setter("scan_listener_port_non_tls", scan_listener_port_non_tls)
        _setter("scan_listener_port_tls", scan_listener_port_tls)
        _setter("state", state)
        _setter("time_created", time_created)
        _setter("time_database_ssl_certificate_expires", time_database_ssl_certificate_expires)
        _setter("time_ords_certificate_expires", time_ords_certificate_expires)
        _setter("time_zone", time_zone)
        _setter("total_container_databases", total_container_databases)
        _setter("vm_cluster_network_id", vm_cluster_network_id)

    @property
    @pulumi.getter(name="autonomousDataStorageSizeInTbs")
    def autonomous_data_storage_size_in_tbs(self) -> float:
        """
        The data disk group size allocated for Autonomous Databases, in TBs.
        """
        return pulumi.get(self, "autonomous_data_storage_size_in_tbs")

    @property
    @pulumi.getter(name="availableAutonomousDataStorageSizeInTbs")
    def available_autonomous_data_storage_size_in_tbs(self) -> float:
        """
        The data disk group size available for Autonomous Databases, in TBs.
        """
        return pulumi.get(self, "available_autonomous_data_storage_size_in_tbs")

    @property
    @pulumi.getter(name="availableContainerDatabases")
    def available_container_databases(self) -> int:
        """
        The number of Autonomous Container Databases that can be created with the currently available local storage.
        """
        return pulumi.get(self, "available_container_databases")

    @property
    @pulumi.getter(name="availableCpus")
    def available_cpus(self) -> int:
        """
        The numnber of CPU cores available.
        """
        return pulumi.get(self, "available_cpus")

    @property
    @pulumi.getter(name="availableDataStorageSizeInTbs")
    def available_data_storage_size_in_tbs(self) -> float:
        """
        **Deprecated.** Use `availableAutonomousDataStorageSizeInTBs` for Autonomous Databases' data storage availability in TBs.
        """
        return pulumi.get(self, "available_data_storage_size_in_tbs")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="computeModel")
    def compute_model(self) -> str:
        """
        The compute model of the Autonomous VM Cluster.
        """
        return pulumi.get(self, "compute_model")

    @property
    @pulumi.getter(name="cpuCoreCountPerNode")
    def cpu_core_count_per_node(self) -> int:
        """
        The number of CPU cores enabled per VM cluster node.
        """
        return pulumi.get(self, "cpu_core_count_per_node")

    @property
    @pulumi.getter(name="cpusEnabled")
    def cpus_enabled(self) -> int:
        """
        The number of enabled CPU cores.
        """
        return pulumi.get(self, "cpus_enabled")

    @property
    @pulumi.getter(name="dataStorageSizeInGb")
    def data_storage_size_in_gb(self) -> float:
        """
        The total data storage allocated in GBs.
        """
        return pulumi.get(self, "data_storage_size_in_gb")

    @property
    @pulumi.getter(name="dataStorageSizeInTbs")
    def data_storage_size_in_tbs(self) -> float:
        """
        The total data storage allocated in TBs
        """
        return pulumi.get(self, "data_storage_size_in_tbs")

    @property
    @pulumi.getter(name="dbNodeStorageSizeInGbs")
    def db_node_storage_size_in_gbs(self) -> int:
        """
        The local node storage allocated in GBs.
        """
        return pulumi.get(self, "db_node_storage_size_in_gbs")

    @property
    @pulumi.getter(name="dbServers")
    def db_servers(self) -> Sequence[str]:
        """
        The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Db servers.
        """
        return pulumi.get(self, "db_servers")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="exadataInfrastructureId")
    def exadata_infrastructure_id(self) -> str:
        """
        If provided, filters the results for the given Exadata Infrastructure.
        """
        return pulumi.get(self, "exadata_infrastructure_id")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous VM cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isLocalBackupEnabled")
    def is_local_backup_enabled(self) -> bool:
        """
        If true, database backup on local Exadata storage is configured for the Autonomous VM cluster. If false, database backup on local Exadata storage is not available in the Autonomous VM cluster.
        """
        return pulumi.get(self, "is_local_backup_enabled")

    @property
    @pulumi.getter(name="isMtlsEnabled")
    def is_mtls_enabled(self) -> bool:
        """
        Enable mutual TLS(mTLS) authentication for database while provisioning a VMCluster. Default is TLS.
        """
        return pulumi.get(self, "is_mtls_enabled")

    @property
    @pulumi.getter(name="lastMaintenanceRunId")
    def last_maintenance_run_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance run.
        """
        return pulumi.get(self, "last_maintenance_run_id")

    @property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> str:
        """
        The Oracle license model that applies to the Autonomous VM cluster. The default is LICENSE_INCLUDED.
        """
        return pulumi.get(self, "license_model")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="maintenanceWindowDetails")
    def maintenance_window_details(self) -> Sequence['outputs.GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailResult']:
        return pulumi.get(self, "maintenance_window_details")

    @property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Sequence['outputs.GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowResult']:
        """
        The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        """
        return pulumi.get(self, "maintenance_windows")

    @property
    @pulumi.getter(name="memoryPerOracleComputeUnitInGbs")
    def memory_per_oracle_compute_unit_in_gbs(self) -> int:
        """
        The amount of memory (in GBs) to be enabled per OCPU or ECPU.
        """
        return pulumi.get(self, "memory_per_oracle_compute_unit_in_gbs")

    @property
    @pulumi.getter(name="memorySizeInGbs")
    def memory_size_in_gbs(self) -> int:
        """
        The memory allocated in GBs.
        """
        return pulumi.get(self, "memory_size_in_gbs")

    @property
    @pulumi.getter(name="nextMaintenanceRunId")
    def next_maintenance_run_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the next maintenance run.
        """
        return pulumi.get(self, "next_maintenance_run_id")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> int:
        """
        The number of nodes in the Autonomous VM Cluster.
        """
        return pulumi.get(self, "node_count")

    @property
    @pulumi.getter(name="ocpusEnabled")
    def ocpus_enabled(self) -> float:
        """
        The number of enabled OCPU cores.
        """
        return pulumi.get(self, "ocpus_enabled")

    @property
    @pulumi.getter(name="reclaimableCpus")
    def reclaimable_cpus(self) -> int:
        """
        For Autonomous Databases on Dedicated Exadata Infrastructure:
        * These are the CPUs that continue to be included in the count of CPUs available to the Autonomous Container Database even after one of its Autonomous Database is terminated or scaled down. You can release them to the available CPUs at its parent Autonomous VM Cluster level by restarting the Autonomous Container Database.
        * The CPU type (OCPUs or ECPUs) is determined by the parent Autonomous Exadata VM Cluster's compute model.
        """
        return pulumi.get(self, "reclaimable_cpus")

    @property
    @pulumi.getter(name="scanListenerPortNonTls")
    def scan_listener_port_non_tls(self) -> int:
        """
        The SCAN Listener Non TLS port number. Default value is 1521.
        """
        return pulumi.get(self, "scan_listener_port_non_tls")

    @property
    @pulumi.getter(name="scanListenerPortTls")
    def scan_listener_port_tls(self) -> int:
        """
        The SCAN Listener TLS port number. Default value is 2484.
        """
        return pulumi.get(self, "scan_listener_port_tls")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time that the Autonomous VM cluster was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeDatabaseSslCertificateExpires")
    def time_database_ssl_certificate_expires(self) -> str:
        """
        The date and time of Database SSL certificate expiration.
        """
        return pulumi.get(self, "time_database_ssl_certificate_expires")

    @property
    @pulumi.getter(name="timeOrdsCertificateExpires")
    def time_ords_certificate_expires(self) -> str:
        """
        The date and time of ORDS certificate expiration.
        """
        return pulumi.get(self, "time_ords_certificate_expires")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        """
        The time zone to use for the Autonomous VM cluster. For details, see [DB System Time Zones](https://docs.cloud.oracle.com/iaas/Content/Database/References/timezones.htm).
        """
        return pulumi.get(self, "time_zone")

    @property
    @pulumi.getter(name="totalContainerDatabases")
    def total_container_databases(self) -> int:
        """
        The total number of Autonomous Container Databases that can be created.
        """
        return pulumi.get(self, "total_container_databases")

    @property
    @pulumi.getter(name="vmClusterNetworkId")
    def vm_cluster_network_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VM cluster network.
        """
        return pulumi.get(self, "vm_cluster_network_id")


@pulumi.output_type
class GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: int,
                 days_of_weeks: Sequence['outputs.GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDaysOfWeekResult'],
                 hours_of_days: Sequence[int],
                 is_custom_action_timeout_enabled: bool,
                 is_monthly_patching_enabled: bool,
                 lead_time_in_weeks: int,
                 months: Sequence['outputs.GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowMonthResult'],
                 patching_mode: str,
                 preference: str,
                 weeks_of_months: Sequence[int]):
        """
        :param Sequence['GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param str preference: The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: int,
             days_of_weeks: Sequence['outputs.GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDaysOfWeekResult'],
             hours_of_days: Sequence[int],
             is_custom_action_timeout_enabled: bool,
             is_monthly_patching_enabled: bool,
             lead_time_in_weeks: int,
             months: Sequence['outputs.GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowMonthResult'],
             patching_mode: str,
             preference: str,
             weeks_of_months: Sequence[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        _setter("days_of_weeks", days_of_weeks)
        _setter("hours_of_days", hours_of_days)
        _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        _setter("lead_time_in_weeks", lead_time_in_weeks)
        _setter("months", months)
        _setter("patching_mode", patching_mode)
        _setter("preference", preference)
        _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> int:
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> bool:
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> bool:
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> str:
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDaysOfWeekResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: int,
                 days_of_weeks: Sequence['outputs.GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult'],
                 hours_of_days: Sequence[int],
                 is_custom_action_timeout_enabled: bool,
                 is_monthly_patching_enabled: bool,
                 lead_time_in_weeks: int,
                 months: Sequence['outputs.GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailMonthResult'],
                 patching_mode: str,
                 preference: str,
                 weeks_of_months: Sequence[int]):
        """
        :param Sequence['GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailMonthArgs'] months: Months during the year when maintenance should be performed.
        :param str preference: The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: int,
             days_of_weeks: Sequence['outputs.GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult'],
             hours_of_days: Sequence[int],
             is_custom_action_timeout_enabled: bool,
             is_monthly_patching_enabled: bool,
             lead_time_in_weeks: int,
             months: Sequence['outputs.GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailMonthResult'],
             patching_mode: str,
             preference: str,
             weeks_of_months: Sequence[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        _setter("days_of_weeks", days_of_weeks)
        _setter("hours_of_days", hours_of_days)
        _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        _setter("lead_time_in_weeks", lead_time_in_weeks)
        _setter("months", months)
        _setter("patching_mode", patching_mode)
        _setter("preference", preference)
        _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> int:
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> bool:
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> bool:
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> str:
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailMonthResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowDetailMonthResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowMonthResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetAutonomousVmClustersAutonomousVmClusterMaintenanceWindowMonthResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutonomousVmClustersFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the month of the year.
        """
        GetAutonomousVmClustersFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetBackupDestinationAssociatedDatabaseResult(dict):
    def __init__(__self__, *,
                 db_name: str,
                 id: str):
        """
        :param str db_name: The display name of the database that is associated with the backup destination.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        GetBackupDestinationAssociatedDatabaseResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_name=db_name,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_name: str,
             id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("db_name", db_name)
        _setter("id", id)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> str:
        """
        The display name of the database that is associated with the backup destination.
        """
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetBackupDestinationMountTypeDetailResult(dict):
    def __init__(__self__, *,
                 local_mount_point_path: str,
                 mount_type: str,
                 nfs_server_export: str,
                 nfs_servers: Sequence[str]):
        """
        :param str local_mount_point_path: The local directory path on each VM cluster node where the NFS server location is mounted. The local directory path and the NFS server location must each be the same across all of the VM cluster nodes. Ensure that the NFS mount is maintained continuously on all of the VM cluster nodes.
        :param str nfs_server_export: Specifies the directory on which to mount the file system
        :param Sequence[str] nfs_servers: Host names or IP addresses for NFS Auto mount.
        """
        GetBackupDestinationMountTypeDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            local_mount_point_path=local_mount_point_path,
            mount_type=mount_type,
            nfs_server_export=nfs_server_export,
            nfs_servers=nfs_servers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             local_mount_point_path: str,
             mount_type: str,
             nfs_server_export: str,
             nfs_servers: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("local_mount_point_path", local_mount_point_path)
        _setter("mount_type", mount_type)
        _setter("nfs_server_export", nfs_server_export)
        _setter("nfs_servers", nfs_servers)

    @property
    @pulumi.getter(name="localMountPointPath")
    def local_mount_point_path(self) -> str:
        """
        The local directory path on each VM cluster node where the NFS server location is mounted. The local directory path and the NFS server location must each be the same across all of the VM cluster nodes. Ensure that the NFS mount is maintained continuously on all of the VM cluster nodes.
        """
        return pulumi.get(self, "local_mount_point_path")

    @property
    @pulumi.getter(name="mountType")
    def mount_type(self) -> str:
        return pulumi.get(self, "mount_type")

    @property
    @pulumi.getter(name="nfsServerExport")
    def nfs_server_export(self) -> str:
        """
        Specifies the directory on which to mount the file system
        """
        return pulumi.get(self, "nfs_server_export")

    @property
    @pulumi.getter(name="nfsServers")
    def nfs_servers(self) -> Sequence[str]:
        """
        Host names or IP addresses for NFS Auto mount.
        """
        return pulumi.get(self, "nfs_servers")


@pulumi.output_type
class GetBackupDestinationsBackupDestinationResult(dict):
    def __init__(__self__, *,
                 associated_databases: Sequence['outputs.GetBackupDestinationsBackupDestinationAssociatedDatabaseResult'],
                 compartment_id: str,
                 connection_string: str,
                 defined_tags: Mapping[str, Any],
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 lifecycle_details: str,
                 local_mount_point_path: str,
                 mount_type_details: Sequence['outputs.GetBackupDestinationsBackupDestinationMountTypeDetailResult'],
                 nfs_mount_type: str,
                 nfs_server_export: str,
                 nfs_servers: Sequence[str],
                 state: str,
                 time_created: str,
                 type: str,
                 vpc_users: Sequence[str]):
        """
        :param Sequence['GetBackupDestinationsBackupDestinationAssociatedDatabaseArgs'] associated_databases: List of databases associated with the backup destination.
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param str connection_string: For a RECOVERY_APPLIANCE backup destination, the connection string for connecting to the Recovery Appliance.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str display_name: The user-provided name of the backup destination.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param str lifecycle_details: A descriptive text associated with the lifecycleState. Typically contains additional displayable text
        :param str local_mount_point_path: The local directory path on each VM cluster node where the NFS server location is mounted. The local directory path and the NFS server location must each be the same across all of the VM cluster nodes. Ensure that the NFS mount is maintained continuously on all of the VM cluster nodes.
        :param str nfs_mount_type: NFS Mount type for backup destination.
        :param str nfs_server_export: Specifies the directory on which to mount the file system
        :param Sequence[str] nfs_servers: Host names or IP addresses for NFS Auto mount.
        :param str state: The current lifecycle state of the backup destination.
        :param str time_created: The date and time the backup destination was created.
        :param str type: A filter to return only resources that match the given type of the Backup Destination.
        :param Sequence[str] vpc_users: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) users that are used to access the Recovery Appliance.
        """
        GetBackupDestinationsBackupDestinationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            associated_databases=associated_databases,
            compartment_id=compartment_id,
            connection_string=connection_string,
            defined_tags=defined_tags,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            lifecycle_details=lifecycle_details,
            local_mount_point_path=local_mount_point_path,
            mount_type_details=mount_type_details,
            nfs_mount_type=nfs_mount_type,
            nfs_server_export=nfs_server_export,
            nfs_servers=nfs_servers,
            state=state,
            time_created=time_created,
            type=type,
            vpc_users=vpc_users,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             associated_databases: Sequence['outputs.GetBackupDestinationsBackupDestinationAssociatedDatabaseResult'],
             compartment_id: str,
             connection_string: str,
             defined_tags: Mapping[str, Any],
             display_name: str,
             freeform_tags: Mapping[str, Any],
             id: str,
             lifecycle_details: str,
             local_mount_point_path: str,
             mount_type_details: Sequence['outputs.GetBackupDestinationsBackupDestinationMountTypeDetailResult'],
             nfs_mount_type: str,
             nfs_server_export: str,
             nfs_servers: Sequence[str],
             state: str,
             time_created: str,
             type: str,
             vpc_users: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("associated_databases", associated_databases)
        _setter("compartment_id", compartment_id)
        _setter("connection_string", connection_string)
        _setter("defined_tags", defined_tags)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("local_mount_point_path", local_mount_point_path)
        _setter("mount_type_details", mount_type_details)
        _setter("nfs_mount_type", nfs_mount_type)
        _setter("nfs_server_export", nfs_server_export)
        _setter("nfs_servers", nfs_servers)
        _setter("state", state)
        _setter("time_created", time_created)
        _setter("type", type)
        _setter("vpc_users", vpc_users)

    @property
    @pulumi.getter(name="associatedDatabases")
    def associated_databases(self) -> Sequence['outputs.GetBackupDestinationsBackupDestinationAssociatedDatabaseResult']:
        """
        List of databases associated with the backup destination.
        """
        return pulumi.get(self, "associated_databases")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> str:
        """
        For a RECOVERY_APPLIANCE backup destination, the connection string for connecting to the Recovery Appliance.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The user-provided name of the backup destination.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A descriptive text associated with the lifecycleState. Typically contains additional displayable text
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="localMountPointPath")
    def local_mount_point_path(self) -> str:
        """
        The local directory path on each VM cluster node where the NFS server location is mounted. The local directory path and the NFS server location must each be the same across all of the VM cluster nodes. Ensure that the NFS mount is maintained continuously on all of the VM cluster nodes.
        """
        warnings.warn("""The 'local_mount_point_path' field has been deprecated. Please use 'local_mount_point_path under mount_type_details' instead.""", DeprecationWarning)
        pulumi.log.warn("""local_mount_point_path is deprecated: The 'local_mount_point_path' field has been deprecated. Please use 'local_mount_point_path under mount_type_details' instead.""")

        return pulumi.get(self, "local_mount_point_path")

    @property
    @pulumi.getter(name="mountTypeDetails")
    def mount_type_details(self) -> Sequence['outputs.GetBackupDestinationsBackupDestinationMountTypeDetailResult']:
        return pulumi.get(self, "mount_type_details")

    @property
    @pulumi.getter(name="nfsMountType")
    def nfs_mount_type(self) -> str:
        """
        NFS Mount type for backup destination.
        """
        return pulumi.get(self, "nfs_mount_type")

    @property
    @pulumi.getter(name="nfsServerExport")
    def nfs_server_export(self) -> str:
        """
        Specifies the directory on which to mount the file system
        """
        return pulumi.get(self, "nfs_server_export")

    @property
    @pulumi.getter(name="nfsServers")
    def nfs_servers(self) -> Sequence[str]:
        """
        Host names or IP addresses for NFS Auto mount.
        """
        return pulumi.get(self, "nfs_servers")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current lifecycle state of the backup destination.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the backup destination was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        A filter to return only resources that match the given type of the Backup Destination.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vpcUsers")
    def vpc_users(self) -> Sequence[str]:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) users that are used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_users")


@pulumi.output_type
class GetBackupDestinationsBackupDestinationAssociatedDatabaseResult(dict):
    def __init__(__self__, *,
                 db_name: str,
                 id: str):
        """
        :param str db_name: The display name of the database that is associated with the backup destination.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        GetBackupDestinationsBackupDestinationAssociatedDatabaseResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_name=db_name,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_name: str,
             id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("db_name", db_name)
        _setter("id", id)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> str:
        """
        The display name of the database that is associated with the backup destination.
        """
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetBackupDestinationsBackupDestinationMountTypeDetailResult(dict):
    def __init__(__self__, *,
                 local_mount_point_path: str,
                 mount_type: str,
                 nfs_server_export: str,
                 nfs_servers: Sequence[str]):
        """
        :param str local_mount_point_path: The local directory path on each VM cluster node where the NFS server location is mounted. The local directory path and the NFS server location must each be the same across all of the VM cluster nodes. Ensure that the NFS mount is maintained continuously on all of the VM cluster nodes.
        :param str nfs_server_export: Specifies the directory on which to mount the file system
        :param Sequence[str] nfs_servers: Host names or IP addresses for NFS Auto mount.
        """
        GetBackupDestinationsBackupDestinationMountTypeDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            local_mount_point_path=local_mount_point_path,
            mount_type=mount_type,
            nfs_server_export=nfs_server_export,
            nfs_servers=nfs_servers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             local_mount_point_path: str,
             mount_type: str,
             nfs_server_export: str,
             nfs_servers: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("local_mount_point_path", local_mount_point_path)
        _setter("mount_type", mount_type)
        _setter("nfs_server_export", nfs_server_export)
        _setter("nfs_servers", nfs_servers)

    @property
    @pulumi.getter(name="localMountPointPath")
    def local_mount_point_path(self) -> str:
        """
        The local directory path on each VM cluster node where the NFS server location is mounted. The local directory path and the NFS server location must each be the same across all of the VM cluster nodes. Ensure that the NFS mount is maintained continuously on all of the VM cluster nodes.
        """
        return pulumi.get(self, "local_mount_point_path")

    @property
    @pulumi.getter(name="mountType")
    def mount_type(self) -> str:
        return pulumi.get(self, "mount_type")

    @property
    @pulumi.getter(name="nfsServerExport")
    def nfs_server_export(self) -> str:
        """
        Specifies the directory on which to mount the file system
        """
        return pulumi.get(self, "nfs_server_export")

    @property
    @pulumi.getter(name="nfsServers")
    def nfs_servers(self) -> Sequence[str]:
        """
        Host names or IP addresses for NFS Auto mount.
        """
        return pulumi.get(self, "nfs_servers")


@pulumi.output_type
class GetBackupDestinationsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetBackupDestinationsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetBackupsBackupResult(dict):
    def __init__(__self__, *,
                 availability_domain: str,
                 compartment_id: str,
                 database_edition: str,
                 database_id: str,
                 database_size_in_gbs: float,
                 display_name: str,
                 id: str,
                 key_store_id: str,
                 key_store_wallet_name: str,
                 kms_key_id: str,
                 kms_key_version_id: str,
                 lifecycle_details: str,
                 shape: str,
                 state: str,
                 time_ended: str,
                 time_started: str,
                 type: str,
                 vault_id: str,
                 version: str):
        """
        :param str availability_domain: The name of the availability domain where the database backup is stored.
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param str database_edition: The Oracle Database edition of the DB system from which the database backup was taken.
        :param str database_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        :param float database_size_in_gbs: The size of the database in gigabytes at the time the backup was taken.
        :param str display_name: The user-friendly name for the backup. The name does not have to be unique.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup.
        :param str key_store_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        :param str key_store_wallet_name: The wallet name for Oracle Key Vault.
        :param str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str shape: Shape of the backup's source database.
        :param str state: The current state of the backup.
        :param str time_ended: The date and time the backup was completed.
        :param str time_started: The date and time the backup started.
        :param str type: The type of backup.
        :param str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        :param str version: Version of the backup's source database
        """
        GetBackupsBackupResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_domain=availability_domain,
            compartment_id=compartment_id,
            database_edition=database_edition,
            database_id=database_id,
            database_size_in_gbs=database_size_in_gbs,
            display_name=display_name,
            id=id,
            key_store_id=key_store_id,
            key_store_wallet_name=key_store_wallet_name,
            kms_key_id=kms_key_id,
            kms_key_version_id=kms_key_version_id,
            lifecycle_details=lifecycle_details,
            shape=shape,
            state=state,
            time_ended=time_ended,
            time_started=time_started,
            type=type,
            vault_id=vault_id,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_domain: str,
             compartment_id: str,
             database_edition: str,
             database_id: str,
             database_size_in_gbs: float,
             display_name: str,
             id: str,
             key_store_id: str,
             key_store_wallet_name: str,
             kms_key_id: str,
             kms_key_version_id: str,
             lifecycle_details: str,
             shape: str,
             state: str,
             time_ended: str,
             time_started: str,
             type: str,
             vault_id: str,
             version: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("availability_domain", availability_domain)
        _setter("compartment_id", compartment_id)
        _setter("database_edition", database_edition)
        _setter("database_id", database_id)
        _setter("database_size_in_gbs", database_size_in_gbs)
        _setter("display_name", display_name)
        _setter("id", id)
        _setter("key_store_id", key_store_id)
        _setter("key_store_wallet_name", key_store_wallet_name)
        _setter("kms_key_id", kms_key_id)
        _setter("kms_key_version_id", kms_key_version_id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("shape", shape)
        _setter("state", state)
        _setter("time_ended", time_ended)
        _setter("time_started", time_started)
        _setter("type", type)
        _setter("vault_id", vault_id)
        _setter("version", version)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> str:
        """
        The name of the availability domain where the database backup is stored.
        """
        return pulumi.get(self, "availability_domain")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="databaseEdition")
    def database_edition(self) -> str:
        """
        The Oracle Database edition of the DB system from which the database backup was taken.
        """
        return pulumi.get(self, "database_edition")

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        """
        return pulumi.get(self, "database_id")

    @property
    @pulumi.getter(name="databaseSizeInGbs")
    def database_size_in_gbs(self) -> float:
        """
        The size of the database in gigabytes at the time the backup was taken.
        """
        return pulumi.get(self, "database_size_in_gbs")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The user-friendly name for the backup. The name does not have to be unique.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="keyStoreId")
    def key_store_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        """
        return pulumi.get(self, "key_store_id")

    @property
    @pulumi.getter(name="keyStoreWalletName")
    def key_store_wallet_name(self) -> str:
        """
        The wallet name for Oracle Key Vault.
        """
        return pulumi.get(self, "key_store_wallet_name")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> str:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        """
        return pulumi.get(self, "kms_key_version_id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def shape(self) -> str:
        """
        Shape of the backup's source database.
        """
        return pulumi.get(self, "shape")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the backup.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeEnded")
    def time_ended(self) -> str:
        """
        The date and time the backup was completed.
        """
        return pulumi.get(self, "time_ended")

    @property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> str:
        """
        The date and time the backup started.
        """
        return pulumi.get(self, "time_started")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of backup.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Version of the backup's source database
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetBackupsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetBackupsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetCloudAutonomousVmClusterAcdResourceUsagesAutonomousContainerDatabaseResourceUsageResult(dict):
    def __init__(__self__, *,
                 autonomous_container_database_vm_usages: Sequence['outputs.GetCloudAutonomousVmClusterAcdResourceUsagesAutonomousContainerDatabaseResourceUsageAutonomousContainerDatabaseVmUsageResult'],
                 available_cpus: float,
                 defined_tags: Mapping[str, Any],
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 largest_provisionable_autonomous_database_in_cpus: float,
                 provisionable_cpuses: Sequence[float],
                 provisioned_cpus: float,
                 reclaimable_cpus: float,
                 reserved_cpus: float,
                 used_cpus: float):
        """
        :param Sequence['GetCloudAutonomousVmClusterAcdResourceUsagesAutonomousContainerDatabaseResourceUsageAutonomousContainerDatabaseVmUsageArgs'] autonomous_container_database_vm_usages: List of autonomous container database resource usage per autonomous virtual machine.
        :param float available_cpus: CPUs / cores available for ADB provisioning or scaling in the Autonomous Container Database.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str display_name: The user-friendly name for the Autonomous Container Database. The name does not need to be unique.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Container Database.
        :param float largest_provisionable_autonomous_database_in_cpus: Largest provisionable ADB in the Autonomous Container Database.
        :param Sequence[float] provisionable_cpuses: Valid list of provisionable CPUs / cores for ADB creation.
        :param float provisioned_cpus: CPUs / cores assigned to ADBs in the Autonomous Container Database.
        :param float reclaimable_cpus: CPUs / cores reclaimable or released to cluster on Autonomous Container Database restart.
        :param float reserved_cpus: CPUs / cores reserved for scalability, resilliency and other overheads. This includes failover, autoscaling and idle instance overhead.
        :param float used_cpus: CPUs / cores assigned to the Autonomous Container Database. Sum of provisioned, reserved and reclaimable CPUs/ cores.
        """
        GetCloudAutonomousVmClusterAcdResourceUsagesAutonomousContainerDatabaseResourceUsageResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autonomous_container_database_vm_usages=autonomous_container_database_vm_usages,
            available_cpus=available_cpus,
            defined_tags=defined_tags,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            largest_provisionable_autonomous_database_in_cpus=largest_provisionable_autonomous_database_in_cpus,
            provisionable_cpuses=provisionable_cpuses,
            provisioned_cpus=provisioned_cpus,
            reclaimable_cpus=reclaimable_cpus,
            reserved_cpus=reserved_cpus,
            used_cpus=used_cpus,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autonomous_container_database_vm_usages: Sequence['outputs.GetCloudAutonomousVmClusterAcdResourceUsagesAutonomousContainerDatabaseResourceUsageAutonomousContainerDatabaseVmUsageResult'],
             available_cpus: float,
             defined_tags: Mapping[str, Any],
             display_name: str,
             freeform_tags: Mapping[str, Any],
             id: str,
             largest_provisionable_autonomous_database_in_cpus: float,
             provisionable_cpuses: Sequence[float],
             provisioned_cpus: float,
             reclaimable_cpus: float,
             reserved_cpus: float,
             used_cpus: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("autonomous_container_database_vm_usages", autonomous_container_database_vm_usages)
        _setter("available_cpus", available_cpus)
        _setter("defined_tags", defined_tags)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("largest_provisionable_autonomous_database_in_cpus", largest_provisionable_autonomous_database_in_cpus)
        _setter("provisionable_cpuses", provisionable_cpuses)
        _setter("provisioned_cpus", provisioned_cpus)
        _setter("reclaimable_cpus", reclaimable_cpus)
        _setter("reserved_cpus", reserved_cpus)
        _setter("used_cpus", used_cpus)

    @property
    @pulumi.getter(name="autonomousContainerDatabaseVmUsages")
    def autonomous_container_database_vm_usages(self) -> Sequence['outputs.GetCloudAutonomousVmClusterAcdResourceUsagesAutonomousContainerDatabaseResourceUsageAutonomousContainerDatabaseVmUsageResult']:
        """
        List of autonomous container database resource usage per autonomous virtual machine.
        """
        return pulumi.get(self, "autonomous_container_database_vm_usages")

    @property
    @pulumi.getter(name="availableCpus")
    def available_cpus(self) -> float:
        """
        CPUs / cores available for ADB provisioning or scaling in the Autonomous Container Database.
        """
        return pulumi.get(self, "available_cpus")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The user-friendly name for the Autonomous Container Database. The name does not need to be unique.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Container Database.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="largestProvisionableAutonomousDatabaseInCpus")
    def largest_provisionable_autonomous_database_in_cpus(self) -> float:
        """
        Largest provisionable ADB in the Autonomous Container Database.
        """
        return pulumi.get(self, "largest_provisionable_autonomous_database_in_cpus")

    @property
    @pulumi.getter(name="provisionableCpuses")
    def provisionable_cpuses(self) -> Sequence[float]:
        """
        Valid list of provisionable CPUs / cores for ADB creation.
        """
        return pulumi.get(self, "provisionable_cpuses")

    @property
    @pulumi.getter(name="provisionedCpus")
    def provisioned_cpus(self) -> float:
        """
        CPUs / cores assigned to ADBs in the Autonomous Container Database.
        """
        return pulumi.get(self, "provisioned_cpus")

    @property
    @pulumi.getter(name="reclaimableCpus")
    def reclaimable_cpus(self) -> float:
        """
        CPUs / cores reclaimable or released to cluster on Autonomous Container Database restart.
        """
        return pulumi.get(self, "reclaimable_cpus")

    @property
    @pulumi.getter(name="reservedCpus")
    def reserved_cpus(self) -> float:
        """
        CPUs / cores reserved for scalability, resilliency and other overheads. This includes failover, autoscaling and idle instance overhead.
        """
        return pulumi.get(self, "reserved_cpus")

    @property
    @pulumi.getter(name="usedCpus")
    def used_cpus(self) -> float:
        """
        CPUs / cores assigned to the Autonomous Container Database. Sum of provisioned, reserved and reclaimable CPUs/ cores.
        """
        return pulumi.get(self, "used_cpus")


@pulumi.output_type
class GetCloudAutonomousVmClusterAcdResourceUsagesAutonomousContainerDatabaseResourceUsageAutonomousContainerDatabaseVmUsageResult(dict):
    def __init__(__self__, *,
                 display_name: str,
                 id: str,
                 provisioned_cpus: float,
                 reclaimable_cpus: float,
                 reserved_cpus: float,
                 used_cpus: float):
        """
        :param str display_name: The user-friendly name for the Autonomous Container Database. The name does not need to be unique.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Container Database.
        :param float provisioned_cpus: CPUs / cores assigned to ADBs in the Autonomous Container Database.
        :param float reclaimable_cpus: CPUs / cores reclaimable or released to cluster on Autonomous Container Database restart.
        :param float reserved_cpus: CPUs / cores reserved for scalability, resilliency and other overheads. This includes failover, autoscaling and idle instance overhead.
        :param float used_cpus: CPUs / cores assigned to the Autonomous Container Database. Sum of provisioned, reserved and reclaimable CPUs/ cores.
        """
        GetCloudAutonomousVmClusterAcdResourceUsagesAutonomousContainerDatabaseResourceUsageAutonomousContainerDatabaseVmUsageResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            display_name=display_name,
            id=id,
            provisioned_cpus=provisioned_cpus,
            reclaimable_cpus=reclaimable_cpus,
            reserved_cpus=reserved_cpus,
            used_cpus=used_cpus,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             display_name: str,
             id: str,
             provisioned_cpus: float,
             reclaimable_cpus: float,
             reserved_cpus: float,
             used_cpus: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("display_name", display_name)
        _setter("id", id)
        _setter("provisioned_cpus", provisioned_cpus)
        _setter("reclaimable_cpus", reclaimable_cpus)
        _setter("reserved_cpus", reserved_cpus)
        _setter("used_cpus", used_cpus)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The user-friendly name for the Autonomous Container Database. The name does not need to be unique.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Container Database.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="provisionedCpus")
    def provisioned_cpus(self) -> float:
        """
        CPUs / cores assigned to ADBs in the Autonomous Container Database.
        """
        return pulumi.get(self, "provisioned_cpus")

    @property
    @pulumi.getter(name="reclaimableCpus")
    def reclaimable_cpus(self) -> float:
        """
        CPUs / cores reclaimable or released to cluster on Autonomous Container Database restart.
        """
        return pulumi.get(self, "reclaimable_cpus")

    @property
    @pulumi.getter(name="reservedCpus")
    def reserved_cpus(self) -> float:
        """
        CPUs / cores reserved for scalability, resilliency and other overheads. This includes failover, autoscaling and idle instance overhead.
        """
        return pulumi.get(self, "reserved_cpus")

    @property
    @pulumi.getter(name="usedCpus")
    def used_cpus(self) -> float:
        """
        CPUs / cores assigned to the Autonomous Container Database. Sum of provisioned, reserved and reclaimable CPUs/ cores.
        """
        return pulumi.get(self, "used_cpus")


@pulumi.output_type
class GetCloudAutonomousVmClusterAcdResourceUsagesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetCloudAutonomousVmClusterAcdResourceUsagesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetCloudAutonomousVmClusterMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: int,
                 days_of_weeks: Sequence['outputs.GetCloudAutonomousVmClusterMaintenanceWindowDaysOfWeekResult'],
                 hours_of_days: Sequence[int],
                 is_custom_action_timeout_enabled: bool,
                 is_monthly_patching_enabled: bool,
                 lead_time_in_weeks: int,
                 months: Sequence['outputs.GetCloudAutonomousVmClusterMaintenanceWindowMonthResult'],
                 patching_mode: str,
                 preference: str,
                 weeks_of_months: Sequence[int]):
        """
        :param int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetCloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetCloudAutonomousVmClusterMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param str preference: The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        GetCloudAutonomousVmClusterMaintenanceWindowResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: int,
             days_of_weeks: Sequence['outputs.GetCloudAutonomousVmClusterMaintenanceWindowDaysOfWeekResult'],
             hours_of_days: Sequence[int],
             is_custom_action_timeout_enabled: bool,
             is_monthly_patching_enabled: bool,
             lead_time_in_weeks: int,
             months: Sequence['outputs.GetCloudAutonomousVmClusterMaintenanceWindowMonthResult'],
             patching_mode: str,
             preference: str,
             weeks_of_months: Sequence[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        _setter("days_of_weeks", days_of_weeks)
        _setter("hours_of_days", hours_of_days)
        _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        _setter("lead_time_in_weeks", lead_time_in_weeks)
        _setter("months", months)
        _setter("patching_mode", patching_mode)
        _setter("preference", preference)
        _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetCloudAutonomousVmClusterMaintenanceWindowDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetCloudAutonomousVmClusterMaintenanceWindowMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetCloudAutonomousVmClusterMaintenanceWindowDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetCloudAutonomousVmClusterMaintenanceWindowDaysOfWeekResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCloudAutonomousVmClusterMaintenanceWindowDetailResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: int,
                 days_of_weeks: Sequence['outputs.GetCloudAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult'],
                 hours_of_days: Sequence[int],
                 is_custom_action_timeout_enabled: bool,
                 is_monthly_patching_enabled: bool,
                 lead_time_in_weeks: int,
                 months: Sequence['outputs.GetCloudAutonomousVmClusterMaintenanceWindowDetailMonthResult'],
                 patching_mode: str,
                 preference: str,
                 weeks_of_months: Sequence[int]):
        """
        :param int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetCloudAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetCloudAutonomousVmClusterMaintenanceWindowDetailMonthArgs'] months: Months during the year when maintenance should be performed.
        :param str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param str preference: The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        GetCloudAutonomousVmClusterMaintenanceWindowDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: int,
             days_of_weeks: Sequence['outputs.GetCloudAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult'],
             hours_of_days: Sequence[int],
             is_custom_action_timeout_enabled: bool,
             is_monthly_patching_enabled: bool,
             lead_time_in_weeks: int,
             months: Sequence['outputs.GetCloudAutonomousVmClusterMaintenanceWindowDetailMonthResult'],
             patching_mode: str,
             preference: str,
             weeks_of_months: Sequence[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        _setter("days_of_weeks", days_of_weeks)
        _setter("hours_of_days", hours_of_days)
        _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        _setter("lead_time_in_weeks", lead_time_in_weeks)
        _setter("months", months)
        _setter("patching_mode", patching_mode)
        _setter("preference", preference)
        _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetCloudAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetCloudAutonomousVmClusterMaintenanceWindowDetailMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetCloudAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetCloudAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCloudAutonomousVmClusterMaintenanceWindowDetailMonthResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetCloudAutonomousVmClusterMaintenanceWindowDetailMonthResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCloudAutonomousVmClusterMaintenanceWindowMonthResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetCloudAutonomousVmClusterMaintenanceWindowMonthResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCloudAutonomousVmClusterResourceUsageAutonomousVmResourceUsageResult(dict):
    def __init__(__self__, *,
                 autonomous_container_database_usages: Sequence['outputs.GetCloudAutonomousVmClusterResourceUsageAutonomousVmResourceUsageAutonomousContainerDatabaseUsageResult'],
                 available_cpus: float,
                 display_name: str,
                 id: str,
                 provisioned_cpus: float,
                 reclaimable_cpus: float,
                 reserved_cpus: float,
                 used_cpus: float):
        """
        :param Sequence['GetCloudAutonomousVmClusterResourceUsageAutonomousVmResourceUsageAutonomousContainerDatabaseUsageArgs'] autonomous_container_database_usages: Associated Autonomous Container Database Usages.
        :param float available_cpus: The number of CPU cores available.
        :param str display_name: The user-friendly name for the Autonomous VM cluster. The name does not need to be unique.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Cloud Autonomous VM cluster.
        :param float provisioned_cpus: The number of CPUs provisioned in an Autonomous VM Cluster.
        :param float reclaimable_cpus: CPU cores that continue to be included in the count of OCPUs available to the Autonomous Container Database even after one of its Autonomous Database is terminated or scaled down. You can release them to the available OCPUs at its parent AVMC level by restarting the Autonomous Container Database.
        :param float reserved_cpus: The number of CPUs reserved in an Autonomous VM Cluster.
        :param float used_cpus: The number of CPU cores alloted to the Autonomous Container Databases in an Cloud Autonomous VM cluster.
        """
        GetCloudAutonomousVmClusterResourceUsageAutonomousVmResourceUsageResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autonomous_container_database_usages=autonomous_container_database_usages,
            available_cpus=available_cpus,
            display_name=display_name,
            id=id,
            provisioned_cpus=provisioned_cpus,
            reclaimable_cpus=reclaimable_cpus,
            reserved_cpus=reserved_cpus,
            used_cpus=used_cpus,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autonomous_container_database_usages: Sequence['outputs.GetCloudAutonomousVmClusterResourceUsageAutonomousVmResourceUsageAutonomousContainerDatabaseUsageResult'],
             available_cpus: float,
             display_name: str,
             id: str,
             provisioned_cpus: float,
             reclaimable_cpus: float,
             reserved_cpus: float,
             used_cpus: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("autonomous_container_database_usages", autonomous_container_database_usages)
        _setter("available_cpus", available_cpus)
        _setter("display_name", display_name)
        _setter("id", id)
        _setter("provisioned_cpus", provisioned_cpus)
        _setter("reclaimable_cpus", reclaimable_cpus)
        _setter("reserved_cpus", reserved_cpus)
        _setter("used_cpus", used_cpus)

    @property
    @pulumi.getter(name="autonomousContainerDatabaseUsages")
    def autonomous_container_database_usages(self) -> Sequence['outputs.GetCloudAutonomousVmClusterResourceUsageAutonomousVmResourceUsageAutonomousContainerDatabaseUsageResult']:
        """
        Associated Autonomous Container Database Usages.
        """
        return pulumi.get(self, "autonomous_container_database_usages")

    @property
    @pulumi.getter(name="availableCpus")
    def available_cpus(self) -> float:
        """
        The number of CPU cores available.
        """
        return pulumi.get(self, "available_cpus")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The user-friendly name for the Autonomous VM cluster. The name does not need to be unique.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Cloud Autonomous VM cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="provisionedCpus")
    def provisioned_cpus(self) -> float:
        """
        The number of CPUs provisioned in an Autonomous VM Cluster.
        """
        return pulumi.get(self, "provisioned_cpus")

    @property
    @pulumi.getter(name="reclaimableCpus")
    def reclaimable_cpus(self) -> float:
        """
        CPU cores that continue to be included in the count of OCPUs available to the Autonomous Container Database even after one of its Autonomous Database is terminated or scaled down. You can release them to the available OCPUs at its parent AVMC level by restarting the Autonomous Container Database.
        """
        return pulumi.get(self, "reclaimable_cpus")

    @property
    @pulumi.getter(name="reservedCpus")
    def reserved_cpus(self) -> float:
        """
        The number of CPUs reserved in an Autonomous VM Cluster.
        """
        return pulumi.get(self, "reserved_cpus")

    @property
    @pulumi.getter(name="usedCpus")
    def used_cpus(self) -> float:
        """
        The number of CPU cores alloted to the Autonomous Container Databases in an Cloud Autonomous VM cluster.
        """
        return pulumi.get(self, "used_cpus")


@pulumi.output_type
class GetCloudAutonomousVmClusterResourceUsageAutonomousVmResourceUsageAutonomousContainerDatabaseUsageResult(dict):
    def __init__(__self__, *,
                 available_cpus: float,
                 display_name: str,
                 id: str,
                 provisioned_cpus: float,
                 reclaimable_cpus: float,
                 reserved_cpus: float,
                 used_cpus: float):
        """
        :param float available_cpus: The number of CPU cores available.
        :param str display_name: The user-friendly name for the Autonomous VM cluster. The name does not need to be unique.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Cloud Autonomous VM cluster.
        :param float provisioned_cpus: The number of CPUs provisioned in an Autonomous VM Cluster.
        :param float reclaimable_cpus: CPU cores that continue to be included in the count of OCPUs available to the Autonomous Container Database even after one of its Autonomous Database is terminated or scaled down. You can release them to the available OCPUs at its parent AVMC level by restarting the Autonomous Container Database.
        :param float reserved_cpus: The number of CPUs reserved in an Autonomous VM Cluster.
        :param float used_cpus: The number of CPU cores alloted to the Autonomous Container Databases in an Cloud Autonomous VM cluster.
        """
        GetCloudAutonomousVmClusterResourceUsageAutonomousVmResourceUsageAutonomousContainerDatabaseUsageResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            available_cpus=available_cpus,
            display_name=display_name,
            id=id,
            provisioned_cpus=provisioned_cpus,
            reclaimable_cpus=reclaimable_cpus,
            reserved_cpus=reserved_cpus,
            used_cpus=used_cpus,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             available_cpus: float,
             display_name: str,
             id: str,
             provisioned_cpus: float,
             reclaimable_cpus: float,
             reserved_cpus: float,
             used_cpus: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("available_cpus", available_cpus)
        _setter("display_name", display_name)
        _setter("id", id)
        _setter("provisioned_cpus", provisioned_cpus)
        _setter("reclaimable_cpus", reclaimable_cpus)
        _setter("reserved_cpus", reserved_cpus)
        _setter("used_cpus", used_cpus)

    @property
    @pulumi.getter(name="availableCpus")
    def available_cpus(self) -> float:
        """
        The number of CPU cores available.
        """
        return pulumi.get(self, "available_cpus")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The user-friendly name for the Autonomous VM cluster. The name does not need to be unique.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Cloud Autonomous VM cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="provisionedCpus")
    def provisioned_cpus(self) -> float:
        """
        The number of CPUs provisioned in an Autonomous VM Cluster.
        """
        return pulumi.get(self, "provisioned_cpus")

    @property
    @pulumi.getter(name="reclaimableCpus")
    def reclaimable_cpus(self) -> float:
        """
        CPU cores that continue to be included in the count of OCPUs available to the Autonomous Container Database even after one of its Autonomous Database is terminated or scaled down. You can release them to the available OCPUs at its parent AVMC level by restarting the Autonomous Container Database.
        """
        return pulumi.get(self, "reclaimable_cpus")

    @property
    @pulumi.getter(name="reservedCpus")
    def reserved_cpus(self) -> float:
        """
        The number of CPUs reserved in an Autonomous VM Cluster.
        """
        return pulumi.get(self, "reserved_cpus")

    @property
    @pulumi.getter(name="usedCpus")
    def used_cpus(self) -> float:
        """
        The number of CPU cores alloted to the Autonomous Container Databases in an Cloud Autonomous VM cluster.
        """
        return pulumi.get(self, "used_cpus")


@pulumi.output_type
class GetCloudAutonomousVmClustersCloudAutonomousVmClusterResult(dict):
    def __init__(__self__, *,
                 autonomous_data_storage_percentage: float,
                 autonomous_data_storage_size_in_tbs: float,
                 availability_domain: str,
                 available_autonomous_data_storage_size_in_tbs: float,
                 available_container_databases: int,
                 available_cpus: float,
                 cloud_exadata_infrastructure_id: str,
                 cluster_time_zone: str,
                 compartment_id: str,
                 compute_model: str,
                 cpu_core_count: int,
                 cpu_core_count_per_node: int,
                 cpu_percentage: float,
                 data_storage_size_in_gb: float,
                 data_storage_size_in_tbs: float,
                 db_node_storage_size_in_gbs: int,
                 db_servers: Sequence[str],
                 defined_tags: Mapping[str, Any],
                 description: str,
                 display_name: str,
                 domain: str,
                 freeform_tags: Mapping[str, Any],
                 hostname: str,
                 id: str,
                 is_mtls_enabled_vm_cluster: bool,
                 last_maintenance_run_id: str,
                 last_update_history_entry_id: str,
                 license_model: str,
                 lifecycle_details: str,
                 maintenance_window_details: Sequence['outputs.GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailResult'],
                 maintenance_windows: Sequence['outputs.GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowResult'],
                 memory_per_oracle_compute_unit_in_gbs: int,
                 memory_size_in_gbs: int,
                 next_maintenance_run_id: str,
                 node_count: int,
                 non_provisionable_autonomous_container_databases: int,
                 nsg_ids: Sequence[str],
                 ocpu_count: float,
                 provisionable_autonomous_container_databases: int,
                 provisioned_autonomous_container_databases: int,
                 provisioned_cpus: float,
                 reclaimable_cpus: float,
                 reserved_cpus: float,
                 scan_listener_port_non_tls: int,
                 scan_listener_port_tls: int,
                 shape: str,
                 state: str,
                 subnet_id: str,
                 time_created: str,
                 time_updated: str,
                 total_autonomous_data_storage_in_tbs: float,
                 total_container_databases: int,
                 total_cpus: float):
        """
        :param float autonomous_data_storage_percentage: The percentage of the data storage used for the Autonomous Databases in an Autonomous VM Cluster.
        :param float autonomous_data_storage_size_in_tbs: The data disk group size allocated for Autonomous Databases, in TBs.
        :param str availability_domain: A filter to return only resources that match the given availability domain exactly.
        :param float available_autonomous_data_storage_size_in_tbs: The data disk group size available for Autonomous Databases, in TBs.
        :param int available_container_databases: The number of Autonomous Container Databases that can be created with the currently available local storage.
        :param float available_cpus: CPU cores available for allocation to Autonomous Databases.
        :param str cloud_exadata_infrastructure_id: If provided, filters the results for the specified cloud Exadata infrastructure.
        :param str cluster_time_zone: The time zone of the Cloud Autonomous VM Cluster.
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param str compute_model: The compute model of the Cloud Autonomous VM Cluster.
        :param int cpu_core_count: The number of CPU cores on the cloud Autonomous VM cluster.
        :param int cpu_core_count_per_node: The number of CPU cores enabled per VM cluster node.
        :param float cpu_percentage: The percentage of total number of CPUs used in an Autonomous VM Cluster.
        :param float data_storage_size_in_gb: The total data storage allocated, in gigabytes (GB).
        :param float data_storage_size_in_tbs: The total data storage allocated, in terabytes (TB).
        :param int db_node_storage_size_in_gbs: The local node storage allocated in GBs.
        :param Sequence[str] db_servers: The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Db servers.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str description: User defined description of the cloud Autonomous VM cluster.
        :param str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param str domain: The domain name for the cloud Autonomous VM cluster.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str hostname: The hostname for the cloud Autonomous VM cluster.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Cloud Autonomous VM cluster.
        :param bool is_mtls_enabled_vm_cluster: Enable mutual TLS(mTLS) authentication for database at time of provisioning a VMCluster. This is applicable to database TLS Certificates only. Default is TLS
        :param str last_maintenance_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance run.
        :param str last_update_history_entry_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance update history. This value is updated when a maintenance update starts.
        :param str license_model: The Oracle license model that applies to the Oracle Autonomous Database. Bring your own license (BYOL) allows you to apply your current on-premises Oracle software licenses to equivalent, highly automated Oracle PaaS and IaaS services in the cloud. License Included allows you to subscribe to new Oracle Database software licenses and the Database service. Note that when provisioning an Autonomous Database on [dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html), this attribute must be null because the attribute is already set at the Autonomous Exadata Infrastructure level. When using [shared Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html), if a value is not specified, the system will supply the value of `BRING_YOUR_OWN_LICENSE`.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param Sequence['GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowArgs'] maintenance_windows: The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        :param int memory_per_oracle_compute_unit_in_gbs: The amount of memory (in GBs) enabled per OCPU or ECPU.
        :param int memory_size_in_gbs: The memory allocated in GBs.
        :param str next_maintenance_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the next maintenance run.
        :param int node_count: The number of database servers in the cloud VM cluster.
        :param int non_provisionable_autonomous_container_databases: The number of non-provisionable Autonomous Container Databases in an Autonomous VM Cluster.
        :param Sequence[str] nsg_ids: The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the network security groups (NSGs) to which this resource belongs. Setting this to an empty list removes all resources from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). **NsgIds restrictions:**
               * A network security group (NSG) is optional for Autonomous Databases with private access. The nsgIds list can be empty.
        :param float ocpu_count: The number of CPU cores on the cloud Autonomous VM cluster. Only 1 decimal place is allowed for the fractional part.
        :param int provisionable_autonomous_container_databases: The number of provisionable Autonomous Container Databases in an Autonomous VM Cluster.
        :param int provisioned_autonomous_container_databases: The number of provisioned Autonomous Container Databases in an Autonomous VM Cluster.
        :param float provisioned_cpus: The number of CPUs provisioned in an Autonomous VM Cluster.
        :param float reclaimable_cpus: For Autonomous Databases on Dedicated Exadata Infrastructure:
               * These are the CPUs that continue to be included in the count of CPUs available to the Autonomous Container Database even after one of its Autonomous Database is terminated or scaled down. You can release them to the available CPUs at its parent Autonomous VM Cluster level by restarting the Autonomous Container Database.
               * The CPU type (OCPUs or ECPUs) is determined by the parent Autonomous Exadata VM Cluster's compute model.
        :param float reserved_cpus: The number of CPUs reserved in an Autonomous VM Cluster.
        :param int scan_listener_port_non_tls: The SCAN Listener Non TLS port. Default is 1521.
        :param int scan_listener_port_tls: The SCAN Listenenr TLS port. Default is 2484.
        :param str shape: The model name of the Exadata hardware running the cloud Autonomous VM cluster.
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        :param str subnet_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet the cloud Autonomous VM Cluster is associated with.
        :param str time_created: The date and time that the cloud Autonomous VM cluster was created.
        :param str time_updated: The last date and time that the cloud Autonomous VM cluster was updated.
        :param float total_autonomous_data_storage_in_tbs: The total data disk group size for Autonomous Databases, in TBs.
        :param int total_container_databases: The total number of Autonomous Container Databases that can be created with the allocated local storage.
        :param float total_cpus: The total number of CPUs in an Autonomous VM Cluster.
        """
        GetCloudAutonomousVmClustersCloudAutonomousVmClusterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autonomous_data_storage_percentage=autonomous_data_storage_percentage,
            autonomous_data_storage_size_in_tbs=autonomous_data_storage_size_in_tbs,
            availability_domain=availability_domain,
            available_autonomous_data_storage_size_in_tbs=available_autonomous_data_storage_size_in_tbs,
            available_container_databases=available_container_databases,
            available_cpus=available_cpus,
            cloud_exadata_infrastructure_id=cloud_exadata_infrastructure_id,
            cluster_time_zone=cluster_time_zone,
            compartment_id=compartment_id,
            compute_model=compute_model,
            cpu_core_count=cpu_core_count,
            cpu_core_count_per_node=cpu_core_count_per_node,
            cpu_percentage=cpu_percentage,
            data_storage_size_in_gb=data_storage_size_in_gb,
            data_storage_size_in_tbs=data_storage_size_in_tbs,
            db_node_storage_size_in_gbs=db_node_storage_size_in_gbs,
            db_servers=db_servers,
            defined_tags=defined_tags,
            description=description,
            display_name=display_name,
            domain=domain,
            freeform_tags=freeform_tags,
            hostname=hostname,
            id=id,
            is_mtls_enabled_vm_cluster=is_mtls_enabled_vm_cluster,
            last_maintenance_run_id=last_maintenance_run_id,
            last_update_history_entry_id=last_update_history_entry_id,
            license_model=license_model,
            lifecycle_details=lifecycle_details,
            maintenance_window_details=maintenance_window_details,
            maintenance_windows=maintenance_windows,
            memory_per_oracle_compute_unit_in_gbs=memory_per_oracle_compute_unit_in_gbs,
            memory_size_in_gbs=memory_size_in_gbs,
            next_maintenance_run_id=next_maintenance_run_id,
            node_count=node_count,
            non_provisionable_autonomous_container_databases=non_provisionable_autonomous_container_databases,
            nsg_ids=nsg_ids,
            ocpu_count=ocpu_count,
            provisionable_autonomous_container_databases=provisionable_autonomous_container_databases,
            provisioned_autonomous_container_databases=provisioned_autonomous_container_databases,
            provisioned_cpus=provisioned_cpus,
            reclaimable_cpus=reclaimable_cpus,
            reserved_cpus=reserved_cpus,
            scan_listener_port_non_tls=scan_listener_port_non_tls,
            scan_listener_port_tls=scan_listener_port_tls,
            shape=shape,
            state=state,
            subnet_id=subnet_id,
            time_created=time_created,
            time_updated=time_updated,
            total_autonomous_data_storage_in_tbs=total_autonomous_data_storage_in_tbs,
            total_container_databases=total_container_databases,
            total_cpus=total_cpus,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autonomous_data_storage_percentage: float,
             autonomous_data_storage_size_in_tbs: float,
             availability_domain: str,
             available_autonomous_data_storage_size_in_tbs: float,
             available_container_databases: int,
             available_cpus: float,
             cloud_exadata_infrastructure_id: str,
             cluster_time_zone: str,
             compartment_id: str,
             compute_model: str,
             cpu_core_count: int,
             cpu_core_count_per_node: int,
             cpu_percentage: float,
             data_storage_size_in_gb: float,
             data_storage_size_in_tbs: float,
             db_node_storage_size_in_gbs: int,
             db_servers: Sequence[str],
             defined_tags: Mapping[str, Any],
             description: str,
             display_name: str,
             domain: str,
             freeform_tags: Mapping[str, Any],
             hostname: str,
             id: str,
             is_mtls_enabled_vm_cluster: bool,
             last_maintenance_run_id: str,
             last_update_history_entry_id: str,
             license_model: str,
             lifecycle_details: str,
             maintenance_window_details: Sequence['outputs.GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailResult'],
             maintenance_windows: Sequence['outputs.GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowResult'],
             memory_per_oracle_compute_unit_in_gbs: int,
             memory_size_in_gbs: int,
             next_maintenance_run_id: str,
             node_count: int,
             non_provisionable_autonomous_container_databases: int,
             nsg_ids: Sequence[str],
             ocpu_count: float,
             provisionable_autonomous_container_databases: int,
             provisioned_autonomous_container_databases: int,
             provisioned_cpus: float,
             reclaimable_cpus: float,
             reserved_cpus: float,
             scan_listener_port_non_tls: int,
             scan_listener_port_tls: int,
             shape: str,
             state: str,
             subnet_id: str,
             time_created: str,
             time_updated: str,
             total_autonomous_data_storage_in_tbs: float,
             total_container_databases: int,
             total_cpus: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("autonomous_data_storage_percentage", autonomous_data_storage_percentage)
        _setter("autonomous_data_storage_size_in_tbs", autonomous_data_storage_size_in_tbs)
        _setter("availability_domain", availability_domain)
        _setter("available_autonomous_data_storage_size_in_tbs", available_autonomous_data_storage_size_in_tbs)
        _setter("available_container_databases", available_container_databases)
        _setter("available_cpus", available_cpus)
        _setter("cloud_exadata_infrastructure_id", cloud_exadata_infrastructure_id)
        _setter("cluster_time_zone", cluster_time_zone)
        _setter("compartment_id", compartment_id)
        _setter("compute_model", compute_model)
        _setter("cpu_core_count", cpu_core_count)
        _setter("cpu_core_count_per_node", cpu_core_count_per_node)
        _setter("cpu_percentage", cpu_percentage)
        _setter("data_storage_size_in_gb", data_storage_size_in_gb)
        _setter("data_storage_size_in_tbs", data_storage_size_in_tbs)
        _setter("db_node_storage_size_in_gbs", db_node_storage_size_in_gbs)
        _setter("db_servers", db_servers)
        _setter("defined_tags", defined_tags)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("domain", domain)
        _setter("freeform_tags", freeform_tags)
        _setter("hostname", hostname)
        _setter("id", id)
        _setter("is_mtls_enabled_vm_cluster", is_mtls_enabled_vm_cluster)
        _setter("last_maintenance_run_id", last_maintenance_run_id)
        _setter("last_update_history_entry_id", last_update_history_entry_id)
        _setter("license_model", license_model)
        _setter("lifecycle_details", lifecycle_details)
        _setter("maintenance_window_details", maintenance_window_details)
        _setter("maintenance_windows", maintenance_windows)
        _setter("memory_per_oracle_compute_unit_in_gbs", memory_per_oracle_compute_unit_in_gbs)
        _setter("memory_size_in_gbs", memory_size_in_gbs)
        _setter("next_maintenance_run_id", next_maintenance_run_id)
        _setter("node_count", node_count)
        _setter("non_provisionable_autonomous_container_databases", non_provisionable_autonomous_container_databases)
        _setter("nsg_ids", nsg_ids)
        _setter("ocpu_count", ocpu_count)
        _setter("provisionable_autonomous_container_databases", provisionable_autonomous_container_databases)
        _setter("provisioned_autonomous_container_databases", provisioned_autonomous_container_databases)
        _setter("provisioned_cpus", provisioned_cpus)
        _setter("reclaimable_cpus", reclaimable_cpus)
        _setter("reserved_cpus", reserved_cpus)
        _setter("scan_listener_port_non_tls", scan_listener_port_non_tls)
        _setter("scan_listener_port_tls", scan_listener_port_tls)
        _setter("shape", shape)
        _setter("state", state)
        _setter("subnet_id", subnet_id)
        _setter("time_created", time_created)
        _setter("time_updated", time_updated)
        _setter("total_autonomous_data_storage_in_tbs", total_autonomous_data_storage_in_tbs)
        _setter("total_container_databases", total_container_databases)
        _setter("total_cpus", total_cpus)

    @property
    @pulumi.getter(name="autonomousDataStoragePercentage")
    def autonomous_data_storage_percentage(self) -> float:
        """
        The percentage of the data storage used for the Autonomous Databases in an Autonomous VM Cluster.
        """
        return pulumi.get(self, "autonomous_data_storage_percentage")

    @property
    @pulumi.getter(name="autonomousDataStorageSizeInTbs")
    def autonomous_data_storage_size_in_tbs(self) -> float:
        """
        The data disk group size allocated for Autonomous Databases, in TBs.
        """
        return pulumi.get(self, "autonomous_data_storage_size_in_tbs")

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> str:
        """
        A filter to return only resources that match the given availability domain exactly.
        """
        return pulumi.get(self, "availability_domain")

    @property
    @pulumi.getter(name="availableAutonomousDataStorageSizeInTbs")
    def available_autonomous_data_storage_size_in_tbs(self) -> float:
        """
        The data disk group size available for Autonomous Databases, in TBs.
        """
        return pulumi.get(self, "available_autonomous_data_storage_size_in_tbs")

    @property
    @pulumi.getter(name="availableContainerDatabases")
    def available_container_databases(self) -> int:
        """
        The number of Autonomous Container Databases that can be created with the currently available local storage.
        """
        return pulumi.get(self, "available_container_databases")

    @property
    @pulumi.getter(name="availableCpus")
    def available_cpus(self) -> float:
        """
        CPU cores available for allocation to Autonomous Databases.
        """
        return pulumi.get(self, "available_cpus")

    @property
    @pulumi.getter(name="cloudExadataInfrastructureId")
    def cloud_exadata_infrastructure_id(self) -> str:
        """
        If provided, filters the results for the specified cloud Exadata infrastructure.
        """
        return pulumi.get(self, "cloud_exadata_infrastructure_id")

    @property
    @pulumi.getter(name="clusterTimeZone")
    def cluster_time_zone(self) -> str:
        """
        The time zone of the Cloud Autonomous VM Cluster.
        """
        return pulumi.get(self, "cluster_time_zone")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="computeModel")
    def compute_model(self) -> str:
        """
        The compute model of the Cloud Autonomous VM Cluster.
        """
        return pulumi.get(self, "compute_model")

    @property
    @pulumi.getter(name="cpuCoreCount")
    def cpu_core_count(self) -> int:
        """
        The number of CPU cores on the cloud Autonomous VM cluster.
        """
        return pulumi.get(self, "cpu_core_count")

    @property
    @pulumi.getter(name="cpuCoreCountPerNode")
    def cpu_core_count_per_node(self) -> int:
        """
        The number of CPU cores enabled per VM cluster node.
        """
        return pulumi.get(self, "cpu_core_count_per_node")

    @property
    @pulumi.getter(name="cpuPercentage")
    def cpu_percentage(self) -> float:
        """
        The percentage of total number of CPUs used in an Autonomous VM Cluster.
        """
        return pulumi.get(self, "cpu_percentage")

    @property
    @pulumi.getter(name="dataStorageSizeInGb")
    def data_storage_size_in_gb(self) -> float:
        """
        The total data storage allocated, in gigabytes (GB).
        """
        return pulumi.get(self, "data_storage_size_in_gb")

    @property
    @pulumi.getter(name="dataStorageSizeInTbs")
    def data_storage_size_in_tbs(self) -> float:
        """
        The total data storage allocated, in terabytes (TB).
        """
        return pulumi.get(self, "data_storage_size_in_tbs")

    @property
    @pulumi.getter(name="dbNodeStorageSizeInGbs")
    def db_node_storage_size_in_gbs(self) -> int:
        """
        The local node storage allocated in GBs.
        """
        return pulumi.get(self, "db_node_storage_size_in_gbs")

    @property
    @pulumi.getter(name="dbServers")
    def db_servers(self) -> Sequence[str]:
        """
        The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Db servers.
        """
        return pulumi.get(self, "db_servers")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        User defined description of the cloud Autonomous VM cluster.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The domain name for the cloud Autonomous VM cluster.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The hostname for the cloud Autonomous VM cluster.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Cloud Autonomous VM cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isMtlsEnabledVmCluster")
    def is_mtls_enabled_vm_cluster(self) -> bool:
        """
        Enable mutual TLS(mTLS) authentication for database at time of provisioning a VMCluster. This is applicable to database TLS Certificates only. Default is TLS
        """
        return pulumi.get(self, "is_mtls_enabled_vm_cluster")

    @property
    @pulumi.getter(name="lastMaintenanceRunId")
    def last_maintenance_run_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance run.
        """
        return pulumi.get(self, "last_maintenance_run_id")

    @property
    @pulumi.getter(name="lastUpdateHistoryEntryId")
    def last_update_history_entry_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance update history. This value is updated when a maintenance update starts.
        """
        return pulumi.get(self, "last_update_history_entry_id")

    @property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> str:
        """
        The Oracle license model that applies to the Oracle Autonomous Database. Bring your own license (BYOL) allows you to apply your current on-premises Oracle software licenses to equivalent, highly automated Oracle PaaS and IaaS services in the cloud. License Included allows you to subscribe to new Oracle Database software licenses and the Database service. Note that when provisioning an Autonomous Database on [dedicated Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html), this attribute must be null because the attribute is already set at the Autonomous Exadata Infrastructure level. When using [shared Exadata infrastructure](https://docs.oracle.com/en/cloud/paas/autonomous-database/index.html), if a value is not specified, the system will supply the value of `BRING_YOUR_OWN_LICENSE`.
        """
        return pulumi.get(self, "license_model")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="maintenanceWindowDetails")
    def maintenance_window_details(self) -> Sequence['outputs.GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailResult']:
        return pulumi.get(self, "maintenance_window_details")

    @property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Sequence['outputs.GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowResult']:
        """
        The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        """
        return pulumi.get(self, "maintenance_windows")

    @property
    @pulumi.getter(name="memoryPerOracleComputeUnitInGbs")
    def memory_per_oracle_compute_unit_in_gbs(self) -> int:
        """
        The amount of memory (in GBs) enabled per OCPU or ECPU.
        """
        return pulumi.get(self, "memory_per_oracle_compute_unit_in_gbs")

    @property
    @pulumi.getter(name="memorySizeInGbs")
    def memory_size_in_gbs(self) -> int:
        """
        The memory allocated in GBs.
        """
        return pulumi.get(self, "memory_size_in_gbs")

    @property
    @pulumi.getter(name="nextMaintenanceRunId")
    def next_maintenance_run_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the next maintenance run.
        """
        return pulumi.get(self, "next_maintenance_run_id")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> int:
        """
        The number of database servers in the cloud VM cluster.
        """
        return pulumi.get(self, "node_count")

    @property
    @pulumi.getter(name="nonProvisionableAutonomousContainerDatabases")
    def non_provisionable_autonomous_container_databases(self) -> int:
        """
        The number of non-provisionable Autonomous Container Databases in an Autonomous VM Cluster.
        """
        return pulumi.get(self, "non_provisionable_autonomous_container_databases")

    @property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Sequence[str]:
        """
        The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the network security groups (NSGs) to which this resource belongs. Setting this to an empty list removes all resources from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). **NsgIds restrictions:**
        * A network security group (NSG) is optional for Autonomous Databases with private access. The nsgIds list can be empty.
        """
        return pulumi.get(self, "nsg_ids")

    @property
    @pulumi.getter(name="ocpuCount")
    def ocpu_count(self) -> float:
        """
        The number of CPU cores on the cloud Autonomous VM cluster. Only 1 decimal place is allowed for the fractional part.
        """
        return pulumi.get(self, "ocpu_count")

    @property
    @pulumi.getter(name="provisionableAutonomousContainerDatabases")
    def provisionable_autonomous_container_databases(self) -> int:
        """
        The number of provisionable Autonomous Container Databases in an Autonomous VM Cluster.
        """
        return pulumi.get(self, "provisionable_autonomous_container_databases")

    @property
    @pulumi.getter(name="provisionedAutonomousContainerDatabases")
    def provisioned_autonomous_container_databases(self) -> int:
        """
        The number of provisioned Autonomous Container Databases in an Autonomous VM Cluster.
        """
        return pulumi.get(self, "provisioned_autonomous_container_databases")

    @property
    @pulumi.getter(name="provisionedCpus")
    def provisioned_cpus(self) -> float:
        """
        The number of CPUs provisioned in an Autonomous VM Cluster.
        """
        return pulumi.get(self, "provisioned_cpus")

    @property
    @pulumi.getter(name="reclaimableCpus")
    def reclaimable_cpus(self) -> float:
        """
        For Autonomous Databases on Dedicated Exadata Infrastructure:
        * These are the CPUs that continue to be included in the count of CPUs available to the Autonomous Container Database even after one of its Autonomous Database is terminated or scaled down. You can release them to the available CPUs at its parent Autonomous VM Cluster level by restarting the Autonomous Container Database.
        * The CPU type (OCPUs or ECPUs) is determined by the parent Autonomous Exadata VM Cluster's compute model.
        """
        return pulumi.get(self, "reclaimable_cpus")

    @property
    @pulumi.getter(name="reservedCpus")
    def reserved_cpus(self) -> float:
        """
        The number of CPUs reserved in an Autonomous VM Cluster.
        """
        return pulumi.get(self, "reserved_cpus")

    @property
    @pulumi.getter(name="scanListenerPortNonTls")
    def scan_listener_port_non_tls(self) -> int:
        """
        The SCAN Listener Non TLS port. Default is 1521.
        """
        return pulumi.get(self, "scan_listener_port_non_tls")

    @property
    @pulumi.getter(name="scanListenerPortTls")
    def scan_listener_port_tls(self) -> int:
        """
        The SCAN Listenenr TLS port. Default is 2484.
        """
        return pulumi.get(self, "scan_listener_port_tls")

    @property
    @pulumi.getter
    def shape(self) -> str:
        """
        The model name of the Exadata hardware running the cloud Autonomous VM cluster.
        """
        return pulumi.get(self, "shape")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet the cloud Autonomous VM Cluster is associated with.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time that the cloud Autonomous VM cluster was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The last date and time that the cloud Autonomous VM cluster was updated.
        """
        return pulumi.get(self, "time_updated")

    @property
    @pulumi.getter(name="totalAutonomousDataStorageInTbs")
    def total_autonomous_data_storage_in_tbs(self) -> float:
        """
        The total data disk group size for Autonomous Databases, in TBs.
        """
        return pulumi.get(self, "total_autonomous_data_storage_in_tbs")

    @property
    @pulumi.getter(name="totalContainerDatabases")
    def total_container_databases(self) -> int:
        """
        The total number of Autonomous Container Databases that can be created with the allocated local storage.
        """
        return pulumi.get(self, "total_container_databases")

    @property
    @pulumi.getter(name="totalCpus")
    def total_cpus(self) -> float:
        """
        The total number of CPUs in an Autonomous VM Cluster.
        """
        return pulumi.get(self, "total_cpus")


@pulumi.output_type
class GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: int,
                 days_of_weeks: Sequence['outputs.GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDaysOfWeekResult'],
                 hours_of_days: Sequence[int],
                 is_custom_action_timeout_enabled: bool,
                 is_monthly_patching_enabled: bool,
                 lead_time_in_weeks: int,
                 months: Sequence['outputs.GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowMonthResult'],
                 patching_mode: str,
                 preference: str,
                 weeks_of_months: Sequence[int]):
        """
        :param int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param str preference: The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: int,
             days_of_weeks: Sequence['outputs.GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDaysOfWeekResult'],
             hours_of_days: Sequence[int],
             is_custom_action_timeout_enabled: bool,
             is_monthly_patching_enabled: bool,
             lead_time_in_weeks: int,
             months: Sequence['outputs.GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowMonthResult'],
             patching_mode: str,
             preference: str,
             weeks_of_months: Sequence[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        _setter("days_of_weeks", days_of_weeks)
        _setter("hours_of_days", hours_of_days)
        _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        _setter("lead_time_in_weeks", lead_time_in_weeks)
        _setter("months", months)
        _setter("patching_mode", patching_mode)
        _setter("preference", preference)
        _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDaysOfWeekResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: int,
                 days_of_weeks: Sequence['outputs.GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult'],
                 hours_of_days: Sequence[int],
                 is_custom_action_timeout_enabled: bool,
                 is_monthly_patching_enabled: bool,
                 lead_time_in_weeks: int,
                 months: Sequence['outputs.GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailMonthResult'],
                 patching_mode: str,
                 preference: str,
                 weeks_of_months: Sequence[int]):
        """
        :param int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailMonthArgs'] months: Months during the year when maintenance should be performed.
        :param str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param str preference: The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: int,
             days_of_weeks: Sequence['outputs.GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult'],
             hours_of_days: Sequence[int],
             is_custom_action_timeout_enabled: bool,
             is_monthly_patching_enabled: bool,
             lead_time_in_weeks: int,
             months: Sequence['outputs.GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailMonthResult'],
             patching_mode: str,
             preference: str,
             weeks_of_months: Sequence[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        _setter("days_of_weeks", days_of_weeks)
        _setter("hours_of_days", hours_of_days)
        _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        _setter("lead_time_in_weeks", lead_time_in_weeks)
        _setter("months", months)
        _setter("patching_mode", patching_mode)
        _setter("preference", preference)
        _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailDaysOfWeekResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailMonthResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowDetailMonthResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowMonthResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetCloudAutonomousVmClustersCloudAutonomousVmClusterMaintenanceWindowMonthResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCloudAutonomousVmClustersFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the month of the year.
        """
        GetCloudAutonomousVmClustersFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetCloudExadataInfrastructureCustomerContactResult(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        GetCloudExadataInfrastructureCustomerContactResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            email=email,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             email: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetCloudExadataInfrastructureMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: int,
                 days_of_weeks: Sequence['outputs.GetCloudExadataInfrastructureMaintenanceWindowDaysOfWeekResult'],
                 hours_of_days: Sequence[int],
                 is_custom_action_timeout_enabled: bool,
                 is_monthly_patching_enabled: bool,
                 lead_time_in_weeks: int,
                 months: Sequence['outputs.GetCloudExadataInfrastructureMaintenanceWindowMonthResult'],
                 patching_mode: str,
                 preference: str,
                 weeks_of_months: Sequence[int]):
        """
        :param int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetCloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetCloudExadataInfrastructureMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param str preference: The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        GetCloudExadataInfrastructureMaintenanceWindowResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: int,
             days_of_weeks: Sequence['outputs.GetCloudExadataInfrastructureMaintenanceWindowDaysOfWeekResult'],
             hours_of_days: Sequence[int],
             is_custom_action_timeout_enabled: bool,
             is_monthly_patching_enabled: bool,
             lead_time_in_weeks: int,
             months: Sequence['outputs.GetCloudExadataInfrastructureMaintenanceWindowMonthResult'],
             patching_mode: str,
             preference: str,
             weeks_of_months: Sequence[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        _setter("days_of_weeks", days_of_weeks)
        _setter("hours_of_days", hours_of_days)
        _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        _setter("lead_time_in_weeks", lead_time_in_weeks)
        _setter("months", months)
        _setter("patching_mode", patching_mode)
        _setter("preference", preference)
        _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetCloudExadataInfrastructureMaintenanceWindowDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetCloudExadataInfrastructureMaintenanceWindowMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetCloudExadataInfrastructureMaintenanceWindowDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetCloudExadataInfrastructureMaintenanceWindowDaysOfWeekResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCloudExadataInfrastructureMaintenanceWindowMonthResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetCloudExadataInfrastructureMaintenanceWindowMonthResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCloudExadataInfrastructureUnAllocatedResourceCloudAutonomousVmClusterResult(dict):
    def __init__(__self__, *,
                 id: str,
                 un_allocated_adb_storage_in_tbs: float):
        """
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Cloud Exadata infrastructure.
        :param float un_allocated_adb_storage_in_tbs: Total unallocated autonomous data storage in the Cloud Autonomous VM Cluster in TBs.
        """
        GetCloudExadataInfrastructureUnAllocatedResourceCloudAutonomousVmClusterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            un_allocated_adb_storage_in_tbs=un_allocated_adb_storage_in_tbs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             un_allocated_adb_storage_in_tbs: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("un_allocated_adb_storage_in_tbs", un_allocated_adb_storage_in_tbs)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Cloud Exadata infrastructure.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="unAllocatedAdbStorageInTbs")
    def un_allocated_adb_storage_in_tbs(self) -> float:
        """
        Total unallocated autonomous data storage in the Cloud Autonomous VM Cluster in TBs.
        """
        return pulumi.get(self, "un_allocated_adb_storage_in_tbs")


@pulumi.output_type
class GetCloudExadataInfrastructuresCloudExadataInfrastructureResult(dict):
    def __init__(__self__, *,
                 activated_storage_count: int,
                 additional_storage_count: int,
                 availability_domain: str,
                 available_storage_size_in_gbs: int,
                 compartment_id: str,
                 compute_count: int,
                 cpu_count: int,
                 customer_contacts: Sequence['outputs.GetCloudExadataInfrastructuresCloudExadataInfrastructureCustomerContactResult'],
                 data_storage_size_in_tbs: float,
                 db_node_storage_size_in_gbs: int,
                 db_server_version: str,
                 defined_tags: Mapping[str, Any],
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 last_maintenance_run_id: str,
                 lifecycle_details: str,
                 maintenance_windows: Sequence['outputs.GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowResult'],
                 max_cpu_count: int,
                 max_data_storage_in_tbs: float,
                 max_db_node_storage_in_gbs: int,
                 max_memory_in_gbs: int,
                 memory_size_in_gbs: int,
                 monthly_db_server_version: str,
                 monthly_storage_server_version: str,
                 next_maintenance_run_id: str,
                 shape: str,
                 state: str,
                 storage_count: int,
                 storage_server_version: str,
                 time_created: str,
                 total_storage_size_in_gbs: int):
        """
        :param int activated_storage_count: The requested number of additional storage servers activated for the Exadata infrastructure.
        :param int additional_storage_count: The requested number of additional storage servers for the Exadata infrastructure.
        :param str availability_domain: The name of the availability domain that the cloud Exadata infrastructure resource is located in.
        :param int available_storage_size_in_gbs: The available storage can be allocated to the cloud Exadata infrastructure resource, in gigabytes (GB).
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param int compute_count: The number of compute servers for the cloud Exadata infrastructure.
        :param int cpu_count: The total number of CPU cores allocated.
        :param Sequence['GetCloudExadataInfrastructuresCloudExadataInfrastructureCustomerContactArgs'] customer_contacts: The list of customer email addresses that receive information from Oracle about the specified Oracle Cloud Infrastructure Database service resource. Oracle uses these email addresses to send notifications about planned and unplanned software maintenance updates, information about system hardware, and other information needed by administrators. Up to 10 email addresses can be added to the customer contacts for a cloud Exadata infrastructure instance.
        :param float data_storage_size_in_tbs: Size, in terabytes, of the DATA disk group.
        :param int db_node_storage_size_in_gbs: The local node storage allocated in GBs.
        :param str db_server_version: The software version of the database servers (dom0) in the cloud Exadata infrastructure. Example: 20.1.15
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the cloud Exadata infrastructure resource.
        :param str last_maintenance_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance run.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param Sequence['GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowArgs'] maintenance_windows: The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        :param int max_cpu_count: The total number of CPU cores available.
        :param float max_data_storage_in_tbs: The total available DATA disk group size.
        :param int max_db_node_storage_in_gbs: The total local node storage available in GBs.
        :param int max_memory_in_gbs: The total memory available in GBs.
        :param int memory_size_in_gbs: The memory allocated in GBs.
        :param str monthly_db_server_version: The monthly software version of the database servers (dom0) in the cloud Exadata infrastructure. Example: 20.1.15
        :param str monthly_storage_server_version: The monthly software version of the storage servers (cells) in the cloud Exadata infrastructure. Example: 20.1.15
        :param str next_maintenance_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the next maintenance run.
        :param str shape: The model name of the cloud Exadata infrastructure resource.
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        :param int storage_count: The number of storage servers for the cloud Exadata infrastructure.
        :param str storage_server_version: The software version of the storage servers (cells) in the cloud Exadata infrastructure. Example: 20.1.15
        :param str time_created: The date and time the cloud Exadata infrastructure resource was created.
        :param int total_storage_size_in_gbs: The total storage allocated to the cloud Exadata infrastructure resource, in gigabytes (GB).
        """
        GetCloudExadataInfrastructuresCloudExadataInfrastructureResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            activated_storage_count=activated_storage_count,
            additional_storage_count=additional_storage_count,
            availability_domain=availability_domain,
            available_storage_size_in_gbs=available_storage_size_in_gbs,
            compartment_id=compartment_id,
            compute_count=compute_count,
            cpu_count=cpu_count,
            customer_contacts=customer_contacts,
            data_storage_size_in_tbs=data_storage_size_in_tbs,
            db_node_storage_size_in_gbs=db_node_storage_size_in_gbs,
            db_server_version=db_server_version,
            defined_tags=defined_tags,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            last_maintenance_run_id=last_maintenance_run_id,
            lifecycle_details=lifecycle_details,
            maintenance_windows=maintenance_windows,
            max_cpu_count=max_cpu_count,
            max_data_storage_in_tbs=max_data_storage_in_tbs,
            max_db_node_storage_in_gbs=max_db_node_storage_in_gbs,
            max_memory_in_gbs=max_memory_in_gbs,
            memory_size_in_gbs=memory_size_in_gbs,
            monthly_db_server_version=monthly_db_server_version,
            monthly_storage_server_version=monthly_storage_server_version,
            next_maintenance_run_id=next_maintenance_run_id,
            shape=shape,
            state=state,
            storage_count=storage_count,
            storage_server_version=storage_server_version,
            time_created=time_created,
            total_storage_size_in_gbs=total_storage_size_in_gbs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             activated_storage_count: int,
             additional_storage_count: int,
             availability_domain: str,
             available_storage_size_in_gbs: int,
             compartment_id: str,
             compute_count: int,
             cpu_count: int,
             customer_contacts: Sequence['outputs.GetCloudExadataInfrastructuresCloudExadataInfrastructureCustomerContactResult'],
             data_storage_size_in_tbs: float,
             db_node_storage_size_in_gbs: int,
             db_server_version: str,
             defined_tags: Mapping[str, Any],
             display_name: str,
             freeform_tags: Mapping[str, Any],
             id: str,
             last_maintenance_run_id: str,
             lifecycle_details: str,
             maintenance_windows: Sequence['outputs.GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowResult'],
             max_cpu_count: int,
             max_data_storage_in_tbs: float,
             max_db_node_storage_in_gbs: int,
             max_memory_in_gbs: int,
             memory_size_in_gbs: int,
             monthly_db_server_version: str,
             monthly_storage_server_version: str,
             next_maintenance_run_id: str,
             shape: str,
             state: str,
             storage_count: int,
             storage_server_version: str,
             time_created: str,
             total_storage_size_in_gbs: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("activated_storage_count", activated_storage_count)
        _setter("additional_storage_count", additional_storage_count)
        _setter("availability_domain", availability_domain)
        _setter("available_storage_size_in_gbs", available_storage_size_in_gbs)
        _setter("compartment_id", compartment_id)
        _setter("compute_count", compute_count)
        _setter("cpu_count", cpu_count)
        _setter("customer_contacts", customer_contacts)
        _setter("data_storage_size_in_tbs", data_storage_size_in_tbs)
        _setter("db_node_storage_size_in_gbs", db_node_storage_size_in_gbs)
        _setter("db_server_version", db_server_version)
        _setter("defined_tags", defined_tags)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("last_maintenance_run_id", last_maintenance_run_id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("maintenance_windows", maintenance_windows)
        _setter("max_cpu_count", max_cpu_count)
        _setter("max_data_storage_in_tbs", max_data_storage_in_tbs)
        _setter("max_db_node_storage_in_gbs", max_db_node_storage_in_gbs)
        _setter("max_memory_in_gbs", max_memory_in_gbs)
        _setter("memory_size_in_gbs", memory_size_in_gbs)
        _setter("monthly_db_server_version", monthly_db_server_version)
        _setter("monthly_storage_server_version", monthly_storage_server_version)
        _setter("next_maintenance_run_id", next_maintenance_run_id)
        _setter("shape", shape)
        _setter("state", state)
        _setter("storage_count", storage_count)
        _setter("storage_server_version", storage_server_version)
        _setter("time_created", time_created)
        _setter("total_storage_size_in_gbs", total_storage_size_in_gbs)

    @property
    @pulumi.getter(name="activatedStorageCount")
    def activated_storage_count(self) -> int:
        """
        The requested number of additional storage servers activated for the Exadata infrastructure.
        """
        return pulumi.get(self, "activated_storage_count")

    @property
    @pulumi.getter(name="additionalStorageCount")
    def additional_storage_count(self) -> int:
        """
        The requested number of additional storage servers for the Exadata infrastructure.
        """
        return pulumi.get(self, "additional_storage_count")

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> str:
        """
        The name of the availability domain that the cloud Exadata infrastructure resource is located in.
        """
        return pulumi.get(self, "availability_domain")

    @property
    @pulumi.getter(name="availableStorageSizeInGbs")
    def available_storage_size_in_gbs(self) -> int:
        """
        The available storage can be allocated to the cloud Exadata infrastructure resource, in gigabytes (GB).
        """
        return pulumi.get(self, "available_storage_size_in_gbs")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="computeCount")
    def compute_count(self) -> int:
        """
        The number of compute servers for the cloud Exadata infrastructure.
        """
        return pulumi.get(self, "compute_count")

    @property
    @pulumi.getter(name="cpuCount")
    def cpu_count(self) -> int:
        """
        The total number of CPU cores allocated.
        """
        return pulumi.get(self, "cpu_count")

    @property
    @pulumi.getter(name="customerContacts")
    def customer_contacts(self) -> Sequence['outputs.GetCloudExadataInfrastructuresCloudExadataInfrastructureCustomerContactResult']:
        """
        The list of customer email addresses that receive information from Oracle about the specified Oracle Cloud Infrastructure Database service resource. Oracle uses these email addresses to send notifications about planned and unplanned software maintenance updates, information about system hardware, and other information needed by administrators. Up to 10 email addresses can be added to the customer contacts for a cloud Exadata infrastructure instance.
        """
        return pulumi.get(self, "customer_contacts")

    @property
    @pulumi.getter(name="dataStorageSizeInTbs")
    def data_storage_size_in_tbs(self) -> float:
        """
        Size, in terabytes, of the DATA disk group.
        """
        return pulumi.get(self, "data_storage_size_in_tbs")

    @property
    @pulumi.getter(name="dbNodeStorageSizeInGbs")
    def db_node_storage_size_in_gbs(self) -> int:
        """
        The local node storage allocated in GBs.
        """
        return pulumi.get(self, "db_node_storage_size_in_gbs")

    @property
    @pulumi.getter(name="dbServerVersion")
    def db_server_version(self) -> str:
        """
        The software version of the database servers (dom0) in the cloud Exadata infrastructure. Example: 20.1.15
        """
        return pulumi.get(self, "db_server_version")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the cloud Exadata infrastructure resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastMaintenanceRunId")
    def last_maintenance_run_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance run.
        """
        return pulumi.get(self, "last_maintenance_run_id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Sequence['outputs.GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowResult']:
        """
        The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        """
        return pulumi.get(self, "maintenance_windows")

    @property
    @pulumi.getter(name="maxCpuCount")
    def max_cpu_count(self) -> int:
        """
        The total number of CPU cores available.
        """
        return pulumi.get(self, "max_cpu_count")

    @property
    @pulumi.getter(name="maxDataStorageInTbs")
    def max_data_storage_in_tbs(self) -> float:
        """
        The total available DATA disk group size.
        """
        return pulumi.get(self, "max_data_storage_in_tbs")

    @property
    @pulumi.getter(name="maxDbNodeStorageInGbs")
    def max_db_node_storage_in_gbs(self) -> int:
        """
        The total local node storage available in GBs.
        """
        return pulumi.get(self, "max_db_node_storage_in_gbs")

    @property
    @pulumi.getter(name="maxMemoryInGbs")
    def max_memory_in_gbs(self) -> int:
        """
        The total memory available in GBs.
        """
        return pulumi.get(self, "max_memory_in_gbs")

    @property
    @pulumi.getter(name="memorySizeInGbs")
    def memory_size_in_gbs(self) -> int:
        """
        The memory allocated in GBs.
        """
        return pulumi.get(self, "memory_size_in_gbs")

    @property
    @pulumi.getter(name="monthlyDbServerVersion")
    def monthly_db_server_version(self) -> str:
        """
        The monthly software version of the database servers (dom0) in the cloud Exadata infrastructure. Example: 20.1.15
        """
        return pulumi.get(self, "monthly_db_server_version")

    @property
    @pulumi.getter(name="monthlyStorageServerVersion")
    def monthly_storage_server_version(self) -> str:
        """
        The monthly software version of the storage servers (cells) in the cloud Exadata infrastructure. Example: 20.1.15
        """
        return pulumi.get(self, "monthly_storage_server_version")

    @property
    @pulumi.getter(name="nextMaintenanceRunId")
    def next_maintenance_run_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the next maintenance run.
        """
        return pulumi.get(self, "next_maintenance_run_id")

    @property
    @pulumi.getter
    def shape(self) -> str:
        """
        The model name of the cloud Exadata infrastructure resource.
        """
        return pulumi.get(self, "shape")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="storageCount")
    def storage_count(self) -> int:
        """
        The number of storage servers for the cloud Exadata infrastructure.
        """
        return pulumi.get(self, "storage_count")

    @property
    @pulumi.getter(name="storageServerVersion")
    def storage_server_version(self) -> str:
        """
        The software version of the storage servers (cells) in the cloud Exadata infrastructure. Example: 20.1.15
        """
        return pulumi.get(self, "storage_server_version")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the cloud Exadata infrastructure resource was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="totalStorageSizeInGbs")
    def total_storage_size_in_gbs(self) -> int:
        """
        The total storage allocated to the cloud Exadata infrastructure resource, in gigabytes (GB).
        """
        return pulumi.get(self, "total_storage_size_in_gbs")


@pulumi.output_type
class GetCloudExadataInfrastructuresCloudExadataInfrastructureCustomerContactResult(dict):
    def __init__(__self__, *,
                 email: str):
        """
        :param str email: The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        GetCloudExadataInfrastructuresCloudExadataInfrastructureCustomerContactResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            email=email,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             email: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("email", email)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: int,
                 days_of_weeks: Sequence['outputs.GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowDaysOfWeekResult'],
                 hours_of_days: Sequence[int],
                 is_custom_action_timeout_enabled: bool,
                 is_monthly_patching_enabled: bool,
                 lead_time_in_weeks: int,
                 months: Sequence['outputs.GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowMonthResult'],
                 patching_mode: str,
                 preference: str,
                 weeks_of_months: Sequence[int]):
        """
        :param int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param str preference: The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: int,
             days_of_weeks: Sequence['outputs.GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowDaysOfWeekResult'],
             hours_of_days: Sequence[int],
             is_custom_action_timeout_enabled: bool,
             is_monthly_patching_enabled: bool,
             lead_time_in_weeks: int,
             months: Sequence['outputs.GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowMonthResult'],
             patching_mode: str,
             preference: str,
             weeks_of_months: Sequence[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        _setter("days_of_weeks", days_of_weeks)
        _setter("hours_of_days", hours_of_days)
        _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        _setter("lead_time_in_weeks", lead_time_in_weeks)
        _setter("months", months)
        _setter("patching_mode", patching_mode)
        _setter("preference", preference)
        _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowDaysOfWeekResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowMonthResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetCloudExadataInfrastructuresCloudExadataInfrastructureMaintenanceWindowMonthResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCloudExadataInfrastructuresFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the month of the year.
        """
        GetCloudExadataInfrastructuresFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetCloudVmClusterDataCollectionOptionResult(dict):
    def __init__(__self__, *,
                 is_diagnostics_events_enabled: bool,
                 is_health_monitoring_enabled: bool,
                 is_incident_logs_enabled: bool):
        """
        :param bool is_diagnostics_events_enabled: Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param bool is_health_monitoring_enabled: Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param bool is_incident_logs_enabled: Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        GetCloudVmClusterDataCollectionOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_diagnostics_events_enabled=is_diagnostics_events_enabled,
            is_health_monitoring_enabled=is_health_monitoring_enabled,
            is_incident_logs_enabled=is_incident_logs_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_diagnostics_events_enabled: bool,
             is_health_monitoring_enabled: bool,
             is_incident_logs_enabled: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        _setter("is_health_monitoring_enabled", is_health_monitoring_enabled)
        _setter("is_incident_logs_enabled", is_incident_logs_enabled)

    @property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> bool:
        """
        Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> bool:
        """
        Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> bool:
        """
        Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")


@pulumi.output_type
class GetCloudVmClusterIormConfigCachResult(dict):
    def __init__(__self__, *,
                 db_plans: Sequence['outputs.GetCloudVmClusterIormConfigCachDbPlanResult'],
                 lifecycle_details: str,
                 objective: str,
                 state: str):
        """
        :param Sequence['GetCloudVmClusterIormConfigCachDbPlanArgs'] db_plans: An array of IORM settings for all the database in the Exadata DB system.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str objective: The current value for the IORM objective. The default is `AUTO`.
        :param str state: The current state of the cloud VM cluster.
        """
        GetCloudVmClusterIormConfigCachResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_plans=db_plans,
            lifecycle_details=lifecycle_details,
            objective=objective,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_plans: Sequence['outputs.GetCloudVmClusterIormConfigCachDbPlanResult'],
             lifecycle_details: str,
             objective: str,
             state: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("db_plans", db_plans)
        _setter("lifecycle_details", lifecycle_details)
        _setter("objective", objective)
        _setter("state", state)

    @property
    @pulumi.getter(name="dbPlans")
    def db_plans(self) -> Sequence['outputs.GetCloudVmClusterIormConfigCachDbPlanResult']:
        """
        An array of IORM settings for all the database in the Exadata DB system.
        """
        return pulumi.get(self, "db_plans")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def objective(self) -> str:
        """
        The current value for the IORM objective. The default is `AUTO`.
        """
        return pulumi.get(self, "objective")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the cloud VM cluster.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetCloudVmClusterIormConfigCachDbPlanResult(dict):
    def __init__(__self__, *,
                 db_name: str,
                 flash_cache_limit: str,
                 share: int):
        """
        :param str db_name: The database name. For the default `DbPlan`, the `dbName` is `default`.
        :param str flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        :param int share: The relative priority of this database.
        """
        GetCloudVmClusterIormConfigCachDbPlanResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_name=db_name,
            flash_cache_limit=flash_cache_limit,
            share=share,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_name: str,
             flash_cache_limit: str,
             share: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("db_name", db_name)
        _setter("flash_cache_limit", flash_cache_limit)
        _setter("share", share)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> str:
        """
        The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> str:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")

    @property
    @pulumi.getter
    def share(self) -> int:
        """
        The relative priority of this database.
        """
        return pulumi.get(self, "share")


@pulumi.output_type
class GetCloudVmClusterIormConfigDbPlanResult(dict):
    def __init__(__self__, *,
                 db_name: str,
                 flash_cache_limit: str,
                 share: int):
        """
        :param str db_name: The database name. For the default `DbPlan`, the `dbName` is `default`.
        :param str flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        :param int share: The relative priority of this database.
        """
        GetCloudVmClusterIormConfigDbPlanResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_name=db_name,
            flash_cache_limit=flash_cache_limit,
            share=share,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_name: str,
             flash_cache_limit: str,
             share: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("db_name", db_name)
        _setter("flash_cache_limit", flash_cache_limit)
        _setter("share", share)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> str:
        """
        The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> str:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")

    @property
    @pulumi.getter
    def share(self) -> int:
        """
        The relative priority of this database.
        """
        return pulumi.get(self, "share")


@pulumi.output_type
class GetCloudVmClustersCloudVmClusterResult(dict):
    def __init__(__self__, *,
                 availability_domain: str,
                 backup_network_nsg_ids: Sequence[str],
                 backup_subnet_id: str,
                 cloud_exadata_infrastructure_id: str,
                 cluster_name: str,
                 compartment_id: str,
                 cpu_core_count: int,
                 create_async: bool,
                 data_collection_options: Sequence['outputs.GetCloudVmClustersCloudVmClusterDataCollectionOptionResult'],
                 data_storage_percentage: int,
                 data_storage_size_in_tbs: float,
                 db_node_storage_size_in_gbs: int,
                 db_servers: Sequence[str],
                 defined_tags: Mapping[str, Any],
                 disk_redundancy: str,
                 display_name: str,
                 domain: str,
                 freeform_tags: Mapping[str, Any],
                 gi_version: str,
                 hostname: str,
                 id: str,
                 iorm_config_caches: Sequence['outputs.GetCloudVmClustersCloudVmClusterIormConfigCachResult'],
                 is_local_backup_enabled: bool,
                 is_sparse_diskgroup_enabled: bool,
                 last_update_history_entry_id: str,
                 license_model: str,
                 lifecycle_details: str,
                 listener_port: str,
                 memory_size_in_gbs: int,
                 node_count: int,
                 nsg_ids: Sequence[str],
                 ocpu_count: float,
                 private_zone_id: str,
                 scan_dns_name: str,
                 scan_dns_record_id: str,
                 scan_ip_ids: Sequence[str],
                 scan_listener_port_tcp: int,
                 scan_listener_port_tcp_ssl: int,
                 shape: str,
                 ssh_public_keys: Sequence[str],
                 state: str,
                 storage_size_in_gbs: int,
                 subnet_id: str,
                 system_version: str,
                 time_created: str,
                 time_zone: str,
                 vip_ids: Sequence[str],
                 zone_id: str):
        """
        :param str availability_domain: The name of the availability domain that the cloud Exadata infrastructure resource is located in.
        :param Sequence[str] backup_network_nsg_ids: A list of the [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the network security groups (NSGs) that the backup network of this DB system belongs to. Setting this to an empty array after the list is created removes the resource from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). Applicable only to Exadata systems.
        :param str backup_subnet_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup network subnet associated with the cloud VM cluster.
        :param str cloud_exadata_infrastructure_id: If provided, filters the results for the specified cloud Exadata infrastructure.
        :param str cluster_name: The cluster name for cloud VM cluster. The cluster name must begin with an alphabetic character, and may contain hyphens (-). Underscores (_) are not permitted. The cluster name can be no longer than 11 characters and is not case sensitive.
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param int cpu_core_count: The number of CPU cores enabled on the cloud VM cluster.
        :param Sequence['GetCloudVmClustersCloudVmClusterDataCollectionOptionArgs'] data_collection_options: Indicates user preferences for the various diagnostic collection options for the VM cluster/Cloud VM cluster/VMBM DBCS.
        :param int data_storage_percentage: The percentage assigned to DATA storage (user data and database files). The remaining percentage is assigned to RECO storage (database redo logs, archive logs, and recovery manager backups). Accepted values are 35, 40, 60 and 80. The default is 80 percent assigned to DATA storage. See [Storage Configuration](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/exaoverview.htm#Exadata) in the Exadata documentation for details on the impact of the configuration settings on storage.
        :param float data_storage_size_in_tbs: The data disk group size to be allocated in TBs.
        :param int db_node_storage_size_in_gbs: The local node storage to be allocated in GBs.
        :param Sequence[str] db_servers: The list of DB servers.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str disk_redundancy: The type of redundancy configured for the cloud Vm cluster. NORMAL is 2-way redundancy. HIGH is 3-way redundancy.
        :param str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param str domain: The domain name for the cloud VM cluster.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str gi_version: A valid Oracle Grid Infrastructure (GI) software version.
        :param str hostname: The hostname for the cloud VM cluster.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the cloud VM cluster.
        :param bool is_local_backup_enabled: If true, database backup on local Exadata storage is configured for the cloud VM cluster. If false, database backup on local Exadata storage is not available in the cloud VM cluster.
        :param bool is_sparse_diskgroup_enabled: If true, sparse disk group is configured for the cloud VM cluster. If false, sparse disk group is not created.
        :param str last_update_history_entry_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance update history entry. This value is updated when a maintenance update starts.
        :param str license_model: The Oracle license model that applies to the cloud VM cluster. The default is LICENSE_INCLUDED.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str listener_port: The port number configured for the listener on the cloud VM cluster.
        :param int memory_size_in_gbs: The memory to be allocated in GBs.
        :param int node_count: The number of nodes in the cloud VM cluster.
        :param Sequence[str] nsg_ids: The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the network security groups (NSGs) to which this resource belongs. Setting this to an empty list removes all resources from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). **NsgIds restrictions:**
               * A network security group (NSG) is optional for Autonomous Databases with private access. The nsgIds list can be empty.
        :param float ocpu_count: The number of OCPU cores to enable on the cloud VM cluster. Only 1 decimal place is allowed for the fractional part.
        :param str scan_dns_name: The FQDN of the DNS record for the SCAN IP addresses that are associated with the cloud VM cluster.
        :param str scan_dns_record_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DNS record for the SCAN IP addresses that are associated with the cloud VM cluster.
        :param Sequence[str] scan_ip_ids: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Single Client Access Name (SCAN) IP addresses associated with the cloud VM cluster. SCAN IP addresses are typically used for load balancing and are not assigned to any interface. Oracle Clusterware directs the requests to the appropriate nodes in the cluster.
        :param int scan_listener_port_tcp: The TCP Single Client Access Name (SCAN) port. The default port is 1521.
        :param int scan_listener_port_tcp_ssl: The TCPS Single Client Access Name (SCAN) port. The default port is 2484.
        :param str shape: The model name of the Exadata hardware running the cloud VM cluster.
        :param Sequence[str] ssh_public_keys: The public key portion of one or more key pairs used for SSH access to the cloud VM cluster.
        :param str state: A filter to return only cloud VM clusters that match the given lifecycle state exactly.
        :param int storage_size_in_gbs: The storage allocation for the disk group, in gigabytes (GB).
        :param str subnet_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet associated with the cloud VM cluster.
        :param str system_version: Operating system version of the image.
        :param str time_created: The date and time that the cloud VM cluster was created.
        :param str time_zone: The time zone of the cloud VM cluster. For details, see [Exadata Infrastructure Time Zones](https://docs.cloud.oracle.com/iaas/Content/Database/References/timezones.htm).
        :param Sequence[str] vip_ids: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the virtual IP (VIP) addresses associated with the cloud VM cluster. The Cluster Ready Services (CRS) creates and maintains one VIP address for each node in the Exadata Cloud Service instance to enable failover. If one node fails, the VIP is reassigned to another active node in the cluster.
        :param str zone_id: The OCID of the zone the cloud VM cluster is associated with.
        """
        GetCloudVmClustersCloudVmClusterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_domain=availability_domain,
            backup_network_nsg_ids=backup_network_nsg_ids,
            backup_subnet_id=backup_subnet_id,
            cloud_exadata_infrastructure_id=cloud_exadata_infrastructure_id,
            cluster_name=cluster_name,
            compartment_id=compartment_id,
            cpu_core_count=cpu_core_count,
            create_async=create_async,
            data_collection_options=data_collection_options,
            data_storage_percentage=data_storage_percentage,
            data_storage_size_in_tbs=data_storage_size_in_tbs,
            db_node_storage_size_in_gbs=db_node_storage_size_in_gbs,
            db_servers=db_servers,
            defined_tags=defined_tags,
            disk_redundancy=disk_redundancy,
            display_name=display_name,
            domain=domain,
            freeform_tags=freeform_tags,
            gi_version=gi_version,
            hostname=hostname,
            id=id,
            iorm_config_caches=iorm_config_caches,
            is_local_backup_enabled=is_local_backup_enabled,
            is_sparse_diskgroup_enabled=is_sparse_diskgroup_enabled,
            last_update_history_entry_id=last_update_history_entry_id,
            license_model=license_model,
            lifecycle_details=lifecycle_details,
            listener_port=listener_port,
            memory_size_in_gbs=memory_size_in_gbs,
            node_count=node_count,
            nsg_ids=nsg_ids,
            ocpu_count=ocpu_count,
            private_zone_id=private_zone_id,
            scan_dns_name=scan_dns_name,
            scan_dns_record_id=scan_dns_record_id,
            scan_ip_ids=scan_ip_ids,
            scan_listener_port_tcp=scan_listener_port_tcp,
            scan_listener_port_tcp_ssl=scan_listener_port_tcp_ssl,
            shape=shape,
            ssh_public_keys=ssh_public_keys,
            state=state,
            storage_size_in_gbs=storage_size_in_gbs,
            subnet_id=subnet_id,
            system_version=system_version,
            time_created=time_created,
            time_zone=time_zone,
            vip_ids=vip_ids,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_domain: str,
             backup_network_nsg_ids: Sequence[str],
             backup_subnet_id: str,
             cloud_exadata_infrastructure_id: str,
             cluster_name: str,
             compartment_id: str,
             cpu_core_count: int,
             create_async: bool,
             data_collection_options: Sequence['outputs.GetCloudVmClustersCloudVmClusterDataCollectionOptionResult'],
             data_storage_percentage: int,
             data_storage_size_in_tbs: float,
             db_node_storage_size_in_gbs: int,
             db_servers: Sequence[str],
             defined_tags: Mapping[str, Any],
             disk_redundancy: str,
             display_name: str,
             domain: str,
             freeform_tags: Mapping[str, Any],
             gi_version: str,
             hostname: str,
             id: str,
             iorm_config_caches: Sequence['outputs.GetCloudVmClustersCloudVmClusterIormConfigCachResult'],
             is_local_backup_enabled: bool,
             is_sparse_diskgroup_enabled: bool,
             last_update_history_entry_id: str,
             license_model: str,
             lifecycle_details: str,
             listener_port: str,
             memory_size_in_gbs: int,
             node_count: int,
             nsg_ids: Sequence[str],
             ocpu_count: float,
             private_zone_id: str,
             scan_dns_name: str,
             scan_dns_record_id: str,
             scan_ip_ids: Sequence[str],
             scan_listener_port_tcp: int,
             scan_listener_port_tcp_ssl: int,
             shape: str,
             ssh_public_keys: Sequence[str],
             state: str,
             storage_size_in_gbs: int,
             subnet_id: str,
             system_version: str,
             time_created: str,
             time_zone: str,
             vip_ids: Sequence[str],
             zone_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("availability_domain", availability_domain)
        _setter("backup_network_nsg_ids", backup_network_nsg_ids)
        _setter("backup_subnet_id", backup_subnet_id)
        _setter("cloud_exadata_infrastructure_id", cloud_exadata_infrastructure_id)
        _setter("cluster_name", cluster_name)
        _setter("compartment_id", compartment_id)
        _setter("cpu_core_count", cpu_core_count)
        _setter("create_async", create_async)
        _setter("data_collection_options", data_collection_options)
        _setter("data_storage_percentage", data_storage_percentage)
        _setter("data_storage_size_in_tbs", data_storage_size_in_tbs)
        _setter("db_node_storage_size_in_gbs", db_node_storage_size_in_gbs)
        _setter("db_servers", db_servers)
        _setter("defined_tags", defined_tags)
        _setter("disk_redundancy", disk_redundancy)
        _setter("display_name", display_name)
        _setter("domain", domain)
        _setter("freeform_tags", freeform_tags)
        _setter("gi_version", gi_version)
        _setter("hostname", hostname)
        _setter("id", id)
        _setter("iorm_config_caches", iorm_config_caches)
        _setter("is_local_backup_enabled", is_local_backup_enabled)
        _setter("is_sparse_diskgroup_enabled", is_sparse_diskgroup_enabled)
        _setter("last_update_history_entry_id", last_update_history_entry_id)
        _setter("license_model", license_model)
        _setter("lifecycle_details", lifecycle_details)
        _setter("listener_port", listener_port)
        _setter("memory_size_in_gbs", memory_size_in_gbs)
        _setter("node_count", node_count)
        _setter("nsg_ids", nsg_ids)
        _setter("ocpu_count", ocpu_count)
        _setter("private_zone_id", private_zone_id)
        _setter("scan_dns_name", scan_dns_name)
        _setter("scan_dns_record_id", scan_dns_record_id)
        _setter("scan_ip_ids", scan_ip_ids)
        _setter("scan_listener_port_tcp", scan_listener_port_tcp)
        _setter("scan_listener_port_tcp_ssl", scan_listener_port_tcp_ssl)
        _setter("shape", shape)
        _setter("ssh_public_keys", ssh_public_keys)
        _setter("state", state)
        _setter("storage_size_in_gbs", storage_size_in_gbs)
        _setter("subnet_id", subnet_id)
        _setter("system_version", system_version)
        _setter("time_created", time_created)
        _setter("time_zone", time_zone)
        _setter("vip_ids", vip_ids)
        _setter("zone_id", zone_id)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> str:
        """
        The name of the availability domain that the cloud Exadata infrastructure resource is located in.
        """
        return pulumi.get(self, "availability_domain")

    @property
    @pulumi.getter(name="backupNetworkNsgIds")
    def backup_network_nsg_ids(self) -> Sequence[str]:
        """
        A list of the [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the network security groups (NSGs) that the backup network of this DB system belongs to. Setting this to an empty array after the list is created removes the resource from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). Applicable only to Exadata systems.
        """
        return pulumi.get(self, "backup_network_nsg_ids")

    @property
    @pulumi.getter(name="backupSubnetId")
    def backup_subnet_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup network subnet associated with the cloud VM cluster.
        """
        return pulumi.get(self, "backup_subnet_id")

    @property
    @pulumi.getter(name="cloudExadataInfrastructureId")
    def cloud_exadata_infrastructure_id(self) -> str:
        """
        If provided, filters the results for the specified cloud Exadata infrastructure.
        """
        return pulumi.get(self, "cloud_exadata_infrastructure_id")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        The cluster name for cloud VM cluster. The cluster name must begin with an alphabetic character, and may contain hyphens (-). Underscores (_) are not permitted. The cluster name can be no longer than 11 characters and is not case sensitive.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="cpuCoreCount")
    def cpu_core_count(self) -> int:
        """
        The number of CPU cores enabled on the cloud VM cluster.
        """
        return pulumi.get(self, "cpu_core_count")

    @property
    @pulumi.getter(name="createAsync")
    def create_async(self) -> bool:
        return pulumi.get(self, "create_async")

    @property
    @pulumi.getter(name="dataCollectionOptions")
    def data_collection_options(self) -> Sequence['outputs.GetCloudVmClustersCloudVmClusterDataCollectionOptionResult']:
        """
        Indicates user preferences for the various diagnostic collection options for the VM cluster/Cloud VM cluster/VMBM DBCS.
        """
        return pulumi.get(self, "data_collection_options")

    @property
    @pulumi.getter(name="dataStoragePercentage")
    def data_storage_percentage(self) -> int:
        """
        The percentage assigned to DATA storage (user data and database files). The remaining percentage is assigned to RECO storage (database redo logs, archive logs, and recovery manager backups). Accepted values are 35, 40, 60 and 80. The default is 80 percent assigned to DATA storage. See [Storage Configuration](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/exaoverview.htm#Exadata) in the Exadata documentation for details on the impact of the configuration settings on storage.
        """
        return pulumi.get(self, "data_storage_percentage")

    @property
    @pulumi.getter(name="dataStorageSizeInTbs")
    def data_storage_size_in_tbs(self) -> float:
        """
        The data disk group size to be allocated in TBs.
        """
        return pulumi.get(self, "data_storage_size_in_tbs")

    @property
    @pulumi.getter(name="dbNodeStorageSizeInGbs")
    def db_node_storage_size_in_gbs(self) -> int:
        """
        The local node storage to be allocated in GBs.
        """
        return pulumi.get(self, "db_node_storage_size_in_gbs")

    @property
    @pulumi.getter(name="dbServers")
    def db_servers(self) -> Sequence[str]:
        """
        The list of DB servers.
        """
        return pulumi.get(self, "db_servers")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="diskRedundancy")
    def disk_redundancy(self) -> str:
        """
        The type of redundancy configured for the cloud Vm cluster. NORMAL is 2-way redundancy. HIGH is 3-way redundancy.
        """
        return pulumi.get(self, "disk_redundancy")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The domain name for the cloud VM cluster.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter(name="giVersion")
    def gi_version(self) -> str:
        """
        A valid Oracle Grid Infrastructure (GI) software version.
        """
        return pulumi.get(self, "gi_version")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The hostname for the cloud VM cluster.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the cloud VM cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="iormConfigCaches")
    def iorm_config_caches(self) -> Sequence['outputs.GetCloudVmClustersCloudVmClusterIormConfigCachResult']:
        return pulumi.get(self, "iorm_config_caches")

    @property
    @pulumi.getter(name="isLocalBackupEnabled")
    def is_local_backup_enabled(self) -> bool:
        """
        If true, database backup on local Exadata storage is configured for the cloud VM cluster. If false, database backup on local Exadata storage is not available in the cloud VM cluster.
        """
        return pulumi.get(self, "is_local_backup_enabled")

    @property
    @pulumi.getter(name="isSparseDiskgroupEnabled")
    def is_sparse_diskgroup_enabled(self) -> bool:
        """
        If true, sparse disk group is configured for the cloud VM cluster. If false, sparse disk group is not created.
        """
        return pulumi.get(self, "is_sparse_diskgroup_enabled")

    @property
    @pulumi.getter(name="lastUpdateHistoryEntryId")
    def last_update_history_entry_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance update history entry. This value is updated when a maintenance update starts.
        """
        return pulumi.get(self, "last_update_history_entry_id")

    @property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> str:
        """
        The Oracle license model that applies to the cloud VM cluster. The default is LICENSE_INCLUDED.
        """
        return pulumi.get(self, "license_model")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="listenerPort")
    def listener_port(self) -> str:
        """
        The port number configured for the listener on the cloud VM cluster.
        """
        return pulumi.get(self, "listener_port")

    @property
    @pulumi.getter(name="memorySizeInGbs")
    def memory_size_in_gbs(self) -> int:
        """
        The memory to be allocated in GBs.
        """
        return pulumi.get(self, "memory_size_in_gbs")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> int:
        """
        The number of nodes in the cloud VM cluster.
        """
        return pulumi.get(self, "node_count")

    @property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Sequence[str]:
        """
        The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the network security groups (NSGs) to which this resource belongs. Setting this to an empty list removes all resources from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). **NsgIds restrictions:**
        * A network security group (NSG) is optional for Autonomous Databases with private access. The nsgIds list can be empty.
        """
        return pulumi.get(self, "nsg_ids")

    @property
    @pulumi.getter(name="ocpuCount")
    def ocpu_count(self) -> float:
        """
        The number of OCPU cores to enable on the cloud VM cluster. Only 1 decimal place is allowed for the fractional part.
        """
        return pulumi.get(self, "ocpu_count")

    @property
    @pulumi.getter(name="privateZoneId")
    def private_zone_id(self) -> str:
        return pulumi.get(self, "private_zone_id")

    @property
    @pulumi.getter(name="scanDnsName")
    def scan_dns_name(self) -> str:
        """
        The FQDN of the DNS record for the SCAN IP addresses that are associated with the cloud VM cluster.
        """
        return pulumi.get(self, "scan_dns_name")

    @property
    @pulumi.getter(name="scanDnsRecordId")
    def scan_dns_record_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DNS record for the SCAN IP addresses that are associated with the cloud VM cluster.
        """
        return pulumi.get(self, "scan_dns_record_id")

    @property
    @pulumi.getter(name="scanIpIds")
    def scan_ip_ids(self) -> Sequence[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Single Client Access Name (SCAN) IP addresses associated with the cloud VM cluster. SCAN IP addresses are typically used for load balancing and are not assigned to any interface. Oracle Clusterware directs the requests to the appropriate nodes in the cluster.
        """
        return pulumi.get(self, "scan_ip_ids")

    @property
    @pulumi.getter(name="scanListenerPortTcp")
    def scan_listener_port_tcp(self) -> int:
        """
        The TCP Single Client Access Name (SCAN) port. The default port is 1521.
        """
        return pulumi.get(self, "scan_listener_port_tcp")

    @property
    @pulumi.getter(name="scanListenerPortTcpSsl")
    def scan_listener_port_tcp_ssl(self) -> int:
        """
        The TCPS Single Client Access Name (SCAN) port. The default port is 2484.
        """
        return pulumi.get(self, "scan_listener_port_tcp_ssl")

    @property
    @pulumi.getter
    def shape(self) -> str:
        """
        The model name of the Exadata hardware running the cloud VM cluster.
        """
        return pulumi.get(self, "shape")

    @property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Sequence[str]:
        """
        The public key portion of one or more key pairs used for SSH access to the cloud VM cluster.
        """
        return pulumi.get(self, "ssh_public_keys")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only cloud VM clusters that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="storageSizeInGbs")
    def storage_size_in_gbs(self) -> int:
        """
        The storage allocation for the disk group, in gigabytes (GB).
        """
        return pulumi.get(self, "storage_size_in_gbs")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet associated with the cloud VM cluster.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="systemVersion")
    def system_version(self) -> str:
        """
        Operating system version of the image.
        """
        return pulumi.get(self, "system_version")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time that the cloud VM cluster was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        """
        The time zone of the cloud VM cluster. For details, see [Exadata Infrastructure Time Zones](https://docs.cloud.oracle.com/iaas/Content/Database/References/timezones.htm).
        """
        return pulumi.get(self, "time_zone")

    @property
    @pulumi.getter(name="vipIds")
    def vip_ids(self) -> Sequence[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the virtual IP (VIP) addresses associated with the cloud VM cluster. The Cluster Ready Services (CRS) creates and maintains one VIP address for each node in the Exadata Cloud Service instance to enable failover. If one node fails, the VIP is reassigned to another active node in the cluster.
        """
        return pulumi.get(self, "vip_ids")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        The OCID of the zone the cloud VM cluster is associated with.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetCloudVmClustersCloudVmClusterDataCollectionOptionResult(dict):
    def __init__(__self__, *,
                 is_diagnostics_events_enabled: bool,
                 is_health_monitoring_enabled: bool,
                 is_incident_logs_enabled: bool):
        """
        :param bool is_diagnostics_events_enabled: Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param bool is_health_monitoring_enabled: Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param bool is_incident_logs_enabled: Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        GetCloudVmClustersCloudVmClusterDataCollectionOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_diagnostics_events_enabled=is_diagnostics_events_enabled,
            is_health_monitoring_enabled=is_health_monitoring_enabled,
            is_incident_logs_enabled=is_incident_logs_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_diagnostics_events_enabled: bool,
             is_health_monitoring_enabled: bool,
             is_incident_logs_enabled: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        _setter("is_health_monitoring_enabled", is_health_monitoring_enabled)
        _setter("is_incident_logs_enabled", is_incident_logs_enabled)

    @property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> bool:
        """
        Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> bool:
        """
        Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> bool:
        """
        Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")


@pulumi.output_type
class GetCloudVmClustersCloudVmClusterIormConfigCachResult(dict):
    def __init__(__self__, *,
                 db_plans: Sequence['outputs.GetCloudVmClustersCloudVmClusterIormConfigCachDbPlanResult'],
                 lifecycle_details: str,
                 objective: str,
                 state: str):
        """
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str state: A filter to return only cloud VM clusters that match the given lifecycle state exactly.
        """
        GetCloudVmClustersCloudVmClusterIormConfigCachResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_plans=db_plans,
            lifecycle_details=lifecycle_details,
            objective=objective,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_plans: Sequence['outputs.GetCloudVmClustersCloudVmClusterIormConfigCachDbPlanResult'],
             lifecycle_details: str,
             objective: str,
             state: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("db_plans", db_plans)
        _setter("lifecycle_details", lifecycle_details)
        _setter("objective", objective)
        _setter("state", state)

    @property
    @pulumi.getter(name="dbPlans")
    def db_plans(self) -> Sequence['outputs.GetCloudVmClustersCloudVmClusterIormConfigCachDbPlanResult']:
        return pulumi.get(self, "db_plans")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def objective(self) -> str:
        return pulumi.get(self, "objective")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only cloud VM clusters that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetCloudVmClustersCloudVmClusterIormConfigCachDbPlanResult(dict):
    def __init__(__self__, *,
                 db_name: str,
                 flash_cache_limit: str,
                 share: int):
        GetCloudVmClustersCloudVmClusterIormConfigCachDbPlanResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_name=db_name,
            flash_cache_limit=flash_cache_limit,
            share=share,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_name: str,
             flash_cache_limit: str,
             share: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("db_name", db_name)
        _setter("flash_cache_limit", flash_cache_limit)
        _setter("share", share)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> str:
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> str:
        return pulumi.get(self, "flash_cache_limit")

    @property
    @pulumi.getter
    def share(self) -> int:
        return pulumi.get(self, "share")


@pulumi.output_type
class GetCloudVmClustersFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetCloudVmClustersFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDataGuardAssociationDataCollectionOptionResult(dict):
    def __init__(__self__, *,
                 is_diagnostics_events_enabled: bool,
                 is_health_monitoring_enabled: bool,
                 is_incident_logs_enabled: bool):
        GetDataGuardAssociationDataCollectionOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_diagnostics_events_enabled=is_diagnostics_events_enabled,
            is_health_monitoring_enabled=is_health_monitoring_enabled,
            is_incident_logs_enabled=is_incident_logs_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_diagnostics_events_enabled: bool,
             is_health_monitoring_enabled: bool,
             is_incident_logs_enabled: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        _setter("is_health_monitoring_enabled", is_health_monitoring_enabled)
        _setter("is_incident_logs_enabled", is_incident_logs_enabled)

    @property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> bool:
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> bool:
        return pulumi.get(self, "is_health_monitoring_enabled")

    @property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> bool:
        return pulumi.get(self, "is_incident_logs_enabled")


@pulumi.output_type
class GetDataGuardAssociationsDataGuardAssociationResult(dict):
    def __init__(__self__, *,
                 apply_lag: str,
                 apply_rate: str,
                 availability_domain: str,
                 backup_network_nsg_ids: Sequence[str],
                 cpu_core_count: int,
                 create_async: bool,
                 creation_type: str,
                 data_collection_options: Sequence['outputs.GetDataGuardAssociationsDataGuardAssociationDataCollectionOptionResult'],
                 database_admin_password: str,
                 database_defined_tags: Mapping[str, Any],
                 database_freeform_tags: Mapping[str, Any],
                 database_id: str,
                 database_software_image_id: str,
                 db_system_defined_tags: Mapping[str, Any],
                 db_system_freeform_tags: Mapping[str, Any],
                 delete_standby_db_home_on_delete: str,
                 display_name: str,
                 fault_domains: Sequence[str],
                 hostname: str,
                 id: str,
                 is_active_data_guard_enabled: bool,
                 license_model: str,
                 lifecycle_details: str,
                 node_count: int,
                 nsg_ids: Sequence[str],
                 peer_data_guard_association_id: str,
                 peer_database_id: str,
                 peer_db_home_id: str,
                 peer_db_system_id: str,
                 peer_db_unique_name: str,
                 peer_role: str,
                 peer_sid_prefix: str,
                 peer_vm_cluster_id: str,
                 private_ip: str,
                 protection_mode: str,
                 role: str,
                 shape: str,
                 state: str,
                 storage_volume_performance_mode: str,
                 subnet_id: str,
                 time_created: str,
                 time_zone: str,
                 transport_type: str):
        """
        :param str apply_lag: The lag time between updates to the primary database and application of the redo data on the standby database, as computed by the reporting database.  Example: `9 seconds`
        :param str apply_rate: The rate at which redo logs are synced between the associated databases.  Example: `180 Mb per second`
        :param str database_id: The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Data Guard association.
        :param bool is_active_data_guard_enabled: True if active Data Guard is enabled.
        :param str lifecycle_details: Additional information about the current lifecycleState, if available.
        :param str peer_data_guard_association_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the peer database's Data Guard association.
        :param str peer_database_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the associated peer database.
        :param str peer_db_home_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home containing the associated peer database.
        :param str peer_db_system_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system containing the associated peer database.
        :param str peer_role: The role of the peer database in this Data Guard association.
        :param str protection_mode: The protection mode of this Data Guard association. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        :param str role: The role of the reporting database in this Data Guard association.
        :param str state: The current state of the Data Guard association.
        :param str time_created: The date and time the Data Guard association was created.
        :param str transport_type: The redo transport type used by this Data Guard association.  For more information, see [Redo Transport Services](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-redo-transport-services.htm#SBYDB00400) in the Oracle Data Guard documentation.
        """
        GetDataGuardAssociationsDataGuardAssociationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apply_lag=apply_lag,
            apply_rate=apply_rate,
            availability_domain=availability_domain,
            backup_network_nsg_ids=backup_network_nsg_ids,
            cpu_core_count=cpu_core_count,
            create_async=create_async,
            creation_type=creation_type,
            data_collection_options=data_collection_options,
            database_admin_password=database_admin_password,
            database_defined_tags=database_defined_tags,
            database_freeform_tags=database_freeform_tags,
            database_id=database_id,
            database_software_image_id=database_software_image_id,
            db_system_defined_tags=db_system_defined_tags,
            db_system_freeform_tags=db_system_freeform_tags,
            delete_standby_db_home_on_delete=delete_standby_db_home_on_delete,
            display_name=display_name,
            fault_domains=fault_domains,
            hostname=hostname,
            id=id,
            is_active_data_guard_enabled=is_active_data_guard_enabled,
            license_model=license_model,
            lifecycle_details=lifecycle_details,
            node_count=node_count,
            nsg_ids=nsg_ids,
            peer_data_guard_association_id=peer_data_guard_association_id,
            peer_database_id=peer_database_id,
            peer_db_home_id=peer_db_home_id,
            peer_db_system_id=peer_db_system_id,
            peer_db_unique_name=peer_db_unique_name,
            peer_role=peer_role,
            peer_sid_prefix=peer_sid_prefix,
            peer_vm_cluster_id=peer_vm_cluster_id,
            private_ip=private_ip,
            protection_mode=protection_mode,
            role=role,
            shape=shape,
            state=state,
            storage_volume_performance_mode=storage_volume_performance_mode,
            subnet_id=subnet_id,
            time_created=time_created,
            time_zone=time_zone,
            transport_type=transport_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apply_lag: str,
             apply_rate: str,
             availability_domain: str,
             backup_network_nsg_ids: Sequence[str],
             cpu_core_count: int,
             create_async: bool,
             creation_type: str,
             data_collection_options: Sequence['outputs.GetDataGuardAssociationsDataGuardAssociationDataCollectionOptionResult'],
             database_admin_password: str,
             database_defined_tags: Mapping[str, Any],
             database_freeform_tags: Mapping[str, Any],
             database_id: str,
             database_software_image_id: str,
             db_system_defined_tags: Mapping[str, Any],
             db_system_freeform_tags: Mapping[str, Any],
             delete_standby_db_home_on_delete: str,
             display_name: str,
             fault_domains: Sequence[str],
             hostname: str,
             id: str,
             is_active_data_guard_enabled: bool,
             license_model: str,
             lifecycle_details: str,
             node_count: int,
             nsg_ids: Sequence[str],
             peer_data_guard_association_id: str,
             peer_database_id: str,
             peer_db_home_id: str,
             peer_db_system_id: str,
             peer_db_unique_name: str,
             peer_role: str,
             peer_sid_prefix: str,
             peer_vm_cluster_id: str,
             private_ip: str,
             protection_mode: str,
             role: str,
             shape: str,
             state: str,
             storage_volume_performance_mode: str,
             subnet_id: str,
             time_created: str,
             time_zone: str,
             transport_type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("apply_lag", apply_lag)
        _setter("apply_rate", apply_rate)
        _setter("availability_domain", availability_domain)
        _setter("backup_network_nsg_ids", backup_network_nsg_ids)
        _setter("cpu_core_count", cpu_core_count)
        _setter("create_async", create_async)
        _setter("creation_type", creation_type)
        _setter("data_collection_options", data_collection_options)
        _setter("database_admin_password", database_admin_password)
        _setter("database_defined_tags", database_defined_tags)
        _setter("database_freeform_tags", database_freeform_tags)
        _setter("database_id", database_id)
        _setter("database_software_image_id", database_software_image_id)
        _setter("db_system_defined_tags", db_system_defined_tags)
        _setter("db_system_freeform_tags", db_system_freeform_tags)
        _setter("delete_standby_db_home_on_delete", delete_standby_db_home_on_delete)
        _setter("display_name", display_name)
        _setter("fault_domains", fault_domains)
        _setter("hostname", hostname)
        _setter("id", id)
        _setter("is_active_data_guard_enabled", is_active_data_guard_enabled)
        _setter("license_model", license_model)
        _setter("lifecycle_details", lifecycle_details)
        _setter("node_count", node_count)
        _setter("nsg_ids", nsg_ids)
        _setter("peer_data_guard_association_id", peer_data_guard_association_id)
        _setter("peer_database_id", peer_database_id)
        _setter("peer_db_home_id", peer_db_home_id)
        _setter("peer_db_system_id", peer_db_system_id)
        _setter("peer_db_unique_name", peer_db_unique_name)
        _setter("peer_role", peer_role)
        _setter("peer_sid_prefix", peer_sid_prefix)
        _setter("peer_vm_cluster_id", peer_vm_cluster_id)
        _setter("private_ip", private_ip)
        _setter("protection_mode", protection_mode)
        _setter("role", role)
        _setter("shape", shape)
        _setter("state", state)
        _setter("storage_volume_performance_mode", storage_volume_performance_mode)
        _setter("subnet_id", subnet_id)
        _setter("time_created", time_created)
        _setter("time_zone", time_zone)
        _setter("transport_type", transport_type)

    @property
    @pulumi.getter(name="applyLag")
    def apply_lag(self) -> str:
        """
        The lag time between updates to the primary database and application of the redo data on the standby database, as computed by the reporting database.  Example: `9 seconds`
        """
        return pulumi.get(self, "apply_lag")

    @property
    @pulumi.getter(name="applyRate")
    def apply_rate(self) -> str:
        """
        The rate at which redo logs are synced between the associated databases.  Example: `180 Mb per second`
        """
        return pulumi.get(self, "apply_rate")

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> str:
        return pulumi.get(self, "availability_domain")

    @property
    @pulumi.getter(name="backupNetworkNsgIds")
    def backup_network_nsg_ids(self) -> Sequence[str]:
        return pulumi.get(self, "backup_network_nsg_ids")

    @property
    @pulumi.getter(name="cpuCoreCount")
    def cpu_core_count(self) -> int:
        return pulumi.get(self, "cpu_core_count")

    @property
    @pulumi.getter(name="createAsync")
    def create_async(self) -> bool:
        return pulumi.get(self, "create_async")

    @property
    @pulumi.getter(name="creationType")
    def creation_type(self) -> str:
        return pulumi.get(self, "creation_type")

    @property
    @pulumi.getter(name="dataCollectionOptions")
    def data_collection_options(self) -> Sequence['outputs.GetDataGuardAssociationsDataGuardAssociationDataCollectionOptionResult']:
        return pulumi.get(self, "data_collection_options")

    @property
    @pulumi.getter(name="databaseAdminPassword")
    def database_admin_password(self) -> str:
        return pulumi.get(self, "database_admin_password")

    @property
    @pulumi.getter(name="databaseDefinedTags")
    def database_defined_tags(self) -> Mapping[str, Any]:
        return pulumi.get(self, "database_defined_tags")

    @property
    @pulumi.getter(name="databaseFreeformTags")
    def database_freeform_tags(self) -> Mapping[str, Any]:
        return pulumi.get(self, "database_freeform_tags")

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> str:
        """
        The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "database_id")

    @property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> str:
        return pulumi.get(self, "database_software_image_id")

    @property
    @pulumi.getter(name="dbSystemDefinedTags")
    def db_system_defined_tags(self) -> Mapping[str, Any]:
        return pulumi.get(self, "db_system_defined_tags")

    @property
    @pulumi.getter(name="dbSystemFreeformTags")
    def db_system_freeform_tags(self) -> Mapping[str, Any]:
        return pulumi.get(self, "db_system_freeform_tags")

    @property
    @pulumi.getter(name="deleteStandbyDbHomeOnDelete")
    def delete_standby_db_home_on_delete(self) -> str:
        return pulumi.get(self, "delete_standby_db_home_on_delete")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="faultDomains")
    def fault_domains(self) -> Sequence[str]:
        return pulumi.get(self, "fault_domains")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Data Guard association.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isActiveDataGuardEnabled")
    def is_active_data_guard_enabled(self) -> bool:
        """
        True if active Data Guard is enabled.
        """
        return pulumi.get(self, "is_active_data_guard_enabled")

    @property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> str:
        return pulumi.get(self, "license_model")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycleState, if available.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> int:
        return pulumi.get(self, "node_count")

    @property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Sequence[str]:
        return pulumi.get(self, "nsg_ids")

    @property
    @pulumi.getter(name="peerDataGuardAssociationId")
    def peer_data_guard_association_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the peer database's Data Guard association.
        """
        return pulumi.get(self, "peer_data_guard_association_id")

    @property
    @pulumi.getter(name="peerDatabaseId")
    def peer_database_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the associated peer database.
        """
        return pulumi.get(self, "peer_database_id")

    @property
    @pulumi.getter(name="peerDbHomeId")
    def peer_db_home_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home containing the associated peer database.
        """
        return pulumi.get(self, "peer_db_home_id")

    @property
    @pulumi.getter(name="peerDbSystemId")
    def peer_db_system_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system containing the associated peer database.
        """
        return pulumi.get(self, "peer_db_system_id")

    @property
    @pulumi.getter(name="peerDbUniqueName")
    def peer_db_unique_name(self) -> str:
        return pulumi.get(self, "peer_db_unique_name")

    @property
    @pulumi.getter(name="peerRole")
    def peer_role(self) -> str:
        """
        The role of the peer database in this Data Guard association.
        """
        return pulumi.get(self, "peer_role")

    @property
    @pulumi.getter(name="peerSidPrefix")
    def peer_sid_prefix(self) -> str:
        return pulumi.get(self, "peer_sid_prefix")

    @property
    @pulumi.getter(name="peerVmClusterId")
    def peer_vm_cluster_id(self) -> str:
        return pulumi.get(self, "peer_vm_cluster_id")

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> str:
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter(name="protectionMode")
    def protection_mode(self) -> str:
        """
        The protection mode of this Data Guard association. For more information, see [Oracle Data Guard Protection Modes](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-protection-modes.htm#SBYDB02000) in the Oracle Data Guard documentation.
        """
        return pulumi.get(self, "protection_mode")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        The role of the reporting database in this Data Guard association.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def shape(self) -> str:
        return pulumi.get(self, "shape")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the Data Guard association.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="storageVolumePerformanceMode")
    def storage_volume_performance_mode(self) -> str:
        return pulumi.get(self, "storage_volume_performance_mode")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the Data Guard association was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        return pulumi.get(self, "time_zone")

    @property
    @pulumi.getter(name="transportType")
    def transport_type(self) -> str:
        """
        The redo transport type used by this Data Guard association.  For more information, see [Redo Transport Services](http://docs.oracle.com/database/122/SBYDB/oracle-data-guard-redo-transport-services.htm#SBYDB00400) in the Oracle Data Guard documentation.
        """
        return pulumi.get(self, "transport_type")


@pulumi.output_type
class GetDataGuardAssociationsDataGuardAssociationDataCollectionOptionResult(dict):
    def __init__(__self__, *,
                 is_diagnostics_events_enabled: bool,
                 is_health_monitoring_enabled: bool,
                 is_incident_logs_enabled: bool):
        GetDataGuardAssociationsDataGuardAssociationDataCollectionOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_diagnostics_events_enabled=is_diagnostics_events_enabled,
            is_health_monitoring_enabled=is_health_monitoring_enabled,
            is_incident_logs_enabled=is_incident_logs_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_diagnostics_events_enabled: bool,
             is_health_monitoring_enabled: bool,
             is_incident_logs_enabled: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        _setter("is_health_monitoring_enabled", is_health_monitoring_enabled)
        _setter("is_incident_logs_enabled", is_incident_logs_enabled)

    @property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> bool:
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> bool:
        return pulumi.get(self, "is_health_monitoring_enabled")

    @property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> bool:
        return pulumi.get(self, "is_incident_logs_enabled")


@pulumi.output_type
class GetDataGuardAssociationsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDataGuardAssociationsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDatabaseConnectionStringResult(dict):
    def __init__(__self__, *,
                 all_connection_strings: Mapping[str, Any],
                 cdb_default: str,
                 cdb_ip_default: str):
        """
        :param Mapping[str, Any] all_connection_strings: All connection strings to use to connect to the Database.
        :param str cdb_default: Host name based CDB Connection String.
        :param str cdb_ip_default: IP based CDB Connection String.
        """
        GetDatabaseConnectionStringResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_connection_strings=all_connection_strings,
            cdb_default=cdb_default,
            cdb_ip_default=cdb_ip_default,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_connection_strings: Mapping[str, Any],
             cdb_default: str,
             cdb_ip_default: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("all_connection_strings", all_connection_strings)
        _setter("cdb_default", cdb_default)
        _setter("cdb_ip_default", cdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Mapping[str, Any]:
        """
        All connection strings to use to connect to the Database.
        """
        return pulumi.get(self, "all_connection_strings")

    @property
    @pulumi.getter(name="cdbDefault")
    def cdb_default(self) -> str:
        """
        Host name based CDB Connection String.
        """
        return pulumi.get(self, "cdb_default")

    @property
    @pulumi.getter(name="cdbIpDefault")
    def cdb_ip_default(self) -> str:
        """
        IP based CDB Connection String.
        """
        return pulumi.get(self, "cdb_ip_default")


@pulumi.output_type
class GetDatabaseDatabaseResult(dict):
    def __init__(__self__, *,
                 admin_password: str,
                 backup_id: str,
                 backup_tde_password: str,
                 character_set: str,
                 database_software_image_id: str,
                 db_backup_configs: Sequence['outputs.GetDatabaseDatabaseDbBackupConfigResult'],
                 db_name: str,
                 db_unique_name: str,
                 db_workload: str,
                 defined_tags: Mapping[str, Any],
                 freeform_tags: Mapping[str, Any],
                 kms_key_id: str,
                 kms_key_version_id: str,
                 ncharacter_set: str,
                 pdb_name: str,
                 sid_prefix: str,
                 tde_wallet_password: str,
                 vault_id: str):
        """
        :param str character_set: The character set for the database.
        :param str database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        :param Sequence['GetDatabaseDatabaseDbBackupConfigArgs'] db_backup_configs: Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        :param str db_name: The database name.
        :param str db_unique_name: A system-generated name for the database to ensure uniqueness within an Oracle Data Guard group (a primary database and its standby databases). The unique name cannot be changed.
        :param str db_workload: **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        :param str ncharacter_set: The national character set for the database.
        :param str pdb_name: The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        :param str sid_prefix: Specifies a prefix for the `Oracle SID` of the database to be created.
        :param str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        GetDatabaseDatabaseResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            admin_password=admin_password,
            backup_id=backup_id,
            backup_tde_password=backup_tde_password,
            character_set=character_set,
            database_software_image_id=database_software_image_id,
            db_backup_configs=db_backup_configs,
            db_name=db_name,
            db_unique_name=db_unique_name,
            db_workload=db_workload,
            defined_tags=defined_tags,
            freeform_tags=freeform_tags,
            kms_key_id=kms_key_id,
            kms_key_version_id=kms_key_version_id,
            ncharacter_set=ncharacter_set,
            pdb_name=pdb_name,
            sid_prefix=sid_prefix,
            tde_wallet_password=tde_wallet_password,
            vault_id=vault_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             admin_password: str,
             backup_id: str,
             backup_tde_password: str,
             character_set: str,
             database_software_image_id: str,
             db_backup_configs: Sequence['outputs.GetDatabaseDatabaseDbBackupConfigResult'],
             db_name: str,
             db_unique_name: str,
             db_workload: str,
             defined_tags: Mapping[str, Any],
             freeform_tags: Mapping[str, Any],
             kms_key_id: str,
             kms_key_version_id: str,
             ncharacter_set: str,
             pdb_name: str,
             sid_prefix: str,
             tde_wallet_password: str,
             vault_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("admin_password", admin_password)
        _setter("backup_id", backup_id)
        _setter("backup_tde_password", backup_tde_password)
        _setter("character_set", character_set)
        _setter("database_software_image_id", database_software_image_id)
        _setter("db_backup_configs", db_backup_configs)
        _setter("db_name", db_name)
        _setter("db_unique_name", db_unique_name)
        _setter("db_workload", db_workload)
        _setter("defined_tags", defined_tags)
        _setter("freeform_tags", freeform_tags)
        _setter("kms_key_id", kms_key_id)
        _setter("kms_key_version_id", kms_key_version_id)
        _setter("ncharacter_set", ncharacter_set)
        _setter("pdb_name", pdb_name)
        _setter("sid_prefix", sid_prefix)
        _setter("tde_wallet_password", tde_wallet_password)
        _setter("vault_id", vault_id)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> str:
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> str:
        return pulumi.get(self, "backup_id")

    @property
    @pulumi.getter(name="backupTdePassword")
    def backup_tde_password(self) -> str:
        return pulumi.get(self, "backup_tde_password")

    @property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> str:
        """
        The character set for the database.
        """
        return pulumi.get(self, "character_set")

    @property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> str:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        return pulumi.get(self, "database_software_image_id")

    @property
    @pulumi.getter(name="dbBackupConfigs")
    def db_backup_configs(self) -> Sequence['outputs.GetDatabaseDatabaseDbBackupConfigResult']:
        """
        Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        """
        return pulumi.get(self, "db_backup_configs")

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> str:
        """
        The database name.
        """
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> str:
        """
        A system-generated name for the database to ensure uniqueness within an Oracle Data Guard group (a primary database and its standby databases). The unique name cannot be changed.
        """
        return pulumi.get(self, "db_unique_name")

    @property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> str:
        """
        **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.
        """
        return pulumi.get(self, "db_workload")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> str:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        """
        return pulumi.get(self, "kms_key_version_id")

    @property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> str:
        """
        The national character set for the database.
        """
        return pulumi.get(self, "ncharacter_set")

    @property
    @pulumi.getter(name="pdbName")
    def pdb_name(self) -> str:
        """
        The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        """
        return pulumi.get(self, "pdb_name")

    @property
    @pulumi.getter(name="sidPrefix")
    def sid_prefix(self) -> str:
        """
        Specifies a prefix for the `Oracle SID` of the database to be created.
        """
        return pulumi.get(self, "sid_prefix")

    @property
    @pulumi.getter(name="tdeWalletPassword")
    def tde_wallet_password(self) -> str:
        return pulumi.get(self, "tde_wallet_password")

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class GetDatabaseDatabaseDbBackupConfigResult(dict):
    def __init__(__self__, *,
                 auto_backup_enabled: bool,
                 auto_backup_window: str,
                 auto_full_backup_day: str,
                 auto_full_backup_window: str,
                 backup_deletion_policy: str,
                 backup_destination_details: Sequence['outputs.GetDatabaseDatabaseDbBackupConfigBackupDestinationDetailResult'],
                 recovery_window_in_days: int,
                 run_immediate_full_backup: bool):
        """
        :param bool auto_backup_enabled: If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param str auto_backup_window: Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param str auto_full_backup_day: Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        :param str auto_full_backup_window: Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param str backup_deletion_policy: This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        :param Sequence['GetDatabaseDatabaseDbBackupConfigBackupDestinationDetailArgs'] backup_destination_details: Backup destination details.
        :param int recovery_window_in_days: Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        :param bool run_immediate_full_backup: If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        GetDatabaseDatabaseDbBackupConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_backup_enabled=auto_backup_enabled,
            auto_backup_window=auto_backup_window,
            auto_full_backup_day=auto_full_backup_day,
            auto_full_backup_window=auto_full_backup_window,
            backup_deletion_policy=backup_deletion_policy,
            backup_destination_details=backup_destination_details,
            recovery_window_in_days=recovery_window_in_days,
            run_immediate_full_backup=run_immediate_full_backup,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_backup_enabled: bool,
             auto_backup_window: str,
             auto_full_backup_day: str,
             auto_full_backup_window: str,
             backup_deletion_policy: str,
             backup_destination_details: Sequence['outputs.GetDatabaseDatabaseDbBackupConfigBackupDestinationDetailResult'],
             recovery_window_in_days: int,
             run_immediate_full_backup: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("auto_backup_enabled", auto_backup_enabled)
        _setter("auto_backup_window", auto_backup_window)
        _setter("auto_full_backup_day", auto_full_backup_day)
        _setter("auto_full_backup_window", auto_full_backup_window)
        _setter("backup_deletion_policy", backup_deletion_policy)
        _setter("backup_destination_details", backup_destination_details)
        _setter("recovery_window_in_days", recovery_window_in_days)
        _setter("run_immediate_full_backup", run_immediate_full_backup)

    @property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> bool:
        """
        If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> str:
        """
        Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> str:
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        return pulumi.get(self, "auto_full_backup_day")

    @property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> str:
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_full_backup_window")

    @property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> str:
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        return pulumi.get(self, "backup_deletion_policy")

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Sequence['outputs.GetDatabaseDatabaseDbBackupConfigBackupDestinationDetailResult']:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> int:
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> bool:
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        return pulumi.get(self, "run_immediate_full_backup")


@pulumi.output_type
class GetDatabaseDatabaseDbBackupConfigBackupDestinationDetailResult(dict):
    def __init__(__self__, *,
                 dbrs_policy_id: str,
                 id: str,
                 type: str,
                 vpc_user: str):
        """
        :param str dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        :param str type: Type of the database backup destination.
        """
        GetDatabaseDatabaseDbBackupConfigBackupDestinationDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dbrs_policy_id=dbrs_policy_id,
            id=id,
            type=type,
            vpc_user=vpc_user,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dbrs_policy_id: str,
             id: str,
             type: str,
             vpc_user: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("dbrs_policy_id", dbrs_policy_id)
        _setter("id", id)
        _setter("type", type)
        _setter("vpc_user", vpc_user)

    @property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> str:
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class GetDatabaseDatabaseManagementConfigResult(dict):
    def __init__(__self__, *,
                 management_status: str,
                 management_type: str):
        """
        :param str management_status: The status of the Database Management service.
        :param str management_type: The Database Management type.
        """
        GetDatabaseDatabaseManagementConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            management_status=management_status,
            management_type=management_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             management_status: str,
             management_type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("management_status", management_status)
        _setter("management_type", management_type)

    @property
    @pulumi.getter(name="managementStatus")
    def management_status(self) -> str:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "management_status")

    @property
    @pulumi.getter(name="managementType")
    def management_type(self) -> str:
        """
        The Database Management type.
        """
        return pulumi.get(self, "management_type")


@pulumi.output_type
class GetDatabaseDbBackupConfigResult(dict):
    def __init__(__self__, *,
                 auto_backup_enabled: bool,
                 auto_backup_window: str,
                 auto_full_backup_day: str,
                 auto_full_backup_window: str,
                 backup_deletion_policy: str,
                 backup_destination_details: Sequence['outputs.GetDatabaseDbBackupConfigBackupDestinationDetailResult'],
                 recovery_window_in_days: int,
                 run_immediate_full_backup: bool):
        """
        :param bool auto_backup_enabled: If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param str auto_backup_window: Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param str auto_full_backup_day: Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        :param str auto_full_backup_window: Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param str backup_deletion_policy: This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        :param Sequence['GetDatabaseDbBackupConfigBackupDestinationDetailArgs'] backup_destination_details: Backup destination details.
        :param int recovery_window_in_days: Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        :param bool run_immediate_full_backup: If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        GetDatabaseDbBackupConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_backup_enabled=auto_backup_enabled,
            auto_backup_window=auto_backup_window,
            auto_full_backup_day=auto_full_backup_day,
            auto_full_backup_window=auto_full_backup_window,
            backup_deletion_policy=backup_deletion_policy,
            backup_destination_details=backup_destination_details,
            recovery_window_in_days=recovery_window_in_days,
            run_immediate_full_backup=run_immediate_full_backup,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_backup_enabled: bool,
             auto_backup_window: str,
             auto_full_backup_day: str,
             auto_full_backup_window: str,
             backup_deletion_policy: str,
             backup_destination_details: Sequence['outputs.GetDatabaseDbBackupConfigBackupDestinationDetailResult'],
             recovery_window_in_days: int,
             run_immediate_full_backup: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("auto_backup_enabled", auto_backup_enabled)
        _setter("auto_backup_window", auto_backup_window)
        _setter("auto_full_backup_day", auto_full_backup_day)
        _setter("auto_full_backup_window", auto_full_backup_window)
        _setter("backup_deletion_policy", backup_deletion_policy)
        _setter("backup_destination_details", backup_destination_details)
        _setter("recovery_window_in_days", recovery_window_in_days)
        _setter("run_immediate_full_backup", run_immediate_full_backup)

    @property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> bool:
        """
        If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> str:
        """
        Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> str:
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        return pulumi.get(self, "auto_full_backup_day")

    @property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> str:
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_full_backup_window")

    @property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> str:
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        return pulumi.get(self, "backup_deletion_policy")

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Sequence['outputs.GetDatabaseDbBackupConfigBackupDestinationDetailResult']:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> int:
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> bool:
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        return pulumi.get(self, "run_immediate_full_backup")


@pulumi.output_type
class GetDatabaseDbBackupConfigBackupDestinationDetailResult(dict):
    def __init__(__self__, *,
                 dbrs_policy_id: str,
                 id: str,
                 type: str,
                 vpc_user: str):
        """
        :param str dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        :param str type: Type of the database backup destination.
        """
        GetDatabaseDbBackupConfigBackupDestinationDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dbrs_policy_id=dbrs_policy_id,
            id=id,
            type=type,
            vpc_user=vpc_user,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dbrs_policy_id: str,
             id: str,
             type: str,
             vpc_user: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("dbrs_policy_id", dbrs_policy_id)
        _setter("id", id)
        _setter("type", type)
        _setter("vpc_user", vpc_user)

    @property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> str:
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class GetDatabaseMaintenanceRunHistoriesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDatabaseMaintenanceRunHistoriesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryResult(dict):
    def __init__(__self__, *,
                 db_servers_history_details: Sequence['outputs.GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryDbServersHistoryDetailResult'],
                 id: str,
                 maintenance_run_details: Sequence['outputs.GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryMaintenanceRunDetailResult']):
        """
        :param Sequence['GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryDbServersHistoryDetailArgs'] db_servers_history_details: List of database server history details.
        :param str id: The OCID of the maintenance run.
        :param Sequence['GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryMaintenanceRunDetailArgs'] maintenance_run_details: Details of a maintenance run.
        """
        GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_servers_history_details=db_servers_history_details,
            id=id,
            maintenance_run_details=maintenance_run_details,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_servers_history_details: Sequence['outputs.GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryDbServersHistoryDetailResult'],
             id: str,
             maintenance_run_details: Sequence['outputs.GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryMaintenanceRunDetailResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("db_servers_history_details", db_servers_history_details)
        _setter("id", id)
        _setter("maintenance_run_details", maintenance_run_details)

    @property
    @pulumi.getter(name="dbServersHistoryDetails")
    def db_servers_history_details(self) -> Sequence['outputs.GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryDbServersHistoryDetailResult']:
        """
        List of database server history details.
        """
        return pulumi.get(self, "db_servers_history_details")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the maintenance run.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="maintenanceRunDetails")
    def maintenance_run_details(self) -> Sequence['outputs.GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryMaintenanceRunDetailResult']:
        """
        Details of a maintenance run.
        """
        return pulumi.get(self, "maintenance_run_details")


@pulumi.output_type
class GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryDbServersHistoryDetailResult(dict):
    def __init__(__self__, *,
                 db_server_patching_details: Sequence['outputs.GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryDbServersHistoryDetailDbServerPatchingDetailResult'],
                 display_name: str,
                 id: str):
        """
        :param Sequence['GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryDbServersHistoryDetailDbServerPatchingDetailArgs'] db_server_patching_details: The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        :param str display_name: The user-friendly name for the maintenance run.
        :param str id: The OCID of the maintenance run.
        """
        GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryDbServersHistoryDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_server_patching_details=db_server_patching_details,
            display_name=display_name,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_server_patching_details: Sequence['outputs.GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryDbServersHistoryDetailDbServerPatchingDetailResult'],
             display_name: str,
             id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("db_server_patching_details", db_server_patching_details)
        _setter("display_name", display_name)
        _setter("id", id)

    @property
    @pulumi.getter(name="dbServerPatchingDetails")
    def db_server_patching_details(self) -> Sequence['outputs.GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryDbServersHistoryDetailDbServerPatchingDetailResult']:
        """
        The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        """
        return pulumi.get(self, "db_server_patching_details")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The user-friendly name for the maintenance run.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the maintenance run.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryDbServersHistoryDetailDbServerPatchingDetailResult(dict):
    def __init__(__self__, *,
                 estimated_patch_duration: int,
                 patching_status: str,
                 time_patching_ended: str,
                 time_patching_started: str):
        """
        :param int estimated_patch_duration: Estimated time, in minutes, to patch one database server.
        :param str patching_status: The status of the patching operation.
        :param str time_patching_ended: The time when the patching operation ended.
        :param str time_patching_started: The time when the patching operation started.
        """
        GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryDbServersHistoryDetailDbServerPatchingDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            estimated_patch_duration=estimated_patch_duration,
            patching_status=patching_status,
            time_patching_ended=time_patching_ended,
            time_patching_started=time_patching_started,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             estimated_patch_duration: int,
             patching_status: str,
             time_patching_ended: str,
             time_patching_started: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("estimated_patch_duration", estimated_patch_duration)
        _setter("patching_status", patching_status)
        _setter("time_patching_ended", time_patching_ended)
        _setter("time_patching_started", time_patching_started)

    @property
    @pulumi.getter(name="estimatedPatchDuration")
    def estimated_patch_duration(self) -> int:
        """
        Estimated time, in minutes, to patch one database server.
        """
        return pulumi.get(self, "estimated_patch_duration")

    @property
    @pulumi.getter(name="patchingStatus")
    def patching_status(self) -> str:
        """
        The status of the patching operation.
        """
        return pulumi.get(self, "patching_status")

    @property
    @pulumi.getter(name="timePatchingEnded")
    def time_patching_ended(self) -> str:
        """
        The time when the patching operation ended.
        """
        return pulumi.get(self, "time_patching_ended")

    @property
    @pulumi.getter(name="timePatchingStarted")
    def time_patching_started(self) -> str:
        """
        The time when the patching operation started.
        """
        return pulumi.get(self, "time_patching_started")


@pulumi.output_type
class GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryMaintenanceRunDetailResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 current_custom_action_timeout_in_mins: int,
                 current_patching_component: str,
                 custom_action_timeout_in_mins: int,
                 description: str,
                 display_name: str,
                 estimated_component_patching_start_time: str,
                 estimated_patching_times: Sequence['outputs.GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryMaintenanceRunDetailEstimatedPatchingTimeResult'],
                 id: str,
                 is_custom_action_timeout_enabled: bool,
                 lifecycle_details: str,
                 maintenance_subtype: str,
                 maintenance_type: str,
                 patch_failure_count: int,
                 patch_id: str,
                 patching_end_time: str,
                 patching_mode: str,
                 patching_start_time: str,
                 patching_status: str,
                 peer_maintenance_run_id: str,
                 state: str,
                 target_db_server_version: str,
                 target_resource_id: str,
                 target_resource_type: str,
                 target_storage_server_version: str,
                 time_ended: str,
                 time_scheduled: str,
                 time_started: str):
        """
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param int current_custom_action_timeout_in_mins: Extend current custom action timeout between the current database servers during waiting state, from 0 (zero) to 30 minutes.
        :param str current_patching_component: The name of the current infrastruture component that is getting patched.
        :param int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Specify a number of minutes, from 15 to 120.
        :param str description: Description of the maintenance run.
        :param str display_name: The user-friendly name for the maintenance run.
        :param str estimated_component_patching_start_time: The estimated start time of the next infrastruture component patching operation.
        :param Sequence['GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryMaintenanceRunDetailEstimatedPatchingTimeArgs'] estimated_patching_times: The estimated total time required in minutes for all patching operations (database server, storage server, and network switch patching).
        :param str id: The OCID of the maintenance run.
        :param bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database servers patching operations.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str maintenance_subtype: Maintenance sub-type.
        :param str maintenance_type: The maintenance type.
        :param int patch_failure_count: Contain the patch failure count.
        :param str patch_id: The unique identifier of the patch. The identifier string includes the patch type, the Oracle Database version, and the patch creation date (using the format YYMMDD). For example, the identifier `ru_patch_19.9.0.0_201030` is used for an RU patch for Oracle Database 19.9.0.0 that was released October 30, 2020.
        :param str patching_end_time: The time when the patching operation ended.
        :param str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param str patching_start_time: The time when the patching operation started.
        :param str patching_status: The status of the patching operation.
        :param str peer_maintenance_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance run for the Autonomous Data Guard association's peer container database.
        :param str state: The state of the maintenance run history.
        :param str target_db_server_version: The target software version for the database server patching operation.
        :param str target_resource_id: The target resource ID.
        :param str target_resource_type: The type of the target resource.
        :param str target_storage_server_version: The target Cell version that is to be patched to.
        :param str time_ended: The date and time the maintenance run was completed.
        :param str time_scheduled: The date and time the maintenance run is scheduled to occur.
        :param str time_started: The date and time the maintenance run starts.
        """
        GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryMaintenanceRunDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            current_custom_action_timeout_in_mins=current_custom_action_timeout_in_mins,
            current_patching_component=current_patching_component,
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            description=description,
            display_name=display_name,
            estimated_component_patching_start_time=estimated_component_patching_start_time,
            estimated_patching_times=estimated_patching_times,
            id=id,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            lifecycle_details=lifecycle_details,
            maintenance_subtype=maintenance_subtype,
            maintenance_type=maintenance_type,
            patch_failure_count=patch_failure_count,
            patch_id=patch_id,
            patching_end_time=patching_end_time,
            patching_mode=patching_mode,
            patching_start_time=patching_start_time,
            patching_status=patching_status,
            peer_maintenance_run_id=peer_maintenance_run_id,
            state=state,
            target_db_server_version=target_db_server_version,
            target_resource_id=target_resource_id,
            target_resource_type=target_resource_type,
            target_storage_server_version=target_storage_server_version,
            time_ended=time_ended,
            time_scheduled=time_scheduled,
            time_started=time_started,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             current_custom_action_timeout_in_mins: int,
             current_patching_component: str,
             custom_action_timeout_in_mins: int,
             description: str,
             display_name: str,
             estimated_component_patching_start_time: str,
             estimated_patching_times: Sequence['outputs.GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryMaintenanceRunDetailEstimatedPatchingTimeResult'],
             id: str,
             is_custom_action_timeout_enabled: bool,
             lifecycle_details: str,
             maintenance_subtype: str,
             maintenance_type: str,
             patch_failure_count: int,
             patch_id: str,
             patching_end_time: str,
             patching_mode: str,
             patching_start_time: str,
             patching_status: str,
             peer_maintenance_run_id: str,
             state: str,
             target_db_server_version: str,
             target_resource_id: str,
             target_resource_type: str,
             target_storage_server_version: str,
             time_ended: str,
             time_scheduled: str,
             time_started: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("compartment_id", compartment_id)
        _setter("current_custom_action_timeout_in_mins", current_custom_action_timeout_in_mins)
        _setter("current_patching_component", current_patching_component)
        _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("estimated_component_patching_start_time", estimated_component_patching_start_time)
        _setter("estimated_patching_times", estimated_patching_times)
        _setter("id", id)
        _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        _setter("lifecycle_details", lifecycle_details)
        _setter("maintenance_subtype", maintenance_subtype)
        _setter("maintenance_type", maintenance_type)
        _setter("patch_failure_count", patch_failure_count)
        _setter("patch_id", patch_id)
        _setter("patching_end_time", patching_end_time)
        _setter("patching_mode", patching_mode)
        _setter("patching_start_time", patching_start_time)
        _setter("patching_status", patching_status)
        _setter("peer_maintenance_run_id", peer_maintenance_run_id)
        _setter("state", state)
        _setter("target_db_server_version", target_db_server_version)
        _setter("target_resource_id", target_resource_id)
        _setter("target_resource_type", target_resource_type)
        _setter("target_storage_server_version", target_storage_server_version)
        _setter("time_ended", time_ended)
        _setter("time_scheduled", time_scheduled)
        _setter("time_started", time_started)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="currentCustomActionTimeoutInMins")
    def current_custom_action_timeout_in_mins(self) -> int:
        """
        Extend current custom action timeout between the current database servers during waiting state, from 0 (zero) to 30 minutes.
        """
        return pulumi.get(self, "current_custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="currentPatchingComponent")
    def current_patching_component(self) -> str:
        """
        The name of the current infrastruture component that is getting patched.
        """
        return pulumi.get(self, "current_patching_component")

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Specify a number of minutes, from 15 to 120.
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of the maintenance run.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The user-friendly name for the maintenance run.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="estimatedComponentPatchingStartTime")
    def estimated_component_patching_start_time(self) -> str:
        """
        The estimated start time of the next infrastruture component patching operation.
        """
        return pulumi.get(self, "estimated_component_patching_start_time")

    @property
    @pulumi.getter(name="estimatedPatchingTimes")
    def estimated_patching_times(self) -> Sequence['outputs.GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryMaintenanceRunDetailEstimatedPatchingTimeResult']:
        """
        The estimated total time required in minutes for all patching operations (database server, storage server, and network switch patching).
        """
        return pulumi.get(self, "estimated_patching_times")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the maintenance run.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database servers patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="maintenanceSubtype")
    def maintenance_subtype(self) -> str:
        """
        Maintenance sub-type.
        """
        return pulumi.get(self, "maintenance_subtype")

    @property
    @pulumi.getter(name="maintenanceType")
    def maintenance_type(self) -> str:
        """
        The maintenance type.
        """
        return pulumi.get(self, "maintenance_type")

    @property
    @pulumi.getter(name="patchFailureCount")
    def patch_failure_count(self) -> int:
        """
        Contain the patch failure count.
        """
        return pulumi.get(self, "patch_failure_count")

    @property
    @pulumi.getter(name="patchId")
    def patch_id(self) -> str:
        """
        The unique identifier of the patch. The identifier string includes the patch type, the Oracle Database version, and the patch creation date (using the format YYMMDD). For example, the identifier `ru_patch_19.9.0.0_201030` is used for an RU patch for Oracle Database 19.9.0.0 that was released October 30, 2020.
        """
        return pulumi.get(self, "patch_id")

    @property
    @pulumi.getter(name="patchingEndTime")
    def patching_end_time(self) -> str:
        """
        The time when the patching operation ended.
        """
        return pulumi.get(self, "patching_end_time")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter(name="patchingStartTime")
    def patching_start_time(self) -> str:
        """
        The time when the patching operation started.
        """
        return pulumi.get(self, "patching_start_time")

    @property
    @pulumi.getter(name="patchingStatus")
    def patching_status(self) -> str:
        """
        The status of the patching operation.
        """
        return pulumi.get(self, "patching_status")

    @property
    @pulumi.getter(name="peerMaintenanceRunId")
    def peer_maintenance_run_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance run for the Autonomous Data Guard association's peer container database.
        """
        return pulumi.get(self, "peer_maintenance_run_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the maintenance run history.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="targetDbServerVersion")
    def target_db_server_version(self) -> str:
        """
        The target software version for the database server patching operation.
        """
        return pulumi.get(self, "target_db_server_version")

    @property
    @pulumi.getter(name="targetResourceId")
    def target_resource_id(self) -> str:
        """
        The target resource ID.
        """
        return pulumi.get(self, "target_resource_id")

    @property
    @pulumi.getter(name="targetResourceType")
    def target_resource_type(self) -> str:
        """
        The type of the target resource.
        """
        return pulumi.get(self, "target_resource_type")

    @property
    @pulumi.getter(name="targetStorageServerVersion")
    def target_storage_server_version(self) -> str:
        """
        The target Cell version that is to be patched to.
        """
        return pulumi.get(self, "target_storage_server_version")

    @property
    @pulumi.getter(name="timeEnded")
    def time_ended(self) -> str:
        """
        The date and time the maintenance run was completed.
        """
        return pulumi.get(self, "time_ended")

    @property
    @pulumi.getter(name="timeScheduled")
    def time_scheduled(self) -> str:
        """
        The date and time the maintenance run is scheduled to occur.
        """
        return pulumi.get(self, "time_scheduled")

    @property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> str:
        """
        The date and time the maintenance run starts.
        """
        return pulumi.get(self, "time_started")


@pulumi.output_type
class GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryMaintenanceRunDetailEstimatedPatchingTimeResult(dict):
    def __init__(__self__, *,
                 estimated_db_server_patching_time: int,
                 estimated_network_switches_patching_time: int,
                 estimated_storage_server_patching_time: int,
                 total_estimated_patching_time: int):
        """
        :param int estimated_db_server_patching_time: The estimated time required in minutes for database server patching.
        :param int estimated_network_switches_patching_time: The estimated time required in minutes for network switch patching.
        :param int estimated_storage_server_patching_time: The estimated time required in minutes for storage server patching.
        :param int total_estimated_patching_time: The estimated total time required in minutes for all patching operations.
        """
        GetDatabaseMaintenanceRunHistoriesMaintenanceRunHistoryMaintenanceRunDetailEstimatedPatchingTimeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            estimated_db_server_patching_time=estimated_db_server_patching_time,
            estimated_network_switches_patching_time=estimated_network_switches_patching_time,
            estimated_storage_server_patching_time=estimated_storage_server_patching_time,
            total_estimated_patching_time=total_estimated_patching_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             estimated_db_server_patching_time: int,
             estimated_network_switches_patching_time: int,
             estimated_storage_server_patching_time: int,
             total_estimated_patching_time: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("estimated_db_server_patching_time", estimated_db_server_patching_time)
        _setter("estimated_network_switches_patching_time", estimated_network_switches_patching_time)
        _setter("estimated_storage_server_patching_time", estimated_storage_server_patching_time)
        _setter("total_estimated_patching_time", total_estimated_patching_time)

    @property
    @pulumi.getter(name="estimatedDbServerPatchingTime")
    def estimated_db_server_patching_time(self) -> int:
        """
        The estimated time required in minutes for database server patching.
        """
        return pulumi.get(self, "estimated_db_server_patching_time")

    @property
    @pulumi.getter(name="estimatedNetworkSwitchesPatchingTime")
    def estimated_network_switches_patching_time(self) -> int:
        """
        The estimated time required in minutes for network switch patching.
        """
        return pulumi.get(self, "estimated_network_switches_patching_time")

    @property
    @pulumi.getter(name="estimatedStorageServerPatchingTime")
    def estimated_storage_server_patching_time(self) -> int:
        """
        The estimated time required in minutes for storage server patching.
        """
        return pulumi.get(self, "estimated_storage_server_patching_time")

    @property
    @pulumi.getter(name="totalEstimatedPatchingTime")
    def total_estimated_patching_time(self) -> int:
        """
        The estimated total time required in minutes for all patching operations.
        """
        return pulumi.get(self, "total_estimated_patching_time")


@pulumi.output_type
class GetDatabaseMaintenanceRunHistoryDbServersHistoryDetailResult(dict):
    def __init__(__self__, *,
                 db_server_patching_details: Sequence['outputs.GetDatabaseMaintenanceRunHistoryDbServersHistoryDetailDbServerPatchingDetailResult'],
                 display_name: str,
                 id: str):
        """
        :param Sequence['GetDatabaseMaintenanceRunHistoryDbServersHistoryDetailDbServerPatchingDetailArgs'] db_server_patching_details: The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        :param str display_name: The user-friendly name for the maintenance run.
        :param str id: The OCID of the maintenance run.
        """
        GetDatabaseMaintenanceRunHistoryDbServersHistoryDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_server_patching_details=db_server_patching_details,
            display_name=display_name,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_server_patching_details: Sequence['outputs.GetDatabaseMaintenanceRunHistoryDbServersHistoryDetailDbServerPatchingDetailResult'],
             display_name: str,
             id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("db_server_patching_details", db_server_patching_details)
        _setter("display_name", display_name)
        _setter("id", id)

    @property
    @pulumi.getter(name="dbServerPatchingDetails")
    def db_server_patching_details(self) -> Sequence['outputs.GetDatabaseMaintenanceRunHistoryDbServersHistoryDetailDbServerPatchingDetailResult']:
        """
        The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        """
        return pulumi.get(self, "db_server_patching_details")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The user-friendly name for the maintenance run.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the maintenance run.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetDatabaseMaintenanceRunHistoryDbServersHistoryDetailDbServerPatchingDetailResult(dict):
    def __init__(__self__, *,
                 estimated_patch_duration: int,
                 patching_status: str,
                 time_patching_ended: str,
                 time_patching_started: str):
        """
        :param int estimated_patch_duration: Estimated time, in minutes, to patch one database server.
        :param str patching_status: The status of the patching operation.
        :param str time_patching_ended: The time when the patching operation ended.
        :param str time_patching_started: The time when the patching operation started.
        """
        GetDatabaseMaintenanceRunHistoryDbServersHistoryDetailDbServerPatchingDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            estimated_patch_duration=estimated_patch_duration,
            patching_status=patching_status,
            time_patching_ended=time_patching_ended,
            time_patching_started=time_patching_started,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             estimated_patch_duration: int,
             patching_status: str,
             time_patching_ended: str,
             time_patching_started: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("estimated_patch_duration", estimated_patch_duration)
        _setter("patching_status", patching_status)
        _setter("time_patching_ended", time_patching_ended)
        _setter("time_patching_started", time_patching_started)

    @property
    @pulumi.getter(name="estimatedPatchDuration")
    def estimated_patch_duration(self) -> int:
        """
        Estimated time, in minutes, to patch one database server.
        """
        return pulumi.get(self, "estimated_patch_duration")

    @property
    @pulumi.getter(name="patchingStatus")
    def patching_status(self) -> str:
        """
        The status of the patching operation.
        """
        return pulumi.get(self, "patching_status")

    @property
    @pulumi.getter(name="timePatchingEnded")
    def time_patching_ended(self) -> str:
        """
        The time when the patching operation ended.
        """
        return pulumi.get(self, "time_patching_ended")

    @property
    @pulumi.getter(name="timePatchingStarted")
    def time_patching_started(self) -> str:
        """
        The time when the patching operation started.
        """
        return pulumi.get(self, "time_patching_started")


@pulumi.output_type
class GetDatabaseMaintenanceRunHistoryMaintenanceRunDetailResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 current_custom_action_timeout_in_mins: int,
                 current_patching_component: str,
                 custom_action_timeout_in_mins: int,
                 description: str,
                 display_name: str,
                 estimated_component_patching_start_time: str,
                 estimated_patching_times: Sequence['outputs.GetDatabaseMaintenanceRunHistoryMaintenanceRunDetailEstimatedPatchingTimeResult'],
                 id: str,
                 is_custom_action_timeout_enabled: bool,
                 lifecycle_details: str,
                 maintenance_subtype: str,
                 maintenance_type: str,
                 patch_failure_count: int,
                 patch_id: str,
                 patching_end_time: str,
                 patching_mode: str,
                 patching_start_time: str,
                 patching_status: str,
                 peer_maintenance_run_id: str,
                 state: str,
                 target_db_server_version: str,
                 target_resource_id: str,
                 target_resource_type: str,
                 target_storage_server_version: str,
                 time_ended: str,
                 time_scheduled: str,
                 time_started: str):
        """
        :param str compartment_id: The OCID of the compartment.
        :param int current_custom_action_timeout_in_mins: Extend current custom action timeout between the current database servers during waiting state, from 0 (zero) to 30 minutes.
        :param str current_patching_component: The name of the current infrastruture component that is getting patched.
        :param int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Specify a number of minutes, from 15 to 120.
        :param str description: Description of the maintenance run.
        :param str display_name: The user-friendly name for the maintenance run.
        :param str estimated_component_patching_start_time: The estimated start time of the next infrastruture component patching operation.
        :param Sequence['GetDatabaseMaintenanceRunHistoryMaintenanceRunDetailEstimatedPatchingTimeArgs'] estimated_patching_times: The estimated total time required in minutes for all patching operations (database server, storage server, and network switch patching).
        :param str id: The OCID of the maintenance run.
        :param bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database servers patching operations.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str maintenance_subtype: Maintenance sub-type.
        :param str maintenance_type: Maintenance type.
        :param int patch_failure_count: Contain the patch failure count.
        :param str patch_id: The unique identifier of the patch. The identifier string includes the patch type, the Oracle Database version, and the patch creation date (using the format YYMMDD). For example, the identifier `ru_patch_19.9.0.0_201030` is used for an RU patch for Oracle Database 19.9.0.0 that was released October 30, 2020.
        :param str patching_end_time: The time when the patching operation ended.
        :param str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param str patching_start_time: The time when the patching operation started.
        :param str patching_status: The status of the patching operation.
        :param str peer_maintenance_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance run for the Autonomous Data Guard association's peer container database.
        :param str state: The current state of the maintenance run. For Autonomous Database Serverless instances, valid states are IN_PROGRESS, SUCCEEDED, and FAILED.
        :param str target_db_server_version: The target software version for the database server patching operation.
        :param str target_resource_id: The ID of the target resource on which the maintenance run occurs.
        :param str target_resource_type: The type of the target resource on which the maintenance run occurs.
        :param str target_storage_server_version: The target Cell version that is to be patched to.
        :param str time_ended: The date and time the maintenance run was completed.
        :param str time_scheduled: The date and time the maintenance run is scheduled to occur.
        :param str time_started: The date and time the maintenance run starts.
        """
        GetDatabaseMaintenanceRunHistoryMaintenanceRunDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            current_custom_action_timeout_in_mins=current_custom_action_timeout_in_mins,
            current_patching_component=current_patching_component,
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            description=description,
            display_name=display_name,
            estimated_component_patching_start_time=estimated_component_patching_start_time,
            estimated_patching_times=estimated_patching_times,
            id=id,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            lifecycle_details=lifecycle_details,
            maintenance_subtype=maintenance_subtype,
            maintenance_type=maintenance_type,
            patch_failure_count=patch_failure_count,
            patch_id=patch_id,
            patching_end_time=patching_end_time,
            patching_mode=patching_mode,
            patching_start_time=patching_start_time,
            patching_status=patching_status,
            peer_maintenance_run_id=peer_maintenance_run_id,
            state=state,
            target_db_server_version=target_db_server_version,
            target_resource_id=target_resource_id,
            target_resource_type=target_resource_type,
            target_storage_server_version=target_storage_server_version,
            time_ended=time_ended,
            time_scheduled=time_scheduled,
            time_started=time_started,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             current_custom_action_timeout_in_mins: int,
             current_patching_component: str,
             custom_action_timeout_in_mins: int,
             description: str,
             display_name: str,
             estimated_component_patching_start_time: str,
             estimated_patching_times: Sequence['outputs.GetDatabaseMaintenanceRunHistoryMaintenanceRunDetailEstimatedPatchingTimeResult'],
             id: str,
             is_custom_action_timeout_enabled: bool,
             lifecycle_details: str,
             maintenance_subtype: str,
             maintenance_type: str,
             patch_failure_count: int,
             patch_id: str,
             patching_end_time: str,
             patching_mode: str,
             patching_start_time: str,
             patching_status: str,
             peer_maintenance_run_id: str,
             state: str,
             target_db_server_version: str,
             target_resource_id: str,
             target_resource_type: str,
             target_storage_server_version: str,
             time_ended: str,
             time_scheduled: str,
             time_started: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("compartment_id", compartment_id)
        _setter("current_custom_action_timeout_in_mins", current_custom_action_timeout_in_mins)
        _setter("current_patching_component", current_patching_component)
        _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("estimated_component_patching_start_time", estimated_component_patching_start_time)
        _setter("estimated_patching_times", estimated_patching_times)
        _setter("id", id)
        _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        _setter("lifecycle_details", lifecycle_details)
        _setter("maintenance_subtype", maintenance_subtype)
        _setter("maintenance_type", maintenance_type)
        _setter("patch_failure_count", patch_failure_count)
        _setter("patch_id", patch_id)
        _setter("patching_end_time", patching_end_time)
        _setter("patching_mode", patching_mode)
        _setter("patching_start_time", patching_start_time)
        _setter("patching_status", patching_status)
        _setter("peer_maintenance_run_id", peer_maintenance_run_id)
        _setter("state", state)
        _setter("target_db_server_version", target_db_server_version)
        _setter("target_resource_id", target_resource_id)
        _setter("target_resource_type", target_resource_type)
        _setter("target_storage_server_version", target_storage_server_version)
        _setter("time_ended", time_ended)
        _setter("time_scheduled", time_scheduled)
        _setter("time_started", time_started)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The OCID of the compartment.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="currentCustomActionTimeoutInMins")
    def current_custom_action_timeout_in_mins(self) -> int:
        """
        Extend current custom action timeout between the current database servers during waiting state, from 0 (zero) to 30 minutes.
        """
        return pulumi.get(self, "current_custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="currentPatchingComponent")
    def current_patching_component(self) -> str:
        """
        The name of the current infrastruture component that is getting patched.
        """
        return pulumi.get(self, "current_patching_component")

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Specify a number of minutes, from 15 to 120.
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of the maintenance run.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The user-friendly name for the maintenance run.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="estimatedComponentPatchingStartTime")
    def estimated_component_patching_start_time(self) -> str:
        """
        The estimated start time of the next infrastruture component patching operation.
        """
        return pulumi.get(self, "estimated_component_patching_start_time")

    @property
    @pulumi.getter(name="estimatedPatchingTimes")
    def estimated_patching_times(self) -> Sequence['outputs.GetDatabaseMaintenanceRunHistoryMaintenanceRunDetailEstimatedPatchingTimeResult']:
        """
        The estimated total time required in minutes for all patching operations (database server, storage server, and network switch patching).
        """
        return pulumi.get(self, "estimated_patching_times")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the maintenance run.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database servers patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="maintenanceSubtype")
    def maintenance_subtype(self) -> str:
        """
        Maintenance sub-type.
        """
        return pulumi.get(self, "maintenance_subtype")

    @property
    @pulumi.getter(name="maintenanceType")
    def maintenance_type(self) -> str:
        """
        Maintenance type.
        """
        return pulumi.get(self, "maintenance_type")

    @property
    @pulumi.getter(name="patchFailureCount")
    def patch_failure_count(self) -> int:
        """
        Contain the patch failure count.
        """
        return pulumi.get(self, "patch_failure_count")

    @property
    @pulumi.getter(name="patchId")
    def patch_id(self) -> str:
        """
        The unique identifier of the patch. The identifier string includes the patch type, the Oracle Database version, and the patch creation date (using the format YYMMDD). For example, the identifier `ru_patch_19.9.0.0_201030` is used for an RU patch for Oracle Database 19.9.0.0 that was released October 30, 2020.
        """
        return pulumi.get(self, "patch_id")

    @property
    @pulumi.getter(name="patchingEndTime")
    def patching_end_time(self) -> str:
        """
        The time when the patching operation ended.
        """
        return pulumi.get(self, "patching_end_time")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter(name="patchingStartTime")
    def patching_start_time(self) -> str:
        """
        The time when the patching operation started.
        """
        return pulumi.get(self, "patching_start_time")

    @property
    @pulumi.getter(name="patchingStatus")
    def patching_status(self) -> str:
        """
        The status of the patching operation.
        """
        return pulumi.get(self, "patching_status")

    @property
    @pulumi.getter(name="peerMaintenanceRunId")
    def peer_maintenance_run_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance run for the Autonomous Data Guard association's peer container database.
        """
        return pulumi.get(self, "peer_maintenance_run_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the maintenance run. For Autonomous Database Serverless instances, valid states are IN_PROGRESS, SUCCEEDED, and FAILED.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="targetDbServerVersion")
    def target_db_server_version(self) -> str:
        """
        The target software version for the database server patching operation.
        """
        return pulumi.get(self, "target_db_server_version")

    @property
    @pulumi.getter(name="targetResourceId")
    def target_resource_id(self) -> str:
        """
        The ID of the target resource on which the maintenance run occurs.
        """
        return pulumi.get(self, "target_resource_id")

    @property
    @pulumi.getter(name="targetResourceType")
    def target_resource_type(self) -> str:
        """
        The type of the target resource on which the maintenance run occurs.
        """
        return pulumi.get(self, "target_resource_type")

    @property
    @pulumi.getter(name="targetStorageServerVersion")
    def target_storage_server_version(self) -> str:
        """
        The target Cell version that is to be patched to.
        """
        return pulumi.get(self, "target_storage_server_version")

    @property
    @pulumi.getter(name="timeEnded")
    def time_ended(self) -> str:
        """
        The date and time the maintenance run was completed.
        """
        return pulumi.get(self, "time_ended")

    @property
    @pulumi.getter(name="timeScheduled")
    def time_scheduled(self) -> str:
        """
        The date and time the maintenance run is scheduled to occur.
        """
        return pulumi.get(self, "time_scheduled")

    @property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> str:
        """
        The date and time the maintenance run starts.
        """
        return pulumi.get(self, "time_started")


@pulumi.output_type
class GetDatabaseMaintenanceRunHistoryMaintenanceRunDetailEstimatedPatchingTimeResult(dict):
    def __init__(__self__, *,
                 estimated_db_server_patching_time: int,
                 estimated_network_switches_patching_time: int,
                 estimated_storage_server_patching_time: int,
                 total_estimated_patching_time: int):
        """
        :param int estimated_db_server_patching_time: The estimated time required in minutes for database server patching.
        :param int estimated_network_switches_patching_time: The estimated time required in minutes for network switch patching.
        :param int estimated_storage_server_patching_time: The estimated time required in minutes for storage server patching.
        :param int total_estimated_patching_time: The estimated total time required in minutes for all patching operations.
        """
        GetDatabaseMaintenanceRunHistoryMaintenanceRunDetailEstimatedPatchingTimeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            estimated_db_server_patching_time=estimated_db_server_patching_time,
            estimated_network_switches_patching_time=estimated_network_switches_patching_time,
            estimated_storage_server_patching_time=estimated_storage_server_patching_time,
            total_estimated_patching_time=total_estimated_patching_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             estimated_db_server_patching_time: int,
             estimated_network_switches_patching_time: int,
             estimated_storage_server_patching_time: int,
             total_estimated_patching_time: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("estimated_db_server_patching_time", estimated_db_server_patching_time)
        _setter("estimated_network_switches_patching_time", estimated_network_switches_patching_time)
        _setter("estimated_storage_server_patching_time", estimated_storage_server_patching_time)
        _setter("total_estimated_patching_time", total_estimated_patching_time)

    @property
    @pulumi.getter(name="estimatedDbServerPatchingTime")
    def estimated_db_server_patching_time(self) -> int:
        """
        The estimated time required in minutes for database server patching.
        """
        return pulumi.get(self, "estimated_db_server_patching_time")

    @property
    @pulumi.getter(name="estimatedNetworkSwitchesPatchingTime")
    def estimated_network_switches_patching_time(self) -> int:
        """
        The estimated time required in minutes for network switch patching.
        """
        return pulumi.get(self, "estimated_network_switches_patching_time")

    @property
    @pulumi.getter(name="estimatedStorageServerPatchingTime")
    def estimated_storage_server_patching_time(self) -> int:
        """
        The estimated time required in minutes for storage server patching.
        """
        return pulumi.get(self, "estimated_storage_server_patching_time")

    @property
    @pulumi.getter(name="totalEstimatedPatchingTime")
    def total_estimated_patching_time(self) -> int:
        """
        The estimated total time required in minutes for all patching operations.
        """
        return pulumi.get(self, "total_estimated_patching_time")


@pulumi.output_type
class GetDatabasePdbConversionHistoryEntriesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDatabasePdbConversionHistoryEntriesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDatabasePdbConversionHistoryEntriesPdbConversionHistoryEntryResult(dict):
    def __init__(__self__, *,
                 action: str,
                 additional_cdb_params: str,
                 cdb_name: str,
                 id: str,
                 lifecycle_details: str,
                 source_database_id: str,
                 state: str,
                 target: str,
                 target_database_id: str,
                 time_ended: str,
                 time_started: str):
        """
        :param str action: The operations used to convert a non-container database to a pluggable database.
               * Use `PRECHECK` to run a pre-check operation on non-container database prior to converting it into a pluggable database.
               * Use `CONVERT` to convert a non-container database into a pluggable database.
               * Use `SYNC` if the non-container database was manually converted into a pluggable database using the dbcli command-line utility. Databases may need to be converted manually if the CONVERT action fails when converting a non-container database using the API.
               * Use `SYNC_ROLLBACK` if the conversion of a non-container database into a pluggable database was manually rolled back using the dbcli command line utility. Conversions may need to be manually rolled back if the CONVERT action fails when converting a non-container database using the API.
        :param str additional_cdb_params: Additional container database parameter.
        :param str cdb_name: The database name. The name must begin with an alphabetic character and can contain a maximum of 8 alphanumeric characters. Special characters are not permitted. The database name must be unique in the tenancy.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database conversion history.
        :param str lifecycle_details: Additional information about the current lifecycle state for the conversion operation.
        :param str source_database_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        :param str state: A filter to return only the pluggable database conversion history entries that match the specified lifecycle state. For example, you can use this filter to return only entries in the "failed" lifecycle state.
        :param str target: The target container database of the pluggable database created by the database conversion operation. Currently, the database conversion operation only supports creating the pluggable database in a new container database.
               * Use `NEW_DATABASE` to specify that the pluggable database be created within a new container database in the same database home.
        :param str target_database_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        :param str time_ended: The date and time when the database conversion operation ended.
        :param str time_started: The date and time when the database conversion operation started.
        """
        GetDatabasePdbConversionHistoryEntriesPdbConversionHistoryEntryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            additional_cdb_params=additional_cdb_params,
            cdb_name=cdb_name,
            id=id,
            lifecycle_details=lifecycle_details,
            source_database_id=source_database_id,
            state=state,
            target=target,
            target_database_id=target_database_id,
            time_ended=time_ended,
            time_started=time_started,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: str,
             additional_cdb_params: str,
             cdb_name: str,
             id: str,
             lifecycle_details: str,
             source_database_id: str,
             state: str,
             target: str,
             target_database_id: str,
             time_ended: str,
             time_started: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action", action)
        _setter("additional_cdb_params", additional_cdb_params)
        _setter("cdb_name", cdb_name)
        _setter("id", id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("source_database_id", source_database_id)
        _setter("state", state)
        _setter("target", target)
        _setter("target_database_id", target_database_id)
        _setter("time_ended", time_ended)
        _setter("time_started", time_started)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The operations used to convert a non-container database to a pluggable database.
        * Use `PRECHECK` to run a pre-check operation on non-container database prior to converting it into a pluggable database.
        * Use `CONVERT` to convert a non-container database into a pluggable database.
        * Use `SYNC` if the non-container database was manually converted into a pluggable database using the dbcli command-line utility. Databases may need to be converted manually if the CONVERT action fails when converting a non-container database using the API.
        * Use `SYNC_ROLLBACK` if the conversion of a non-container database into a pluggable database was manually rolled back using the dbcli command line utility. Conversions may need to be manually rolled back if the CONVERT action fails when converting a non-container database using the API.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="additionalCdbParams")
    def additional_cdb_params(self) -> str:
        """
        Additional container database parameter.
        """
        return pulumi.get(self, "additional_cdb_params")

    @property
    @pulumi.getter(name="cdbName")
    def cdb_name(self) -> str:
        """
        The database name. The name must begin with an alphabetic character and can contain a maximum of 8 alphanumeric characters. Special characters are not permitted. The database name must be unique in the tenancy.
        """
        return pulumi.get(self, "cdb_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database conversion history.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state for the conversion operation.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="sourceDatabaseId")
    def source_database_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        """
        return pulumi.get(self, "source_database_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only the pluggable database conversion history entries that match the specified lifecycle state. For example, you can use this filter to return only entries in the "failed" lifecycle state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        The target container database of the pluggable database created by the database conversion operation. Currently, the database conversion operation only supports creating the pluggable database in a new container database.
        * Use `NEW_DATABASE` to specify that the pluggable database be created within a new container database in the same database home.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="targetDatabaseId")
    def target_database_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        """
        return pulumi.get(self, "target_database_id")

    @property
    @pulumi.getter(name="timeEnded")
    def time_ended(self) -> str:
        """
        The date and time when the database conversion operation ended.
        """
        return pulumi.get(self, "time_ended")

    @property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> str:
        """
        The date and time when the database conversion operation started.
        """
        return pulumi.get(self, "time_started")


@pulumi.output_type
class GetDatabaseSoftwareImagesDatabaseSoftwareImageResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 database_software_image_included_patches: Sequence[str],
                 database_software_image_one_off_patches: Sequence[str],
                 database_version: str,
                 defined_tags: Mapping[str, Any],
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 image_shape_family: str,
                 image_type: str,
                 included_patches_summary: str,
                 is_upgrade_supported: bool,
                 lifecycle_details: str,
                 ls_inventory: str,
                 patch_set: str,
                 source_db_home_id: str,
                 state: str,
                 time_created: str):
        """
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Sequence[str] database_software_image_included_patches: List of one-off patches for Database Homes.
        :param Sequence[str] database_software_image_one_off_patches: List of one-off patches for Database Homes.
        :param str database_version: The database version with which the database software image is to be built.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database software image.
        :param str image_shape_family: A filter to return only resources that match the given image shape family exactly.
        :param str image_type: A filter to return only resources that match the given image type exactly.
        :param str included_patches_summary: The patches included in the image and the version of the image.
        :param bool is_upgrade_supported: If provided, filters the results to the set of database versions which are supported for Upgrade.
        :param str lifecycle_details: Detailed message for the lifecycle state.
        :param str ls_inventory: The output from the OPatch lsInventory command, which is passed as a string.
        :param str patch_set: The PSU or PBP or Release Updates. To get a list of supported versions, use the [ListDbVersions](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/DbVersionSummary/ListDbVersions) operation.
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        :param str time_created: The date and time the database software image was created.
        """
        GetDatabaseSoftwareImagesDatabaseSoftwareImageResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            database_software_image_included_patches=database_software_image_included_patches,
            database_software_image_one_off_patches=database_software_image_one_off_patches,
            database_version=database_version,
            defined_tags=defined_tags,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            image_shape_family=image_shape_family,
            image_type=image_type,
            included_patches_summary=included_patches_summary,
            is_upgrade_supported=is_upgrade_supported,
            lifecycle_details=lifecycle_details,
            ls_inventory=ls_inventory,
            patch_set=patch_set,
            source_db_home_id=source_db_home_id,
            state=state,
            time_created=time_created,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             database_software_image_included_patches: Sequence[str],
             database_software_image_one_off_patches: Sequence[str],
             database_version: str,
             defined_tags: Mapping[str, Any],
             display_name: str,
             freeform_tags: Mapping[str, Any],
             id: str,
             image_shape_family: str,
             image_type: str,
             included_patches_summary: str,
             is_upgrade_supported: bool,
             lifecycle_details: str,
             ls_inventory: str,
             patch_set: str,
             source_db_home_id: str,
             state: str,
             time_created: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("compartment_id", compartment_id)
        _setter("database_software_image_included_patches", database_software_image_included_patches)
        _setter("database_software_image_one_off_patches", database_software_image_one_off_patches)
        _setter("database_version", database_version)
        _setter("defined_tags", defined_tags)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("image_shape_family", image_shape_family)
        _setter("image_type", image_type)
        _setter("included_patches_summary", included_patches_summary)
        _setter("is_upgrade_supported", is_upgrade_supported)
        _setter("lifecycle_details", lifecycle_details)
        _setter("ls_inventory", ls_inventory)
        _setter("patch_set", patch_set)
        _setter("source_db_home_id", source_db_home_id)
        _setter("state", state)
        _setter("time_created", time_created)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="databaseSoftwareImageIncludedPatches")
    def database_software_image_included_patches(self) -> Sequence[str]:
        """
        List of one-off patches for Database Homes.
        """
        return pulumi.get(self, "database_software_image_included_patches")

    @property
    @pulumi.getter(name="databaseSoftwareImageOneOffPatches")
    def database_software_image_one_off_patches(self) -> Sequence[str]:
        """
        List of one-off patches for Database Homes.
        """
        return pulumi.get(self, "database_software_image_one_off_patches")

    @property
    @pulumi.getter(name="databaseVersion")
    def database_version(self) -> str:
        """
        The database version with which the database software image is to be built.
        """
        return pulumi.get(self, "database_version")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database software image.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="imageShapeFamily")
    def image_shape_family(self) -> str:
        """
        A filter to return only resources that match the given image shape family exactly.
        """
        return pulumi.get(self, "image_shape_family")

    @property
    @pulumi.getter(name="imageType")
    def image_type(self) -> str:
        """
        A filter to return only resources that match the given image type exactly.
        """
        return pulumi.get(self, "image_type")

    @property
    @pulumi.getter(name="includedPatchesSummary")
    def included_patches_summary(self) -> str:
        """
        The patches included in the image and the version of the image.
        """
        return pulumi.get(self, "included_patches_summary")

    @property
    @pulumi.getter(name="isUpgradeSupported")
    def is_upgrade_supported(self) -> bool:
        """
        If provided, filters the results to the set of database versions which are supported for Upgrade.
        """
        return pulumi.get(self, "is_upgrade_supported")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Detailed message for the lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="lsInventory")
    def ls_inventory(self) -> str:
        """
        The output from the OPatch lsInventory command, which is passed as a string.
        """
        return pulumi.get(self, "ls_inventory")

    @property
    @pulumi.getter(name="patchSet")
    def patch_set(self) -> str:
        """
        The PSU or PBP or Release Updates. To get a list of supported versions, use the [ListDbVersions](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/DbVersionSummary/ListDbVersions) operation.
        """
        return pulumi.get(self, "patch_set")

    @property
    @pulumi.getter(name="sourceDbHomeId")
    def source_db_home_id(self) -> str:
        return pulumi.get(self, "source_db_home_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the database software image was created.
        """
        return pulumi.get(self, "time_created")


@pulumi.output_type
class GetDatabaseSoftwareImagesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDatabaseSoftwareImagesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDatabaseUpgradeHistoryEntriesDatabaseUpgradeHistoryEntryResult(dict):
    def __init__(__self__, *,
                 action: str,
                 id: str,
                 lifecycle_details: str,
                 options: str,
                 source: str,
                 source_db_home_id: str,
                 state: str,
                 target_database_software_image_id: str,
                 target_db_home_id: str,
                 target_db_version: str,
                 time_ended: str,
                 time_started: str):
        """
        :param str action: The database upgrade action.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database upgrade history.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str options: Additional upgrade options supported by DBUA(Database Upgrade Assistant). Example: "-upgradeTimezone false -keepEvents"
        :param str source: The source of the Oracle Database software to be used for the upgrade.
               * Use `DB_VERSION` to specify a generally-available Oracle Database software version to upgrade the database.
               * Use `DB_SOFTWARE_IMAGE` to specify a [database software image](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/databasesoftwareimage.htm) to upgrade the database.
        :param str source_db_home_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        :param str state: A filter to return only upgradeHistoryEntries that match the given lifecycle state exactly.
        :param str target_database_software_image_id: the database software image used for upgrading database.
        :param str target_db_home_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        :param str target_db_version: A valid Oracle Database version. For a list of supported versions, use the ListDbVersions operation.
        :param str time_ended: The date and time when the database upgrade ended.
        :param str time_started: The date and time when the database upgrade started.
        """
        GetDatabaseUpgradeHistoryEntriesDatabaseUpgradeHistoryEntryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            id=id,
            lifecycle_details=lifecycle_details,
            options=options,
            source=source,
            source_db_home_id=source_db_home_id,
            state=state,
            target_database_software_image_id=target_database_software_image_id,
            target_db_home_id=target_db_home_id,
            target_db_version=target_db_version,
            time_ended=time_ended,
            time_started=time_started,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: str,
             id: str,
             lifecycle_details: str,
             options: str,
             source: str,
             source_db_home_id: str,
             state: str,
             target_database_software_image_id: str,
             target_db_home_id: str,
             target_db_version: str,
             time_ended: str,
             time_started: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action", action)
        _setter("id", id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("options", options)
        _setter("source", source)
        _setter("source_db_home_id", source_db_home_id)
        _setter("state", state)
        _setter("target_database_software_image_id", target_database_software_image_id)
        _setter("target_db_home_id", target_db_home_id)
        _setter("target_db_version", target_db_version)
        _setter("time_ended", time_ended)
        _setter("time_started", time_started)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The database upgrade action.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database upgrade history.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def options(self) -> str:
        """
        Additional upgrade options supported by DBUA(Database Upgrade Assistant). Example: "-upgradeTimezone false -keepEvents"
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        The source of the Oracle Database software to be used for the upgrade.
        * Use `DB_VERSION` to specify a generally-available Oracle Database software version to upgrade the database.
        * Use `DB_SOFTWARE_IMAGE` to specify a [database software image](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/databasesoftwareimage.htm) to upgrade the database.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="sourceDbHomeId")
    def source_db_home_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        """
        return pulumi.get(self, "source_db_home_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only upgradeHistoryEntries that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="targetDatabaseSoftwareImageId")
    def target_database_software_image_id(self) -> str:
        """
        the database software image used for upgrading database.
        """
        return pulumi.get(self, "target_database_software_image_id")

    @property
    @pulumi.getter(name="targetDbHomeId")
    def target_db_home_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        """
        return pulumi.get(self, "target_db_home_id")

    @property
    @pulumi.getter(name="targetDbVersion")
    def target_db_version(self) -> str:
        """
        A valid Oracle Database version. For a list of supported versions, use the ListDbVersions operation.
        """
        return pulumi.get(self, "target_db_version")

    @property
    @pulumi.getter(name="timeEnded")
    def time_ended(self) -> str:
        """
        The date and time when the database upgrade ended.
        """
        return pulumi.get(self, "time_ended")

    @property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> str:
        """
        The date and time when the database upgrade started.
        """
        return pulumi.get(self, "time_started")


@pulumi.output_type
class GetDatabaseUpgradeHistoryEntriesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDatabaseUpgradeHistoryEntriesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDatabasesDatabaseResult(dict):
    def __init__(__self__, *,
                 character_set: str,
                 compartment_id: str,
                 connection_strings: Sequence['outputs.GetDatabasesDatabaseConnectionStringResult'],
                 database_management_configs: Sequence['outputs.GetDatabasesDatabaseDatabaseManagementConfigResult'],
                 database_software_image_id: str,
                 databases: Sequence['outputs.GetDatabasesDatabaseDatabaseResult'],
                 db_backup_configs: Sequence['outputs.GetDatabasesDatabaseDbBackupConfigResult'],
                 db_home_id: str,
                 db_name: str,
                 db_system_id: str,
                 db_unique_name: str,
                 db_version: str,
                 db_workload: str,
                 defined_tags: Mapping[str, Any],
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 is_cdb: bool,
                 key_store_id: str,
                 key_store_wallet_name: str,
                 kms_key_id: str,
                 kms_key_migration: bool,
                 kms_key_rotation: int,
                 kms_key_version_id: str,
                 last_backup_duration_in_seconds: int,
                 last_backup_timestamp: str,
                 last_failed_backup_timestamp: str,
                 lifecycle_details: str,
                 ncharacter_set: str,
                 pdb_name: str,
                 sid_prefix: str,
                 source: str,
                 source_database_point_in_time_recovery_timestamp: str,
                 state: str,
                 time_created: str,
                 vault_id: str,
                 vm_cluster_id: str):
        """
        :param str character_set: The character set for the database.
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Sequence['GetDatabasesDatabaseConnectionStringArgs'] connection_strings: The Connection strings used to connect to the Oracle Database.
        :param Sequence['GetDatabasesDatabaseDatabaseManagementConfigArgs'] database_management_configs: The configuration of the Database Management service.
        :param str database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        :param Sequence['GetDatabasesDatabaseDbBackupConfigArgs'] db_backup_configs: Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        :param str db_home_id: A Database Home [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm). *Note: Either `db_home_id` or `system_id` is required to make the LIST API call.
        :param str db_name: A filter to return only resources that match the entire database name given. The match is not case sensitive.
        :param str db_system_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        :param str db_unique_name: A system-generated name for the database to ensure uniqueness within an Oracle Data Guard group (a primary database and its standby databases). The unique name cannot be changed.
        :param str db_workload: **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        :param bool is_cdb: True if the database is a container database.
        :param str key_store_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        :param str key_store_wallet_name: The wallet name for Oracle Key Vault.
        :param str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        :param int last_backup_duration_in_seconds: The duration when the latest database backup created.
        :param str last_backup_timestamp: The date and time when the latest database backup was created.
        :param str last_failed_backup_timestamp: The date and time when the latest database backup failed.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str ncharacter_set: The national character set for the database.
        :param str pdb_name: The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        :param str sid_prefix: Specifies a prefix for the `Oracle SID` of the database to be created.
        :param str source_database_point_in_time_recovery_timestamp: Point in time recovery timeStamp of the source database at which cloned database system is cloned from the source database system, as described in [RFC 3339](https://tools.ietf.org/rfc/rfc3339)
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        :param str time_created: The date and time the database was created.
        :param str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        :param str vm_cluster_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VM cluster.
        """
        GetDatabasesDatabaseResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            character_set=character_set,
            compartment_id=compartment_id,
            connection_strings=connection_strings,
            database_management_configs=database_management_configs,
            database_software_image_id=database_software_image_id,
            databases=databases,
            db_backup_configs=db_backup_configs,
            db_home_id=db_home_id,
            db_name=db_name,
            db_system_id=db_system_id,
            db_unique_name=db_unique_name,
            db_version=db_version,
            db_workload=db_workload,
            defined_tags=defined_tags,
            freeform_tags=freeform_tags,
            id=id,
            is_cdb=is_cdb,
            key_store_id=key_store_id,
            key_store_wallet_name=key_store_wallet_name,
            kms_key_id=kms_key_id,
            kms_key_migration=kms_key_migration,
            kms_key_rotation=kms_key_rotation,
            kms_key_version_id=kms_key_version_id,
            last_backup_duration_in_seconds=last_backup_duration_in_seconds,
            last_backup_timestamp=last_backup_timestamp,
            last_failed_backup_timestamp=last_failed_backup_timestamp,
            lifecycle_details=lifecycle_details,
            ncharacter_set=ncharacter_set,
            pdb_name=pdb_name,
            sid_prefix=sid_prefix,
            source=source,
            source_database_point_in_time_recovery_timestamp=source_database_point_in_time_recovery_timestamp,
            state=state,
            time_created=time_created,
            vault_id=vault_id,
            vm_cluster_id=vm_cluster_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             character_set: str,
             compartment_id: str,
             connection_strings: Sequence['outputs.GetDatabasesDatabaseConnectionStringResult'],
             database_management_configs: Sequence['outputs.GetDatabasesDatabaseDatabaseManagementConfigResult'],
             database_software_image_id: str,
             databases: Sequence['outputs.GetDatabasesDatabaseDatabaseResult'],
             db_backup_configs: Sequence['outputs.GetDatabasesDatabaseDbBackupConfigResult'],
             db_home_id: str,
             db_name: str,
             db_system_id: str,
             db_unique_name: str,
             db_version: str,
             db_workload: str,
             defined_tags: Mapping[str, Any],
             freeform_tags: Mapping[str, Any],
             id: str,
             is_cdb: bool,
             key_store_id: str,
             key_store_wallet_name: str,
             kms_key_id: str,
             kms_key_migration: bool,
             kms_key_rotation: int,
             kms_key_version_id: str,
             last_backup_duration_in_seconds: int,
             last_backup_timestamp: str,
             last_failed_backup_timestamp: str,
             lifecycle_details: str,
             ncharacter_set: str,
             pdb_name: str,
             sid_prefix: str,
             source: str,
             source_database_point_in_time_recovery_timestamp: str,
             state: str,
             time_created: str,
             vault_id: str,
             vm_cluster_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("character_set", character_set)
        _setter("compartment_id", compartment_id)
        _setter("connection_strings", connection_strings)
        _setter("database_management_configs", database_management_configs)
        _setter("database_software_image_id", database_software_image_id)
        _setter("databases", databases)
        _setter("db_backup_configs", db_backup_configs)
        _setter("db_home_id", db_home_id)
        _setter("db_name", db_name)
        _setter("db_system_id", db_system_id)
        _setter("db_unique_name", db_unique_name)
        _setter("db_version", db_version)
        _setter("db_workload", db_workload)
        _setter("defined_tags", defined_tags)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("is_cdb", is_cdb)
        _setter("key_store_id", key_store_id)
        _setter("key_store_wallet_name", key_store_wallet_name)
        _setter("kms_key_id", kms_key_id)
        _setter("kms_key_migration", kms_key_migration)
        _setter("kms_key_rotation", kms_key_rotation)
        _setter("kms_key_version_id", kms_key_version_id)
        _setter("last_backup_duration_in_seconds", last_backup_duration_in_seconds)
        _setter("last_backup_timestamp", last_backup_timestamp)
        _setter("last_failed_backup_timestamp", last_failed_backup_timestamp)
        _setter("lifecycle_details", lifecycle_details)
        _setter("ncharacter_set", ncharacter_set)
        _setter("pdb_name", pdb_name)
        _setter("sid_prefix", sid_prefix)
        _setter("source", source)
        _setter("source_database_point_in_time_recovery_timestamp", source_database_point_in_time_recovery_timestamp)
        _setter("state", state)
        _setter("time_created", time_created)
        _setter("vault_id", vault_id)
        _setter("vm_cluster_id", vm_cluster_id)

    @property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> str:
        """
        The character set for the database.
        """
        return pulumi.get(self, "character_set")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Sequence['outputs.GetDatabasesDatabaseConnectionStringResult']:
        """
        The Connection strings used to connect to the Oracle Database.
        """
        return pulumi.get(self, "connection_strings")

    @property
    @pulumi.getter(name="databaseManagementConfigs")
    def database_management_configs(self) -> Sequence['outputs.GetDatabasesDatabaseDatabaseManagementConfigResult']:
        """
        The configuration of the Database Management service.
        """
        return pulumi.get(self, "database_management_configs")

    @property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> str:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        return pulumi.get(self, "database_software_image_id")

    @property
    @pulumi.getter
    def databases(self) -> Sequence['outputs.GetDatabasesDatabaseDatabaseResult']:
        return pulumi.get(self, "databases")

    @property
    @pulumi.getter(name="dbBackupConfigs")
    def db_backup_configs(self) -> Sequence['outputs.GetDatabasesDatabaseDbBackupConfigResult']:
        """
        Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        """
        return pulumi.get(self, "db_backup_configs")

    @property
    @pulumi.getter(name="dbHomeId")
    def db_home_id(self) -> str:
        """
        A Database Home [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm). *Note: Either `db_home_id` or `system_id` is required to make the LIST API call.
        """
        return pulumi.get(self, "db_home_id")

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> str:
        """
        A filter to return only resources that match the entire database name given. The match is not case sensitive.
        """
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        """
        return pulumi.get(self, "db_system_id")

    @property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> str:
        """
        A system-generated name for the database to ensure uniqueness within an Oracle Data Guard group (a primary database and its standby databases). The unique name cannot be changed.
        """
        return pulumi.get(self, "db_unique_name")

    @property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> str:
        return pulumi.get(self, "db_version")

    @property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> str:
        """
        **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.
        """
        return pulumi.get(self, "db_workload")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isCdb")
    def is_cdb(self) -> bool:
        """
        True if the database is a container database.
        """
        return pulumi.get(self, "is_cdb")

    @property
    @pulumi.getter(name="keyStoreId")
    def key_store_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        """
        return pulumi.get(self, "key_store_id")

    @property
    @pulumi.getter(name="keyStoreWalletName")
    def key_store_wallet_name(self) -> str:
        """
        The wallet name for Oracle Key Vault.
        """
        return pulumi.get(self, "key_store_wallet_name")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="kmsKeyMigration")
    def kms_key_migration(self) -> bool:
        return pulumi.get(self, "kms_key_migration")

    @property
    @pulumi.getter(name="kmsKeyRotation")
    def kms_key_rotation(self) -> int:
        return pulumi.get(self, "kms_key_rotation")

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> str:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        """
        return pulumi.get(self, "kms_key_version_id")

    @property
    @pulumi.getter(name="lastBackupDurationInSeconds")
    def last_backup_duration_in_seconds(self) -> int:
        """
        The duration when the latest database backup created.
        """
        return pulumi.get(self, "last_backup_duration_in_seconds")

    @property
    @pulumi.getter(name="lastBackupTimestamp")
    def last_backup_timestamp(self) -> str:
        """
        The date and time when the latest database backup was created.
        """
        return pulumi.get(self, "last_backup_timestamp")

    @property
    @pulumi.getter(name="lastFailedBackupTimestamp")
    def last_failed_backup_timestamp(self) -> str:
        """
        The date and time when the latest database backup failed.
        """
        return pulumi.get(self, "last_failed_backup_timestamp")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> str:
        """
        The national character set for the database.
        """
        return pulumi.get(self, "ncharacter_set")

    @property
    @pulumi.getter(name="pdbName")
    def pdb_name(self) -> str:
        """
        The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        """
        return pulumi.get(self, "pdb_name")

    @property
    @pulumi.getter(name="sidPrefix")
    def sid_prefix(self) -> str:
        """
        Specifies a prefix for the `Oracle SID` of the database to be created.
        """
        return pulumi.get(self, "sid_prefix")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="sourceDatabasePointInTimeRecoveryTimestamp")
    def source_database_point_in_time_recovery_timestamp(self) -> str:
        """
        Point in time recovery timeStamp of the source database at which cloned database system is cloned from the source database system, as described in [RFC 3339](https://tools.ietf.org/rfc/rfc3339)
        """
        return pulumi.get(self, "source_database_point_in_time_recovery_timestamp")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the database was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")

    @property
    @pulumi.getter(name="vmClusterId")
    def vm_cluster_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VM cluster.
        """
        return pulumi.get(self, "vm_cluster_id")


@pulumi.output_type
class GetDatabasesDatabaseConnectionStringResult(dict):
    def __init__(__self__, *,
                 all_connection_strings: Mapping[str, Any],
                 cdb_default: str,
                 cdb_ip_default: str):
        """
        :param Mapping[str, Any] all_connection_strings: All connection strings to use to connect to the Database.
        :param str cdb_default: Host name based CDB Connection String.
        :param str cdb_ip_default: IP based CDB Connection String.
        """
        GetDatabasesDatabaseConnectionStringResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_connection_strings=all_connection_strings,
            cdb_default=cdb_default,
            cdb_ip_default=cdb_ip_default,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_connection_strings: Mapping[str, Any],
             cdb_default: str,
             cdb_ip_default: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("all_connection_strings", all_connection_strings)
        _setter("cdb_default", cdb_default)
        _setter("cdb_ip_default", cdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Mapping[str, Any]:
        """
        All connection strings to use to connect to the Database.
        """
        return pulumi.get(self, "all_connection_strings")

    @property
    @pulumi.getter(name="cdbDefault")
    def cdb_default(self) -> str:
        """
        Host name based CDB Connection String.
        """
        return pulumi.get(self, "cdb_default")

    @property
    @pulumi.getter(name="cdbIpDefault")
    def cdb_ip_default(self) -> str:
        """
        IP based CDB Connection String.
        """
        return pulumi.get(self, "cdb_ip_default")


@pulumi.output_type
class GetDatabasesDatabaseDatabaseResult(dict):
    def __init__(__self__, *,
                 admin_password: str,
                 backup_id: str,
                 backup_tde_password: str,
                 character_set: str,
                 database_software_image_id: str,
                 db_backup_configs: Sequence['outputs.GetDatabasesDatabaseDatabaseDbBackupConfigResult'],
                 db_name: str,
                 db_unique_name: str,
                 db_workload: str,
                 defined_tags: Mapping[str, Any],
                 freeform_tags: Mapping[str, Any],
                 kms_key_id: str,
                 kms_key_version_id: str,
                 ncharacter_set: str,
                 pdb_name: str,
                 sid_prefix: str,
                 tde_wallet_password: str,
                 vault_id: str):
        """
        :param str character_set: The character set for the database.
        :param str database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        :param Sequence['GetDatabasesDatabaseDatabaseDbBackupConfigArgs'] db_backup_configs: Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        :param str db_name: A filter to return only resources that match the entire database name given. The match is not case sensitive.
        :param str db_unique_name: A system-generated name for the database to ensure uniqueness within an Oracle Data Guard group (a primary database and its standby databases). The unique name cannot be changed.
        :param str db_workload: **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param str kms_key_version_id: The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        :param str ncharacter_set: The national character set for the database.
        :param str pdb_name: The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        :param str sid_prefix: Specifies a prefix for the `Oracle SID` of the database to be created.
        :param str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        GetDatabasesDatabaseDatabaseResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            admin_password=admin_password,
            backup_id=backup_id,
            backup_tde_password=backup_tde_password,
            character_set=character_set,
            database_software_image_id=database_software_image_id,
            db_backup_configs=db_backup_configs,
            db_name=db_name,
            db_unique_name=db_unique_name,
            db_workload=db_workload,
            defined_tags=defined_tags,
            freeform_tags=freeform_tags,
            kms_key_id=kms_key_id,
            kms_key_version_id=kms_key_version_id,
            ncharacter_set=ncharacter_set,
            pdb_name=pdb_name,
            sid_prefix=sid_prefix,
            tde_wallet_password=tde_wallet_password,
            vault_id=vault_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             admin_password: str,
             backup_id: str,
             backup_tde_password: str,
             character_set: str,
             database_software_image_id: str,
             db_backup_configs: Sequence['outputs.GetDatabasesDatabaseDatabaseDbBackupConfigResult'],
             db_name: str,
             db_unique_name: str,
             db_workload: str,
             defined_tags: Mapping[str, Any],
             freeform_tags: Mapping[str, Any],
             kms_key_id: str,
             kms_key_version_id: str,
             ncharacter_set: str,
             pdb_name: str,
             sid_prefix: str,
             tde_wallet_password: str,
             vault_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("admin_password", admin_password)
        _setter("backup_id", backup_id)
        _setter("backup_tde_password", backup_tde_password)
        _setter("character_set", character_set)
        _setter("database_software_image_id", database_software_image_id)
        _setter("db_backup_configs", db_backup_configs)
        _setter("db_name", db_name)
        _setter("db_unique_name", db_unique_name)
        _setter("db_workload", db_workload)
        _setter("defined_tags", defined_tags)
        _setter("freeform_tags", freeform_tags)
        _setter("kms_key_id", kms_key_id)
        _setter("kms_key_version_id", kms_key_version_id)
        _setter("ncharacter_set", ncharacter_set)
        _setter("pdb_name", pdb_name)
        _setter("sid_prefix", sid_prefix)
        _setter("tde_wallet_password", tde_wallet_password)
        _setter("vault_id", vault_id)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> str:
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> str:
        return pulumi.get(self, "backup_id")

    @property
    @pulumi.getter(name="backupTdePassword")
    def backup_tde_password(self) -> str:
        return pulumi.get(self, "backup_tde_password")

    @property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> str:
        """
        The character set for the database.
        """
        return pulumi.get(self, "character_set")

    @property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> str:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        return pulumi.get(self, "database_software_image_id")

    @property
    @pulumi.getter(name="dbBackupConfigs")
    def db_backup_configs(self) -> Sequence['outputs.GetDatabasesDatabaseDatabaseDbBackupConfigResult']:
        """
        Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        """
        return pulumi.get(self, "db_backup_configs")

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> str:
        """
        A filter to return only resources that match the entire database name given. The match is not case sensitive.
        """
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> str:
        """
        A system-generated name for the database to ensure uniqueness within an Oracle Data Guard group (a primary database and its standby databases). The unique name cannot be changed.
        """
        return pulumi.get(self, "db_unique_name")

    @property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> str:
        """
        **Deprecated.** The dbWorkload field has been deprecated for Exadata Database Service on Dedicated Infrastructure, Exadata Database Service on Cloud@Customer, and Base Database Service. Support for this attribute will end in November 2023. You may choose to update your custom scripts to exclude the dbWorkload attribute. After November 2023 if you pass a value to the dbWorkload attribute, it will be ignored.
        """
        return pulumi.get(self, "db_workload")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> str:
        """
        The OCID of the key container version that is used in database transparent data encryption (TDE) operations KMS Key can have multiple key versions. If none is specified, the current key version (latest) of the Key Id is used for the operation.
        """
        return pulumi.get(self, "kms_key_version_id")

    @property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> str:
        """
        The national character set for the database.
        """
        return pulumi.get(self, "ncharacter_set")

    @property
    @pulumi.getter(name="pdbName")
    def pdb_name(self) -> str:
        """
        The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        """
        return pulumi.get(self, "pdb_name")

    @property
    @pulumi.getter(name="sidPrefix")
    def sid_prefix(self) -> str:
        """
        Specifies a prefix for the `Oracle SID` of the database to be created.
        """
        return pulumi.get(self, "sid_prefix")

    @property
    @pulumi.getter(name="tdeWalletPassword")
    def tde_wallet_password(self) -> str:
        return pulumi.get(self, "tde_wallet_password")

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class GetDatabasesDatabaseDatabaseDbBackupConfigResult(dict):
    def __init__(__self__, *,
                 auto_backup_enabled: bool,
                 auto_backup_window: str,
                 auto_full_backup_day: str,
                 auto_full_backup_window: str,
                 backup_deletion_policy: str,
                 backup_destination_details: Sequence['outputs.GetDatabasesDatabaseDatabaseDbBackupConfigBackupDestinationDetailResult'],
                 recovery_window_in_days: int,
                 run_immediate_full_backup: bool):
        """
        :param bool auto_backup_enabled: If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param str auto_backup_window: Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param str auto_full_backup_day: Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        :param str auto_full_backup_window: Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param str backup_deletion_policy: This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        :param Sequence['GetDatabasesDatabaseDatabaseDbBackupConfigBackupDestinationDetailArgs'] backup_destination_details: Backup destination details.
        :param int recovery_window_in_days: Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        :param bool run_immediate_full_backup: If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        GetDatabasesDatabaseDatabaseDbBackupConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_backup_enabled=auto_backup_enabled,
            auto_backup_window=auto_backup_window,
            auto_full_backup_day=auto_full_backup_day,
            auto_full_backup_window=auto_full_backup_window,
            backup_deletion_policy=backup_deletion_policy,
            backup_destination_details=backup_destination_details,
            recovery_window_in_days=recovery_window_in_days,
            run_immediate_full_backup=run_immediate_full_backup,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_backup_enabled: bool,
             auto_backup_window: str,
             auto_full_backup_day: str,
             auto_full_backup_window: str,
             backup_deletion_policy: str,
             backup_destination_details: Sequence['outputs.GetDatabasesDatabaseDatabaseDbBackupConfigBackupDestinationDetailResult'],
             recovery_window_in_days: int,
             run_immediate_full_backup: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("auto_backup_enabled", auto_backup_enabled)
        _setter("auto_backup_window", auto_backup_window)
        _setter("auto_full_backup_day", auto_full_backup_day)
        _setter("auto_full_backup_window", auto_full_backup_window)
        _setter("backup_deletion_policy", backup_deletion_policy)
        _setter("backup_destination_details", backup_destination_details)
        _setter("recovery_window_in_days", recovery_window_in_days)
        _setter("run_immediate_full_backup", run_immediate_full_backup)

    @property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> bool:
        """
        If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> str:
        """
        Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> str:
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        return pulumi.get(self, "auto_full_backup_day")

    @property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> str:
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_full_backup_window")

    @property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> str:
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        return pulumi.get(self, "backup_deletion_policy")

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Sequence['outputs.GetDatabasesDatabaseDatabaseDbBackupConfigBackupDestinationDetailResult']:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> int:
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> bool:
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        return pulumi.get(self, "run_immediate_full_backup")


@pulumi.output_type
class GetDatabasesDatabaseDatabaseDbBackupConfigBackupDestinationDetailResult(dict):
    def __init__(__self__, *,
                 dbrs_policy_id: str,
                 id: str,
                 type: str,
                 vpc_user: str):
        """
        :param str dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        :param str type: Type of the database backup destination.
        """
        GetDatabasesDatabaseDatabaseDbBackupConfigBackupDestinationDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dbrs_policy_id=dbrs_policy_id,
            id=id,
            type=type,
            vpc_user=vpc_user,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dbrs_policy_id: str,
             id: str,
             type: str,
             vpc_user: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("dbrs_policy_id", dbrs_policy_id)
        _setter("id", id)
        _setter("type", type)
        _setter("vpc_user", vpc_user)

    @property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> str:
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class GetDatabasesDatabaseDatabaseManagementConfigResult(dict):
    def __init__(__self__, *,
                 management_status: str,
                 management_type: str):
        """
        :param str management_status: The status of the Database Management service.
        :param str management_type: The Database Management type.
        """
        GetDatabasesDatabaseDatabaseManagementConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            management_status=management_status,
            management_type=management_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             management_status: str,
             management_type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("management_status", management_status)
        _setter("management_type", management_type)

    @property
    @pulumi.getter(name="managementStatus")
    def management_status(self) -> str:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "management_status")

    @property
    @pulumi.getter(name="managementType")
    def management_type(self) -> str:
        """
        The Database Management type.
        """
        return pulumi.get(self, "management_type")


@pulumi.output_type
class GetDatabasesDatabaseDbBackupConfigResult(dict):
    def __init__(__self__, *,
                 auto_backup_enabled: bool,
                 auto_backup_window: str,
                 auto_full_backup_day: str,
                 auto_full_backup_window: str,
                 backup_deletion_policy: str,
                 backup_destination_details: Sequence['outputs.GetDatabasesDatabaseDbBackupConfigBackupDestinationDetailResult'],
                 recovery_window_in_days: int,
                 run_immediate_full_backup: bool):
        """
        :param bool auto_backup_enabled: If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param str auto_backup_window: Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param str auto_full_backup_day: Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        :param str auto_full_backup_window: Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param str backup_deletion_policy: This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        :param Sequence['GetDatabasesDatabaseDbBackupConfigBackupDestinationDetailArgs'] backup_destination_details: Backup destination details.
        :param int recovery_window_in_days: Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        :param bool run_immediate_full_backup: If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        GetDatabasesDatabaseDbBackupConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_backup_enabled=auto_backup_enabled,
            auto_backup_window=auto_backup_window,
            auto_full_backup_day=auto_full_backup_day,
            auto_full_backup_window=auto_full_backup_window,
            backup_deletion_policy=backup_deletion_policy,
            backup_destination_details=backup_destination_details,
            recovery_window_in_days=recovery_window_in_days,
            run_immediate_full_backup=run_immediate_full_backup,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_backup_enabled: bool,
             auto_backup_window: str,
             auto_full_backup_day: str,
             auto_full_backup_window: str,
             backup_deletion_policy: str,
             backup_destination_details: Sequence['outputs.GetDatabasesDatabaseDbBackupConfigBackupDestinationDetailResult'],
             recovery_window_in_days: int,
             run_immediate_full_backup: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("auto_backup_enabled", auto_backup_enabled)
        _setter("auto_backup_window", auto_backup_window)
        _setter("auto_full_backup_day", auto_full_backup_day)
        _setter("auto_full_backup_window", auto_full_backup_window)
        _setter("backup_deletion_policy", backup_deletion_policy)
        _setter("backup_destination_details", backup_destination_details)
        _setter("recovery_window_in_days", recovery_window_in_days)
        _setter("run_immediate_full_backup", run_immediate_full_backup)

    @property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> bool:
        """
        If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> str:
        """
        Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> str:
        """
        Day of the week the full backup should be applied on the database system. If no option is selected, the value is null and we will default to Sunday.
        """
        return pulumi.get(self, "auto_full_backup_day")

    @property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> str:
        """
        Time window selected for initiating full backup for the database system. There are twelve available two-hour time windows. If no option is selected, the value is null and a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_full_backup_window")

    @property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> str:
        """
        This defines when the backups will be deleted. - IMMEDIATE option keep the backup for predefined time i.e 72 hours and then delete permanently... - RETAIN will keep the backups as per the policy defined for database backups.
        """
        return pulumi.get(self, "backup_deletion_policy")

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Sequence['outputs.GetDatabasesDatabaseDbBackupConfigBackupDestinationDetailResult']:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> int:
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> bool:
        """
        If set to true, configures automatic full backups in the local region (the region of the DB system) for the first backup run immediately.
        """
        return pulumi.get(self, "run_immediate_full_backup")


@pulumi.output_type
class GetDatabasesDatabaseDbBackupConfigBackupDestinationDetailResult(dict):
    def __init__(__self__, *,
                 dbrs_policy_id: str,
                 id: str,
                 type: str,
                 vpc_user: str):
        """
        :param str dbrs_policy_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        :param str type: Type of the database backup destination.
        """
        GetDatabasesDatabaseDbBackupConfigBackupDestinationDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dbrs_policy_id=dbrs_policy_id,
            id=id,
            type=type,
            vpc_user=vpc_user,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dbrs_policy_id: str,
             id: str,
             type: str,
             vpc_user: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("dbrs_policy_id", dbrs_policy_id)
        _setter("id", id)
        _setter("type", type)
        _setter("vpc_user", vpc_user)

    @property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DBRS policy used for backup.
        """
        return pulumi.get(self, "dbrs_policy_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> str:
        return pulumi.get(self, "vpc_user")


@pulumi.output_type
class GetDatabasesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDatabasesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDbHomeDatabaseResult(dict):
    def __init__(__self__, *,
                 admin_password: str,
                 backup_id: str,
                 backup_tde_password: str,
                 character_set: str,
                 connection_strings: Sequence['outputs.GetDbHomeDatabaseConnectionStringResult'],
                 database_id: str,
                 database_software_image_id: str,
                 db_backup_configs: Sequence['outputs.GetDbHomeDatabaseDbBackupConfigResult'],
                 db_name: str,
                 db_unique_name: str,
                 db_workload: str,
                 defined_tags: Mapping[str, Any],
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 kms_key_id: str,
                 kms_key_version_id: str,
                 lifecycle_details: str,
                 ncharacter_set: str,
                 one_off_patches: Sequence[str],
                 pdb_name: str,
                 sid_prefix: str,
                 state: str,
                 tde_wallet_password: str,
                 time_created: str,
                 time_stamp_for_point_in_time_recovery: str,
                 vault_id: str):
        """
        :param str database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        :param str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param Sequence[str] one_off_patches: List of one-off patches for Database Homes.
        :param str state: The current state of the Database Home.
        :param str time_created: The date and time the Database Home was created.
        """
        GetDbHomeDatabaseResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            admin_password=admin_password,
            backup_id=backup_id,
            backup_tde_password=backup_tde_password,
            character_set=character_set,
            connection_strings=connection_strings,
            database_id=database_id,
            database_software_image_id=database_software_image_id,
            db_backup_configs=db_backup_configs,
            db_name=db_name,
            db_unique_name=db_unique_name,
            db_workload=db_workload,
            defined_tags=defined_tags,
            freeform_tags=freeform_tags,
            id=id,
            kms_key_id=kms_key_id,
            kms_key_version_id=kms_key_version_id,
            lifecycle_details=lifecycle_details,
            ncharacter_set=ncharacter_set,
            one_off_patches=one_off_patches,
            pdb_name=pdb_name,
            sid_prefix=sid_prefix,
            state=state,
            tde_wallet_password=tde_wallet_password,
            time_created=time_created,
            time_stamp_for_point_in_time_recovery=time_stamp_for_point_in_time_recovery,
            vault_id=vault_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             admin_password: str,
             backup_id: str,
             backup_tde_password: str,
             character_set: str,
             connection_strings: Sequence['outputs.GetDbHomeDatabaseConnectionStringResult'],
             database_id: str,
             database_software_image_id: str,
             db_backup_configs: Sequence['outputs.GetDbHomeDatabaseDbBackupConfigResult'],
             db_name: str,
             db_unique_name: str,
             db_workload: str,
             defined_tags: Mapping[str, Any],
             freeform_tags: Mapping[str, Any],
             id: str,
             kms_key_id: str,
             kms_key_version_id: str,
             lifecycle_details: str,
             ncharacter_set: str,
             one_off_patches: Sequence[str],
             pdb_name: str,
             sid_prefix: str,
             state: str,
             tde_wallet_password: str,
             time_created: str,
             time_stamp_for_point_in_time_recovery: str,
             vault_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("admin_password", admin_password)
        _setter("backup_id", backup_id)
        _setter("backup_tde_password", backup_tde_password)
        _setter("character_set", character_set)
        _setter("connection_strings", connection_strings)
        _setter("database_id", database_id)
        _setter("database_software_image_id", database_software_image_id)
        _setter("db_backup_configs", db_backup_configs)
        _setter("db_name", db_name)
        _setter("db_unique_name", db_unique_name)
        _setter("db_workload", db_workload)
        _setter("defined_tags", defined_tags)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("kms_key_id", kms_key_id)
        _setter("kms_key_version_id", kms_key_version_id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("ncharacter_set", ncharacter_set)
        _setter("one_off_patches", one_off_patches)
        _setter("pdb_name", pdb_name)
        _setter("sid_prefix", sid_prefix)
        _setter("state", state)
        _setter("tde_wallet_password", tde_wallet_password)
        _setter("time_created", time_created)
        _setter("time_stamp_for_point_in_time_recovery", time_stamp_for_point_in_time_recovery)
        _setter("vault_id", vault_id)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> str:
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> str:
        return pulumi.get(self, "backup_id")

    @property
    @pulumi.getter(name="backupTdePassword")
    def backup_tde_password(self) -> str:
        return pulumi.get(self, "backup_tde_password")

    @property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> str:
        return pulumi.get(self, "character_set")

    @property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Sequence['outputs.GetDbHomeDatabaseConnectionStringResult']:
        return pulumi.get(self, "connection_strings")

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> str:
        return pulumi.get(self, "database_id")

    @property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> str:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        return pulumi.get(self, "database_software_image_id")

    @property
    @pulumi.getter(name="dbBackupConfigs")
    def db_backup_configs(self) -> Sequence['outputs.GetDbHomeDatabaseDbBackupConfigResult']:
        return pulumi.get(self, "db_backup_configs")

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> str:
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> str:
        return pulumi.get(self, "db_unique_name")

    @property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> str:
        return pulumi.get(self, "db_workload")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> str:
        return pulumi.get(self, "kms_key_version_id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> str:
        return pulumi.get(self, "ncharacter_set")

    @property
    @pulumi.getter(name="oneOffPatches")
    def one_off_patches(self) -> Sequence[str]:
        """
        List of one-off patches for Database Homes.
        """
        return pulumi.get(self, "one_off_patches")

    @property
    @pulumi.getter(name="pdbName")
    def pdb_name(self) -> str:
        return pulumi.get(self, "pdb_name")

    @property
    @pulumi.getter(name="sidPrefix")
    def sid_prefix(self) -> str:
        return pulumi.get(self, "sid_prefix")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the Database Home.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="tdeWalletPassword")
    def tde_wallet_password(self) -> str:
        return pulumi.get(self, "tde_wallet_password")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the Database Home was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeStampForPointInTimeRecovery")
    def time_stamp_for_point_in_time_recovery(self) -> str:
        return pulumi.get(self, "time_stamp_for_point_in_time_recovery")

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> str:
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class GetDbHomeDatabaseConnectionStringResult(dict):
    def __init__(__self__, *,
                 all_connection_strings: Mapping[str, Any],
                 cdb_default: str,
                 cdb_ip_default: str):
        GetDbHomeDatabaseConnectionStringResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_connection_strings=all_connection_strings,
            cdb_default=cdb_default,
            cdb_ip_default=cdb_ip_default,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_connection_strings: Mapping[str, Any],
             cdb_default: str,
             cdb_ip_default: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("all_connection_strings", all_connection_strings)
        _setter("cdb_default", cdb_default)
        _setter("cdb_ip_default", cdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Mapping[str, Any]:
        return pulumi.get(self, "all_connection_strings")

    @property
    @pulumi.getter(name="cdbDefault")
    def cdb_default(self) -> str:
        return pulumi.get(self, "cdb_default")

    @property
    @pulumi.getter(name="cdbIpDefault")
    def cdb_ip_default(self) -> str:
        return pulumi.get(self, "cdb_ip_default")


@pulumi.output_type
class GetDbHomeDatabaseDbBackupConfigResult(dict):
    def __init__(__self__, *,
                 auto_backup_enabled: bool,
                 auto_backup_window: str,
                 auto_full_backup_day: str,
                 auto_full_backup_window: str,
                 backup_deletion_policy: str,
                 backup_destination_details: Sequence['outputs.GetDbHomeDatabaseDbBackupConfigBackupDestinationDetailResult'],
                 recovery_window_in_days: int,
                 run_immediate_full_backup: bool):
        GetDbHomeDatabaseDbBackupConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_backup_enabled=auto_backup_enabled,
            auto_backup_window=auto_backup_window,
            auto_full_backup_day=auto_full_backup_day,
            auto_full_backup_window=auto_full_backup_window,
            backup_deletion_policy=backup_deletion_policy,
            backup_destination_details=backup_destination_details,
            recovery_window_in_days=recovery_window_in_days,
            run_immediate_full_backup=run_immediate_full_backup,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_backup_enabled: bool,
             auto_backup_window: str,
             auto_full_backup_day: str,
             auto_full_backup_window: str,
             backup_deletion_policy: str,
             backup_destination_details: Sequence['outputs.GetDbHomeDatabaseDbBackupConfigBackupDestinationDetailResult'],
             recovery_window_in_days: int,
             run_immediate_full_backup: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("auto_backup_enabled", auto_backup_enabled)
        _setter("auto_backup_window", auto_backup_window)
        _setter("auto_full_backup_day", auto_full_backup_day)
        _setter("auto_full_backup_window", auto_full_backup_window)
        _setter("backup_deletion_policy", backup_deletion_policy)
        _setter("backup_destination_details", backup_destination_details)
        _setter("recovery_window_in_days", recovery_window_in_days)
        _setter("run_immediate_full_backup", run_immediate_full_backup)

    @property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> bool:
        return pulumi.get(self, "auto_backup_enabled")

    @property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> str:
        return pulumi.get(self, "auto_backup_window")

    @property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> str:
        return pulumi.get(self, "auto_full_backup_day")

    @property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> str:
        return pulumi.get(self, "auto_full_backup_window")

    @property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> str:
        return pulumi.get(self, "backup_deletion_policy")

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Sequence['outputs.GetDbHomeDatabaseDbBackupConfigBackupDestinationDetailResult']:
        return pulumi.get(self, "backup_destination_details")

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> int:
        return pulumi.get(self, "recovery_window_in_days")

    @property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> bool:
        return pulumi.get(self, "run_immediate_full_backup")


@pulumi.output_type
class GetDbHomeDatabaseDbBackupConfigBackupDestinationDetailResult(dict):
    def __init__(__self__, *,
                 dbrs_policy_id: str,
                 id: str,
                 type: str):
        """
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        """
        GetDbHomeDatabaseDbBackupConfigBackupDestinationDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dbrs_policy_id=dbrs_policy_id,
            id=id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dbrs_policy_id: str,
             id: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("dbrs_policy_id", dbrs_policy_id)
        _setter("id", id)
        _setter("type", type)

    @property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> str:
        return pulumi.get(self, "dbrs_policy_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDbHomePatchHistoryEntriesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDbHomePatchHistoryEntriesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDbHomePatchHistoryEntriesPatchHistoryEntryResult(dict):
    def __init__(__self__, *,
                 action: str,
                 id: str,
                 lifecycle_details: str,
                 patch_id: str,
                 patch_type: str,
                 state: str,
                 time_ended: str,
                 time_started: str):
        """
        :param str action: The action being performed or was completed.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch history entry.
        :param str lifecycle_details: A descriptive text associated with the lifecycleState. Typically contains additional displayable text.
        :param str patch_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch.
        :param str patch_type: The type of Patch operation.
        :param str state: The current state of the action.
        :param str time_ended: The date and time when the patch action completed
        :param str time_started: The date and time when the patch action started.
        """
        GetDbHomePatchHistoryEntriesPatchHistoryEntryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            id=id,
            lifecycle_details=lifecycle_details,
            patch_id=patch_id,
            patch_type=patch_type,
            state=state,
            time_ended=time_ended,
            time_started=time_started,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: str,
             id: str,
             lifecycle_details: str,
             patch_id: str,
             patch_type: str,
             state: str,
             time_ended: str,
             time_started: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action", action)
        _setter("id", id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("patch_id", patch_id)
        _setter("patch_type", patch_type)
        _setter("state", state)
        _setter("time_ended", time_ended)
        _setter("time_started", time_started)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action being performed or was completed.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch history entry.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A descriptive text associated with the lifecycleState. Typically contains additional displayable text.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="patchId")
    def patch_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch.
        """
        return pulumi.get(self, "patch_id")

    @property
    @pulumi.getter(name="patchType")
    def patch_type(self) -> str:
        """
        The type of Patch operation.
        """
        return pulumi.get(self, "patch_type")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the action.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeEnded")
    def time_ended(self) -> str:
        """
        The date and time when the patch action completed
        """
        return pulumi.get(self, "time_ended")

    @property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> str:
        """
        The date and time when the patch action started.
        """
        return pulumi.get(self, "time_started")


@pulumi.output_type
class GetDbHomePatchesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDbHomePatchesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDbHomePatchesPatchResult(dict):
    def __init__(__self__, *,
                 available_actions: Sequence[str],
                 description: str,
                 id: str,
                 last_action: str,
                 lifecycle_details: str,
                 state: str,
                 time_released: str,
                 version: str):
        """
        :param Sequence[str] available_actions: Actions that can possibly be performed using this patch.
        :param str description: The text describing this patch package.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch.
        :param str last_action: Action that is currently being performed or was completed last.
        :param str lifecycle_details: A descriptive text associated with the lifecycleState. Typically can contain additional displayable text.
        :param str state: The current state of the patch as a result of lastAction.
        :param str time_released: The date and time that the patch was released.
        :param str version: The version of this patch package.
        """
        GetDbHomePatchesPatchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            available_actions=available_actions,
            description=description,
            id=id,
            last_action=last_action,
            lifecycle_details=lifecycle_details,
            state=state,
            time_released=time_released,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             available_actions: Sequence[str],
             description: str,
             id: str,
             last_action: str,
             lifecycle_details: str,
             state: str,
             time_released: str,
             version: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("available_actions", available_actions)
        _setter("description", description)
        _setter("id", id)
        _setter("last_action", last_action)
        _setter("lifecycle_details", lifecycle_details)
        _setter("state", state)
        _setter("time_released", time_released)
        _setter("version", version)

    @property
    @pulumi.getter(name="availableActions")
    def available_actions(self) -> Sequence[str]:
        """
        Actions that can possibly be performed using this patch.
        """
        return pulumi.get(self, "available_actions")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The text describing this patch package.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastAction")
    def last_action(self) -> str:
        """
        Action that is currently being performed or was completed last.
        """
        return pulumi.get(self, "last_action")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A descriptive text associated with the lifecycleState. Typically can contain additional displayable text.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the patch as a result of lastAction.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeReleased")
    def time_released(self) -> str:
        """
        The date and time that the patch was released.
        """
        return pulumi.get(self, "time_released")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The version of this patch package.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetDbHomesDbHomeResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 database_software_image_id: str,
                 databases: Sequence['outputs.GetDbHomesDbHomeDatabaseResult'],
                 db_home_id: str,
                 db_home_location: str,
                 db_system_id: str,
                 db_version: str,
                 defined_tags: Mapping[str, Any],
                 display_name: str,
                 enable_database_delete: bool,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 is_desupported_version: bool,
                 kms_key_id: str,
                 kms_key_version_id: str,
                 last_patch_history_entry_id: str,
                 lifecycle_details: str,
                 source: str,
                 state: str,
                 time_created: str,
                 vm_cluster_id: str):
        """
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param str database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        :param str db_home_location: The location of the Oracle Database Home.
        :param str db_system_id: The DB system [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm). If provided, filters the results to the set of database versions which are supported for the DB system.
        :param str db_version: A filter to return only DB Homes that match the specified dbVersion.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        :param str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param str last_patch_history_entry_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last patch history. This value is updated as soon as a patch operation is started.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        :param str time_created: The date and time the Database Home was created.
        :param str vm_cluster_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VM cluster.
        """
        GetDbHomesDbHomeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            database_software_image_id=database_software_image_id,
            databases=databases,
            db_home_id=db_home_id,
            db_home_location=db_home_location,
            db_system_id=db_system_id,
            db_version=db_version,
            defined_tags=defined_tags,
            display_name=display_name,
            enable_database_delete=enable_database_delete,
            freeform_tags=freeform_tags,
            id=id,
            is_desupported_version=is_desupported_version,
            kms_key_id=kms_key_id,
            kms_key_version_id=kms_key_version_id,
            last_patch_history_entry_id=last_patch_history_entry_id,
            lifecycle_details=lifecycle_details,
            source=source,
            state=state,
            time_created=time_created,
            vm_cluster_id=vm_cluster_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             database_software_image_id: str,
             databases: Sequence['outputs.GetDbHomesDbHomeDatabaseResult'],
             db_home_id: str,
             db_home_location: str,
             db_system_id: str,
             db_version: str,
             defined_tags: Mapping[str, Any],
             display_name: str,
             enable_database_delete: bool,
             freeform_tags: Mapping[str, Any],
             id: str,
             is_desupported_version: bool,
             kms_key_id: str,
             kms_key_version_id: str,
             last_patch_history_entry_id: str,
             lifecycle_details: str,
             source: str,
             state: str,
             time_created: str,
             vm_cluster_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("compartment_id", compartment_id)
        _setter("database_software_image_id", database_software_image_id)
        _setter("databases", databases)
        _setter("db_home_id", db_home_id)
        _setter("db_home_location", db_home_location)
        _setter("db_system_id", db_system_id)
        _setter("db_version", db_version)
        _setter("defined_tags", defined_tags)
        _setter("display_name", display_name)
        _setter("enable_database_delete", enable_database_delete)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("is_desupported_version", is_desupported_version)
        _setter("kms_key_id", kms_key_id)
        _setter("kms_key_version_id", kms_key_version_id)
        _setter("last_patch_history_entry_id", last_patch_history_entry_id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("source", source)
        _setter("state", state)
        _setter("time_created", time_created)
        _setter("vm_cluster_id", vm_cluster_id)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> str:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        return pulumi.get(self, "database_software_image_id")

    @property
    @pulumi.getter
    def databases(self) -> Sequence['outputs.GetDbHomesDbHomeDatabaseResult']:
        return pulumi.get(self, "databases")

    @property
    @pulumi.getter(name="dbHomeId")
    def db_home_id(self) -> str:
        return pulumi.get(self, "db_home_id")

    @property
    @pulumi.getter(name="dbHomeLocation")
    def db_home_location(self) -> str:
        """
        The location of the Oracle Database Home.
        """
        return pulumi.get(self, "db_home_location")

    @property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> str:
        """
        The DB system [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm). If provided, filters the results to the set of database versions which are supported for the DB system.
        """
        return pulumi.get(self, "db_system_id")

    @property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> str:
        """
        A filter to return only DB Homes that match the specified dbVersion.
        """
        return pulumi.get(self, "db_version")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="enableDatabaseDelete")
    def enable_database_delete(self) -> bool:
        return pulumi.get(self, "enable_database_delete")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isDesupportedVersion")
    def is_desupported_version(self) -> bool:
        return pulumi.get(self, "is_desupported_version")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> str:
        return pulumi.get(self, "kms_key_version_id")

    @property
    @pulumi.getter(name="lastPatchHistoryEntryId")
    def last_patch_history_entry_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last patch history. This value is updated as soon as a patch operation is started.
        """
        return pulumi.get(self, "last_patch_history_entry_id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the Database Home was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="vmClusterId")
    def vm_cluster_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VM cluster.
        """
        return pulumi.get(self, "vm_cluster_id")


@pulumi.output_type
class GetDbHomesDbHomeDatabaseResult(dict):
    def __init__(__self__, *,
                 admin_password: str,
                 backup_id: str,
                 backup_tde_password: str,
                 character_set: str,
                 connection_strings: Sequence['outputs.GetDbHomesDbHomeDatabaseConnectionStringResult'],
                 database_id: str,
                 database_software_image_id: str,
                 db_backup_configs: Sequence['outputs.GetDbHomesDbHomeDatabaseDbBackupConfigResult'],
                 db_name: str,
                 db_unique_name: str,
                 db_workload: str,
                 defined_tags: Mapping[str, Any],
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 kms_key_id: str,
                 kms_key_version_id: str,
                 lifecycle_details: str,
                 ncharacter_set: str,
                 one_off_patches: Sequence[str],
                 pdb_name: str,
                 sid_prefix: str,
                 state: str,
                 tde_wallet_password: str,
                 time_created: str,
                 time_stamp_for_point_in_time_recovery: str,
                 vault_id: str):
        """
        :param str backup_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup. Specify a backupId to list only the DB systems or DB homes that support creating a database using this backup in this compartment.
        :param str database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        :param str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param Sequence[str] one_off_patches: List of one-off patches for Database Homes.
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        :param str time_created: The date and time the Database Home was created.
        """
        GetDbHomesDbHomeDatabaseResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            admin_password=admin_password,
            backup_id=backup_id,
            backup_tde_password=backup_tde_password,
            character_set=character_set,
            connection_strings=connection_strings,
            database_id=database_id,
            database_software_image_id=database_software_image_id,
            db_backup_configs=db_backup_configs,
            db_name=db_name,
            db_unique_name=db_unique_name,
            db_workload=db_workload,
            defined_tags=defined_tags,
            freeform_tags=freeform_tags,
            id=id,
            kms_key_id=kms_key_id,
            kms_key_version_id=kms_key_version_id,
            lifecycle_details=lifecycle_details,
            ncharacter_set=ncharacter_set,
            one_off_patches=one_off_patches,
            pdb_name=pdb_name,
            sid_prefix=sid_prefix,
            state=state,
            tde_wallet_password=tde_wallet_password,
            time_created=time_created,
            time_stamp_for_point_in_time_recovery=time_stamp_for_point_in_time_recovery,
            vault_id=vault_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             admin_password: str,
             backup_id: str,
             backup_tde_password: str,
             character_set: str,
             connection_strings: Sequence['outputs.GetDbHomesDbHomeDatabaseConnectionStringResult'],
             database_id: str,
             database_software_image_id: str,
             db_backup_configs: Sequence['outputs.GetDbHomesDbHomeDatabaseDbBackupConfigResult'],
             db_name: str,
             db_unique_name: str,
             db_workload: str,
             defined_tags: Mapping[str, Any],
             freeform_tags: Mapping[str, Any],
             id: str,
             kms_key_id: str,
             kms_key_version_id: str,
             lifecycle_details: str,
             ncharacter_set: str,
             one_off_patches: Sequence[str],
             pdb_name: str,
             sid_prefix: str,
             state: str,
             tde_wallet_password: str,
             time_created: str,
             time_stamp_for_point_in_time_recovery: str,
             vault_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("admin_password", admin_password)
        _setter("backup_id", backup_id)
        _setter("backup_tde_password", backup_tde_password)
        _setter("character_set", character_set)
        _setter("connection_strings", connection_strings)
        _setter("database_id", database_id)
        _setter("database_software_image_id", database_software_image_id)
        _setter("db_backup_configs", db_backup_configs)
        _setter("db_name", db_name)
        _setter("db_unique_name", db_unique_name)
        _setter("db_workload", db_workload)
        _setter("defined_tags", defined_tags)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("kms_key_id", kms_key_id)
        _setter("kms_key_version_id", kms_key_version_id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("ncharacter_set", ncharacter_set)
        _setter("one_off_patches", one_off_patches)
        _setter("pdb_name", pdb_name)
        _setter("sid_prefix", sid_prefix)
        _setter("state", state)
        _setter("tde_wallet_password", tde_wallet_password)
        _setter("time_created", time_created)
        _setter("time_stamp_for_point_in_time_recovery", time_stamp_for_point_in_time_recovery)
        _setter("vault_id", vault_id)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> str:
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup. Specify a backupId to list only the DB systems or DB homes that support creating a database using this backup in this compartment.
        """
        return pulumi.get(self, "backup_id")

    @property
    @pulumi.getter(name="backupTdePassword")
    def backup_tde_password(self) -> str:
        return pulumi.get(self, "backup_tde_password")

    @property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> str:
        return pulumi.get(self, "character_set")

    @property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Sequence['outputs.GetDbHomesDbHomeDatabaseConnectionStringResult']:
        return pulumi.get(self, "connection_strings")

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> str:
        return pulumi.get(self, "database_id")

    @property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> str:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        return pulumi.get(self, "database_software_image_id")

    @property
    @pulumi.getter(name="dbBackupConfigs")
    def db_backup_configs(self) -> Sequence['outputs.GetDbHomesDbHomeDatabaseDbBackupConfigResult']:
        return pulumi.get(self, "db_backup_configs")

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> str:
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> str:
        return pulumi.get(self, "db_unique_name")

    @property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> str:
        return pulumi.get(self, "db_workload")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> str:
        return pulumi.get(self, "kms_key_version_id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> str:
        return pulumi.get(self, "ncharacter_set")

    @property
    @pulumi.getter(name="oneOffPatches")
    def one_off_patches(self) -> Sequence[str]:
        """
        List of one-off patches for Database Homes.
        """
        return pulumi.get(self, "one_off_patches")

    @property
    @pulumi.getter(name="pdbName")
    def pdb_name(self) -> str:
        return pulumi.get(self, "pdb_name")

    @property
    @pulumi.getter(name="sidPrefix")
    def sid_prefix(self) -> str:
        return pulumi.get(self, "sid_prefix")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="tdeWalletPassword")
    def tde_wallet_password(self) -> str:
        return pulumi.get(self, "tde_wallet_password")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the Database Home was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeStampForPointInTimeRecovery")
    def time_stamp_for_point_in_time_recovery(self) -> str:
        return pulumi.get(self, "time_stamp_for_point_in_time_recovery")

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> str:
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class GetDbHomesDbHomeDatabaseConnectionStringResult(dict):
    def __init__(__self__, *,
                 all_connection_strings: Mapping[str, Any],
                 cdb_default: str,
                 cdb_ip_default: str):
        GetDbHomesDbHomeDatabaseConnectionStringResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_connection_strings=all_connection_strings,
            cdb_default=cdb_default,
            cdb_ip_default=cdb_ip_default,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_connection_strings: Mapping[str, Any],
             cdb_default: str,
             cdb_ip_default: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("all_connection_strings", all_connection_strings)
        _setter("cdb_default", cdb_default)
        _setter("cdb_ip_default", cdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Mapping[str, Any]:
        return pulumi.get(self, "all_connection_strings")

    @property
    @pulumi.getter(name="cdbDefault")
    def cdb_default(self) -> str:
        return pulumi.get(self, "cdb_default")

    @property
    @pulumi.getter(name="cdbIpDefault")
    def cdb_ip_default(self) -> str:
        return pulumi.get(self, "cdb_ip_default")


@pulumi.output_type
class GetDbHomesDbHomeDatabaseDbBackupConfigResult(dict):
    def __init__(__self__, *,
                 auto_backup_enabled: bool,
                 auto_backup_window: str,
                 auto_full_backup_day: str,
                 auto_full_backup_window: str,
                 backup_deletion_policy: str,
                 backup_destination_details: Sequence['outputs.GetDbHomesDbHomeDatabaseDbBackupConfigBackupDestinationDetailResult'],
                 recovery_window_in_days: int,
                 run_immediate_full_backup: bool):
        GetDbHomesDbHomeDatabaseDbBackupConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_backup_enabled=auto_backup_enabled,
            auto_backup_window=auto_backup_window,
            auto_full_backup_day=auto_full_backup_day,
            auto_full_backup_window=auto_full_backup_window,
            backup_deletion_policy=backup_deletion_policy,
            backup_destination_details=backup_destination_details,
            recovery_window_in_days=recovery_window_in_days,
            run_immediate_full_backup=run_immediate_full_backup,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_backup_enabled: bool,
             auto_backup_window: str,
             auto_full_backup_day: str,
             auto_full_backup_window: str,
             backup_deletion_policy: str,
             backup_destination_details: Sequence['outputs.GetDbHomesDbHomeDatabaseDbBackupConfigBackupDestinationDetailResult'],
             recovery_window_in_days: int,
             run_immediate_full_backup: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("auto_backup_enabled", auto_backup_enabled)
        _setter("auto_backup_window", auto_backup_window)
        _setter("auto_full_backup_day", auto_full_backup_day)
        _setter("auto_full_backup_window", auto_full_backup_window)
        _setter("backup_deletion_policy", backup_deletion_policy)
        _setter("backup_destination_details", backup_destination_details)
        _setter("recovery_window_in_days", recovery_window_in_days)
        _setter("run_immediate_full_backup", run_immediate_full_backup)

    @property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> bool:
        return pulumi.get(self, "auto_backup_enabled")

    @property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> str:
        return pulumi.get(self, "auto_backup_window")

    @property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> str:
        return pulumi.get(self, "auto_full_backup_day")

    @property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> str:
        return pulumi.get(self, "auto_full_backup_window")

    @property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> str:
        return pulumi.get(self, "backup_deletion_policy")

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Sequence['outputs.GetDbHomesDbHomeDatabaseDbBackupConfigBackupDestinationDetailResult']:
        return pulumi.get(self, "backup_destination_details")

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> int:
        return pulumi.get(self, "recovery_window_in_days")

    @property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> bool:
        return pulumi.get(self, "run_immediate_full_backup")


@pulumi.output_type
class GetDbHomesDbHomeDatabaseDbBackupConfigBackupDestinationDetailResult(dict):
    def __init__(__self__, *,
                 dbrs_policy_id: str,
                 id: str,
                 type: str):
        """
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        """
        GetDbHomesDbHomeDatabaseDbBackupConfigBackupDestinationDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dbrs_policy_id=dbrs_policy_id,
            id=id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dbrs_policy_id: str,
             id: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("dbrs_policy_id", dbrs_policy_id)
        _setter("id", id)
        _setter("type", type)

    @property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> str:
        return pulumi.get(self, "dbrs_policy_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Database Home.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDbHomesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDbHomesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDbNodeConsoleConnectionsConsoleConnectionResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 connection_string: str,
                 db_node_id: str,
                 defined_tags: Mapping[str, Any],
                 fingerprint: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 lifecycle_details: str,
                 public_key: str,
                 service_host_key_fingerprint: str,
                 state: str):
        """
        :param str compartment_id: The OCID of the compartment to contain the console connection.
        :param str connection_string: The SSH connection string for the console connection.
        :param str db_node_id: The database node [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str fingerprint: The SSH public key fingerprint for the console connection.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str id: The OCID of the console connection.
        :param str lifecycle_details: Information about the current lifecycle state.
        :param str service_host_key_fingerprint: The SSH public key's fingerprint for the console connection service host.
        :param str state: The current state of the console connection.
        """
        GetDbNodeConsoleConnectionsConsoleConnectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            connection_string=connection_string,
            db_node_id=db_node_id,
            defined_tags=defined_tags,
            fingerprint=fingerprint,
            freeform_tags=freeform_tags,
            id=id,
            lifecycle_details=lifecycle_details,
            public_key=public_key,
            service_host_key_fingerprint=service_host_key_fingerprint,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             connection_string: str,
             db_node_id: str,
             defined_tags: Mapping[str, Any],
             fingerprint: str,
             freeform_tags: Mapping[str, Any],
             id: str,
             lifecycle_details: str,
             public_key: str,
             service_host_key_fingerprint: str,
             state: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("compartment_id", compartment_id)
        _setter("connection_string", connection_string)
        _setter("db_node_id", db_node_id)
        _setter("defined_tags", defined_tags)
        _setter("fingerprint", fingerprint)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("public_key", public_key)
        _setter("service_host_key_fingerprint", service_host_key_fingerprint)
        _setter("state", state)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The OCID of the compartment to contain the console connection.
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> str:
        """
        The SSH connection string for the console connection.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter(name="dbNodeId")
    def db_node_id(self) -> str:
        """
        The database node [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "db_node_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter
    def fingerprint(self) -> str:
        """
        The SSH public key fingerprint for the console connection.
        """
        return pulumi.get(self, "fingerprint")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the console connection.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> str:
        return pulumi.get(self, "public_key")

    @property
    @pulumi.getter(name="serviceHostKeyFingerprint")
    def service_host_key_fingerprint(self) -> str:
        """
        The SSH public key's fingerprint for the console connection service host.
        """
        return pulumi.get(self, "service_host_key_fingerprint")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the console connection.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetDbNodeConsoleConnectionsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDbNodeConsoleConnectionsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDbNodesDbNodeResult(dict):
    def __init__(__self__, *,
                 additional_details: str,
                 backup_ip_id: str,
                 backup_vnic2id: str,
                 backup_vnic_id: str,
                 cpu_core_count: int,
                 db_node_id: str,
                 db_node_storage_size_in_gbs: int,
                 db_server_id: str,
                 db_system_id: str,
                 defined_tags: Mapping[str, Any],
                 fault_domain: str,
                 freeform_tags: Mapping[str, Any],
                 host_ip_id: str,
                 hostname: str,
                 id: str,
                 lifecycle_details: str,
                 maintenance_type: str,
                 memory_size_in_gbs: int,
                 software_storage_size_in_gb: int,
                 state: str,
                 time_created: str,
                 time_maintenance_window_end: str,
                 time_maintenance_window_start: str,
                 vnic2id: str,
                 vnic_id: str):
        """
        :param str additional_details: Additional information about the planned maintenance.
        :param str backup_ip_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup IP address associated with the database node. Use this OCID with either the [GetPrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/PrivateIp/GetPrivateIp) or the [GetPublicIpByPrivateIpId](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/PublicIp/GetPublicIpByPrivateIpId) API to get the IP address needed to make a database connection.
        :param str backup_vnic2id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the second backup VNIC.
        :param str backup_vnic_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup VNIC.
        :param int cpu_core_count: The number of CPU cores enabled on the Db node.
        :param int db_node_storage_size_in_gbs: The allocated local node storage in GBs on the Db node.
        :param str db_server_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Exacc Db server.
        :param str db_system_id: The DB system [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm). If provided, filters the results to the set of database versions which are supported for the DB system.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str fault_domain: The name of the Fault Domain the instance is contained in.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str host_ip_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the host IP address associated with the database node. Use this OCID with either the  [GetPrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/PrivateIp/GetPrivateIp) or the [GetPublicIpByPrivateIpId](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/PublicIp/GetPublicIpByPrivateIpId) API to get the IP address  needed to make a database connection.
        :param str hostname: The host name for the database node.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database node.
        :param str lifecycle_details: Information about the current lifecycle state.
        :param str maintenance_type: The type of database node maintenance.
        :param int memory_size_in_gbs: The allocated memory in GBs on the Db node.
        :param int software_storage_size_in_gb: The size (in GB) of the block storage volume allocation for the DB system. This attribute applies only for virtual machine DB systems.
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        :param str time_created: The date and time that the database node was created.
        :param str time_maintenance_window_end: End date and time of maintenance window.
        :param str time_maintenance_window_start: Start date and time of maintenance window.
        :param str vnic2id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the second VNIC.
        :param str vnic_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VNIC.
        """
        GetDbNodesDbNodeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            additional_details=additional_details,
            backup_ip_id=backup_ip_id,
            backup_vnic2id=backup_vnic2id,
            backup_vnic_id=backup_vnic_id,
            cpu_core_count=cpu_core_count,
            db_node_id=db_node_id,
            db_node_storage_size_in_gbs=db_node_storage_size_in_gbs,
            db_server_id=db_server_id,
            db_system_id=db_system_id,
            defined_tags=defined_tags,
            fault_domain=fault_domain,
            freeform_tags=freeform_tags,
            host_ip_id=host_ip_id,
            hostname=hostname,
            id=id,
            lifecycle_details=lifecycle_details,
            maintenance_type=maintenance_type,
            memory_size_in_gbs=memory_size_in_gbs,
            software_storage_size_in_gb=software_storage_size_in_gb,
            state=state,
            time_created=time_created,
            time_maintenance_window_end=time_maintenance_window_end,
            time_maintenance_window_start=time_maintenance_window_start,
            vnic2id=vnic2id,
            vnic_id=vnic_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             additional_details: str,
             backup_ip_id: str,
             backup_vnic2id: str,
             backup_vnic_id: str,
             cpu_core_count: int,
             db_node_id: str,
             db_node_storage_size_in_gbs: int,
             db_server_id: str,
             db_system_id: str,
             defined_tags: Mapping[str, Any],
             fault_domain: str,
             freeform_tags: Mapping[str, Any],
             host_ip_id: str,
             hostname: str,
             id: str,
             lifecycle_details: str,
             maintenance_type: str,
             memory_size_in_gbs: int,
             software_storage_size_in_gb: int,
             state: str,
             time_created: str,
             time_maintenance_window_end: str,
             time_maintenance_window_start: str,
             vnic2id: str,
             vnic_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("additional_details", additional_details)
        _setter("backup_ip_id", backup_ip_id)
        _setter("backup_vnic2id", backup_vnic2id)
        _setter("backup_vnic_id", backup_vnic_id)
        _setter("cpu_core_count", cpu_core_count)
        _setter("db_node_id", db_node_id)
        _setter("db_node_storage_size_in_gbs", db_node_storage_size_in_gbs)
        _setter("db_server_id", db_server_id)
        _setter("db_system_id", db_system_id)
        _setter("defined_tags", defined_tags)
        _setter("fault_domain", fault_domain)
        _setter("freeform_tags", freeform_tags)
        _setter("host_ip_id", host_ip_id)
        _setter("hostname", hostname)
        _setter("id", id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("maintenance_type", maintenance_type)
        _setter("memory_size_in_gbs", memory_size_in_gbs)
        _setter("software_storage_size_in_gb", software_storage_size_in_gb)
        _setter("state", state)
        _setter("time_created", time_created)
        _setter("time_maintenance_window_end", time_maintenance_window_end)
        _setter("time_maintenance_window_start", time_maintenance_window_start)
        _setter("vnic2id", vnic2id)
        _setter("vnic_id", vnic_id)

    @property
    @pulumi.getter(name="additionalDetails")
    def additional_details(self) -> str:
        """
        Additional information about the planned maintenance.
        """
        return pulumi.get(self, "additional_details")

    @property
    @pulumi.getter(name="backupIpId")
    def backup_ip_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup IP address associated with the database node. Use this OCID with either the [GetPrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/PrivateIp/GetPrivateIp) or the [GetPublicIpByPrivateIpId](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/PublicIp/GetPublicIpByPrivateIpId) API to get the IP address needed to make a database connection.
        """
        return pulumi.get(self, "backup_ip_id")

    @property
    @pulumi.getter(name="backupVnic2id")
    def backup_vnic2id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the second backup VNIC.
        """
        return pulumi.get(self, "backup_vnic2id")

    @property
    @pulumi.getter(name="backupVnicId")
    def backup_vnic_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup VNIC.
        """
        return pulumi.get(self, "backup_vnic_id")

    @property
    @pulumi.getter(name="cpuCoreCount")
    def cpu_core_count(self) -> int:
        """
        The number of CPU cores enabled on the Db node.
        """
        return pulumi.get(self, "cpu_core_count")

    @property
    @pulumi.getter(name="dbNodeId")
    def db_node_id(self) -> str:
        return pulumi.get(self, "db_node_id")

    @property
    @pulumi.getter(name="dbNodeStorageSizeInGbs")
    def db_node_storage_size_in_gbs(self) -> int:
        """
        The allocated local node storage in GBs on the Db node.
        """
        return pulumi.get(self, "db_node_storage_size_in_gbs")

    @property
    @pulumi.getter(name="dbServerId")
    def db_server_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Exacc Db server.
        """
        return pulumi.get(self, "db_server_id")

    @property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> str:
        """
        The DB system [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm). If provided, filters the results to the set of database versions which are supported for the DB system.
        """
        return pulumi.get(self, "db_system_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="faultDomain")
    def fault_domain(self) -> str:
        """
        The name of the Fault Domain the instance is contained in.
        """
        return pulumi.get(self, "fault_domain")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter(name="hostIpId")
    def host_ip_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the host IP address associated with the database node. Use this OCID with either the  [GetPrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/PrivateIp/GetPrivateIp) or the [GetPublicIpByPrivateIpId](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/PublicIp/GetPublicIpByPrivateIpId) API to get the IP address  needed to make a database connection.
        """
        return pulumi.get(self, "host_ip_id")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host name for the database node.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database node.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="maintenanceType")
    def maintenance_type(self) -> str:
        """
        The type of database node maintenance.
        """
        return pulumi.get(self, "maintenance_type")

    @property
    @pulumi.getter(name="memorySizeInGbs")
    def memory_size_in_gbs(self) -> int:
        """
        The allocated memory in GBs on the Db node.
        """
        return pulumi.get(self, "memory_size_in_gbs")

    @property
    @pulumi.getter(name="softwareStorageSizeInGb")
    def software_storage_size_in_gb(self) -> int:
        """
        The size (in GB) of the block storage volume allocation for the DB system. This attribute applies only for virtual machine DB systems.
        """
        return pulumi.get(self, "software_storage_size_in_gb")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time that the database node was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeMaintenanceWindowEnd")
    def time_maintenance_window_end(self) -> str:
        """
        End date and time of maintenance window.
        """
        return pulumi.get(self, "time_maintenance_window_end")

    @property
    @pulumi.getter(name="timeMaintenanceWindowStart")
    def time_maintenance_window_start(self) -> str:
        """
        Start date and time of maintenance window.
        """
        return pulumi.get(self, "time_maintenance_window_start")

    @property
    @pulumi.getter
    def vnic2id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the second VNIC.
        """
        return pulumi.get(self, "vnic2id")

    @property
    @pulumi.getter(name="vnicId")
    def vnic_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VNIC.
        """
        return pulumi.get(self, "vnic_id")


@pulumi.output_type
class GetDbNodesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDbNodesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDbServerDbServerPatchingDetailResult(dict):
    def __init__(__self__, *,
                 estimated_patch_duration: int,
                 patching_status: str,
                 time_patching_ended: str,
                 time_patching_started: str):
        """
        :param int estimated_patch_duration: Estimated time, in minutes, to patch one database server.
        :param str patching_status: The status of the patching operation.
        :param str time_patching_ended: The time when the patching operation ended.
        :param str time_patching_started: The time when the patching operation started.
        """
        GetDbServerDbServerPatchingDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            estimated_patch_duration=estimated_patch_duration,
            patching_status=patching_status,
            time_patching_ended=time_patching_ended,
            time_patching_started=time_patching_started,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             estimated_patch_duration: int,
             patching_status: str,
             time_patching_ended: str,
             time_patching_started: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("estimated_patch_duration", estimated_patch_duration)
        _setter("patching_status", patching_status)
        _setter("time_patching_ended", time_patching_ended)
        _setter("time_patching_started", time_patching_started)

    @property
    @pulumi.getter(name="estimatedPatchDuration")
    def estimated_patch_duration(self) -> int:
        """
        Estimated time, in minutes, to patch one database server.
        """
        return pulumi.get(self, "estimated_patch_duration")

    @property
    @pulumi.getter(name="patchingStatus")
    def patching_status(self) -> str:
        """
        The status of the patching operation.
        """
        return pulumi.get(self, "patching_status")

    @property
    @pulumi.getter(name="timePatchingEnded")
    def time_patching_ended(self) -> str:
        """
        The time when the patching operation ended.
        """
        return pulumi.get(self, "time_patching_ended")

    @property
    @pulumi.getter(name="timePatchingStarted")
    def time_patching_started(self) -> str:
        """
        The time when the patching operation started.
        """
        return pulumi.get(self, "time_patching_started")


@pulumi.output_type
class GetDbServersDbServerResult(dict):
    def __init__(__self__, *,
                 autonomous_virtual_machine_ids: Sequence[str],
                 autonomous_vm_cluster_ids: Sequence[str],
                 compartment_id: str,
                 cpu_core_count: int,
                 db_node_ids: Sequence[str],
                 db_node_storage_size_in_gbs: int,
                 db_server_patching_details: Sequence['outputs.GetDbServersDbServerDbServerPatchingDetailResult'],
                 defined_tags: Mapping[str, Any],
                 display_name: str,
                 exadata_infrastructure_id: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 lifecycle_details: str,
                 max_cpu_count: int,
                 max_db_node_storage_in_gbs: int,
                 max_memory_in_gbs: int,
                 memory_size_in_gbs: int,
                 shape: str,
                 state: str,
                 time_created: str,
                 vm_cluster_ids: Sequence[str]):
        """
        :param Sequence[str] autonomous_virtual_machine_ids: The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Virtual Machines associated with the Db server.
        :param Sequence[str] autonomous_vm_cluster_ids: The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous VM Clusters associated with the Db server.
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param int cpu_core_count: The number of CPU cores enabled on the Db server.
        :param Sequence[str] db_node_ids: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Db nodes associated with the Db server.
        :param int db_node_storage_size_in_gbs: The allocated local node storage in GBs on the Db server.
        :param Sequence['GetDbServersDbServerDbServerPatchingDetailArgs'] db_server_patching_details: The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param str exadata_infrastructure_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the ExadataInfrastructure.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Exacc Db server.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param int max_cpu_count: The total number of CPU cores available.
        :param int max_db_node_storage_in_gbs: The total local node storage available in GBs.
        :param int max_memory_in_gbs: The total memory available in GBs.
        :param int memory_size_in_gbs: The allocated memory in GBs on the Db server.
        :param str shape: The shape of the Db server. The shape determines the amount of CPU, storage, and memory resources available.
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        :param str time_created: The date and time that the Db Server was created.
        :param Sequence[str] vm_cluster_ids: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VM Clusters associated with the Db server.
        """
        GetDbServersDbServerResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autonomous_virtual_machine_ids=autonomous_virtual_machine_ids,
            autonomous_vm_cluster_ids=autonomous_vm_cluster_ids,
            compartment_id=compartment_id,
            cpu_core_count=cpu_core_count,
            db_node_ids=db_node_ids,
            db_node_storage_size_in_gbs=db_node_storage_size_in_gbs,
            db_server_patching_details=db_server_patching_details,
            defined_tags=defined_tags,
            display_name=display_name,
            exadata_infrastructure_id=exadata_infrastructure_id,
            freeform_tags=freeform_tags,
            id=id,
            lifecycle_details=lifecycle_details,
            max_cpu_count=max_cpu_count,
            max_db_node_storage_in_gbs=max_db_node_storage_in_gbs,
            max_memory_in_gbs=max_memory_in_gbs,
            memory_size_in_gbs=memory_size_in_gbs,
            shape=shape,
            state=state,
            time_created=time_created,
            vm_cluster_ids=vm_cluster_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autonomous_virtual_machine_ids: Sequence[str],
             autonomous_vm_cluster_ids: Sequence[str],
             compartment_id: str,
             cpu_core_count: int,
             db_node_ids: Sequence[str],
             db_node_storage_size_in_gbs: int,
             db_server_patching_details: Sequence['outputs.GetDbServersDbServerDbServerPatchingDetailResult'],
             defined_tags: Mapping[str, Any],
             display_name: str,
             exadata_infrastructure_id: str,
             freeform_tags: Mapping[str, Any],
             id: str,
             lifecycle_details: str,
             max_cpu_count: int,
             max_db_node_storage_in_gbs: int,
             max_memory_in_gbs: int,
             memory_size_in_gbs: int,
             shape: str,
             state: str,
             time_created: str,
             vm_cluster_ids: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("autonomous_virtual_machine_ids", autonomous_virtual_machine_ids)
        _setter("autonomous_vm_cluster_ids", autonomous_vm_cluster_ids)
        _setter("compartment_id", compartment_id)
        _setter("cpu_core_count", cpu_core_count)
        _setter("db_node_ids", db_node_ids)
        _setter("db_node_storage_size_in_gbs", db_node_storage_size_in_gbs)
        _setter("db_server_patching_details", db_server_patching_details)
        _setter("defined_tags", defined_tags)
        _setter("display_name", display_name)
        _setter("exadata_infrastructure_id", exadata_infrastructure_id)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("max_cpu_count", max_cpu_count)
        _setter("max_db_node_storage_in_gbs", max_db_node_storage_in_gbs)
        _setter("max_memory_in_gbs", max_memory_in_gbs)
        _setter("memory_size_in_gbs", memory_size_in_gbs)
        _setter("shape", shape)
        _setter("state", state)
        _setter("time_created", time_created)
        _setter("vm_cluster_ids", vm_cluster_ids)

    @property
    @pulumi.getter(name="autonomousVirtualMachineIds")
    def autonomous_virtual_machine_ids(self) -> Sequence[str]:
        """
        The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous Virtual Machines associated with the Db server.
        """
        return pulumi.get(self, "autonomous_virtual_machine_ids")

    @property
    @pulumi.getter(name="autonomousVmClusterIds")
    def autonomous_vm_cluster_ids(self) -> Sequence[str]:
        """
        The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Autonomous VM Clusters associated with the Db server.
        """
        return pulumi.get(self, "autonomous_vm_cluster_ids")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="cpuCoreCount")
    def cpu_core_count(self) -> int:
        """
        The number of CPU cores enabled on the Db server.
        """
        return pulumi.get(self, "cpu_core_count")

    @property
    @pulumi.getter(name="dbNodeIds")
    def db_node_ids(self) -> Sequence[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Db nodes associated with the Db server.
        """
        return pulumi.get(self, "db_node_ids")

    @property
    @pulumi.getter(name="dbNodeStorageSizeInGbs")
    def db_node_storage_size_in_gbs(self) -> int:
        """
        The allocated local node storage in GBs on the Db server.
        """
        return pulumi.get(self, "db_node_storage_size_in_gbs")

    @property
    @pulumi.getter(name="dbServerPatchingDetails")
    def db_server_patching_details(self) -> Sequence['outputs.GetDbServersDbServerDbServerPatchingDetailResult']:
        """
        The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        """
        return pulumi.get(self, "db_server_patching_details")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="exadataInfrastructureId")
    def exadata_infrastructure_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the ExadataInfrastructure.
        """
        return pulumi.get(self, "exadata_infrastructure_id")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Exacc Db server.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="maxCpuCount")
    def max_cpu_count(self) -> int:
        """
        The total number of CPU cores available.
        """
        return pulumi.get(self, "max_cpu_count")

    @property
    @pulumi.getter(name="maxDbNodeStorageInGbs")
    def max_db_node_storage_in_gbs(self) -> int:
        """
        The total local node storage available in GBs.
        """
        return pulumi.get(self, "max_db_node_storage_in_gbs")

    @property
    @pulumi.getter(name="maxMemoryInGbs")
    def max_memory_in_gbs(self) -> int:
        """
        The total memory available in GBs.
        """
        return pulumi.get(self, "max_memory_in_gbs")

    @property
    @pulumi.getter(name="memorySizeInGbs")
    def memory_size_in_gbs(self) -> int:
        """
        The allocated memory in GBs on the Db server.
        """
        return pulumi.get(self, "memory_size_in_gbs")

    @property
    @pulumi.getter
    def shape(self) -> str:
        """
        The shape of the Db server. The shape determines the amount of CPU, storage, and memory resources available.
        """
        return pulumi.get(self, "shape")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time that the Db Server was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="vmClusterIds")
    def vm_cluster_ids(self) -> Sequence[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VM Clusters associated with the Db server.
        """
        return pulumi.get(self, "vm_cluster_ids")


@pulumi.output_type
class GetDbServersDbServerDbServerPatchingDetailResult(dict):
    def __init__(__self__, *,
                 estimated_patch_duration: int,
                 patching_status: str,
                 time_patching_ended: str,
                 time_patching_started: str):
        """
        :param int estimated_patch_duration: Estimated time, in minutes, to patch one database server.
        :param str patching_status: The status of the patching operation.
        :param str time_patching_ended: The time when the patching operation ended.
        :param str time_patching_started: The time when the patching operation started.
        """
        GetDbServersDbServerDbServerPatchingDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            estimated_patch_duration=estimated_patch_duration,
            patching_status=patching_status,
            time_patching_ended=time_patching_ended,
            time_patching_started=time_patching_started,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             estimated_patch_duration: int,
             patching_status: str,
             time_patching_ended: str,
             time_patching_started: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("estimated_patch_duration", estimated_patch_duration)
        _setter("patching_status", patching_status)
        _setter("time_patching_ended", time_patching_ended)
        _setter("time_patching_started", time_patching_started)

    @property
    @pulumi.getter(name="estimatedPatchDuration")
    def estimated_patch_duration(self) -> int:
        """
        Estimated time, in minutes, to patch one database server.
        """
        return pulumi.get(self, "estimated_patch_duration")

    @property
    @pulumi.getter(name="patchingStatus")
    def patching_status(self) -> str:
        """
        The status of the patching operation.
        """
        return pulumi.get(self, "patching_status")

    @property
    @pulumi.getter(name="timePatchingEnded")
    def time_patching_ended(self) -> str:
        """
        The time when the patching operation ended.
        """
        return pulumi.get(self, "time_patching_ended")

    @property
    @pulumi.getter(name="timePatchingStarted")
    def time_patching_started(self) -> str:
        """
        The time when the patching operation started.
        """
        return pulumi.get(self, "time_patching_started")


@pulumi.output_type
class GetDbServersFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDbServersFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDbSystemComputePerformancesDbSystemComputePerformanceResult(dict):
    def __init__(__self__, *,
                 compute_performance_lists: Sequence['outputs.GetDbSystemComputePerformancesDbSystemComputePerformanceComputePerformanceListResult'],
                 shape: str):
        """
        :param Sequence['GetDbSystemComputePerformancesDbSystemComputePerformanceComputePerformanceListArgs'] compute_performance_lists: List of Compute performance details for the specified DB system shape.
        :param str shape: The shape of the DB system.
        """
        GetDbSystemComputePerformancesDbSystemComputePerformanceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compute_performance_lists=compute_performance_lists,
            shape=shape,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compute_performance_lists: Sequence['outputs.GetDbSystemComputePerformancesDbSystemComputePerformanceComputePerformanceListResult'],
             shape: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("compute_performance_lists", compute_performance_lists)
        _setter("shape", shape)

    @property
    @pulumi.getter(name="computePerformanceLists")
    def compute_performance_lists(self) -> Sequence['outputs.GetDbSystemComputePerformancesDbSystemComputePerformanceComputePerformanceListResult']:
        """
        List of Compute performance details for the specified DB system shape.
        """
        return pulumi.get(self, "compute_performance_lists")

    @property
    @pulumi.getter
    def shape(self) -> str:
        """
        The shape of the DB system.
        """
        return pulumi.get(self, "shape")


@pulumi.output_type
class GetDbSystemComputePerformancesDbSystemComputePerformanceComputePerformanceListResult(dict):
    def __init__(__self__, *,
                 cpu_core_count: int,
                 memory_in_gbs: float,
                 network_bandwidth_in_gbps: float,
                 network_iops: float,
                 network_throughput_in_mbps: float):
        """
        :param int cpu_core_count: The number of OCPU cores available.
        :param float memory_in_gbs: The amount of memory allocated for the VMDB System.
        :param float network_bandwidth_in_gbps: The network bandwidth of the VMDB system in gbps.
        :param float network_iops: IOPS for the VMDB System.
        :param float network_throughput_in_mbps: Network throughput for the VMDB System.
        """
        GetDbSystemComputePerformancesDbSystemComputePerformanceComputePerformanceListResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cpu_core_count=cpu_core_count,
            memory_in_gbs=memory_in_gbs,
            network_bandwidth_in_gbps=network_bandwidth_in_gbps,
            network_iops=network_iops,
            network_throughput_in_mbps=network_throughput_in_mbps,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cpu_core_count: int,
             memory_in_gbs: float,
             network_bandwidth_in_gbps: float,
             network_iops: float,
             network_throughput_in_mbps: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cpu_core_count", cpu_core_count)
        _setter("memory_in_gbs", memory_in_gbs)
        _setter("network_bandwidth_in_gbps", network_bandwidth_in_gbps)
        _setter("network_iops", network_iops)
        _setter("network_throughput_in_mbps", network_throughput_in_mbps)

    @property
    @pulumi.getter(name="cpuCoreCount")
    def cpu_core_count(self) -> int:
        """
        The number of OCPU cores available.
        """
        return pulumi.get(self, "cpu_core_count")

    @property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> float:
        """
        The amount of memory allocated for the VMDB System.
        """
        return pulumi.get(self, "memory_in_gbs")

    @property
    @pulumi.getter(name="networkBandwidthInGbps")
    def network_bandwidth_in_gbps(self) -> float:
        """
        The network bandwidth of the VMDB system in gbps.
        """
        return pulumi.get(self, "network_bandwidth_in_gbps")

    @property
    @pulumi.getter(name="networkIops")
    def network_iops(self) -> float:
        """
        IOPS for the VMDB System.
        """
        return pulumi.get(self, "network_iops")

    @property
    @pulumi.getter(name="networkThroughputInMbps")
    def network_throughput_in_mbps(self) -> float:
        """
        Network throughput for the VMDB System.
        """
        return pulumi.get(self, "network_throughput_in_mbps")


@pulumi.output_type
class GetDbSystemComputePerformancesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDbSystemComputePerformancesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDbSystemHistoryEntriesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDbSystemHistoryEntriesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDbSystemHistoryEntriesPatchHistoryEntryResult(dict):
    def __init__(__self__, *,
                 action: str,
                 id: str,
                 lifecycle_details: str,
                 patch_id: str,
                 patch_type: str,
                 state: str,
                 time_ended: str,
                 time_started: str):
        """
        :param str action: The action being performed or was completed.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch history entry.
        :param str lifecycle_details: A descriptive text associated with the lifecycleState. Typically contains additional displayable text.
        :param str patch_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch.
        :param str patch_type: The type of Patch operation.
        :param str state: The current state of the action.
        :param str time_ended: The date and time when the patch action completed
        :param str time_started: The date and time when the patch action started.
        """
        GetDbSystemHistoryEntriesPatchHistoryEntryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            id=id,
            lifecycle_details=lifecycle_details,
            patch_id=patch_id,
            patch_type=patch_type,
            state=state,
            time_ended=time_ended,
            time_started=time_started,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: str,
             id: str,
             lifecycle_details: str,
             patch_id: str,
             patch_type: str,
             state: str,
             time_ended: str,
             time_started: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action", action)
        _setter("id", id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("patch_id", patch_id)
        _setter("patch_type", patch_type)
        _setter("state", state)
        _setter("time_ended", time_ended)
        _setter("time_started", time_started)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action being performed or was completed.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch history entry.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A descriptive text associated with the lifecycleState. Typically contains additional displayable text.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="patchId")
    def patch_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch.
        """
        return pulumi.get(self, "patch_id")

    @property
    @pulumi.getter(name="patchType")
    def patch_type(self) -> str:
        """
        The type of Patch operation.
        """
        return pulumi.get(self, "patch_type")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the action.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeEnded")
    def time_ended(self) -> str:
        """
        The date and time when the patch action completed
        """
        return pulumi.get(self, "time_ended")

    @property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> str:
        """
        The date and time when the patch action started.
        """
        return pulumi.get(self, "time_started")


@pulumi.output_type
class GetDbSystemPatchesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDbSystemPatchesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDbSystemPatchesPatchResult(dict):
    def __init__(__self__, *,
                 available_actions: Sequence[str],
                 description: str,
                 id: str,
                 last_action: str,
                 lifecycle_details: str,
                 state: str,
                 time_released: str,
                 version: str):
        """
        :param Sequence[str] available_actions: Actions that can possibly be performed using this patch.
        :param str description: The text describing this patch package.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch.
        :param str last_action: Action that is currently being performed or was completed last.
        :param str lifecycle_details: A descriptive text associated with the lifecycleState. Typically can contain additional displayable text.
        :param str state: The current state of the patch as a result of lastAction.
        :param str time_released: The date and time that the patch was released.
        :param str version: The version of this patch package.
        """
        GetDbSystemPatchesPatchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            available_actions=available_actions,
            description=description,
            id=id,
            last_action=last_action,
            lifecycle_details=lifecycle_details,
            state=state,
            time_released=time_released,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             available_actions: Sequence[str],
             description: str,
             id: str,
             last_action: str,
             lifecycle_details: str,
             state: str,
             time_released: str,
             version: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("available_actions", available_actions)
        _setter("description", description)
        _setter("id", id)
        _setter("last_action", last_action)
        _setter("lifecycle_details", lifecycle_details)
        _setter("state", state)
        _setter("time_released", time_released)
        _setter("version", version)

    @property
    @pulumi.getter(name="availableActions")
    def available_actions(self) -> Sequence[str]:
        """
        Actions that can possibly be performed using this patch.
        """
        return pulumi.get(self, "available_actions")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The text describing this patch package.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastAction")
    def last_action(self) -> str:
        """
        Action that is currently being performed or was completed last.
        """
        return pulumi.get(self, "last_action")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A descriptive text associated with the lifecycleState. Typically can contain additional displayable text.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the patch as a result of lastAction.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeReleased")
    def time_released(self) -> str:
        """
        The date and time that the patch was released.
        """
        return pulumi.get(self, "time_released")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The version of this patch package.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetDbSystemShapesDbSystemShapeResult(dict):
    def __init__(__self__, *,
                 available_core_count: int,
                 available_core_count_per_node: int,
                 available_data_storage_in_tbs: int,
                 available_data_storage_per_server_in_tbs: float,
                 available_db_node_per_node_in_gbs: int,
                 available_db_node_storage_in_gbs: int,
                 available_memory_in_gbs: int,
                 available_memory_per_node_in_gbs: int,
                 core_count_increment: int,
                 max_storage_count: int,
                 maximum_node_count: int,
                 min_core_count_per_node: int,
                 min_data_storage_in_tbs: int,
                 min_db_node_storage_per_node_in_gbs: int,
                 min_memory_per_node_in_gbs: int,
                 min_storage_count: int,
                 minimum_core_count: int,
                 minimum_node_count: int,
                 name: str,
                 shape: str,
                 shape_family: str,
                 shape_type: str):
        """
        :param int available_core_count: The maximum number of CPU cores that can be enabled on the DB system for this shape.
        :param int available_core_count_per_node: The maximum number of CPU cores per database node that can be enabled for this shape. Only applicable to the flex Exadata shape, ExaCC Elastic shapes and VM Flex shapes.
        :param int available_data_storage_in_tbs: The maximum DATA storage that can be enabled for this shape.
        :param float available_data_storage_per_server_in_tbs: The maximum data storage available per storage server for this shape. Only applicable to ExaCC Elastic shapes.
        :param int available_db_node_per_node_in_gbs: The maximum Db Node storage available per database node for this shape. Only applicable to ExaCC Elastic shapes.
        :param int available_db_node_storage_in_gbs: The maximum Db Node storage that can be enabled for this shape.
        :param int available_memory_in_gbs: The maximum memory that can be enabled for this shape.
        :param int available_memory_per_node_in_gbs: The maximum memory available per database node for this shape. Only applicable to ExaCC Elastic shapes.
        :param int core_count_increment: The discrete number by which the CPU core count for this shape can be increased or decreased.
        :param int max_storage_count: The maximum number of Exadata storage servers available for the Exadata infrastructure.
        :param int maximum_node_count: The maximum number of compute servers available for this shape.
        :param int min_core_count_per_node: The minimum number of CPU cores that can be enabled per node for this shape.
        :param int min_data_storage_in_tbs: The minimum data storage that need be allocated for this shape.
        :param int min_db_node_storage_per_node_in_gbs: The minimum Db Node storage that need be allocated per node for this shape.
        :param int min_memory_per_node_in_gbs: The minimum memory that need be allocated per node for this shape.
        :param int min_storage_count: The minimum number of Exadata storage servers available for the Exadata infrastructure.
        :param int minimum_core_count: The minimum number of CPU cores that can be enabled on the DB system for this shape.
        :param int minimum_node_count: The minimum number of compute servers available for this shape.
        :param str name: The name of the shape used for the DB system.
        :param str shape: Deprecated. Use `name` instead of `shape`.
        :param str shape_family: The family of the shape used for the DB system.
        :param str shape_type: The shape type for the virtual machine DB system. Shape type is determined by CPU hardware. Valid values are `AMD` , `INTEL` or `INTEL_FLEX_X9`.
        """
        GetDbSystemShapesDbSystemShapeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            available_core_count=available_core_count,
            available_core_count_per_node=available_core_count_per_node,
            available_data_storage_in_tbs=available_data_storage_in_tbs,
            available_data_storage_per_server_in_tbs=available_data_storage_per_server_in_tbs,
            available_db_node_per_node_in_gbs=available_db_node_per_node_in_gbs,
            available_db_node_storage_in_gbs=available_db_node_storage_in_gbs,
            available_memory_in_gbs=available_memory_in_gbs,
            available_memory_per_node_in_gbs=available_memory_per_node_in_gbs,
            core_count_increment=core_count_increment,
            max_storage_count=max_storage_count,
            maximum_node_count=maximum_node_count,
            min_core_count_per_node=min_core_count_per_node,
            min_data_storage_in_tbs=min_data_storage_in_tbs,
            min_db_node_storage_per_node_in_gbs=min_db_node_storage_per_node_in_gbs,
            min_memory_per_node_in_gbs=min_memory_per_node_in_gbs,
            min_storage_count=min_storage_count,
            minimum_core_count=minimum_core_count,
            minimum_node_count=minimum_node_count,
            name=name,
            shape=shape,
            shape_family=shape_family,
            shape_type=shape_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             available_core_count: int,
             available_core_count_per_node: int,
             available_data_storage_in_tbs: int,
             available_data_storage_per_server_in_tbs: float,
             available_db_node_per_node_in_gbs: int,
             available_db_node_storage_in_gbs: int,
             available_memory_in_gbs: int,
             available_memory_per_node_in_gbs: int,
             core_count_increment: int,
             max_storage_count: int,
             maximum_node_count: int,
             min_core_count_per_node: int,
             min_data_storage_in_tbs: int,
             min_db_node_storage_per_node_in_gbs: int,
             min_memory_per_node_in_gbs: int,
             min_storage_count: int,
             minimum_core_count: int,
             minimum_node_count: int,
             name: str,
             shape: str,
             shape_family: str,
             shape_type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("available_core_count", available_core_count)
        _setter("available_core_count_per_node", available_core_count_per_node)
        _setter("available_data_storage_in_tbs", available_data_storage_in_tbs)
        _setter("available_data_storage_per_server_in_tbs", available_data_storage_per_server_in_tbs)
        _setter("available_db_node_per_node_in_gbs", available_db_node_per_node_in_gbs)
        _setter("available_db_node_storage_in_gbs", available_db_node_storage_in_gbs)
        _setter("available_memory_in_gbs", available_memory_in_gbs)
        _setter("available_memory_per_node_in_gbs", available_memory_per_node_in_gbs)
        _setter("core_count_increment", core_count_increment)
        _setter("max_storage_count", max_storage_count)
        _setter("maximum_node_count", maximum_node_count)
        _setter("min_core_count_per_node", min_core_count_per_node)
        _setter("min_data_storage_in_tbs", min_data_storage_in_tbs)
        _setter("min_db_node_storage_per_node_in_gbs", min_db_node_storage_per_node_in_gbs)
        _setter("min_memory_per_node_in_gbs", min_memory_per_node_in_gbs)
        _setter("min_storage_count", min_storage_count)
        _setter("minimum_core_count", minimum_core_count)
        _setter("minimum_node_count", minimum_node_count)
        _setter("name", name)
        _setter("shape", shape)
        _setter("shape_family", shape_family)
        _setter("shape_type", shape_type)

    @property
    @pulumi.getter(name="availableCoreCount")
    def available_core_count(self) -> int:
        """
        The maximum number of CPU cores that can be enabled on the DB system for this shape.
        """
        return pulumi.get(self, "available_core_count")

    @property
    @pulumi.getter(name="availableCoreCountPerNode")
    def available_core_count_per_node(self) -> int:
        """
        The maximum number of CPU cores per database node that can be enabled for this shape. Only applicable to the flex Exadata shape, ExaCC Elastic shapes and VM Flex shapes.
        """
        return pulumi.get(self, "available_core_count_per_node")

    @property
    @pulumi.getter(name="availableDataStorageInTbs")
    def available_data_storage_in_tbs(self) -> int:
        """
        The maximum DATA storage that can be enabled for this shape.
        """
        return pulumi.get(self, "available_data_storage_in_tbs")

    @property
    @pulumi.getter(name="availableDataStoragePerServerInTbs")
    def available_data_storage_per_server_in_tbs(self) -> float:
        """
        The maximum data storage available per storage server for this shape. Only applicable to ExaCC Elastic shapes.
        """
        return pulumi.get(self, "available_data_storage_per_server_in_tbs")

    @property
    @pulumi.getter(name="availableDbNodePerNodeInGbs")
    def available_db_node_per_node_in_gbs(self) -> int:
        """
        The maximum Db Node storage available per database node for this shape. Only applicable to ExaCC Elastic shapes.
        """
        return pulumi.get(self, "available_db_node_per_node_in_gbs")

    @property
    @pulumi.getter(name="availableDbNodeStorageInGbs")
    def available_db_node_storage_in_gbs(self) -> int:
        """
        The maximum Db Node storage that can be enabled for this shape.
        """
        return pulumi.get(self, "available_db_node_storage_in_gbs")

    @property
    @pulumi.getter(name="availableMemoryInGbs")
    def available_memory_in_gbs(self) -> int:
        """
        The maximum memory that can be enabled for this shape.
        """
        return pulumi.get(self, "available_memory_in_gbs")

    @property
    @pulumi.getter(name="availableMemoryPerNodeInGbs")
    def available_memory_per_node_in_gbs(self) -> int:
        """
        The maximum memory available per database node for this shape. Only applicable to ExaCC Elastic shapes.
        """
        return pulumi.get(self, "available_memory_per_node_in_gbs")

    @property
    @pulumi.getter(name="coreCountIncrement")
    def core_count_increment(self) -> int:
        """
        The discrete number by which the CPU core count for this shape can be increased or decreased.
        """
        return pulumi.get(self, "core_count_increment")

    @property
    @pulumi.getter(name="maxStorageCount")
    def max_storage_count(self) -> int:
        """
        The maximum number of Exadata storage servers available for the Exadata infrastructure.
        """
        return pulumi.get(self, "max_storage_count")

    @property
    @pulumi.getter(name="maximumNodeCount")
    def maximum_node_count(self) -> int:
        """
        The maximum number of compute servers available for this shape.
        """
        return pulumi.get(self, "maximum_node_count")

    @property
    @pulumi.getter(name="minCoreCountPerNode")
    def min_core_count_per_node(self) -> int:
        """
        The minimum number of CPU cores that can be enabled per node for this shape.
        """
        return pulumi.get(self, "min_core_count_per_node")

    @property
    @pulumi.getter(name="minDataStorageInTbs")
    def min_data_storage_in_tbs(self) -> int:
        """
        The minimum data storage that need be allocated for this shape.
        """
        return pulumi.get(self, "min_data_storage_in_tbs")

    @property
    @pulumi.getter(name="minDbNodeStoragePerNodeInGbs")
    def min_db_node_storage_per_node_in_gbs(self) -> int:
        """
        The minimum Db Node storage that need be allocated per node for this shape.
        """
        return pulumi.get(self, "min_db_node_storage_per_node_in_gbs")

    @property
    @pulumi.getter(name="minMemoryPerNodeInGbs")
    def min_memory_per_node_in_gbs(self) -> int:
        """
        The minimum memory that need be allocated per node for this shape.
        """
        return pulumi.get(self, "min_memory_per_node_in_gbs")

    @property
    @pulumi.getter(name="minStorageCount")
    def min_storage_count(self) -> int:
        """
        The minimum number of Exadata storage servers available for the Exadata infrastructure.
        """
        return pulumi.get(self, "min_storage_count")

    @property
    @pulumi.getter(name="minimumCoreCount")
    def minimum_core_count(self) -> int:
        """
        The minimum number of CPU cores that can be enabled on the DB system for this shape.
        """
        return pulumi.get(self, "minimum_core_count")

    @property
    @pulumi.getter(name="minimumNodeCount")
    def minimum_node_count(self) -> int:
        """
        The minimum number of compute servers available for this shape.
        """
        return pulumi.get(self, "minimum_node_count")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the shape used for the DB system.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def shape(self) -> str:
        """
        Deprecated. Use `name` instead of `shape`.
        """
        warnings.warn("""The 'shape' field has been deprecated. Please use 'name' instead.""", DeprecationWarning)
        pulumi.log.warn("""shape is deprecated: The 'shape' field has been deprecated. Please use 'name' instead.""")

        return pulumi.get(self, "shape")

    @property
    @pulumi.getter(name="shapeFamily")
    def shape_family(self) -> str:
        """
        The family of the shape used for the DB system.
        """
        return pulumi.get(self, "shape_family")

    @property
    @pulumi.getter(name="shapeType")
    def shape_type(self) -> str:
        """
        The shape type for the virtual machine DB system. Shape type is determined by CPU hardware. Valid values are `AMD` , `INTEL` or `INTEL_FLEX_X9`.
        """
        return pulumi.get(self, "shape_type")


@pulumi.output_type
class GetDbSystemShapesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the shape used for the DB system.
        """
        GetDbSystemShapesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the shape used for the DB system.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDbSystemStoragePerformancesDbSystemStoragePerformanceResult(dict):
    def __init__(__self__, *,
                 data_storage_performance_lists: Sequence['outputs.GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListResult'],
                 reco_storage_performance_lists: Sequence['outputs.GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListResult'],
                 shape_type: str):
        """
        :param Sequence['GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListArgs'] data_storage_performance_lists: List of storage performance for the DATA disks
        :param Sequence['GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListArgs'] reco_storage_performance_lists: List of storage performance for the RECO disks
        :param str shape_type: Optional. Filters the performance results by shape type.
        """
        GetDbSystemStoragePerformancesDbSystemStoragePerformanceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_storage_performance_lists=data_storage_performance_lists,
            reco_storage_performance_lists=reco_storage_performance_lists,
            shape_type=shape_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_storage_performance_lists: Sequence['outputs.GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListResult'],
             reco_storage_performance_lists: Sequence['outputs.GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListResult'],
             shape_type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_storage_performance_lists", data_storage_performance_lists)
        _setter("reco_storage_performance_lists", reco_storage_performance_lists)
        _setter("shape_type", shape_type)

    @property
    @pulumi.getter(name="dataStoragePerformanceLists")
    def data_storage_performance_lists(self) -> Sequence['outputs.GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListResult']:
        """
        List of storage performance for the DATA disks
        """
        return pulumi.get(self, "data_storage_performance_lists")

    @property
    @pulumi.getter(name="recoStoragePerformanceLists")
    def reco_storage_performance_lists(self) -> Sequence['outputs.GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListResult']:
        """
        List of storage performance for the RECO disks
        """
        return pulumi.get(self, "reco_storage_performance_lists")

    @property
    @pulumi.getter(name="shapeType")
    def shape_type(self) -> str:
        """
        Optional. Filters the performance results by shape type.
        """
        return pulumi.get(self, "shape_type")


@pulumi.output_type
class GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListResult(dict):
    def __init__(__self__, *,
                 balanced_disk_performances: Sequence['outputs.GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListBalancedDiskPerformanceResult'],
                 high_disk_performances: Sequence['outputs.GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListHighDiskPerformanceResult'],
                 size_in_gbs: int):
        """
        :param Sequence['GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListBalancedDiskPerformanceArgs'] balanced_disk_performances: Representation of disk performance detail parameters.
        :param Sequence['GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListHighDiskPerformanceArgs'] high_disk_performances: Representation of disk performance detail parameters.
        :param int size_in_gbs: Size in GBs.
        """
        GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            balanced_disk_performances=balanced_disk_performances,
            high_disk_performances=high_disk_performances,
            size_in_gbs=size_in_gbs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             balanced_disk_performances: Sequence['outputs.GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListBalancedDiskPerformanceResult'],
             high_disk_performances: Sequence['outputs.GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListHighDiskPerformanceResult'],
             size_in_gbs: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("balanced_disk_performances", balanced_disk_performances)
        _setter("high_disk_performances", high_disk_performances)
        _setter("size_in_gbs", size_in_gbs)

    @property
    @pulumi.getter(name="balancedDiskPerformances")
    def balanced_disk_performances(self) -> Sequence['outputs.GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListBalancedDiskPerformanceResult']:
        """
        Representation of disk performance detail parameters.
        """
        return pulumi.get(self, "balanced_disk_performances")

    @property
    @pulumi.getter(name="highDiskPerformances")
    def high_disk_performances(self) -> Sequence['outputs.GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListHighDiskPerformanceResult']:
        """
        Representation of disk performance detail parameters.
        """
        return pulumi.get(self, "high_disk_performances")

    @property
    @pulumi.getter(name="sizeInGbs")
    def size_in_gbs(self) -> int:
        """
        Size in GBs.
        """
        return pulumi.get(self, "size_in_gbs")


@pulumi.output_type
class GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListBalancedDiskPerformanceResult(dict):
    def __init__(__self__, *,
                 disk_iops: float,
                 disk_throughput_in_mbps: float):
        """
        :param float disk_iops: Disk IOPS in thousands.
        :param float disk_throughput_in_mbps: Disk Throughput in Mbps.
        """
        GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListBalancedDiskPerformanceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disk_iops=disk_iops,
            disk_throughput_in_mbps=disk_throughput_in_mbps,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disk_iops: float,
             disk_throughput_in_mbps: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("disk_iops", disk_iops)
        _setter("disk_throughput_in_mbps", disk_throughput_in_mbps)

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> float:
        """
        Disk IOPS in thousands.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="diskThroughputInMbps")
    def disk_throughput_in_mbps(self) -> float:
        """
        Disk Throughput in Mbps.
        """
        return pulumi.get(self, "disk_throughput_in_mbps")


@pulumi.output_type
class GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListHighDiskPerformanceResult(dict):
    def __init__(__self__, *,
                 disk_iops: float,
                 disk_throughput_in_mbps: float):
        """
        :param float disk_iops: Disk IOPS in thousands.
        :param float disk_throughput_in_mbps: Disk Throughput in Mbps.
        """
        GetDbSystemStoragePerformancesDbSystemStoragePerformanceDataStoragePerformanceListHighDiskPerformanceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disk_iops=disk_iops,
            disk_throughput_in_mbps=disk_throughput_in_mbps,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disk_iops: float,
             disk_throughput_in_mbps: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("disk_iops", disk_iops)
        _setter("disk_throughput_in_mbps", disk_throughput_in_mbps)

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> float:
        """
        Disk IOPS in thousands.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="diskThroughputInMbps")
    def disk_throughput_in_mbps(self) -> float:
        """
        Disk Throughput in Mbps.
        """
        return pulumi.get(self, "disk_throughput_in_mbps")


@pulumi.output_type
class GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListResult(dict):
    def __init__(__self__, *,
                 balanced_disk_performances: Sequence['outputs.GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListBalancedDiskPerformanceResult'],
                 high_disk_performances: Sequence['outputs.GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListHighDiskPerformanceResult'],
                 size_in_gbs: int):
        """
        :param Sequence['GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListBalancedDiskPerformanceArgs'] balanced_disk_performances: Representation of disk performance detail parameters.
        :param Sequence['GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListHighDiskPerformanceArgs'] high_disk_performances: Representation of disk performance detail parameters.
        :param int size_in_gbs: Size in GBs.
        """
        GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            balanced_disk_performances=balanced_disk_performances,
            high_disk_performances=high_disk_performances,
            size_in_gbs=size_in_gbs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             balanced_disk_performances: Sequence['outputs.GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListBalancedDiskPerformanceResult'],
             high_disk_performances: Sequence['outputs.GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListHighDiskPerformanceResult'],
             size_in_gbs: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("balanced_disk_performances", balanced_disk_performances)
        _setter("high_disk_performances", high_disk_performances)
        _setter("size_in_gbs", size_in_gbs)

    @property
    @pulumi.getter(name="balancedDiskPerformances")
    def balanced_disk_performances(self) -> Sequence['outputs.GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListBalancedDiskPerformanceResult']:
        """
        Representation of disk performance detail parameters.
        """
        return pulumi.get(self, "balanced_disk_performances")

    @property
    @pulumi.getter(name="highDiskPerformances")
    def high_disk_performances(self) -> Sequence['outputs.GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListHighDiskPerformanceResult']:
        """
        Representation of disk performance detail parameters.
        """
        return pulumi.get(self, "high_disk_performances")

    @property
    @pulumi.getter(name="sizeInGbs")
    def size_in_gbs(self) -> int:
        """
        Size in GBs.
        """
        return pulumi.get(self, "size_in_gbs")


@pulumi.output_type
class GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListBalancedDiskPerformanceResult(dict):
    def __init__(__self__, *,
                 disk_iops: float,
                 disk_throughput_in_mbps: float):
        """
        :param float disk_iops: Disk IOPS in thousands.
        :param float disk_throughput_in_mbps: Disk Throughput in Mbps.
        """
        GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListBalancedDiskPerformanceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disk_iops=disk_iops,
            disk_throughput_in_mbps=disk_throughput_in_mbps,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disk_iops: float,
             disk_throughput_in_mbps: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("disk_iops", disk_iops)
        _setter("disk_throughput_in_mbps", disk_throughput_in_mbps)

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> float:
        """
        Disk IOPS in thousands.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="diskThroughputInMbps")
    def disk_throughput_in_mbps(self) -> float:
        """
        Disk Throughput in Mbps.
        """
        return pulumi.get(self, "disk_throughput_in_mbps")


@pulumi.output_type
class GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListHighDiskPerformanceResult(dict):
    def __init__(__self__, *,
                 disk_iops: float,
                 disk_throughput_in_mbps: float):
        """
        :param float disk_iops: Disk IOPS in thousands.
        :param float disk_throughput_in_mbps: Disk Throughput in Mbps.
        """
        GetDbSystemStoragePerformancesDbSystemStoragePerformanceRecoStoragePerformanceListHighDiskPerformanceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disk_iops=disk_iops,
            disk_throughput_in_mbps=disk_throughput_in_mbps,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disk_iops: float,
             disk_throughput_in_mbps: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("disk_iops", disk_iops)
        _setter("disk_throughput_in_mbps", disk_throughput_in_mbps)

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> float:
        """
        Disk IOPS in thousands.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="diskThroughputInMbps")
    def disk_throughput_in_mbps(self) -> float:
        """
        Disk Throughput in Mbps.
        """
        return pulumi.get(self, "disk_throughput_in_mbps")


@pulumi.output_type
class GetDbSystemStoragePerformancesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDbSystemStoragePerformancesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDbSystemsDbSystemResult(dict):
    def __init__(__self__, *,
                 availability_domain: str,
                 backup_network_nsg_ids: Sequence[str],
                 backup_subnet_id: str,
                 cluster_name: str,
                 compartment_id: str,
                 cpu_core_count: int,
                 data_collection_options: Sequence['outputs.GetDbSystemsDbSystemDataCollectionOptionResult'],
                 data_storage_percentage: int,
                 data_storage_size_in_gb: int,
                 database_edition: str,
                 db_homes: Sequence['outputs.GetDbSystemsDbSystemDbHomeResult'],
                 db_system_options: Sequence['outputs.GetDbSystemsDbSystemDbSystemOptionResult'],
                 defined_tags: Mapping[str, Any],
                 disk_redundancy: str,
                 display_name: str,
                 domain: str,
                 fault_domains: Sequence[str],
                 freeform_tags: Mapping[str, Any],
                 hostname: str,
                 id: str,
                 iorm_config_caches: Sequence['outputs.GetDbSystemsDbSystemIormConfigCachResult'],
                 kms_key_id: str,
                 kms_key_version_id: str,
                 last_maintenance_run_id: str,
                 last_patch_history_entry_id: str,
                 license_model: str,
                 lifecycle_details: str,
                 listener_port: int,
                 maintenance_window_details: Sequence['outputs.GetDbSystemsDbSystemMaintenanceWindowDetailResult'],
                 maintenance_windows: Sequence['outputs.GetDbSystemsDbSystemMaintenanceWindowResult'],
                 memory_size_in_gbs: int,
                 next_maintenance_run_id: str,
                 node_count: int,
                 nsg_ids: Sequence[str],
                 os_version: str,
                 point_in_time_data_disk_clone_timestamp: str,
                 private_ip: str,
                 reco_storage_size_in_gb: int,
                 scan_dns_name: str,
                 scan_dns_record_id: str,
                 scan_ip_ids: Sequence[str],
                 shape: str,
                 source: str,
                 source_db_system_id: str,
                 sparse_diskgroup: bool,
                 ssh_public_keys: Sequence[str],
                 state: str,
                 storage_volume_performance_mode: str,
                 subnet_id: str,
                 time_created: str,
                 time_zone: str,
                 version: str,
                 vip_ids: Sequence[str],
                 zone_id: str):
        """
        :param str availability_domain: A filter to return only resources that match the given availability domain exactly.
        :param Sequence[str] backup_network_nsg_ids: A list of the [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the network security groups (NSGs) that the backup network of this DB system belongs to. Setting this to an empty array after the list is created removes the resource from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). Applicable only to Exadata systems.
        :param str backup_subnet_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup network subnet the DB system is associated with. Applicable only to Exadata DB systems.
        :param str cluster_name: The cluster name for Exadata and 2-node RAC virtual machine DB systems. The cluster name must begin with an alphabetic character, and may contain hyphens (-). Underscores (_) are not permitted. The cluster name can be no longer than 11 characters and is not case sensitive.
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param int cpu_core_count: The number of CPU cores enabled on the DB system.
        :param Sequence['GetDbSystemsDbSystemDataCollectionOptionArgs'] data_collection_options: Indicates user preferences for the various diagnostic collection options for the VM cluster/Cloud VM cluster/VMBM DBCS.
        :param int data_storage_percentage: The percentage assigned to DATA storage (user data and database files). The remaining percentage is assigned to RECO storage (database redo logs, archive logs, and recovery manager backups). Accepted values are 40 and 80. The default is 80 percent assigned to DATA storage. Not applicable for virtual machine DB systems. Required for BMDBs.
        :param int data_storage_size_in_gb: The data storage size, in gigabytes, that is currently available to the DB system. Applies only for virtual machine DB systems. Required for VMDBs.
        :param str database_edition: The Oracle Database edition that applies to all the databases on the DB system.
        :param Sequence['GetDbSystemsDbSystemDbSystemOptionArgs'] db_system_options: The DB system options.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str disk_redundancy: The type of redundancy configured for the DB system. NORMAL is 2-way redundancy. HIGH is 3-way redundancy.
        :param str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param str domain: The domain name for the DB system.
        :param Sequence[str] fault_domains: List of the Fault Domains in which this DB system is provisioned.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str hostname: The hostname for the DB system.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        :param str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param str last_maintenance_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance run.
        :param str last_patch_history_entry_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last patch history. This value is updated as soon as a patch operation starts.
        :param str license_model: The Oracle license model that applies to all the databases on the DB system. The default is LICENSE_INCLUDED.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param int listener_port: The port number configured for the listener on the DB system.
        :param Sequence['GetDbSystemsDbSystemMaintenanceWindowArgs'] maintenance_windows: The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        :param int memory_size_in_gbs: Memory allocated to the DB system, in gigabytes.
        :param str next_maintenance_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the next maintenance run.
        :param int node_count: The number of nodes in the DB system. For RAC DB systems, the value is greater than 1.
        :param Sequence[str] nsg_ids: The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the network security groups (NSGs) to which this resource belongs. Setting this to an empty list removes all resources from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). **NsgIds restrictions:**
               * A network security group (NSG) is optional for Autonomous Databases with private access. The nsgIds list can be empty.
        :param str os_version: The most recent OS Patch Version applied on the DB system.
        :param str point_in_time_data_disk_clone_timestamp: The point in time for a cloned database system when the data disks were cloned from the source database system, as described in [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        :param int reco_storage_size_in_gb: The RECO/REDO storage size, in gigabytes, that is currently allocated to the DB system. Applies only for virtual machine DB systems.
        :param str scan_dns_name: The FQDN of the DNS record for the SCAN IP addresses that are associated with the DB system.
        :param str scan_dns_record_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DNS record for the SCAN IP addresses that are associated with the DB system.
        :param Sequence[str] scan_ip_ids: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Single Client Access Name (SCAN) IP addresses associated with the DB system. SCAN IP addresses are typically used for load balancing and are not assigned to any interface. Oracle Clusterware directs the requests to the appropriate nodes in the cluster.
        :param str shape: The shape of the DB system. The shape determines resources to allocate to the DB system.
               * For virtual machine shapes, the number of CPU cores and memory
               * For bare metal and Exadata shapes, the number of CPU cores, storage, and memory
        :param str source_db_system_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        :param bool sparse_diskgroup: True, if Sparse Diskgroup is configured for Exadata dbsystem, False, if Sparse diskgroup was not configured. Only applied for Exadata shape.
        :param Sequence[str] ssh_public_keys: The public key portion of one or more key pairs used for SSH access to the DB system.
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        :param str storage_volume_performance_mode: The block storage volume performance level. Valid values are `BALANCED` and `HIGH_PERFORMANCE`. See [Block Volume Performance](https://docs.cloud.oracle.com/iaas/Content/Block/Concepts/blockvolumeperformance.htm) for more information.
        :param str subnet_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet the DB system is associated with.
        :param str time_created: The date and time the DB system was created.
        :param str time_zone: The time zone of the DB system. For details, see [DB System Time Zones](https://docs.cloud.oracle.com/iaas/Content/Database/References/timezones.htm).
        :param str version: The Oracle Database version of the DB system.
        :param Sequence[str] vip_ids: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the virtual IP (VIP) addresses associated with the DB system. The Cluster Ready Services (CRS) creates and maintains one VIP address for each node in the DB system to enable failover. If one node fails, the VIP is reassigned to another active node in the cluster.
        :param str zone_id: The OCID of the zone the DB system is associated with.
        """
        GetDbSystemsDbSystemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_domain=availability_domain,
            backup_network_nsg_ids=backup_network_nsg_ids,
            backup_subnet_id=backup_subnet_id,
            cluster_name=cluster_name,
            compartment_id=compartment_id,
            cpu_core_count=cpu_core_count,
            data_collection_options=data_collection_options,
            data_storage_percentage=data_storage_percentage,
            data_storage_size_in_gb=data_storage_size_in_gb,
            database_edition=database_edition,
            db_homes=db_homes,
            db_system_options=db_system_options,
            defined_tags=defined_tags,
            disk_redundancy=disk_redundancy,
            display_name=display_name,
            domain=domain,
            fault_domains=fault_domains,
            freeform_tags=freeform_tags,
            hostname=hostname,
            id=id,
            iorm_config_caches=iorm_config_caches,
            kms_key_id=kms_key_id,
            kms_key_version_id=kms_key_version_id,
            last_maintenance_run_id=last_maintenance_run_id,
            last_patch_history_entry_id=last_patch_history_entry_id,
            license_model=license_model,
            lifecycle_details=lifecycle_details,
            listener_port=listener_port,
            maintenance_window_details=maintenance_window_details,
            maintenance_windows=maintenance_windows,
            memory_size_in_gbs=memory_size_in_gbs,
            next_maintenance_run_id=next_maintenance_run_id,
            node_count=node_count,
            nsg_ids=nsg_ids,
            os_version=os_version,
            point_in_time_data_disk_clone_timestamp=point_in_time_data_disk_clone_timestamp,
            private_ip=private_ip,
            reco_storage_size_in_gb=reco_storage_size_in_gb,
            scan_dns_name=scan_dns_name,
            scan_dns_record_id=scan_dns_record_id,
            scan_ip_ids=scan_ip_ids,
            shape=shape,
            source=source,
            source_db_system_id=source_db_system_id,
            sparse_diskgroup=sparse_diskgroup,
            ssh_public_keys=ssh_public_keys,
            state=state,
            storage_volume_performance_mode=storage_volume_performance_mode,
            subnet_id=subnet_id,
            time_created=time_created,
            time_zone=time_zone,
            version=version,
            vip_ids=vip_ids,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_domain: str,
             backup_network_nsg_ids: Sequence[str],
             backup_subnet_id: str,
             cluster_name: str,
             compartment_id: str,
             cpu_core_count: int,
             data_collection_options: Sequence['outputs.GetDbSystemsDbSystemDataCollectionOptionResult'],
             data_storage_percentage: int,
             data_storage_size_in_gb: int,
             database_edition: str,
             db_homes: Sequence['outputs.GetDbSystemsDbSystemDbHomeResult'],
             db_system_options: Sequence['outputs.GetDbSystemsDbSystemDbSystemOptionResult'],
             defined_tags: Mapping[str, Any],
             disk_redundancy: str,
             display_name: str,
             domain: str,
             fault_domains: Sequence[str],
             freeform_tags: Mapping[str, Any],
             hostname: str,
             id: str,
             iorm_config_caches: Sequence['outputs.GetDbSystemsDbSystemIormConfigCachResult'],
             kms_key_id: str,
             kms_key_version_id: str,
             last_maintenance_run_id: str,
             last_patch_history_entry_id: str,
             license_model: str,
             lifecycle_details: str,
             listener_port: int,
             maintenance_window_details: Sequence['outputs.GetDbSystemsDbSystemMaintenanceWindowDetailResult'],
             maintenance_windows: Sequence['outputs.GetDbSystemsDbSystemMaintenanceWindowResult'],
             memory_size_in_gbs: int,
             next_maintenance_run_id: str,
             node_count: int,
             nsg_ids: Sequence[str],
             os_version: str,
             point_in_time_data_disk_clone_timestamp: str,
             private_ip: str,
             reco_storage_size_in_gb: int,
             scan_dns_name: str,
             scan_dns_record_id: str,
             scan_ip_ids: Sequence[str],
             shape: str,
             source: str,
             source_db_system_id: str,
             sparse_diskgroup: bool,
             ssh_public_keys: Sequence[str],
             state: str,
             storage_volume_performance_mode: str,
             subnet_id: str,
             time_created: str,
             time_zone: str,
             version: str,
             vip_ids: Sequence[str],
             zone_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("availability_domain", availability_domain)
        _setter("backup_network_nsg_ids", backup_network_nsg_ids)
        _setter("backup_subnet_id", backup_subnet_id)
        _setter("cluster_name", cluster_name)
        _setter("compartment_id", compartment_id)
        _setter("cpu_core_count", cpu_core_count)
        _setter("data_collection_options", data_collection_options)
        _setter("data_storage_percentage", data_storage_percentage)
        _setter("data_storage_size_in_gb", data_storage_size_in_gb)
        _setter("database_edition", database_edition)
        _setter("db_homes", db_homes)
        _setter("db_system_options", db_system_options)
        _setter("defined_tags", defined_tags)
        _setter("disk_redundancy", disk_redundancy)
        _setter("display_name", display_name)
        _setter("domain", domain)
        _setter("fault_domains", fault_domains)
        _setter("freeform_tags", freeform_tags)
        _setter("hostname", hostname)
        _setter("id", id)
        _setter("iorm_config_caches", iorm_config_caches)
        _setter("kms_key_id", kms_key_id)
        _setter("kms_key_version_id", kms_key_version_id)
        _setter("last_maintenance_run_id", last_maintenance_run_id)
        _setter("last_patch_history_entry_id", last_patch_history_entry_id)
        _setter("license_model", license_model)
        _setter("lifecycle_details", lifecycle_details)
        _setter("listener_port", listener_port)
        _setter("maintenance_window_details", maintenance_window_details)
        _setter("maintenance_windows", maintenance_windows)
        _setter("memory_size_in_gbs", memory_size_in_gbs)
        _setter("next_maintenance_run_id", next_maintenance_run_id)
        _setter("node_count", node_count)
        _setter("nsg_ids", nsg_ids)
        _setter("os_version", os_version)
        _setter("point_in_time_data_disk_clone_timestamp", point_in_time_data_disk_clone_timestamp)
        _setter("private_ip", private_ip)
        _setter("reco_storage_size_in_gb", reco_storage_size_in_gb)
        _setter("scan_dns_name", scan_dns_name)
        _setter("scan_dns_record_id", scan_dns_record_id)
        _setter("scan_ip_ids", scan_ip_ids)
        _setter("shape", shape)
        _setter("source", source)
        _setter("source_db_system_id", source_db_system_id)
        _setter("sparse_diskgroup", sparse_diskgroup)
        _setter("ssh_public_keys", ssh_public_keys)
        _setter("state", state)
        _setter("storage_volume_performance_mode", storage_volume_performance_mode)
        _setter("subnet_id", subnet_id)
        _setter("time_created", time_created)
        _setter("time_zone", time_zone)
        _setter("version", version)
        _setter("vip_ids", vip_ids)
        _setter("zone_id", zone_id)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> str:
        """
        A filter to return only resources that match the given availability domain exactly.
        """
        return pulumi.get(self, "availability_domain")

    @property
    @pulumi.getter(name="backupNetworkNsgIds")
    def backup_network_nsg_ids(self) -> Sequence[str]:
        """
        A list of the [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the network security groups (NSGs) that the backup network of this DB system belongs to. Setting this to an empty array after the list is created removes the resource from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). Applicable only to Exadata systems.
        """
        return pulumi.get(self, "backup_network_nsg_ids")

    @property
    @pulumi.getter(name="backupSubnetId")
    def backup_subnet_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup network subnet the DB system is associated with. Applicable only to Exadata DB systems.
        """
        return pulumi.get(self, "backup_subnet_id")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        The cluster name for Exadata and 2-node RAC virtual machine DB systems. The cluster name must begin with an alphabetic character, and may contain hyphens (-). Underscores (_) are not permitted. The cluster name can be no longer than 11 characters and is not case sensitive.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="cpuCoreCount")
    def cpu_core_count(self) -> int:
        """
        The number of CPU cores enabled on the DB system.
        """
        return pulumi.get(self, "cpu_core_count")

    @property
    @pulumi.getter(name="dataCollectionOptions")
    def data_collection_options(self) -> Sequence['outputs.GetDbSystemsDbSystemDataCollectionOptionResult']:
        """
        Indicates user preferences for the various diagnostic collection options for the VM cluster/Cloud VM cluster/VMBM DBCS.
        """
        return pulumi.get(self, "data_collection_options")

    @property
    @pulumi.getter(name="dataStoragePercentage")
    def data_storage_percentage(self) -> int:
        """
        The percentage assigned to DATA storage (user data and database files). The remaining percentage is assigned to RECO storage (database redo logs, archive logs, and recovery manager backups). Accepted values are 40 and 80. The default is 80 percent assigned to DATA storage. Not applicable for virtual machine DB systems. Required for BMDBs.
        """
        return pulumi.get(self, "data_storage_percentage")

    @property
    @pulumi.getter(name="dataStorageSizeInGb")
    def data_storage_size_in_gb(self) -> int:
        """
        The data storage size, in gigabytes, that is currently available to the DB system. Applies only for virtual machine DB systems. Required for VMDBs.
        """
        return pulumi.get(self, "data_storage_size_in_gb")

    @property
    @pulumi.getter(name="databaseEdition")
    def database_edition(self) -> str:
        """
        The Oracle Database edition that applies to all the databases on the DB system.
        """
        return pulumi.get(self, "database_edition")

    @property
    @pulumi.getter(name="dbHomes")
    def db_homes(self) -> Sequence['outputs.GetDbSystemsDbSystemDbHomeResult']:
        return pulumi.get(self, "db_homes")

    @property
    @pulumi.getter(name="dbSystemOptions")
    def db_system_options(self) -> Sequence['outputs.GetDbSystemsDbSystemDbSystemOptionResult']:
        """
        The DB system options.
        """
        return pulumi.get(self, "db_system_options")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="diskRedundancy")
    def disk_redundancy(self) -> str:
        """
        The type of redundancy configured for the DB system. NORMAL is 2-way redundancy. HIGH is 3-way redundancy.
        """
        return pulumi.get(self, "disk_redundancy")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The domain name for the DB system.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="faultDomains")
    def fault_domains(self) -> Sequence[str]:
        """
        List of the Fault Domains in which this DB system is provisioned.
        """
        return pulumi.get(self, "fault_domains")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The hostname for the DB system.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="iormConfigCaches")
    def iorm_config_caches(self) -> Sequence['outputs.GetDbSystemsDbSystemIormConfigCachResult']:
        return pulumi.get(self, "iorm_config_caches")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> str:
        return pulumi.get(self, "kms_key_version_id")

    @property
    @pulumi.getter(name="lastMaintenanceRunId")
    def last_maintenance_run_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last maintenance run.
        """
        return pulumi.get(self, "last_maintenance_run_id")

    @property
    @pulumi.getter(name="lastPatchHistoryEntryId")
    def last_patch_history_entry_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last patch history. This value is updated as soon as a patch operation starts.
        """
        return pulumi.get(self, "last_patch_history_entry_id")

    @property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> str:
        """
        The Oracle license model that applies to all the databases on the DB system. The default is LICENSE_INCLUDED.
        """
        return pulumi.get(self, "license_model")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="listenerPort")
    def listener_port(self) -> int:
        """
        The port number configured for the listener on the DB system.
        """
        return pulumi.get(self, "listener_port")

    @property
    @pulumi.getter(name="maintenanceWindowDetails")
    def maintenance_window_details(self) -> Sequence['outputs.GetDbSystemsDbSystemMaintenanceWindowDetailResult']:
        return pulumi.get(self, "maintenance_window_details")

    @property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Sequence['outputs.GetDbSystemsDbSystemMaintenanceWindowResult']:
        """
        The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        """
        return pulumi.get(self, "maintenance_windows")

    @property
    @pulumi.getter(name="memorySizeInGbs")
    def memory_size_in_gbs(self) -> int:
        """
        Memory allocated to the DB system, in gigabytes.
        """
        return pulumi.get(self, "memory_size_in_gbs")

    @property
    @pulumi.getter(name="nextMaintenanceRunId")
    def next_maintenance_run_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the next maintenance run.
        """
        return pulumi.get(self, "next_maintenance_run_id")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> int:
        """
        The number of nodes in the DB system. For RAC DB systems, the value is greater than 1.
        """
        return pulumi.get(self, "node_count")

    @property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Sequence[str]:
        """
        The list of [OCIDs](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the network security groups (NSGs) to which this resource belongs. Setting this to an empty list removes all resources from all NSGs. For more information about NSGs, see [Security Rules](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/securityrules.htm). **NsgIds restrictions:**
        * A network security group (NSG) is optional for Autonomous Databases with private access. The nsgIds list can be empty.
        """
        return pulumi.get(self, "nsg_ids")

    @property
    @pulumi.getter(name="osVersion")
    def os_version(self) -> str:
        """
        The most recent OS Patch Version applied on the DB system.
        """
        return pulumi.get(self, "os_version")

    @property
    @pulumi.getter(name="pointInTimeDataDiskCloneTimestamp")
    def point_in_time_data_disk_clone_timestamp(self) -> str:
        """
        The point in time for a cloned database system when the data disks were cloned from the source database system, as described in [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        """
        return pulumi.get(self, "point_in_time_data_disk_clone_timestamp")

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> str:
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter(name="recoStorageSizeInGb")
    def reco_storage_size_in_gb(self) -> int:
        """
        The RECO/REDO storage size, in gigabytes, that is currently allocated to the DB system. Applies only for virtual machine DB systems.
        """
        return pulumi.get(self, "reco_storage_size_in_gb")

    @property
    @pulumi.getter(name="scanDnsName")
    def scan_dns_name(self) -> str:
        """
        The FQDN of the DNS record for the SCAN IP addresses that are associated with the DB system.
        """
        return pulumi.get(self, "scan_dns_name")

    @property
    @pulumi.getter(name="scanDnsRecordId")
    def scan_dns_record_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DNS record for the SCAN IP addresses that are associated with the DB system.
        """
        return pulumi.get(self, "scan_dns_record_id")

    @property
    @pulumi.getter(name="scanIpIds")
    def scan_ip_ids(self) -> Sequence[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Single Client Access Name (SCAN) IP addresses associated with the DB system. SCAN IP addresses are typically used for load balancing and are not assigned to any interface. Oracle Clusterware directs the requests to the appropriate nodes in the cluster.
        """
        return pulumi.get(self, "scan_ip_ids")

    @property
    @pulumi.getter
    def shape(self) -> str:
        """
        The shape of the DB system. The shape determines resources to allocate to the DB system.
        * For virtual machine shapes, the number of CPU cores and memory
        * For bare metal and Exadata shapes, the number of CPU cores, storage, and memory
        """
        return pulumi.get(self, "shape")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="sourceDbSystemId")
    def source_db_system_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        """
        return pulumi.get(self, "source_db_system_id")

    @property
    @pulumi.getter(name="sparseDiskgroup")
    def sparse_diskgroup(self) -> bool:
        """
        True, if Sparse Diskgroup is configured for Exadata dbsystem, False, if Sparse diskgroup was not configured. Only applied for Exadata shape.
        """
        return pulumi.get(self, "sparse_diskgroup")

    @property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Sequence[str]:
        """
        The public key portion of one or more key pairs used for SSH access to the DB system.
        """
        return pulumi.get(self, "ssh_public_keys")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="storageVolumePerformanceMode")
    def storage_volume_performance_mode(self) -> str:
        """
        The block storage volume performance level. Valid values are `BALANCED` and `HIGH_PERFORMANCE`. See [Block Volume Performance](https://docs.cloud.oracle.com/iaas/Content/Block/Concepts/blockvolumeperformance.htm) for more information.
        """
        return pulumi.get(self, "storage_volume_performance_mode")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet the DB system is associated with.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the DB system was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        """
        The time zone of the DB system. For details, see [DB System Time Zones](https://docs.cloud.oracle.com/iaas/Content/Database/References/timezones.htm).
        """
        return pulumi.get(self, "time_zone")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The Oracle Database version of the DB system.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="vipIds")
    def vip_ids(self) -> Sequence[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the virtual IP (VIP) addresses associated with the DB system. The Cluster Ready Services (CRS) creates and maintains one VIP address for each node in the DB system to enable failover. If one node fails, the VIP is reassigned to another active node in the cluster.
        """
        return pulumi.get(self, "vip_ids")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        The OCID of the zone the DB system is associated with.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetDbSystemsDbSystemDataCollectionOptionResult(dict):
    def __init__(__self__, *,
                 is_diagnostics_events_enabled: bool,
                 is_health_monitoring_enabled: bool,
                 is_incident_logs_enabled: bool):
        """
        :param bool is_diagnostics_events_enabled: Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param bool is_health_monitoring_enabled: Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param bool is_incident_logs_enabled: Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        GetDbSystemsDbSystemDataCollectionOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_diagnostics_events_enabled=is_diagnostics_events_enabled,
            is_health_monitoring_enabled=is_health_monitoring_enabled,
            is_incident_logs_enabled=is_incident_logs_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_diagnostics_events_enabled: bool,
             is_health_monitoring_enabled: bool,
             is_incident_logs_enabled: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        _setter("is_health_monitoring_enabled", is_health_monitoring_enabled)
        _setter("is_incident_logs_enabled", is_incident_logs_enabled)

    @property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> bool:
        """
        Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> bool:
        """
        Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> bool:
        """
        Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")


@pulumi.output_type
class GetDbSystemsDbSystemDbHomeResult(dict):
    def __init__(__self__, *,
                 create_async: bool,
                 database_software_image_id: str,
                 databases: Sequence['outputs.GetDbSystemsDbSystemDbHomeDatabaseResult'],
                 db_home_location: str,
                 db_version: str,
                 defined_tags: Mapping[str, Any],
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 last_patch_history_entry_id: str,
                 lifecycle_details: str,
                 state: str,
                 time_created: str):
        """
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        :param str last_patch_history_entry_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last patch history. This value is updated as soon as a patch operation starts.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        :param str time_created: The date and time the DB system was created.
        """
        GetDbSystemsDbSystemDbHomeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            create_async=create_async,
            database_software_image_id=database_software_image_id,
            databases=databases,
            db_home_location=db_home_location,
            db_version=db_version,
            defined_tags=defined_tags,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            last_patch_history_entry_id=last_patch_history_entry_id,
            lifecycle_details=lifecycle_details,
            state=state,
            time_created=time_created,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             create_async: bool,
             database_software_image_id: str,
             databases: Sequence['outputs.GetDbSystemsDbSystemDbHomeDatabaseResult'],
             db_home_location: str,
             db_version: str,
             defined_tags: Mapping[str, Any],
             display_name: str,
             freeform_tags: Mapping[str, Any],
             id: str,
             last_patch_history_entry_id: str,
             lifecycle_details: str,
             state: str,
             time_created: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("create_async", create_async)
        _setter("database_software_image_id", database_software_image_id)
        _setter("databases", databases)
        _setter("db_home_location", db_home_location)
        _setter("db_version", db_version)
        _setter("defined_tags", defined_tags)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("last_patch_history_entry_id", last_patch_history_entry_id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("state", state)
        _setter("time_created", time_created)

    @property
    @pulumi.getter(name="createAsync")
    def create_async(self) -> bool:
        return pulumi.get(self, "create_async")

    @property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> str:
        return pulumi.get(self, "database_software_image_id")

    @property
    @pulumi.getter
    def databases(self) -> Sequence['outputs.GetDbSystemsDbSystemDbHomeDatabaseResult']:
        return pulumi.get(self, "databases")

    @property
    @pulumi.getter(name="dbHomeLocation")
    def db_home_location(self) -> str:
        return pulumi.get(self, "db_home_location")

    @property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> str:
        return pulumi.get(self, "db_version")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastPatchHistoryEntryId")
    def last_patch_history_entry_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last patch history. This value is updated as soon as a patch operation starts.
        """
        return pulumi.get(self, "last_patch_history_entry_id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the DB system was created.
        """
        return pulumi.get(self, "time_created")


@pulumi.output_type
class GetDbSystemsDbSystemDbHomeDatabaseResult(dict):
    def __init__(__self__, *,
                 admin_password: str,
                 backup_id: str,
                 backup_tde_password: str,
                 character_set: str,
                 connection_strings: Sequence['outputs.GetDbSystemsDbSystemDbHomeDatabaseConnectionStringResult'],
                 database_id: str,
                 database_software_image_id: str,
                 db_backup_configs: Sequence['outputs.GetDbSystemsDbSystemDbHomeDatabaseDbBackupConfigResult'],
                 db_domain: str,
                 db_name: str,
                 db_unique_name: str,
                 db_workload: str,
                 defined_tags: Mapping[str, Any],
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 kms_key_id: str,
                 kms_key_version_id: str,
                 lifecycle_details: str,
                 ncharacter_set: str,
                 pdb_name: str,
                 state: str,
                 tde_wallet_password: str,
                 time_created: str,
                 time_stamp_for_point_in_time_recovery: str,
                 vault_id: str):
        """
        :param str backup_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup. Specify a backupId to list only the DB systems or DB homes that support creating a database using this backup in this compartment.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        :param str kms_key_id: The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        :param str time_created: The date and time the DB system was created.
        """
        GetDbSystemsDbSystemDbHomeDatabaseResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            admin_password=admin_password,
            backup_id=backup_id,
            backup_tde_password=backup_tde_password,
            character_set=character_set,
            connection_strings=connection_strings,
            database_id=database_id,
            database_software_image_id=database_software_image_id,
            db_backup_configs=db_backup_configs,
            db_domain=db_domain,
            db_name=db_name,
            db_unique_name=db_unique_name,
            db_workload=db_workload,
            defined_tags=defined_tags,
            freeform_tags=freeform_tags,
            id=id,
            kms_key_id=kms_key_id,
            kms_key_version_id=kms_key_version_id,
            lifecycle_details=lifecycle_details,
            ncharacter_set=ncharacter_set,
            pdb_name=pdb_name,
            state=state,
            tde_wallet_password=tde_wallet_password,
            time_created=time_created,
            time_stamp_for_point_in_time_recovery=time_stamp_for_point_in_time_recovery,
            vault_id=vault_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             admin_password: str,
             backup_id: str,
             backup_tde_password: str,
             character_set: str,
             connection_strings: Sequence['outputs.GetDbSystemsDbSystemDbHomeDatabaseConnectionStringResult'],
             database_id: str,
             database_software_image_id: str,
             db_backup_configs: Sequence['outputs.GetDbSystemsDbSystemDbHomeDatabaseDbBackupConfigResult'],
             db_domain: str,
             db_name: str,
             db_unique_name: str,
             db_workload: str,
             defined_tags: Mapping[str, Any],
             freeform_tags: Mapping[str, Any],
             id: str,
             kms_key_id: str,
             kms_key_version_id: str,
             lifecycle_details: str,
             ncharacter_set: str,
             pdb_name: str,
             state: str,
             tde_wallet_password: str,
             time_created: str,
             time_stamp_for_point_in_time_recovery: str,
             vault_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("admin_password", admin_password)
        _setter("backup_id", backup_id)
        _setter("backup_tde_password", backup_tde_password)
        _setter("character_set", character_set)
        _setter("connection_strings", connection_strings)
        _setter("database_id", database_id)
        _setter("database_software_image_id", database_software_image_id)
        _setter("db_backup_configs", db_backup_configs)
        _setter("db_domain", db_domain)
        _setter("db_name", db_name)
        _setter("db_unique_name", db_unique_name)
        _setter("db_workload", db_workload)
        _setter("defined_tags", defined_tags)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("kms_key_id", kms_key_id)
        _setter("kms_key_version_id", kms_key_version_id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("ncharacter_set", ncharacter_set)
        _setter("pdb_name", pdb_name)
        _setter("state", state)
        _setter("tde_wallet_password", tde_wallet_password)
        _setter("time_created", time_created)
        _setter("time_stamp_for_point_in_time_recovery", time_stamp_for_point_in_time_recovery)
        _setter("vault_id", vault_id)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> str:
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup. Specify a backupId to list only the DB systems or DB homes that support creating a database using this backup in this compartment.
        """
        return pulumi.get(self, "backup_id")

    @property
    @pulumi.getter(name="backupTdePassword")
    def backup_tde_password(self) -> str:
        return pulumi.get(self, "backup_tde_password")

    @property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> str:
        return pulumi.get(self, "character_set")

    @property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Sequence['outputs.GetDbSystemsDbSystemDbHomeDatabaseConnectionStringResult']:
        return pulumi.get(self, "connection_strings")

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> str:
        return pulumi.get(self, "database_id")

    @property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> str:
        return pulumi.get(self, "database_software_image_id")

    @property
    @pulumi.getter(name="dbBackupConfigs")
    def db_backup_configs(self) -> Sequence['outputs.GetDbSystemsDbSystemDbHomeDatabaseDbBackupConfigResult']:
        return pulumi.get(self, "db_backup_configs")

    @property
    @pulumi.getter(name="dbDomain")
    def db_domain(self) -> str:
        return pulumi.get(self, "db_domain")

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> str:
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> str:
        return pulumi.get(self, "db_unique_name")

    @property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> str:
        return pulumi.get(self, "db_workload")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> str:
        """
        The OCID of the key container that is used as the master encryption key in database transparent data encryption (TDE) operations.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="kmsKeyVersionId")
    def kms_key_version_id(self) -> str:
        return pulumi.get(self, "kms_key_version_id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> str:
        return pulumi.get(self, "ncharacter_set")

    @property
    @pulumi.getter(name="pdbName")
    def pdb_name(self) -> str:
        return pulumi.get(self, "pdb_name")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="tdeWalletPassword")
    def tde_wallet_password(self) -> str:
        return pulumi.get(self, "tde_wallet_password")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the DB system was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeStampForPointInTimeRecovery")
    def time_stamp_for_point_in_time_recovery(self) -> str:
        return pulumi.get(self, "time_stamp_for_point_in_time_recovery")

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> str:
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class GetDbSystemsDbSystemDbHomeDatabaseConnectionStringResult(dict):
    def __init__(__self__, *,
                 all_connection_strings: Mapping[str, Any],
                 cdb_default: str,
                 cdb_ip_default: str):
        GetDbSystemsDbSystemDbHomeDatabaseConnectionStringResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_connection_strings=all_connection_strings,
            cdb_default=cdb_default,
            cdb_ip_default=cdb_ip_default,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_connection_strings: Mapping[str, Any],
             cdb_default: str,
             cdb_ip_default: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("all_connection_strings", all_connection_strings)
        _setter("cdb_default", cdb_default)
        _setter("cdb_ip_default", cdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Mapping[str, Any]:
        return pulumi.get(self, "all_connection_strings")

    @property
    @pulumi.getter(name="cdbDefault")
    def cdb_default(self) -> str:
        return pulumi.get(self, "cdb_default")

    @property
    @pulumi.getter(name="cdbIpDefault")
    def cdb_ip_default(self) -> str:
        return pulumi.get(self, "cdb_ip_default")


@pulumi.output_type
class GetDbSystemsDbSystemDbHomeDatabaseDbBackupConfigResult(dict):
    def __init__(__self__, *,
                 auto_backup_enabled: bool,
                 auto_backup_window: str,
                 auto_full_backup_day: str,
                 auto_full_backup_window: str,
                 backup_deletion_policy: str,
                 backup_destination_details: Sequence['outputs.GetDbSystemsDbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailResult'],
                 recovery_window_in_days: int,
                 run_immediate_full_backup: bool):
        GetDbSystemsDbSystemDbHomeDatabaseDbBackupConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_backup_enabled=auto_backup_enabled,
            auto_backup_window=auto_backup_window,
            auto_full_backup_day=auto_full_backup_day,
            auto_full_backup_window=auto_full_backup_window,
            backup_deletion_policy=backup_deletion_policy,
            backup_destination_details=backup_destination_details,
            recovery_window_in_days=recovery_window_in_days,
            run_immediate_full_backup=run_immediate_full_backup,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_backup_enabled: bool,
             auto_backup_window: str,
             auto_full_backup_day: str,
             auto_full_backup_window: str,
             backup_deletion_policy: str,
             backup_destination_details: Sequence['outputs.GetDbSystemsDbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailResult'],
             recovery_window_in_days: int,
             run_immediate_full_backup: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("auto_backup_enabled", auto_backup_enabled)
        _setter("auto_backup_window", auto_backup_window)
        _setter("auto_full_backup_day", auto_full_backup_day)
        _setter("auto_full_backup_window", auto_full_backup_window)
        _setter("backup_deletion_policy", backup_deletion_policy)
        _setter("backup_destination_details", backup_destination_details)
        _setter("recovery_window_in_days", recovery_window_in_days)
        _setter("run_immediate_full_backup", run_immediate_full_backup)

    @property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> bool:
        return pulumi.get(self, "auto_backup_enabled")

    @property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> str:
        return pulumi.get(self, "auto_backup_window")

    @property
    @pulumi.getter(name="autoFullBackupDay")
    def auto_full_backup_day(self) -> str:
        return pulumi.get(self, "auto_full_backup_day")

    @property
    @pulumi.getter(name="autoFullBackupWindow")
    def auto_full_backup_window(self) -> str:
        return pulumi.get(self, "auto_full_backup_window")

    @property
    @pulumi.getter(name="backupDeletionPolicy")
    def backup_deletion_policy(self) -> str:
        return pulumi.get(self, "backup_deletion_policy")

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Sequence['outputs.GetDbSystemsDbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailResult']:
        return pulumi.get(self, "backup_destination_details")

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> int:
        return pulumi.get(self, "recovery_window_in_days")

    @property
    @pulumi.getter(name="runImmediateFullBackup")
    def run_immediate_full_backup(self) -> bool:
        return pulumi.get(self, "run_immediate_full_backup")


@pulumi.output_type
class GetDbSystemsDbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailResult(dict):
    def __init__(__self__, *,
                 dbrs_policy_id: str,
                 id: str,
                 type: str):
        """
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        """
        GetDbSystemsDbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dbrs_policy_id=dbrs_policy_id,
            id=id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dbrs_policy_id: str,
             id: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("dbrs_policy_id", dbrs_policy_id)
        _setter("id", id)
        _setter("type", type)

    @property
    @pulumi.getter(name="dbrsPolicyId")
    def dbrs_policy_id(self) -> str:
        return pulumi.get(self, "dbrs_policy_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DB system.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDbSystemsDbSystemDbSystemOptionResult(dict):
    def __init__(__self__, *,
                 storage_management: str):
        """
        :param str storage_management: The storage option used in DB system. ASM - Automatic storage management LVM - Logical Volume management
        """
        GetDbSystemsDbSystemDbSystemOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            storage_management=storage_management,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             storage_management: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("storage_management", storage_management)

    @property
    @pulumi.getter(name="storageManagement")
    def storage_management(self) -> str:
        """
        The storage option used in DB system. ASM - Automatic storage management LVM - Logical Volume management
        """
        return pulumi.get(self, "storage_management")


@pulumi.output_type
class GetDbSystemsDbSystemIormConfigCachResult(dict):
    def __init__(__self__, *,
                 db_plans: Sequence['outputs.GetDbSystemsDbSystemIormConfigCachDbPlanResult'],
                 db_system_id: str,
                 lifecycle_details: str,
                 objective: str,
                 state: str):
        """
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        """
        GetDbSystemsDbSystemIormConfigCachResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_plans=db_plans,
            db_system_id=db_system_id,
            lifecycle_details=lifecycle_details,
            objective=objective,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_plans: Sequence['outputs.GetDbSystemsDbSystemIormConfigCachDbPlanResult'],
             db_system_id: str,
             lifecycle_details: str,
             objective: str,
             state: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("db_plans", db_plans)
        _setter("db_system_id", db_system_id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("objective", objective)
        _setter("state", state)

    @property
    @pulumi.getter(name="dbPlans")
    def db_plans(self) -> Sequence['outputs.GetDbSystemsDbSystemIormConfigCachDbPlanResult']:
        return pulumi.get(self, "db_plans")

    @property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> str:
        return pulumi.get(self, "db_system_id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def objective(self) -> str:
        return pulumi.get(self, "objective")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetDbSystemsDbSystemIormConfigCachDbPlanResult(dict):
    def __init__(__self__, *,
                 db_name: str,
                 flash_cache_limit: str,
                 share: int):
        GetDbSystemsDbSystemIormConfigCachDbPlanResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_name=db_name,
            flash_cache_limit=flash_cache_limit,
            share=share,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_name: str,
             flash_cache_limit: str,
             share: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("db_name", db_name)
        _setter("flash_cache_limit", flash_cache_limit)
        _setter("share", share)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> str:
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> str:
        return pulumi.get(self, "flash_cache_limit")

    @property
    @pulumi.getter
    def share(self) -> int:
        return pulumi.get(self, "share")


@pulumi.output_type
class GetDbSystemsDbSystemMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: int,
                 days_of_weeks: Sequence['outputs.GetDbSystemsDbSystemMaintenanceWindowDaysOfWeekResult'],
                 hours_of_days: Sequence[int],
                 is_custom_action_timeout_enabled: bool,
                 is_monthly_patching_enabled: bool,
                 lead_time_in_weeks: int,
                 months: Sequence['outputs.GetDbSystemsDbSystemMaintenanceWindowMonthResult'],
                 patching_mode: str,
                 preference: str,
                 weeks_of_months: Sequence[int]):
        """
        :param int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetDbSystemsDbSystemMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetDbSystemsDbSystemMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param str preference: The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        GetDbSystemsDbSystemMaintenanceWindowResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: int,
             days_of_weeks: Sequence['outputs.GetDbSystemsDbSystemMaintenanceWindowDaysOfWeekResult'],
             hours_of_days: Sequence[int],
             is_custom_action_timeout_enabled: bool,
             is_monthly_patching_enabled: bool,
             lead_time_in_weeks: int,
             months: Sequence['outputs.GetDbSystemsDbSystemMaintenanceWindowMonthResult'],
             patching_mode: str,
             preference: str,
             weeks_of_months: Sequence[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        _setter("days_of_weeks", days_of_weeks)
        _setter("hours_of_days", hours_of_days)
        _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        _setter("lead_time_in_weeks", lead_time_in_weeks)
        _setter("months", months)
        _setter("patching_mode", patching_mode)
        _setter("preference", preference)
        _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetDbSystemsDbSystemMaintenanceWindowDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetDbSystemsDbSystemMaintenanceWindowMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetDbSystemsDbSystemMaintenanceWindowDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetDbSystemsDbSystemMaintenanceWindowDaysOfWeekResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDbSystemsDbSystemMaintenanceWindowDetailResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: int,
                 days_of_weeks: Sequence['outputs.GetDbSystemsDbSystemMaintenanceWindowDetailDaysOfWeekResult'],
                 hours_of_days: Sequence[int],
                 is_custom_action_timeout_enabled: bool,
                 is_monthly_patching_enabled: bool,
                 lead_time_in_weeks: int,
                 months: Sequence['outputs.GetDbSystemsDbSystemMaintenanceWindowDetailMonthResult'],
                 patching_mode: str,
                 preference: str,
                 weeks_of_months: Sequence[int]):
        """
        :param int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetDbSystemsDbSystemMaintenanceWindowDetailDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetDbSystemsDbSystemMaintenanceWindowDetailMonthArgs'] months: Months during the year when maintenance should be performed.
        :param str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param str preference: The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        GetDbSystemsDbSystemMaintenanceWindowDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: int,
             days_of_weeks: Sequence['outputs.GetDbSystemsDbSystemMaintenanceWindowDetailDaysOfWeekResult'],
             hours_of_days: Sequence[int],
             is_custom_action_timeout_enabled: bool,
             is_monthly_patching_enabled: bool,
             lead_time_in_weeks: int,
             months: Sequence['outputs.GetDbSystemsDbSystemMaintenanceWindowDetailMonthResult'],
             patching_mode: str,
             preference: str,
             weeks_of_months: Sequence[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        _setter("days_of_weeks", days_of_weeks)
        _setter("hours_of_days", hours_of_days)
        _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        _setter("lead_time_in_weeks", lead_time_in_weeks)
        _setter("months", months)
        _setter("patching_mode", patching_mode)
        _setter("preference", preference)
        _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetDbSystemsDbSystemMaintenanceWindowDetailDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetDbSystemsDbSystemMaintenanceWindowDetailMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetDbSystemsDbSystemMaintenanceWindowDetailDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetDbSystemsDbSystemMaintenanceWindowDetailDaysOfWeekResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDbSystemsDbSystemMaintenanceWindowDetailMonthResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetDbSystemsDbSystemMaintenanceWindowDetailMonthResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDbSystemsDbSystemMaintenanceWindowMonthResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetDbSystemsDbSystemMaintenanceWindowMonthResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDbSystemsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the month of the year.
        """
        GetDbSystemsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDbSystemsUpgradeHistoryEntriesDbSystemUpgradeHistoryEntryResult(dict):
    def __init__(__self__, *,
                 action: str,
                 id: str,
                 lifecycle_details: str,
                 new_gi_version: str,
                 old_gi_version: str,
                 snapshot_retention_period_in_days: int,
                 state: str,
                 time_ended: str,
                 time_started: str):
        """
        :param str action: The operating system upgrade action.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the upgrade history entry.
        :param str lifecycle_details: A descriptive text associated with the lifecycleState. Typically contains additional displayable text.
        :param str new_gi_version: A valid Oracle Grid Infrastructure (GI) software version.
        :param str old_gi_version: A valid Oracle Grid Infrastructure (GI) software version.
        :param int snapshot_retention_period_in_days: The retention period, in days, for the snapshot that allows you to perform a rollback of the upgrade operation. After this number of days passes, you cannot roll back the upgrade.
        :param str state: A filter to return only upgrade history entries that match the given lifecycle state exactly.
        :param str time_ended: The date and time when the upgrade action completed
        :param str time_started: The date and time when the upgrade action started.
        """
        GetDbSystemsUpgradeHistoryEntriesDbSystemUpgradeHistoryEntryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            id=id,
            lifecycle_details=lifecycle_details,
            new_gi_version=new_gi_version,
            old_gi_version=old_gi_version,
            snapshot_retention_period_in_days=snapshot_retention_period_in_days,
            state=state,
            time_ended=time_ended,
            time_started=time_started,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: str,
             id: str,
             lifecycle_details: str,
             new_gi_version: str,
             old_gi_version: str,
             snapshot_retention_period_in_days: int,
             state: str,
             time_ended: str,
             time_started: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action", action)
        _setter("id", id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("new_gi_version", new_gi_version)
        _setter("old_gi_version", old_gi_version)
        _setter("snapshot_retention_period_in_days", snapshot_retention_period_in_days)
        _setter("state", state)
        _setter("time_ended", time_ended)
        _setter("time_started", time_started)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The operating system upgrade action.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the upgrade history entry.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A descriptive text associated with the lifecycleState. Typically contains additional displayable text.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="newGiVersion")
    def new_gi_version(self) -> str:
        """
        A valid Oracle Grid Infrastructure (GI) software version.
        """
        return pulumi.get(self, "new_gi_version")

    @property
    @pulumi.getter(name="oldGiVersion")
    def old_gi_version(self) -> str:
        """
        A valid Oracle Grid Infrastructure (GI) software version.
        """
        return pulumi.get(self, "old_gi_version")

    @property
    @pulumi.getter(name="snapshotRetentionPeriodInDays")
    def snapshot_retention_period_in_days(self) -> int:
        """
        The retention period, in days, for the snapshot that allows you to perform a rollback of the upgrade operation. After this number of days passes, you cannot roll back the upgrade.
        """
        return pulumi.get(self, "snapshot_retention_period_in_days")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only upgrade history entries that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeEnded")
    def time_ended(self) -> str:
        """
        The date and time when the upgrade action completed
        """
        return pulumi.get(self, "time_ended")

    @property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> str:
        """
        The date and time when the upgrade action started.
        """
        return pulumi.get(self, "time_started")


@pulumi.output_type
class GetDbSystemsUpgradeHistoryEntriesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDbSystemsUpgradeHistoryEntriesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetDbVersionsDbVersionResult(dict):
    def __init__(__self__, *,
                 is_latest_for_major_version: bool,
                 is_preview_db_version: bool,
                 is_upgrade_supported: bool,
                 supports_pdb: bool,
                 version: str):
        """
        :param bool is_latest_for_major_version: True if this version of the Oracle Database software is the latest version for a release.
        :param bool is_preview_db_version: True if this version of the Oracle Database software is the preview version.
        :param bool is_upgrade_supported: If provided, filters the results to the set of database versions which are supported for Upgrade.
        :param bool supports_pdb: True if this version of the Oracle Database software supports pluggable databases.
        :param str version: A valid Oracle Database version.
        """
        GetDbVersionsDbVersionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_latest_for_major_version=is_latest_for_major_version,
            is_preview_db_version=is_preview_db_version,
            is_upgrade_supported=is_upgrade_supported,
            supports_pdb=supports_pdb,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_latest_for_major_version: bool,
             is_preview_db_version: bool,
             is_upgrade_supported: bool,
             supports_pdb: bool,
             version: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("is_latest_for_major_version", is_latest_for_major_version)
        _setter("is_preview_db_version", is_preview_db_version)
        _setter("is_upgrade_supported", is_upgrade_supported)
        _setter("supports_pdb", supports_pdb)
        _setter("version", version)

    @property
    @pulumi.getter(name="isLatestForMajorVersion")
    def is_latest_for_major_version(self) -> bool:
        """
        True if this version of the Oracle Database software is the latest version for a release.
        """
        return pulumi.get(self, "is_latest_for_major_version")

    @property
    @pulumi.getter(name="isPreviewDbVersion")
    def is_preview_db_version(self) -> bool:
        """
        True if this version of the Oracle Database software is the preview version.
        """
        return pulumi.get(self, "is_preview_db_version")

    @property
    @pulumi.getter(name="isUpgradeSupported")
    def is_upgrade_supported(self) -> bool:
        """
        If provided, filters the results to the set of database versions which are supported for Upgrade.
        """
        return pulumi.get(self, "is_upgrade_supported")

    @property
    @pulumi.getter(name="supportsPdb")
    def supports_pdb(self) -> bool:
        """
        True if this version of the Oracle Database software supports pluggable databases.
        """
        return pulumi.get(self, "supports_pdb")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        A valid Oracle Database version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetDbVersionsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetDbVersionsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetExadataInfrastructureContactResult(dict):
    def __init__(__self__, *,
                 email: str,
                 is_contact_mos_validated: bool,
                 is_primary: bool,
                 name: str,
                 phone_number: str):
        """
        :param str email: The email for the Exadata Infrastructure contact.
        :param bool is_contact_mos_validated: If `true`, this Exadata Infrastructure contact is a valid My Oracle Support (MOS) contact. If `false`, this Exadata Infrastructure contact is not a valid MOS contact.
        :param bool is_primary: If `true`, this Exadata Infrastructure contact is a primary contact. If `false`, this Exadata Infrastructure is a secondary contact.
        :param str name: Name of the month of the year.
        :param str phone_number: The phone number for the Exadata Infrastructure contact.
        """
        GetExadataInfrastructureContactResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            email=email,
            is_contact_mos_validated=is_contact_mos_validated,
            is_primary=is_primary,
            name=name,
            phone_number=phone_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             email: str,
             is_contact_mos_validated: bool,
             is_primary: bool,
             name: str,
             phone_number: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("email", email)
        _setter("is_contact_mos_validated", is_contact_mos_validated)
        _setter("is_primary", is_primary)
        _setter("name", name)
        _setter("phone_number", phone_number)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email for the Exadata Infrastructure contact.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="isContactMosValidated")
    def is_contact_mos_validated(self) -> bool:
        """
        If `true`, this Exadata Infrastructure contact is a valid My Oracle Support (MOS) contact. If `false`, this Exadata Infrastructure contact is not a valid MOS contact.
        """
        return pulumi.get(self, "is_contact_mos_validated")

    @property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> bool:
        """
        If `true`, this Exadata Infrastructure contact is a primary contact. If `false`, this Exadata Infrastructure is a secondary contact.
        """
        return pulumi.get(self, "is_primary")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> str:
        """
        The phone number for the Exadata Infrastructure contact.
        """
        return pulumi.get(self, "phone_number")


@pulumi.output_type
class GetExadataInfrastructureMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: int,
                 days_of_weeks: Sequence['outputs.GetExadataInfrastructureMaintenanceWindowDaysOfWeekResult'],
                 hours_of_days: Sequence[int],
                 is_custom_action_timeout_enabled: bool,
                 is_monthly_patching_enabled: bool,
                 lead_time_in_weeks: int,
                 months: Sequence['outputs.GetExadataInfrastructureMaintenanceWindowMonthResult'],
                 patching_mode: str,
                 preference: str,
                 weeks_of_months: Sequence[int]):
        """
        :param int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetExadataInfrastructureMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetExadataInfrastructureMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param str preference: The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        GetExadataInfrastructureMaintenanceWindowResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: int,
             days_of_weeks: Sequence['outputs.GetExadataInfrastructureMaintenanceWindowDaysOfWeekResult'],
             hours_of_days: Sequence[int],
             is_custom_action_timeout_enabled: bool,
             is_monthly_patching_enabled: bool,
             lead_time_in_weeks: int,
             months: Sequence['outputs.GetExadataInfrastructureMaintenanceWindowMonthResult'],
             patching_mode: str,
             preference: str,
             weeks_of_months: Sequence[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        _setter("days_of_weeks", days_of_weeks)
        _setter("hours_of_days", hours_of_days)
        _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        _setter("lead_time_in_weeks", lead_time_in_weeks)
        _setter("months", months)
        _setter("patching_mode", patching_mode)
        _setter("preference", preference)
        _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetExadataInfrastructureMaintenanceWindowDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetExadataInfrastructureMaintenanceWindowMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetExadataInfrastructureMaintenanceWindowDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetExadataInfrastructureMaintenanceWindowDaysOfWeekResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetExadataInfrastructureMaintenanceWindowMonthResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetExadataInfrastructureMaintenanceWindowMonthResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetExadataInfrastructureNetworkBondingModeDetailResult(dict):
    def __init__(__self__, *,
                 backup_network_bonding_mode: str,
                 client_network_bonding_mode: str,
                 dr_network_bonding_mode: str):
        """
        :param str backup_network_bonding_mode: The network bonding mode for the Exadata infrastructure.
        :param str client_network_bonding_mode: The network bonding mode for the Exadata infrastructure.
        :param str dr_network_bonding_mode: The network bonding mode for the Exadata infrastructure.
        """
        GetExadataInfrastructureNetworkBondingModeDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backup_network_bonding_mode=backup_network_bonding_mode,
            client_network_bonding_mode=client_network_bonding_mode,
            dr_network_bonding_mode=dr_network_bonding_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backup_network_bonding_mode: str,
             client_network_bonding_mode: str,
             dr_network_bonding_mode: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("backup_network_bonding_mode", backup_network_bonding_mode)
        _setter("client_network_bonding_mode", client_network_bonding_mode)
        _setter("dr_network_bonding_mode", dr_network_bonding_mode)

    @property
    @pulumi.getter(name="backupNetworkBondingMode")
    def backup_network_bonding_mode(self) -> str:
        """
        The network bonding mode for the Exadata infrastructure.
        """
        return pulumi.get(self, "backup_network_bonding_mode")

    @property
    @pulumi.getter(name="clientNetworkBondingMode")
    def client_network_bonding_mode(self) -> str:
        """
        The network bonding mode for the Exadata infrastructure.
        """
        return pulumi.get(self, "client_network_bonding_mode")

    @property
    @pulumi.getter(name="drNetworkBondingMode")
    def dr_network_bonding_mode(self) -> str:
        """
        The network bonding mode for the Exadata infrastructure.
        """
        return pulumi.get(self, "dr_network_bonding_mode")


@pulumi.output_type
class GetExadataInfrastructureUnAllocatedResourceAutonomousVmClusterResult(dict):
    def __init__(__self__, *,
                 id: str,
                 un_allocated_adb_storage_in_tbs: float):
        """
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Exadata infrastructure.
        :param float un_allocated_adb_storage_in_tbs: Total unallocated autonomous data storage in the AVM in TBs.
        """
        GetExadataInfrastructureUnAllocatedResourceAutonomousVmClusterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            un_allocated_adb_storage_in_tbs=un_allocated_adb_storage_in_tbs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             un_allocated_adb_storage_in_tbs: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("un_allocated_adb_storage_in_tbs", un_allocated_adb_storage_in_tbs)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Exadata infrastructure.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="unAllocatedAdbStorageInTbs")
    def un_allocated_adb_storage_in_tbs(self) -> float:
        """
        Total unallocated autonomous data storage in the AVM in TBs.
        """
        return pulumi.get(self, "un_allocated_adb_storage_in_tbs")


@pulumi.output_type
class GetExadataInfrastructuresExadataInfrastructureResult(dict):
    def __init__(__self__, *,
                 activated_storage_count: int,
                 activation_file: str,
                 additional_compute_count: int,
                 additional_compute_system_model: str,
                 additional_storage_count: int,
                 admin_network_cidr: str,
                 availability_domain: str,
                 cloud_control_plane_server1: str,
                 cloud_control_plane_server2: str,
                 compartment_id: str,
                 compute_count: int,
                 contacts: Sequence['outputs.GetExadataInfrastructuresExadataInfrastructureContactResult'],
                 corporate_proxy: str,
                 cpus_enabled: int,
                 create_async: bool,
                 csi_number: str,
                 data_storage_size_in_tbs: float,
                 db_node_storage_size_in_gbs: int,
                 db_server_version: str,
                 defined_tags: Mapping[str, Any],
                 display_name: str,
                 dns_servers: Sequence[str],
                 freeform_tags: Mapping[str, Any],
                 gateway: str,
                 id: str,
                 infini_band_network_cidr: str,
                 is_cps_offline_report_enabled: bool,
                 is_multi_rack_deployment: bool,
                 lifecycle_details: str,
                 maintenance_slo_status: str,
                 maintenance_windows: Sequence['outputs.GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowResult'],
                 max_cpu_count: int,
                 max_data_storage_in_tbs: float,
                 max_db_node_storage_in_gbs: int,
                 max_memory_in_gbs: int,
                 memory_size_in_gbs: int,
                 monthly_db_server_version: str,
                 multi_rack_configuration_file: str,
                 netmask: str,
                 network_bonding_mode_details: Sequence['outputs.GetExadataInfrastructuresExadataInfrastructureNetworkBondingModeDetailResult'],
                 ntp_servers: Sequence[str],
                 rack_serial_number: str,
                 shape: str,
                 state: str,
                 storage_count: int,
                 storage_server_version: str,
                 time_created: str,
                 time_zone: str):
        """
        :param int activated_storage_count: The requested number of additional storage servers activated for the Exadata infrastructure.
        :param int additional_compute_count: The requested number of additional compute servers for the Exadata infrastructure.
        :param str additional_compute_system_model: Oracle Exadata System Model specification. The system model determines the amount of compute or storage server resources available for use. For more information, please see [System and Shape Configuration Options] (https://docs.oracle.com/en/engineered-systems/exadata-cloud-at-customer/ecccm/ecc-system-config-options.html#GUID-9E090174-5C57-4EB1-9243-B470F9F10D6B)
        :param int additional_storage_count: The requested number of additional storage servers for the Exadata infrastructure.
        :param str admin_network_cidr: The CIDR block for the Exadata administration network.
        :param str availability_domain: The name of the availability domain that the Exadata infrastructure is located in.
        :param str cloud_control_plane_server1: The IP address for the first control plane server.
        :param str cloud_control_plane_server2: The IP address for the second control plane server.
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param int compute_count: The number of compute servers for the Exadata infrastructure.
        :param Sequence['GetExadataInfrastructuresExadataInfrastructureContactArgs'] contacts: The list of contacts for the Exadata infrastructure.
        :param str corporate_proxy: The corporate network proxy for access to the control plane network.
        :param int cpus_enabled: The number of enabled CPU cores.
        :param str csi_number: The CSI Number of the Exadata infrastructure.
        :param float data_storage_size_in_tbs: Size, in terabytes, of the DATA disk group.
        :param int db_node_storage_size_in_gbs: The local node storage allocated in GBs.
        :param str db_server_version: The software version of the database servers (dom0) in the Exadata infrastructure.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param Sequence[str] dns_servers: The list of DNS server IP addresses. Maximum of 3 allowed.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str gateway: The gateway for the control plane network.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Exadata infrastructure.
        :param str infini_band_network_cidr: The CIDR block for the Exadata InfiniBand interconnect.
        :param bool is_cps_offline_report_enabled: Indicates whether cps offline diagnostic report is enabled for this Exadata infrastructure. This will allow a customer to quickly check status themselves and fix problems on their end, saving time and frustration for both Oracle and the customer when they find the CPS in a disconnected state.You can enable offline diagnostic report during Exadata infrastructure provisioning. You can also disable or enable it at any time using the UpdateExadatainfrastructure API.
        :param bool is_multi_rack_deployment: Indicates if deployment is Multi-Rack or not.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str maintenance_slo_status: A field to capture ‘Maintenance SLO Status’ for the Exadata infrastructure with values ‘OK’, ‘DEGRADED’. Default is ‘OK’ when the infrastructure is provisioned.
        :param Sequence['GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowArgs'] maintenance_windows: The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        :param int max_cpu_count: The total number of CPU cores available.
        :param float max_data_storage_in_tbs: The total available DATA disk group size.
        :param int max_db_node_storage_in_gbs: The total local node storage available in GBs.
        :param int max_memory_in_gbs: The total memory available in GBs.
        :param int memory_size_in_gbs: The memory allocated in GBs.
        :param str monthly_db_server_version: The monthly software version of the database servers (dom0) in the Exadata infrastructure.
        :param str multi_rack_configuration_file: The base64 encoded Multi-Rack configuration json file.
        :param str netmask: The netmask for the control plane network.
        :param Sequence['GetExadataInfrastructuresExadataInfrastructureNetworkBondingModeDetailArgs'] network_bonding_mode_details: Details of bonding mode for Client and Backup and DR networks of an Exadata infrastructure.
        :param Sequence[str] ntp_servers: The list of NTP server IP addresses. Maximum of 3 allowed.
        :param str rack_serial_number: The serial number for the Exadata infrastructure.
        :param str shape: The shape of the Exadata infrastructure. The shape determines the amount of CPU, storage, and memory resources allocated to the instance.
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        :param int storage_count: The number of Exadata storage servers for the Exadata infrastructure.
        :param str storage_server_version: The software version of the storage servers (cells) in the Exadata infrastructure.
        :param str time_created: The date and time the Exadata infrastructure was created.
        :param str time_zone: The time zone of the Exadata infrastructure. For details, see [Exadata Infrastructure Time Zones](https://docs.cloud.oracle.com/iaas/Content/Database/References/timezones.htm).
        """
        GetExadataInfrastructuresExadataInfrastructureResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            activated_storage_count=activated_storage_count,
            activation_file=activation_file,
            additional_compute_count=additional_compute_count,
            additional_compute_system_model=additional_compute_system_model,
            additional_storage_count=additional_storage_count,
            admin_network_cidr=admin_network_cidr,
            availability_domain=availability_domain,
            cloud_control_plane_server1=cloud_control_plane_server1,
            cloud_control_plane_server2=cloud_control_plane_server2,
            compartment_id=compartment_id,
            compute_count=compute_count,
            contacts=contacts,
            corporate_proxy=corporate_proxy,
            cpus_enabled=cpus_enabled,
            create_async=create_async,
            csi_number=csi_number,
            data_storage_size_in_tbs=data_storage_size_in_tbs,
            db_node_storage_size_in_gbs=db_node_storage_size_in_gbs,
            db_server_version=db_server_version,
            defined_tags=defined_tags,
            display_name=display_name,
            dns_servers=dns_servers,
            freeform_tags=freeform_tags,
            gateway=gateway,
            id=id,
            infini_band_network_cidr=infini_band_network_cidr,
            is_cps_offline_report_enabled=is_cps_offline_report_enabled,
            is_multi_rack_deployment=is_multi_rack_deployment,
            lifecycle_details=lifecycle_details,
            maintenance_slo_status=maintenance_slo_status,
            maintenance_windows=maintenance_windows,
            max_cpu_count=max_cpu_count,
            max_data_storage_in_tbs=max_data_storage_in_tbs,
            max_db_node_storage_in_gbs=max_db_node_storage_in_gbs,
            max_memory_in_gbs=max_memory_in_gbs,
            memory_size_in_gbs=memory_size_in_gbs,
            monthly_db_server_version=monthly_db_server_version,
            multi_rack_configuration_file=multi_rack_configuration_file,
            netmask=netmask,
            network_bonding_mode_details=network_bonding_mode_details,
            ntp_servers=ntp_servers,
            rack_serial_number=rack_serial_number,
            shape=shape,
            state=state,
            storage_count=storage_count,
            storage_server_version=storage_server_version,
            time_created=time_created,
            time_zone=time_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             activated_storage_count: int,
             activation_file: str,
             additional_compute_count: int,
             additional_compute_system_model: str,
             additional_storage_count: int,
             admin_network_cidr: str,
             availability_domain: str,
             cloud_control_plane_server1: str,
             cloud_control_plane_server2: str,
             compartment_id: str,
             compute_count: int,
             contacts: Sequence['outputs.GetExadataInfrastructuresExadataInfrastructureContactResult'],
             corporate_proxy: str,
             cpus_enabled: int,
             create_async: bool,
             csi_number: str,
             data_storage_size_in_tbs: float,
             db_node_storage_size_in_gbs: int,
             db_server_version: str,
             defined_tags: Mapping[str, Any],
             display_name: str,
             dns_servers: Sequence[str],
             freeform_tags: Mapping[str, Any],
             gateway: str,
             id: str,
             infini_band_network_cidr: str,
             is_cps_offline_report_enabled: bool,
             is_multi_rack_deployment: bool,
             lifecycle_details: str,
             maintenance_slo_status: str,
             maintenance_windows: Sequence['outputs.GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowResult'],
             max_cpu_count: int,
             max_data_storage_in_tbs: float,
             max_db_node_storage_in_gbs: int,
             max_memory_in_gbs: int,
             memory_size_in_gbs: int,
             monthly_db_server_version: str,
             multi_rack_configuration_file: str,
             netmask: str,
             network_bonding_mode_details: Sequence['outputs.GetExadataInfrastructuresExadataInfrastructureNetworkBondingModeDetailResult'],
             ntp_servers: Sequence[str],
             rack_serial_number: str,
             shape: str,
             state: str,
             storage_count: int,
             storage_server_version: str,
             time_created: str,
             time_zone: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("activated_storage_count", activated_storage_count)
        _setter("activation_file", activation_file)
        _setter("additional_compute_count", additional_compute_count)
        _setter("additional_compute_system_model", additional_compute_system_model)
        _setter("additional_storage_count", additional_storage_count)
        _setter("admin_network_cidr", admin_network_cidr)
        _setter("availability_domain", availability_domain)
        _setter("cloud_control_plane_server1", cloud_control_plane_server1)
        _setter("cloud_control_plane_server2", cloud_control_plane_server2)
        _setter("compartment_id", compartment_id)
        _setter("compute_count", compute_count)
        _setter("contacts", contacts)
        _setter("corporate_proxy", corporate_proxy)
        _setter("cpus_enabled", cpus_enabled)
        _setter("create_async", create_async)
        _setter("csi_number", csi_number)
        _setter("data_storage_size_in_tbs", data_storage_size_in_tbs)
        _setter("db_node_storage_size_in_gbs", db_node_storage_size_in_gbs)
        _setter("db_server_version", db_server_version)
        _setter("defined_tags", defined_tags)
        _setter("display_name", display_name)
        _setter("dns_servers", dns_servers)
        _setter("freeform_tags", freeform_tags)
        _setter("gateway", gateway)
        _setter("id", id)
        _setter("infini_band_network_cidr", infini_band_network_cidr)
        _setter("is_cps_offline_report_enabled", is_cps_offline_report_enabled)
        _setter("is_multi_rack_deployment", is_multi_rack_deployment)
        _setter("lifecycle_details", lifecycle_details)
        _setter("maintenance_slo_status", maintenance_slo_status)
        _setter("maintenance_windows", maintenance_windows)
        _setter("max_cpu_count", max_cpu_count)
        _setter("max_data_storage_in_tbs", max_data_storage_in_tbs)
        _setter("max_db_node_storage_in_gbs", max_db_node_storage_in_gbs)
        _setter("max_memory_in_gbs", max_memory_in_gbs)
        _setter("memory_size_in_gbs", memory_size_in_gbs)
        _setter("monthly_db_server_version", monthly_db_server_version)
        _setter("multi_rack_configuration_file", multi_rack_configuration_file)
        _setter("netmask", netmask)
        _setter("network_bonding_mode_details", network_bonding_mode_details)
        _setter("ntp_servers", ntp_servers)
        _setter("rack_serial_number", rack_serial_number)
        _setter("shape", shape)
        _setter("state", state)
        _setter("storage_count", storage_count)
        _setter("storage_server_version", storage_server_version)
        _setter("time_created", time_created)
        _setter("time_zone", time_zone)

    @property
    @pulumi.getter(name="activatedStorageCount")
    def activated_storage_count(self) -> int:
        """
        The requested number of additional storage servers activated for the Exadata infrastructure.
        """
        return pulumi.get(self, "activated_storage_count")

    @property
    @pulumi.getter(name="activationFile")
    def activation_file(self) -> str:
        return pulumi.get(self, "activation_file")

    @property
    @pulumi.getter(name="additionalComputeCount")
    def additional_compute_count(self) -> int:
        """
        The requested number of additional compute servers for the Exadata infrastructure.
        """
        return pulumi.get(self, "additional_compute_count")

    @property
    @pulumi.getter(name="additionalComputeSystemModel")
    def additional_compute_system_model(self) -> str:
        """
        Oracle Exadata System Model specification. The system model determines the amount of compute or storage server resources available for use. For more information, please see [System and Shape Configuration Options] (https://docs.oracle.com/en/engineered-systems/exadata-cloud-at-customer/ecccm/ecc-system-config-options.html#GUID-9E090174-5C57-4EB1-9243-B470F9F10D6B)
        """
        return pulumi.get(self, "additional_compute_system_model")

    @property
    @pulumi.getter(name="additionalStorageCount")
    def additional_storage_count(self) -> int:
        """
        The requested number of additional storage servers for the Exadata infrastructure.
        """
        return pulumi.get(self, "additional_storage_count")

    @property
    @pulumi.getter(name="adminNetworkCidr")
    def admin_network_cidr(self) -> str:
        """
        The CIDR block for the Exadata administration network.
        """
        return pulumi.get(self, "admin_network_cidr")

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> str:
        """
        The name of the availability domain that the Exadata infrastructure is located in.
        """
        return pulumi.get(self, "availability_domain")

    @property
    @pulumi.getter(name="cloudControlPlaneServer1")
    def cloud_control_plane_server1(self) -> str:
        """
        The IP address for the first control plane server.
        """
        return pulumi.get(self, "cloud_control_plane_server1")

    @property
    @pulumi.getter(name="cloudControlPlaneServer2")
    def cloud_control_plane_server2(self) -> str:
        """
        The IP address for the second control plane server.
        """
        return pulumi.get(self, "cloud_control_plane_server2")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="computeCount")
    def compute_count(self) -> int:
        """
        The number of compute servers for the Exadata infrastructure.
        """
        return pulumi.get(self, "compute_count")

    @property
    @pulumi.getter
    def contacts(self) -> Sequence['outputs.GetExadataInfrastructuresExadataInfrastructureContactResult']:
        """
        The list of contacts for the Exadata infrastructure.
        """
        return pulumi.get(self, "contacts")

    @property
    @pulumi.getter(name="corporateProxy")
    def corporate_proxy(self) -> str:
        """
        The corporate network proxy for access to the control plane network.
        """
        return pulumi.get(self, "corporate_proxy")

    @property
    @pulumi.getter(name="cpusEnabled")
    def cpus_enabled(self) -> int:
        """
        The number of enabled CPU cores.
        """
        return pulumi.get(self, "cpus_enabled")

    @property
    @pulumi.getter(name="createAsync")
    def create_async(self) -> bool:
        return pulumi.get(self, "create_async")

    @property
    @pulumi.getter(name="csiNumber")
    def csi_number(self) -> str:
        """
        The CSI Number of the Exadata infrastructure.
        """
        return pulumi.get(self, "csi_number")

    @property
    @pulumi.getter(name="dataStorageSizeInTbs")
    def data_storage_size_in_tbs(self) -> float:
        """
        Size, in terabytes, of the DATA disk group.
        """
        return pulumi.get(self, "data_storage_size_in_tbs")

    @property
    @pulumi.getter(name="dbNodeStorageSizeInGbs")
    def db_node_storage_size_in_gbs(self) -> int:
        """
        The local node storage allocated in GBs.
        """
        return pulumi.get(self, "db_node_storage_size_in_gbs")

    @property
    @pulumi.getter(name="dbServerVersion")
    def db_server_version(self) -> str:
        """
        The software version of the database servers (dom0) in the Exadata infrastructure.
        """
        return pulumi.get(self, "db_server_version")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Sequence[str]:
        """
        The list of DNS server IP addresses. Maximum of 3 allowed.
        """
        return pulumi.get(self, "dns_servers")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        The gateway for the control plane network.
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Exadata infrastructure.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="infiniBandNetworkCidr")
    def infini_band_network_cidr(self) -> str:
        """
        The CIDR block for the Exadata InfiniBand interconnect.
        """
        return pulumi.get(self, "infini_band_network_cidr")

    @property
    @pulumi.getter(name="isCpsOfflineReportEnabled")
    def is_cps_offline_report_enabled(self) -> bool:
        """
        Indicates whether cps offline diagnostic report is enabled for this Exadata infrastructure. This will allow a customer to quickly check status themselves and fix problems on their end, saving time and frustration for both Oracle and the customer when they find the CPS in a disconnected state.You can enable offline diagnostic report during Exadata infrastructure provisioning. You can also disable or enable it at any time using the UpdateExadatainfrastructure API.
        """
        return pulumi.get(self, "is_cps_offline_report_enabled")

    @property
    @pulumi.getter(name="isMultiRackDeployment")
    def is_multi_rack_deployment(self) -> bool:
        """
        Indicates if deployment is Multi-Rack or not.
        """
        return pulumi.get(self, "is_multi_rack_deployment")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="maintenanceSloStatus")
    def maintenance_slo_status(self) -> str:
        """
        A field to capture ‘Maintenance SLO Status’ for the Exadata infrastructure with values ‘OK’, ‘DEGRADED’. Default is ‘OK’ when the infrastructure is provisioned.
        """
        return pulumi.get(self, "maintenance_slo_status")

    @property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Sequence['outputs.GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowResult']:
        """
        The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        """
        return pulumi.get(self, "maintenance_windows")

    @property
    @pulumi.getter(name="maxCpuCount")
    def max_cpu_count(self) -> int:
        """
        The total number of CPU cores available.
        """
        return pulumi.get(self, "max_cpu_count")

    @property
    @pulumi.getter(name="maxDataStorageInTbs")
    def max_data_storage_in_tbs(self) -> float:
        """
        The total available DATA disk group size.
        """
        return pulumi.get(self, "max_data_storage_in_tbs")

    @property
    @pulumi.getter(name="maxDbNodeStorageInGbs")
    def max_db_node_storage_in_gbs(self) -> int:
        """
        The total local node storage available in GBs.
        """
        return pulumi.get(self, "max_db_node_storage_in_gbs")

    @property
    @pulumi.getter(name="maxMemoryInGbs")
    def max_memory_in_gbs(self) -> int:
        """
        The total memory available in GBs.
        """
        return pulumi.get(self, "max_memory_in_gbs")

    @property
    @pulumi.getter(name="memorySizeInGbs")
    def memory_size_in_gbs(self) -> int:
        """
        The memory allocated in GBs.
        """
        return pulumi.get(self, "memory_size_in_gbs")

    @property
    @pulumi.getter(name="monthlyDbServerVersion")
    def monthly_db_server_version(self) -> str:
        """
        The monthly software version of the database servers (dom0) in the Exadata infrastructure.
        """
        return pulumi.get(self, "monthly_db_server_version")

    @property
    @pulumi.getter(name="multiRackConfigurationFile")
    def multi_rack_configuration_file(self) -> str:
        """
        The base64 encoded Multi-Rack configuration json file.
        """
        return pulumi.get(self, "multi_rack_configuration_file")

    @property
    @pulumi.getter
    def netmask(self) -> str:
        """
        The netmask for the control plane network.
        """
        return pulumi.get(self, "netmask")

    @property
    @pulumi.getter(name="networkBondingModeDetails")
    def network_bonding_mode_details(self) -> Sequence['outputs.GetExadataInfrastructuresExadataInfrastructureNetworkBondingModeDetailResult']:
        """
        Details of bonding mode for Client and Backup and DR networks of an Exadata infrastructure.
        """
        return pulumi.get(self, "network_bonding_mode_details")

    @property
    @pulumi.getter(name="ntpServers")
    def ntp_servers(self) -> Sequence[str]:
        """
        The list of NTP server IP addresses. Maximum of 3 allowed.
        """
        return pulumi.get(self, "ntp_servers")

    @property
    @pulumi.getter(name="rackSerialNumber")
    def rack_serial_number(self) -> str:
        """
        The serial number for the Exadata infrastructure.
        """
        return pulumi.get(self, "rack_serial_number")

    @property
    @pulumi.getter
    def shape(self) -> str:
        """
        The shape of the Exadata infrastructure. The shape determines the amount of CPU, storage, and memory resources allocated to the instance.
        """
        return pulumi.get(self, "shape")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="storageCount")
    def storage_count(self) -> int:
        """
        The number of Exadata storage servers for the Exadata infrastructure.
        """
        return pulumi.get(self, "storage_count")

    @property
    @pulumi.getter(name="storageServerVersion")
    def storage_server_version(self) -> str:
        """
        The software version of the storage servers (cells) in the Exadata infrastructure.
        """
        return pulumi.get(self, "storage_server_version")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the Exadata infrastructure was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        """
        The time zone of the Exadata infrastructure. For details, see [Exadata Infrastructure Time Zones](https://docs.cloud.oracle.com/iaas/Content/Database/References/timezones.htm).
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class GetExadataInfrastructuresExadataInfrastructureContactResult(dict):
    def __init__(__self__, *,
                 email: str,
                 is_contact_mos_validated: bool,
                 is_primary: bool,
                 name: str,
                 phone_number: str):
        """
        :param str email: The email for the Exadata Infrastructure contact.
        :param bool is_contact_mos_validated: If `true`, this Exadata Infrastructure contact is a valid My Oracle Support (MOS) contact. If `false`, this Exadata Infrastructure contact is not a valid MOS contact.
        :param bool is_primary: If `true`, this Exadata Infrastructure contact is a primary contact. If `false`, this Exadata Infrastructure is a secondary contact.
        :param str name: Name of the month of the year.
        :param str phone_number: The phone number for the Exadata Infrastructure contact.
        """
        GetExadataInfrastructuresExadataInfrastructureContactResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            email=email,
            is_contact_mos_validated=is_contact_mos_validated,
            is_primary=is_primary,
            name=name,
            phone_number=phone_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             email: str,
             is_contact_mos_validated: bool,
             is_primary: bool,
             name: str,
             phone_number: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("email", email)
        _setter("is_contact_mos_validated", is_contact_mos_validated)
        _setter("is_primary", is_primary)
        _setter("name", name)
        _setter("phone_number", phone_number)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email for the Exadata Infrastructure contact.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="isContactMosValidated")
    def is_contact_mos_validated(self) -> bool:
        """
        If `true`, this Exadata Infrastructure contact is a valid My Oracle Support (MOS) contact. If `false`, this Exadata Infrastructure contact is not a valid MOS contact.
        """
        return pulumi.get(self, "is_contact_mos_validated")

    @property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> bool:
        """
        If `true`, this Exadata Infrastructure contact is a primary contact. If `false`, this Exadata Infrastructure is a secondary contact.
        """
        return pulumi.get(self, "is_primary")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> str:
        """
        The phone number for the Exadata Infrastructure contact.
        """
        return pulumi.get(self, "phone_number")


@pulumi.output_type
class GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 custom_action_timeout_in_mins: int,
                 days_of_weeks: Sequence['outputs.GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowDaysOfWeekResult'],
                 hours_of_days: Sequence[int],
                 is_custom_action_timeout_enabled: bool,
                 is_monthly_patching_enabled: bool,
                 lead_time_in_weeks: int,
                 months: Sequence['outputs.GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowMonthResult'],
                 patching_mode: str,
                 preference: str,
                 weeks_of_months: Sequence[int]):
        """
        :param int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        :param Sequence['GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowDaysOfWeekArgs'] days_of_weeks: Days during the week when maintenance should be performed.
        :param Sequence[int] hours_of_days: The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        :param bool is_monthly_patching_enabled: If true, enables the monthly patching option.
        :param int lead_time_in_weeks: Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param Sequence['GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowMonthArgs'] months: Months during the year when maintenance should be performed.
        :param str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param str preference: The maintenance window scheduling preference.
        :param Sequence[int] weeks_of_months: Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            days_of_weeks=days_of_weeks,
            hours_of_days=hours_of_days,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_monthly_patching_enabled=is_monthly_patching_enabled,
            lead_time_in_weeks=lead_time_in_weeks,
            months=months,
            patching_mode=patching_mode,
            preference=preference,
            weeks_of_months=weeks_of_months,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_action_timeout_in_mins: int,
             days_of_weeks: Sequence['outputs.GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowDaysOfWeekResult'],
             hours_of_days: Sequence[int],
             is_custom_action_timeout_enabled: bool,
             is_monthly_patching_enabled: bool,
             lead_time_in_weeks: int,
             months: Sequence['outputs.GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowMonthResult'],
             patching_mode: str,
             preference: str,
             weeks_of_months: Sequence[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        _setter("days_of_weeks", days_of_weeks)
        _setter("hours_of_days", hours_of_days)
        _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        _setter("is_monthly_patching_enabled", is_monthly_patching_enabled)
        _setter("lead_time_in_weeks", lead_time_in_weeks)
        _setter("months", months)
        _setter("patching_mode", patching_mode)
        _setter("preference", preference)
        _setter("weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Sequence['outputs.GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowDaysOfWeekResult']:
        """
        Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Sequence[int]:
        """
        The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isMonthlyPatchingEnabled")
    def is_monthly_patching_enabled(self) -> bool:
        """
        If true, enables the monthly patching option.
        """
        return pulumi.get(self, "is_monthly_patching_enabled")

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> int:
        """
        Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @property
    @pulumi.getter
    def months(self) -> Sequence['outputs.GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowMonthResult']:
        """
        Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter
    def preference(self) -> str:
        """
        The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Sequence[int]:
        """
        Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")


@pulumi.output_type
class GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowDaysOfWeekResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowDaysOfWeekResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowMonthResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the month of the year.
        """
        GetExadataInfrastructuresExadataInfrastructureMaintenanceWindowMonthResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetExadataInfrastructuresExadataInfrastructureNetworkBondingModeDetailResult(dict):
    def __init__(__self__, *,
                 backup_network_bonding_mode: str,
                 client_network_bonding_mode: str,
                 dr_network_bonding_mode: str):
        """
        :param str backup_network_bonding_mode: The network bonding mode for the Exadata infrastructure.
        :param str client_network_bonding_mode: The network bonding mode for the Exadata infrastructure.
        :param str dr_network_bonding_mode: The network bonding mode for the Exadata infrastructure.
        """
        GetExadataInfrastructuresExadataInfrastructureNetworkBondingModeDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backup_network_bonding_mode=backup_network_bonding_mode,
            client_network_bonding_mode=client_network_bonding_mode,
            dr_network_bonding_mode=dr_network_bonding_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backup_network_bonding_mode: str,
             client_network_bonding_mode: str,
             dr_network_bonding_mode: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("backup_network_bonding_mode", backup_network_bonding_mode)
        _setter("client_network_bonding_mode", client_network_bonding_mode)
        _setter("dr_network_bonding_mode", dr_network_bonding_mode)

    @property
    @pulumi.getter(name="backupNetworkBondingMode")
    def backup_network_bonding_mode(self) -> str:
        """
        The network bonding mode for the Exadata infrastructure.
        """
        return pulumi.get(self, "backup_network_bonding_mode")

    @property
    @pulumi.getter(name="clientNetworkBondingMode")
    def client_network_bonding_mode(self) -> str:
        """
        The network bonding mode for the Exadata infrastructure.
        """
        return pulumi.get(self, "client_network_bonding_mode")

    @property
    @pulumi.getter(name="drNetworkBondingMode")
    def dr_network_bonding_mode(self) -> str:
        """
        The network bonding mode for the Exadata infrastructure.
        """
        return pulumi.get(self, "dr_network_bonding_mode")


@pulumi.output_type
class GetExadataInfrastructuresFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the month of the year.
        """
        GetExadataInfrastructuresFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetExadataIormConfigDbPlanResult(dict):
    def __init__(__self__, *,
                 db_name: str,
                 flash_cache_limit: str,
                 share: int):
        """
        :param str db_name: The database name. For the default `DbPlan`, the `dbName` is `default`.
        :param str flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        :param int share: The relative priority of this database.
        """
        GetExadataIormConfigDbPlanResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_name=db_name,
            flash_cache_limit=flash_cache_limit,
            share=share,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_name: str,
             flash_cache_limit: str,
             share: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("db_name", db_name)
        _setter("flash_cache_limit", flash_cache_limit)
        _setter("share", share)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> str:
        """
        The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> str:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")

    @property
    @pulumi.getter
    def share(self) -> int:
        """
        The relative priority of this database.
        """
        return pulumi.get(self, "share")


@pulumi.output_type
class GetExternalContainerDatabaseDatabaseManagementConfigResult(dict):
    def __init__(__self__, *,
                 database_management_connection_id: str,
                 database_management_status: str,
                 license_model: str):
        """
        :param str database_management_connection_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param str database_management_status: The status of the Database Management service.
        :param str license_model: The Oracle license model that applies to the external database.
        """
        GetExternalContainerDatabaseDatabaseManagementConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_management_connection_id=database_management_connection_id,
            database_management_status=database_management_status,
            license_model=license_model,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_management_connection_id: str,
             database_management_status: str,
             license_model: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database_management_connection_id", database_management_connection_id)
        _setter("database_management_status", database_management_status)
        _setter("license_model", license_model)

    @property
    @pulumi.getter(name="databaseManagementConnectionId")
    def database_management_connection_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "database_management_connection_id")

    @property
    @pulumi.getter(name="databaseManagementStatus")
    def database_management_status(self) -> str:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "database_management_status")

    @property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> str:
        """
        The Oracle license model that applies to the external database.
        """
        return pulumi.get(self, "license_model")


@pulumi.output_type
class GetExternalContainerDatabaseStackMonitoringConfigResult(dict):
    def __init__(__self__, *,
                 stack_monitoring_connector_id: str,
                 stack_monitoring_status: str):
        """
        :param str stack_monitoring_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param str stack_monitoring_status: The status of Stack Monitoring.
        """
        GetExternalContainerDatabaseStackMonitoringConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            stack_monitoring_connector_id=stack_monitoring_connector_id,
            stack_monitoring_status=stack_monitoring_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             stack_monitoring_connector_id: str,
             stack_monitoring_status: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("stack_monitoring_connector_id", stack_monitoring_connector_id)
        _setter("stack_monitoring_status", stack_monitoring_status)

    @property
    @pulumi.getter(name="stackMonitoringConnectorId")
    def stack_monitoring_connector_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "stack_monitoring_connector_id")

    @property
    @pulumi.getter(name="stackMonitoringStatus")
    def stack_monitoring_status(self) -> str:
        """
        The status of Stack Monitoring.
        """
        return pulumi.get(self, "stack_monitoring_status")


@pulumi.output_type
class GetExternalContainerDatabasesExternalContainerDatabaseResult(dict):
    def __init__(__self__, *,
                 character_set: str,
                 compartment_id: str,
                 database_configuration: str,
                 database_edition: str,
                 database_management_configs: Sequence['outputs.GetExternalContainerDatabasesExternalContainerDatabaseDatabaseManagementConfigResult'],
                 database_version: str,
                 db_id: str,
                 db_packs: str,
                 db_unique_name: str,
                 defined_tags: Mapping[str, Any],
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 lifecycle_details: str,
                 ncharacter_set: str,
                 stack_monitoring_configs: Sequence['outputs.GetExternalContainerDatabasesExternalContainerDatabaseStackMonitoringConfigResult'],
                 state: str,
                 time_created: str,
                 time_zone: str):
        """
        :param str character_set: The character set of the external database.
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param str database_configuration: The Oracle Database configuration
        :param str database_edition: The Oracle Database edition.
        :param Sequence['GetExternalContainerDatabasesExternalContainerDatabaseDatabaseManagementConfigArgs'] database_management_configs: The configuration of the Database Management service.
        :param str database_version: The Oracle Database version.
        :param str db_id: The Oracle Database ID, which identifies an Oracle Database located outside of Oracle Cloud.
        :param str db_packs: The database packs licensed for the external Oracle Database.
        :param str db_unique_name: The `DB_UNIQUE_NAME` of the external database.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure external database resource.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str ncharacter_set: The national character of the external database.
        :param Sequence['GetExternalContainerDatabasesExternalContainerDatabaseStackMonitoringConfigArgs'] stack_monitoring_configs: The configuration of Stack Monitoring for the external database.
        :param str state: A filter to return only resources that match the specified lifecycle state.
        :param str time_created: The date and time the database was created.
        :param str time_zone: The time zone of the external database. It is a time zone offset (a character type in the format '[+|-]TZH:TZM') or a time zone region name, depending on how the time zone value was specified when the database was created / last altered.
        """
        GetExternalContainerDatabasesExternalContainerDatabaseResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            character_set=character_set,
            compartment_id=compartment_id,
            database_configuration=database_configuration,
            database_edition=database_edition,
            database_management_configs=database_management_configs,
            database_version=database_version,
            db_id=db_id,
            db_packs=db_packs,
            db_unique_name=db_unique_name,
            defined_tags=defined_tags,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            lifecycle_details=lifecycle_details,
            ncharacter_set=ncharacter_set,
            stack_monitoring_configs=stack_monitoring_configs,
            state=state,
            time_created=time_created,
            time_zone=time_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             character_set: str,
             compartment_id: str,
             database_configuration: str,
             database_edition: str,
             database_management_configs: Sequence['outputs.GetExternalContainerDatabasesExternalContainerDatabaseDatabaseManagementConfigResult'],
             database_version: str,
             db_id: str,
             db_packs: str,
             db_unique_name: str,
             defined_tags: Mapping[str, Any],
             display_name: str,
             freeform_tags: Mapping[str, Any],
             id: str,
             lifecycle_details: str,
             ncharacter_set: str,
             stack_monitoring_configs: Sequence['outputs.GetExternalContainerDatabasesExternalContainerDatabaseStackMonitoringConfigResult'],
             state: str,
             time_created: str,
             time_zone: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("character_set", character_set)
        _setter("compartment_id", compartment_id)
        _setter("database_configuration", database_configuration)
        _setter("database_edition", database_edition)
        _setter("database_management_configs", database_management_configs)
        _setter("database_version", database_version)
        _setter("db_id", db_id)
        _setter("db_packs", db_packs)
        _setter("db_unique_name", db_unique_name)
        _setter("defined_tags", defined_tags)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("ncharacter_set", ncharacter_set)
        _setter("stack_monitoring_configs", stack_monitoring_configs)
        _setter("state", state)
        _setter("time_created", time_created)
        _setter("time_zone", time_zone)

    @property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> str:
        """
        The character set of the external database.
        """
        return pulumi.get(self, "character_set")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="databaseConfiguration")
    def database_configuration(self) -> str:
        """
        The Oracle Database configuration
        """
        return pulumi.get(self, "database_configuration")

    @property
    @pulumi.getter(name="databaseEdition")
    def database_edition(self) -> str:
        """
        The Oracle Database edition.
        """
        return pulumi.get(self, "database_edition")

    @property
    @pulumi.getter(name="databaseManagementConfigs")
    def database_management_configs(self) -> Sequence['outputs.GetExternalContainerDatabasesExternalContainerDatabaseDatabaseManagementConfigResult']:
        """
        The configuration of the Database Management service.
        """
        return pulumi.get(self, "database_management_configs")

    @property
    @pulumi.getter(name="databaseVersion")
    def database_version(self) -> str:
        """
        The Oracle Database version.
        """
        return pulumi.get(self, "database_version")

    @property
    @pulumi.getter(name="dbId")
    def db_id(self) -> str:
        """
        The Oracle Database ID, which identifies an Oracle Database located outside of Oracle Cloud.
        """
        return pulumi.get(self, "db_id")

    @property
    @pulumi.getter(name="dbPacks")
    def db_packs(self) -> str:
        """
        The database packs licensed for the external Oracle Database.
        """
        return pulumi.get(self, "db_packs")

    @property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> str:
        """
        The `DB_UNIQUE_NAME` of the external database.
        """
        return pulumi.get(self, "db_unique_name")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure external database resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> str:
        """
        The national character of the external database.
        """
        return pulumi.get(self, "ncharacter_set")

    @property
    @pulumi.getter(name="stackMonitoringConfigs")
    def stack_monitoring_configs(self) -> Sequence['outputs.GetExternalContainerDatabasesExternalContainerDatabaseStackMonitoringConfigResult']:
        """
        The configuration of Stack Monitoring for the external database.
        """
        return pulumi.get(self, "stack_monitoring_configs")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the specified lifecycle state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the database was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        """
        The time zone of the external database. It is a time zone offset (a character type in the format '[+|-]TZH:TZM') or a time zone region name, depending on how the time zone value was specified when the database was created / last altered.
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class GetExternalContainerDatabasesExternalContainerDatabaseDatabaseManagementConfigResult(dict):
    def __init__(__self__, *,
                 database_management_connection_id: str,
                 database_management_status: str,
                 license_model: str):
        """
        :param str database_management_connection_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param str database_management_status: The status of the Database Management service.
        :param str license_model: The Oracle license model that applies to the external database.
        """
        GetExternalContainerDatabasesExternalContainerDatabaseDatabaseManagementConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_management_connection_id=database_management_connection_id,
            database_management_status=database_management_status,
            license_model=license_model,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_management_connection_id: str,
             database_management_status: str,
             license_model: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database_management_connection_id", database_management_connection_id)
        _setter("database_management_status", database_management_status)
        _setter("license_model", license_model)

    @property
    @pulumi.getter(name="databaseManagementConnectionId")
    def database_management_connection_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "database_management_connection_id")

    @property
    @pulumi.getter(name="databaseManagementStatus")
    def database_management_status(self) -> str:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "database_management_status")

    @property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> str:
        """
        The Oracle license model that applies to the external database.
        """
        return pulumi.get(self, "license_model")


@pulumi.output_type
class GetExternalContainerDatabasesExternalContainerDatabaseStackMonitoringConfigResult(dict):
    def __init__(__self__, *,
                 stack_monitoring_connector_id: str,
                 stack_monitoring_status: str):
        """
        :param str stack_monitoring_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param str stack_monitoring_status: The status of Stack Monitoring.
        """
        GetExternalContainerDatabasesExternalContainerDatabaseStackMonitoringConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            stack_monitoring_connector_id=stack_monitoring_connector_id,
            stack_monitoring_status=stack_monitoring_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             stack_monitoring_connector_id: str,
             stack_monitoring_status: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("stack_monitoring_connector_id", stack_monitoring_connector_id)
        _setter("stack_monitoring_status", stack_monitoring_status)

    @property
    @pulumi.getter(name="stackMonitoringConnectorId")
    def stack_monitoring_connector_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "stack_monitoring_connector_id")

    @property
    @pulumi.getter(name="stackMonitoringStatus")
    def stack_monitoring_status(self) -> str:
        """
        The status of Stack Monitoring.
        """
        return pulumi.get(self, "stack_monitoring_status")


@pulumi.output_type
class GetExternalContainerDatabasesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetExternalContainerDatabasesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetExternalDatabaseConnectorConnectionCredentialResult(dict):
    def __init__(__self__, *,
                 credential_name: str,
                 credential_type: str,
                 password: str,
                 role: str,
                 ssl_secret_id: str,
                 username: str):
        """
        :param str credential_name: The name of the credential information that used to connect to the database. The name should be in "x.y" format, where the length of "x" has a maximum of 64 characters, and length of "y" has a maximum of 199 characters. The name strings can contain letters, numbers and the underscore character only. Other characters are not valid, except for the "." character that separates the "x" and "y" portions of the name. *IMPORTANT* - The name must be unique within the Oracle Cloud Infrastructure region the credential is being created in. If you specify a name that duplicates the name of another credential within the same Oracle Cloud Infrastructure region, you may overwrite or corrupt the credential that is already using the name.
        :param str credential_type: The type of credential used to connect to the database.
        :param str password: The password that will be used to connect to the database.
        :param str role: The role of the user that will be connecting to the database.
        :param str ssl_secret_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        :param str username: The username that will be used to connect to the database.
        """
        GetExternalDatabaseConnectorConnectionCredentialResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credential_name=credential_name,
            credential_type=credential_type,
            password=password,
            role=role,
            ssl_secret_id=ssl_secret_id,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credential_name: str,
             credential_type: str,
             password: str,
             role: str,
             ssl_secret_id: str,
             username: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("credential_name", credential_name)
        _setter("credential_type", credential_type)
        _setter("password", password)
        _setter("role", role)
        _setter("ssl_secret_id", ssl_secret_id)
        _setter("username", username)

    @property
    @pulumi.getter(name="credentialName")
    def credential_name(self) -> str:
        """
        The name of the credential information that used to connect to the database. The name should be in "x.y" format, where the length of "x" has a maximum of 64 characters, and length of "y" has a maximum of 199 characters. The name strings can contain letters, numbers and the underscore character only. Other characters are not valid, except for the "." character that separates the "x" and "y" portions of the name. *IMPORTANT* - The name must be unique within the Oracle Cloud Infrastructure region the credential is being created in. If you specify a name that duplicates the name of another credential within the same Oracle Cloud Infrastructure region, you may overwrite or corrupt the credential that is already using the name.
        """
        return pulumi.get(self, "credential_name")

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> str:
        """
        The type of credential used to connect to the database.
        """
        return pulumi.get(self, "credential_type")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password that will be used to connect to the database.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        The role of the user that will be connecting to the database.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter(name="sslSecretId")
    def ssl_secret_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "ssl_secret_id")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username that will be used to connect to the database.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetExternalDatabaseConnectorConnectionStringResult(dict):
    def __init__(__self__, *,
                 hostname: str,
                 port: int,
                 protocol: str,
                 service: str):
        """
        :param str hostname: The host name of the database.
        :param int port: The port used to connect to the database.
        :param str protocol: The protocol used to connect to the database.
        :param str service: The name of the service alias used to connect to the database.
        """
        GetExternalDatabaseConnectorConnectionStringResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hostname=hostname,
            port=port,
            protocol=protocol,
            service=service,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hostname: str,
             port: int,
             protocol: str,
             service: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("hostname", hostname)
        _setter("port", port)
        _setter("protocol", protocol)
        _setter("service", service)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host name of the database.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port used to connect to the database.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol used to connect to the database.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        The name of the service alias used to connect to the database.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class GetExternalDatabaseConnectorsExternalDatabaseConnectorResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 connection_credentials: Sequence['outputs.GetExternalDatabaseConnectorsExternalDatabaseConnectorConnectionCredentialResult'],
                 connection_status: str,
                 connection_strings: Sequence['outputs.GetExternalDatabaseConnectorsExternalDatabaseConnectorConnectionStringResult'],
                 connector_agent_id: str,
                 connector_type: str,
                 defined_tags: Mapping[str, Any],
                 display_name: str,
                 external_database_id: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 lifecycle_details: str,
                 state: str,
                 time_connection_status_last_updated: str,
                 time_created: str):
        """
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Sequence['GetExternalDatabaseConnectorsExternalDatabaseConnectorConnectionCredentialArgs'] connection_credentials: Credentials used to connect to the database. Currently only the `DETAILS` type is supported for creating MACS connector crendentials.
        :param str connection_status: The status of connectivity to the external database.
        :param Sequence['GetExternalDatabaseConnectorsExternalDatabaseConnectorConnectionStringArgs'] connection_strings: The Oracle Database connection string.
        :param str connector_agent_id: The ID of the agent used for the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param str connector_type: The type of connector used by the external database resource.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param str external_database_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the external database whose connectors will be listed.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str state: A filter to return only resources that match the specified lifecycle state.
        :param str time_connection_status_last_updated: The date and time the `connectionStatus` of this external connector was last updated.
        :param str time_created: The date and time the external connector was created.
        """
        GetExternalDatabaseConnectorsExternalDatabaseConnectorResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            connection_credentials=connection_credentials,
            connection_status=connection_status,
            connection_strings=connection_strings,
            connector_agent_id=connector_agent_id,
            connector_type=connector_type,
            defined_tags=defined_tags,
            display_name=display_name,
            external_database_id=external_database_id,
            freeform_tags=freeform_tags,
            id=id,
            lifecycle_details=lifecycle_details,
            state=state,
            time_connection_status_last_updated=time_connection_status_last_updated,
            time_created=time_created,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             connection_credentials: Sequence['outputs.GetExternalDatabaseConnectorsExternalDatabaseConnectorConnectionCredentialResult'],
             connection_status: str,
             connection_strings: Sequence['outputs.GetExternalDatabaseConnectorsExternalDatabaseConnectorConnectionStringResult'],
             connector_agent_id: str,
             connector_type: str,
             defined_tags: Mapping[str, Any],
             display_name: str,
             external_database_id: str,
             freeform_tags: Mapping[str, Any],
             id: str,
             lifecycle_details: str,
             state: str,
             time_connection_status_last_updated: str,
             time_created: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("compartment_id", compartment_id)
        _setter("connection_credentials", connection_credentials)
        _setter("connection_status", connection_status)
        _setter("connection_strings", connection_strings)
        _setter("connector_agent_id", connector_agent_id)
        _setter("connector_type", connector_type)
        _setter("defined_tags", defined_tags)
        _setter("display_name", display_name)
        _setter("external_database_id", external_database_id)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("state", state)
        _setter("time_connection_status_last_updated", time_connection_status_last_updated)
        _setter("time_created", time_created)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="connectionCredentials")
    def connection_credentials(self) -> Sequence['outputs.GetExternalDatabaseConnectorsExternalDatabaseConnectorConnectionCredentialResult']:
        """
        Credentials used to connect to the database. Currently only the `DETAILS` type is supported for creating MACS connector crendentials.
        """
        return pulumi.get(self, "connection_credentials")

    @property
    @pulumi.getter(name="connectionStatus")
    def connection_status(self) -> str:
        """
        The status of connectivity to the external database.
        """
        return pulumi.get(self, "connection_status")

    @property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Sequence['outputs.GetExternalDatabaseConnectorsExternalDatabaseConnectorConnectionStringResult']:
        """
        The Oracle Database connection string.
        """
        return pulumi.get(self, "connection_strings")

    @property
    @pulumi.getter(name="connectorAgentId")
    def connector_agent_id(self) -> str:
        """
        The ID of the agent used for the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "connector_agent_id")

    @property
    @pulumi.getter(name="connectorType")
    def connector_type(self) -> str:
        """
        The type of connector used by the external database resource.
        """
        return pulumi.get(self, "connector_type")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="externalDatabaseId")
    def external_database_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the external database whose connectors will be listed.
        """
        return pulumi.get(self, "external_database_id")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the specified lifecycle state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeConnectionStatusLastUpdated")
    def time_connection_status_last_updated(self) -> str:
        """
        The date and time the `connectionStatus` of this external connector was last updated.
        """
        return pulumi.get(self, "time_connection_status_last_updated")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the external connector was created.
        """
        return pulumi.get(self, "time_created")


@pulumi.output_type
class GetExternalDatabaseConnectorsExternalDatabaseConnectorConnectionCredentialResult(dict):
    def __init__(__self__, *,
                 credential_name: str,
                 credential_type: str,
                 password: str,
                 role: str,
                 ssl_secret_id: str,
                 username: str):
        """
        :param str credential_name: The name of the credential information that used to connect to the database. The name should be in "x.y" format, where the length of "x" has a maximum of 64 characters, and length of "y" has a maximum of 199 characters. The name strings can contain letters, numbers and the underscore character only. Other characters are not valid, except for the "." character that separates the "x" and "y" portions of the name. *IMPORTANT* - The name must be unique within the Oracle Cloud Infrastructure region the credential is being created in. If you specify a name that duplicates the name of another credential within the same Oracle Cloud Infrastructure region, you may overwrite or corrupt the credential that is already using the name.
        :param str credential_type: The type of credential used to connect to the database.
        :param str password: The password that will be used to connect to the database.
        :param str role: The role of the user that will be connecting to the database.
        :param str ssl_secret_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        :param str username: The username that will be used to connect to the database.
        """
        GetExternalDatabaseConnectorsExternalDatabaseConnectorConnectionCredentialResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credential_name=credential_name,
            credential_type=credential_type,
            password=password,
            role=role,
            ssl_secret_id=ssl_secret_id,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credential_name: str,
             credential_type: str,
             password: str,
             role: str,
             ssl_secret_id: str,
             username: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("credential_name", credential_name)
        _setter("credential_type", credential_type)
        _setter("password", password)
        _setter("role", role)
        _setter("ssl_secret_id", ssl_secret_id)
        _setter("username", username)

    @property
    @pulumi.getter(name="credentialName")
    def credential_name(self) -> str:
        """
        The name of the credential information that used to connect to the database. The name should be in "x.y" format, where the length of "x" has a maximum of 64 characters, and length of "y" has a maximum of 199 characters. The name strings can contain letters, numbers and the underscore character only. Other characters are not valid, except for the "." character that separates the "x" and "y" portions of the name. *IMPORTANT* - The name must be unique within the Oracle Cloud Infrastructure region the credential is being created in. If you specify a name that duplicates the name of another credential within the same Oracle Cloud Infrastructure region, you may overwrite or corrupt the credential that is already using the name.
        """
        return pulumi.get(self, "credential_name")

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> str:
        """
        The type of credential used to connect to the database.
        """
        return pulumi.get(self, "credential_type")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password that will be used to connect to the database.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        The role of the user that will be connecting to the database.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter(name="sslSecretId")
    def ssl_secret_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "ssl_secret_id")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username that will be used to connect to the database.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetExternalDatabaseConnectorsExternalDatabaseConnectorConnectionStringResult(dict):
    def __init__(__self__, *,
                 hostname: str,
                 port: int,
                 protocol: str,
                 service: str):
        """
        :param str hostname: The host name of the database.
        :param int port: The port used to connect to the database.
        :param str protocol: The protocol used to connect to the database.
        :param str service: The name of the service alias used to connect to the database.
        """
        GetExternalDatabaseConnectorsExternalDatabaseConnectorConnectionStringResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hostname=hostname,
            port=port,
            protocol=protocol,
            service=service,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hostname: str,
             port: int,
             protocol: str,
             service: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("hostname", hostname)
        _setter("port", port)
        _setter("protocol", protocol)
        _setter("service", service)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The host name of the database.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port used to connect to the database.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol used to connect to the database.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        The name of the service alias used to connect to the database.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class GetExternalDatabaseConnectorsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetExternalDatabaseConnectorsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetExternalNonContainerDatabaseDatabaseManagementConfigResult(dict):
    def __init__(__self__, *,
                 database_management_connection_id: str,
                 database_management_status: str,
                 license_model: str):
        """
        :param str database_management_connection_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param str database_management_status: The status of the Database Management service.
        :param str license_model: The Oracle license model that applies to the external database.
        """
        GetExternalNonContainerDatabaseDatabaseManagementConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_management_connection_id=database_management_connection_id,
            database_management_status=database_management_status,
            license_model=license_model,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_management_connection_id: str,
             database_management_status: str,
             license_model: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database_management_connection_id", database_management_connection_id)
        _setter("database_management_status", database_management_status)
        _setter("license_model", license_model)

    @property
    @pulumi.getter(name="databaseManagementConnectionId")
    def database_management_connection_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "database_management_connection_id")

    @property
    @pulumi.getter(name="databaseManagementStatus")
    def database_management_status(self) -> str:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "database_management_status")

    @property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> str:
        """
        The Oracle license model that applies to the external database.
        """
        return pulumi.get(self, "license_model")


@pulumi.output_type
class GetExternalNonContainerDatabaseOperationsInsightsConfigResult(dict):
    def __init__(__self__, *,
                 operations_insights_connector_id: str,
                 operations_insights_status: str):
        """
        :param str operations_insights_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param str operations_insights_status: The status of Operations Insights
        """
        GetExternalNonContainerDatabaseOperationsInsightsConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operations_insights_connector_id=operations_insights_connector_id,
            operations_insights_status=operations_insights_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operations_insights_connector_id: str,
             operations_insights_status: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("operations_insights_connector_id", operations_insights_connector_id)
        _setter("operations_insights_status", operations_insights_status)

    @property
    @pulumi.getter(name="operationsInsightsConnectorId")
    def operations_insights_connector_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "operations_insights_connector_id")

    @property
    @pulumi.getter(name="operationsInsightsStatus")
    def operations_insights_status(self) -> str:
        """
        The status of Operations Insights
        """
        return pulumi.get(self, "operations_insights_status")


@pulumi.output_type
class GetExternalNonContainerDatabaseStackMonitoringConfigResult(dict):
    def __init__(__self__, *,
                 stack_monitoring_connector_id: str,
                 stack_monitoring_status: str):
        """
        :param str stack_monitoring_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param str stack_monitoring_status: The status of Stack Monitoring.
        """
        GetExternalNonContainerDatabaseStackMonitoringConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            stack_monitoring_connector_id=stack_monitoring_connector_id,
            stack_monitoring_status=stack_monitoring_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             stack_monitoring_connector_id: str,
             stack_monitoring_status: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("stack_monitoring_connector_id", stack_monitoring_connector_id)
        _setter("stack_monitoring_status", stack_monitoring_status)

    @property
    @pulumi.getter(name="stackMonitoringConnectorId")
    def stack_monitoring_connector_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "stack_monitoring_connector_id")

    @property
    @pulumi.getter(name="stackMonitoringStatus")
    def stack_monitoring_status(self) -> str:
        """
        The status of Stack Monitoring.
        """
        return pulumi.get(self, "stack_monitoring_status")


@pulumi.output_type
class GetExternalNonContainerDatabasesExternalNonContainerDatabaseResult(dict):
    def __init__(__self__, *,
                 character_set: str,
                 compartment_id: str,
                 database_configuration: str,
                 database_edition: str,
                 database_management_configs: Sequence['outputs.GetExternalNonContainerDatabasesExternalNonContainerDatabaseDatabaseManagementConfigResult'],
                 database_version: str,
                 db_id: str,
                 db_packs: str,
                 db_unique_name: str,
                 defined_tags: Mapping[str, Any],
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 lifecycle_details: str,
                 ncharacter_set: str,
                 operations_insights_configs: Sequence['outputs.GetExternalNonContainerDatabasesExternalNonContainerDatabaseOperationsInsightsConfigResult'],
                 stack_monitoring_configs: Sequence['outputs.GetExternalNonContainerDatabasesExternalNonContainerDatabaseStackMonitoringConfigResult'],
                 state: str,
                 time_created: str,
                 time_zone: str):
        """
        :param str character_set: The character set of the external database.
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param str database_configuration: The Oracle Database configuration
        :param str database_edition: The Oracle Database edition.
        :param Sequence['GetExternalNonContainerDatabasesExternalNonContainerDatabaseDatabaseManagementConfigArgs'] database_management_configs: The configuration of the Database Management service.
        :param str database_version: The Oracle Database version.
        :param str db_id: The Oracle Database ID, which identifies an Oracle Database located outside of Oracle Cloud.
        :param str db_packs: The database packs licensed for the external Oracle Database.
        :param str db_unique_name: The `DB_UNIQUE_NAME` of the external database.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure external database resource.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str ncharacter_set: The national character of the external database.
        :param Sequence['GetExternalNonContainerDatabasesExternalNonContainerDatabaseOperationsInsightsConfigArgs'] operations_insights_configs: The configuration of Operations Insights for the external database
        :param Sequence['GetExternalNonContainerDatabasesExternalNonContainerDatabaseStackMonitoringConfigArgs'] stack_monitoring_configs: The configuration of Stack Monitoring for the external database.
        :param str state: A filter to return only resources that match the specified lifecycle state.
        :param str time_created: The date and time the database was created.
        :param str time_zone: The time zone of the external database. It is a time zone offset (a character type in the format '[+|-]TZH:TZM') or a time zone region name, depending on how the time zone value was specified when the database was created / last altered.
        """
        GetExternalNonContainerDatabasesExternalNonContainerDatabaseResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            character_set=character_set,
            compartment_id=compartment_id,
            database_configuration=database_configuration,
            database_edition=database_edition,
            database_management_configs=database_management_configs,
            database_version=database_version,
            db_id=db_id,
            db_packs=db_packs,
            db_unique_name=db_unique_name,
            defined_tags=defined_tags,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            lifecycle_details=lifecycle_details,
            ncharacter_set=ncharacter_set,
            operations_insights_configs=operations_insights_configs,
            stack_monitoring_configs=stack_monitoring_configs,
            state=state,
            time_created=time_created,
            time_zone=time_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             character_set: str,
             compartment_id: str,
             database_configuration: str,
             database_edition: str,
             database_management_configs: Sequence['outputs.GetExternalNonContainerDatabasesExternalNonContainerDatabaseDatabaseManagementConfigResult'],
             database_version: str,
             db_id: str,
             db_packs: str,
             db_unique_name: str,
             defined_tags: Mapping[str, Any],
             display_name: str,
             freeform_tags: Mapping[str, Any],
             id: str,
             lifecycle_details: str,
             ncharacter_set: str,
             operations_insights_configs: Sequence['outputs.GetExternalNonContainerDatabasesExternalNonContainerDatabaseOperationsInsightsConfigResult'],
             stack_monitoring_configs: Sequence['outputs.GetExternalNonContainerDatabasesExternalNonContainerDatabaseStackMonitoringConfigResult'],
             state: str,
             time_created: str,
             time_zone: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("character_set", character_set)
        _setter("compartment_id", compartment_id)
        _setter("database_configuration", database_configuration)
        _setter("database_edition", database_edition)
        _setter("database_management_configs", database_management_configs)
        _setter("database_version", database_version)
        _setter("db_id", db_id)
        _setter("db_packs", db_packs)
        _setter("db_unique_name", db_unique_name)
        _setter("defined_tags", defined_tags)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("ncharacter_set", ncharacter_set)
        _setter("operations_insights_configs", operations_insights_configs)
        _setter("stack_monitoring_configs", stack_monitoring_configs)
        _setter("state", state)
        _setter("time_created", time_created)
        _setter("time_zone", time_zone)

    @property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> str:
        """
        The character set of the external database.
        """
        return pulumi.get(self, "character_set")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="databaseConfiguration")
    def database_configuration(self) -> str:
        """
        The Oracle Database configuration
        """
        return pulumi.get(self, "database_configuration")

    @property
    @pulumi.getter(name="databaseEdition")
    def database_edition(self) -> str:
        """
        The Oracle Database edition.
        """
        return pulumi.get(self, "database_edition")

    @property
    @pulumi.getter(name="databaseManagementConfigs")
    def database_management_configs(self) -> Sequence['outputs.GetExternalNonContainerDatabasesExternalNonContainerDatabaseDatabaseManagementConfigResult']:
        """
        The configuration of the Database Management service.
        """
        return pulumi.get(self, "database_management_configs")

    @property
    @pulumi.getter(name="databaseVersion")
    def database_version(self) -> str:
        """
        The Oracle Database version.
        """
        return pulumi.get(self, "database_version")

    @property
    @pulumi.getter(name="dbId")
    def db_id(self) -> str:
        """
        The Oracle Database ID, which identifies an Oracle Database located outside of Oracle Cloud.
        """
        return pulumi.get(self, "db_id")

    @property
    @pulumi.getter(name="dbPacks")
    def db_packs(self) -> str:
        """
        The database packs licensed for the external Oracle Database.
        """
        return pulumi.get(self, "db_packs")

    @property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> str:
        """
        The `DB_UNIQUE_NAME` of the external database.
        """
        return pulumi.get(self, "db_unique_name")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure external database resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> str:
        """
        The national character of the external database.
        """
        return pulumi.get(self, "ncharacter_set")

    @property
    @pulumi.getter(name="operationsInsightsConfigs")
    def operations_insights_configs(self) -> Sequence['outputs.GetExternalNonContainerDatabasesExternalNonContainerDatabaseOperationsInsightsConfigResult']:
        """
        The configuration of Operations Insights for the external database
        """
        return pulumi.get(self, "operations_insights_configs")

    @property
    @pulumi.getter(name="stackMonitoringConfigs")
    def stack_monitoring_configs(self) -> Sequence['outputs.GetExternalNonContainerDatabasesExternalNonContainerDatabaseStackMonitoringConfigResult']:
        """
        The configuration of Stack Monitoring for the external database.
        """
        return pulumi.get(self, "stack_monitoring_configs")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the specified lifecycle state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the database was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        """
        The time zone of the external database. It is a time zone offset (a character type in the format '[+|-]TZH:TZM') or a time zone region name, depending on how the time zone value was specified when the database was created / last altered.
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class GetExternalNonContainerDatabasesExternalNonContainerDatabaseDatabaseManagementConfigResult(dict):
    def __init__(__self__, *,
                 database_management_connection_id: str,
                 database_management_status: str,
                 license_model: str):
        """
        :param str database_management_connection_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param str database_management_status: The status of the Database Management service.
        :param str license_model: The Oracle license model that applies to the external database.
        """
        GetExternalNonContainerDatabasesExternalNonContainerDatabaseDatabaseManagementConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_management_connection_id=database_management_connection_id,
            database_management_status=database_management_status,
            license_model=license_model,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_management_connection_id: str,
             database_management_status: str,
             license_model: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database_management_connection_id", database_management_connection_id)
        _setter("database_management_status", database_management_status)
        _setter("license_model", license_model)

    @property
    @pulumi.getter(name="databaseManagementConnectionId")
    def database_management_connection_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "database_management_connection_id")

    @property
    @pulumi.getter(name="databaseManagementStatus")
    def database_management_status(self) -> str:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "database_management_status")

    @property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> str:
        """
        The Oracle license model that applies to the external database.
        """
        return pulumi.get(self, "license_model")


@pulumi.output_type
class GetExternalNonContainerDatabasesExternalNonContainerDatabaseOperationsInsightsConfigResult(dict):
    def __init__(__self__, *,
                 operations_insights_connector_id: str,
                 operations_insights_status: str):
        """
        :param str operations_insights_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param str operations_insights_status: The status of Operations Insights
        """
        GetExternalNonContainerDatabasesExternalNonContainerDatabaseOperationsInsightsConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operations_insights_connector_id=operations_insights_connector_id,
            operations_insights_status=operations_insights_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operations_insights_connector_id: str,
             operations_insights_status: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("operations_insights_connector_id", operations_insights_connector_id)
        _setter("operations_insights_status", operations_insights_status)

    @property
    @pulumi.getter(name="operationsInsightsConnectorId")
    def operations_insights_connector_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "operations_insights_connector_id")

    @property
    @pulumi.getter(name="operationsInsightsStatus")
    def operations_insights_status(self) -> str:
        """
        The status of Operations Insights
        """
        return pulumi.get(self, "operations_insights_status")


@pulumi.output_type
class GetExternalNonContainerDatabasesExternalNonContainerDatabaseStackMonitoringConfigResult(dict):
    def __init__(__self__, *,
                 stack_monitoring_connector_id: str,
                 stack_monitoring_status: str):
        """
        :param str stack_monitoring_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param str stack_monitoring_status: The status of Stack Monitoring.
        """
        GetExternalNonContainerDatabasesExternalNonContainerDatabaseStackMonitoringConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            stack_monitoring_connector_id=stack_monitoring_connector_id,
            stack_monitoring_status=stack_monitoring_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             stack_monitoring_connector_id: str,
             stack_monitoring_status: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("stack_monitoring_connector_id", stack_monitoring_connector_id)
        _setter("stack_monitoring_status", stack_monitoring_status)

    @property
    @pulumi.getter(name="stackMonitoringConnectorId")
    def stack_monitoring_connector_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "stack_monitoring_connector_id")

    @property
    @pulumi.getter(name="stackMonitoringStatus")
    def stack_monitoring_status(self) -> str:
        """
        The status of Stack Monitoring.
        """
        return pulumi.get(self, "stack_monitoring_status")


@pulumi.output_type
class GetExternalNonContainerDatabasesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetExternalNonContainerDatabasesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetExternalPluggableDatabaseDatabaseManagementConfigResult(dict):
    def __init__(__self__, *,
                 database_management_connection_id: str,
                 database_management_status: str,
                 license_model: str):
        """
        :param str database_management_connection_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param str database_management_status: The status of the Database Management service.
        :param str license_model: The Oracle license model that applies to the external database.
        """
        GetExternalPluggableDatabaseDatabaseManagementConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_management_connection_id=database_management_connection_id,
            database_management_status=database_management_status,
            license_model=license_model,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_management_connection_id: str,
             database_management_status: str,
             license_model: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database_management_connection_id", database_management_connection_id)
        _setter("database_management_status", database_management_status)
        _setter("license_model", license_model)

    @property
    @pulumi.getter(name="databaseManagementConnectionId")
    def database_management_connection_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "database_management_connection_id")

    @property
    @pulumi.getter(name="databaseManagementStatus")
    def database_management_status(self) -> str:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "database_management_status")

    @property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> str:
        """
        The Oracle license model that applies to the external database.
        """
        return pulumi.get(self, "license_model")


@pulumi.output_type
class GetExternalPluggableDatabaseOperationsInsightsConfigResult(dict):
    def __init__(__self__, *,
                 operations_insights_connector_id: str,
                 operations_insights_status: str):
        """
        :param str operations_insights_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param str operations_insights_status: The status of Operations Insights
        """
        GetExternalPluggableDatabaseOperationsInsightsConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operations_insights_connector_id=operations_insights_connector_id,
            operations_insights_status=operations_insights_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operations_insights_connector_id: str,
             operations_insights_status: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("operations_insights_connector_id", operations_insights_connector_id)
        _setter("operations_insights_status", operations_insights_status)

    @property
    @pulumi.getter(name="operationsInsightsConnectorId")
    def operations_insights_connector_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "operations_insights_connector_id")

    @property
    @pulumi.getter(name="operationsInsightsStatus")
    def operations_insights_status(self) -> str:
        """
        The status of Operations Insights
        """
        return pulumi.get(self, "operations_insights_status")


@pulumi.output_type
class GetExternalPluggableDatabaseStackMonitoringConfigResult(dict):
    def __init__(__self__, *,
                 stack_monitoring_connector_id: str,
                 stack_monitoring_status: str):
        """
        :param str stack_monitoring_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param str stack_monitoring_status: The status of Stack Monitoring.
        """
        GetExternalPluggableDatabaseStackMonitoringConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            stack_monitoring_connector_id=stack_monitoring_connector_id,
            stack_monitoring_status=stack_monitoring_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             stack_monitoring_connector_id: str,
             stack_monitoring_status: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("stack_monitoring_connector_id", stack_monitoring_connector_id)
        _setter("stack_monitoring_status", stack_monitoring_status)

    @property
    @pulumi.getter(name="stackMonitoringConnectorId")
    def stack_monitoring_connector_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "stack_monitoring_connector_id")

    @property
    @pulumi.getter(name="stackMonitoringStatus")
    def stack_monitoring_status(self) -> str:
        """
        The status of Stack Monitoring.
        """
        return pulumi.get(self, "stack_monitoring_status")


@pulumi.output_type
class GetExternalPluggableDatabasesExternalPluggableDatabaseResult(dict):
    def __init__(__self__, *,
                 character_set: str,
                 compartment_id: str,
                 database_configuration: str,
                 database_edition: str,
                 database_management_configs: Sequence['outputs.GetExternalPluggableDatabasesExternalPluggableDatabaseDatabaseManagementConfigResult'],
                 database_version: str,
                 db_id: str,
                 db_packs: str,
                 db_unique_name: str,
                 defined_tags: Mapping[str, Any],
                 display_name: str,
                 external_container_database_id: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 lifecycle_details: str,
                 ncharacter_set: str,
                 operations_insights_configs: Sequence['outputs.GetExternalPluggableDatabasesExternalPluggableDatabaseOperationsInsightsConfigResult'],
                 source_id: str,
                 stack_monitoring_configs: Sequence['outputs.GetExternalPluggableDatabasesExternalPluggableDatabaseStackMonitoringConfigResult'],
                 state: str,
                 time_created: str,
                 time_zone: str):
        """
        :param str character_set: The character set of the external database.
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param str database_configuration: The Oracle Database configuration
        :param str database_edition: The Oracle Database edition.
        :param Sequence['GetExternalPluggableDatabasesExternalPluggableDatabaseDatabaseManagementConfigArgs'] database_management_configs: The configuration of the Database Management service.
        :param str database_version: The Oracle Database version.
        :param str db_id: The Oracle Database ID, which identifies an Oracle Database located outside of Oracle Cloud.
        :param str db_packs: The database packs licensed for the external Oracle Database.
        :param str db_unique_name: The `DB_UNIQUE_NAME` of the external database.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param str external_container_database_id: The ExternalContainerDatabase [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure external database resource.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str ncharacter_set: The national character of the external database.
        :param Sequence['GetExternalPluggableDatabasesExternalPluggableDatabaseOperationsInsightsConfigArgs'] operations_insights_configs: The configuration of Operations Insights for the external database
        :param str source_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the the non-container database that was converted to a pluggable database to create this resource.
        :param Sequence['GetExternalPluggableDatabasesExternalPluggableDatabaseStackMonitoringConfigArgs'] stack_monitoring_configs: The configuration of Stack Monitoring for the external database.
        :param str state: A filter to return only resources that match the specified lifecycle state.
        :param str time_created: The date and time the database was created.
        :param str time_zone: The time zone of the external database. It is a time zone offset (a character type in the format '[+|-]TZH:TZM') or a time zone region name, depending on how the time zone value was specified when the database was created / last altered.
        """
        GetExternalPluggableDatabasesExternalPluggableDatabaseResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            character_set=character_set,
            compartment_id=compartment_id,
            database_configuration=database_configuration,
            database_edition=database_edition,
            database_management_configs=database_management_configs,
            database_version=database_version,
            db_id=db_id,
            db_packs=db_packs,
            db_unique_name=db_unique_name,
            defined_tags=defined_tags,
            display_name=display_name,
            external_container_database_id=external_container_database_id,
            freeform_tags=freeform_tags,
            id=id,
            lifecycle_details=lifecycle_details,
            ncharacter_set=ncharacter_set,
            operations_insights_configs=operations_insights_configs,
            source_id=source_id,
            stack_monitoring_configs=stack_monitoring_configs,
            state=state,
            time_created=time_created,
            time_zone=time_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             character_set: str,
             compartment_id: str,
             database_configuration: str,
             database_edition: str,
             database_management_configs: Sequence['outputs.GetExternalPluggableDatabasesExternalPluggableDatabaseDatabaseManagementConfigResult'],
             database_version: str,
             db_id: str,
             db_packs: str,
             db_unique_name: str,
             defined_tags: Mapping[str, Any],
             display_name: str,
             external_container_database_id: str,
             freeform_tags: Mapping[str, Any],
             id: str,
             lifecycle_details: str,
             ncharacter_set: str,
             operations_insights_configs: Sequence['outputs.GetExternalPluggableDatabasesExternalPluggableDatabaseOperationsInsightsConfigResult'],
             source_id: str,
             stack_monitoring_configs: Sequence['outputs.GetExternalPluggableDatabasesExternalPluggableDatabaseStackMonitoringConfigResult'],
             state: str,
             time_created: str,
             time_zone: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("character_set", character_set)
        _setter("compartment_id", compartment_id)
        _setter("database_configuration", database_configuration)
        _setter("database_edition", database_edition)
        _setter("database_management_configs", database_management_configs)
        _setter("database_version", database_version)
        _setter("db_id", db_id)
        _setter("db_packs", db_packs)
        _setter("db_unique_name", db_unique_name)
        _setter("defined_tags", defined_tags)
        _setter("display_name", display_name)
        _setter("external_container_database_id", external_container_database_id)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("ncharacter_set", ncharacter_set)
        _setter("operations_insights_configs", operations_insights_configs)
        _setter("source_id", source_id)
        _setter("stack_monitoring_configs", stack_monitoring_configs)
        _setter("state", state)
        _setter("time_created", time_created)
        _setter("time_zone", time_zone)

    @property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> str:
        """
        The character set of the external database.
        """
        return pulumi.get(self, "character_set")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="databaseConfiguration")
    def database_configuration(self) -> str:
        """
        The Oracle Database configuration
        """
        return pulumi.get(self, "database_configuration")

    @property
    @pulumi.getter(name="databaseEdition")
    def database_edition(self) -> str:
        """
        The Oracle Database edition.
        """
        return pulumi.get(self, "database_edition")

    @property
    @pulumi.getter(name="databaseManagementConfigs")
    def database_management_configs(self) -> Sequence['outputs.GetExternalPluggableDatabasesExternalPluggableDatabaseDatabaseManagementConfigResult']:
        """
        The configuration of the Database Management service.
        """
        return pulumi.get(self, "database_management_configs")

    @property
    @pulumi.getter(name="databaseVersion")
    def database_version(self) -> str:
        """
        The Oracle Database version.
        """
        return pulumi.get(self, "database_version")

    @property
    @pulumi.getter(name="dbId")
    def db_id(self) -> str:
        """
        The Oracle Database ID, which identifies an Oracle Database located outside of Oracle Cloud.
        """
        return pulumi.get(self, "db_id")

    @property
    @pulumi.getter(name="dbPacks")
    def db_packs(self) -> str:
        """
        The database packs licensed for the external Oracle Database.
        """
        return pulumi.get(self, "db_packs")

    @property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> str:
        """
        The `DB_UNIQUE_NAME` of the external database.
        """
        return pulumi.get(self, "db_unique_name")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="externalContainerDatabaseId")
    def external_container_database_id(self) -> str:
        """
        The ExternalContainerDatabase [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "external_container_database_id")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure external database resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> str:
        """
        The national character of the external database.
        """
        return pulumi.get(self, "ncharacter_set")

    @property
    @pulumi.getter(name="operationsInsightsConfigs")
    def operations_insights_configs(self) -> Sequence['outputs.GetExternalPluggableDatabasesExternalPluggableDatabaseOperationsInsightsConfigResult']:
        """
        The configuration of Operations Insights for the external database
        """
        return pulumi.get(self, "operations_insights_configs")

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the the non-container database that was converted to a pluggable database to create this resource.
        """
        return pulumi.get(self, "source_id")

    @property
    @pulumi.getter(name="stackMonitoringConfigs")
    def stack_monitoring_configs(self) -> Sequence['outputs.GetExternalPluggableDatabasesExternalPluggableDatabaseStackMonitoringConfigResult']:
        """
        The configuration of Stack Monitoring for the external database.
        """
        return pulumi.get(self, "stack_monitoring_configs")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the specified lifecycle state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the database was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        """
        The time zone of the external database. It is a time zone offset (a character type in the format '[+|-]TZH:TZM') or a time zone region name, depending on how the time zone value was specified when the database was created / last altered.
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class GetExternalPluggableDatabasesExternalPluggableDatabaseDatabaseManagementConfigResult(dict):
    def __init__(__self__, *,
                 database_management_connection_id: str,
                 database_management_status: str,
                 license_model: str):
        """
        :param str database_management_connection_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param str database_management_status: The status of the Database Management service.
        :param str license_model: The Oracle license model that applies to the external database.
        """
        GetExternalPluggableDatabasesExternalPluggableDatabaseDatabaseManagementConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_management_connection_id=database_management_connection_id,
            database_management_status=database_management_status,
            license_model=license_model,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_management_connection_id: str,
             database_management_status: str,
             license_model: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database_management_connection_id", database_management_connection_id)
        _setter("database_management_status", database_management_status)
        _setter("license_model", license_model)

    @property
    @pulumi.getter(name="databaseManagementConnectionId")
    def database_management_connection_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "database_management_connection_id")

    @property
    @pulumi.getter(name="databaseManagementStatus")
    def database_management_status(self) -> str:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "database_management_status")

    @property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> str:
        """
        The Oracle license model that applies to the external database.
        """
        return pulumi.get(self, "license_model")


@pulumi.output_type
class GetExternalPluggableDatabasesExternalPluggableDatabaseOperationsInsightsConfigResult(dict):
    def __init__(__self__, *,
                 operations_insights_connector_id: str,
                 operations_insights_status: str):
        """
        :param str operations_insights_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param str operations_insights_status: The status of Operations Insights
        """
        GetExternalPluggableDatabasesExternalPluggableDatabaseOperationsInsightsConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operations_insights_connector_id=operations_insights_connector_id,
            operations_insights_status=operations_insights_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operations_insights_connector_id: str,
             operations_insights_status: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("operations_insights_connector_id", operations_insights_connector_id)
        _setter("operations_insights_status", operations_insights_status)

    @property
    @pulumi.getter(name="operationsInsightsConnectorId")
    def operations_insights_connector_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "operations_insights_connector_id")

    @property
    @pulumi.getter(name="operationsInsightsStatus")
    def operations_insights_status(self) -> str:
        """
        The status of Operations Insights
        """
        return pulumi.get(self, "operations_insights_status")


@pulumi.output_type
class GetExternalPluggableDatabasesExternalPluggableDatabaseStackMonitoringConfigResult(dict):
    def __init__(__self__, *,
                 stack_monitoring_connector_id: str,
                 stack_monitoring_status: str):
        """
        :param str stack_monitoring_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param str stack_monitoring_status: The status of Stack Monitoring.
        """
        GetExternalPluggableDatabasesExternalPluggableDatabaseStackMonitoringConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            stack_monitoring_connector_id=stack_monitoring_connector_id,
            stack_monitoring_status=stack_monitoring_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             stack_monitoring_connector_id: str,
             stack_monitoring_status: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("stack_monitoring_connector_id", stack_monitoring_connector_id)
        _setter("stack_monitoring_status", stack_monitoring_status)

    @property
    @pulumi.getter(name="stackMonitoringConnectorId")
    def stack_monitoring_connector_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "stack_monitoring_connector_id")

    @property
    @pulumi.getter(name="stackMonitoringStatus")
    def stack_monitoring_status(self) -> str:
        """
        The status of Stack Monitoring.
        """
        return pulumi.get(self, "stack_monitoring_status")


@pulumi.output_type
class GetExternalPluggableDatabasesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetExternalPluggableDatabasesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetFlexComponentsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to return only resources that match the entire name given. The match is not case sensitive.
        """
        GetFlexComponentsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to return only resources that match the entire name given. The match is not case sensitive.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetFlexComponentsFlexComponentCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetFlexComponentsFlexComponentCollectionItemResult']):
        GetFlexComponentsFlexComponentCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Sequence['outputs.GetFlexComponentsFlexComponentCollectionItemResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetFlexComponentsFlexComponentCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetFlexComponentsFlexComponentCollectionItemResult(dict):
    def __init__(__self__, *,
                 available_core_count: int,
                 available_db_storage_in_gbs: int,
                 minimum_core_count: int,
                 name: str):
        """
        :param int available_core_count: The maximum number of CPU cores that can ben enabled on the DB Server for this Flex Component.
        :param int available_db_storage_in_gbs: The maximum  storage that can be enabled on the Storage Server for this Flex Component.
        :param int minimum_core_count: The minimum number of CPU cores that can be enabled on the DB Server for this Flex Component.
        :param str name: A filter to return only resources that match the entire name given. The match is not case sensitive.
        """
        GetFlexComponentsFlexComponentCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            available_core_count=available_core_count,
            available_db_storage_in_gbs=available_db_storage_in_gbs,
            minimum_core_count=minimum_core_count,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             available_core_count: int,
             available_db_storage_in_gbs: int,
             minimum_core_count: int,
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("available_core_count", available_core_count)
        _setter("available_db_storage_in_gbs", available_db_storage_in_gbs)
        _setter("minimum_core_count", minimum_core_count)
        _setter("name", name)

    @property
    @pulumi.getter(name="availableCoreCount")
    def available_core_count(self) -> int:
        """
        The maximum number of CPU cores that can ben enabled on the DB Server for this Flex Component.
        """
        return pulumi.get(self, "available_core_count")

    @property
    @pulumi.getter(name="availableDbStorageInGbs")
    def available_db_storage_in_gbs(self) -> int:
        """
        The maximum  storage that can be enabled on the Storage Server for this Flex Component.
        """
        return pulumi.get(self, "available_db_storage_in_gbs")

    @property
    @pulumi.getter(name="minimumCoreCount")
    def minimum_core_count(self) -> int:
        """
        The minimum number of CPU cores that can be enabled on the DB Server for this Flex Component.
        """
        return pulumi.get(self, "minimum_core_count")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to return only resources that match the entire name given. The match is not case sensitive.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetGiVersionsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetGiVersionsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetGiVersionsGiVersionResult(dict):
    def __init__(__self__, *,
                 version: str):
        """
        :param str version: A valid Oracle Grid Infrastructure (GI) software version.
        """
        GetGiVersionsGiVersionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             version: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("version", version)

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        A valid Oracle Grid Infrastructure (GI) software version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetKeyStoreAssociatedDatabaseResult(dict):
    def __init__(__self__, *,
                 db_name: str,
                 id: str):
        """
        :param str db_name: The name of the database that is associated with the key store.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        """
        GetKeyStoreAssociatedDatabaseResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_name=db_name,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_name: str,
             id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("db_name", db_name)
        _setter("id", id)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> str:
        """
        The name of the database that is associated with the key store.
        """
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetKeyStoreTypeDetailResult(dict):
    def __init__(__self__, *,
                 admin_username: str,
                 connection_ips: Sequence[str],
                 secret_id: str,
                 type: str,
                 vault_id: str):
        """
        :param str admin_username: The administrator username to connect to Oracle Key Vault
        :param Sequence[str] connection_ips: The list of Oracle Key Vault connection IP addresses.
        :param str secret_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        :param str type: The type of key store.
        :param str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        GetKeyStoreTypeDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            admin_username=admin_username,
            connection_ips=connection_ips,
            secret_id=secret_id,
            type=type,
            vault_id=vault_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             admin_username: str,
             connection_ips: Sequence[str],
             secret_id: str,
             type: str,
             vault_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("admin_username", admin_username)
        _setter("connection_ips", connection_ips)
        _setter("secret_id", secret_id)
        _setter("type", type)
        _setter("vault_id", vault_id)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> str:
        """
        The administrator username to connect to Oracle Key Vault
        """
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="connectionIps")
    def connection_ips(self) -> Sequence[str]:
        """
        The list of Oracle Key Vault connection IP addresses.
        """
        return pulumi.get(self, "connection_ips")

    @property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "secret_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of key store.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class GetKeyStoresFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetKeyStoresFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetKeyStoresKeyStoreResult(dict):
    def __init__(__self__, *,
                 associated_databases: Sequence['outputs.GetKeyStoresKeyStoreAssociatedDatabaseResult'],
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 display_name: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 lifecycle_details: str,
                 state: str,
                 time_created: str,
                 type_details: Sequence['outputs.GetKeyStoresKeyStoreTypeDetailResult']):
        """
        :param Sequence['GetKeyStoresKeyStoreAssociatedDatabaseArgs'] associated_databases: List of databases associated with the key store.
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str display_name: The user-friendly name for the key store. The name does not need to be unique.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str state: The current state of the key store.
        :param str time_created: The date and time that the key store was created.
        :param Sequence['GetKeyStoresKeyStoreTypeDetailArgs'] type_details: Key store type details.
        """
        GetKeyStoresKeyStoreResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            associated_databases=associated_databases,
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            display_name=display_name,
            freeform_tags=freeform_tags,
            id=id,
            lifecycle_details=lifecycle_details,
            state=state,
            time_created=time_created,
            type_details=type_details,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             associated_databases: Sequence['outputs.GetKeyStoresKeyStoreAssociatedDatabaseResult'],
             compartment_id: str,
             defined_tags: Mapping[str, Any],
             display_name: str,
             freeform_tags: Mapping[str, Any],
             id: str,
             lifecycle_details: str,
             state: str,
             time_created: str,
             type_details: Sequence['outputs.GetKeyStoresKeyStoreTypeDetailResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("associated_databases", associated_databases)
        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("display_name", display_name)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("state", state)
        _setter("time_created", time_created)
        _setter("type_details", type_details)

    @property
    @pulumi.getter(name="associatedDatabases")
    def associated_databases(self) -> Sequence['outputs.GetKeyStoresKeyStoreAssociatedDatabaseResult']:
        """
        List of databases associated with the key store.
        """
        return pulumi.get(self, "associated_databases")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The user-friendly name for the key store. The name does not need to be unique.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the key store.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time that the key store was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="typeDetails")
    def type_details(self) -> Sequence['outputs.GetKeyStoresKeyStoreTypeDetailResult']:
        """
        Key store type details.
        """
        return pulumi.get(self, "type_details")


@pulumi.output_type
class GetKeyStoresKeyStoreAssociatedDatabaseResult(dict):
    def __init__(__self__, *,
                 db_name: str,
                 id: str):
        """
        :param str db_name: The name of the database that is associated with the key store.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        """
        GetKeyStoresKeyStoreAssociatedDatabaseResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_name=db_name,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_name: str,
             id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("db_name", db_name)
        _setter("id", id)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> str:
        """
        The name of the database that is associated with the key store.
        """
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetKeyStoresKeyStoreTypeDetailResult(dict):
    def __init__(__self__, *,
                 admin_username: str,
                 connection_ips: Sequence[str],
                 secret_id: str,
                 type: str,
                 vault_id: str):
        """
        :param str admin_username: The administrator username to connect to Oracle Key Vault
        :param Sequence[str] connection_ips: The list of Oracle Key Vault connection IP addresses.
        :param str secret_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        :param str type: The type of key store.
        :param str vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        GetKeyStoresKeyStoreTypeDetailResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            admin_username=admin_username,
            connection_ips=connection_ips,
            secret_id=secret_id,
            type=type,
            vault_id=vault_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             admin_username: str,
             connection_ips: Sequence[str],
             secret_id: str,
             type: str,
             vault_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("admin_username", admin_username)
        _setter("connection_ips", connection_ips)
        _setter("secret_id", secret_id)
        _setter("type", type)
        _setter("vault_id", vault_id)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> str:
        """
        The administrator username to connect to Oracle Key Vault
        """
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="connectionIps")
    def connection_ips(self) -> Sequence[str]:
        """
        The list of Oracle Key Vault connection IP addresses.
        """
        return pulumi.get(self, "connection_ips")

    @property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "secret_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of key store.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")


@pulumi.output_type
class GetMaintenanceRunEstimatedPatchingTimeResult(dict):
    def __init__(__self__, *,
                 estimated_db_server_patching_time: int,
                 estimated_network_switches_patching_time: int,
                 estimated_storage_server_patching_time: int,
                 total_estimated_patching_time: int):
        """
        :param int estimated_db_server_patching_time: The estimated time required in minutes for database server patching.
        :param int estimated_network_switches_patching_time: The estimated time required in minutes for network switch patching.
        :param int estimated_storage_server_patching_time: The estimated time required in minutes for storage server patching.
        :param int total_estimated_patching_time: The estimated total time required in minutes for all patching operations.
        """
        GetMaintenanceRunEstimatedPatchingTimeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            estimated_db_server_patching_time=estimated_db_server_patching_time,
            estimated_network_switches_patching_time=estimated_network_switches_patching_time,
            estimated_storage_server_patching_time=estimated_storage_server_patching_time,
            total_estimated_patching_time=total_estimated_patching_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             estimated_db_server_patching_time: int,
             estimated_network_switches_patching_time: int,
             estimated_storage_server_patching_time: int,
             total_estimated_patching_time: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("estimated_db_server_patching_time", estimated_db_server_patching_time)
        _setter("estimated_network_switches_patching_time", estimated_network_switches_patching_time)
        _setter("estimated_storage_server_patching_time", estimated_storage_server_patching_time)
        _setter("total_estimated_patching_time", total_estimated_patching_time)

    @property
    @pulumi.getter(name="estimatedDbServerPatchingTime")
    def estimated_db_server_patching_time(self) -> int:
        """
        The estimated time required in minutes for database server patching.
        """
        return pulumi.get(self, "estimated_db_server_patching_time")

    @property
    @pulumi.getter(name="estimatedNetworkSwitchesPatchingTime")
    def estimated_network_switches_patching_time(self) -> int:
        """
        The estimated time required in minutes for network switch patching.
        """
        return pulumi.get(self, "estimated_network_switches_patching_time")

    @property
    @pulumi.getter(name="estimatedStorageServerPatchingTime")
    def estimated_storage_server_patching_time(self) -> int:
        """
        The estimated time required in minutes for storage server patching.
        """
        return pulumi.get(self, "estimated_storage_server_patching_time")

    @property
    @pulumi.getter(name="totalEstimatedPatchingTime")
    def total_estimated_patching_time(self) -> int:
        """
        The estimated total time required in minutes for all patching operations.
        """
        return pulumi.get(self, "total_estimated_patching_time")


@pulumi.output_type
class GetMaintenanceRunsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetMaintenanceRunsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetMaintenanceRunsMaintenanceRunResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 current_custom_action_timeout_in_mins: int,
                 current_patching_component: str,
                 custom_action_timeout_in_mins: int,
                 description: str,
                 display_name: str,
                 estimated_component_patching_start_time: str,
                 estimated_patching_times: Sequence['outputs.GetMaintenanceRunsMaintenanceRunEstimatedPatchingTimeResult'],
                 id: str,
                 is_custom_action_timeout_enabled: bool,
                 is_enabled: bool,
                 is_patch_now_enabled: bool,
                 is_resume_patching: bool,
                 lifecycle_details: str,
                 maintenance_run_id: str,
                 maintenance_subtype: str,
                 maintenance_type: str,
                 patch_failure_count: int,
                 patch_id: str,
                 patching_end_time: str,
                 patching_mode: str,
                 patching_start_time: str,
                 patching_status: str,
                 peer_maintenance_run_id: str,
                 state: str,
                 target_db_server_version: str,
                 target_resource_id: str,
                 target_resource_type: str,
                 target_storage_server_version: str,
                 time_ended: str,
                 time_scheduled: str,
                 time_started: str):
        """
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param int current_custom_action_timeout_in_mins: Extend current custom action timeout between the current database servers during waiting state, from 0 (zero) to 30 minutes.
        :param str current_patching_component: The name of the current infrastruture component that is getting patched.
        :param int custom_action_timeout_in_mins: Determines the amount of time the system will wait before the start of each database server patching operation. Specify a number of minutes, from 15 to 120.
        :param str description: Description of the maintenance run.
        :param str display_name: The user-friendly name for the maintenance run.
        :param str estimated_component_patching_start_time: The estimated start time of the next infrastruture component patching operation.
        :param Sequence['GetMaintenanceRunsMaintenanceRunEstimatedPatchingTimeArgs'] estimated_patching_times: The estimated total time required in minutes for all patching operations (database server, storage server, and network switch patching).
        :param str id: The OCID of the maintenance run.
        :param bool is_custom_action_timeout_enabled: If true, enables the configuration of a custom action timeout (waiting period) between database servers patching operations.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param str maintenance_subtype: The sub-type of the maintenance run.
        :param str maintenance_type: The maintenance type.
        :param int patch_failure_count: Contain the patch failure count.
        :param str patch_id: The unique identifier of the patch. The identifier string includes the patch type, the Oracle Database version, and the patch creation date (using the format YYMMDD). For example, the identifier `ru_patch_19.9.0.0_201030` is used for an RU patch for Oracle Database 19.9.0.0 that was released October 30, 2020.
        :param str patching_end_time: The time when the patching operation ended.
        :param str patching_mode: Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        :param str patching_start_time: The time when the patching operation started.
        :param str patching_status: The status of the patching operation.
        :param str peer_maintenance_run_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance run for the Autonomous Data Guard association's peer container database.
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        :param str target_db_server_version: The target software version for the database server patching operation.
        :param str target_resource_id: The target resource ID.
        :param str target_resource_type: The type of the target resource. Accepted values are: AUTONOMOUS_CONTAINER_DATABASE, AUTONOMOUS_EXADATA_INFRASTRUCTURE, EXADATA_DB_SYSTEM
        :param str target_storage_server_version: The target Cell version that is to be patched to.
        :param str time_ended: The date and time the maintenance run was completed.
        :param str time_scheduled: The date and time the maintenance run is scheduled to occur.
        :param str time_started: The date and time the maintenance run starts.
        """
        GetMaintenanceRunsMaintenanceRunResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            current_custom_action_timeout_in_mins=current_custom_action_timeout_in_mins,
            current_patching_component=current_patching_component,
            custom_action_timeout_in_mins=custom_action_timeout_in_mins,
            description=description,
            display_name=display_name,
            estimated_component_patching_start_time=estimated_component_patching_start_time,
            estimated_patching_times=estimated_patching_times,
            id=id,
            is_custom_action_timeout_enabled=is_custom_action_timeout_enabled,
            is_enabled=is_enabled,
            is_patch_now_enabled=is_patch_now_enabled,
            is_resume_patching=is_resume_patching,
            lifecycle_details=lifecycle_details,
            maintenance_run_id=maintenance_run_id,
            maintenance_subtype=maintenance_subtype,
            maintenance_type=maintenance_type,
            patch_failure_count=patch_failure_count,
            patch_id=patch_id,
            patching_end_time=patching_end_time,
            patching_mode=patching_mode,
            patching_start_time=patching_start_time,
            patching_status=patching_status,
            peer_maintenance_run_id=peer_maintenance_run_id,
            state=state,
            target_db_server_version=target_db_server_version,
            target_resource_id=target_resource_id,
            target_resource_type=target_resource_type,
            target_storage_server_version=target_storage_server_version,
            time_ended=time_ended,
            time_scheduled=time_scheduled,
            time_started=time_started,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             current_custom_action_timeout_in_mins: int,
             current_patching_component: str,
             custom_action_timeout_in_mins: int,
             description: str,
             display_name: str,
             estimated_component_patching_start_time: str,
             estimated_patching_times: Sequence['outputs.GetMaintenanceRunsMaintenanceRunEstimatedPatchingTimeResult'],
             id: str,
             is_custom_action_timeout_enabled: bool,
             is_enabled: bool,
             is_patch_now_enabled: bool,
             is_resume_patching: bool,
             lifecycle_details: str,
             maintenance_run_id: str,
             maintenance_subtype: str,
             maintenance_type: str,
             patch_failure_count: int,
             patch_id: str,
             patching_end_time: str,
             patching_mode: str,
             patching_start_time: str,
             patching_status: str,
             peer_maintenance_run_id: str,
             state: str,
             target_db_server_version: str,
             target_resource_id: str,
             target_resource_type: str,
             target_storage_server_version: str,
             time_ended: str,
             time_scheduled: str,
             time_started: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("compartment_id", compartment_id)
        _setter("current_custom_action_timeout_in_mins", current_custom_action_timeout_in_mins)
        _setter("current_patching_component", current_patching_component)
        _setter("custom_action_timeout_in_mins", custom_action_timeout_in_mins)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("estimated_component_patching_start_time", estimated_component_patching_start_time)
        _setter("estimated_patching_times", estimated_patching_times)
        _setter("id", id)
        _setter("is_custom_action_timeout_enabled", is_custom_action_timeout_enabled)
        _setter("is_enabled", is_enabled)
        _setter("is_patch_now_enabled", is_patch_now_enabled)
        _setter("is_resume_patching", is_resume_patching)
        _setter("lifecycle_details", lifecycle_details)
        _setter("maintenance_run_id", maintenance_run_id)
        _setter("maintenance_subtype", maintenance_subtype)
        _setter("maintenance_type", maintenance_type)
        _setter("patch_failure_count", patch_failure_count)
        _setter("patch_id", patch_id)
        _setter("patching_end_time", patching_end_time)
        _setter("patching_mode", patching_mode)
        _setter("patching_start_time", patching_start_time)
        _setter("patching_status", patching_status)
        _setter("peer_maintenance_run_id", peer_maintenance_run_id)
        _setter("state", state)
        _setter("target_db_server_version", target_db_server_version)
        _setter("target_resource_id", target_resource_id)
        _setter("target_resource_type", target_resource_type)
        _setter("target_storage_server_version", target_storage_server_version)
        _setter("time_ended", time_ended)
        _setter("time_scheduled", time_scheduled)
        _setter("time_started", time_started)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="currentCustomActionTimeoutInMins")
    def current_custom_action_timeout_in_mins(self) -> int:
        """
        Extend current custom action timeout between the current database servers during waiting state, from 0 (zero) to 30 minutes.
        """
        return pulumi.get(self, "current_custom_action_timeout_in_mins")

    @property
    @pulumi.getter(name="currentPatchingComponent")
    def current_patching_component(self) -> str:
        """
        The name of the current infrastruture component that is getting patched.
        """
        return pulumi.get(self, "current_patching_component")

    @property
    @pulumi.getter(name="customActionTimeoutInMins")
    def custom_action_timeout_in_mins(self) -> int:
        """
        Determines the amount of time the system will wait before the start of each database server patching operation. Specify a number of minutes, from 15 to 120.
        """
        return pulumi.get(self, "custom_action_timeout_in_mins")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of the maintenance run.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The user-friendly name for the maintenance run.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="estimatedComponentPatchingStartTime")
    def estimated_component_patching_start_time(self) -> str:
        """
        The estimated start time of the next infrastruture component patching operation.
        """
        return pulumi.get(self, "estimated_component_patching_start_time")

    @property
    @pulumi.getter(name="estimatedPatchingTimes")
    def estimated_patching_times(self) -> Sequence['outputs.GetMaintenanceRunsMaintenanceRunEstimatedPatchingTimeResult']:
        """
        The estimated total time required in minutes for all patching operations (database server, storage server, and network switch patching).
        """
        return pulumi.get(self, "estimated_patching_times")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The OCID of the maintenance run.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isCustomActionTimeoutEnabled")
    def is_custom_action_timeout_enabled(self) -> bool:
        """
        If true, enables the configuration of a custom action timeout (waiting period) between database servers patching operations.
        """
        return pulumi.get(self, "is_custom_action_timeout_enabled")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="isPatchNowEnabled")
    def is_patch_now_enabled(self) -> bool:
        return pulumi.get(self, "is_patch_now_enabled")

    @property
    @pulumi.getter(name="isResumePatching")
    def is_resume_patching(self) -> bool:
        return pulumi.get(self, "is_resume_patching")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="maintenanceRunId")
    def maintenance_run_id(self) -> str:
        return pulumi.get(self, "maintenance_run_id")

    @property
    @pulumi.getter(name="maintenanceSubtype")
    def maintenance_subtype(self) -> str:
        """
        The sub-type of the maintenance run.
        """
        return pulumi.get(self, "maintenance_subtype")

    @property
    @pulumi.getter(name="maintenanceType")
    def maintenance_type(self) -> str:
        """
        The maintenance type.
        """
        return pulumi.get(self, "maintenance_type")

    @property
    @pulumi.getter(name="patchFailureCount")
    def patch_failure_count(self) -> int:
        """
        Contain the patch failure count.
        """
        return pulumi.get(self, "patch_failure_count")

    @property
    @pulumi.getter(name="patchId")
    def patch_id(self) -> str:
        """
        The unique identifier of the patch. The identifier string includes the patch type, the Oracle Database version, and the patch creation date (using the format YYMMDD). For example, the identifier `ru_patch_19.9.0.0_201030` is used for an RU patch for Oracle Database 19.9.0.0 that was released October 30, 2020.
        """
        return pulumi.get(self, "patch_id")

    @property
    @pulumi.getter(name="patchingEndTime")
    def patching_end_time(self) -> str:
        """
        The time when the patching operation ended.
        """
        return pulumi.get(self, "patching_end_time")

    @property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> str:
        """
        Cloud Exadata infrastructure node patching method, either "ROLLING" or "NONROLLING". Default value is ROLLING.
        """
        return pulumi.get(self, "patching_mode")

    @property
    @pulumi.getter(name="patchingStartTime")
    def patching_start_time(self) -> str:
        """
        The time when the patching operation started.
        """
        return pulumi.get(self, "patching_start_time")

    @property
    @pulumi.getter(name="patchingStatus")
    def patching_status(self) -> str:
        """
        The status of the patching operation.
        """
        return pulumi.get(self, "patching_status")

    @property
    @pulumi.getter(name="peerMaintenanceRunId")
    def peer_maintenance_run_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance run for the Autonomous Data Guard association's peer container database.
        """
        return pulumi.get(self, "peer_maintenance_run_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="targetDbServerVersion")
    def target_db_server_version(self) -> str:
        """
        The target software version for the database server patching operation.
        """
        return pulumi.get(self, "target_db_server_version")

    @property
    @pulumi.getter(name="targetResourceId")
    def target_resource_id(self) -> str:
        """
        The target resource ID.
        """
        return pulumi.get(self, "target_resource_id")

    @property
    @pulumi.getter(name="targetResourceType")
    def target_resource_type(self) -> str:
        """
        The type of the target resource. Accepted values are: AUTONOMOUS_CONTAINER_DATABASE, AUTONOMOUS_EXADATA_INFRASTRUCTURE, EXADATA_DB_SYSTEM
        """
        return pulumi.get(self, "target_resource_type")

    @property
    @pulumi.getter(name="targetStorageServerVersion")
    def target_storage_server_version(self) -> str:
        """
        The target Cell version that is to be patched to.
        """
        return pulumi.get(self, "target_storage_server_version")

    @property
    @pulumi.getter(name="timeEnded")
    def time_ended(self) -> str:
        """
        The date and time the maintenance run was completed.
        """
        return pulumi.get(self, "time_ended")

    @property
    @pulumi.getter(name="timeScheduled")
    def time_scheduled(self) -> str:
        """
        The date and time the maintenance run is scheduled to occur.
        """
        return pulumi.get(self, "time_scheduled")

    @property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> str:
        """
        The date and time the maintenance run starts.
        """
        return pulumi.get(self, "time_started")


@pulumi.output_type
class GetMaintenanceRunsMaintenanceRunEstimatedPatchingTimeResult(dict):
    def __init__(__self__, *,
                 estimated_db_server_patching_time: int,
                 estimated_network_switches_patching_time: int,
                 estimated_storage_server_patching_time: int,
                 total_estimated_patching_time: int):
        """
        :param int estimated_db_server_patching_time: The estimated time required in minutes for database server patching.
        :param int estimated_network_switches_patching_time: The estimated time required in minutes for network switch patching.
        :param int estimated_storage_server_patching_time: The estimated time required in minutes for storage server patching.
        :param int total_estimated_patching_time: The estimated total time required in minutes for all patching operations.
        """
        GetMaintenanceRunsMaintenanceRunEstimatedPatchingTimeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            estimated_db_server_patching_time=estimated_db_server_patching_time,
            estimated_network_switches_patching_time=estimated_network_switches_patching_time,
            estimated_storage_server_patching_time=estimated_storage_server_patching_time,
            total_estimated_patching_time=total_estimated_patching_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             estimated_db_server_patching_time: int,
             estimated_network_switches_patching_time: int,
             estimated_storage_server_patching_time: int,
             total_estimated_patching_time: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("estimated_db_server_patching_time", estimated_db_server_patching_time)
        _setter("estimated_network_switches_patching_time", estimated_network_switches_patching_time)
        _setter("estimated_storage_server_patching_time", estimated_storage_server_patching_time)
        _setter("total_estimated_patching_time", total_estimated_patching_time)

    @property
    @pulumi.getter(name="estimatedDbServerPatchingTime")
    def estimated_db_server_patching_time(self) -> int:
        """
        The estimated time required in minutes for database server patching.
        """
        return pulumi.get(self, "estimated_db_server_patching_time")

    @property
    @pulumi.getter(name="estimatedNetworkSwitchesPatchingTime")
    def estimated_network_switches_patching_time(self) -> int:
        """
        The estimated time required in minutes for network switch patching.
        """
        return pulumi.get(self, "estimated_network_switches_patching_time")

    @property
    @pulumi.getter(name="estimatedStorageServerPatchingTime")
    def estimated_storage_server_patching_time(self) -> int:
        """
        The estimated time required in minutes for storage server patching.
        """
        return pulumi.get(self, "estimated_storage_server_patching_time")

    @property
    @pulumi.getter(name="totalEstimatedPatchingTime")
    def total_estimated_patching_time(self) -> int:
        """
        The estimated total time required in minutes for all patching operations.
        """
        return pulumi.get(self, "total_estimated_patching_time")


@pulumi.output_type
class GetManagedPreferredCredentialsFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetManagedPreferredCredentialsFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetManagedPreferredCredentialsPreferredCredentialCollectionResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetManagedPreferredCredentialsPreferredCredentialCollectionItemResult']):
        GetManagedPreferredCredentialsPreferredCredentialCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            items=items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             items: Sequence['outputs.GetManagedPreferredCredentialsPreferredCredentialCollectionItemResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("items", items)

    @property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetManagedPreferredCredentialsPreferredCredentialCollectionItemResult']:
        return pulumi.get(self, "items")


@pulumi.output_type
class GetManagedPreferredCredentialsPreferredCredentialCollectionItemResult(dict):
    def __init__(__self__, *,
                 credential_name: str,
                 is_accessible: bool,
                 password_secret_id: str,
                 role: str,
                 status: str,
                 type: str,
                 user_name: str):
        """
        :param str credential_name: The name of the preferred credential.
        :param bool is_accessible: Indicates whether the preferred credential is accessible.
        :param str password_secret_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Vault service secret that contains the database user password.
        :param str role: The role of the database user.
        :param str status: The status of the preferred credential.
        :param str type: The type of preferred credential. Only 'BASIC' is supported currently.
        :param str user_name: The user name used to connect to the database.
        """
        GetManagedPreferredCredentialsPreferredCredentialCollectionItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credential_name=credential_name,
            is_accessible=is_accessible,
            password_secret_id=password_secret_id,
            role=role,
            status=status,
            type=type,
            user_name=user_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credential_name: str,
             is_accessible: bool,
             password_secret_id: str,
             role: str,
             status: str,
             type: str,
             user_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("credential_name", credential_name)
        _setter("is_accessible", is_accessible)
        _setter("password_secret_id", password_secret_id)
        _setter("role", role)
        _setter("status", status)
        _setter("type", type)
        _setter("user_name", user_name)

    @property
    @pulumi.getter(name="credentialName")
    def credential_name(self) -> str:
        """
        The name of the preferred credential.
        """
        return pulumi.get(self, "credential_name")

    @property
    @pulumi.getter(name="isAccessible")
    def is_accessible(self) -> bool:
        """
        Indicates whether the preferred credential is accessible.
        """
        return pulumi.get(self, "is_accessible")

    @property
    @pulumi.getter(name="passwordSecretId")
    def password_secret_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Vault service secret that contains the database user password.
        """
        return pulumi.get(self, "password_secret_id")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        The role of the database user.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the preferred credential.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of preferred credential. Only 'BASIC' is supported currently.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> str:
        """
        The user name used to connect to the database.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class GetOneoffPatchesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetOneoffPatchesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetOneoffPatchesOneoffPatchResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 db_version: str,
                 defined_tags: Mapping[str, Any],
                 display_name: str,
                 download_oneoff_patch_trigger: int,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 lifecycle_details: str,
                 one_off_patches: Sequence[str],
                 release_update: str,
                 sha256sum: str,
                 size_in_kbs: float,
                 state: str,
                 time_created: str,
                 time_of_expiration: str,
                 time_updated: str):
        """
        :param str compartment_id: (Updatable) The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param str db_version: A valid Oracle Database version. To get a list of supported versions, use the [ListDbVersions](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/DbVersionSummary/ListDbVersions) operation.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the one-off patch.
        :param str lifecycle_details: Detailed message for the lifecycle state.
        :param Sequence[str] one_off_patches: List of one-off patches for Database Homes.
        :param str release_update: The PSU or PBP or Release Updates. To get a list of supported versions, use the [ListDbVersions](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/DbVersionSummary/ListDbVersions) operation.
        :param str sha256sum: SHA-256 checksum of the one-off patch.
        :param float size_in_kbs: The size of one-off patch in kilobytes.
        :param str state: A filter to return only resources that match the given lifecycle state exactly
        :param str time_created: The date and time one-off patch was created.
        :param str time_of_expiration: The date and time until which the one-off patch will be available for download.
        :param str time_updated: The date and time one-off patch was updated.
        """
        GetOneoffPatchesOneoffPatchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            db_version=db_version,
            defined_tags=defined_tags,
            display_name=display_name,
            download_oneoff_patch_trigger=download_oneoff_patch_trigger,
            freeform_tags=freeform_tags,
            id=id,
            lifecycle_details=lifecycle_details,
            one_off_patches=one_off_patches,
            release_update=release_update,
            sha256sum=sha256sum,
            size_in_kbs=size_in_kbs,
            state=state,
            time_created=time_created,
            time_of_expiration=time_of_expiration,
            time_updated=time_updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             db_version: str,
             defined_tags: Mapping[str, Any],
             display_name: str,
             download_oneoff_patch_trigger: int,
             freeform_tags: Mapping[str, Any],
             id: str,
             lifecycle_details: str,
             one_off_patches: Sequence[str],
             release_update: str,
             sha256sum: str,
             size_in_kbs: float,
             state: str,
             time_created: str,
             time_of_expiration: str,
             time_updated: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("compartment_id", compartment_id)
        _setter("db_version", db_version)
        _setter("defined_tags", defined_tags)
        _setter("display_name", display_name)
        _setter("download_oneoff_patch_trigger", download_oneoff_patch_trigger)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("one_off_patches", one_off_patches)
        _setter("release_update", release_update)
        _setter("sha256sum", sha256sum)
        _setter("size_in_kbs", size_in_kbs)
        _setter("state", state)
        _setter("time_created", time_created)
        _setter("time_of_expiration", time_of_expiration)
        _setter("time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        (Updatable) The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> str:
        """
        A valid Oracle Database version. To get a list of supported versions, use the [ListDbVersions](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/DbVersionSummary/ListDbVersions) operation.
        """
        return pulumi.get(self, "db_version")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="downloadOneoffPatchTrigger")
    def download_oneoff_patch_trigger(self) -> int:
        return pulumi.get(self, "download_oneoff_patch_trigger")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the one-off patch.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Detailed message for the lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="oneOffPatches")
    def one_off_patches(self) -> Sequence[str]:
        """
        List of one-off patches for Database Homes.
        """
        return pulumi.get(self, "one_off_patches")

    @property
    @pulumi.getter(name="releaseUpdate")
    def release_update(self) -> str:
        """
        The PSU or PBP or Release Updates. To get a list of supported versions, use the [ListDbVersions](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/DbVersionSummary/ListDbVersions) operation.
        """
        return pulumi.get(self, "release_update")

    @property
    @pulumi.getter
    def sha256sum(self) -> str:
        """
        SHA-256 checksum of the one-off patch.
        """
        return pulumi.get(self, "sha256sum")

    @property
    @pulumi.getter(name="sizeInKbs")
    def size_in_kbs(self) -> float:
        """
        The size of one-off patch in kilobytes.
        """
        return pulumi.get(self, "size_in_kbs")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time one-off patch was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeOfExpiration")
    def time_of_expiration(self) -> str:
        """
        The date and time until which the one-off patch will be available for download.
        """
        return pulumi.get(self, "time_of_expiration")

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> str:
        """
        The date and time one-off patch was updated.
        """
        return pulumi.get(self, "time_updated")


@pulumi.output_type
class GetPluggableDatabaseConnectionStringResult(dict):
    def __init__(__self__, *,
                 all_connection_strings: Mapping[str, Any],
                 pdb_default: str,
                 pdb_ip_default: str):
        """
        :param Mapping[str, Any] all_connection_strings: All connection strings to use to connect to the pluggable database.
        :param str pdb_default: A host name-based PDB connection string.
        :param str pdb_ip_default: An IP-based PDB connection string.
        """
        GetPluggableDatabaseConnectionStringResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_connection_strings=all_connection_strings,
            pdb_default=pdb_default,
            pdb_ip_default=pdb_ip_default,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_connection_strings: Mapping[str, Any],
             pdb_default: str,
             pdb_ip_default: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("all_connection_strings", all_connection_strings)
        _setter("pdb_default", pdb_default)
        _setter("pdb_ip_default", pdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Mapping[str, Any]:
        """
        All connection strings to use to connect to the pluggable database.
        """
        return pulumi.get(self, "all_connection_strings")

    @property
    @pulumi.getter(name="pdbDefault")
    def pdb_default(self) -> str:
        """
        A host name-based PDB connection string.
        """
        return pulumi.get(self, "pdb_default")

    @property
    @pulumi.getter(name="pdbIpDefault")
    def pdb_ip_default(self) -> str:
        """
        An IP-based PDB connection string.
        """
        return pulumi.get(self, "pdb_ip_default")


@pulumi.output_type
class GetPluggableDatabasePluggableDatabaseManagementConfigResult(dict):
    def __init__(__self__, *,
                 management_status: str):
        """
        :param str management_status: The status of the Pluggable Database Management service.
        """
        GetPluggableDatabasePluggableDatabaseManagementConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            management_status=management_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             management_status: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("management_status", management_status)

    @property
    @pulumi.getter(name="managementStatus")
    def management_status(self) -> str:
        """
        The status of the Pluggable Database Management service.
        """
        return pulumi.get(self, "management_status")


@pulumi.output_type
class GetPluggableDatabasesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetPluggableDatabasesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetPluggableDatabasesPluggableDatabaseResult(dict):
    def __init__(__self__, *,
                 compartment_id: str,
                 connection_strings: Sequence['outputs.GetPluggableDatabasesPluggableDatabaseConnectionStringResult'],
                 container_database_id: str,
                 defined_tags: Mapping[str, Any],
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 is_restricted: bool,
                 lifecycle_details: str,
                 open_mode: str,
                 pdb_admin_password: str,
                 pdb_name: str,
                 pluggable_database_management_configs: Sequence['outputs.GetPluggableDatabasesPluggableDatabasePluggableDatabaseManagementConfigResult'],
                 rotate_key_trigger: int,
                 should_pdb_admin_account_be_locked: bool,
                 state: str,
                 tde_wallet_password: str,
                 time_created: str):
        """
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Sequence['GetPluggableDatabasesPluggableDatabaseConnectionStringArgs'] connection_strings: Connection strings to connect to an Oracle Pluggable Database.
        :param str container_database_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the CDB.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the pluggable database.
        :param bool is_restricted: The restricted mode of the pluggable database. If a pluggable database is opened in restricted mode, the user needs both create a session and have restricted session privileges to connect to it.
        :param str lifecycle_details: Detailed message for the lifecycle state.
        :param str open_mode: The mode that pluggable database is in. Open mode can only be changed to READ_ONLY or MIGRATE directly from the backend (within the Oracle Database software).
        :param str pdb_name: A filter to return only pluggable databases that match the entire name given. The match is not case sensitive.
        :param Sequence['GetPluggableDatabasesPluggableDatabasePluggableDatabaseManagementConfigArgs'] pluggable_database_management_configs: The configuration of the Pluggable Database Management service.
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        :param str time_created: The date and time the pluggable database was created.
        """
        GetPluggableDatabasesPluggableDatabaseResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compartment_id=compartment_id,
            connection_strings=connection_strings,
            container_database_id=container_database_id,
            defined_tags=defined_tags,
            freeform_tags=freeform_tags,
            id=id,
            is_restricted=is_restricted,
            lifecycle_details=lifecycle_details,
            open_mode=open_mode,
            pdb_admin_password=pdb_admin_password,
            pdb_name=pdb_name,
            pluggable_database_management_configs=pluggable_database_management_configs,
            rotate_key_trigger=rotate_key_trigger,
            should_pdb_admin_account_be_locked=should_pdb_admin_account_be_locked,
            state=state,
            tde_wallet_password=tde_wallet_password,
            time_created=time_created,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compartment_id: str,
             connection_strings: Sequence['outputs.GetPluggableDatabasesPluggableDatabaseConnectionStringResult'],
             container_database_id: str,
             defined_tags: Mapping[str, Any],
             freeform_tags: Mapping[str, Any],
             id: str,
             is_restricted: bool,
             lifecycle_details: str,
             open_mode: str,
             pdb_admin_password: str,
             pdb_name: str,
             pluggable_database_management_configs: Sequence['outputs.GetPluggableDatabasesPluggableDatabasePluggableDatabaseManagementConfigResult'],
             rotate_key_trigger: int,
             should_pdb_admin_account_be_locked: bool,
             state: str,
             tde_wallet_password: str,
             time_created: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("compartment_id", compartment_id)
        _setter("connection_strings", connection_strings)
        _setter("container_database_id", container_database_id)
        _setter("defined_tags", defined_tags)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("is_restricted", is_restricted)
        _setter("lifecycle_details", lifecycle_details)
        _setter("open_mode", open_mode)
        _setter("pdb_admin_password", pdb_admin_password)
        _setter("pdb_name", pdb_name)
        _setter("pluggable_database_management_configs", pluggable_database_management_configs)
        _setter("rotate_key_trigger", rotate_key_trigger)
        _setter("should_pdb_admin_account_be_locked", should_pdb_admin_account_be_locked)
        _setter("state", state)
        _setter("tde_wallet_password", tde_wallet_password)
        _setter("time_created", time_created)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Sequence['outputs.GetPluggableDatabasesPluggableDatabaseConnectionStringResult']:
        """
        Connection strings to connect to an Oracle Pluggable Database.
        """
        return pulumi.get(self, "connection_strings")

    @property
    @pulumi.getter(name="containerDatabaseId")
    def container_database_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the CDB.
        """
        return pulumi.get(self, "container_database_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the pluggable database.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isRestricted")
    def is_restricted(self) -> bool:
        """
        The restricted mode of the pluggable database. If a pluggable database is opened in restricted mode, the user needs both create a session and have restricted session privileges to connect to it.
        """
        return pulumi.get(self, "is_restricted")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Detailed message for the lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="openMode")
    def open_mode(self) -> str:
        """
        The mode that pluggable database is in. Open mode can only be changed to READ_ONLY or MIGRATE directly from the backend (within the Oracle Database software).
        """
        return pulumi.get(self, "open_mode")

    @property
    @pulumi.getter(name="pdbAdminPassword")
    def pdb_admin_password(self) -> str:
        return pulumi.get(self, "pdb_admin_password")

    @property
    @pulumi.getter(name="pdbName")
    def pdb_name(self) -> str:
        """
        A filter to return only pluggable databases that match the entire name given. The match is not case sensitive.
        """
        return pulumi.get(self, "pdb_name")

    @property
    @pulumi.getter(name="pluggableDatabaseManagementConfigs")
    def pluggable_database_management_configs(self) -> Sequence['outputs.GetPluggableDatabasesPluggableDatabasePluggableDatabaseManagementConfigResult']:
        """
        The configuration of the Pluggable Database Management service.
        """
        return pulumi.get(self, "pluggable_database_management_configs")

    @property
    @pulumi.getter(name="rotateKeyTrigger")
    def rotate_key_trigger(self) -> int:
        return pulumi.get(self, "rotate_key_trigger")

    @property
    @pulumi.getter(name="shouldPdbAdminAccountBeLocked")
    def should_pdb_admin_account_be_locked(self) -> bool:
        return pulumi.get(self, "should_pdb_admin_account_be_locked")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="tdeWalletPassword")
    def tde_wallet_password(self) -> str:
        return pulumi.get(self, "tde_wallet_password")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time the pluggable database was created.
        """
        return pulumi.get(self, "time_created")


@pulumi.output_type
class GetPluggableDatabasesPluggableDatabaseConnectionStringResult(dict):
    def __init__(__self__, *,
                 all_connection_strings: Mapping[str, Any],
                 pdb_default: str,
                 pdb_ip_default: str):
        """
        :param Mapping[str, Any] all_connection_strings: All connection strings to use to connect to the pluggable database.
        :param str pdb_default: A host name-based PDB connection string.
        :param str pdb_ip_default: An IP-based PDB connection string.
        """
        GetPluggableDatabasesPluggableDatabaseConnectionStringResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            all_connection_strings=all_connection_strings,
            pdb_default=pdb_default,
            pdb_ip_default=pdb_ip_default,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             all_connection_strings: Mapping[str, Any],
             pdb_default: str,
             pdb_ip_default: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("all_connection_strings", all_connection_strings)
        _setter("pdb_default", pdb_default)
        _setter("pdb_ip_default", pdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Mapping[str, Any]:
        """
        All connection strings to use to connect to the pluggable database.
        """
        return pulumi.get(self, "all_connection_strings")

    @property
    @pulumi.getter(name="pdbDefault")
    def pdb_default(self) -> str:
        """
        A host name-based PDB connection string.
        """
        return pulumi.get(self, "pdb_default")

    @property
    @pulumi.getter(name="pdbIpDefault")
    def pdb_ip_default(self) -> str:
        """
        An IP-based PDB connection string.
        """
        return pulumi.get(self, "pdb_ip_default")


@pulumi.output_type
class GetPluggableDatabasesPluggableDatabasePluggableDatabaseManagementConfigResult(dict):
    def __init__(__self__, *,
                 management_status: str):
        """
        :param str management_status: The status of the Pluggable Database Management service.
        """
        GetPluggableDatabasesPluggableDatabasePluggableDatabaseManagementConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            management_status=management_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             management_status: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("management_status", management_status)

    @property
    @pulumi.getter(name="managementStatus")
    def management_status(self) -> str:
        """
        The status of the Pluggable Database Management service.
        """
        return pulumi.get(self, "management_status")


@pulumi.output_type
class GetVmClusterDataCollectionOptionResult(dict):
    def __init__(__self__, *,
                 is_diagnostics_events_enabled: bool,
                 is_health_monitoring_enabled: bool,
                 is_incident_logs_enabled: bool):
        """
        :param bool is_diagnostics_events_enabled: Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param bool is_health_monitoring_enabled: Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param bool is_incident_logs_enabled: Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        GetVmClusterDataCollectionOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_diagnostics_events_enabled=is_diagnostics_events_enabled,
            is_health_monitoring_enabled=is_health_monitoring_enabled,
            is_incident_logs_enabled=is_incident_logs_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_diagnostics_events_enabled: bool,
             is_health_monitoring_enabled: bool,
             is_incident_logs_enabled: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        _setter("is_health_monitoring_enabled", is_health_monitoring_enabled)
        _setter("is_incident_logs_enabled", is_incident_logs_enabled)

    @property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> bool:
        """
        Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> bool:
        """
        Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> bool:
        """
        Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")


@pulumi.output_type
class GetVmClusterNetworkDrScanResult(dict):
    def __init__(__self__, *,
                 hostname: str,
                 ips: Sequence[str],
                 scan_listener_port_tcp: int):
        """
        :param str hostname: The node host name.
        :param Sequence[str] ips: The list of SCAN IP addresses. Three addresses should be provided.
        :param int scan_listener_port_tcp: The SCAN TCPIP port. Default is 1521.
        """
        GetVmClusterNetworkDrScanResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hostname=hostname,
            ips=ips,
            scan_listener_port_tcp=scan_listener_port_tcp,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hostname: str,
             ips: Sequence[str],
             scan_listener_port_tcp: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("hostname", hostname)
        _setter("ips", ips)
        _setter("scan_listener_port_tcp", scan_listener_port_tcp)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The node host name.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def ips(self) -> Sequence[str]:
        """
        The list of SCAN IP addresses. Three addresses should be provided.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="scanListenerPortTcp")
    def scan_listener_port_tcp(self) -> int:
        """
        The SCAN TCPIP port. Default is 1521.
        """
        return pulumi.get(self, "scan_listener_port_tcp")


@pulumi.output_type
class GetVmClusterNetworkScanResult(dict):
    def __init__(__self__, *,
                 hostname: str,
                 ips: Sequence[str],
                 port: int,
                 scan_listener_port_tcp: int,
                 scan_listener_port_tcp_ssl: int):
        """
        :param str hostname: The node host name.
        :param Sequence[str] ips: The list of SCAN IP addresses. Three addresses should be provided.
        :param int port: **Deprecated.** This field is deprecated. You may use 'scanListenerPortTcp' to specify the port. The SCAN TCPIP port. Default is 1521.
        :param int scan_listener_port_tcp: The SCAN TCPIP port. Default is 1521.
        :param int scan_listener_port_tcp_ssl: The SCAN TCPIP SSL port. Default is 2484.
        """
        GetVmClusterNetworkScanResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hostname=hostname,
            ips=ips,
            port=port,
            scan_listener_port_tcp=scan_listener_port_tcp,
            scan_listener_port_tcp_ssl=scan_listener_port_tcp_ssl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hostname: str,
             ips: Sequence[str],
             port: int,
             scan_listener_port_tcp: int,
             scan_listener_port_tcp_ssl: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("hostname", hostname)
        _setter("ips", ips)
        _setter("port", port)
        _setter("scan_listener_port_tcp", scan_listener_port_tcp)
        _setter("scan_listener_port_tcp_ssl", scan_listener_port_tcp_ssl)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The node host name.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def ips(self) -> Sequence[str]:
        """
        The list of SCAN IP addresses. Three addresses should be provided.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        **Deprecated.** This field is deprecated. You may use 'scanListenerPortTcp' to specify the port. The SCAN TCPIP port. Default is 1521.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="scanListenerPortTcp")
    def scan_listener_port_tcp(self) -> int:
        """
        The SCAN TCPIP port. Default is 1521.
        """
        return pulumi.get(self, "scan_listener_port_tcp")

    @property
    @pulumi.getter(name="scanListenerPortTcpSsl")
    def scan_listener_port_tcp_ssl(self) -> int:
        """
        The SCAN TCPIP SSL port. Default is 2484.
        """
        return pulumi.get(self, "scan_listener_port_tcp_ssl")


@pulumi.output_type
class GetVmClusterNetworkVmNetworkResult(dict):
    def __init__(__self__, *,
                 domain_name: str,
                 gateway: str,
                 netmask: str,
                 network_type: str,
                 nodes: Sequence['outputs.GetVmClusterNetworkVmNetworkNodeResult'],
                 vlan_id: str):
        """
        :param str domain_name: The network domain name.
        :param str gateway: The network gateway.
        :param str netmask: The network netmask.
        :param str network_type: The network type.
        :param Sequence['GetVmClusterNetworkVmNetworkNodeArgs'] nodes: The list of node details.
        :param str vlan_id: The network VLAN ID.
        """
        GetVmClusterNetworkVmNetworkResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain_name=domain_name,
            gateway=gateway,
            netmask=netmask,
            network_type=network_type,
            nodes=nodes,
            vlan_id=vlan_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain_name: str,
             gateway: str,
             netmask: str,
             network_type: str,
             nodes: Sequence['outputs.GetVmClusterNetworkVmNetworkNodeResult'],
             vlan_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("domain_name", domain_name)
        _setter("gateway", gateway)
        _setter("netmask", netmask)
        _setter("network_type", network_type)
        _setter("nodes", nodes)
        _setter("vlan_id", vlan_id)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> str:
        """
        The network domain name.
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        The network gateway.
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter
    def netmask(self) -> str:
        """
        The network netmask.
        """
        return pulumi.get(self, "netmask")

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> str:
        """
        The network type.
        """
        return pulumi.get(self, "network_type")

    @property
    @pulumi.getter
    def nodes(self) -> Sequence['outputs.GetVmClusterNetworkVmNetworkNodeResult']:
        """
        The list of node details.
        """
        return pulumi.get(self, "nodes")

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> str:
        """
        The network VLAN ID.
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class GetVmClusterNetworkVmNetworkNodeResult(dict):
    def __init__(__self__, *,
                 db_server_id: str,
                 hostname: str,
                 ip: str,
                 state: str,
                 vip: str,
                 vip_hostname: str):
        """
        :param str db_server_id: The Db server associated with the node.
        :param str hostname: The node host name.
        :param str ip: The node IP address.
        :param str state: The current state of the VM cluster network nodes. CREATING - The resource is being created REQUIRES_VALIDATION - The resource is created and may not be usable until it is validated. VALIDATING - The resource is being validated and not available to use. VALIDATED - The resource is validated and is available for consumption by VM cluster. VALIDATION_FAILED - The resource validation has failed and might require user input to be corrected. UPDATING - The resource is being updated and not available to use. ALLOCATED - The resource is currently being used by VM cluster. TERMINATING - The resource is being deleted and not available to use. TERMINATED - The resource is deleted and unavailable. FAILED - The resource is in a failed state due to validation or other errors.
        :param str vip: The node virtual IP (VIP) address.
        :param str vip_hostname: The node virtual IP (VIP) host name.
        """
        GetVmClusterNetworkVmNetworkNodeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_server_id=db_server_id,
            hostname=hostname,
            ip=ip,
            state=state,
            vip=vip,
            vip_hostname=vip_hostname,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_server_id: str,
             hostname: str,
             ip: str,
             state: str,
             vip: str,
             vip_hostname: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("db_server_id", db_server_id)
        _setter("hostname", hostname)
        _setter("ip", ip)
        _setter("state", state)
        _setter("vip", vip)
        _setter("vip_hostname", vip_hostname)

    @property
    @pulumi.getter(name="dbServerId")
    def db_server_id(self) -> str:
        """
        The Db server associated with the node.
        """
        return pulumi.get(self, "db_server_id")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The node host name.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        The node IP address.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the VM cluster network nodes. CREATING - The resource is being created REQUIRES_VALIDATION - The resource is created and may not be usable until it is validated. VALIDATING - The resource is being validated and not available to use. VALIDATED - The resource is validated and is available for consumption by VM cluster. VALIDATION_FAILED - The resource validation has failed and might require user input to be corrected. UPDATING - The resource is being updated and not available to use. ALLOCATED - The resource is currently being used by VM cluster. TERMINATING - The resource is being deleted and not available to use. TERMINATED - The resource is deleted and unavailable. FAILED - The resource is in a failed state due to validation or other errors.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def vip(self) -> str:
        """
        The node virtual IP (VIP) address.
        """
        return pulumi.get(self, "vip")

    @property
    @pulumi.getter(name="vipHostname")
    def vip_hostname(self) -> str:
        """
        The node virtual IP (VIP) host name.
        """
        return pulumi.get(self, "vip_hostname")


@pulumi.output_type
class GetVmClusterNetworksFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetVmClusterNetworksFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetVmClusterNetworksVmClusterNetworkResult(dict):
    def __init__(__self__, *,
                 action: str,
                 compartment_id: str,
                 defined_tags: Mapping[str, Any],
                 display_name: str,
                 dns: Sequence[str],
                 dr_scans: Sequence['outputs.GetVmClusterNetworksVmClusterNetworkDrScanResult'],
                 exadata_infrastructure_id: str,
                 freeform_tags: Mapping[str, Any],
                 id: str,
                 lifecycle_details: str,
                 ntps: Sequence[str],
                 scans: Sequence['outputs.GetVmClusterNetworksVmClusterNetworkScanResult'],
                 state: str,
                 time_created: str,
                 validate_vm_cluster_network: bool,
                 vm_cluster_id: str,
                 vm_networks: Sequence['outputs.GetVmClusterNetworksVmClusterNetworkVmNetworkResult']):
        """
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param Sequence[str] dns: The list of DNS server IP addresses. Maximum of 3 allowed.
        :param Sequence['GetVmClusterNetworksVmClusterNetworkDrScanArgs'] dr_scans: The SCAN details for DR network
        :param str exadata_infrastructure_id: The Exadata infrastructure [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VM cluster network.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param Sequence[str] ntps: The list of NTP server IP addresses. Maximum of 3 allowed.
        :param Sequence['GetVmClusterNetworksVmClusterNetworkScanArgs'] scans: The SCAN details.
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        :param str time_created: The date and time when the VM cluster network was created.
        :param str vm_cluster_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the associated VM Cluster.
        :param Sequence['GetVmClusterNetworksVmClusterNetworkVmNetworkArgs'] vm_networks: Details of the client and backup networks.
        """
        GetVmClusterNetworksVmClusterNetworkResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            compartment_id=compartment_id,
            defined_tags=defined_tags,
            display_name=display_name,
            dns=dns,
            dr_scans=dr_scans,
            exadata_infrastructure_id=exadata_infrastructure_id,
            freeform_tags=freeform_tags,
            id=id,
            lifecycle_details=lifecycle_details,
            ntps=ntps,
            scans=scans,
            state=state,
            time_created=time_created,
            validate_vm_cluster_network=validate_vm_cluster_network,
            vm_cluster_id=vm_cluster_id,
            vm_networks=vm_networks,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: str,
             compartment_id: str,
             defined_tags: Mapping[str, Any],
             display_name: str,
             dns: Sequence[str],
             dr_scans: Sequence['outputs.GetVmClusterNetworksVmClusterNetworkDrScanResult'],
             exadata_infrastructure_id: str,
             freeform_tags: Mapping[str, Any],
             id: str,
             lifecycle_details: str,
             ntps: Sequence[str],
             scans: Sequence['outputs.GetVmClusterNetworksVmClusterNetworkScanResult'],
             state: str,
             time_created: str,
             validate_vm_cluster_network: bool,
             vm_cluster_id: str,
             vm_networks: Sequence['outputs.GetVmClusterNetworksVmClusterNetworkVmNetworkResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action", action)
        _setter("compartment_id", compartment_id)
        _setter("defined_tags", defined_tags)
        _setter("display_name", display_name)
        _setter("dns", dns)
        _setter("dr_scans", dr_scans)
        _setter("exadata_infrastructure_id", exadata_infrastructure_id)
        _setter("freeform_tags", freeform_tags)
        _setter("id", id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("ntps", ntps)
        _setter("scans", scans)
        _setter("state", state)
        _setter("time_created", time_created)
        _setter("validate_vm_cluster_network", validate_vm_cluster_network)
        _setter("vm_cluster_id", vm_cluster_id)
        _setter("vm_networks", vm_networks)

    @property
    @pulumi.getter
    def action(self) -> str:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def dns(self) -> Sequence[str]:
        """
        The list of DNS server IP addresses. Maximum of 3 allowed.
        """
        return pulumi.get(self, "dns")

    @property
    @pulumi.getter(name="drScans")
    def dr_scans(self) -> Sequence['outputs.GetVmClusterNetworksVmClusterNetworkDrScanResult']:
        """
        The SCAN details for DR network
        """
        return pulumi.get(self, "dr_scans")

    @property
    @pulumi.getter(name="exadataInfrastructureId")
    def exadata_infrastructure_id(self) -> str:
        """
        The Exadata infrastructure [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "exadata_infrastructure_id")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VM cluster network.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def ntps(self) -> Sequence[str]:
        """
        The list of NTP server IP addresses. Maximum of 3 allowed.
        """
        return pulumi.get(self, "ntps")

    @property
    @pulumi.getter
    def scans(self) -> Sequence['outputs.GetVmClusterNetworksVmClusterNetworkScanResult']:
        """
        The SCAN details.
        """
        return pulumi.get(self, "scans")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time when the VM cluster network was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="validateVmClusterNetwork")
    def validate_vm_cluster_network(self) -> bool:
        return pulumi.get(self, "validate_vm_cluster_network")

    @property
    @pulumi.getter(name="vmClusterId")
    def vm_cluster_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the associated VM Cluster.
        """
        return pulumi.get(self, "vm_cluster_id")

    @property
    @pulumi.getter(name="vmNetworks")
    def vm_networks(self) -> Sequence['outputs.GetVmClusterNetworksVmClusterNetworkVmNetworkResult']:
        """
        Details of the client and backup networks.
        """
        return pulumi.get(self, "vm_networks")


@pulumi.output_type
class GetVmClusterNetworksVmClusterNetworkDrScanResult(dict):
    def __init__(__self__, *,
                 hostname: str,
                 ips: Sequence[str],
                 scan_listener_port_tcp: int):
        """
        :param str hostname: The node host name.
        :param Sequence[str] ips: The list of SCAN IP addresses. Three addresses should be provided.
        :param int scan_listener_port_tcp: The SCAN TCPIP port. Default is 1521.
        """
        GetVmClusterNetworksVmClusterNetworkDrScanResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hostname=hostname,
            ips=ips,
            scan_listener_port_tcp=scan_listener_port_tcp,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hostname: str,
             ips: Sequence[str],
             scan_listener_port_tcp: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("hostname", hostname)
        _setter("ips", ips)
        _setter("scan_listener_port_tcp", scan_listener_port_tcp)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The node host name.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def ips(self) -> Sequence[str]:
        """
        The list of SCAN IP addresses. Three addresses should be provided.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="scanListenerPortTcp")
    def scan_listener_port_tcp(self) -> int:
        """
        The SCAN TCPIP port. Default is 1521.
        """
        return pulumi.get(self, "scan_listener_port_tcp")


@pulumi.output_type
class GetVmClusterNetworksVmClusterNetworkScanResult(dict):
    def __init__(__self__, *,
                 hostname: str,
                 ips: Sequence[str],
                 port: int,
                 scan_listener_port_tcp: int,
                 scan_listener_port_tcp_ssl: int):
        """
        :param str hostname: The node host name.
        :param Sequence[str] ips: The list of SCAN IP addresses. Three addresses should be provided.
        :param int port: **Deprecated.** This field is deprecated. You may use 'scanListenerPortTcp' to specify the port. The SCAN TCPIP port. Default is 1521.
        :param int scan_listener_port_tcp: The SCAN TCPIP port. Default is 1521.
        :param int scan_listener_port_tcp_ssl: The SCAN TCPIP SSL port. Default is 2484.
        """
        GetVmClusterNetworksVmClusterNetworkScanResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hostname=hostname,
            ips=ips,
            port=port,
            scan_listener_port_tcp=scan_listener_port_tcp,
            scan_listener_port_tcp_ssl=scan_listener_port_tcp_ssl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hostname: str,
             ips: Sequence[str],
             port: int,
             scan_listener_port_tcp: int,
             scan_listener_port_tcp_ssl: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("hostname", hostname)
        _setter("ips", ips)
        _setter("port", port)
        _setter("scan_listener_port_tcp", scan_listener_port_tcp)
        _setter("scan_listener_port_tcp_ssl", scan_listener_port_tcp_ssl)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The node host name.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def ips(self) -> Sequence[str]:
        """
        The list of SCAN IP addresses. Three addresses should be provided.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        **Deprecated.** This field is deprecated. You may use 'scanListenerPortTcp' to specify the port. The SCAN TCPIP port. Default is 1521.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="scanListenerPortTcp")
    def scan_listener_port_tcp(self) -> int:
        """
        The SCAN TCPIP port. Default is 1521.
        """
        return pulumi.get(self, "scan_listener_port_tcp")

    @property
    @pulumi.getter(name="scanListenerPortTcpSsl")
    def scan_listener_port_tcp_ssl(self) -> int:
        """
        The SCAN TCPIP SSL port. Default is 2484.
        """
        return pulumi.get(self, "scan_listener_port_tcp_ssl")


@pulumi.output_type
class GetVmClusterNetworksVmClusterNetworkVmNetworkResult(dict):
    def __init__(__self__, *,
                 domain_name: str,
                 gateway: str,
                 netmask: str,
                 network_type: str,
                 nodes: Sequence['outputs.GetVmClusterNetworksVmClusterNetworkVmNetworkNodeResult'],
                 vlan_id: str):
        """
        :param str domain_name: The network domain name.
        :param str gateway: The network gateway.
        :param str netmask: The network netmask.
        :param str network_type: The network type.
        :param Sequence['GetVmClusterNetworksVmClusterNetworkVmNetworkNodeArgs'] nodes: The list of node details.
        :param str vlan_id: The network VLAN ID.
        """
        GetVmClusterNetworksVmClusterNetworkVmNetworkResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain_name=domain_name,
            gateway=gateway,
            netmask=netmask,
            network_type=network_type,
            nodes=nodes,
            vlan_id=vlan_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain_name: str,
             gateway: str,
             netmask: str,
             network_type: str,
             nodes: Sequence['outputs.GetVmClusterNetworksVmClusterNetworkVmNetworkNodeResult'],
             vlan_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("domain_name", domain_name)
        _setter("gateway", gateway)
        _setter("netmask", netmask)
        _setter("network_type", network_type)
        _setter("nodes", nodes)
        _setter("vlan_id", vlan_id)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> str:
        """
        The network domain name.
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        The network gateway.
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter
    def netmask(self) -> str:
        """
        The network netmask.
        """
        return pulumi.get(self, "netmask")

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> str:
        """
        The network type.
        """
        return pulumi.get(self, "network_type")

    @property
    @pulumi.getter
    def nodes(self) -> Sequence['outputs.GetVmClusterNetworksVmClusterNetworkVmNetworkNodeResult']:
        """
        The list of node details.
        """
        return pulumi.get(self, "nodes")

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> str:
        """
        The network VLAN ID.
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class GetVmClusterNetworksVmClusterNetworkVmNetworkNodeResult(dict):
    def __init__(__self__, *,
                 db_server_id: str,
                 hostname: str,
                 ip: str,
                 state: str,
                 vip: str,
                 vip_hostname: str):
        """
        :param str db_server_id: The Db server associated with the node.
        :param str hostname: The node host name.
        :param str ip: The node IP address.
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        :param str vip: The node virtual IP (VIP) address.
        :param str vip_hostname: The node virtual IP (VIP) host name.
        """
        GetVmClusterNetworksVmClusterNetworkVmNetworkNodeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_server_id=db_server_id,
            hostname=hostname,
            ip=ip,
            state=state,
            vip=vip,
            vip_hostname=vip_hostname,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_server_id: str,
             hostname: str,
             ip: str,
             state: str,
             vip: str,
             vip_hostname: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("db_server_id", db_server_id)
        _setter("hostname", hostname)
        _setter("ip", ip)
        _setter("state", state)
        _setter("vip", vip)
        _setter("vip_hostname", vip_hostname)

    @property
    @pulumi.getter(name="dbServerId")
    def db_server_id(self) -> str:
        """
        The Db server associated with the node.
        """
        return pulumi.get(self, "db_server_id")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The node host name.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        The node IP address.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def vip(self) -> str:
        """
        The node virtual IP (VIP) address.
        """
        return pulumi.get(self, "vip")

    @property
    @pulumi.getter(name="vipHostname")
    def vip_hostname(self) -> str:
        """
        The node virtual IP (VIP) host name.
        """
        return pulumi.get(self, "vip_hostname")


@pulumi.output_type
class GetVmClusterPatchHistoryEntriesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetVmClusterPatchHistoryEntriesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetVmClusterPatchHistoryEntriesPatchHistoryEntryResult(dict):
    def __init__(__self__, *,
                 action: str,
                 id: str,
                 lifecycle_details: str,
                 patch_id: str,
                 state: str,
                 time_ended: str,
                 time_started: str):
        """
        :param str action: The action being performed or was completed.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch history entry.
        :param str lifecycle_details: A descriptive text associated with the lifecycleState. Typically contains additional displayable text.
        :param str patch_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch.
        :param str state: The current state of the action.
        :param str time_ended: The date and time when the patch action completed
        :param str time_started: The date and time when the patch action started.
        """
        GetVmClusterPatchHistoryEntriesPatchHistoryEntryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            id=id,
            lifecycle_details=lifecycle_details,
            patch_id=patch_id,
            state=state,
            time_ended=time_ended,
            time_started=time_started,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: str,
             id: str,
             lifecycle_details: str,
             patch_id: str,
             state: str,
             time_ended: str,
             time_started: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action", action)
        _setter("id", id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("patch_id", patch_id)
        _setter("state", state)
        _setter("time_ended", time_ended)
        _setter("time_started", time_started)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action being performed or was completed.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch history entry.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A descriptive text associated with the lifecycleState. Typically contains additional displayable text.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="patchId")
    def patch_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch.
        """
        return pulumi.get(self, "patch_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the action.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeEnded")
    def time_ended(self) -> str:
        """
        The date and time when the patch action completed
        """
        return pulumi.get(self, "time_ended")

    @property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> str:
        """
        The date and time when the patch action started.
        """
        return pulumi.get(self, "time_started")


@pulumi.output_type
class GetVmClusterPatchesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetVmClusterPatchesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetVmClusterPatchesPatchResult(dict):
    def __init__(__self__, *,
                 available_actions: Sequence[str],
                 description: str,
                 id: str,
                 last_action: str,
                 lifecycle_details: str,
                 state: str,
                 time_released: str,
                 version: str):
        """
        :param Sequence[str] available_actions: Actions that can possibly be performed using this patch.
        :param str description: The text describing this patch package.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch.
        :param str last_action: Action that is currently being performed or was completed last.
        :param str lifecycle_details: A descriptive text associated with the lifecycleState. Typically can contain additional displayable text.
        :param str state: The current state of the patch as a result of lastAction.
        :param str time_released: The date and time that the patch was released.
        :param str version: The version of this patch package.
        """
        GetVmClusterPatchesPatchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            available_actions=available_actions,
            description=description,
            id=id,
            last_action=last_action,
            lifecycle_details=lifecycle_details,
            state=state,
            time_released=time_released,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             available_actions: Sequence[str],
             description: str,
             id: str,
             last_action: str,
             lifecycle_details: str,
             state: str,
             time_released: str,
             version: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("available_actions", available_actions)
        _setter("description", description)
        _setter("id", id)
        _setter("last_action", last_action)
        _setter("lifecycle_details", lifecycle_details)
        _setter("state", state)
        _setter("time_released", time_released)
        _setter("version", version)

    @property
    @pulumi.getter(name="availableActions")
    def available_actions(self) -> Sequence[str]:
        """
        Actions that can possibly be performed using this patch.
        """
        return pulumi.get(self, "available_actions")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The text describing this patch package.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the patch.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastAction")
    def last_action(self) -> str:
        """
        Action that is currently being performed or was completed last.
        """
        return pulumi.get(self, "last_action")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        A descriptive text associated with the lifecycleState. Typically can contain additional displayable text.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the patch as a result of lastAction.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeReleased")
    def time_released(self) -> str:
        """
        The date and time that the patch was released.
        """
        return pulumi.get(self, "time_released")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The version of this patch package.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetVmClusterRecommendedNetworkDrScanResult(dict):
    def __init__(__self__, *,
                 hostname: str,
                 ips: Sequence[str],
                 scan_listener_port_tcp: int):
        """
        :param str hostname: The node host name.
        :param Sequence[str] ips: The list of SCAN IP addresses. Three addresses should be provided.
        :param int scan_listener_port_tcp: The SCAN TCPIP port. Default is 1521.
        """
        GetVmClusterRecommendedNetworkDrScanResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hostname=hostname,
            ips=ips,
            scan_listener_port_tcp=scan_listener_port_tcp,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hostname: str,
             ips: Sequence[str],
             scan_listener_port_tcp: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("hostname", hostname)
        _setter("ips", ips)
        _setter("scan_listener_port_tcp", scan_listener_port_tcp)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The node host name.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def ips(self) -> Sequence[str]:
        """
        The list of SCAN IP addresses. Three addresses should be provided.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="scanListenerPortTcp")
    def scan_listener_port_tcp(self) -> int:
        """
        The SCAN TCPIP port. Default is 1521.
        """
        return pulumi.get(self, "scan_listener_port_tcp")


@pulumi.output_type
class GetVmClusterRecommendedNetworkNetworkResult(dict):
    def __init__(__self__, *,
                 cidr: str,
                 domain: str,
                 gateway: str,
                 netmask: str,
                 network_type: str,
                 prefix: str,
                 vlan_id: str):
        """
        :param str cidr: The cidr for the network.
        :param str domain: The network domain name.
        :param str gateway: The network gateway.
        :param str netmask: The network netmask.
        :param str network_type: The network type.
        :param str prefix: The network domain name.
        :param str vlan_id: The network VLAN ID.
        """
        GetVmClusterRecommendedNetworkNetworkResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr=cidr,
            domain=domain,
            gateway=gateway,
            netmask=netmask,
            network_type=network_type,
            prefix=prefix,
            vlan_id=vlan_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr: str,
             domain: str,
             gateway: str,
             netmask: str,
             network_type: str,
             prefix: str,
             vlan_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cidr", cidr)
        _setter("domain", domain)
        _setter("gateway", gateway)
        _setter("netmask", netmask)
        _setter("network_type", network_type)
        _setter("prefix", prefix)
        _setter("vlan_id", vlan_id)

    @property
    @pulumi.getter
    def cidr(self) -> str:
        """
        The cidr for the network.
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The network domain name.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        The network gateway.
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter
    def netmask(self) -> str:
        """
        The network netmask.
        """
        return pulumi.get(self, "netmask")

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> str:
        """
        The network type.
        """
        return pulumi.get(self, "network_type")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        """
        The network domain name.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> str:
        """
        The network VLAN ID.
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class GetVmClusterRecommendedNetworkScanResult(dict):
    def __init__(__self__, *,
                 hostname: str,
                 ips: Sequence[str],
                 port: int,
                 scan_listener_port_tcp: int,
                 scan_listener_port_tcp_ssl: int):
        """
        :param str hostname: The node host name.
        :param Sequence[str] ips: The list of SCAN IP addresses. Three addresses should be provided.
        :param int port: **Deprecated.** This field is deprecated. You may use 'scanListenerPortTcp' to specify the port. The SCAN TCPIP port. Default is 1521.
        :param int scan_listener_port_tcp: The SCAN TCPIP port. Default is 1521.
        :param int scan_listener_port_tcp_ssl: The SCAN TCPIP SSL port. Default is 2484.
        """
        GetVmClusterRecommendedNetworkScanResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hostname=hostname,
            ips=ips,
            port=port,
            scan_listener_port_tcp=scan_listener_port_tcp,
            scan_listener_port_tcp_ssl=scan_listener_port_tcp_ssl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hostname: str,
             ips: Sequence[str],
             port: int,
             scan_listener_port_tcp: int,
             scan_listener_port_tcp_ssl: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("hostname", hostname)
        _setter("ips", ips)
        _setter("port", port)
        _setter("scan_listener_port_tcp", scan_listener_port_tcp)
        _setter("scan_listener_port_tcp_ssl", scan_listener_port_tcp_ssl)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The node host name.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def ips(self) -> Sequence[str]:
        """
        The list of SCAN IP addresses. Three addresses should be provided.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        **Deprecated.** This field is deprecated. You may use 'scanListenerPortTcp' to specify the port. The SCAN TCPIP port. Default is 1521.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="scanListenerPortTcp")
    def scan_listener_port_tcp(self) -> int:
        """
        The SCAN TCPIP port. Default is 1521.
        """
        return pulumi.get(self, "scan_listener_port_tcp")

    @property
    @pulumi.getter(name="scanListenerPortTcpSsl")
    def scan_listener_port_tcp_ssl(self) -> int:
        """
        The SCAN TCPIP SSL port. Default is 2484.
        """
        return pulumi.get(self, "scan_listener_port_tcp_ssl")


@pulumi.output_type
class GetVmClusterRecommendedNetworkVmNetworkResult(dict):
    def __init__(__self__, *,
                 domain_name: str,
                 gateway: str,
                 netmask: str,
                 network_type: str,
                 nodes: Sequence['outputs.GetVmClusterRecommendedNetworkVmNetworkNodeResult'],
                 vlan_id: str):
        """
        :param str domain_name: The network domain name.
        :param str gateway: The network gateway.
        :param str netmask: The network netmask.
        :param str network_type: The network type.
        :param Sequence['GetVmClusterRecommendedNetworkVmNetworkNodeArgs'] nodes: The list of node details.
        :param str vlan_id: The network VLAN ID.
        """
        GetVmClusterRecommendedNetworkVmNetworkResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain_name=domain_name,
            gateway=gateway,
            netmask=netmask,
            network_type=network_type,
            nodes=nodes,
            vlan_id=vlan_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain_name: str,
             gateway: str,
             netmask: str,
             network_type: str,
             nodes: Sequence['outputs.GetVmClusterRecommendedNetworkVmNetworkNodeResult'],
             vlan_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("domain_name", domain_name)
        _setter("gateway", gateway)
        _setter("netmask", netmask)
        _setter("network_type", network_type)
        _setter("nodes", nodes)
        _setter("vlan_id", vlan_id)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> str:
        """
        The network domain name.
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        The network gateway.
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter
    def netmask(self) -> str:
        """
        The network netmask.
        """
        return pulumi.get(self, "netmask")

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> str:
        """
        The network type.
        """
        return pulumi.get(self, "network_type")

    @property
    @pulumi.getter
    def nodes(self) -> Sequence['outputs.GetVmClusterRecommendedNetworkVmNetworkNodeResult']:
        """
        The list of node details.
        """
        return pulumi.get(self, "nodes")

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> str:
        """
        The network VLAN ID.
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class GetVmClusterRecommendedNetworkVmNetworkNodeResult(dict):
    def __init__(__self__, *,
                 db_server_id: str,
                 hostname: str,
                 ip: str,
                 state: str,
                 vip: str,
                 vip_hostname: str):
        """
        :param str db_server_id: The Db server associated with the node.
        :param str hostname: The node host name.
        :param str ip: The node IP address.
        :param str state: The current state of the VM cluster network nodes. CREATING - The resource is being created REQUIRES_VALIDATION - The resource is created and may not be usable until it is validated. VALIDATING - The resource is being validated and not available to use. VALIDATED - The resource is validated and is available for consumption by VM cluster. VALIDATION_FAILED - The resource validation has failed and might require user input to be corrected. UPDATING - The resource is being updated and not available to use. ALLOCATED - The resource is currently being used by VM cluster. TERMINATING - The resource is being deleted and not available to use. TERMINATED - The resource is deleted and unavailable. FAILED - The resource is in a failed state due to validation or other errors.
        :param str vip: The node virtual IP (VIP) address.
        :param str vip_hostname: The node virtual IP (VIP) host name.
        """
        GetVmClusterRecommendedNetworkVmNetworkNodeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_server_id=db_server_id,
            hostname=hostname,
            ip=ip,
            state=state,
            vip=vip,
            vip_hostname=vip_hostname,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_server_id: str,
             hostname: str,
             ip: str,
             state: str,
             vip: str,
             vip_hostname: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("db_server_id", db_server_id)
        _setter("hostname", hostname)
        _setter("ip", ip)
        _setter("state", state)
        _setter("vip", vip)
        _setter("vip_hostname", vip_hostname)

    @property
    @pulumi.getter(name="dbServerId")
    def db_server_id(self) -> str:
        """
        The Db server associated with the node.
        """
        return pulumi.get(self, "db_server_id")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        The node host name.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        The node IP address.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The current state of the VM cluster network nodes. CREATING - The resource is being created REQUIRES_VALIDATION - The resource is created and may not be usable until it is validated. VALIDATING - The resource is being validated and not available to use. VALIDATED - The resource is validated and is available for consumption by VM cluster. VALIDATION_FAILED - The resource validation has failed and might require user input to be corrected. UPDATING - The resource is being updated and not available to use. ALLOCATED - The resource is currently being used by VM cluster. TERMINATING - The resource is being deleted and not available to use. TERMINATED - The resource is deleted and unavailable. FAILED - The resource is in a failed state due to validation or other errors.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def vip(self) -> str:
        """
        The node virtual IP (VIP) address.
        """
        return pulumi.get(self, "vip")

    @property
    @pulumi.getter(name="vipHostname")
    def vip_hostname(self) -> str:
        """
        The node virtual IP (VIP) host name.
        """
        return pulumi.get(self, "vip_hostname")


@pulumi.output_type
class GetVmClusterUpdateHistoryEntriesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetVmClusterUpdateHistoryEntriesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetVmClusterUpdateHistoryEntriesVmClusterUpdateHistoryEntryResult(dict):
    def __init__(__self__, *,
                 id: str,
                 lifecycle_details: str,
                 state: str,
                 time_completed: str,
                 time_started: str,
                 update_action: str,
                 update_id: str,
                 update_type: str):
        """
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance update history entry.
        :param str lifecycle_details: Descriptive text providing additional details about the lifecycle state.
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        :param str time_completed: The date and time when the maintenance update action completed.
        :param str time_started: The date and time when the maintenance update action started.
        :param str update_action: The update action performed using this maintenance update.
        :param str update_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance update.
        :param str update_type: A filter to return only resources that match the given update type exactly.
        """
        GetVmClusterUpdateHistoryEntriesVmClusterUpdateHistoryEntryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            lifecycle_details=lifecycle_details,
            state=state,
            time_completed=time_completed,
            time_started=time_started,
            update_action=update_action,
            update_id=update_id,
            update_type=update_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             lifecycle_details: str,
             state: str,
             time_completed: str,
             time_started: str,
             update_action: str,
             update_id: str,
             update_type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("lifecycle_details", lifecycle_details)
        _setter("state", state)
        _setter("time_completed", time_completed)
        _setter("time_started", time_started)
        _setter("update_action", update_action)
        _setter("update_id", update_id)
        _setter("update_type", update_type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance update history entry.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Descriptive text providing additional details about the lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeCompleted")
    def time_completed(self) -> str:
        """
        The date and time when the maintenance update action completed.
        """
        return pulumi.get(self, "time_completed")

    @property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> str:
        """
        The date and time when the maintenance update action started.
        """
        return pulumi.get(self, "time_started")

    @property
    @pulumi.getter(name="updateAction")
    def update_action(self) -> str:
        """
        The update action performed using this maintenance update.
        """
        return pulumi.get(self, "update_action")

    @property
    @pulumi.getter(name="updateId")
    def update_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance update.
        """
        return pulumi.get(self, "update_id")

    @property
    @pulumi.getter(name="updateType")
    def update_type(self) -> str:
        """
        A filter to return only resources that match the given update type exactly.
        """
        return pulumi.get(self, "update_type")


@pulumi.output_type
class GetVmClusterUpdatesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetVmClusterUpdatesFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetVmClusterUpdatesVmClusterUpdateResult(dict):
    def __init__(__self__, *,
                 available_actions: Sequence[str],
                 description: str,
                 id: str,
                 last_action: str,
                 lifecycle_details: str,
                 state: str,
                 time_released: str,
                 update_type: str,
                 version: str):
        """
        :param Sequence[str] available_actions: The possible actions that can be performed using this maintenance update.
        :param str description: Details of the maintenance update package.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance update.
        :param str last_action: The update action performed most recently using this maintenance update.
        :param str lifecycle_details: Descriptive text providing additional details about the lifecycle state.
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        :param str time_released: The date and time the maintenance update was released.
        :param str update_type: A filter to return only resources that match the given update type exactly.
        :param str version: The version of the maintenance update package.
        """
        GetVmClusterUpdatesVmClusterUpdateResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            available_actions=available_actions,
            description=description,
            id=id,
            last_action=last_action,
            lifecycle_details=lifecycle_details,
            state=state,
            time_released=time_released,
            update_type=update_type,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             available_actions: Sequence[str],
             description: str,
             id: str,
             last_action: str,
             lifecycle_details: str,
             state: str,
             time_released: str,
             update_type: str,
             version: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("available_actions", available_actions)
        _setter("description", description)
        _setter("id", id)
        _setter("last_action", last_action)
        _setter("lifecycle_details", lifecycle_details)
        _setter("state", state)
        _setter("time_released", time_released)
        _setter("update_type", update_type)
        _setter("version", version)

    @property
    @pulumi.getter(name="availableActions")
    def available_actions(self) -> Sequence[str]:
        """
        The possible actions that can be performed using this maintenance update.
        """
        return pulumi.get(self, "available_actions")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Details of the maintenance update package.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the maintenance update.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastAction")
    def last_action(self) -> str:
        """
        The update action performed most recently using this maintenance update.
        """
        return pulumi.get(self, "last_action")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Descriptive text providing additional details about the lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeReleased")
    def time_released(self) -> str:
        """
        The date and time the maintenance update was released.
        """
        return pulumi.get(self, "time_released")

    @property
    @pulumi.getter(name="updateType")
    def update_type(self) -> str:
        """
        A filter to return only resources that match the given update type exactly.
        """
        return pulumi.get(self, "update_type")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The version of the maintenance update package.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetVmClustersFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        GetVmClustersFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
            regex=regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             regex: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)
        if regex is not None:
            _setter("regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetVmClustersVmClusterResult(dict):
    def __init__(__self__, *,
                 availability_domain: str,
                 compartment_id: str,
                 cpu_core_count: int,
                 cpus_enabled: int,
                 data_collection_options: Sequence['outputs.GetVmClustersVmClusterDataCollectionOptionResult'],
                 data_storage_size_in_gb: float,
                 data_storage_size_in_tbs: float,
                 db_node_storage_size_in_gbs: int,
                 db_servers: Sequence[str],
                 defined_tags: Mapping[str, Any],
                 display_name: str,
                 exadata_infrastructure_id: str,
                 freeform_tags: Mapping[str, Any],
                 gi_version: str,
                 id: str,
                 is_local_backup_enabled: bool,
                 is_sparse_diskgroup_enabled: bool,
                 last_patch_history_entry_id: str,
                 license_model: str,
                 lifecycle_details: str,
                 memory_size_in_gbs: int,
                 ocpu_count: float,
                 ocpus_enabled: float,
                 shape: str,
                 ssh_public_keys: Sequence[str],
                 state: str,
                 system_version: str,
                 time_created: str,
                 time_zone: str,
                 vm_cluster_network_id: str):
        """
        :param str availability_domain: The name of the availability domain that the VM cluster is located in.
        :param str compartment_id: The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param int cpus_enabled: The number of enabled CPU cores.
        :param Sequence['GetVmClustersVmClusterDataCollectionOptionArgs'] data_collection_options: Indicates user preferences for the various diagnostic collection options for the VM cluster/Cloud VM cluster/VMBM DBCS.
        :param float data_storage_size_in_gb: Size of the DATA disk group in GBs.
        :param float data_storage_size_in_tbs: Size, in terabytes, of the DATA disk group.
        :param int db_node_storage_size_in_gbs: The local node storage allocated in GBs.
        :param Sequence[str] db_servers: The list of Db server.
        :param Mapping[str, Any] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param str display_name: A filter to return only resources that match the entire display name given. The match is not case sensitive.
        :param str exadata_infrastructure_id: If provided, filters the results for the given Exadata Infrastructure.
        :param Mapping[str, Any] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param str gi_version: The Oracle Grid Infrastructure software version for the VM cluster.
        :param str id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VM cluster.
        :param bool is_local_backup_enabled: If true, database backup on local Exadata storage is configured for the VM cluster. If false, database backup on local Exadata storage is not available in the VM cluster.
        :param bool is_sparse_diskgroup_enabled: If true, sparse disk group is configured for the VM cluster. If false, sparse disk group is not created.
        :param str last_patch_history_entry_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last patch history. This value is updated as soon as a patch operation starts.
        :param str license_model: The Oracle license model that applies to the VM cluster. The default is LICENSE_INCLUDED.
        :param str lifecycle_details: Additional information about the current lifecycle state.
        :param int memory_size_in_gbs: The memory allocated in GBs.
        :param str shape: The shape of the Exadata infrastructure. The shape determines the amount of CPU, storage, and memory resources allocated to the instance.
        :param Sequence[str] ssh_public_keys: The public key portion of one or more key pairs used for SSH access to the VM cluster.
        :param str state: A filter to return only resources that match the given lifecycle state exactly.
        :param str system_version: Operating system version of the image.
        :param str time_created: The date and time that the VM cluster was created.
        :param str time_zone: The time zone of the Exadata infrastructure. For details, see [Exadata Infrastructure Time Zones](https://docs.cloud.oracle.com/iaas/Content/Database/References/timezones.htm).
        :param str vm_cluster_network_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VM cluster network.
        """
        GetVmClustersVmClusterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_domain=availability_domain,
            compartment_id=compartment_id,
            cpu_core_count=cpu_core_count,
            cpus_enabled=cpus_enabled,
            data_collection_options=data_collection_options,
            data_storage_size_in_gb=data_storage_size_in_gb,
            data_storage_size_in_tbs=data_storage_size_in_tbs,
            db_node_storage_size_in_gbs=db_node_storage_size_in_gbs,
            db_servers=db_servers,
            defined_tags=defined_tags,
            display_name=display_name,
            exadata_infrastructure_id=exadata_infrastructure_id,
            freeform_tags=freeform_tags,
            gi_version=gi_version,
            id=id,
            is_local_backup_enabled=is_local_backup_enabled,
            is_sparse_diskgroup_enabled=is_sparse_diskgroup_enabled,
            last_patch_history_entry_id=last_patch_history_entry_id,
            license_model=license_model,
            lifecycle_details=lifecycle_details,
            memory_size_in_gbs=memory_size_in_gbs,
            ocpu_count=ocpu_count,
            ocpus_enabled=ocpus_enabled,
            shape=shape,
            ssh_public_keys=ssh_public_keys,
            state=state,
            system_version=system_version,
            time_created=time_created,
            time_zone=time_zone,
            vm_cluster_network_id=vm_cluster_network_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_domain: str,
             compartment_id: str,
             cpu_core_count: int,
             cpus_enabled: int,
             data_collection_options: Sequence['outputs.GetVmClustersVmClusterDataCollectionOptionResult'],
             data_storage_size_in_gb: float,
             data_storage_size_in_tbs: float,
             db_node_storage_size_in_gbs: int,
             db_servers: Sequence[str],
             defined_tags: Mapping[str, Any],
             display_name: str,
             exadata_infrastructure_id: str,
             freeform_tags: Mapping[str, Any],
             gi_version: str,
             id: str,
             is_local_backup_enabled: bool,
             is_sparse_diskgroup_enabled: bool,
             last_patch_history_entry_id: str,
             license_model: str,
             lifecycle_details: str,
             memory_size_in_gbs: int,
             ocpu_count: float,
             ocpus_enabled: float,
             shape: str,
             ssh_public_keys: Sequence[str],
             state: str,
             system_version: str,
             time_created: str,
             time_zone: str,
             vm_cluster_network_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("availability_domain", availability_domain)
        _setter("compartment_id", compartment_id)
        _setter("cpu_core_count", cpu_core_count)
        _setter("cpus_enabled", cpus_enabled)
        _setter("data_collection_options", data_collection_options)
        _setter("data_storage_size_in_gb", data_storage_size_in_gb)
        _setter("data_storage_size_in_tbs", data_storage_size_in_tbs)
        _setter("db_node_storage_size_in_gbs", db_node_storage_size_in_gbs)
        _setter("db_servers", db_servers)
        _setter("defined_tags", defined_tags)
        _setter("display_name", display_name)
        _setter("exadata_infrastructure_id", exadata_infrastructure_id)
        _setter("freeform_tags", freeform_tags)
        _setter("gi_version", gi_version)
        _setter("id", id)
        _setter("is_local_backup_enabled", is_local_backup_enabled)
        _setter("is_sparse_diskgroup_enabled", is_sparse_diskgroup_enabled)
        _setter("last_patch_history_entry_id", last_patch_history_entry_id)
        _setter("license_model", license_model)
        _setter("lifecycle_details", lifecycle_details)
        _setter("memory_size_in_gbs", memory_size_in_gbs)
        _setter("ocpu_count", ocpu_count)
        _setter("ocpus_enabled", ocpus_enabled)
        _setter("shape", shape)
        _setter("ssh_public_keys", ssh_public_keys)
        _setter("state", state)
        _setter("system_version", system_version)
        _setter("time_created", time_created)
        _setter("time_zone", time_zone)
        _setter("vm_cluster_network_id", vm_cluster_network_id)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> str:
        """
        The name of the availability domain that the VM cluster is located in.
        """
        return pulumi.get(self, "availability_domain")

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> str:
        """
        The compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "compartment_id")

    @property
    @pulumi.getter(name="cpuCoreCount")
    def cpu_core_count(self) -> int:
        return pulumi.get(self, "cpu_core_count")

    @property
    @pulumi.getter(name="cpusEnabled")
    def cpus_enabled(self) -> int:
        """
        The number of enabled CPU cores.
        """
        return pulumi.get(self, "cpus_enabled")

    @property
    @pulumi.getter(name="dataCollectionOptions")
    def data_collection_options(self) -> Sequence['outputs.GetVmClustersVmClusterDataCollectionOptionResult']:
        """
        Indicates user preferences for the various diagnostic collection options for the VM cluster/Cloud VM cluster/VMBM DBCS.
        """
        return pulumi.get(self, "data_collection_options")

    @property
    @pulumi.getter(name="dataStorageSizeInGb")
    def data_storage_size_in_gb(self) -> float:
        """
        Size of the DATA disk group in GBs.
        """
        return pulumi.get(self, "data_storage_size_in_gb")

    @property
    @pulumi.getter(name="dataStorageSizeInTbs")
    def data_storage_size_in_tbs(self) -> float:
        """
        Size, in terabytes, of the DATA disk group.
        """
        return pulumi.get(self, "data_storage_size_in_tbs")

    @property
    @pulumi.getter(name="dbNodeStorageSizeInGbs")
    def db_node_storage_size_in_gbs(self) -> int:
        """
        The local node storage allocated in GBs.
        """
        return pulumi.get(self, "db_node_storage_size_in_gbs")

    @property
    @pulumi.getter(name="dbServers")
    def db_servers(self) -> Sequence[str]:
        """
        The list of Db server.
        """
        return pulumi.get(self, "db_servers")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Mapping[str, Any]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        A filter to return only resources that match the entire display name given. The match is not case sensitive.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="exadataInfrastructureId")
    def exadata_infrastructure_id(self) -> str:
        """
        If provided, filters the results for the given Exadata Infrastructure.
        """
        return pulumi.get(self, "exadata_infrastructure_id")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Mapping[str, Any]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter(name="giVersion")
    def gi_version(self) -> str:
        """
        The Oracle Grid Infrastructure software version for the VM cluster.
        """
        return pulumi.get(self, "gi_version")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VM cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isLocalBackupEnabled")
    def is_local_backup_enabled(self) -> bool:
        """
        If true, database backup on local Exadata storage is configured for the VM cluster. If false, database backup on local Exadata storage is not available in the VM cluster.
        """
        return pulumi.get(self, "is_local_backup_enabled")

    @property
    @pulumi.getter(name="isSparseDiskgroupEnabled")
    def is_sparse_diskgroup_enabled(self) -> bool:
        """
        If true, sparse disk group is configured for the VM cluster. If false, sparse disk group is not created.
        """
        return pulumi.get(self, "is_sparse_diskgroup_enabled")

    @property
    @pulumi.getter(name="lastPatchHistoryEntryId")
    def last_patch_history_entry_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last patch history. This value is updated as soon as a patch operation starts.
        """
        return pulumi.get(self, "last_patch_history_entry_id")

    @property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> str:
        """
        The Oracle license model that applies to the VM cluster. The default is LICENSE_INCLUDED.
        """
        return pulumi.get(self, "license_model")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> str:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter(name="memorySizeInGbs")
    def memory_size_in_gbs(self) -> int:
        """
        The memory allocated in GBs.
        """
        return pulumi.get(self, "memory_size_in_gbs")

    @property
    @pulumi.getter(name="ocpuCount")
    def ocpu_count(self) -> float:
        return pulumi.get(self, "ocpu_count")

    @property
    @pulumi.getter(name="ocpusEnabled")
    def ocpus_enabled(self) -> float:
        return pulumi.get(self, "ocpus_enabled")

    @property
    @pulumi.getter
    def shape(self) -> str:
        """
        The shape of the Exadata infrastructure. The shape determines the amount of CPU, storage, and memory resources allocated to the instance.
        """
        return pulumi.get(self, "shape")

    @property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Sequence[str]:
        """
        The public key portion of one or more key pairs used for SSH access to the VM cluster.
        """
        return pulumi.get(self, "ssh_public_keys")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        A filter to return only resources that match the given lifecycle state exactly.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="systemVersion")
    def system_version(self) -> str:
        """
        Operating system version of the image.
        """
        return pulumi.get(self, "system_version")

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> str:
        """
        The date and time that the VM cluster was created.
        """
        return pulumi.get(self, "time_created")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        """
        The time zone of the Exadata infrastructure. For details, see [Exadata Infrastructure Time Zones](https://docs.cloud.oracle.com/iaas/Content/Database/References/timezones.htm).
        """
        return pulumi.get(self, "time_zone")

    @property
    @pulumi.getter(name="vmClusterNetworkId")
    def vm_cluster_network_id(self) -> str:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VM cluster network.
        """
        return pulumi.get(self, "vm_cluster_network_id")


@pulumi.output_type
class GetVmClustersVmClusterDataCollectionOptionResult(dict):
    def __init__(__self__, *,
                 is_diagnostics_events_enabled: bool,
                 is_health_monitoring_enabled: bool,
                 is_incident_logs_enabled: bool):
        """
        :param bool is_diagnostics_events_enabled: Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        :param bool is_health_monitoring_enabled: Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        :param bool is_incident_logs_enabled: Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        GetVmClustersVmClusterDataCollectionOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_diagnostics_events_enabled=is_diagnostics_events_enabled,
            is_health_monitoring_enabled=is_health_monitoring_enabled,
            is_incident_logs_enabled=is_incident_logs_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_diagnostics_events_enabled: bool,
             is_health_monitoring_enabled: bool,
             is_incident_logs_enabled: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("is_diagnostics_events_enabled", is_diagnostics_events_enabled)
        _setter("is_health_monitoring_enabled", is_health_monitoring_enabled)
        _setter("is_incident_logs_enabled", is_incident_logs_enabled)

    @property
    @pulumi.getter(name="isDiagnosticsEventsEnabled")
    def is_diagnostics_events_enabled(self) -> bool:
        """
        Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS. Enabling diagnostic collection allows you to receive Events service notifications for guest VM issues. Diagnostic collection also allows Oracle to provide enhanced service and proactive support for your Exadata system. You can enable diagnostic collection during VM cluster/Cloud VM cluster provisioning. You can also disable or enable it at any time using the `UpdateVmCluster` or `updateCloudVmCluster` API.
        """
        return pulumi.get(self, "is_diagnostics_events_enabled")

    @property
    @pulumi.getter(name="isHealthMonitoringEnabled")
    def is_health_monitoring_enabled(self) -> bool:
        """
        Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling health monitoring allows Oracle to collect diagnostic data and share it with its operations and support personnel. You may also receive notifications for some events. Collecting health diagnostics enables Oracle to provide proactive support and enhanced service for your system. Optionally enable health monitoring while provisioning a system. You can also disable or enable health monitoring anytime using the `UpdateVmCluster`, `UpdateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_health_monitoring_enabled")

    @property
    @pulumi.getter(name="isIncidentLogsEnabled")
    def is_incident_logs_enabled(self) -> bool:
        """
        Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS. Enabling incident logs collection allows Oracle to receive Events service notifications for guest VM issues, collect incident logs and traces, and use them to diagnose issues and resolve them. Optionally enable incident logs collection while provisioning a system. You can also disable or enable incident logs collection anytime using the `UpdateVmCluster`, `updateCloudVmCluster` or `updateDbsystem` API.
        """
        return pulumi.get(self, "is_incident_logs_enabled")


